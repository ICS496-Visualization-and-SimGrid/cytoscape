(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sbgnRenderer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

/*!

Cytoscape.js {{VERSION}} (MIT licensed)

Copyright (c) The Cytoscape Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

'use strict';

},{}],2:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( './util' );
var is = _dereq_( './is' );
var Promise = _dereq_( './promise' );

var Animation = function( target, opts, opts2 ){
  if( !(this instanceof Animation) ){
    return new Animation( target, opts, opts2 );
  }

  var _p = this._private = util.extend( {
    duration: 1000
  }, opts, opts2 );

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if( _p.complete && is.fn( _p.complete ) ){
    _p.completes.push( _p.complete );
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend( anifn, {

  instanceString: function(){ return 'animation'; },

  hook: function(){
    var _p = this._private;

    if( !_p.hooked ){
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;
      if( _p.queue ){
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push( this );

      // add to the animation loop pool
      if( is.elementOrCollection( _p.target ) ){
        _p.target.cy().addToAnimationPool( _p.target );
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function(){
    var _p = this._private;

    // autorewind
    if( _p.progress === 1 ){
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function(){
    return this._private.playing;
  },

  apply: function(){
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function(){
    return this._private.applying;
  },

  pause: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function(){
    return this.progress( 0 );
  },

  fastforward: function(){
    return this.progress( 1 );
  },

  time: function( t ){
    var _p = this._private;

    if( t === undefined ){
      return _p.progress * _p.duration;
    } else {
      return this.progress( t / _p.duration );
    }
  },

  progress: function( p ){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( p === undefined ){
      return _p.progress;
    } else {
      if( wasPlaying ){
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if( wasPlaying ){
        this.play();
      }
    }

    return this;
  },

  completed: function(){
    return this._private.progress === 1;
  },

  reverse: function(){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( wasPlaying ){
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function( a, b ){
      var _pa = _p[ a ];

      _p[ a ] = _p[ b ];
      _p[ b ] = _pa;
    };

    swap( 'zoom', 'startZoom' );
    swap( 'pan', 'startPan' );
    swap( 'position', 'startPosition' );

    // swap styles
    for( var i = 0; i < _p.style.length; i++ ){
      var prop = _p.style[ i ];
      var name = prop.name;
      var startStyleProp = _p.startStyle[ name ];

      _p.startStyle[ name ] = prop;
      _p.style[ i ] = startStyleProp;
    }

    if( wasPlaying ){
      this.play();
    }

    return this;
  },

  promise: function( type ){
    var _p = this._private;

    var arr;

    switch( type ){
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise( function( resolve, reject ){
      arr.push( function(){
        resolve();
      } );
    } );
  }

} );

anifn.complete = anifn.completed;

module.exports = Animation;

},{"./is":82,"./promise":85,"./util":99}],3:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  aStar: function( options ){
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function( start, end, cameFromMap, pathAcum ){
      // Base case
      if( start == end ){
        pathAcum.unshift( cy.getElementById( end ) );
        return pathAcum;
      }

      if( end in cameFromMap ){
        // We know which node is before the last one
        var previous = cameFromMap[ end ];
        var previousEdge = cameFromEdge[ end ];

        pathAcum.unshift( cy.getElementById( previousEdge ) );
        pathAcum.unshift( cy.getElementById( end ) );

        return reconstructPath( start,
                     previous,
                     cameFromMap,
                     pathAcum );
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function( openSet, fScore ){
      if( openSet.length === 0 ){
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[ openSet[0] ];
      for( var i = 1; i < openSet.length; i++ ){
        var s = fScore[ openSet[ i ] ];
        if( s < tempScore ){
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if( options != null && options.root != null ){
      var source = is.string( options.root ) ?
        // use it as a selector, e.g. "#rootID
        this.filter( options.root )[0] :
        options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if( options.goal != null ){
      var target = is.string( options.goal ) ?
        // use it as a selector, e.g. "#goalID
        this.filter( options.goal )[0] :
        options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if( options.heuristic != null && is.fn( options.heuristic ) ){
      var heuristic = options.heuristic;
    } else {
      var heuristic = function(){ return 0; }; // use constant if unspecified
    }

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var sid = source.id();
    var tid = target.id();

    var closedSet = [];
    var openSet = [ sid ];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[ sid ] = 0;
    fScore[ sid ] = heuristic( source );

    // Counter
    var steps = 0;

    // Main loop
    while( openSet.length > 0 ){
      var minPos = findMin( openSet, fScore );
      var cMin = cy.getElementById( openSet[ minPos ] );
      var cMinId = cMin.id();
      steps++;

      // If we've found our goal, then we are done
      if( cMinId == tid ){
        var rPath = reconstructPath( sid, tid, cameFrom, [] );

        return {
          found: true,
          distance: gScore[ cMinId ],
          path: eles.spawn( rPath ),
          steps: steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push( cMinId );
      // Remove cMin from boundary nodes
      openSet.splice( minPos, 1 );

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin._private.edges;

      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];

        // edge must be in set of calling eles
        if( !this.hasElementWithId( e.id() ) ){ continue; }

        // cMin must be the source of edge if directed
        if( directed && e.data('source') !== cMinId ){ continue; }

        var wSrc = e.source();
        var wTgt = e.target();

        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id();

        // node must be in set of calling eles
        if( !this.hasElementWithId( wid ) ){ continue; }

        // if node is in closedSet, ignore it
        if( closedSet.indexOf( wid ) != -1 ){
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[ cMinId ] + weightFn( e );

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if( openSet.indexOf( wid ) == -1 ){
          gScore[ wid ] = tempScore;
          fScore[ wid ] = tempScore + heuristic( w );
          openSet.push( wid ); // Add node to openSet
          cameFrom[ wid ] = cMinId;
          cameFromEdge[ wid ] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if( tempScore < gScore[ wid ] ){
          gScore[ wid ] = tempScore;
          fScore[ wid ] = tempScore + heuristic( w );
          cameFrom[ wid ] = cMinId;
        }

      } // End of neighbors update

    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }

}); // elesfn


module.exports = elesfn;

},{"../../is":82}],4:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );
var util = _dereq_( '../../util' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  bellmanFord: function( options ){
    var eles = this;

    options = options || {};

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var source = this.filter( options.root )[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for( var i = 0; i < numNodes; i++ ){
      if( nodes[ i ].id() === source.id() ){
        cost[ i ] = 0;
      } else {
        cost[ i ] = Infinity;
      }
      predecessor[ i ] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for( var i = 1; i < numNodes; i++ ){
      flag = false;
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn( edges[ e ] );

        var temp = cost[ sourceIndex ] + weight;
        if( temp < cost[ targetIndex ] ){
          cost[ targetIndex ] = temp;
          predecessor[ targetIndex ] = sourceIndex;
          predEdge[ targetIndex ] = edges[ e ];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if( !directed ){
          var temp = cost[ targetIndex ] + weight;
          if( temp < cost[ sourceIndex ] ){
            cost[ sourceIndex ] = temp;
            predecessor[ sourceIndex ] = targetIndex;
            predEdge[ sourceIndex ] = edges[ e ];
            flag = true;
          }
        }
      }

      if( !flag ){
        break;
      }
    }

    if( flag ){
      // Check for negative weight cycles
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn( edges[ e ] );

        if( cost[ sourceIndex ] + weight < cost[ targetIndex ] ){
          util.error( 'Graph contains a negative weight cycle for Bellman-Ford' );
          return { pathTo: undefined,
               distanceTo: undefined,
               hasNegativeWeightCycle: true};
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }


    var res = {
      distanceTo: function( to ){
        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[ id2position[ toId ] ];
      },

      pathTo: function( to ){

        var reconstructPathAux = function( predecessor, fromPos, toPos, position2id, acumPath, predEdge ){
          for( ;; ){
            // Add toId to path
            acumPath.push( cy.getElementById( position2id[ toPos ] ) );
            acumPath.push( predEdge[ toPos ] );

            if( fromPos === toPos ){
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[ toPos ];
            if( typeof predPos === 'undefined' ){
              return undefined;
            }

            toPos = predPos;
          }

        };

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res =  reconstructPathAux( predecessor,
                      id2position[ source.id() ],
                      id2position[ toId ],
                      position2id,
                      path,
                      predEdge );

        // Get it in the correct order and return it
        if( res != null ){
          res.reverse();
        }

        return eles.spawn( res );
      },

      hasNegativeWeightCycle: false
    };

    return res;

  } // bellmanFord

}); // elesfn

module.exports = elesfn;

},{"../../is":82,"../../util":99}],5:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );
var Heap = _dereq_( '../../heap' );

var elesfn = ({

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function( options ){
    options = options || {};

    // Weight - optional
    var weighted, weightFn;
    if( is.fn( options.weight ) ){
      weightFn = options.weight;
      weighted = true;
    } else {
      weighted = false;
    }

    // Directed - default false
    var directed = options.directed != null ? options.directed : false;

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function( key, val ){
        _C[ key ] = val;

        if( val > max ){ max = val; }
      },

      get: function( key ){ return _C[ key ]; }
    };

    // A contains the neighborhoods of every node
    for( var i = 0; i < V.length; i++ ){
      var v = V[ i ];
      var vid = v.id();

      if( directed ){
        A[ vid ] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[ vid ] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set( vid, 0 );
    }

    for( var s = 0; s < V.length; s++ ){
      var sid = V[s].id();
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function( a, b ){
        return d[a] - d[b];
      }); // queue

      // init dictionaries
      for( var i = 0; i < V.length; i++ ){
        var vid = V[ i ].id();

        P[ vid ] = [];
        g[ vid ] = 0;
        d[ vid ] = Infinity;
      }

      g[ sid ] = 1; // sigma
      d[ sid ] = 0; // distance to s

      Q.push( sid );

      while( !Q.empty() ){
        var v = Q.pop();

        S.push( v );

        if( weighted ){
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j];
            var vEle = cy.getElementById( v );

            var edge;
            if( vEle.edgesTo( w ).length > 0 ){
              edge = vEle.edgesTo( w )[0];
            } else {
              edge = w.edgesTo( vEle )[0];
            }

            var edgeWeight = weightFn( edge );

            w = w.id();

            if( d[w] > d[v] + edgeWeight ){
              d[w] = d[v] + edgeWeight;

              if( Q.nodes.indexOf( w ) < 0 ){ //if w is not in Q
                Q.push( w );
              } else { // update position if w is in Q
                Q.updateItem( w );
              }

              g[w] = 0;
              P[w] = [];
            }

            if( d[w] == d[v] + edgeWeight ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        } else {
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j].id();

            if( d[w] == Infinity ){
              Q.push( w );

              d[w] = d[v] + 1;
            }

            if( d[w] == d[v] + 1 ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        }
      }

      var e = {};
      for( var i = 0; i < V.length; i++ ){
        e[ V[ i ].id() ] = 0;
      }

      while( S.length > 0 ){
        var w = S.pop();

        for( var j = 0; j < P[w].length; j++ ){
          var v = P[w][j];

          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);

          if( w != V[s].id() ){
            C.set( w, C.get( w ) + e[w] );
          }
        }
      }
    }

    var ret = {
      betweenness: function( node ){
        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node );
      },

      betweennessNormalized: function( node ){
        if ( max == 0 )
          return 0;

        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node ) / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

},{"../../heap":80,"../../is":82}],6:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

var defineSearch = function( params ){
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn( roots, fn, directed ){
    var options;
    if( is.plainObject( roots ) && !is.elementOrCollection( roots ) ){
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !is.fn( fn ) ? fn : directed;
    fn = is.fn( fn ) ? fn : function(){};

    var cy = this._private.cy;
    var v = roots = is.string( roots ) ? this.filter( roots ) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for( var i = 0; i < v.length; i++ ){
      if( v[ i ].isNode() ){
        Q.unshift( v[ i ] );

        if( params.bfs ){
          V[ v[ i ].id() ] = true;

          connectedNodes.push( v[ i ] );
        }

        id2depth[ v[ i ].id() ] = 0;
      }
    }

    while( Q.length !== 0 ){
      var v = params.bfs ? Q.shift() : Q.pop();

      if( params.dfs ){
        if( V[ v.id() ] ){ continue; }

        V[ v.id() ] = true;

        connectedNodes.push( v );
      }

      var depth = id2depth[ v.id() ];
      var prevEdge = connectedBy[ v.id() ];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
      var ret;

      ret = fn( v, prevEdge, prevNode, j++, depth );

      if( ret === true ){
        found = v;
        break;
      }

      if( ret === false ){
        break;
      }

      var vwEdges = v.connectedEdges( directed ? function( ele ){ return ele.data( 'source' ) === v.id(); } : undefined ).intersect( edges );
      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];
        var w = e.connectedNodes( function( n ){ return n.id() !== v.id(); } ).intersect( nodes );

        if( w.length !== 0 && !V[ w.id() ] ){
          w = w[0];

          Q.push( w );

          if( params.bfs ){
            V[ w.id() ] = true;

            connectedNodes.push( w );
          }

          connectedBy[ w.id() ] = e;

          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
        }
      }

    }

    var connectedEles = [];

    for( var i = 0; i < connectedNodes.length; i++ ){
      var node = connectedNodes[ i ];
      var edge = connectedBy[ node.id() ];

      if( edge ){
        connectedEles.push( edge );
      }

      connectedEles.push( node );
    }

    return {
      path: cy.collection( connectedEles, { unique: true } ),
      found: cy.collection( found )
    };
  };
};

// search, spanning trees, etc
var elesfn = ({
  breadthFirstSearch: defineSearch( { bfs: true } ),
  depthFirstSearch: defineSearch( { dfs: true } )
});

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

},{"../../is":82}],7:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

var elesfn = ({

  closenessCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall( { weight: options.weight, directed: options.directed } );

    // Compute closeness for every node and find the maximum closeness
    for( var i = 0; i < nodes.length; i++ ){
      var currCloseness = 0;
      for( var j = 0; j < nodes.length; j++ ){
        if( i != j ){
          var d = fw.distance( nodes[ i ], nodes[ j ] );

          if( harmonic ){
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if( !harmonic ){
        currCloseness = 1 / currCloseness;
      }

      if( maxCloseness < currCloseness ){
        maxCloseness = currCloseness;
      }

      closenesses[ nodes[ i ].id() ] = currCloseness;
    }

    return {
      closeness: function( node ){
        if( maxCloseness == 0 ){ return 0; }

        if( is.string( node ) ){
          // from is a selector string
          var node = (cy.filter( node )[0]).id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[ node ] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function( options ){
    options = options || {};

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var root = this.filter( options.root )[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weight = options.weight;
    } else {
      var weight = function(){return 1;};
    }

    // directed - optional
    if( options.directed != null && is.bool( options.directed ) ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra( {
      root: root,
      weight: weight,
      directed: directed
    } );
    var totalDistance = 0;

    var nodes = this.nodes();
    for( var i = 0; i < nodes.length; i++ ){
      if( nodes[ i ].id() != root.id() ){
        var d = dijkstra.distanceTo( nodes[ i ] );

        if( harmonic ){
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

},{"../../is":82}],8:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );
var util = _dereq_( '../../util' );

var elesfn = ({

  degreeCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if( !directed ){
      var degrees = {};
      var maxDegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );
        if( maxDegree < currDegree.degree )
          maxDegree = currDegree.degree;

        degrees[ node.id() ] = currDegree.degree;
      }

      return {
        degree: function( node ){
          if( maxDegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[ node ] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );

        if( maxIndegree < currDegree.indegree )
          maxIndegree = currDegree.indegree;

        if( maxOutdegree < currDegree.outdegree )
          maxOutdegree = currDegree.outdegree;

        indegrees[ node.id() ] = currDegree.indegree;
        outdegrees[ node.id() ] = currDegree.outdegree;
      }

      return {
        indegree: function( node ){
          if ( maxIndegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[ node ] / maxIndegree;
        },
        outdegree: function( node ){
          if ( maxOutdegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[ node ] / maxOutdegree;
        }

      };
    }

  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function( options ){
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if( options != null && options.root != null ){
      var root = is.string( options.root ) ? this.filter( options.root )[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){
        return 1;
      };
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if( options.alpha != null && is.number( options.alpha ) ){
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }


    if( !directed ){
      var connEdges = root.connectedEdges().intersection( callingEles );
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for( var i = 0; i < connEdges.length; i++ ){
        var edge = connEdges[ i ];
        s += weightFn( edge );
      }

      return {
        degree: Math.pow( k, 1 - alpha ) * Math.pow( s, alpha )
      };
    } else {
      var incoming = root.connectedEdges( 'edge[target = "' + root.id() + '"]' ).intersection( callingEles );
      var outgoing = root.connectedEdges( 'edge[source = "' + root.id() + '"]' ).intersection( callingEles );
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for( var i = 0; i < incoming.length; i++ ){
        var edge = incoming[ i ];
        s_in += weightFn( edge );
      }

      // Now, sum outgoing edge weights
      for( var i = 0; i < outgoing.length; i++ ){
        var edge = outgoing[ i ];
        s_out += weightFn( edge );
      }

      return {
        indegree: Math.pow( k_in, 1 - alpha ) * Math.pow( s_in, alpha ),
        outdegree: Math.pow( k_out, 1 - alpha ) * Math.pow( s_out, alpha )
      };
    }
  } // degreeCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

},{"../../is":82,"../../util":99}],9:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );
var Heap = _dereq_( '../../heap' );

var elesfn = ({

  dijkstra: function( root, weightFn, directed ){
    var options;
    if( is.plainObject( root ) && !is.elementOrCollection( root ) ){
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    var source = is.string( root ) ? this.filter( root )[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter( function( ele ){ return !ele.isLoop(); } );
    var nodes = this.nodes();

    var getDist = function( node ){
      return dist[ node.id() ];
    };

    var setDist = function( node, d ){
      dist[ node.id() ] = d;

      Q.updateItem( node );
    };

    var Q = new Heap( function( a, b ){
      return getDist( a ) - getDist( b );
    } );

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];

      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
      Q.push( node );
    }

    var distBetween = function( u, v ){
      var uvs = ( directed ? u.edgesTo( v ) : u.edgesWith( v ) ).intersect( edges );
      var smallestDistance = Infinity;
      var smallestEdge;

      for( var i = 0; i < uvs.length; i++ ){
        var edge = uvs[ i ];
        var weight = weightFn( edge );

        if( weight < smallestDistance || !smallestEdge ){
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while( Q.size() > 0 ){
      var u = Q.pop();
      var smalletsDist = getDist( u );
      var uid = u.id();

      knownDist[ uid ] = smalletsDist;

      if( smalletsDist === Math.Infinite ){
        break;
      }

      var neighbors = u.neighborhood().intersect( nodes );
      for( var i = 0; i < neighbors.length; i++ ){
        var v = neighbors[ i ];
        var vid = v.id();
        var vDist = distBetween( u, v );

        var alt = smalletsDist + vDist.dist;

        if( alt < getDist( v ) ){
          setDist( v, alt );

          prev[ vid ] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];

        return knownDist[ target.id() ];
      },

      pathTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];
        var S = [];
        var u = target;

        if( target.length > 0 ){
          S.unshift( target );

          while( prev[ u.id() ] ){
            var p = prev[ u.id() ];

            S.unshift( p.edge );
            S.unshift( p.node );

            u = p.node;
          }
        }

        return cy.collection( S );
      }
    };
  }
});

module.exports = elesfn;

},{"../../heap":80,"../../is":82}],10:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  floydWarshall: function( options ){
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for( var i = 0; i < numNodes; i++ ){
      var newRow = new Array( numNodes );
      for( var j = 0; j < numNodes; j++ ){
        if( i == j ){
          newRow[ j ] = 0;
        } else {
          newRow[ j ] = Infinity;
        }
      }
      dist.push( newRow );
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function( next ){
      for( var i = 0; i < numNodes; i++ ){
        var newRow = new Array( numNodes );
        for( var j = 0; j < numNodes; j++ ){
          newRow[ j ] = undefined;
        }
        next.push( newRow );
      }
    };

    initMatrix( next );
    initMatrix( edgeNext );

    // Process edges
    for( var i = 0; i < edges.length ; i++ ){
      var sourceIndex = id2position[ edges[ i ].source().id() ];
      var targetIndex = id2position[ edges[ i ].target().id() ];
      var weight = weightFn( edges[ i ] );

      // Check if already process another edge between same 2 nodes
      if( dist[ sourceIndex ][ targetIndex ] > weight ){
        dist[ sourceIndex ][ targetIndex ] = weight;
        next[ sourceIndex ][ targetIndex ] = targetIndex;
        edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
      }
    }

    // If undirected graph, process 'reversed' edges
    if( !directed ){
      for( var i = 0; i < edges.length ; i++ ){
        var sourceIndex = id2position[ edges[ i ].target().id() ];
        var targetIndex = id2position[ edges[ i ].source().id() ];
        var weight = weightFn( edges[ i ] );

        // Check if already process another edge between same 2 nodes
        if( dist[ sourceIndex ][ targetIndex ] > weight ){
          dist[ sourceIndex ][ targetIndex ] = weight;
          next[ sourceIndex ][ targetIndex ] = targetIndex;
          edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
        }
      }
    }

    // Main loop
    for( var k = 0; k < numNodes; k++ ){
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] ){
            dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];
            next[ i ][ j ] = next[ i ][ k ];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }

    var res = {
      distance: function( from, to ){
        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[ id2position[ fromId ] ][ id2position[ toId ] ];
      },

      path: function( from, to ){
        var reconstructPathAux = function( from, to, next, position2id, edgeNext ){
          if( from === to ){
            return cy.getElementById( position2id[ from ] );
          }
          if( next[ from ][ to ] === undefined ){
            return undefined;
          }

          var path = [ cy.getElementById( position2id[ from ] ) ];
          var prev = from;
          while( from !== to ){
            prev = from;
            from = next[ from ][ to ];

            var edge = edgeNext[ prev ][ from ];
            path.push( edge );

            path.push( cy.getElementById( position2id[ from ] ) );
          }
          return path;
        };

        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux( id2position[ fromId ],
                      id2position[ toId ],
                      next,
                      position2id,
                      edgeNext );

        return cy.collection( pathArr );
      }
    };

    return res;

  } // floydWarshall

}); // elesfn

module.exports = elesfn;

},{"../../is":82}],11:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );

var elesfn = {};

[
  _dereq_( './bfs-dfs' ),
  _dereq_( './dijkstra' ),
  _dereq_( './kruskal' ),
  _dereq_( './a-star' ),
  _dereq_( './floyd-warshall' ),
  _dereq_( './bellman-ford' ),
  _dereq_( './kerger-stein' ),
  _dereq_( './page-rank' ),
  _dereq_( './degree-centrality' ),
  _dereq_( './closeness-centrality' ),
  _dereq_( './betweenness-centrality' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = elesfn;

},{"../../util":99,"./a-star":3,"./bellman-ford":4,"./betweenness-centrality":5,"./bfs-dfs":6,"./closeness-centrality":7,"./degree-centrality":8,"./dijkstra":9,"./floyd-warshall":10,"./kerger-stein":12,"./kruskal":13,"./page-rank":14}],12:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );

var elesfn = ({

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function( options ){
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function( edgeIndex, nodeMap, remainingEdges ){
      var edgeInfo = remainingEdges[ edgeIndex ];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[ sourceIn ];
      var partition2 = nodeMap[ targetIn ];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter( function( edge ){
        if( nodeMap[ edge[1] ] === partition1 && nodeMap[ edge[2] ] === partition2 ){
          return false;
        }
        if( nodeMap[ edge[1] ] === partition2 && nodeMap[ edge[2] ] === partition1 ){
          return false;
        }
        return true;
      } );

      // All edges pointing to partition2 should now point to partition1
      for( var i = 0; i < newEdges.length; i++ ){
        var edge = newEdges[ i ];
        if( edge[1] === partition2 ){ // Check source
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][1] = partition1;
        } else if( edge[2] === partition2 ){ // Check target
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for( var i = 0; i < nodeMap.length; i++ ){
        if( nodeMap[ i ] === partition2 ){
          nodeMap[ i ] = partition1;
        }
      }

      return newEdges;
    };


    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function( metaNodeMap,
                   remainingEdges,
                   size,
                   sizeLimit ){
      // Stop condition
      if( size <= sizeLimit ){
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor( (Math.random() * remainingEdges.length) );

      // Colapse graph based on edge
      var newEdges = colapse( edgeIndex, metaNodeMap, remainingEdges );

      return contractUntil( metaNodeMap,
                 newEdges,
                 size - 1,
                 sizeLimit );
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil( Math.pow( Math.log( numNodes ) / Math.LN2, 2 ) );
    var stopSize = Math.floor( numNodes / Math.sqrt( 2 ) );

    if( numNodes < 2 ){
      util.error( 'At least 2 nodes are required for Karger-Stein algorithm' );
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for( var i = 0; i < numEdges; i++ ){
      var e = edges[ i ];
      edgeIndexes.push( [ i, id2position[ e.source().id() ], id2position[ e.target().id() ] ] );
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for( var i = 0; i < numNodes; i++ ){
      originalMetaNode.push( i );
    }

    // Main loop
    for( var iter = 0; iter <= numIter; iter++ ){
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice( 0 );

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil( metaNodeMap, edgeIndexes, numNodes, stopSize );

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice( 0 );

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil( metaNodeMap, edgesState, stopSize, 2 );
      var res2 = contractUntil( metaNodeMap2, edgesState, stopSize, 2 );

      // Is any of the 2 results the best cut so far?
      if( res1.length <= res2.length && res1.length < minCutSize ){
        minCutSize = res1.length;
        minCut = [ res1, metaNodeMap ];
      } else if( res2.length <= res1.length && res2.length < minCutSize ){
        minCutSize = res2.length;
        minCut = [ res2, metaNodeMap2 ];
      }
    } // end of main loop


    // Construct result
    var resEdges = (minCut[0]).map( function( e ){ return edges[ e[0] ]; } );
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for( var i = 0; i < minCut[1].length; i++ ){
      var partitionId = minCut[1][ i ];
      if( partitionId === witnessNodePartition ){
        partition1.push( nodes[ i ] );
      } else {
        partition2.push( nodes[ i ] );
      }
    }

    var ret = {
      cut: eles.spawn( cy, resEdges ),
      partition1: eles.spawn( partition1 ),
      partition2: eles.spawn( partition2 )
    };

    return ret;
  }
}); // elesfn


module.exports = elesfn;

},{"../../util":99}],13:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

// search, spanning trees, etc
var elesfn = ({

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function( weightFn ){
    var cy = this.cy();

    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    function findSet( ele ){
      for( var i = 0; i < forest.length; i++ ){
        var eles = forest[ i ];

        if( eles.anySame( ele ) ){
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection( cy, [] );
    var forest = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      forest.push( nodes[ i ].collection() );
    }

    var edges = this.edges();
    var S = edges.toArray().sort( function( a, b ){
      var weightA = weightFn( a );
      var weightB = weightFn( b );

      return weightA - weightB;
    } );

    for( var i = 0; i < S.length; i++ ){
      var edge = S[ i ];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet( u );
      var setV = findSet( v );

      if( setU.index !== setV.index ){
        A = A.add( edge );

        // combine forests for u and v
        forest[ setU.index ] = setU.eles.add( setV.eles );
        forest.splice( setV.index, 1 );
      }
    }

    return nodes.add( A );
  }
});

module.exports = elesfn;

},{"../../is":82}],14:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../is' );

var elesfn = ({

  pageRank: function( options ){
    options = options || {};

    var normalizeVector = function( vector ){
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for( var i = 0; i < length; i++ ){
        total += vector[ i ];
      }

      // Now, divide each by the sum of all elements
      for( var i = 0; i < length; i++ ){
        vector[ i ] = vector[ i ] / total;
      }
    };

    // dampingFactor - optional
    if( options != null &&
      options.dampingFactor != null ){
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if( options != null &&
      options.precision != null ){
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if( options != null &&
      options.iterations != null ){
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if( options != null &&
      options.weight != null &&
      is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for( var i = 0; i < numNodes; i++ ){
      var newRow = [];
      for( var j = 0; j < numNodes; j++ ){
        newRow.push( 0.0 );
      }
      matrix.push( newRow );
      columnSum.push( 0.0 );
    }

    // Now, process edges
    for( var i = 0; i < numEdges; i++ ){
      var edge = edges[ i ];
      var s = id2position[ edge.source().id() ];
      var t = id2position[ edge.target().id() ];
      var w = weightFn( edge );

      // Update matrix
      matrix[ t ][ s ] += w;

      // Update column sum
      columnSum[ s ] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for( var j = 0; j < numNodes; j++ ){
      if( columnSum[ j ] === 0 ){
        // No 'links' out from node jth, assume equal probability for each possible node
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = matrix[ i ][ j ] / columnSum[ j ] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for( var i = 0; i < numNodes; i++ ){
      eigenvector.push( 1.0 );
      nullVector.push( 0.0 );
    }

    for( var iter = 0; iter < numIter; iter++ ){
      // New array with all 0's
      var temp = nullVector.slice( 0 );

      // Multiply matrix with previous result
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          temp[ i ] += matrix[ i ][ j ] * eigenvector[ j ];
        }
      }

      normalizeVector( temp );
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for( var i = 0; i < numNodes; i++ ){
        diff += Math.pow( previous[ i ] - eigenvector[ i ], 2 );
      }

      // If difference is less than the desired threshold, stop iterating
      if( diff < epsilon ){
        break;
      }
    }

    // Construct result
    var res = {
      rank: function( node ){
        if( is.string( node ) ){
          // is a selector string
          var nodeId = (cy.filter( node )[0]).id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[ id2position[ nodeId ] ];
      }
    };


    return res;
  } // pageRank

}); // elesfn

module.exports = elesfn;

},{"../../is":82}],15:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );

var elesfn = ({
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
});

module.exports = elesfn;

},{"../define":44}],16:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );

var elesfn = ({
  classes: function( classes ){
    classes = ( classes || '' ).match( /\S+/g ) || [];
    var self = this;
    var changed = [];
    var classesMap = {};

    // fill in classes map
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[ i ];

      classesMap[ cls ] = true;
    }

    // check and update each ele
    for( var j = 0; j < self.length; j++ ){
      var ele = self[ j ];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[ i ];
        var eleHasClass = eleClasses[ cls ];

        if( !eleHasClass ){
          changedEle = true;
          break;
        }
      }

      // check if ele has classes outside of those passed
      if( !changedEle ){
        var classes = Object.keys( eleClasses );

        for( var i = 0; i < classes.length; i++ ){
          var eleCls = classes[i];
          var eleHasClass = eleClasses[ eleCls ];
          var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function

          if( eleHasClass && !specdClass ){
            changedEle = true;
            break;
          }
        }
      }

      if( changedEle ){
        _p.classes = util.copy( classesMap );

        changed.push( ele );
      }
    }

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  addClass: function( classes ){
    return this.toggleClass( classes, true );
  },

  hasClass: function( className ){
    var ele = this[0];
    return ( ele != null && ele._private.classes[ className ] ) ? true : false;
  },

  toggleClass: function( classesStr, toggle ){
    var classes = classesStr.match( /\S+/g ) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for( var i = 0, il = self.length; i < il; i++ ){
      var ele = self[ i ];
      var changedEle = false;

      for( var j = 0; j < classes.length; j++ ){
        var cls = classes[ j ];
        var eleClasses = ele._private.classes;
        var hasClass = eleClasses[ cls ];
        var shouldAdd = toggle || (toggle === undefined && !hasClass);

        if( shouldAdd ){
          eleClasses[ cls ] = true;

          if( !hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        } else { // then remove
          eleClasses[ cls ] = false;

          if( hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        }

      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  removeClass: function( classes ){
    return this.toggleClass( classes, false );
  },

  flashClass: function( classes, duration ){
    var self = this;

    if( duration == null ){
      duration = 250;
    } else if( duration === 0 ){
      return self; // nothing to do really
    }

    self.addClass( classes );
    setTimeout( function(){
      self.removeClass( classes );
    }, duration );

    return self;
  }
});

module.exports = elesfn;

},{"../util":99}],17:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Selector = _dereq_('../selector');

var elesfn = ({
  allAre: function( selector ){
    var selObj = new Selector( selector );

    return this.every(function( ele ){
      return selObj.matches( ele );
    });
  },

  is: function( selector ){
    var selObj = new Selector( selector );

    return this.some(function( ele ){
      return selObj.matches( ele );
    });
  },

  some: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( ret ){
        return true;
      }
    }

    return false;
  },

  every: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( !ret ){
        return false;
      }
    }

    return true;
  },

  same: function( collection ){
    collection = this.cy().collection( collection );

    // cheap extra check
    if( this.length !== collection.length ){
      return false;
    }

    return this.every(function( ele ){
      return collection.hasElementWithId( ele.id() );
    });
  },

  anySame: function( collection ){
    collection = this.cy().collection( collection );

    return this.some(function( ele ){
      return collection.hasElementWithId( ele.id() );
    });
  },

  allAreNeighbors: function( collection ){
    collection = this.cy().collection( collection );

    var nhood = this.neighborhood();

    return collection.every(function( ele ){
      return nhood.hasElementWithId( ele.id() );
    });
  },

  contains: function( collection ){
    collection = this.cy().collection( collection );

    var self = this;

    return collection.every(function( ele ){
      return self.hasElementWithId( ele.id() );
    });
  }
});

elesfn.allAreNeighbours = elesfn.allAreNeighbors;
elesfn.has = elesfn.contains;

module.exports = elesfn;

},{"../is":82,"../selector":86}],18:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  parent: function( selector ){
    var parents = [];
    var cy = this._private.cy;

    // optimisation for single ele call
    if( this.length === 1 ){
      var parent = this[0]._private.parent;

      if( parent ){ return parent; }
    }

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parent = ele._private.parent;

      if( parent ){
        parents.push( parent );
      }
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  parents: function( selector ){
    var parents = [];

    var eles = this.parent();
    while( eles.nonempty() ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];
        parents.push( ele );
      }

      eles = eles.parent();
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  commonAncestors: function( selector ){
    var ancestors;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
    }

    return ancestors.filter( selector );
  },

  orphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isOrphan();
    } ).filter( selector );
  },

  nonorphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isChild();
    } ).filter( selector );
  },

  children: function( selector ){
    var children = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      children = children.concat( ele._private.children );
    }

    return this.spawn( children, { unique: true } ).filter( selector );
  },

  siblings: function( selector ){
    return this.parent().children().not( this ).filter( selector );
  },

  isParent: function(){
    var ele = this[0];

    if( ele ){
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },

  isChildless: function(){
    var ele = this[0];

    if( ele ){
      return ele.isNode() && ele._private.children.length === 0;
    }
  },

  isChild: function(){
    var ele = this[0];

    if( ele ){
      return ele.isNode() && ele._private.parent != null;
    }
  },

  isOrphan: function(){
    var ele = this[0];

    if( ele ){
      return ele.isNode() && ele._private.parent == null;
    }
  },

  descendants: function( selector ){
    var elements = [];

    function add( eles ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        elements.push( ele );

        if( ele.children().nonempty() ){
          add( ele.children() );
        }
      }
    }

    add( this.children() );

    return this.spawn( elements, { unique: true } ).filter( selector );
  }
});

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

},{}],19:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );
var fn, elesfn;

fn = elesfn = ({

  data: define.data( {
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  removeData: define.removeData( {
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  } ),

  rscratch: define.data( {
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  } ),

  removeRscratch: define.removeData( {
    field: 'rscratch',
    triggerEvent: false
  } ),

  id: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.id;
    }
  }

});

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

},{"../define":44}],20:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );

var elesfn = {};

function defineDegreeFunction( callback ){
  return function( includeLoops ){
    var self = this;

    if( includeLoops === undefined ){
      includeLoops = true;
    }

    if( self.length === 0 ){ return; }

    if( self.isNode() && !self.removed() ){
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for( var i = 0; i < connectedEdges.length; i++ ){
        var edge = connectedEdges[ i ];

        if( !includeLoops && edge.isLoop() ){
          continue;
        }

        degree += callback( node, edge );
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend( elesfn, {
  degree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( edge.target() ) ){
      return 2;
    } else {
      return 1;
    }
  } ),

  indegree: defineDegreeFunction( function( node, edge ){
    if( edge.target().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } ),

  outdegree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } )
} );

function defineDegreeBoundsFunction( degreeFn, callback ){
  return function( includeLoops ){
    var ret;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[ i ];
      var degree = ele[ degreeFn ]( includeLoops );
      if( degree !== undefined && (ret === undefined || callback( degree, ret )) ){
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend( elesfn, {
  minDegree: defineDegreeBoundsFunction( 'degree', function( degree, min ){
    return degree < min;
  } ),

  maxDegree: defineDegreeBoundsFunction( 'degree', function( degree, max ){
    return degree > max;
  } ),

  minIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, min ){
    return degree < min;
  } ),

  maxIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, max ){
    return degree > max;
  } ),

  minOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, min ){
    return degree < min;
  } ),

  maxOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, max ){
    return degree > max;
  } )
} );

util.extend( elesfn, {
  totalDegree: function( includeLoops ){
    var total = 0;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      total += nodes[ i ].degree( includeLoops );
    }

    return total;
  }
} );

module.exports = elesfn;

},{"../util":99}],21:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );
var is = _dereq_( '../is' );
var util = _dereq_( '../util' );
var math = _dereq_( '../math' );
var fn, elesfn;

fn = elesfn = ({

  position: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'rtrigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  // position but no notification to renderer
  silentPosition: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  positions: function( pos, silent ){
    if( is.plainObject( pos ) ){
      if( silent ){
        this.silentPosition( pos );
      } else {
        this.position( pos );
      }

    } else if( is.fn( pos ) ){
      var fn = pos;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];

        var pos = fn( ele, i );

        if( pos && !ele.locked() && !ele.isParent() ){
          var elePos = ele._private.position;
          elePos.x = pos.x;
          elePos.y = pos.y;
        }
      }

      this.dirtyCompoundBoundsCache();

      if( silent ){
        this.trigger( 'position' );
      } else {
        this.rtrigger( 'position' );
      }
    }

    return this; // chaining
  },

  silentPositions: function( pos ){
    return this.positions( pos, true );
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject( dim ) ? dim : undefined;
    var setting = rpos !== undefined || ( val !== undefined && is.string( dim ) );

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = ( val - pan[ dim ] ) / zoom;
          } else if( rpos !== undefined ){ // set whole position
            ele._private.position = {
              x: ( rpos.x - pan.x ) / zoom,
              y: ( rpos.y - pan.y ) / zoom
            };
          }
        }

        this.rtrigger( 'position' );
      } else { // getting
        var pos = ele._private.position;
        rpos = {
          x: pos.x * zoom + pan.x,
          y: pos.y * zoom + pan.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return rpos;
        } else { // then return the specified dimension
          return rpos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject( dim ) ? dim : undefined;
    var setting = ppos !== undefined || ( val !== undefined && is.string( dim ) );
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = val + origin[ dim ];
          } else if( ppos !== undefined ){ // set whole position
            ele._private.position = {
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            };
          }
        }

        this.dirtyCompoundBoundsCache();
        this.rtrigger( 'position' );

      } else { // getting
        var pos = ele._private.position;
        var parent = hasCompoundNodes ? ele.parent() : null;
        var hasParent = parent && parent.length > 0;
        var relativeToParent = hasParent;

        if( hasParent ){
          parent = parent[0];
        }

        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

        ppos = {
          x: pos.x - origin.x,
          y: pos.y - origin.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return ppos;
        } else { // then return the specified dimension
          return ppos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  renderedBoundingBox: function( options ){
    var bb = this.boundingBox( options );
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();

    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  },

  dirtyCompoundBoundsCache: function(){
    var cy = this.cy();

    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return this; }

    var eles = this;
    var q = [];

    for( var i = 0; i < this.length; i++ ){
      q.push( this[i] );
    }

    while( q.length > 0 ){
      var ele = q.shift();

      ele._private.compoundBoundsClean = false;

      if( ele.isParent() ){
        ele.trigger('bounds');
      }

      if( ele.isChild() ){
        q.push( ele.parent() );
      }
    }

    return this;
  },

  updateCompoundBounds: function(){
    var cy = this.cy();

    // save cycles for non compound graphs or when style disabled
    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return this; }

    var updated = [];

    function update( parent ){
      if( !parent.isParent() ){ return; }

      var _p = parent._private;
      var children = parent.children();
      var includeLabels = parent.pstyle( 'compound-sizing-wrt-labels' ).value === 'include';

      var min = {
        width: {
          val: parent.pstyle( 'min-width' ).pfValue,
          left: parent.pstyle( 'min-width-bias-left' ),
          right: parent.pstyle( 'min-width-bias-right' )
        },
        height: {
          val: parent.pstyle( 'min-height' ).pfValue,
          top: parent.pstyle( 'min-height-bias-top' ),
          bottom: parent.pstyle( 'min-height-bias-bottom' )
        }
      };

      var bb = children.boundingBox( {
        includeLabels: includeLabels,
        includeOverlays: false,

        // updating the compound bounds happens outside of the regular
        // cache cycle (i.e. before fired events)
        useCache: false
      } );
      var pos = _p.position;

      function computeBiasValues( propDiff, propBias, propBiasComplement ){
        var biasDiff = 0;
        var biasComplementDiff = 0;
        var biasTotal = propBias + propBiasComplement;

        if( propDiff > 0 && biasTotal > 0 ){
          biasDiff = ( propBias / biasTotal ) * propDiff;
          biasComplementDiff = ( propBiasComplement / biasTotal ) * propDiff;
        }
        return {
          biasDiff: biasDiff,
          biasComplementDiff: biasComplementDiff
        };
      }

      function computePaddingValues( width, height, paddingObject, relativeTo ) {
        // Assuming percentage is number from 0 to 1
        if(paddingObject.units === '%') {
          switch(relativeTo) {
            case 'width':
              return width > 0 ? paddingObject.pfValue * width : 0;
            case 'height':
              return height > 0 ? paddingObject.pfValue * height : 0;
            case 'average':
              return ( width > 0 ) && ( height > 0 ) ? paddingObject.pfValue * ( width + height ) / 2 : 0;
            case 'min':
              return ( width > 0 ) && ( height > 0 ) ? ( ( width > height ) ? paddingObject.pfValue * height : paddingObject.pfValue * width ) : 0;
            case 'max':
              return ( width > 0 ) && ( height > 0 ) ? ( ( width > height ) ? paddingObject.pfValue * width : paddingObject.pfValue * height ) : 0;
            default:
              return 0;
          }
        } else if(paddingObject.units === 'px') {
          return paddingObject.pfValue;
        } else {
          return 0;
        }
      }

      var leftVal = min.width.left.value;
      if( min.width.left.units === 'px' && min.width.val > 0 ){
        leftVal = ( leftVal * 100 ) / min.width.val;
      }
      var rightVal = min.width.right.value;
      if( min.width.right.units === 'px' && min.width.val > 0 ){
        rightVal = ( rightVal * 100 ) / min.width.val;
      }

      var topVal = min.height.top.value;
      if( min.height.top.units === 'px' && min.height.val > 0 ){
        topVal = ( topVal * 100 ) / min.height.val;
      }

      var bottomVal = min.height.bottom.value;
      if( min.height.bottom.units === 'px' && min.height.val > 0 ){
        bottomVal = ( bottomVal * 100 ) / min.height.val;
      }

      var widthBiasDiffs = computeBiasValues( min.width.val - bb.w, leftVal, rightVal );
      var diffLeft = widthBiasDiffs.biasDiff;
      var diffRight = widthBiasDiffs.biasComplementDiff;

      var heightBiasDiffs = computeBiasValues( min.height.val - bb.h, topVal, bottomVal );
      var diffTop = heightBiasDiffs.biasDiff;
      var diffBottom = heightBiasDiffs.biasComplementDiff;

      _p.autoPadding = computePaddingValues( bb.w, bb.h, ele.pstyle( 'padding' ), ele.pstyle( 'padding-relative-to' ).value );

      _p.autoWidth = Math.max(bb.w, min.width.val);
      pos.x = (- diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

      _p.autoHeight = Math.max(bb.h, min.height.val);
      pos.y = (- diffBottom + bb.y1 + bb.y2 + diffTop) / 2;

      updated.push( parent );
    }

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var _p = ele._private;

      if( !_p.compoundBoundsClean ){
        update( ele );

        if( !cy._private.batchingStyle ){
          _p.compoundBoundsClean = true;
        }
      }
    }

    return this;
  }
});

var noninf = function( x ){
  if( x === Infinity || x === -Infinity ){
    return 0;
  }

  return x;
};

var updateBounds = function( b, x1, y1, x2, y2 ){
  // don't update with zero area boxes
  if( x2 - x1 === 0 || y2 - y1 === 0 ){ return; }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
};

var updateBoundsFromBox = function( b, b2 ){
  return updateBounds( b, b2.x1, b2.y1, b2.x2, b2.y2 );
};

var prefixedProperty = function( obj, field, prefix ){
  return util.getPrefixedProperty( obj, field, prefix );
};

var updateBoundsFromArrow = function( bounds, ele, prefix, options ){
  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle( prefix + '-arrow-shape' ).value;
  var x;
  var y;

  if( arrowType !== 'none' ){
    if( prefix === 'source' ){
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if( prefix === 'target' ){
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    }

    updateBounds( bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW );
  }
};

var updateBoundsFromLabel = function( bounds, ele, prefix, options ){
  var prefixDash;

  if( prefix ){
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle( prefixDash + 'label' ).strValue;

  if( label ){
    var halign = ele.pstyle( 'text-halign' );
    var valign = ele.pstyle( 'text-valign' );
    var labelWidth = prefixedProperty( rstyle, 'labelWidth', prefix );
    var labelHeight = prefixedProperty( rstyle, 'labelHeight', prefix );
    var labelX = prefixedProperty( rstyle, 'labelX', prefix );
    var labelY = prefixedProperty( rstyle, 'labelY', prefix );
    var marginX = ele.pstyle( prefixDash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( prefixDash + 'text-margin-y' ).pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle( prefixDash + 'text-rotation' );
    var outlineWidth = ele.pstyle( 'text-outline-width' ).pfValue;
    var borderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle( 'text-background-padding' ).pfValue;

    var lh = labelHeight + 2 * padding;
    var lw = labelWidth + 2 * padding;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if( isEdge ){
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch( halign.value ){
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch( valign.value ){
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }

    var isAutorotate = ( isEdge && rotation.strValue === 'autorotate' );
    var isPfValue = ( rotation.pfValue != null && rotation.pfValue !== 0 );

    if( isAutorotate || isPfValue ){
      var theta = isAutorotate ? prefixedProperty( _p.rstyle, 'labelAngle', prefix ) : rotation.pfValue;
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - labelX;
        y = y - labelY;

        return {
          x: x * cos - y * sin + labelX,
          y: x * sin + y * cos + labelY
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
      ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
    }

    lx1 += marginX - Math.max( outlineWidth, halfBorderWidth );
    lx2 += marginX + Math.max( outlineWidth, halfBorderWidth );
    ly1 += marginY - Math.max( outlineWidth, halfBorderWidth );
    ly2 += marginY + Math.max( outlineWidth, halfBorderWidth );

    updateBounds( bounds, lx1, ly1, lx2, ly2 );
  }

  return bounds;
};

// get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function( ele, options ){
  var cy = ele._private.cy;
  var cy_p = cy._private;
  var styleEnabled = cy_p.styleEnabled;

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  var _p = ele._private;
  var display = styleEnabled ? ele.pstyle( 'display' ).value : 'element';
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2, x, y;
  var displayed = display !== 'none';

  if( displayed ){
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if( styleEnabled && options.includeOverlays ){
      overlayOpacity = ele.pstyle( 'overlay-opacity' ).value;

      if( overlayOpacity !== 0 ){
        overlayPadding = ele.pstyle( 'overlay-padding' ).value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if( styleEnabled ){
      w = ele.pstyle( 'width' ).pfValue;
      wHalf = w / 2;
    }

    if( isNode && options.includeNodes ){
      var pos = _p.position;
      x = pos.x;
      y = pos.y;
      var w = ele.outerWidth();
      var halfW = w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;

      // handle node dimensions
      /////////////////////////

      ex1 = x - halfW - overlayPadding;
      ex2 = x + halfW + overlayPadding;
      ey1 = y - halfH - overlayPadding;
      ey2 = y + halfH + overlayPadding;

      updateBounds( bounds, ex1, ey1, ex2, ey2 );

    } else if( isEdge && options.includeEdges ){
      var rstyle = _p.rstyle || {};

      // handle edge dimensions (rough box estimate)
      //////////////////////////////////////////////
      if( styleEnabled ){
        ex1 = Math.min( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ex2 = Math.max( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ey1 = Math.min( rstyle.srcY, rstyle.midY, rstyle.tgtY );
        ey2 = Math.max( rstyle.srcY, rstyle.midY, rstyle.tgtY );

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        updateBounds( bounds, ex1, ey1, ex2, ey2 );
      }

      // precise haystacks
      ////////////////////
      if( styleEnabled && ele.pstyle( 'curve-style' ).strValue === 'haystack' ){
        var hpts = rstyle.haystackPts;

        ex1 = hpts[0].x;
        ey1 = hpts[0].y;
        ex2 = hpts[1].x;
        ey2 = hpts[1].y;

        if( ex1 > ex2 ){
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if( ey1 > ey2 ){
          var temp = ey1;
          ey1 = ey2;
          ey2 = temp;
        }

        updateBounds( bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf );

      // handle points along edge
      ///////////////////////////
      } else {
        var pts = rstyle.bezierPts || rstyle.linePts || [];

        for( var j = 0; j < pts.length; j++ ){
          var pt = pts[ j ];

          ex1 = pt.x - wHalf;
          ex2 = pt.x + wHalf;
          ey1 = pt.y - wHalf;
          ey2 = pt.y + wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }

        // fallback on source and target positions
        //////////////////////////////////////////
        if( pts.length === 0 ){
          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;

          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          // take into account edge width
          ex1 -= wHalf;
          ex2 += wHalf;
          ey1 -= wHalf;
          ey2 += wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }
      }

    } // edges

    // overlay
    //////////

    if( styleEnabled ){

      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;

      updateBounds( bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding );
    }

    // handle edge arrow size
    /////////////////////////

    if( styleEnabled && options.includeEdges && isEdge ){
      updateBoundsFromArrow( bounds, ele, 'mid-source', options );
      updateBoundsFromArrow( bounds, ele, 'mid-target', options );
      updateBoundsFromArrow( bounds, ele, 'source', options );
      updateBoundsFromArrow( bounds, ele, 'target', options );
    }

    // handle label dimensions
    //////////////////////////

    if( styleEnabled && options.includeLabels ){
      updateBoundsFromLabel( bounds, ele, null, options );

      if( isEdge ){
        updateBoundsFromLabel( bounds, ele, 'source', options );
        updateBoundsFromLabel( bounds, ele, 'target', options );
      }
    } // style enabled for labels
  } // if displayed

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  if( bounds.w > 0 && bounds.h > 0 && displayed ){
    math.expandBoundingBox( bounds, 1 );
  }

  return bounds;
};

var tf = function( val ){
  if( val ){
    return 't';
  } else {
    return 'f';
  }
};

var getKey = function( opts ){
  var key = '';

  key += tf( opts.incudeNodes );
  key += tf( opts.includeEdges );
  key += tf( opts.includeLabels );
  key += tf( opts.includeOverlays );

  return key;
};

var cachedBoundingBoxImpl = function( ele, opts ){
  var _p = ele._private;
  var bb;
  var headless = ele.cy().headless();
  var key = opts === defBbOpts ? defBbOptsKey : getKey( opts );

  if( !opts.useCache || headless || !_p.bbCache || !_p.bbCache[key] ){
    bb = boundingBoxImpl( ele, opts );

    if( !headless ){
      _p.bbCache = _p.bbCache || {};
      _p.bbCache[key] = bb;
    }
  } else {
    bb = _p.bbCache[key];
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeOverlays: true,
  useCache: true
};

var defBbOptsKey = getKey( defBbOpts );

elesfn.recalculateRenderedStyle = function( useCache ){
  var cy = this.cy();
  var renderer = cy.renderer();
  var styleEnabled = cy.styleEnabled();

  if( renderer && styleEnabled ){
    renderer.recalculateRenderedStyle( this, useCache );
  }

  return this;
};

function filledBbOpts( options ){
  return {
    includeNodes: util.default( options.includeNodes, defBbOpts.includeNodes ),
    includeEdges: util.default( options.includeEdges, defBbOpts.includeEdges ),
    includeLabels: util.default( options.includeLabels, defBbOpts.includeLabels ),
    includeOverlays: util.default( options.includeOverlays, defBbOpts.includeOverlays ),
    useCache: util.default( options.useCache, defBbOpts.useCache )
  };
}

elesfn.boundingBox = function( options ){
  // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function
  if( this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true) ){
    if( options === undefined ){
      options = defBbOpts;
    } else {
      options = filledBbOpts( options );
    }

    return cachedBoundingBoxImpl( this[0], options );
  }

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  options = options || util.staticEmptyObject();

  var opts = filledBbOpts( options );

  var eles = this;
  var cy = eles.cy();
  var styleEnabled = cy.styleEnabled();

  if( styleEnabled ){
    this.recalculateRenderedStyle( opts.useCache );
  }

  var updatedEdge = {}; // use to avoid duplicated edge updates

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ ele.id() ] ){
      var edges = ele.parallelEdges();

      for( var j = 0; j < edges.length; j++ ){ // make all as updated
        updatedEdge[ edges[j].id() ] = true;
      }

      edges.recalculateRenderedStyle( opts.useCache ); // n.b. ele.parallelEdges() single is cached
    }

    updateBoundsFromBox( bounds, cachedBoundingBoxImpl( ele, opts ) );
  }

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  return bounds;
};

// private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway
elesfn.boundingBoxAt = function( fn ){
  var nodes = this.nodes();
  var oldPos = {};

  if( is.plainObject( fn ) ){
    var obj = fn;

    fn = function(){ return obj; };
  }

  // save the current position and set the new one, per node
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[i];
    var pos = n._private.position;
    var newPos = fn.call( n, i, n );

    oldPos[ n.id() ] = { x: pos.x, y: pos.y };

    pos.x = newPos.x;
    pos.y = newPos.y;
  }

  this.trigger('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  var bb = this.boundingBox({ useCache: false });

  // restore the original position, per node
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[i];
    var pos = n._private.position;
    var old = oldPos[ n.id() ];

    pos.x = old.x;
    pos.y = old.y;
  }

  this.trigger('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  return bb;
};

var defineDimFns = function( opts ){
  opts.uppercaseName = util.capitalize( opts.name );
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize( opts.outerName );

  fn[ opts.name ] = function dimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        if( ele.isParent() ){
          ele.updateCompoundBounds();

          return _p[ opts.autoName ] || 0;
        }

        var d = ele.pstyle( opts.name );

        switch( d.strValue ){
          case 'label':
            return _p.rstyle[ opts.labelName ] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var dim = ele[ opts.name ]();
        var border = ele.pstyle( 'border-width' ).pfValue; // n.b. 1/2 each side
        var padding = 2 * ele.padding();

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
    var ele = this[0];

    if( ele ){
      var d = ele[ opts.name ]();
      return d * this.cy().zoom();
    }
  };

  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
    var ele = this[0];

    if( ele ){
      var od = ele[ opts.outerName ]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns( {
  name: 'width'
} );

defineDimFns( {
  name: 'height'
} );

elesfn.padding = function(){
  var ele = this[0];
  var _p = ele._private;
  if( ele.isParent() ){
    ele.updateCompoundBounds();

    if( _p.autoPadding !== undefined ){
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
}

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;
fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

},{"../define":44,"../is":82,"../math":84,"../util":99}],22:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

// represents a node or an edge
var Element = function( cy, params, restore ){
  var self = this;
  restore = (restore === undefined || restore ? true : false);

  if( cy === undefined || params === undefined || !is.core( cy ) ){
    util.error( 'An element must have a core reference and parameters set' );
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if( group == null ){
    if( params.data && params.data.source != null && params.data.target != null ){
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if( group !== 'nodes' && group !== 'edges' ){
    util.error( 'An element must be of type `nodes` or `edges`; you specified `' + group + '`' );
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  var _p = this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: {}, // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [], // array of children
    parent: null, // parent ref
    traversalCache: {} // cache of output of traversal functions
  };

  // renderedPosition overrides if specified
  if( params.renderedPosition ){
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  if( is.string( params.classes ) ){
    var classes = params.classes.split( /\s+/ );
    for( var i = 0, l = classes.length; i < l; i++ ){
      var cls = classes[ i ];
      if( !cls || cls === '' ){ continue; }

      _p.classes[ cls ] = true;
    }
  }

  if( params.style || params.css ){
    cy.style().applyBypass( this, params.style || params.css );
  }

  if( restore === undefined || restore ){
    this.restore();
  }

};

module.exports = Element;

},{"../is":82,"../util":99}],23:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );

var elesfn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger(), // .trigger( events [, extraParams] )

  rtrigger: function( event, extraParams ){ // for internal use only
    if( this.length === 0 ){ return; } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify( {
      type: event,
      eles: this
    } );

    this.trigger( event, extraParams );
    return this;
  }
});

// aliases:
define.eventAliasesOn( elesfn );

module.exports = elesfn;

},{"../define":44}],24:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var Selector = _dereq_( '../selector' );

var elesfn = ({
  nodes: function( selector ){
    return this.filter( function( ele, i ){
      return ele.isNode();
    } ).filter( selector );
  },

  edges: function( selector ){
    return this.filter( function( ele, i ){
      return ele.isEdge();
    } ).filter( selector );
  },

  filter: function( filter, thisArg ){
    if( filter === undefined ){ // check this first b/c it's the most common/performant case
      return this;
    } else if( is.string( filter ) || is.elementOrCollection( filter ) ){
      return new Selector( filter ).filter( this );
    } else if( is.fn( filter ) ){
      var filterEles = this.spawn();
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];
        var include = thisArg ? filter.apply( thisArg, [ ele, i, eles ] ) : filter( ele, i, eles );

        if( include ){
          filterEles.merge( ele );
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function( toRemove ){
    if( !toRemove ){
      return this;
    } else {

      if( is.string( toRemove ) ){
        toRemove = this.filter( toRemove );
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for( var i = 0; i < this.length; i++ ){
        var element = this[ i ];

        var remove = rMap.has( element.id() );
        if( !remove ){
          elements.push( element );
        }
      }

      return this.spawn( elements );
    }

  },

  absoluteComplement: function(){
    var cy = this._private.cy;

    return cy.mutableElements().not( this );
  },

  intersect: function( other ){
    // if a selector is specified, then filter by it instead
    if( is.string( other ) ){
      var selector = other;
      return this.filter( selector );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for( var i = 0; i < col.length; i++ ){
      var id = col[ i ]._private.data.id;
      var entry = map2.get( id );

      if( entry ){
        elements.push( entry.ele );
      }
    }

    return this.spawn( elements );
  },

  xor: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other ){
      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId( id );

        if( !inOther ){
          elements.push( ele );
        }
      }

    };

    add( col1, col2 );
    add( col2, col1 );

    return this.spawn( elements );
  },

  diff: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other, retEles ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId( id );

        if( inOther ){
          both.push( ele );
        } else {
          retEles.push( ele );
        }
      }

    };

    add( col1, col2, left );
    add( col2, col1, right );

    return {
      left: this.spawn( left, { unique: true } ),
      right: this.spawn( right, { unique: true } ),
      both: this.spawn( both, { unique: true } )
    };
  },

  add: function( toAdd ){
    var cy = this._private.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    var elements = [];

    for( var i = 0; i < this.length; i++ ){
      elements.push( this[ i ] );
    }

    var map = this._private.map;

    for( var i = 0; i < toAdd.length; i++ ){

      var add = !map.has( toAdd[ i ].id() );
      if( add ){
        elements.push( toAdd[ i ] );
      }
    }

    return this.spawn( elements );
  },

  // in place merge on calling collection
  merge: function( toAdd ){
    var _p = this._private;
    var cy = _p.cy;

    if( !toAdd ){
      return this;
    }

    if( toAdd && is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    var map = _p.map;

    for( var i = 0; i < toAdd.length; i++ ){
      var toAddEle = toAdd[ i ];
      var id = toAddEle._private.data.id;
      var add = !map.has( id );

      if( add ){
        var index = this.length++;

        this[ index ] = toAddEle;

        map.set( id, { ele: toAddEle, index: index } );
      } else { // replace
        var index = map.get( id ).index;

        this[ index ] = toAddEle;
        map.set( id, { ele: toAddEle, index: index } );
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function( ele ){
    ele = ele[0];

    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry =  map.get( id );

    if( !entry ){
      return this; // no need to remove
    }

    var i = entry.index;

    // remove ele
    this[ i ] = undefined;
    map.delete( id );

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if( this.length > 1 && !unmergedLastEle ){
      var lastEleI = this.length - 1;
      var lastEle = this[ lastEleI ];
      var lastEleId = lastEle._private.data.id;

      this[ lastEleI ] = undefined;
      this[ i ] = lastEle;
      map.set( lastEleId, { ele: lastEle, index: i } );
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function( toRemove ){
    var cy = this._private.cy;

    if( !toRemove ){
      return this;
    }

    if( toRemove && is.string( toRemove ) ){
      var selector = toRemove;
      toRemove = cy.mutableElements().filter( selector );
    }

    for( var i = 0; i < toRemove.length; i++ ){
      this.unmergeOne( toRemove[ i ] );
    }

    return this; // chaining
  },

  map: function( mapFn, thisArg ){
    var arr = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var ret = thisArg ? mapFn.apply( thisArg, [ ele, i, eles ] ) : mapFn( ele, i, eles );

      arr.push( ret );
    }

    return arr;
  },

  reduce: function( fn, initialValue ){
    var val = initialValue;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      val = fn( val, eles[i], i, eles );
    }

    return val;
  },

  max: function( valFn, thisArg ){
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val > max ){
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function( valFn, thisArg ){
    var min = Infinity;
    var minEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val < min ){
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
});

// aliases
var fn = elesfn;
fn[ 'u' ] = fn[ '|' ] = fn[ '+' ] = fn.union = fn.or = fn.add;
fn[ '\\' ] = fn[ '!' ] = fn[ '-' ] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn[ 'n' ] = fn[ '&' ] = fn[ '.' ] = fn.and = fn.intersection = fn.intersect;
fn[ '^' ] = fn[ '(+)' ] = fn[ '(-)' ] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

},{"../is":82,"../selector":86}],25:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  isNode: function(){
    return this.group() === 'nodes';
  },

  isEdge: function(){
    return this.group() === 'edges';
  },

  isLoop: function(){
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function(){
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.group;
    }
  }
});


module.exports = elesfn;

},{}],26:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');
var Map = _dereq_('../map');
var Set = _dereq_('../set');

var Element = _dereq_('./element');

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  generate: function( cy, element, tryThisId ){
    var id = tryThisId != null ? tryThisId : util.uuid();

    while( cy.hasElementWithId( id ) ){
      id = util.uuid();
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function( cy, elements, options ){
  if( cy === undefined || !is.core( cy ) ){
    util.error( 'A collection must have a reference to the core' );
    return;
  }

  var map = new Map();
  var createdElements = false;

  if( !elements ){
    elements = [];
  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = new Set();

    for( var i = 0, l = elements.length; i < l; i++ ){
      var json = elements[ i ];

      if( json.data == null ){
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if( data.id == null ){
        data.id = idFactory.generate( cy, json );
      } else if( cy.hasElementWithId( data.id ) || elesIds.has( data.id ) ){
        continue; // can't create element if prior id already exists
      }

      var ele = new Element( cy, json, false );
      eles.push( ele );
      elesIds.add( data.id );
    }

    elements = eles;
  }

  this.length = 0;

  for( var i = 0, l = elements.length; i < l; i++ ){
    var element = elements[ i ];
    if( !element ){  continue; }

    var id = element._private.data.id;

    if( !options || ( options.unique && !map.has(id) ) ){
      map.set( id, {
        index: this.length,
        ele: element
      } );

      this[ this.length ] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  };

  // restore the elements if we created them from json
  if( createdElements ){
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function(){
  return 'collection';
};

elesfn.spawn = function( cy, eles, opts ){
  if( !is.core( cy ) ){ // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection( cy, eles, opts );
};

elesfn.spawnSelf = function(){
  return this.spawn( this );
};

elesfn.cy = function(){
  return this._private.cy;
};

elesfn.element = function(){
  return this[0];
};

elesfn.collection = function(){
  if( is.collection( this ) ){
    return this;
  } else { // an element
    return new Collection( this._private.cy, [ this ] );
  }
};

elesfn.unique = function(){
  return new Collection( this._private.cy, this, { unique: true } );
};

elesfn.hasElementWithId = function( id ){
  return this._private.map.has( id );
};

elesfn.getElementById = function( id ){
  var cy = this._private.cy;
  var entry = this._private.map.get( id );

  return entry ? entry.ele : new Collection( cy ); // get ele or empty collection
};

elesfn.poolIndex = function(){
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this._private.data.id;

  return eles._private.map.get( id ).index;
};

elesfn.json = function( obj ){
  var ele = this.element();
  var cy = this.cy();

  if( ele == null && obj ){ return this; } // can't set to no eles

  if( ele == null ){ return undefined; } // can't get from no eles

  var p = ele._private;

  if( is.plainObject( obj ) ){ // set

    cy.startBatch();

    if( obj.data ){
      ele.data( obj.data );
    }

    if( obj.position ){
      ele.position( obj.position );
    }

    // ignore group -- immutable

    var checkSwitch = function( k, trueFnName, falseFnName ){
      var obj_k = obj[ k ];

      if( obj_k != null && obj_k !== p[ k ] ){
        if( obj_k ){
          ele[ trueFnName ]();
        } else {
          ele[ falseFnName ]();
        }
      }
    };

    checkSwitch( 'removed', 'remove', 'restore' );

    checkSwitch( 'selected', 'select', 'unselect' );

    checkSwitch( 'selectable', 'selectify', 'unselectify' );

    checkSwitch( 'locked', 'lock', 'unlock' );

    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );

    if( obj.classes != null ){
      ele.classes( obj.classes );
    }

    cy.endBatch();

    return this;

  } else if( obj === undefined ){ // get

    var json = {
      data: util.copy( p.data ),
      position: util.copy( p.position ),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    json.classes = Object.keys( p.classes ).filter(function( cls ){
      return p.classes[cls];
    }).join(' ');

    return json;
  }
};

elesfn.jsons = function(){
  var jsons = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();

    jsons.push( json );
  }

  return jsons;
};

elesfn.clone = function(){
  var cy = this.cy();
  var elesArr = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();
    var clone = new Element( cy, json, false ); // NB no restore

    elesArr.push( clone );
  }

  return new Collection( cy, elesArr );
};
elesfn.copy = elesfn.clone;

elesfn.restore = function( notifyRenderer ){
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var nodes = [];
  var edges = [];
  var elements;
  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    if( !ele.removed() ){
      // don't need to handle this ele
      continue;
    }

    // keep nodes first in the array and edges after
    if( ele.isNode() ){ // put to front of array if node
      nodes.push( ele );
    } else { // put to end of array if edge
      edges.push( ele );
    }
  }

  elements = nodes.concat( edges );

  var i;
  var removeFromElements = function(){
    elements.splice( i, 1 );
    i--;
  };

  // now, restore each element
  for( i = 0; i < elements.length; i++ ){
    var ele = elements[ i ];

    var _private = ele._private;
    var data = _private.data;

    // the traversal cache should start fresh when ele is added
    ele.clearTraversalCache();

    // set id and validate
    if( data.id === undefined ){
      data.id = idFactory.generate( cy, ele );

    } else if( is.number( data.id ) ){
      data.id = '' + data.id; // now it's a string

    } else if( is.emptyString( data.id ) || !is.string( data.id ) ){
      util.error( 'Can not create element with invalid string ID `' + data.id + '`' );

      // can't create element if it has empty string as id or non-string id
      removeFromElements();
      continue;
    } else if( cy.hasElementWithId( data.id ) ){
      util.error( 'Can not create second element with ID `' + data.id + '`' );

      // can't create element if one already has that id
      removeFromElements();
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if( ele.isNode() ){ // extra checks for nodes
      var node = ele;
      var pos = _private.position;

      // make sure the nodes have a defined position

      if( pos.x == null ){
        pos.x = 0;
      }

      if( pos.y == null ){
        pos.y = 0;
      }
    }

    if( ele.isEdge() ){ // extra checks for edges

      var edge = ele;
      var fields = [ 'source', 'target' ];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for( var j = 0; j < fieldsLength; j++ ){

        var field = fields[ j ];
        var val = data[ field ];

        if( is.number( val ) ){
          val = data[ field ] = '' + data[ field ]; // now string
        }

        if( val == null || val === '' ){
          // can't create if source or target is not defined properly
          util.error( 'Can not create edge `' + id + '` with unspecified ' + field );
          badSourceOrTarget = true;
        } else if( !cy.hasElementWithId( val ) ){
          // can't create edge if one of its nodes doesn't exist
          util.error( 'Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`' );
          badSourceOrTarget = true;
        }
      }

      if( badSourceOrTarget ){ removeFromElements(); continue; } // can't create this

      var src = cy.getElementById( data.source );
      var tgt = cy.getElementById( data.target );

      src._private.edges.push( edge );
      tgt._private.edges.push( edge );

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge

    // create mock ids / indexes maps for element so it can be used like collections
    _private.map = new Map();
    _private.map.set( id, { ele: ele, index: 0 } );

    _private.removed = false;
    cy.addToPool( ele );
  } // for each element

  // do compound node sanity checks
  for( var i = 0; i < nodes.length; i++ ){ // each node
    var node = nodes[ i ];
    var data = node._private.data;

    if( is.number( data.parent ) ){ // then automake string
      data.parent = '' + data.parent;
    }

    var parentId = data.parent;

    var specifiedParent = parentId != null;

    if( specifiedParent ){
      var parent = cy.getElementById( parentId );

      if( parent.empty() ){
        // non-existant parent; just remove it
        data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while( !ancestor.empty() ){
          if( node.same( ancestor ) ){
            // mark self as parent and remove from data
            selfAsParent = true;
            data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if( !selfAsParent ){
          // connect with children
          parent[0]._private.children.push( node );
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy_p.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  if( elements.length > 0 ){
    var restored = new Collection( cy, elements );

    for( var i = 0; i < restored.length; i++ ){
      var ele = restored[i];

      if( ele.isNode() ){ continue; }

      // adding an edge invalidates the traversal caches for the parallel edges
      var pedges = ele.parallelEdges().clearTraversalCache();

      // adding an edge invalidates the traversal cache for the connected nodes
      ele.source().clearTraversalCache();
      ele.target().clearTraversalCache();
    }

    var toUpdateStyle;

    if( cy_p.hasCompoundNodes ){
      toUpdateStyle = cy.collection().merge( restored ).merge( restored.connectedNodes() ).merge( restored.parent() );
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.updateStyle( notifyRenderer );

    if( notifyRenderer ){
      restored.rtrigger( 'add' );
    } else {
      restored.trigger( 'add' );
    }
  }

  return self; // chainability
};

elesfn.removed = function(){
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function(){
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function( notifyRenderer ){
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges( node ){
    var edges = node._private.edges;
    for( var i = 0; i < edges.length; i++ ){
      add( edges[ i ] );
    }
  }


  // add descendant nodes
  function addChildren( node ){
    var children = node._private.children;

    for( var i = 0; i < children.length; i++ ){
      add( children[ i ] );
    }
  }

  function add( ele ){
    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
    if( alreadyAdded ){
      return;
    } else {
      elesToRemoveIds[ ele.id() ] = true;
    }

    if( ele.isNode() ){
      elesToRemove.push( ele ); // nodes are removed last

      addConnectedEdges( ele );
      addChildren( ele );
    } else {
      elesToRemove.unshift( ele ); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    add( ele );
  }

  function removeEdgeRef( node, edge ){
    var connectedEdges = node._private.edges;

    util.removeFromArray( connectedEdges, edge );

    // removing an edges invalidates the traversal cache for its nodes
    node.clearTraversalCache();
  }

  function removeParallelRefs( edge ){
    // removing an edge invalidates the traversal caches for the parallel edges
    edge.parallelEdges().clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef( parent, ele ){
    ele = ele[0];
    parent = parent[0];

    var children = parent._private.children;
    var pid = parent.id();

    util.removeFromArray( children, ele );

    if( !alteredParents.ids[ pid ] ){
      alteredParents.ids[ pid ] = true;
      alteredParents.push( parent );
    }
  }

  // remove from core pool
  cy.removeFromPool( elesToRemove );

  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[ i ];

    // mark as removed
    ele._private.removed = true;

    // add to list of removed elements
    removed.push( ele );

    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
      var src = ele.source()[0];
      var tgt = ele.target()[0];

      removeEdgeRef( src, ele );
      removeEdgeRef( tgt, ele );
      removeParallelRefs( ele );

    } else { // remove reference to parent
      var parent = ele.parent();

      if( parent.length !== 0 ){
        removeChildRef( parent, ele );
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for( var i = 0; i < elesStillInside.length; i++ ){
    var ele = elesStillInside[ i ];

    if( ele.isParent() ){
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection( this.cy(), removed );
  if( removedElements.size() > 0 ){
    // must manually notify since trigger won't do this automatically once removed

    if( notifyRenderer ){
      this.cy().notify( {
        type: 'remove',
        eles: removedElements
      } );
    }

    removedElements.trigger( 'remove' );
  }

  // the parents who were modified by the removal need their style updated
  for( var i = 0; i < alteredParents.length; i++ ){
    var ele = alteredParents[ i ];

    if( !ele.removed() ){
      ele.updateStyle();
    }
  }

  return new Collection( cy, removed );
};

elesfn.move = function( struct ){
  var cy = this._private.cy;

  if( struct.source !== undefined || struct.target !== undefined ){
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.hasElementWithId( srcId );
    var tgtExists = cy.hasElementWithId( tgtId );

    if( srcExists || tgtExists ){
      var jsons = this.jsons();

      this.remove();

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'edges' ){
          if( srcExists ){ json.data.source = srcId; }

          if( tgtExists ){ json.data.target = tgtId; }

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons );
    }

  } else if( struct.parent !== undefined ){ // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.hasElementWithId( parentId );

    if( parentExists ){
      var jsons = this.jsons();
      var descs = this.descendants();
      var descsEtcJsons = descs.union( descs.union( this ).connectedEdges() ).jsons();

      this.remove(); // NB: also removes descendants and their connected edges

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'nodes' ){
          json.data.parent = parentId === null ? undefined : parentId;

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons.concat( descsEtcJsons ) );
    }
  }

  return this; // if nothing done
};

[
  _dereq_( './algorithms' ),
  _dereq_( './animation' ),
  _dereq_( './class' ),
  _dereq_( './comparators' ),
  _dereq_( './compounds' ),
  _dereq_( './data' ),
  _dereq_( './degree' ),
  _dereq_( './dimensions' ),
  _dereq_( './events' ),
  _dereq_( './filter' ),
  _dereq_( './group' ),
  _dereq_( './index' ),
  _dereq_( './iteration' ),
  _dereq_( './layout' ),
  _dereq_( './style' ),
  _dereq_( './switch-functions' ),
  _dereq_( './traversing' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = Collection;

},{"../is":82,"../map":83,"../set":87,"../util":99,"./algorithms":11,"./animation":15,"./class":16,"./comparators":17,"./compounds":18,"./data":19,"./degree":20,"./dimensions":21,"./element":22,"./events":23,"./filter":24,"./group":25,"./index":26,"./iteration":27,"./layout":28,"./style":29,"./switch-functions":30,"./traversing":31}],27:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var zIndexSort = _dereq_( './zsort' );

var elesfn = ({
  forEach: function( fn, thisArg ){
    if( is.fn( fn ) ){

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

        if( ret === false ){ break; } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function(){
    var array = [];

    for( var i = 0; i < this.length; i++ ){
      array.push( this[ i ] );
    }

    return array;
  },

  slice: function( start, end ){
    var array = [];
    var thisSize = this.length;

    if( end == null ){
      end = thisSize;
    }

    if( start == null ){
      start = 0;
    }

    if( start < 0 ){
      start = thisSize + start;
    }

    if( end < 0 ){
      end = thisSize + end;
    }

    for( var i = start; i >= 0 && i < end && i < thisSize; i++ ){
      array.push( this[ i ] );
    }

    return this.spawn( array );
  },

  size: function(){
    return this.length;
  },

  eq: function( i ){
    return this[ i ] || this.spawn();
  },

  first: function(){
    return this[0] || this.spawn();
  },

  last: function(){
    return this[ this.length - 1 ] || this.spawn();
  },

  empty: function(){
    return this.length === 0;
  },

  nonempty: function(){
    return !this.empty();
  },

  sort: function( sortFn ){
    if( !is.fn( sortFn ) ){
      return this;
    }

    var sorted = this.toArray().sort( sortFn );

    return this.spawn( sorted );
  },

  sortByZIndex: function(){
    return this.sort( zIndexSort );
  },

  zDepth: function(){
    var ele = this[0];
    if( !ele ){ return undefined; }

    // var cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if( group === 'nodes' ){
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if( !ele.isParent() ){
        return Number.MAX_SAFE_INTEGER - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
    }
  }
});

elesfn.each = elesfn.forEach;

module.exports = elesfn;

},{"../is":82,"./zsort":32}],28:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var util = _dereq_( '../util' );
var Promise = _dereq_('../promise');
var math = _dereq_('../math');

var elesfn = ({

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function( layout, options, fn ){
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges

    // memoized version of position function
    var fnMem = util.memoize( fn, function( node, i ){
      return node.id() + '$' + i;
    } );

    layout.trigger( { type: 'layoutstart', layout: layout } );

    layout.animations = [];

    var calculateSpacing = function( spacing, nodesBb, pos ){
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };

      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };

      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var spacingBb = function(){
      var bb = math.makeBoundingBox();

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var pos = fnMem( node, i );

        math.expandBoundingBoxByPoint( bb, pos.x, pos.y );
      }

      return bb;
    };

    if( options.animate ){
      var bb = spacingBb();

      var finalPos = {};

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var newPos = fnMem( node, i );
        var pos = node.position();

        if( !is.number( pos.x ) || !is.number( pos.y ) ){
          node.silentPosition( { x: 0, y: 0 } );
        }

        if( options.spacingFactor && options.spacingFactor !== 1 ){
          var spacing = Math.abs( options.spacingFactor );

          newPos = calculateSpacing( spacing, bb, newPos );
        }

        finalPos[ node.id() ] = newPos;
      }

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var newPos = finalPos[ node.id() ];

        var ani = node.animation( {
          position: newPos,
          duration: options.animationDuration,
          easing: options.animationEasing
        } );

        layout.animations.push( ani );

        ani.play();
      }

      if( options.fit ){
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(function( i, node ){
              return finalPos[ node.id() ];
            }),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push( fitAni );

        fitAni.play();
      } else if( options.zoom !== undefined && options.pan !== undefined ){
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push( zoomPanAni );

        zoomPanAni.play();
      }

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      Promise.all( layout.animations.map(function( ani ){
        return ani.promise();
      }) ).then(function(){
        layout.one( 'layoutstop', options.stop );
        layout.trigger( { type: 'layoutstop', layout: layout } );
      });
    } else {
      if( options.spacingFactor && options.spacingFactor !== 1 ){
        var spacing = Math.abs( options.spacingFactor );
        var bb = spacingBb();

        nodes.positions( function( node, i ){
          var pos = fnMem( node, i );

          return calculateSpacing( spacing, bb, pos );
        });
      } else {
        nodes.positions( fn );
      }

      if( options.fit ){
        cy.fit( options.eles, options.padding );
      }

      if( options.zoom != null ){
        cy.zoom( options.zoom );
      }

      if( options.pan ){
        cy.pan( options.pan );
      }

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      layout.one( 'layoutstop', options.stop );
      layout.trigger( { type: 'layoutstop', layout: layout } );
    }

    return this; // chaining
  },

  layout: function( options ){
    var cy = this.cy();

    return cy.makeLayout( util.extend( {}, options, {
      eles: this
    } ) );
  }

});

// aliases:
elesfn.createLayout = elesfn.makeLayout = elesfn.layout;

module.exports = elesfn;

},{"../is":82,"../math":84,"../promise":85,"../util":99}],29:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );

var elesfn = ({

  // fully updates (recalculates) the style for the elements
  updateStyle: function( notifyRenderer ){
    var cy = this._private.cy;

    if( !cy.styleEnabled() ){ return this; }

    if( cy._private.batchingStyle ){
      var bEles = cy._private.batchStyleEles;

      bEles.merge( this );

      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;

    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( hasCompounds ){ // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge( this.descendants() ).merge( this.parents() );
    }

    var changedEles = style.apply( updatedEles );

    if( notifyRenderer ){
      changedEles.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      changedEles.trigger( 'style' ); // just fire the event
    }

    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function( notifyRenderer ){
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( !cy.styleEnabled() ){ return this; }

    var changedEles = style.updateMappers( this );

    this.dirtyCompoundBoundsCache( notifyRenderer );

    if( notifyRenderer ){
      changedEles.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      changedEles.trigger( 'style' ); // just fire the event
    }
    return this; // chaining
  },

  // get the internal parsed style object for the specified property
  parsedStyle: function( property ){
    var ele = this[0];
    var cy = ele.cy();

    if( !cy.styleEnabled() ){ return; }

    if( ele ){
      return ele._private.style[ property ] || cy.style().getDefaultProperty( property );
    }
  },

  numericStyle: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      var pstyle = ele.pstyle( property );

      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },

  numericStyleUnits: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      return ele.pstyle( property ).units;
    }
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function( property ){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return this; }

    var ele = this[0];

    if( ele ){
      return cy.style().getRenderedStyle( ele, property );
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  style: function( name, value ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();

    if( is.plainObject( name ) ){ // then extend the bypass
      var props = name;
      style.applyBypass( this, props, updateTransitions );

      this.dirtyCompoundBoundsCache();

      this.rtrigger( 'style' ); // let the renderer know we've updated style

    } else if( is.string( name ) ){

      if( value === undefined ){ // then get the property from the style
        var ele = this[0];

        if( ele ){
          return style.getStylePropertyValue( ele, name );
        } else { // empty collection => can't get any value
          return;
        }

      } else { // then set the bypass with the property value
        style.applyBypass( this, name, value, updateTransitions );

        this.dirtyCompoundBoundsCache();

        this.rtrigger( 'style' ); // let the renderer know we've updated style
      }

    } else if( name === undefined ){
      var ele = this[0];

      if( ele ){
        return style.getRawStyle( ele );
      } else { // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeStyle: function( names ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if( names === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeAllBypasses( ele, updateTransitions );
      }
    } else {
      names = names.split( /\s+/ );

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeBypasses( ele, names, updateTransitions );
      }
    }

    this.dirtyCompoundBoundsCache();

    this.rtrigger( 'style' ); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function(){
    this.css( 'display', 'element' );
    return this; // chaining
  },

  hide: function(){
    this.css( 'display', 'none' );
    return this; // chaining
  },

  effectiveOpacity: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return 1; }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if( ele ){
      var _p = ele._private;
      var parentOpacity = ele.pstyle( 'opacity' ).value;

      if( !hasCompoundNodes ){ return parentOpacity; }

      var parents = !_p.data.parent ? null : ele.parents();

      if( parents ){
        for( var i = 0; i < parents.length; i++ ){
          var parent = parents[ i ];
          var opacity = parent.pstyle( 'opacity' ).value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if( ele ){
      if( !hasCompoundNodes ){
        return ele.pstyle( 'opacity' ).value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  backgrounding: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

});

function defineDerivedStateFunction( specs ){
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;

  return function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return true; }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele ){
      var _p = ele._private;

      if( !ok( ele ) ){ return false; }

      if( ele.isNode() ){
        if( hasCompoundNodes ){
          var parents = _p.data.parent ? ele.parents() : null;

          if( parents ){ for( var i = 0; i < parents.length; i++ ){
            var parent = parents[ i ];

            if( !parentOk( parent ) ){ return false; }
          } }
        }

        return true;
      } else {
        return edgeOkViaNode( _p.source ) && edgeOkViaNode( _p.target );
      }
    }
  }
}

var eleTakesUpSpace = function( ele ){
  return (
    ele.pstyle( 'display' ).value === 'element'
    && ele.width() !== 0
    && ( ele.isNode() ? ele.height() !== 0 : true )
  );
};

elesfn.takesUpSpace = defineDerivedStateFunction({
  ok: eleTakesUpSpace
});

var eleInteractive = function( ele ){
  return (
    ele.pstyle('events').value === 'yes'
    && ele.pstyle('visibility').value === 'visible'
    && eleTakesUpSpace( ele )
  );
};

var parentInteractive = function( parent ){
  return (
    parent.pstyle('visibility').value === 'visible'
    && eleTakesUpSpace( parent )
  );
};

elesfn.interactive = defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
});

elesfn.noninteractive = function(){
  var ele = this[0];

  if( ele ){
    return !ele.interactive();
  }
};

var eleVisible = function( ele ){
  return (
    ele.pstyle( 'visibility' ).value === 'visible'
    && ele.pstyle( 'opacity' ).pfValue !== 0
    && eleTakesUpSpace( ele )
  );
};

var edgeVisibleViaNode = eleTakesUpSpace;

elesfn.visible = defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
});

elesfn.hidden = function(){
  var ele = this[0];

  if( ele ){
    return !ele.visible();
  }
};


elesfn.bypass = elesfn.css = elesfn.style;
elesfn.renderedCss = elesfn.renderedStyle;
elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
elesfn.pstyle = elesfn.parsedStyle;

module.exports = elesfn;

},{"../is":82}],30:[function(_dereq_,module,exports){
'use strict';

var elesfn = {};

function defineSwitchFunction( params ){
  return function(){
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if( args.length === 2 ){
      var data = args[0];
      var handler = args[1];
      this.on( params.event, data, handler );
    }

    // e.g. cy.nodes().select( handler )
    else if( args.length === 1 ){
      var handler = args[0];
      this.on( params.event, handler );
    }

    // e.g. cy.nodes().select()
    else if( args.length === 0 ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var able = !params.ableField || ele._private[ params.ableField ];
        var changed = ele._private[ params.field ] != params.value;

        if( params.overrideAble ){
          var overrideAble = params.overrideAble( ele );

          if( overrideAble !== undefined ){
            able = overrideAble;

            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
          }
        }

        if( able ){
          ele._private[ params.field ] = params.value;

          if( changed ){
            changedEles.push( ele );
          }
        }
      }

      var changedColl = this.spawn( changedEles );
      changedColl.updateStyle(); // change of state => possible change of style
      changedColl.trigger( params.event );
    }

    return this;
  };
}

function defineSwitchSet( params ){
  elesfn[ params.field ] = function(){
    var ele = this[0];

    if( ele ){
      if( params.overrideField ){
        var val = params.overrideField( ele );

        if( val !== undefined ){
          return val;
        }
      }

      return ele._private[ params.field ];
    }
  };

  elesfn[ params.on ] = defineSwitchFunction( {
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  } );

  elesfn[ params.off ] = defineSwitchFunction( {
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  } );
}

defineSwitchSet( {
  field: 'locked',
  overrideField: function( ele ){
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
} );

defineSwitchSet( {
  field: 'grabbable',
  overrideField: function( ele ){
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
} );

defineSwitchSet( {
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
} );

defineSwitchSet( {
  field: 'selectable',
  overrideField: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
} );

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function(){
  var ele = this[0];
  if( ele ){
    return ele._private.grabbed;
  }
};

defineSwitchSet( {
  field: 'active',
  on: 'activate',
  off: 'unactivate'
} );

elesfn.inactive = function(){
  var ele = this[0];
  if( ele ){
    return !ele._private.active;
  }
};

module.exports = elesfn;

},{}],31:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var elesfn = {};

var cache = function( fn, name ){
  return function traversalCache( arg1, arg2, arg3, arg4 ){
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if( selectorOrEles == null ){
      key = 'null';
    } else if( is.elementOrCollection( selectorOrEles ) && selectorOrEles.length === 1 ){
      key = '#' + selectorOrEles.id();
    }

    if( eles.length === 1 && key ){
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[ name ] = tch[ name ] || {};
      var cacheHit = ch[ key ];

      if( cacheHit ){
        return cacheHit;
      } else {
        return ( ch[ key ] = fn.call( eles, arg1, arg2, arg3, arg4 ) );
      }
    } else {
      return fn.call( eles, arg1, arg2, arg3, arg4 );
    }
  };
};

// DAG functions
////////////////

var defineDagExtremity = function( params ){
  return function dagExtremityImpl( selector ){
    var eles = this;
    var ret = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      if( !ele.isNode() ){
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if(
             ( params.noIncomingEdges && tgt === ele && src !== ele )
          || ( params.noOutgoingEdges && src === ele && tgt !== ele )
        ){
          disqualified = true;
          break;
        }
      }

      if( !disqualified ){
        ret.push( ele );
      }
    }

    return this.spawn( ret, { unique: true } ).filter( selector );
  };
};

var defineDagOneHop = function( params ){
  return function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];

      if( !ele.isNode() ){ continue; }

      var edges = ele.connectedEdges();
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        var src = edge.source();
        var tgt = edge.target();

        if( params.outgoing && src === ele ){
          oEles.push( edge );
          oEles.push( tgt );
        } else if( params.incoming && tgt === ele ){
          oEles.push( edge );
          oEles.push( src );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  };
};

var defineDagAllHops = function( params ){
  return function( selector ){
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for( ;; ){
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if( next.length === 0 ){ break; } // done if none left

      var newNext = false;
      for( var i = 0; i < next.length; i++ ){
        var n = next[ i ];
        var nid = n.id();

        if( !sElesIds[ nid ] ){
          sElesIds[ nid ] = true;
          sEles.push( n );
          newNext = true;
        }
      }

      if( !newNext ){ break; } // done if touched all outgoers already

      eles = next;
    }

    return this.spawn( sEles, { unique: true } ).filter( selector );
  };
};

elesfn.clearTraversalCache = function( ){
  for( var i = 0; i < this.length; i++ ){
    this[i]._private.traversalCache = null;
  }
};

util.extend( elesfn, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({ noIncomingEdges: true }),

  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({ noOutgoingEdges: true }),

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache( defineDagOneHop({ outgoing: true }) , 'outgoers' ),

  // aka DAG descendants
  successors: defineDagAllHops({ outgoing: true }),

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache( defineDagOneHop({ incoming: true }), 'incomers' ),

  // aka DAG ancestors
  predecessors: defineDagAllHops({ incoming: true })
} );


// Neighbourhood functions
//////////////////////////

util.extend( elesfn, {
  neighborhood: cache(function( selector ){
    var elements = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
      var node = nodes[ i ];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for( var j = 0; j < connectedEdges.length; j++ ){
        var edge = connectedEdges[ j ];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if( otherNode.length > 0 ){
          elements.push( otherNode[0] ); // add node 1 hop away
        }

        // add connected edge
        elements.push( edge[0] );
      }

    }

    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
  }, 'neighborhood'),

  closedNeighborhood: function( selector ){
    return this.neighborhood().add( this ).filter( selector );
  },

  openNeighborhood: function( selector ){
    return this.neighborhood( selector );
  }
} );

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend( elesfn, {
  source: cache(function sourceImpl( selector ){
    var ele = this[0];
    var src;

    if( ele ){
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter( selector ) : src;
  }, 'source'),

  target: cache(function targetImpl( selector ){
    var ele = this[0];
    var tgt;

    if( ele ){
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter( selector ) : tgt;
  }, 'target'),

  sources: defineSourceFunction( {
    attr: 'source'
  } ),

  targets: defineSourceFunction( {
    attr: 'target'
  } )
} );

function defineSourceFunction( params ){
  return function sourceImpl( selector ){
    var sources = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var src = ele._private[ params.attr ];

      if( src ){
        sources.push( src );
      }
    }

    return this.spawn( sources, { unique: true } ).filter( selector );
  };
}

util.extend( elesfn, {
  edgesWith: cache( defineEdgesWithFunction(), 'edgesWith', true ),

  edgesTo: cache( defineEdgesWithFunction( {
    thisIsSrc: true
  } ), 'edgesTo', true )
} );

function defineEdgesWithFunction( params ){

  return function edgesWithImpl( otherNodes ){
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if( is.string( otherNodes ) ){
      otherNodes = cy.$( otherNodes );
    }

    for( var h = 0; h < otherNodes.length; h++ ){
      var edges = otherNodes[ h ]._private.edges;

      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[ i ];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId( edgeData.source ) && otherNodes.hasElementWithId( edgeData.target );
        var otherToThis = otherNodes.hasElementWithId( edgeData.source ) && this.hasElementWithId( edgeData.target );
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if( !edgeConnectsThisAndOther ){ continue; }

        if( p.thisIsSrc || p.thisIsTgt ){
          if( p.thisIsSrc && !thisToOther ){ continue; }

          if( p.thisIsTgt && !otherToThis ){ continue; }
        }

        elements.push( edge );
      }
    }

    return this.spawn( elements, { unique: true } );
  };
}

util.extend( elesfn, {
  connectedEdges: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var node = eles[ i ];
      if( !node.isNode() ){ continue; }

      var edges = node._private.edges;

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        retEles.push( edge );
      }
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedEdges'),

  connectedNodes: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var edge = eles[ i ];
      if( !edge.isEdge() ){ continue; }

      retEles.push( edge.source()[0] );
      retEles.push( edge.target()[0] );
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedNodes'),

  parallelEdges: cache( defineParallelEdgesFunction(), 'parallelEdges' ),

  codirectedEdges: cache( defineParallelEdgesFunction( {
    codirected: true
  } ), 'codirectedEdges' )
} );

function defineParallelEdgesFunction( params ){
  var defaults = {
    codirected: false
  };
  params = util.extend( {}, defaults, params );

  return function parallelEdgesImpl( selector ){ // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for( var i = 0; i < edges.length; i++ ){
      var edge1 = edges[ i ];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for( var j = 0; j < srcEdges1.length; j++ ){
        var edge2 = srcEdges1[ j ];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
          elements.push( edge2 );
        }
      }
    }

    return this.spawn( elements, { unique: true } ).filter( selector );
  };

}

// Misc functions
/////////////////

util.extend( elesfn, {
  components: function(){
    var self = this;
    var cy = self.cy();
    var visited = self.spawn();
    var unvisited = self.nodes().spawnSelf();
    var components = [];

    var visitInComponent = function( node, component ){
      visited.merge( node );
      unvisited.unmerge( node );
      component.merge( node );
    };

    if( unvisited.empty() ){ return self.spawn(); }

    do {
      var component = cy.collection();
      components.push( component );

      var root = unvisited[0];
      visitInComponent( root, component );

      self.bfs({
        directed: false,
        roots: root,
        visit: function( v, e, u, i, depth ){
          visitInComponent( v, component );
        }
      } );

    } while( unvisited.length > 0 );

    return components.map(function( component ){
      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){
        return component.anySame( edge.source() ) && component.anySame( edge.target() );
      });

      return component.union( connectedEdges );
    });
  }
} );

module.exports = elesfn;

},{"../is":82,"../util":99}],32:[function(_dereq_,module,exports){
'use strict';

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */
var zIndexSort = function( a, b ){
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele){
    var style = ele.pstyle( 'z-compound-depth' );
    if ( style.value === 'auto' ){
      return hasCompoundNodes ? ele.zDepth() : 0
    } else if ( style.value === 'bottom' ){
      return -1
    } else if ( style.value === 'top' ){
      return Number.MAX_SAFE_INTEGER
    }
    // 'orphan'
    return 0
  }
  var depthDiff = getDepth(a) - getDepth(b);
  if ( depthDiff !== 0 ){
    return depthDiff
  }

  function getEleDepth(ele){
    var style = ele.pstyle( 'z-index-compare' );
    if ( style.value === 'auto' ){
      return ele.isNode() ? 1 : 0
    }
    // 'manual'
    return 0
  }
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if ( eleDiff !== 0 ){
    return eleDiff
  }

  var zDiff = a.pstyle( 'z-index' ).value - b.pstyle( 'z-index' ).value;
  if ( zDiff !== 0 ){
    return zDiff
  }
  // compare indices in the core (order added to graph w/ last on top)
  return a.poolIndex() - b.poolIndex();
};

module.exports = zIndexSort;

},{}],33:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var util = _dereq_( '../util' );
var Collection = _dereq_( '../collection' );
var Element = _dereq_( '../collection/element' );

var corefn = {
  add: function( opts ){

    var elements;
    var cy = this;

    // add the elements
    if( is.elementOrCollection( opts ) ){
      var eles = opts;

      if( eles._private.cy === cy ){ // same instance => just restore
        elements = eles.restore();

      } else { // otherwise, copy from json
        var jsons = [];

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[ i ];
          jsons.push( ele.json() );
        }

        elements = new Collection( cy, jsons );
      }
    }

    // specify an array of options
    else if( is.array( opts ) ){
      var jsons = opts;

      elements = new Collection( cy, jsons );
    }

    // specify via opts.nodes and opts.edges
    else if( is.plainObject( opts ) && (is.array( opts.nodes ) || is.array( opts.edges )) ){
      var elesByGroup = opts;
      var jsons = [];

      var grs = [ 'nodes', 'edges' ];
      for( var i = 0, il = grs.length; i < il; i++ ){
        var group = grs[ i ];
        var elesArray = elesByGroup[ group ];

        if( is.array( elesArray ) ){

          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
            var json = util.extend( { group: group }, elesArray[ j ] );

            jsons.push( json );
          }
        }
      }

      elements = new Collection( cy, jsons );
    }

    // specify options for one element
    else {
      var json = opts;
      elements = (new Element( cy, json )).collection();
    }

    return elements;
  },

  remove: function( collection ){
    if( is.elementOrCollection( collection ) ){
      // already have right ref
    } else if( is.string( collection ) ){
      var selector = collection;
      collection = this.$( selector );
    }

    return collection.remove();
  }
};

module.exports = corefn;

},{"../collection":26,"../collection/element":22,"../is":82,"../util":99}],34:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );
var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var corefn = ({

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function( eles ){
    var cy = this;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    cy._private.aniEles.merge( eles );
  },

  stopAnimationLoop: function(){
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function(){
    var cy = this;

    cy._private.animationsRunning = true;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function globalAnimationStep(){
      if( !cy._private.animationsRunning ){ return; }

      util.requestAnimationFrame( function animationStep( now ){
        handleElements( now );
        globalAnimationStep();
      } );
    }

    var renderer = cy.renderer();

    if( renderer && renderer.beforeRender ){ // let the renderer schedule animations
      renderer.beforeRender( function rendererAnimationStep( willDraw, now ){
        handleElements( now );
      }, renderer.beforeRenderPriorities.animations );
    } else { // manage the animation loop ourselves
      globalAnimationStep(); // first call
    }

    function handleElements( now ){
      var eles = cy._private.aniEles;
      var doneEles = [];

      function handleElement( ele, isCore ){
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false;

        // cancel all animations on display:none ele
        if( !isCore && ele.pstyle('display').value === 'none' ){
          // put all current and queue animations in this tick's current list
          // and empty the lists for the element
          current = current.splice( 0, current.length ).concat( queue.splice( 0, queue.length ) );

          // stop all animations
          for( var i = 0; i < current.length; i++ ){ current[i].stop(); }
        }

        // if nothing currently animating, get something from the queue
        if( current.length === 0 ){
          var next = queue.shift();

          if( next ){
            current.push( next );
          }
        }

        var callbacks = function( callbacks ){
          for( var j = callbacks.length - 1; j >= 0; j-- ){
            var cb = callbacks[ j ];

            cb();
          }

          callbacks.splice( 0, callbacks.length );
        };

        // step and remove if done
        for( var i = current.length - 1; i >= 0; i-- ){
          var ani = current[ i ];
          var ani_p = ani._private;

          if( ani_p.stopped ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.frames );

            continue;
          }

          if( !ani_p.playing && !ani_p.applying ){ continue; }

          // an apply() while playing shouldn't do anything
          if( ani_p.playing && ani_p.applying ){
            ani_p.applying = false;
          }

          if( !ani_p.started ){
            startAnimation( ele, ani, now );
          }

          step( ele, ani, now, isCore );

          if( ani_p.applying ){
            ani_p.applying = false;
          }

          callbacks( ani_p.frames );

          if( ani.completed() ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.completes );
          }

          ranAnis = true;
        }

        if( !isCore && current.length === 0 && queue.length === 0 ){
          doneEles.push( ele );
        }

        return ranAnis;
      } // handleElement

      // handle all eles
      var ranEleAni = false;
      for( var e = 0; e < eles.length; e++ ){
        var ele = eles[ e ];
        var handledThisEle = handleElement( ele );

        ranEleAni = ranEleAni || handledThisEle;
      } // each element

      var ranCoreAni = handleElement( cy, true );

      // notify renderer
      if( ranEleAni || ranCoreAni ){
        if( eles.length > 0 ){
          eles.dirtyCompoundBoundsCache();

          cy.notify({
            type: 'draw',
            eles: eles
          });
        } else {
          cy.notify({
            type: 'draw'
          });
        }
      }

      // remove elements from list of currently animating if its queues are empty
      eles.unmerge( doneEles );

      cy.trigger('step');

    } // handleElements

    function startAnimation( self, ani, now ){
      var isCore = is.core( self );
      var isEles = !isCore;
      var ele = self;
      var style = cy._private.style;
      var ani_p = ani._private;

      if( isEles ){
        var pos = ele._private.position;

        ani_p.startPosition = ani_p.startPosition || {
          x: pos.x,
          y: pos.y
        };

        ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle( ele, ani_p.style );
      }

      if( isCore ){
        var pan = cy._private.pan;

        ani_p.startPan = ani_p.startPan || {
          x: pan.x,
          y: pan.y
        };

        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
      }

      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }

    function step( self, ani, now, isCore ){
      var style = cy._private.style;
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;

      if( !ani_p.easingImpl ){

        if( pEasing == null ){ // use default
          ani_p.easingImpl = easings[ 'linear' ];

        } else { // then define w/ name
          var easingVals;

          if( is.string( pEasing ) ){
            var easingProp = style.parse( 'transition-timing-function', pEasing );

            easingVals = easingProp.value;

          } else { // then assume preparsed array
            easingVals = pEasing;
          }

          var name, args;

          if( is.string( easingVals ) ){
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice( 2 ).map( function( n ){ return +n; } );
          }

          if( args.length > 0 ){ // create with args
            if( name === 'spring' ){
              args.push( ani_p.duration ); // need duration to generate spring
            }

            ani_p.easingImpl = easings[ name ].apply( null, args );
          } else { // static impl by name
            ani_p.easingImpl = easings[ name ];
          }
        }

      }

      var easing = ani_p.easingImpl;
      var percent;

      if( ani_p.duration === 0 ){
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }

      if( ani_p.applying ){
        percent = ani_p.progress;
      }

      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( ani_p.delay == null ){ // then update

        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        var pos = _p.position;
        if( endPos && isEles ){
          if( valid( startPos.x, endPos.x ) ){
            pos.x = ease( startPos.x, endPos.x, percent, easing );
          }

          if( valid( startPos.y, endPos.y ) ){
            pos.y = ease( startPos.y, endPos.y, percent, easing );
          }

          self.trigger('position');
        }

        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if( animatingPan ){
          if( valid( startPan.x, endPan.x ) ){
            pan.x = ease( startPan.x, endPan.x, percent, easing );
          }

          if( valid( startPan.y, endPan.y ) ){
            pan.y = ease( startPan.y, endPan.y, percent, easing );
          }

          self.trigger( 'pan' );
        }

        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if( animatingZoom ){
          if( valid( startZoom, endZoom ) ){
            _p.zoom = ease( startZoom, endZoom, percent, easing );
          }

          self.trigger( 'zoom' );
        }

        if( animatingPan || animatingZoom ){
          self.trigger( 'viewport' );
        }

        var props = ani_p.style;
        if( props && props.length > 0 && isEles ){
          for( var i = 0; i < props.length; i++ ){
            var prop = props[ i ];
            var name = prop.name;
            var end = prop;

            var start = ani_p.startStyle[ name ];
            var easedVal = ease( start, end, percent, easing );

            style.overrideBypass( self, name, easedVal );
          } // for props

          self.trigger('style');

        } // if

      }

      ani_p.progress = percent;

      return percent;
    }

    function valid( start, end ){
      if( start == null || end == null ){
        return false;
      }

      if( is.number( start ) && is.number( end ) ){
        return true;
      } else if( (start) && (end) ){
        return true;
      }

      return false;
    }

    // assumes p0 = 0, p3 = 1
    function evalCubicBezier( p1, p2, t ){
      var one_t = 1 - t;
      var tsq = t * t;

      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
    }

    function cubicBezier( p1, p2 ){
      return function( start, end, percent ){
        return start + (end - start) * evalCubicBezier( p1, p2, percent );
      };
    }

    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function(){
      function springAccelerationForState( state ){
        return (-state.tension * state.x) - (state.friction * state.v);
      }

      function springEvaluateStateWithDerivative( initialState, dt, derivative ){
        var state = {
          x: initialState.x + derivative.dx * dt,
          v: initialState.v + derivative.dv * dt,
          tension: initialState.tension,
          friction: initialState.friction
        };

        return { dx: state.v, dv: springAccelerationForState( state ) };
      }

      function springIntegrateState( state, dt ){
        var a = {
          dx: state.v,
          dv: springAccelerationForState( state )
        },
        b = springEvaluateStateWithDerivative( state, dt * 0.5, a ),
        c = springEvaluateStateWithDerivative( state, dt * 0.5, b ),
        d = springEvaluateStateWithDerivative( state, dt, c ),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;

        return state;
      }

      return function springRK4Factory( tension, friction, duration ){

        var initState = {
          x: -1,
          v: 0,
          tension: null,
          friction: null
        },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration, dt, last_state;

        tension = parseFloat( tension ) || 500;
        friction = parseFloat( friction ) || 20;
        duration = duration || null;

        initState.tension = tension;
        initState.friction = friction;

        have_duration = duration !== null;

        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
        if( have_duration ){
          /* Run the simulation without a duration. */
          time_lapsed = springRK4Factory( tension, friction );
          /* Compute the adjusted time delta. */
          dt = time_lapsed / duration * DT;
        } else {
          dt = DT;
        }

        while( true ){
          /* Next/step function .*/
          last_state = springIntegrateState( last_state || initState, dt );
          /* Store the position. */
          path.push( 1 + last_state.x );
          time_lapsed += 16;
          /* If the change threshold is reached, break. */
          if( !(Math.abs( last_state.x ) > tolerance && Math.abs( last_state.v ) > tolerance) ){
            break;
          }
        }

        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
           computed path and returns a snapshot of the position according to a given percentComplete. */
        return !have_duration ? time_lapsed : function( percentComplete ){ return path[ (percentComplete * (path.length - 1)) | 0 ]; };
      };
    }());

    var easings = {
      'linear': function( start, end, percent ){
        return start + (end - start) * percent;
      },

      // default easings
      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),

      // sine
      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),

      // quad
      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),

      // cubic
      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),

      // quart
      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),

      // quint
      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),

      // expo
      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),

      // circ
      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),


      // user param easings...

      'spring': function( tension, friction, duration ){
        if( duration === 0 ){ // can't get a spring w/ duration 0
          return easings.linear; // duration 0 => jump to end so impl doesn't matter
        }

        var spring = generateSpringRK4( tension, friction, duration );

        return function( start, end, percent ){
          return start + (end - start) * spring( percent );
        };
      },

      'cubic-bezier': function( x1, y1, x2, y2 ){
        return cubicBezier( x1, y1, x2, y2 );
      }
    };

    function ease( startProp, endProp, percent, easingFn ){
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      var start, end;

      if( startProp.pfValue != null || startProp.value != null ){
        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
      } else {
        start = startProp;
      }

      if( endProp.pfValue != null || endProp.value != null ){
        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
      } else {
        end = endProp;
      }

      if( is.number( start ) && is.number( end ) ){
        return easingFn( start, end, percent );

      } else if( is.array( start ) && is.array( end ) ){
        var easedArr = [];

        for( var i = 0; i < end.length; i++ ){
          var si = start[ i ];
          var ei = end[ i ];

          if( si != null && ei != null ){
            var val = easingFn( si, ei, percent );

            if( startProp.roundValue ){ val = Math.round( val ); }

            easedArr.push( val );
          } else {
            easedArr.push( ei );
          }
        }

        return easedArr;
      }

      return undefined;
    }

  }

});

module.exports = corefn;

},{"../define":44,"../is":82,"../util":99}],35:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_( '../define' );

var corefn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger() // .trigger( events [, extraParams] )
});

define.eventAliasesOn( corefn );

module.exports = corefn;

},{"../define":44}],36:[function(_dereq_,module,exports){
'use strict';

var corefn = ({

  png: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png( options );
  },

  jpg: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg( options );
  }

});

corefn.jpeg = corefn.jpg;

module.exports = corefn;

},{}],37:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_( '../window' );
var util = _dereq_( '../util' );
var Collection = _dereq_( '../collection' );
var is = _dereq_( '../is' );
var Promise = _dereq_( '../promise' );
var define = _dereq_( '../define' );

var Core = function( opts ){
  var cy = this;

  opts = util.extend( {}, opts );

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if( reg && reg.cy ){
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );

  var defVal = function( def, val, altVal ){
    if( val !== undefined ){
      return val;
    } else if( altVal !== undefined ){
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    options: options, // cached options
    elements: new Collection( this ), // elements in the graph
    listeners: [], // list of listeners
    aniEles: new Collection( this ), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false, // whether destroy was called
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal( true, options.zoomingEnabled ),
    userZoomingEnabled: defVal( true, options.userZoomingEnabled ),
    panningEnabled: defVal( true, options.panningEnabled ),
    userPanningEnabled: defVal( true, options.userPanningEnabled ),
    boxSelectionEnabled: defVal( true, options.boxSelectionEnabled ),
    autolock: defVal( false, options.autolock, options.autolockNodes ),
    autoungrabify: defVal( false, options.autoungrabify, options.autoungrabifyNodes ),
    autounselectify: defVal( false, options.autounselectify ),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number( options.zoom ) ? options.zoom : 1,
    pan: {
      x: is.plainObject( options.pan ) && is.number( options.pan.x ) ? options.pan.x : 0,
      y: is.plainObject( options.pan ) && is.number( options.pan.y ) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  // set selection type
  var selType = options.selectionType;
  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if( is.number( options.minZoom ) && is.number( options.maxZoom ) && options.minZoom < options.maxZoom ){
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if( is.number( options.minZoom ) && options.maxZoom === undefined ){
    _p.minZoom = options.minZoom;
  } else if( is.number( options.maxZoom ) && options.minZoom === undefined ){
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function( extData, next ){
    var anyIsPromise = extData.some( is.promise );

    if( anyIsPromise ){
      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
    } else {
      next( extData ); // exec synchronously for convenience
    }
  };

  // create the renderer
  cy.initRenderer( util.extend( {
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number( options.wheelSensitivity ) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number( options.pixelRatio ) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer ) );

  var setElesAndLayout = function( elements, onload, ondone ){
    cy.notifications( false );

    // remove old elements
    var oldEles = cy.mutableElements();
    if( oldEles.length > 0 ){
      oldEles.remove();
    }

    if( elements != null ){
      if( is.plainObject( elements ) || is.array( elements ) ){
        cy.add( elements );
      }
    }

    cy.one( 'layoutready', function( e ){
      cy.notifications( true );
      cy.trigger( e ); // we missed this event by turning notifications off, so pass it on

      cy.notify( {
        type: 'load',
        eles: cy.mutableElements()
      } );

      cy.one( 'load', onload );
      cy.trigger( 'load' );
    } ).one( 'layoutstop', function(){
      cy.one( 'done', ondone );
      cy.trigger( 'done' );
    } );

    var layoutOpts = util.extend( {}, cy._private.options.layout );
    layoutOpts.eles = cy.elements();

    cy.layout( layoutOpts ).run();
  };

  loadExtData([ options.style, options.elements ], function( thens ){
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if( _p.styleEnabled ){
      cy.setStyle( initStyle );
    }

    // initial load
    setElesAndLayout( initEles, function(){ // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( is.fn( options.ready ) ){
        cy.on( 'ready', options.ready );
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[ i ];
        cy.on( 'ready', fn );
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.trigger( 'ready' );
    }, options.done );

  } );
};

var corefn = Core.prototype; // short alias

util.extend( corefn, {
  instanceString: function(){
    return 'core';
  },

  isReady: function(){
    return this._private.ready;
  },

  isDestroyed: function(){
    return this._private.destroyed;
  },

  ready: function( fn ){
    if( this.isReady() ){
      this.trigger( 'ready', [], fn ); // just calls fn as though triggered via ready event
    } else {
      this.on( 'ready', fn );
    }

    return this;
  },

  destroy: function(){
    var cy = this;
    if( cy.isDestroyed() ) return;

    cy.stopAnimationLoop();

    cy.destroyRenderer();

    this.trigger( 'destroy' );

    cy._private.destroyed = true;

    return cy;
  },

  hasElementWithId: function( id ){
    return this._private.elements.hasElementWithId( id );
  },

  getElementById: function( id ){
    return this._private.elements.getElementById( id );
  },

  selectionType: function(){
    return this._private.selectionType;
  },

  hasCompoundNodes: function(){
    return this._private.hasCompoundNodes;
  },

  headless: function(){
    return this._private.options.renderer.name === 'null';
  },

  styleEnabled: function(){
    return this._private.styleEnabled;
  },

  addToPool: function( eles ){
    this._private.elements.merge( eles );

    return this; // chaining
  },

  removeFromPool: function( eles ){
    this._private.elements.unmerge( eles );

    return this;
  },

  container: function(){
    return this._private.container;
  },

  options: function(){
    return util.copy( this._private.options );
  },

  json: function( obj ){
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    if( is.plainObject( obj ) ){ // set

      cy.startBatch();

      if( obj.elements ){
        var idInJson = {};

        var updateEles = function( jsons, gr ){
          for( var i = 0; i < jsons.length; i++ ){
            var json = jsons[ i ];
            var id = json.data.id;
            var ele = cy.getElementById( id );

            idInJson[ id ] = true;

            if( ele.length !== 0 ){ // existing element should be updated
              ele.json( json );
            } else { // otherwise should be added
              if( gr ){
                cy.add( util.extend( { group: gr }, json ) );
              } else {
                cy.add( json );
              }
            }
          }
        };

        if( is.array( obj.elements ) ){ // elements: []
          updateEles( obj.elements );

        } else { // elements: { nodes: [], edges: [] }
          var grs = [ 'nodes', 'edges' ];
          for( var i = 0; i < grs.length; i++ ){
            var gr = grs[ i ];
            var elements = obj.elements[ gr ];

            if( is.array( elements ) ){
              updateEles( elements, gr );
            }
          }
        }

        // elements not specified in json should be removed
        eles.stdFilter( function( ele ){
          return !idInJson[ ele.id() ];
        } ).remove();
      }

      if( obj.style ){
        cy.style( obj.style );
      }

      if( obj.zoom != null && obj.zoom !== _p.zoom ){
        cy.zoom( obj.zoom );
      }

      if( obj.pan ){
        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
          cy.pan( obj.pan );
        }
      }

      var fields = [
        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
        'panningEnabled', 'userPanningEnabled',
        'boxSelectionEnabled',
        'autolock', 'autoungrabify', 'autounselectify'
      ];

      for( var i = 0; i < fields.length; i++ ){
        var f = fields[ i ];

        if( obj[ f ] != null ){
          cy[ f ]( obj[ f ] );
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if( obj === undefined ){ // get
      var json = {};

      json.elements = {};
      eles.forEach( function( ele ){
        var group = ele.group();

        if( !json.elements[ group ] ){
          json.elements[ group ] = [];
        }

        json.elements[ group ].push( ele.json() );
      } );

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy( cy._private.pan );
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy( cy._private.options.renderer );
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  } )

} );

corefn.$id = corefn.getElementById;

[
  _dereq_( './add-remove' ),
  _dereq_( './animation' ),
  _dereq_( './events' ),
  _dereq_( './export' ),
  _dereq_( './layout' ),
  _dereq_( './notification' ),
  _dereq_( './renderer' ),
  _dereq_( './search' ),
  _dereq_( './style' ),
  _dereq_( './viewport' )
].forEach( function( props ){
  util.extend( corefn, props );
} );

module.exports = Core;

},{"../collection":26,"../define":44,"../is":82,"../promise":85,"../util":99,"../window":107,"./add-remove":33,"./animation":34,"./events":35,"./export":36,"./layout":38,"./notification":39,"./renderer":40,"./search":41,"./style":42,"./viewport":43}],38:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var corefn = ({

  layout: function( options ){
    var cy = this;

    if( options == null ){
      util.error( 'Layout options must be specified to make a layout' );
      return;
    }

    if( options.name == null ){
      util.error( 'A `name` must be specified to make a layout' );
      return;
    }

    var name = options.name;
    var Layout = cy.extension( 'layout', name );

    if( Layout == null ){
      util.error( 'Can not apply layout: No such layout `' + name + '` found; did you include its JS file?' );
      return;
    }

    var eles;
    if( is.string( options.eles ) ){
      eles = cy.$( options.eles );
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout( util.extend( {}, options, {
      cy: cy,
      eles: eles
    } ) );

    return layout;
  }

});

corefn.createLayout = corefn.makeLayout = corefn.layout;

module.exports = corefn;

},{"../is":82,"../util":99}],39:[function(_dereq_,module,exports){
'use strict';

var corefn = ({
  notify: function( params ){
    var _p = this._private;

    if( _p.batchingNotify ){
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if( params.eles ){
        bEles.merge( params.eles );
      }

      if( !bTypes.ids[ params.type ] ){
        bTypes.push( params.type );
        bTypes.ids[ params.type ] = true;
      }

      return; // notifications are disabled during batching
    }

    if( !_p.notificationsEnabled ){ return; } // exit on disabled

    var renderer = this.renderer();

    // exit if destroy() called on core or renderer in between frames #1499 #1528
    if( this.isDestroyed() || !renderer ){ return; }

    renderer.notify( params );
  },

  notifications: function( bool ){
    var p = this._private;

    if( bool === undefined ){
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function( callback ){
    this.notifications( false );
    callback();
    this.notifications( true );
  },

  startBatch: function(){
    var _p = this._private;

    if( _p.batchCount == null ){
      _p.batchCount = 0;
    }

    if( _p.batchCount === 0 ){
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];
      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function(){
    var _p = this._private;

    _p.batchCount--;

    if( _p.batchCount === 0 ){
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify( {
        type: _p.batchNotifyTypes,
        eles: _p.batchNotifyEles
      } );
    }

    return this;
  },

  batch: function( callback ){
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function( map ){
    var cy = this;

    return this.batch( function(){
      var ids = Object.keys( map );

      for( var i = 0; i < ids.length; i++ ){
        var id = ids[i];
        var data = map[ id ];
        var ele = cy.getElementById( id );

        ele.data( data );
      }
    } );
  }
});

module.exports = corefn;

},{}],40:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );

var corefn = ({

  renderTo: function( context, zoom, pan, pxRatio ){
    var r = this._private.renderer;

    r.renderTo( context, zoom, pan, pxRatio );
    return this;
  },

  renderer: function(){
    return this._private.renderer;
  },

  forceRender: function(){
    this.notify( {
      type: 'draw'
    } );

    return this;
  },

  resize: function(){
    this.invalidateSize();

    this.notify( {
      type: 'resize'
    } );

    this.trigger( 'resize' );

    return this;
  },

  initRenderer: function( options ){
    var cy = this;

    var RendererProto = cy.extension( 'renderer', options.name );
    if( RendererProto == null ){
      util.error( 'Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name );
      return;
    }

    var rOpts = util.extend( {}, options, {
      cy: cy
    } );

    cy._private.renderer = new RendererProto( rOpts );
  },

  destroyRenderer: function(){
    var cy = this;

    cy.notify( { type: 'destroy' } ); // destroy the renderer

    var domEle = cy.container();
    if( domEle ){
      domEle._cyreg = null;

      while( domEle.childNodes.length > 0 ){
        domEle.removeChild( domEle.childNodes[0] );
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref
  },

  onRender: function( fn ){
    return this.on('render', fn);
  },

  offRender: function( fn ){
    return this.off('render', fn);
  }

});

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

},{"../util":99}],41:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var Collection = _dereq_( '../collection' );

var corefn = ({

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function( eles, opts ){

    if( is.string( eles ) ){
      return this.$( eles );

    } else if( is.elementOrCollection( eles ) ){
      return eles.collection();

    } else if( is.array( eles ) ){
      return new Collection( this, eles, opts );
    }

    return new Collection( this );
  },

  nodes: function( selector ){
    var nodes = this.$( function( ele ){
      return ele.isNode();
    } );

    if( selector ){
      return nodes.filter( selector );
    }

    return nodes;
  },

  edges: function( selector ){
    var edges = this.$( function( ele ){
      return ele.isEdge();
    } );

    if( selector ){
      return edges.filter( selector );
    }

    return edges;
  },

  // search the graph like jQuery
  $: function( selector ){
    var eles = this._private.elements;

    if( selector ){
      return eles.filter( selector );
    } else {
      return eles.spawnSelf();
    }
  },

  mutableElements: function(){
    return this._private.elements;
  }

});

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

},{"../collection":26,"../is":82}],42:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var Style = _dereq_( '../style' );

var corefn = ({

  style: function( newStyle ){
    if( newStyle ){
      var s = this.setStyle( newStyle );

      s.update();
    }

    return this._private.style;
  },

  setStyle: function( style ){
    var _p = this._private;

    if( is.stylesheet( style ) ){
      _p.style = style.generateStyle( this );

    } else if( is.array( style ) ){
      _p.style = Style.fromJson( this, style );

    } else if( is.string( style ) ){
      _p.style = Style.fromString( this, style );

    } else {
      _p.style = Style( this );
    }

    return _p.style;
  }
});

module.exports = corefn;

},{"../is":82,"../style":92}],43:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var window = _dereq_( '../window' );

var corefn = ({

  autolock: function( bool ){
    if( bool !== undefined ){
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function( bool ){
    if( bool !== undefined ){
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function( bool ){
    if( bool !== undefined ){
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function(){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch( args.length ){
    case 0: // .pan()
      return pan;

    case 1:

      if( is.string( args[0] ) ){ // .pan('x')
        dim = args[0];
        return pan[ dim ];

      } else if( is.plainObject( args[0] ) ){ // .pan({ x: 0, y: 100 })
        if( !this._private.panningEnabled ){
          return this;
        }

        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x = x;
        }

        if( is.number( y ) ){
          pan.y = y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .pan('x', 100)
      if( !this._private.panningEnabled ){
        return this;
      }

      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] = val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  panBy: function( params ){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if( !this._private.panningEnabled ){
      return this;
    }

    switch( args.length ){
    case 1:

      if( is.plainObject( args[0] ) ){ // .panBy({ x: 0, y: 100 })
        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x += x;
        }

        if( is.number( y ) ){
          pan.y += y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .panBy('x', 100)
      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] += val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  fit: function( elements, padding ){
    var viewportState = this.getFitViewport( elements, padding );

    if( viewportState ){
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.trigger( 'pan zoom viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getFitViewport: function( elements, padding ){
    if( is.number( elements ) && padding === undefined ){ // elements is optional
      padding = elements;
      elements = undefined;
    }

    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return;
    }

    var bb;

    if( is.string( elements ) ){
      var sel = elements;
      elements = this.$( sel );

    } else if( is.boundingBox( elements ) ){ // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom;
    padding = is.number( padding ) ? padding : 0;

    if( !isNaN( w ) && !isNaN( h ) && w > 0 && h > 0 && !isNaN( bb.w ) && !isNaN( bb.h ) &&  bb.w > 0 && bb.h > 0 ){
      zoom = Math.min( (w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h );

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
        y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.minZoom;
    } else if( is.number( zoom ) ){
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.maxZoom;
    } else if( is.number( zoom ) ){
      this._private.maxZoom = zoom;
    }

    return this;
  },

  zoom: function( params ){
    var pos; // in rendered px
    var zoom;

    if( params === undefined ){ // then get the zoom
      return this._private.zoom;

    } else if( is.number( params ) ){ // then set the zoom
      zoom = params;

    } else if( is.plainObject( params ) ){ // then zoom about a point
      zoom = params.level;

      if( params.position ){
        var p = params.position;
        var pan = this._private.pan;
        var z = this._private.zoom;

        pos = { // convert to rendered px
          x: p.x * z + pan.x,
          y: p.y * z + pan.y
        };
      } else if( params.renderedPosition ){
        pos = params.renderedPosition;
      }

      if( pos && !this._private.panningEnabled ){
        return this; // panning disabled
      }
    }

    if( !this._private.zoomingEnabled ){
      return this; // zooming disabled
    }

    if( !is.number( zoom ) || ( pos && (!is.number( pos.x ) || !is.number( pos.y )) ) ){
      return this; // can't zoom with invalid params
    }

    // crop zoom
    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

    if( pos ){ // set zoom about position
      var pan1 = this._private.pan;
      var zoom1 = this._private.zoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };

      this._private.zoom = zoom;
      this._private.pan = pan2;

      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
      this.trigger( ' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );

    } else { // just set the zoom
      this._private.zoom = zoom;
      this.trigger( 'zoom viewport' );
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  viewport: function( opts ){
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if( !opts ){ return this; }
    if( !is.number( opts.zoom ) ){ zoomDefd = false; }
    if( !is.plainObject( opts.pan ) ){ panDefd = false; }
    if( !zoomDefd && !panDefd ){ return this; }

    if( zoomDefd ){
      var z = opts.zoom;

      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
        zoomFailed = true;

      } else {
        _p.zoom = z;

        events.push( 'zoom' );
      }
    }

    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
      var p = opts.pan;

      if( is.number( p.x ) ){
        _p.pan.x = p.x;
        panFailed = false;
      }

      if( is.number( p.y ) ){
        _p.pan.y = p.y;
        panFailed = false;
      }

      if( !panFailed ){
        events.push( 'pan' );
      }
    }

    if( events.length > 0 ){
      events.push( 'viewport' );
      this.trigger( events.join( ' ' ) );

      this.notify( {
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  center: function( elements ){
    var pan = this.getCenterPan( elements );

    if( pan ){
      this._private.pan = pan;

      this.trigger( 'pan viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getCenterPan: function( elements, zoom ){
    if( !this._private.panningEnabled ){
      return;
    }

    if( is.string( elements ) ){
      var selector = elements;
      elements = this.mutableElements().filter( selector );
    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
      y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
    };

    return pan;
  },

  reset: function(){
    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return this;
    }

    this.viewport( {
      pan: { x: 0, y: 0 },
      zoom: 1
    } );

    return this; // chaining
  },

  invalidateSize: function(){
    this._private.sizeCache = null;
  },

  size: function(){
    var _p = this._private;
    var container = _p.container;

    return ( _p.sizeCache = _p.sizeCache || ( container ? (function(){
      var rect = container.getBoundingClientRect();
      var style = window.getComputedStyle( container );
      var val = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };

      return {
        width: rect.width - val('padding-left') - val('padding-right') - val('border-left-width') - val('border-right-width'),
        height: rect.height - val('padding-top') - val('padding-bottom') - val('border-top-width') - val('border-bottom-width')
      };
    })() : { // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    } ) );
  },

  width: function(){
    return this.size().width;
  },

  height: function(){
    return this.size().height;
  },

  extent: function(){
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: ( rb.x1 - pan.x ) / zoom,
      x2: ( rb.x2 - pan.x ) / zoom,
      y1: ( rb.y1 - pan.y ) / zoom,
      y2: ( rb.y2 - pan.y ) / zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function(){
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
});

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

},{"../is":82,"../window":107}],44:[function(_dereq_,module,exports){
'use strict';

// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// var foo = define.foo({ /* params... */ })

var util = _dereq_( './util' );
var is = _dereq_( './is' );
var Selector = _dereq_( './selector' );
var Promise = _dereq_( './promise' );
var Event = _dereq_( './event' );
var Animation = _dereq_( './animation' );

var define = {

  // access data field
  data: function( params ){
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      onSet: function( self ){},
      canSet: function( self ){ return true; }
    };
    params = util.extend( {}, defaults, params );

    return function dataImpl( name, value ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if( is.string( name ) ){ // set or get property

        // .data('foo')
        if( p.allowGetting && value === undefined ){ // get

          var ret;
          if( single ){
            ret = single._private[ p.field ][ name ];
          }
          return ret;

        // .data('foo', 'bar')
        } else if( p.allowSetting && value !== undefined ){ // set
          var valid = !p.immutableKeys[ name ];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[ i ] ) ){
                all[ i ]._private[ p.field ][ name ] = value;
              }
            }

            // update mappers if asked
            if( p.updateStyle ){ self.updateStyle(); }

            // call onSet callback
            p.onSet( self );

            if( p.settingTriggersEvent ){
              self[ p.triggerFnName ]( p.settingEvent );
            }
          }
        }

      // .data({ 'foo': 'bar' })
      } else if( p.allowSetting && is.plainObject( name ) ){ // extend
        var obj = name;
        var k, v;
        var keys = Object.keys( obj );

        for( var i = 0; i < keys.length; i++ ){
          k = keys[ i ];
          v = obj[ k ];

          var valid = !p.immutableKeys[ k ];
          if( valid ){
            for( var j = 0; j < all.length; j++ ){
              var ele = all[j];

              if( p.canSet( ele ) ){
                ele._private[ p.field ][ k ] = v;
              }
            }
          }
        }

        // update mappers if asked
        if( p.updateStyle ){ self.updateStyle(); }

        // call onSet callback
        p.onSet( self );

        if( p.settingTriggersEvent ){
          self[ p.triggerFnName ]( p.settingEvent );
        }

      // .data(function(){ ... })
      } else if( p.allowBinding && is.fn( name ) ){ // bind to event
        var fn = name;
        self.on( p.bindingEvent, fn );

      // .data()
      } else if( p.allowGetting && name === undefined ){ // get whole object
        var ret;
        if( single ){
          ret = single._private[ p.field ];
        }
        return ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function( params ){
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend( {}, defaults, params );

    return function removeDataImpl( names ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like

      // .removeData('foo bar')
      if( is.string( names ) ){ // then get the list of keys, and delete them
        var keys = names.split( /\s+/ );
        var l = keys.length;

        for( var i = 0; i < l; i++ ){ // delete each non-empty key
          var key = keys[ i ];
          if( is.emptyString( key ) ){ continue; }

          var valid = !p.immutableKeys[ key ]; // not valid if immutable
          if( valid ){
            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
              all[ i_a ]._private[ p.field ][ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }

      // .removeData()
      } else if( names === undefined ){ // then delete all keys

        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
          var _privateFields = all[ i_a ]._private[ p.field ];
          var keys = Object.keys( _privateFields );

          for( var i = 0; i < keys.length; i++ ){
            var key = keys[i];
            var validKeyToDelete = !p.immutableKeys[ key ];

            if( validKeyToDelete ){
              _privateFields[ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }
      }

      return self; // maintain chaining
    }; // function
  }, // removeData

  // event function reusable stuff
  event: {
    regex: /(\w+)(\.(?:\w+|\*))?/, // regex for matching event strings (e.g. "click.namespace")
    universalNamespace: '.*', // matches as if no namespace specified and prevents users from unbinding accidentally
    optionalTypeRegex: /(\w+)?(\.(?:\w+|\*))?/,
    falseCallback: function(){ return false; }
  },

  // event binding
  on: function( params ){
    var defaults = {
      unbindSelfOnTrigger: false,
      unbindAllBindersOnTrigger: false
    };
    params = util.extend( {}, defaults, params );

    return function onImpl( events, selector, data, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var p = params;

      if( is.plainObject( selector ) ){ // selector is actually data
        callback = data;
        data = selector;
        selector = undefined;
      } else if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        data = undefined;
        selector = undefined;
      }

      if( is.fn( data ) || data === false ){ // data is actually callback
        callback = data;
        data = undefined;
      }

      // if there isn't a callback, we can't really do anything
      // (can't speak for mapped events arg version)
      if( !(is.fn( callback ) || callback === false) && eventsIsString ){
        return self; // maintain chaining
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];
        if( callback === false ){
          callback = define.event.falseCallback;
        }

        if( !is.fn( callback ) ){ continue; }

        evts = evts.split( /\s+/ );
        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]

          if( match ){
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            var listener = {
              callback: callback, // callback to run
              data: data, // extra data in eventObj.data
              delegated: selector ? true : false, // whether the evt is delegated
              selector: selector, // the selector to match for delegated events
              selObj: new Selector( selector ), // cached selector object to save rebuilding
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
              binders: all // who bound together
            };

            for( var j = 0; j < all.length; j++ ){
              var _p = all[ j ]._private = all[ j ]._private || {};

              _p.listeners = _p.listeners || [];
              _p.listeners.push( listener );
            }
          }
        } // for events array
      } // for events map

      return self; // maintain chaining
    }; // function
  }, // on

  eventAliasesOn: function( proto ){
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.removeListener = p.unlisten = p.unbind = p.off;
    p.emit = p.trigger;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function( events, selector ){
      var self = this;
      var args = Array.prototype.slice.call( arguments, 0 );

      return new Promise( function( resolve, reject ){
        var callback = function( e ){
          self.off.apply( self, offArgs );

          resolve( e );
        };

        var onArgs = args.concat( [ callback ] );
        var offArgs = onArgs.concat( [] );

        self.on.apply( self, onArgs );
      } );
    };
  },

  off: function offImpl( params ){
    var defaults = {
    };
    params = util.extend( {}, defaults, params );

    return function( events, selector, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );

      if( arguments.length === 0 ){ // then unbind all

        for( var i = 0; i < all.length; i++ ){
          all[ i ]._private = all[ i ]._private || {};

          _p.listeners = [];
        }

        return self; // maintain chaining
      }

      if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        selector = undefined;
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];

        if( callback === false ){
          callback = define.event.falseCallback;
        }

        evts = evts.split( /\s+/ );
        for( var h = 0; h < evts.length; h++ ){
          var evt = evts[ h ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
          if( match ){
            var type = match[1] ? match[1] : undefined;
            var namespace = match[2] ? match[2] : undefined;

            for( var i = 0; i < all.length; i++ ){ //
              var _p = all[ i ]._private = all[ i ]._private || {};
              var listeners = _p.listeners = _p.listeners || [];

              for( var j = 0; j < listeners.length; j++ ){
                var listener = listeners[ j ];
                var nsMatches = !namespace || namespace === listener.namespace;
                var typeMatches = !type || listener.type === type;
                var cbMatches = !callback || callback === listener.callback;
                var listenerMatches = nsMatches && typeMatches && cbMatches;

                // delete listener if it matches
                if( listenerMatches ){
                  listeners.splice( j, 1 );
                  j--;
                }
              } // for listeners
            } // for all
          } // if match
        } // for events array

      } // for events map

      return self; // maintain chaining
    }; // function
  }, // off

  trigger: function( params ){
    var defaults = {};
    params = util.extend( {}, defaults, params );

    return function triggerImpl( events, extraParams, fnToTrigger ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var eventsIsObject = is.plainObject( events );
      var eventsIsEvent = is.event( events );
      var _p = this._private = this._private || {};
      var cy = _p.cy || ( is.core( this ) ? this : null );
      var hasCompounds = cy ? cy.hasCompoundNodes() : false;

      if( eventsIsString ){ // then make a plain event object for each event name
        var evts = events.split( /\s+/ );
        events = [];

        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]
          var type = match[1];
          var namespace = match[2] ? match[2] : undefined;

          events.push( {
            type: type,
            namespace: namespace
          } );
        }
      } else if( eventsIsObject ){ // put in length 1 array
        var eventArgObj = events;

        events = [ eventArgObj ];
      }

      if( extraParams ){
        if( !is.array( extraParams ) ){ // make sure extra params are in an array if specified
          extraParams = [ extraParams ];
        }
      } else { // otherwise, we've got nothing
        extraParams = [];
      }

      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
        var evtObj = events[ i ];

        for( var j = 0; j < all.length; j++ ){ // for each
          var triggerer = all[ j ];
          var _p = triggerer._private = triggerer._private || {};
          var listeners = _p.listeners = _p.listeners || [];
          var triggererIsElement = is.element( triggerer );
          var bubbleUp = triggererIsElement || params.layout;

          // create the event for this element from the event object
          var evt;

          if( eventsIsEvent ){ // then just get the object
            evt = evtObj;

            evt.target = evt.target || triggerer;
            evt.cy = evt.cy || cy;

          } else { // then we have to make one
            evt = new Event( evtObj, {
              target: triggerer,
              cy: cy,
              namespace: evtObj.namespace
            } );
          }

          // if a layout was specified, then put it in the typed event
          if( evtObj.layout ){
            evt.layout = evtObj.layout;
          }

          // if triggered by layout, put in event
          if( params.layout ){
            evt.layout = triggerer;
          }

          // create a rendered position based on the passed position
          if( evt.position ){
            var pos = evt.position;
            var zoom = cy.zoom();
            var pan = cy.pan();

            evt.renderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          if( fnToTrigger ){ // then override the listeners list with just the one we specified
            listeners = [ {
              namespace: evt.namespace,
              type: evt.type,
              callback: fnToTrigger
            } ];
          }

          for( var k = 0; k < listeners.length; k++ ){ // check each listener
            var lis = listeners[ k ];
            var nsMatches = !lis.namespace || lis.namespace === evt.namespace || lis.namespace === define.event.universalNamespace;
            var typeMatches = lis.type === evt.type;
            var targetMatches = lis.delegated ? ( triggerer !== evt.target && is.element( evt.target ) && lis.selObj.matches( evt.target ) ) : (true); // we're not going to validate the hierarchy; that's too expensive
            var listenerMatches = nsMatches && typeMatches && targetMatches;

            if( listenerMatches ){ // then trigger it
              var args = [ evt ];
              args = args.concat( extraParams ); // add extra params to args list

              if( lis.data ){ // add on data plugged into binding
                evt.data = lis.data;
              } else { // or clear it in case the event obj is reused
                evt.data = undefined;
              }

              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                listeners.splice( k, 1 );
                k--;
              }

              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                var binders = lis.binders;
                for( var l = 0; l < binders.length; l++ ){
                  var binder = binders[ l ];
                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                  var binderListeners = binder._private.listeners;
                  for( var m = 0; m < binderListeners.length; m++ ){
                    var binderListener = binderListeners[ m ];

                    if( binderListener === lis ){ // delete listener from list
                      binderListeners.splice( m, 1 );
                      m--;
                    }
                  }
                }
              }

              // run the callback
              var context = lis.delegated ? evt.target : triggerer;
              var ret = lis.callback.apply( context, args );

              if( ret === false || evt.isPropagationStopped() ){
                // then don't bubble
                bubbleUp = false;

                if( ret === false ){
                  // returning false is a shorthand for stopping propagation and preventing the def. action
                  evt.stopPropagation();
                  evt.preventDefault();
                }
              }
            } // if listener matches
          } // for each listener

          // bubble up event for elements
          if( bubbleUp ){
            var parent = hasCompounds ? triggerer._private.parent : null;
            var hasParent = parent != null && parent.length !== 0;

            if( hasParent ){ // then bubble up to parent
              parent = parent[0];
              parent.trigger( evt );
            } else { // otherwise, bubble up to the core
              cy.trigger( evt );
            }
          }

        } // for each of all
      } // for each event

      return self; // maintain chaining
    }; // function
  }, // trigger

  animated: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animatedImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return false; }

      var ele = all[0];

      if( ele ){
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function clearQueueImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animate( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  delayAnimation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayAnimationImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animation( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  animation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animationImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if( !cy.styleEnabled() ){ return this; }

      var style = cy.style();

      properties = util.extend( {}, properties, params );

      if( properties.duration === undefined ){
        properties.duration = 400;
      }

      switch( properties.duration ){
      case 'slow':
        properties.duration = 600;
        break;
      case 'fast':
        properties.duration = 200;
        break;
      }

      var propertiesEmpty = Object.keys( properties ).length === 0;

      if( propertiesEmpty ){
        return new Animation( all[0], properties ); // nothing to animate
      }

      if( isEles ){
        properties.style = style.getPropsList( properties.style || properties.css );

        properties.css = undefined;
      }

      if( properties.renderedPosition && isEles ){
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = {
          x: ( rpos.x - pan.x ) / zoom,
          y: ( rpos.y - pan.y ) / zoom
        };
      }

      // override pan w/ panBy if set
      if( properties.panBy && isCore ){
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if( center && isCore ){
        var centerPan = cy.getCenterPan( center.eles, properties.zoom );

        if( centerPan ){
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if( properties.fit && isCore ){
        var fit = properties.fit;
        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

        if( fitVp ){
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      return new Animation( all[0], properties );
    };
  }, // animate

  animate: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animateImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      if( params ){
        properties = util.extend( {}, properties, params );
      }

      // manually hook and run the animation
      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function stopImpl( clearQueue, jumpToEnd ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var _p = ele._private;
        var anis = _p.animation.current;

        for( var j = 0; j < anis.length; j++ ){
          var ani = anis[ j ];
          var ani_p = ani._private;

          if( jumpToEnd ){
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if( clearQueue ){
          _p.animation.queue = [];
        }

        if( !jumpToEnd ){
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify( {
        eles: this,
        type: 'draw'
      } );

      return this;
    };
  } // stop

}; // define

module.exports = define;

},{"./animation":2,"./event":45,"./is":82,"./promise":85,"./selector":86,"./util":99}],45:[function(_dereq_,module,exports){
'use strict';

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function( src, props ){
  // Allow instantiation without the 'new' keyword
  if( !(this instanceof Event) ){
    return new Event( src, props );
  }

  // Event object
  if( src && src.type ){
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if( props ){
    // util.extend( this, props );

    // more efficient to manually copy fields we use
    this.type = props.type !== undefined ? props.type : this.type;
    this.cy = props.cy;
    this.target = props.target;
    this.position = props.position;
    this.renderedPosition = props.renderedPosition;
    this.namespace = props.namespace;
    this.layout = props.layout;
    this.data = props.data;
    this.message = props.message;
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();
};

function returnFalse(){
  return false;
}

function returnTrue(){
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function(){
    return 'event';
  },

  preventDefault: function(){
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if preventDefault exists run it on the original event
    if( e.preventDefault ){
      e.preventDefault();
    }
  },

  stopPropagation: function(){
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if stopPropagation exists run it on the original event
    if( e.stopPropagation ){
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function(){
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

},{}],46:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( './util' );
var define = _dereq_( './define' );
var Collection = _dereq_( './collection' );
var Core = _dereq_( './core' );
var incExts = _dereq_( './extensions' );
var is = _dereq_( './is' );

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension( type, name, registrant ){

  var ext = registrant;

  var overrideErr = function( field ){
    util.error( 'Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden' );
  };

  if( type === 'core' ){
    if( Core.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Core.prototype[ name ] = registrant;
    }

  } else if( type === 'collection' ){
    if( Collection.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Collection.prototype[ name ] = registrant;
    }

  } else if( type === 'layout' ){
    // fill in missing layout functions in the prototype

    var Layout = function( options ){
      this.options = options;

      registrant.call( this, options );

      // make sure layout has _private for use w/ std apis like .on()
      if( !is.plainObject( this._private ) ){
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
    };

    var layoutProto = Layout.prototype = Object.create( registrant.prototype );

    var optLayoutFns = [];

    for( var i = 0; i < optLayoutFns.length; i++ ){
      var fnName = optLayoutFns[ i ];

      layoutProto[ fnName ] = layoutProto[ fnName ] || function(){ return this; };
    }

    // either .start() or .run() is defined, so autogen the other
    if( layoutProto.start && !layoutProto.run ){
      layoutProto.run = function(){ this.start(); return this; };
    } else if( !layoutProto.start && layoutProto.run ){
      layoutProto.start = function(){ this.run(); return this; };
    }

    var regStop = registrant.prototype.stop;
    layoutProto.stop = function(){
      var opts = this.options;

      if( opts && opts.animate ){
        var anis = this.animations;

        if( anis ){
          for( var i = 0; i < anis.length; i++ ){
            anis[ i ].stop();
          }
        }
      }

      if( regStop ){
        regStop.call( this );
      } else {
        this.trigger( 'layoutstop' );
      }

      return this;
    };

    if( !layoutProto.destroy ){
      layoutProto.destroy = function(){
        return this;
      };
    }

    layoutProto.on = define.on( { layout: true } );
    layoutProto.one = define.on( { layout: true, unbindSelfOnTrigger: true } );
    layoutProto.once = define.on( { layout: true, unbindAllBindersOnTrigger: true } );
    layoutProto.off = define.off( { layout: true } );
    layoutProto.trigger = define.trigger( { layout: true } );

    define.eventAliasesOn( layoutProto );

    ext = Layout; // replace with our wrapped layout

  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
    // user registered renderers inherit from base

    var BaseRenderer = getExtension( 'renderer', 'base' );
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function(){
      BaseRenderer.apply( this, arguments );
      RegistrantRenderer.apply( this, arguments );
    };

    var proto = Renderer.prototype;

    for( var pName in bProto ){
      var pVal = bProto[ pName ];
      var existsInR = rProto[ pName ] != null;

      if( existsInR ){
        return overrideErr( pName );
      }

      proto[ pName ] = pVal; // take impl from base
    }

    for( var pName in rProto ){
      proto[ pName ] = rProto[ pName ]; // take impl from registrant
    }

    bProto.clientFunctions.forEach( function( name ){
      proto[ name ] = proto[ name ] || function(){
        util.error( 'Renderer does not implement `renderer.' + name + '()` on its prototype' );
      };
    } );

    ext = Renderer;

  }

  return util.setMap( {
    map: extensions,
    keys: [ type, name ],
    value: ext
  } );
}

function getExtension( type, name ){
  return util.getMap( {
    map: extensions,
    keys: [ type, name ]
  } );
}

function setModule( type, name, moduleType, moduleName, registrant ){
  return util.setMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ],
    value: registrant
  } );
}

function getModule( type, name, moduleType, moduleName ){
  return util.getMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ]
  } );
}

var extension = function(){
  // e.g. extension('renderer', 'svg')
  if( arguments.length === 2 ){
    return getExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if( arguments.length === 3 ){
    return setExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
  else if( arguments.length === 4 ){
    return getModule.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
  else if( arguments.length === 5 ){
    return setModule.apply( null, arguments );
  }

  else {
    util.error( 'Invalid extension access syntax' );
  }

};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach( function( group ){
  group.extensions.forEach( function( ext ){
    setExtension( group.type, ext.name, ext.impl );
  } );
} );

module.exports = extension;

},{"./collection":26,"./core":37,"./define":44,"./extensions":47,"./is":82,"./util":99}],47:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  {
    type: 'layout',
    extensions: _dereq_( './layout' )
  },

  {
    type: 'renderer',
    extensions: _dereq_( './renderer' )
  }
];

},{"./layout":53,"./renderer":78}],48:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );
var is = _dereq_( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function BreadthFirstLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

BreadthFirstLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );
  var graph = eles;

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var roots;
  if( is.elementOrCollection( options.roots ) ){
    roots = options.roots;
  } else if( is.array( options.roots ) ){
    var rootsArray = [];

    for( var i = 0; i < options.roots.length; i++ ){
      var id = options.roots[ i ];
      var ele = cy.getElementById( id );
      rootsArray.push( ele );
    }

    roots = cy.collection( rootsArray );
  } else if( is.string( options.roots ) ){
    roots = cy.$( options.roots );

  } else {
    if( options.directed ){
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      while( unhandledNodes.length > 0 ){
        var currComp = cy.collection();

        eles.bfs( {
          roots: unhandledNodes[0],
          visit: function( node, edge, pNode, i, depth ){
            currComp = currComp.add( node );
          },
          directed: false
        } );

        unhandledNodes = unhandledNodes.not( currComp );
        components.push( currComp );
      }

      roots = cy.collection();
      for( var i = 0; i < components.length; i++ ){
        var comp = components[ i ];
        var maxDegree = comp.maxDegree( false );
        var compRoots = comp.filter( function( ele ){
          return ele.degree( false ) === maxDegree;
        } );

        roots = roots.add( compRoots );
      }

    }
  }


  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs( {
    roots: roots,
    directed: options.directed,
    visit: function( node, edge, pNode, i, depth ){
      var ele = node[0];
      var id = ele.id();

      if( !depths[ depth ] ){
        depths[ depth ] = [];
      }

      depths[ depth ].push( ele );
      foundByBfs[ id ] = true;
      id2depth[ id ] = depth;
      prevNode[ id ] = pNode;
      prevEdge[ id ] = edge;

      if( pNode ){
        var prevId = pNode.id();
        var succ = successors[ prevId ] = successors[ prevId ] || [];

        succ.push( node );
      }
    }
  } );

  // check for nodes not found by bfs
  var orphanNodes = [];
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[ i ];

    if( foundByBfs[ ele.id() ] ){
      continue;
    } else {
      orphanNodes.push( ele );
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while( orphanNodes.length !== 0 && checks < maxChecks ){
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for( var i = 0; i < neighbors.length; i++ ){
      var depth = id2depth[ neighbors[ i ].id() ];

      if( depth !== undefined ){
        depths[ depth ].push( node );
        assignedDepth = true;
        break;
      }
    }

    if( !assignedDepth ){
      orphanNodes.push( node );
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while( orphanNodes.length !== 0 ){
    var node = orphanNodes.shift();
    //var subgraph = graph.bfs( node ).path;
    var assignedDepth = false;

    // for( var i = 0; i < subgraph.length; i++ ){
    //   var depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
      if( depths.length === 0 ){
        depths.push( [] );
      }

      depths[0].push( node );
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function(){
    for( var i = 0; i < depths.length; i++ ){
      var eles = depths[ i ];

      for( var j = 0; j < eles.length; j++ ){
        var ele = eles[ j ];

        ele._private.scratch.breadthfirst = {
          depth: i,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();


  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges( function( ele ){
      return ele.data( 'target' ) === node.id();
    } );
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther;
    for( var i = 0; i < edges.length; i++ ){
      var edge = edges[ i ];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

  // make maximal if so set by adjusting depths
  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

    var nDepths = depths.length;
    var elesToMove = [];
    for( var i = 0; i < nDepths; i++ ){
      var depth = depths[ i ];

      var nDepth = depth.length;
      for( var j = 0; j < nDepth; j++ ){
        var ele = depth[ j ];
        var info = ele._private.scratch.breadthfirst;
        var intEle = intersectsDepth( ele );

        if( intEle ){
          info.intEle = intEle;
          elesToMove.push( ele );
        }
      }
    }

    for( var i = 0; i < elesToMove.length; i++ ){
      var ele = elesToMove[ i ];
      var info = ele._private.scratch.breadthfirst;
      var intEle = info.intEle;
      var intInfo = intEle._private.scratch.breadthfirst;

      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while( newDepth > depths.length - 1 ){
        depths.push( [] );
      }
      depths[ newDepth ].push( ele );

      info.depth = newDepth;
      info.index = depths[ newDepth ].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if( options.avoidOverlap ){
    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[ i ];
      var nbb = n.boundingBox();
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max( minDistance, w, h );
    }
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function( ele ){
    if( cachedWeightedPercent[ ele.id() ] ){
      return cachedWeightedPercent[ ele.id() ];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not( ':parent' ).intersection(nodes);
    var percent = 0;
    var samples = 0;

    for( var i = 0; i < neighbors.length; i++ ){
      var neighbor = neighbors[ i ];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var depth = bf.depth;
      var nDepth = depths[ depth ].length;

      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max( 1, samples );
    percent = percent / samples;

    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ ele.id() ] = percent;
    return percent;
  };


  // rearrange the indices in each depth level based on connectivity

  var sortFn = function( a, b ){
    var apct = getWeightedPercent( a );
    var bpct = getWeightedPercent( b );

    return apct - bpct;
  };

  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

    for( var i = 0; i < depths.length; i++ ){
      depths[ i ] = depths[ i ].sort( sortFn );
    }
    assignDepthsToEles(); // and update

  }

  var biggestDepthSize = 0;
  for( var i = 0; i < depths.length; i++ ){
    biggestDepthSize = Math.max( depths[ i ].length, biggestDepthSize );
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };

  var getPosition = function( ele, isBottomDepth ){
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[ depth ].length;

    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
    radiusStepSize = Math.max( radiusStepSize, minDistance );

    if( !options.circle ){

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if( isBottomDepth ){
        return epos;
      }

      // var succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( var i = 0 ; i < succs.length; i++ ){
      //     var spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;

    } else {
      if( options.circle ){
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
        var theta = 2 * Math.PI / depths[ depth ].length * index;

        if( depth === 0 && depths[0].length === 1 ){
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos( theta ),
          y: center.y + radius * Math.sin( theta )
        };

      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }

  };

  // get positions in reverse depth order
  var pos = {};
  for( var i = depths.length - 1; i >= 0; i-- ){
    var depth = depths[ i ];

    for( var j = 0; j < depth.length; j++ ){
      var node = depth[ j ];

      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
    }
  }

  nodes.layoutPositions( this, options, function( node ){
    return pos[ node.id() ];
  } );

  return this; // chaining
};

module.exports = BreadthFirstLayout;

},{"../../is":82,"../../math":84,"../../util":99}],49:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );
var is = _dereq_( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined, // the radius of the circle
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function CircleLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

CircleLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;

  var dTheta = sweep / ( Math.max( 1, nodes.length - 1 ) );
  var r;

  var minDistance = 0;
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max( minDistance, w, h );
  }

  if( is.number( options.radius ) ){
    r = options.radius;
  } else if( nodes.length <= 1 ){
    r = 0;
  } else {
    r = Math.min( bb.h, bb.w ) / 2 - minDistance;
  }

  // calculate the radius
  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos( dTheta ) - Math.cos( 0 );
    var dsin = Math.sin( dTheta ) - Math.sin( 0 );
    var rMin = Math.sqrt( minDistance * minDistance / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping
    r = Math.max( rMin, r );
  }

  var getPos = function( ele, i ){
    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );

    var rx = r * Math.cos( theta );
    var ry = r * Math.sin( theta );
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = CircleLayout;

},{"../../is":82,"../../math":84,"../../util":99}],50:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up  
  concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function( nodes ){ // the variation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function ConcentricLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

ConcentricLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var value;

    // calculate the node value
    value = options.concentric( node );
    nodeValues.push( {
      value: value,
      node: node
    } );

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var nbb = node.boundingBox();

    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
  }

  // sort node values in descreasing order
  nodeValues.sort( function( a, b ){
    return b.value - a.value;
  } );

  var levelWidth = options.levelWidth( nodes );

  // put the values into levels
  var levels = [ [] ];
  var currentLevel = levels[0];
  for( var i = 0; i < nodeValues.length; i++ ){
    var val = nodeValues[ i ];

    if( currentLevel.length > 0 ){
      var diff = Math.abs( currentLevel[0].value - val.value );

      if( diff >= levelWidth ){
        currentLevel = [];
        levels.push( currentLevel );
      }
    }

    currentLevel.push( val );
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if( !options.avoidOverlap ){ // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = ( Math.min( bb.w, bb.h ) / 2 - minDist );
    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

    minDist = Math.min( minDist, rStep );
  }

  // find the metrics for each level
  var r = 0;
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / ( Math.max( 1, level.length - 1 ) );

    // calculate the radius
    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      var dcos = Math.cos( dTheta ) - Math.cos( 0 );
      var dsin = Math.sin( dTheta ) - Math.sin( 0 );
      var rMin = Math.sqrt( minDist * minDist / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping

      r = Math.max( rMin, r );
    }

    level.r = r;

    r += minDist;
  }

  if( options.equidistant ){
    var rDeltaMax = 0;
    var r = 0;

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];
      var rDelta = level.r - r;

      rDeltaMax = Math.max( rDeltaMax, rDelta );
    }

    r = 0;
    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];

      if( i === 0 ){
        r = level.r;
      }

      level.r = r;

      r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var dTheta = level.dTheta;
    var r = level.r;

    for( var j = 0; j < level.length; j++ ){
      var val = level[ j ];
      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;

      var p = {
        x: center.x + r * Math.cos( theta ),
        y: center.y + r * Math.sin( theta )
      };

      pos[ val.node.id() ] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions( this, options, function( ele ){
    var id = ele.id();

    return pos[ id ];
  } );

  return this; // chaining
};

module.exports = ConcentricLayout;

},{"../../math":84,"../../util":99}],51:[function(_dereq_,module,exports){
'use strict';

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );
var is = _dereq_( '../../is' );
var Promise = _dereq_('../../promise');

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready: function(){},

  // Called on `layoutstop`
  stop: function(){},

  // Whether to animate while running the layout
  animate: true,

  // The layout animates only after this many milliseconds
  // (prevents flashing on fast runs)
  animationThreshold: 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh: 20,

  // Whether to fit the network view after when done
  fit: true,

  // Padding on fit
  padding: 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,

  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,

  // Extra spacing between components in non-compound graphs
  componentSpacing: 100,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function( node ){ return 400000; },

  // Node repulsion (overlapping) multiplier
  nodeOverlap: 10,

  // Node overlap increase multiplier
  nodeOverlapAutoFactor: 2,

  // Ideal edge (non nested) length
  idealEdgeLength: function( edge ){ return 10; },

  // Divisor to compute edge forces
  edgeElasticity: function( edge ){ return 100; },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 5,

  // Gravity force (constant)
  gravity: 80,

  // Maximum number of iterations to perform
  numIter: 1000,

  // Initial temperature (maximum node displacement)
  initialTemp: 200,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.95,

  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0,

  // Pass a reference to weaver to use threads for calculations
  weaver: false
};


/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout( options ){
  this.options = util.extend( {}, defaults, options );

  this.options.layout = this;
}

/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function(){
  var options = this.options;
  var cy      = options.cy;
  var layout  = this;
  var thread  = this.thread;
  var Thread  = options.weaver ? options.weaver.Thread : null;

  var falseThread = { // use false thread as polyfill
    listeners: [],
    on: function(e, cb){
      this.listeners.push({ event: e, callback: cb });

      return this;
    },
    trigger: function(e){
      if( is.string(e) ){
        e = { type: e };
      }

      var matchesEvent = function( l ){ return l.event === e.type; };
      var trigger = function( l ){ l.callback(e); };

      this.listeners.filter( matchesEvent ).forEach( trigger );

      return this;
    },
    pass: function( data ){
      this.pass = data;

      return this;
    },
    run: function( cb ){
      var pass = this.pass;

      return new Promise(function( resolve ){
        resolve( cb( pass ) );
      });
    },
    stop: function(){
      return this;
    }
  };

  function broadcast( message ){ // for false thread
    var e = { type: 'message', message: message };

    falseThread.trigger( e );
  }

  if( !thread || thread.stopped() ){
    thread = this.thread = Thread ? new Thread() : falseThread;
  }

  layout.stopped = false;

  layout.trigger( { type: 'layoutstart', layout: layout } );

  // Set DEBUG - Global variable
  if( true === options.debug ){
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo( cy, layout, options );

  // Show LayoutInfo contents if debugging
  if( DEBUG ){
    printLayoutInfo( layoutInfo );
  }

  // If required, randomize node positions
  if (options.randomize) {
    randomizePositions( layoutInfo, cy );
  }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function( rOpts ){
    rOpts = rOpts || {};

    if( refreshRequested && !rOpts.next ){
      return;
    }

    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame( function(){
      refreshPositions( layoutInfo, cy, options );

      // Fit the graph if necessary
      if( true === options.fit ){
        cy.fit( options.padding );
      }

      refreshRequested = false;

      if( rOpts.next ){ rOpts.next(); }
    });
  };

  thread.on( 'message', function( e ){
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  } );

  thread.pass( {
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  } ).run( function( pass ){
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;
    var currentForce = {};
    var t = 2;
    for(var i = 0; i < layoutInfo.layoutNodes.length; i++) {
      //console.log(layoutInfo.layoutNodes[i].id);
      currentForce[layoutInfo.layoutNodes[i].id] = {};
      for(var j = i + 1; j < layoutInfo.layoutNodes.length; j++) {
        currentForce[layoutInfo.layoutNodes[i].id][layoutInfo.layoutNodes[j].id] = options.nodeOverlap;
      }
    }

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function( layoutInfo, options, step ){
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces( layoutInfo, options );
      // Calculate edge forces
      calculateEdgeForces( layoutInfo, options );
      // Calculate gravity forces
      calculateGravityForces( layoutInfo, options );
      // Propagate forces from parent to child
      propagateForces( layoutInfo, options );
      // Update positions based on calculated forces
      updatePositions( layoutInfo, options );
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function( layoutInfo, options ){
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for( var j = 0; j < numNodes; j++ ){
          var node1 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];

          for( var k = j + 1; k < numNodes; k++ ){
            var node2 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ k ] ] ];

            nodeRepulsion( node1, node2, layoutInfo, options );
          }
        }
      }
    };

    var randomDistance = function( max ){
      return -max + 2 * max * Math.random();
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function( node1, node2, layoutInfo, options ){
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if( 0 === directionX && 0 === directionY ){
        directionX = randomDistance( maxRandDist );
        directionY = randomDistance( maxRandDist );
      }

      var overlap = nodesOverlap( node1, node2, directionX, directionY );

      if( overlap > 0 ){
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force    = currentForce[node1.id][node2.id] /*options.nodeOverlap*/ * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt( directionX * directionX + directionY * directionY );
        // s += "\nDistance: " + distance;
        var forceX   = force * directionX / distance;
        var forceY   = force * directionY / distance;
        currentForce[node1.id][node2.id] *= options.nodeOverlapAutoFactor;
      } else {
        currentForce[node1.id][node2.id] = options.nodeOverlap;
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint( node1, directionX, directionY );
        var point2 = findClippingPoint( node2, -1 * directionX, -1 * directionY );

        // Use clipping points to compute distance
        var distanceX   = point2.x - point1.x;
        var distanceY   = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance    = Math.sqrt( distanceSqr );
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }


      // Apply force
      if( !node1.isLocked ){
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if( !node2.isLocked ){
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function( node1, node2, dX, dY ){

      if( dX > 0 ){
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if( dY > 0 ){
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if( overlapX >= 0 && overlapY >= 0 ){
        return Math.sqrt( overlapX * overlapX + overlapY * overlapY );
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function( node, dX, dY ){

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope     = dY / dX;
      var nodeSlope    = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};

      // Case: Vertical direction (up)
      if( 0 === dX && 0 < dY ){
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;

        return res;
      }

      // Case: Vertical direction (down)
      if( 0 === dX && 0 > dY ){
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";

        return res;
      }

      // Case: Intersects the right border
      if( 0 < dX &&
      -1 * nodeSlope <= dirSlope &&
      dirSlope <= nodeSlope ){
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        // s += "\nRightborder";

        return res;
      }

      // Case: Intersects the left border
      if( 0 > dX &&
      -1 * nodeSlope <= dirSlope &&
      dirSlope <= nodeSlope ){
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        // s += "\nLeftborder";

        return res;
      }

      // Case: Intersects the top border
      if( 0 < dY &&
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope ) ){
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        // s += "\nTop border";

        return res;
      }

      // Case: Intersects the bottom border
      if( 0 > dY &&
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope ) ){
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        // s += "\nBottom border";

        return res;
      }

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function( layoutInfo, options ){
      // Iterate over all edges
      for( var i = 0; i < layoutInfo.edgeSize; i++ ){
        // Get edge, source & target nodes
        var edge     = layoutInfo.layoutEdges[ i ];
        var sourceIx = layoutInfo.idToIndex[ edge.sourceId ];
        var source   = layoutInfo.layoutNodes[ sourceIx ];
        var targetIx = layoutInfo.idToIndex[ edge.targetId ];
        var target   = layoutInfo.layoutNodes[ targetIx ];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if( 0 === directionX && 0 === directionY ){
          return;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint( source, directionX, directionY );
        var point2 = findClippingPoint( target, -1 * directionX, -1 * directionY );


        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l  = Math.sqrt( lx * lx + ly * ly );

        var force  = Math.pow( edge.idealLength - l, 2 ) / edge.elasticity;

        if( 0 !== l ){
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if( !source.isLocked ){
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if( !target.isLocked ){
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function( layoutInfo, options ){
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if( 0 === i ){
          var centerX   = layoutInfo.clientHeight / 2;
          var centerY   = layoutInfo.clientWidth  / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp    = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[0] ] ];
          var parent  = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ temp.parentId ] ];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for( var j = 0; j < numNodes; j++ ){
          var node = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];
          // s = "Node: " + node.id;

          if( node.isLocked ){ continue; }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d  = Math.sqrt( dx * dx + dy * dy );
          if( d > distThreshold ){
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {
            // s += ": skypped since it's too close to center";
          }
          // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function( layoutInfo, options ){
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0;   // Points to the start the queue
      var end   = -1;  // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply( queue, layoutInfo.graphSet[0] );
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while( start <= end ){
        // Get the node to visit and remove it from queue
        var nodeId    = queue[ start++ ];
        var nodeIndex = layoutInfo.idToIndex[ nodeId ];
        var node      = layoutInfo.layoutNodes[ nodeIndex ];
        var children  = node.children;

        // We only need to process the node if it's compound
        if( 0 < children.length && !node.isLocked ){
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for( var i = 0; i < children.length; i++ ){
            var childNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ children[ i ] ] ];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[ ++end ] = children[ i ];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }

      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function( layoutInfo, options ){
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length ){
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length || n.isLocked ){
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce( n.offsetX, n.offsetY, layoutInfo.temperature );
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX    = n.positionX - n.width;
        n.maxX    = n.positionX + n.width;
        n.minY    = n.positionY - n.height;
        n.maxY    = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries( n, layoutInfo );
      }

      // Update size, position of compund nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length && !n.isLocked ){
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width     = n.maxX - n.minX;
          n.height    = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function( forceX, forceY, max ){
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt( forceX * forceX + forceY * forceY );

      if( force > max ){
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };

      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function( node, layoutInfo ){
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if( null == parentId ){
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ parentId ] ];
      var flag = false;

      // MaxX
      if( null == p.maxX || node.maxX + p.padRight > p.maxX ){
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if( null == p.minX || node.minX - p.padLeft < p.minX ){
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if( null == p.maxY || node.maxY + p.padBottom > p.maxY ){
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if( null == p.minY || node.minY - p.padTop < p.minY ){
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if( flag ){
        // logDebug(s);
        return updateAncestryBoundaries( p, layoutInfo );
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function( layutInfo, options ){
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var cid = node.cmptId;
        var component = components[ cid ] = components[ cid ] || [];

        component.push( node );
      }

      var totalA = 0;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          c.x1 = Math.min( c.x1, n.positionX - n.width / 2 );
          c.x2 = Math.max( c.x2, n.positionX + n.width / 2 );
          c.y1 = Math.min( c.y1, n.positionY - n.height / 2 );
          c.y2 = Math.max( c.y2, n.positionY + n.height / 2 );
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort( function( c1, c2 ){
        return c2.w * c2.h - c1.w * c1.h;
      } );

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          if( !n.isLocked ){
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max( rowH, c.h );

        if( usedW > maxRowW ){
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function( i ){
      if( stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step( layoutInfo, options, i );

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if( layoutInfo.temperature < options.minTemp ){
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while( f < options.refresh && i < options.numIter ){
        var loopRet = mainLoop( i );
        if( !loopRet ){ break; }

        f++;
        i++;
      }

      if( options.animate ){
        broadcast( layoutInfo.layoutNodes ); // eslint-disable-line no-undef
      }

    } while( loopRet && i + 1 < options.numIter );

    separateComponents( layoutInfo, options );

    return layoutInfo;
  } ).then( function( layoutInfoUpdated ){
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  } );

  var done = function(){
    refresh({
      force: true,
      next: function(){
        // Layout has finished
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }
    });
  };

  return this; // chaining
};


/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function(){
  this.stopped = true;

  if( this.thread ){
    this.thread.stop();
  }

  this.trigger( 'layoutstop' );

  return this; // chaining
};

CoseLayout.prototype.destroy = function(){
  if( this.thread ){
    this.thread.stop();
  }

  return this; // chaining
};


/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function( cy, layout, options ){
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo   = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
                   } )
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for( var i = 0; i < components.length; i++ ){
    var component = components[ i ];

    for( var j = 0; j < component.length; j++ ){
      var node = component[ j ];

      id2cmptId[ node.id() ] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();

    var tempNode        = {};
    tempNode.isLocked   = n.locked();
    tempNode.id         = n.data( 'id' );
    tempNode.parentId   = n.data( 'parent' );
    tempNode.cmptId     = id2cmptId[ n.id() ];
    tempNode.children   = [];
    tempNode.positionX  = n.position( 'x' );
    tempNode.positionY  = n.position( 'y' );
    tempNode.offsetX    = 0;
    tempNode.offsetY    = 0;
    tempNode.height     = nbb.w;
    tempNode.width      = nbb.h;
    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft    = parseFloat( n.style( 'padding' ) );
    tempNode.padRight   = parseFloat( n.style( 'padding' ) );
    tempNode.padTop     = parseFloat( n.style( 'padding' ) );
    tempNode.padBottom  = parseFloat( n.style( 'padding' ) );

    // forces
    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion(n) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push( tempNode );
    // Add entry to id-index map
    layoutInfo.idToIndex[ tempNode.id ] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0;   // Points to the start the queue
  var end   = -1;  // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if( null != p_id ){
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[ layoutInfo.idToIndex[ p_id ] ].children.push( n.id );
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[ ++end ] = n.id;
      tempGraph.push( n.id );
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push( tempGraph );

  // Traverse the graph, level by level,
  while( start <= end ){
    // Get the node to visit and remove it from queue
    var node_id  = queue[ start++ ];
    var node_ix  = layoutInfo.idToIndex[ node_id ];
    var node     = layoutInfo.layoutNodes[ node_ix ];
    var children = node.children;
    if( children.length > 0 ){
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push( children );
      // Add children to que queue to be visited
      for( var i = 0; i < children.length; i++ ){
        queue[ ++end ] = children[ i ];
      }
    }
  }

  // Create indexToGraph map
  for( var i = 0; i < layoutInfo.graphSet.length; i++ ){
    var graph = layoutInfo.graphSet[ i ];
    for( var j = 0; j < graph.length; j++ ){
      var index = layoutInfo.idToIndex[ graph[ j ] ];
      layoutInfo.indexToGraph[ index ] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for( var i = 0; i < layoutInfo.edgeSize; i++ ){
    var e = edges[ i ];
    var tempEdge = {};
    tempEdge.id       = e.data( 'id' );
    tempEdge.sourceId = e.data( 'source' );
    tempEdge.targetId = e.data( 'target' );

    // Compute ideal length
    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity(e) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx    = layoutInfo.idToIndex[ tempEdge.sourceId ];
    var targetIx    = layoutInfo.idToIndex[ tempEdge.targetId ];
    var sourceGraph = layoutInfo.indexToGraph[ sourceIx ];
    var targetGraph = layoutInfo.indexToGraph[ targetIx ];

    if( sourceGraph != targetGraph ){
      // Find lowest common graph ancestor
      var lca = findLCA( tempEdge.sourceId, tempEdge.targetId, layoutInfo );

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[ lca ];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[ sourceIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[ targetIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push( tempEdge );
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};


/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function( node1, node2, layoutInfo ){
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux( node1, node2, 0, layoutInfo );
  if( 2 > res.count ){
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};


/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function( node1, node2, graphIx, layoutInfo ){
  var graph = layoutInfo.graphSet[ graphIx ];
  // If both nodes belongs to graphIx
  if( -1 < graph.indexOf( node1 ) && -1 < graph.indexOf( node2 ) ){
    return {count: 2, graph: graphIx};
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for( var i = 0; i < graph.length; i++ ){
    var nodeId   = graph[ i ];
    var nodeIx   = layoutInfo.idToIndex[ nodeId ];
    var children = layoutInfo.layoutNodes[ nodeIx ].children;

    // If the node has no child, skip it
    if( 0 === children.length ){
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[ layoutInfo.idToIndex[ children[0] ] ];
    var result = findLCA_aux( node1, node2, childGraphIx, layoutInfo );
    if( 0 === result.count ){
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if( 1 === result.count ){
      // One of (node1, node2) is present in this subgraph
      c++;
      if( 2 === c ){
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {count: c, graph: graphIx};
};


/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function( layoutInfo ){
  /* eslint-disable */

  if( !DEBUG ){
    return;
  }
  console.debug( 'layoutNodes:' );
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var s =
    '\nindex: '     + i +
    '\nId: '        + n.id +
    '\nChildren: '  + n.children.toString() +
    '\nparentId: '  + n.parentId  +
    '\npositionX: ' + n.positionX +
    '\npositionY: ' + n.positionY +
    '\nOffsetX: ' + n.offsetX +
    '\nOffsetY: ' + n.offsetY +
    '\npadLeft: ' + n.padLeft +
    '\npadRight: ' + n.padRight +
    '\npadTop: ' + n.padTop +
    '\npadBottom: ' + n.padBottom;

    console.debug( s );
  }

  console.debug( 'idToIndex' );
  for( var i in layoutInfo.idToIndex ){
    console.debug( 'Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[ i ] );
  }

  console.debug( 'Graph Set' );
  var set = layoutInfo.graphSet;
  for( var i = 0; i < set.length; i ++ ){
    console.debug( 'Set : ' + i + ': ' + set[ i ].toString() );
  }

  var s = 'IndexToGraph';
  for( var i = 0; i < layoutInfo.indexToGraph.length; i ++ ){
    s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[ i ];
  }
  console.debug( s );

  s = 'Layout Edges';
  for( var i = 0; i < layoutInfo.layoutEdges.length; i++ ){
    var e = layoutInfo.layoutEdges[ i ];
    s += '\nEdge Index: ' + i + ' ID: ' + e.id +
    ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId +
    ' Ideal Length: ' + e.idealLength;
  }
  console.debug( s );

  s =  'nodeSize: ' + layoutInfo.nodeSize;
  s += '\nedgeSize: ' + layoutInfo.edgeSize;
  s += '\ntemperature: ' + layoutInfo.temperature;
  console.debug( s );

  return;
  /* eslint-enable */
};


/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function( layoutInfo, cy ){
  var width     = layoutInfo.clientWidth;
  var height    = layoutInfo.clientHeight;

  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];

    // No need to randomize compound nodes or locked nodes
    if( 0 === n.children.length && !n.isLocked ){
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};


/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function( layoutInfo, cy, options ){
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if( options.boundingBox ){
    nodes.forEach( function( node ){
      var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ node.data( 'id' ) ] ];

      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
    } );

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions( function( ele, i ){
    var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ ele.data( 'id' ) ] ];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if( options.boundingBox ){ // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  } );

  // Trigger layoutReady only on first call
  if( true !== layoutInfo.ready ){
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one( 'layoutready', options.ready );
    layout.trigger( { type: 'layoutready', layout: this } );
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

},{"../../is":82,"../../math":84,"../../promise":85,"../../util":99}],52:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function( node ){}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function GridLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

GridLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  if( bb.h === 0 || bb.w === 0 ){
    nodes.layoutPositions( this, options, function( ele ){
      return { x: bb.x1, y: bb.y1 };
    } );

  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt( cells * bb.h / bb.w );
    var rows = Math.round( splits );
    var cols = Math.round( bb.w / bb.h * splits );

    var small = function( val ){
      if( val == null ){
        return Math.min( rows, cols );
      } else {
        var min = Math.min( rows, cols );
        if( min == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function( val ){
      if( val == null ){
        return Math.max( rows, cols );
      } else {
        var max = Math.max( rows, cols );
        if( max == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if( oRows != null && oCols != null ){
      rows = oRows;
      cols = oCols;
    } else if( oRows != null && oCols == null ){
      rows = oRows;
      cols = Math.ceil( cells / rows );
    } else if( oRows == null && oCols != null ){
      cols = oCols;
      rows = Math.ceil( cells / cols );
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if( cols * rows > cells ){
      var sm = small();
      var lg = large();

      // reducing the small side takes away the most cells, so try it first
      if( (sm - 1) * lg >= cells ){
        small( sm - 1 );
      } else if( (lg - 1) * sm >= cells ){
        large( lg - 1 );
      }
    } else {

      // if rounding was too low, add rows or columns
      while( cols * rows < cells ){
        var sm = small();
        var lg = large();

        // try to add to larger side first (adds less in multiplication)
        if( (lg + 1) * sm >= cells ){
          large( lg + 1 );
        } else {
          small( sm + 1 );
        }
      }
    }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if( options.condense ){
      cellWidth = 0;
      cellHeight = 0;
    }

    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var pos = node._private.position;

        if( pos.x == null || pos.y == null ){ // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.boundingBox();
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max( cellWidth, w );
        cellHeight = Math.max( cellHeight, h );
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function( row, col ){
      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;
    };

    var use = function( row, col ){
      cellUsed[ 'c-' + row + '-' + col ] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function(){
      col++;
      if( col >= cols ){
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];
      var rcPos = options.position( node );

      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
        var pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if( pos.col === undefined ){ // find unused col
          pos.col = 0;

          while( used( pos.row, pos.col ) ){
            pos.col++;
          }
        } else if( pos.row === undefined ){ // find unused row
          pos.row = 0;

          while( used( pos.row, pos.col ) ){
            pos.row++;
          }
        }

        id2manPos[ node.id() ] = pos;
        use( pos.row, pos.col );
      }
    }

    var getPos = function( element, i ){
      var x, y;

      if( element.locked() || element.isParent() ){
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[ element.id() ];
      if( rcPos ){
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;

      } else { // otherwise set automatically

        while( used( row, col ) ){
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use( row, col );

        moveToNextCell();
      }

      return { x: x, y: y };

    };

    nodes.layoutPositions( this, options, getPos );
  }

  return this; // chaining

};

module.exports = GridLayout;

},{"../../math":84,"../../util":99}],53:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'breadthfirst', impl: _dereq_( './breadthfirst' ) },
  { name: 'circle', impl: _dereq_( './circle' ) },
  { name: 'concentric',impl: _dereq_( './concentric' ) },
  { name: 'cose', impl: _dereq_( './cose' ) },
  { name: 'grid', impl: _dereq_( './grid' ) },
  { name: 'null', impl: _dereq_( './null' ) },
  { name: 'preset', impl: _dereq_( './preset' ) },
  { name: 'random', impl: _dereq_( './random' ) }
];

},{"./breadthfirst":48,"./circle":49,"./concentric":50,"./cose":51,"./grid":52,"./null":54,"./preset":55,"./random":56}],54:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );

// default layout options
var defaults = {
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

// runs the layout
NullLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.trigger( 'layoutstart' );

  // puts all nodes at (0, 0)
  eles.nodes().positions( function(){
    return {
      x: 0,
      y: 0
    };
  } );

  // trigger layoutready when each node has had its position set at least once
  layout.one( 'layoutready', options.ready );
  layout.trigger( 'layoutready' );

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one( 'layoutstop', options.stop );
  layout.trigger( 'layoutstop' );

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function(){
  return this; // chaining
};

module.exports = NullLayout;

},{"../../util":99}],55:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var is = _dereq_( '../../is' );

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function PresetLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

PresetLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn( options.positions );

  function getPosition( node ){
    if( options.positions == null ){
      return null;
    }

    if( posIsFn ){
      return options.positions( node );
    }

    var pos = options.positions[ node._private.data.id ];

    if( pos == null ){
      return null;
    }

    return pos;
  }

  nodes.layoutPositions( this, options, function( node, i ){
    var position = getPosition( node );

    if( node.locked() || position == null ){
      return false;
    }

    return position;
  } );

  return this; // chaining
};

module.exports = PresetLayout;

},{"../../is":82,"../../util":99}],56:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../util' );
var math = _dereq_( '../../math' );

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function RandomLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

RandomLayout.prototype.run = function(){
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var getPos = function( node, i ){
    return {
      x: bb.x1 + Math.round( Math.random() * bb.w ),
      y: bb.y1 + Math.round( Math.random() * bb.h )
    };
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = RandomLayout;

},{"../../math":84,"../../util":99}],57:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_( '../../../math' );
var is = _dereq_( '../../../is' );
var util = _dereq_( '../../../util' );

var BRp = {};

BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function(){
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function( x, y, size, angle, translation, padding ){
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;

    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);

    return inside;
  };

  var transform = function( x, y, size, angle, translation ){
    var xRotated = x * Math.cos( angle ) - y * Math.sin( angle );
    var yRotated = x * Math.sin( angle ) + y * Math.cos( angle );

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function( pts, size, angle, translation ){
    var retPts = [];

    for( var i = 0; i < pts.length; i += 2 ){
      var x = pts[ i ];
      var y = pts[ i + 1];

      retPts.push( transform( x, y, size, angle, translation ) );
    }

    return retPts;
  };

  var pointsToArr = function( pts ){
    var ret = [];

    for( var i = 0; i < pts.length; i++ ){
      var p = pts[ i ];

      ret.push( p.x, p.y );
    }

    return ret;
  };

  var standardGap = function( edge ) {
    return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).pfValue * 2;
  };

  var defineArrowShape = function( name, defn ){
    if( is.string( defn ) ){
      defn = arrowShapes[ defn ];
    }

    arrowShapes[ name ] = util.extend( {
      name: name,

      points: [
        -0.15, -0.3,
        0.15, -0.3,
        0.15, 0.3,
        -0.15, 0.3
      ],

      collide: function( x, y, size, angle, translation, padding ){
        var points = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
        var inside = math.pointInsidePolygonPoints( x, y, points );

        return inside;
      },

      roughCollide: bbCollide,

      draw: function( context, size, angle, translation ){
        var points = transformPoints( this.points, size, angle, translation );

        renderer.arrowShapeImpl( 'polygon' )( context, points );
      },

      spacing: function( edge ){
        return 0;
      },

      gap: standardGap
    }, defn );
  };

  defineArrowShape( 'none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  } );

  defineArrowShape( 'triangle', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ]
  } );

  defineArrowShape( 'arrow', 'triangle' );

  defineArrowShape( 'triangle-backcurve', {
    points: arrowShapes[ 'triangle' ].points,

    controlPoint: [ 0, -0.15 ],

    roughCollide: bbCollide,

    draw: function( context, size, angle, translation ){
      var ptsTrans = transformPoints( this.points, size, angle, translation );
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
    },

    gap: function( edge ) {
      return standardGap(edge) * 0.985;
    }
  } );


  defineArrowShape( 'triangle-tee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      var triPts = transformPoints( this.points, size, angle, translation );
      var teePts = transformPoints( this.pointsTee, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
    }
  } );

  defineArrowShape( 'triangle-cross', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    crossLinePoints: [
      -0.24175, -0.4,
      0.24175, -0.4,
    ],

    forceStroke: true,

    matchEdgeWidth: true,

    scaleCoord: function ( constant, size, edgeWidth ){
     return constant + ( edgeWidth * 0.012 ) + ( math.log2( size - 28.95 ) * 0.001 );
    },

   scaleCrossLineXCoord: function( size, edgeWidth ){
      return this.scaleCoord( 0.42, size, edgeWidth );
    },

    scaleCrossLineYCoord: function( size, edgeWidth ){
      return this.scaleCoord( -0.01, size, edgeWidth );
    },

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var crossLinePts = pointsToArr( transformPoints( this.crossLinePoints, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts )
      || math.inLineVicinity( x, y,
        crossLinePts[0], crossLinePts[1], crossLinePts[2], crossLinePts[3], padding );

      return inside;
    },

    draw: function( context, size, angle, translation, edgeWidth ){
      var scaledCrossLine = [
        this.crossLinePoints[0] + this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[1] - this.scaleCrossLineYCoord( size, edgeWidth ),
        this.crossLinePoints[2] - this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[3] - this.scaleCrossLineYCoord( size, edgeWidth )
      ];
      var triPts = transformPoints( this.points, size, angle, translation );
      var crossLinePts = transformPoints( scaledCrossLine, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, crossLinePts );
    }
  } );

  defineArrowShape( 'vee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      0, -0.15
    ],

    gap: function( edge ){
      return standardGap(edge) * 0.985;
    }
  } );

  defineArrowShape( 'circle', {
    radius: 0.15,

    collide: function( x, y, size, angle, translation, padding ){
      var t = translation;
      var inside = ( Math.pow( t.x - x, 2 ) + Math.pow( t.y - y, 2 ) <= Math.pow( (size + 2 * padding) * this.radius, 2 ) );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
    },

    spacing: function( edge ){
      return renderer.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.radius;
    }
  } );

  defineArrowShape( 'tee', {
    points: [
      -0.15, 0,
      -0.15, -0.1,
      0.15, -0.1,
      0.15, 0
    ],

    spacing: function( edge ){
      return 1;
    },

    gap: function( edge ){
      return 1;
    }
  } );

  defineArrowShape( 'square', {
    points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ]
  } );

  defineArrowShape( 'diamond', {
    points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    gap: function( edge ){
      return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).value;
    }
  } );

};

module.exports = BRp;

},{"../../../is":82,"../../../math":84,"../../../util":99}],58:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_( '../../../math' );
var is = _dereq_( '../../../is' );
var util = _dereq_( '../../../util' );
var zIndexSort = _dereq_( '../../../collection/zsort' );
var window = _dereq_( '../../../window' );

var BRp = {};

BRp.registerCalculationListeners = function(){
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function( eles, e, dirtyStyleCaches ){
    elesToUpdate.merge( eles );

    if( dirtyStyleCaches === true || dirtyStyleCaches === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle;

        rstyle.clean = false;
        _p.bbCache = null;

        var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

        if( !evts[ e.type ] ){
          evts[ e.type ] = true;
          evts.length++;
        }
      }
    }
  };

  r.binder( cy )
    // nodes

    .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode( e ){
      var node = e.target;

      enqueue( node, e );
      enqueue( node.connectedEdges(), e );
    })

    .on('add.*', 'node', function onDirtyAddNode( e ){
      var ele = e.target;

      enqueue( ele, e );
    })

    .on('background.*', 'node', function onDirtyBgNode( e ){
      var ele = e.target;

      enqueue( ele, e, false );
    })

    // edges

    .on('add.* style.*', 'edge', function onDirtyEdge( e ){
      var edge = e.target;

      enqueue( edge, e );
      enqueue( edge.parallelEdges(), e );
    })

    .on('remove.*', 'edge', function onDirtyRemoveEdge( e ){
      var edge = e.target;
      var pEdges = edge.parallelEdges();

      for( var i = 0; i < pEdges.length; i++ ){
        var pEdge = pEdges[i];

        if( !pEdge.removed() ){
          enqueue( pEdge, e );
        }
      }
    })

    // manual dirtying

    .on('dirty.*', 'node', function onDirtyEle( e ){
      var ele = e.cyTarget;

      enqueue( ele, e );
    })
  ;

  var updateEleCalcs = function( willDraw ){
    if( willDraw ){
      var fns = r.onUpdateEleCalcsFns;

      if( fns ){ for( var i = 0; i < fns.length; i++ ){
        var fn = fns[i];

        fn( willDraw, elesToUpdate );
      } }

      r.recalculateRenderedStyle( elesToUpdate, false );

      for( var i = 0; i < elesToUpdate.length; i++ ){
        elesToUpdate[i]._private.rstyle.dirtyEvents = null;
      }

      elesToUpdate = cy.collection();
    }
  };

  r.beforeRender( updateEleCalcs, r.beforeRenderPriorities.eleCalcs );
};

BRp.onUpdateEleCalcs = function( fn ){
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

  fns.push( fn );
};

BRp.recalculateRenderedStyle = function( eles, useCache ){
  var edges = [];
  var nodes = [];

  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  if( this.destroyed ){ return; }

  // use cache by default for perf
  if( useCache === undefined ){ useCache = true; }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;

    // only update if dirty and in graph
    if( (useCache && rstyle.clean) || ele.removed() ){ continue; }

    // only update if not display: none
    if( ele.pstyle('display').value === 'none' ){ continue; }

    if( _p.group === 'nodes' ){
      nodes.push( ele );
    } else { // edges
      edges.push( ele );
    }

    rstyle.clean = true;
    // rstyle.dirtyEvents = null;
  }

  // update node data from projections
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = _p.position;

    this.recalculateNodeLabelProjection( ele );

    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle( 'width' ).pfValue;
    rstyle.nodeH = ele.pstyle( 'height' ).pfValue;
  }

  this.recalculateEdgeProjections( edges );

  // update edge data from projections
  for( var i = 0; i < edges.length; i++ ){
    var ele = edges[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch;

    this.recalculateEdgeLabelProjections( ele );

    // update rstyle positions
    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

// Project mouse
BRp.projectIntoViewport = function( clientX, clientY ){
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var pan = cy.pan();
  var zoom = cy.zoom();

  var x = ( clientX - offsetLeft - pan.x ) / zoom;
  var y = ( clientY - offsetTop - pan.y ) / zoom;

  return [ x, y ];
};

BRp.findContainerClientCoords = function(){
  if( this.containerBB ){
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window.getComputedStyle( container );
  var styleValue = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };
  var extra = {
    left: styleValue('padding-left') + styleValue('border-left-width'),
    right: styleValue('padding-right') + styleValue('border-right-width'),
    top: styleValue('padding-top') + styleValue('border-top-width'),
    bottom: styleValue('padding-bottom') + styleValue('border-bottom-width')
  };

  return ( this.containerBB = [ // x, y, w, h
    rect.left + extra.left,
    rect.top + extra.top,
    rect.right - rect.left - extra.left - extra.right,
    rect.bottom - rect.top - extra.top - extra.bottom
  ] );
};

BRp.invalidateContainerClientCoordsCache = function(){
  this.containerBB = null;
};

BRp.findNearestElement = function( x, y, interactiveElementsOnly, isTouch ){
  return this.findNearestElements( x, y, interactiveElementsOnly, isTouch )[0];
};

BRp.findNearestElements = function( x, y, interactiveElementsOnly, isTouch ){
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if( interactiveElementsOnly ){
    eles = eles.interactive;
  }

  function addEle( ele, sqDist ){
    if( ele.isNode() ){
      if( nearNode ){
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push( ele );
      }
    }

    if( ele.isEdge() && ( sqDist == null || sqDist < minSqDist ) ){
      if( nearEdge ){ // then replace existing edge
        // can replace only if same z-index
        if( nearEdge.pstyle( 'z-index' ).value === ele.pstyle('z-index').value ){
          for( var i = 0; i < near.length; i++ ){
            if( near[i].isEdge() ){
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push( ele );
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode( node ){
    var _p = node._private;

    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = _p.position;

    if(
      pos.x - hw <= x && x <= pos.x + hw // bb check x
        &&
      pos.y - hh <= y && y <= pos.y + hh // bb check y
    ){
      var shape = r.nodeShapes[ self.getNodeShape( node ) ];

      if(
        shape.checkPoint( x, y, 0, width, height, pos.x, pos.y )
      ){
        addEle( node, 0 );
        return true;
      }

    }
  }

  function checkEdge( edge ){
    var _p = edge._private;

    var rs = _p.rscratch;
    var styleWidth = edge.pstyle( 'width' ).pfValue;
    var scale = edge.pstyle( 'arrow-scale' ).value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
      var pts = rs.allpts;

      for( var i = 0; i + 3 < pts.length; i += 2 ){
        if(
          (inEdgeBB = math.inLineVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], width2 ))
            &&
          widthSq > ( sqDist = math.sqdistToFiniteLine( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] ) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }

    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
      var pts = rs.allpts;
      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
        if(
          (inEdgeBB = math.inBezierVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5], width2 ))
            &&
          (widthSq > (sqDist = math.sqdistToQuadraticBezier( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5] )) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows

    var src = src || _p.source;
    var tgt = tgt || _p.target;

    var arSize = self.getArrowWidth( styleWidth, scale );

    var arrows = [
      { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
      { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
      { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
      { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
    ];

    for( var i = 0; i < arrows.length; i++ ){
      var ar = arrows[ i ];
      var shape = r.arrowShapes[ edge.pstyle( ar.name + '-arrow-shape' ).value ];

      if(
        shape.roughCollide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
         &&
        shape.collide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
      ){
        addEle( edge );
        return true;
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if( hasCompounds && near.length > 0 ){
      checkNode( src );
      checkNode( tgt );
    }
  }

  function preprop( obj, name, pre ){
    return util.getPrefixedProperty( obj, name, pre );
  }

  function checkLabel( ele, prefix ){
    var _p = ele._private;
    var th = labelThreshold;

    var prefixDash;
    if( prefix ){
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    var text = ele.pstyle( prefixDash + 'label' ).value;
    var eventsEnabled = ele.pstyle( 'text-events' ).strValue === 'yes';

    if( !eventsEnabled || !text ){ return; }

    var rstyle = _p.rstyle;
    var bw = ele.pstyle('text-border-width').pfValue;
    var pw = ele.pstyle('text-background-padding').pfValue;
    var lw = preprop( rstyle, 'labelWidth', prefix ) + bw + 2*th + 2*pw;
    var lh = preprop( rstyle, 'labelHeight', prefix ) + bw + 2*th + 2*pw;
    var lx = preprop( rstyle, 'labelX', prefix );
    var ly = preprop( rstyle, 'labelY', prefix );

    var theta = preprop( _p.rscratch, 'labelAngle', prefix );

    var lx1 = lx - lw / 2;
    var lx2 = lx + lw / 2;
    var ly1 = ly - lh / 2;
    var ly2 = ly + lh / 2;

    if( theta ){
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - lx;
        y = y - ly;

        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      var points = [
        px1y1.x, px1y1.y,
        px2y1.x, px2y1.y,
        px2y2.x, px2y2.y,
        px1y2.x, px1y2.y
      ];

      if( math.pointInsidePolygonPoints( x, y, points ) ){
        addEle( ele );
        return true;
      }
    } else { // do a cheaper bb check
      var bb = {
        w: lw,
        h: lh,
        x1: lx1,
        x2: lx2,
        y1: ly1,
        y2: ly2
      };

      if( math.inBoundingBox( bb, x, y ) ){
        addEle( ele );
        return true;
      }
    }

  }

  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
    var ele = eles[ i ];

    if( ele.isNode() ){
      checkNode( ele ) || checkLabel( ele );

    } else { // then edge
      checkEdge( ele ) || checkLabel( ele ) || checkLabel( ele, 'source' ) || checkLabel( ele, 'target' );
    }
  }

  return near;
};

// 'Give me everything from this box'
BRp.getAllInBox = function( x1, y1, x2, y2 ){
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];

  var x1c = Math.min( x1, x2 );
  var x2c = Math.max( x1, x2 );
  var y1c = Math.min( y1, y2 );
  var y2c = Math.max( y1, y2 );

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox( {
    x1: x1, y1: y1,
    x2: x2, y2: y2
  } );

  for( var e = 0; e < eles.length; e++ ){
    var ele = eles[e];

    if( ele.isNode() ){
      var node = ele;
      var nodeBb = node.boundingBox( {
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      } );

      if( math.boundingBoxesIntersect( boxBb, nodeBb ) ){
        box.push( node );
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
      if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }

      if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){

        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for( var i = 0; i < pts.length; i++ ){
          if( !math.pointInBoundingBox( boxBb, pts[ i ] ) ){
            allInside = false;
            break;
          }
        }

        if( allInside ){
          box.push( edge );
        }

      } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
        box.push( edge );
      }
    }
  }

  return box;
};


/**
 * Returns the shape of the given node. If the height or width of the given node
 * is set to auto, the node is considered to be a compound.
 *
 * @param node          a node
 * @return {String}     shape of the node
 */
BRp.getNodeShape = function( node ){
  var r = this;
  var shape = node.pstyle( 'shape' ).value;

  if( node.isParent() ){
    if( shape === 'rectangle'
    || shape === 'roundrectangle'
    || shape === 'cutrectangle'
    || shape === 'barrel' ){
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if( shape === 'polygon' ){
    var points = node.pstyle( 'shape-polygon-points' ).value;

    return r.nodeShapes.makePolygon( points ).name;
  }

  return shape;
};

BRp.updateCachedGrabbedEles = function(){
  var eles = this.cachedZSortedEles;

  if( !eles ){
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];

  var grabTargets = [];

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.grabbed() && !ele.isParent() ){
      grabTargets.push( ele );
    } else if( rs.inDragLayer ){
      eles.drag.push( ele );
    } else {
      eles.nondrag.push( ele );
    }
  }

  // put the grab target nodes last so it's on top of its neighbourhood
  for( var i = 0; i < grabTargets.length; i++ ){
    var ele = grabTargets[i];

    eles.drag.push( ele );
  }
};

BRp.invalidateCachedZSortedEles = function(){
  this.cachedZSortedEles = null;
};

BRp.getCachedZSortedEles = function( forceRecalc ){
  if( forceRecalc || !this.cachedZSortedEles ){
    //console.time('cachezorder')

    var eles = this.cy.mutableElements().toArray();

    eles.sort( zIndexSort );

    eles.interactive = eles.filter(function( ele ){
      return ele.interactive();
    });

    this.cachedZSortedEles = eles;

    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

function pushBezierPts( r, edge, pts ){
  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt( p1, p2, p3, t ); };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for( var i = 0; i < r.bezierProjPcts.length; i++ ){
    var p = r.bezierProjPcts[i];

    bpts.push( {
      x: qbezierAt( pts[0], pts[2], pts[4], p ),
      y: qbezierAt( pts[1], pts[3], pts[5], p )
    } );
  }
}

BRp.projectLines = function( edge ){
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  // clear the cached points state
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      pushBezierPts( this, edge, rs.allpts.slice( i, i + 6 ) );
    }
  } else if(  et === 'segments' ){
    var lpts = _p.rstyle.linePts = [];

    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
      lpts.push( {
        x: rs.allpts[ i ],
        y: rs.allpts[ i + 1]
      } );
    }
  } else if( et === 'haystack' ){
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [
      { x: hpts[0], y: hpts[1] },
      { x: hpts[2], y: hpts[3] }
    ];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth( edge.pstyle('width').pfValue, edge.pstyle( 'arrow-scale' ).value )
    * this.arrowShapeWidth;
};

BRp.projectBezier = BRp.projectLines;

BRp.recalculateNodeLabelProjection = function( node ){
  var content = node.pstyle( 'label' ).strValue;

  if( is.emptyString(content) ){ return; }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = _p.position;
  var textHalign = node.pstyle( 'text-halign' ).strValue;
  var textValign = node.pstyle( 'text-valign' ).strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch( textHalign ){
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default: // e.g. center
      textX = nodePos.x;
  }

  switch( textValign ){
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default: // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( node );
};

BRp.recalculateEdgeLabelProjections = function( edge ){
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if( content.mid || content.source || content.target ){
    // then we have to calculate...
  } else {
    return; // no labels => no calcs
  }

  // add center point to style so bounding box calculations can use it
  //
  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function( propName, prefix, value ){
    util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
    util.setPrefixedProperty( _p.rstyle, propName, prefix, value );
  };

  setRs( 'labelX', null, p.x );
  setRs( 'labelY', null, p.y );

  var createControlPointInfo = function(){
    if( createControlPointInfo.cache ){ return createControlPointInfo.cache; } // use cache so only 1x per edge

    var ctrlpts = [];

    // store each ctrlpt info init
    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      var p0 = { x: rs.allpts[i], y: rs.allpts[i+1] };
      var p1 = { x: rs.allpts[i+2], y: rs.allpts[i+3] }; // ctrlpt
      var p2 = { x: rs.allpts[i+4], y: rs.allpts[i+5] };

      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment( cp, p0, p1, t0, t1 ){
      var length = math.dist( p0, p1 );
      var prevSegment = cp.segments[ cp.segments.length - 1 ];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };

      cp.segments.push( segment );

      cp.length += length;
    }

    // update each ctrlpt with segment info
    for( var i = 0; i < ctrlpts.length; i++ ){
      var cp = ctrlpts[i];
      var prevCp = ctrlpts[i - 1];

      if( prevCp ){
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(
        cp,
        cp.p0,   bpts[ i * nProjs ],
        0,       r.bezierProjPcts[ 0 ]
      ); // first

      for( var j = 0; j < nProjs - 1; j++ ){
        addSegment(
          cp,
          bpts[ i * nProjs + j ],   bpts[ i * nProjs + j + 1 ],
          r.bezierProjPcts[ j ],    r.bezierProjPcts[ j + 1 ]
        );
      }

      addSegment(
        cp,
        bpts[ i * nProjs + nProjs - 1 ],   cp.p2,
        r.bezierProjPcts[ nProjs - 1 ],    1
      ); // last
    }

    return ( createControlPointInfo.cache = ctrlpts );
  };

  var calculateEndProjection = function( prefix ){
    var angle;
    var isSrc = prefix === 'source';

    if( !content[ prefix ] ){ return; }

    var offset = edge.pstyle(prefix+'-text-offset').pfValue;

    var lineAngle = function( p0, p1 ){
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;

      return Math.atan( dy / dx );
    };

    var bezierAngle = function( p0, p1, p2, t ){
      var t0 = math.bound( 0, t - 0.001, 1 );
      var t1 = math.bound( 0, t + 0.001, 1 );

      var lp0 = math.qbezierPtAt( p0, p1, p2, t0 );
      var lp1 = math.qbezierPtAt( p0, p1, p2, t1 );

      return lineAngle( lp0, lp1 );
    };

    switch( rs.edgeType ){
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        var cps = createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;

        // find the segment we're on
        for( var i = 0; i < cps.length; i++ ){
          var cp = cps[ isSrc ? i : cps.length - 1 - i ];

          for( var j = 0; j < cp.segments.length; j++ ){
            var seg = cp.segments[ isSrc ? j : cp.segments.length - 1 - j ];
            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

            startDist = totalDist;
            totalDist += seg.length;

            if( totalDist >= offset || lastSeg ){
              selected = { cp: cp, segment: seg };
              break;
            }
          }

          if( selected ){ break; }
        }

        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = ( offset - startDist ) / ( seg.length );
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

        t = math.bound( 0, t, 1 );
        p = math.qbezierPtAt( cp.p0, cp.p1, cp.p2, t );
        angle = bezierAngle( cp.p0, cp.p1, cp.p2, t, p );

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        var d = 0, di, d0;
        var p0, p1;
        var l = rs.allpts.length;

        for( var i = 0; i + 3 < l; i += 2 ){
          if( isSrc ){
            p0 = { x: rs.allpts[i],     y: rs.allpts[i+1] };
            p1 = { x: rs.allpts[i+2],   y: rs.allpts[i+3] };
          } else {
            p0 = { x: rs.allpts[l-2-i], y: rs.allpts[l-1-i] };
            p1 = { x: rs.allpts[l-4-i], y: rs.allpts[l-3-i] };
          }

          di = math.dist( p0, p1 );
          d0 = d;
          d += di;

          if( d >= offset ){ break; }
        }

        var pD = offset - d0;
        var t = pD / di;

        t  = math.bound( 0, t, 1 );
        p = math.lineAt( p0, p1, t );
        angle = lineAngle( p0, p1 );

        break;
    }

    setRs( 'labelX', prefix, p.x );
    setRs( 'labelY', prefix, p.y );
    setRs( 'labelAutoAngle', prefix, angle );
  };

  calculateEndProjection( 'source' );
  calculateEndProjection( 'target' );

  this.applyLabelDimensions( edge );
};

BRp.applyLabelDimensions = function( ele ){
  this.applyPrefixedLabelDimensions( ele );

  if( ele.isEdge() ){
    this.applyPrefixedLabelDimensions( ele, 'source' );
    this.applyPrefixedLabelDimensions( ele, 'target' );
  }
};

BRp.applyPrefixedLabelDimensions = function( ele, prefix ){
  var _p = ele._private;

  var text = this.getLabelText( ele, prefix );
  var labelDims = this.calculateLabelDimensions( ele, text );

  util.setPrefixedProperty( _p.rstyle,   'labelWidth', prefix, labelDims.width );
  util.setPrefixedProperty( _p.rscratch, 'labelWidth', prefix, labelDims.width );

  util.setPrefixedProperty( _p.rstyle,   'labelHeight', prefix, labelDims.height );
  util.setPrefixedProperty( _p.rscratch, 'labelHeight', prefix, labelDims.height );
};

BRp.getLabelText = function( ele, prefix ){
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle( pfd + 'label' ).strValue;
  var textTransform = ele.pstyle( 'text-transform' ).value;
  var rscratch = function( propName, value ){
    if( value ){
      util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
      return value;
    } else {
      return util.getPrefixedProperty( _p.rscratch, propName, prefix );
    }
  };

  if( textTransform == 'none' ){
    // passthrough
  } else if( textTransform == 'uppercase' ){
    text = text.toUpperCase();
  } else if( textTransform == 'lowercase' ){
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle( 'text-wrap' ).value;

  if( wrapStyle === 'wrap' ){
    //console.log('wrap');

    var labelKey = rscratch( 'labelKey' );

    // save recalc if the label is the same as before
    if( labelKey && rscratch( 'labelWrapKey' ) === labelKey ){
      // console.log('wrap cache hit');
      return rscratch( 'labelWrapCachedText' );
    }
    // console.log('wrap cache miss');

    var lines = text.split( '\n' );
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var wrappedLines = [];

    for( var l = 0; l < lines.length; l++ ){
      var line = lines[ l ];
      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
      var lineW = lineDims.width;

      if( lineW > maxW ){ // line is too long
        var words = line.split( /\s+/ ); // NB: assume collapsed whitespace into single space
        var subline = '';

        for( var w = 0; w < words.length; w++ ){
          var word = words[ w ];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
          var testW = testDims.width;

          if( testW <= maxW ){ // word fits on current line
            subline += word + ' ';
          } else { // word starts new line
            wrappedLines.push( subline );
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if( !subline.match( /^\s+$/ ) ){
          wrappedLines.push( subline );
        }
      } else { // line is already short enough
        wrappedLines.push( line );
      }
    } // for

    rscratch( 'labelWrapCachedLines', wrappedLines );
    text = rscratch( 'labelWrapCachedText', wrappedLines.join( '\n' ) );
    rscratch( 'labelWrapKey', labelKey );

    // console.log(text)
  } else if( wrapStyle === 'ellipsis' ){
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var ellipsized = '';
    var ellipsis = '\u2026';
    var incLastCh = false;

    for( var i = 0; i < text.length; i++ ){
      var widthWithNextCh = this.calculateLabelDimensions( ele, ellipsized + text[i] + ellipsis ).width;

      if( widthWithNextCh > maxW ){ break; }

      ellipsized += text[i];

      if( i === text.length - 1 ){ incLastCh = true; }
    }

    if( !incLastCh ){
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize

  return text;
};

BRp.calculateLabelDimensions = function( ele, text, extraKey ){
  var r = this;

  var cacheKey = ele._private.labelStyleKey + '$@$' + text;

  if( extraKey ){
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if( cache[ cacheKey ] ){
    return cache[ cacheKey ];
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ( sizeMult * ele.pstyle( 'font-size' ).pfValue ) + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;

  var div = this.labelCalcDiv;

  if( !div ){
    div = this.labelCalcDiv = document.createElement( 'div' ); // eslint-disable-line no-undef
    document.body.appendChild( div ); // eslint-disable-line no-undef
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[ cacheKey ] = {
    width: Math.ceil( div.clientWidth / sizeMult ),
    height: Math.ceil( div.clientHeight / sizeMult )
  };

  return cache[ cacheKey ];
};

BRp.recalculateEdgeProjections = function( edges ){
  this.findEdgeControlPoints( edges );
};


// Find edge control points
BRp.findEdgeControlPoints = function( edges ){
  if( !edges || edges.length === 0 ){ return; }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for( var i = 0; i < edges.length; i++ ){
    var edge = edges[ i ];
    var _p = edge._private;
    var data = _p.data;
    var curveStyle = edge.pstyle( 'curve-style' ).value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( edge.pstyle( 'display').value === 'none' ){
      continue;
    }

    if( curveStyle === 'haystack' ){
      haystackEdges.push( edge );
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ?
      tgtId + '$-$' + srcId :
      srcId + '$-$' + tgtId ;

    if( edgeIsUnbundled ){
      pairId = 'unbundled' + '$-$' + data.id;
    }

    if( hashTable[ pairId ] == null ){
      hashTable[ pairId ] = [];
      pairIds.push( pairId );
    }

    hashTable[ pairId ].push( edge );

    if( edgeIsUnbundled ){
      hashTable[ pairId ].hasUnbundled = true;
    }
  }

  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for( var p = 0; p < pairIds.length; p++ ){
    pairId = pairIds[ p ];
    var pairEdges = hashTable[ pairId ];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort( function( edge1, edge2 ){
      return edge1.poolIndex() - edge2.poolIndex();
    } );

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    // make sure src/tgt distinction is consistent for bundled edges
    if( !pairEdges.hasUnbundled && src.id() > tgt.id() ){
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    src_p = src._private;
    tgt_p = tgt._private;

    srcPos = src_p.position;
    tgtPos = tgt_p.position;

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[ this.getNodeShape( src ) ];
    tgtShape = r.nodeShapes[ this.getNodeShape( tgt ) ];

    badBezier = false;

    var edge;
    var edge_p;
    var rs;

    var dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    var srcX2 = srcPos.x;
    var srcY2 = srcPos.y;
    var srcW2 = srcW;
    var srcH2 = srcH;

    var tgtX2 = tgtPos.x;
    var tgtY2 = tgtPos.y;
    var tgtW2 = tgtW;
    var tgtH2 = tgtH;

    var numEdges2 = pairEdges.length;

    for( var i = 0; i < pairEdges.length; i++ ){
      edge = pairEdges[ i ];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;

      var curveStyle = edge.pstyle( 'curve-style' ).value;

      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      var ctrlptDists = edge.pstyle( 'control-point-distances' );
      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;
      var ctrlptWs = edge.pstyle( 'control-point-weights' );
      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
      var stepSize = edge.pstyle( 'control-point-step-size' ).pfValue;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeDistances = edge.pstyle('edge-distances').value;
      var segmentWs = edge.pstyle( 'segment-weights' );
      var segmentDs = edge.pstyle( 'segment-distances' );
      var segmentsN = Math.min( segmentWs.pfValue.length, segmentDs.pfValue.length );

      var srcX1 = rs.lastSrcCtlPtX;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcH1 = rs.lastSrcCtlPtH;

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtH1 = rs.lastTgtCtlPtH;

      var curveStyle1 = rs.lastCurveStyle;
      var curveStyle2 = curveStyle;

      var ctrlptDists1 = rs.lastCtrlptDists;
      var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;

      var ctrlptWs1 = rs.lastCtrlptWs;
      var ctrlptWs2 = ctrlptWs.strValue;

      var segmentWs1 = rs.lastSegmentWs;
      var segmentWs2 = segmentWs.strValue;

      var segmentDs1 = rs.lastSegmentDs;
      var segmentDs2 = segmentDs.strValue;

      var stepSize1 = rs.lastStepSize;
      var stepSize2 = stepSize;

      var loopDir1 = rs.lastLoopDir;
      var loopDir2 = loopDir;

      var loopSwp1 = rs.lastLoopSwp;
      var loopSwp2 = loopSwp;

      var edgeDistances1 = rs.lastEdgeDistances;
      var edgeDistances2 = edgeDistances;

      if( badBezier ){
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
      &&  curveStyle1 === curveStyle2
      &&  ctrlptDists1 === ctrlptDists2
      &&  ctrlptWs1 === ctrlptWs2
      &&  segmentWs1 === segmentWs2
      &&  segmentDs1 === segmentDs2
      &&  stepSize1 === stepSize2
      &&  loopDir1 === loopDir2
      &&  loopSwp1 === loopSwp2
      &&  edgeDistances1 === edgeDistances2
      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
        continue; // then the control points haven't changed and we can skip calculating them
      } else {
        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastCurveStyle = curveStyle2;
        rs.lastCtrlptDists = ctrlptDists2;
        rs.lastCtrlptWs = ctrlptWs2;
        rs.lastSegmentDs = segmentDs2;
        rs.lastSegmentWs = segmentWs2;
        rs.lastStepSize = stepSize2;
        rs.lastLoopDir = loopDir2;
        rs.lastLoopSwp = loopSwp2;
        rs.lastEdgeDistances = edgeDistances2;
      }

      if( !pairEdges.calculatedIntersection && ( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ) ){

        pairEdges.calculatedIntersection = true;

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          0
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          0
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var posPts = {
          x1: srcPos.x,
          x2: tgtPos.x,
          y1: srcPos.y,
          y2: tgtPos.y
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx * dx + dy * dy );

        var vector = {
          x: dx,
          y: dy
        };

        var vectorNorm = {
          x: vector.x / l,
          y: vector.y / l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };


        // if node shapes overlap, then no ctrl pts to draw
        if(
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  &&
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
        ){
          vectorNormInverse = {};
          badBezier = true;
        }

      }

      rs.srcIntn = srcOutside;
      rs.tgtIntn = tgtOutside;

      if( src === tgt ){
        // Self-edge

        rs.edgeType = 'self';

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var outAngle =  loopDir - loopSwp / 2;
        var inAngle  =  loopDir + loopSwp / 2;

        // increase by step size for overlapping loops, keyed on direction and sweep values
        var dc = String(loopDir + '_' + loopSwp);
        j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

        rs.ctrlpts = [
          srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)
        ];

      } else if(
        hasCompounds &&
        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
        ( src.parents().anySame( tgt ) || tgt.parents().anySame( src ) )
      ){
        // Compound edge

        rs.edgeType = 'compound';

        // because the line approximation doesn't apply for compound beziers
        // (loop/self edges are already elided b/c of cheap src==tgt check)
        rs.badBezier = false;

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var loopW = 50;

        var loopaPos = {
          x: srcPos.x - srcW / 2,
          y: srcPos.y - srcH / 2
        };

        var loopbPos = {
          x: tgtPos.x - tgtW / 2,
          y: tgtPos.y - tgtH / 2
        };

        var loopPos = {
          x: Math.min( loopaPos.x, loopbPos.x ),
          y: Math.min( loopaPos.y, loopbPos.y )
        };

        // avoids cases with impossible beziers
        var minCompoundStretch = 0.5;
        var compoundStretchA = Math.max( minCompoundStretch, Math.log( srcW * 0.01 ) );
        var compoundStretchB = Math.max( minCompoundStretch, Math.log( tgtW * 0.01 ) );

        rs.ctrlpts = [
          loopPos.x,
          loopPos.y - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,

          loopPos.x - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
          loopPos.y
        ];

      } else if( curveStyle === 'segments' ){
        // Segments (multiple straight lines)

        rs.edgeType = 'segments';
        rs.segpts = [];

        for( var s = 0; s < segmentsN; s++ ){
          var w = segmentWs.pfValue[ s ];
          var d = segmentDs.pfValue[ s ];

          var w1 = 1 - w;
          var w2 = w;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.segpts.push(
            adjustedMidpt.x + vectorNormInverse.x * d,
            adjustedMidpt.y + vectorNormInverse.y * d
          );
        }

      // Straight edge
      } else if(
        pairEdges.length % 2 === 1
        && i === Math.floor( pairEdges.length / 2 )
        && !edgeIsUnbundled
      ){

        rs.edgeType = 'straight';

      } else {
        // (Multi)bezier

        var multi = edgeIsUnbundled;

        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for( var b = 0; b < bezierN; b++ ){
          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manctrlptDist;
          var sign = math.signum( normctrlptDist );

          if( multi ){
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[ b ] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[ b ];
          }

          if( edgeIsUnbundled ){ // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

          var w1 = 1 - ctrlptWeight;
          var w2 = ctrlptWeight;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.ctrlpts.push(
            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
          );
        }

      }

      // find endpts for edge
      this.findEndpoints( edge );

      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );

      var minCpADistFactor = 3;
      var arrowW = this.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.arrowShapeWidth;
      var minCpADist = minCpADistFactor * arrowW;

      if( rs.edgeType === 'bezier' ){
        var startACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        var overlapping = false;

        if( badStart || badAStart || closeStartACp ){
          overlapping = true;

          // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var srcCtrlPtIntn = srcShape.intersectLine(
            srcPos.x,
            srcPos.y,
            srcW,
            srcH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeStartACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }

        if( badEnd || badAEnd || closeEndACp ){
          overlapping = true;

          // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var tgtCtrlPtIntn = tgtShape.intersectLine(
            tgtPos.x,
            tgtPos.y,
            tgtW,
            tgtH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeEndACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
          }

        }

        if( overlapping ){
          // recalc endpts
          this.findEndpoints( edge );
        }

      }

      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.allpts = [];

        rs.allpts.push( rs.startX, rs.startY );

        for( var b = 0; b + 1 < rs.ctrlpts.length; b += 2 ){
          // ctrl pt itself
          rs.allpts.push( rs.ctrlpts[ b ], rs.ctrlpts[ b + 1] );

          // the midpt between ctrlpts as intermediate destination pts
          if( b + 3 < rs.ctrlpts.length ){
            rs.allpts.push( (rs.ctrlpts[ b ] + rs.ctrlpts[ b + 2]) / 2, (rs.ctrlpts[ b + 1] + rs.ctrlpts[ b + 3]) / 2 );
          }
        }

        rs.allpts.push( rs.endX, rs.endY );

        var m, mt;
        if( rs.ctrlpts.length / 2 % 2 === 0 ){
          m = rs.allpts.length / 2 - 1;

          rs.midX = rs.allpts[ m ];
          rs.midY = rs.allpts[ m + 1];
        } else {
          m = rs.allpts.length / 2 - 3;
          mt = 0.5;

          rs.midX = math.qbezierAt( rs.allpts[ m ], rs.allpts[ m + 2], rs.allpts[ m + 4], mt );
          rs.midY = math.qbezierAt( rs.allpts[ m + 1], rs.allpts[ m + 3], rs.allpts[ m + 5], mt );
        }

      } else if( rs.edgeType === 'straight' ){
        // need to calc these after endpts
        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];

        // default midpt for labels etc
        rs.midX = ( rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX ) / 4;
        rs.midY = ( rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY ) / 4;

      } else if( rs.edgeType === 'segments' ){
        rs.allpts = [];
        rs.allpts.push( rs.startX, rs.startY );
        rs.allpts.push.apply( rs.allpts, rs.segpts );
        rs.allpts.push( rs.endX, rs.endY );

        if( rs.segpts.length % 4 === 0 ){
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;

          rs.midX = ( rs.segpts[ i1 ] + rs.segpts[ i2 ] ) / 2;
          rs.midY = ( rs.segpts[ i1 + 1] + rs.segpts[ i2 + 1] ) / 2;
        } else {
          var i1 = rs.segpts.length / 2 - 1;

          rs.midX = rs.segpts[ i1 ];
          rs.midY = rs.segpts[ i1 + 1];
        }


      }

      this.projectLines( edge );
      this.calculateArrowAngles( edge );
      this.recalculateEdgeLabelProjections( edge );
      this.calculateLabelAngles( edge );

    } // for pair edges
  } // for pair ids

  for( var i = 0; i < haystackEdges.length; i++ ){
    var edge = haystackEdges[ i ];
    var _p = edge._private;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if( !rscratch.haystack ){
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src._private.position;
    var tgtPos = tgt._private.position;
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle( 'haystack-radius' ).value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [
      rs.source.x * srcW * halfRadius + srcPos.x,
      rs.source.y * srcH * halfRadius + srcPos.y,
      rs.target.x * tgtW * halfRadius + tgtPos.x,
      rs.target.y * tgtH * halfRadius + tgtPos.y
    ];

    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = 'haystack';
    rscratch.haystack = true;

    this.projectLines( edge );
    this.calculateArrowAngles( edge );
    this.recalculateEdgeLabelProjections( edge );
    this.calculateLabelAngles( edge );
  }
};

var getAngleFromDisp = function( dispX, dispY ){
  return Math.atan2( dispY, dispX ) - Math.PI / 2;
};

BRp.calculateArrowAngles = function( edge ){
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  var srcPos = edge._private.source._private.position;
  var tgtPos = edge._private.target._private.position;

  if( isHaystack ){
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY;

  // source
  //

  if( isSegments ){
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var bX = math.qbezierAt( pts[0], pts[2], pts[4], 0.1 );
    var bY = math.qbezierAt( pts[1], pts[3], pts[5], 0.1 );

    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if( isHaystack ){
    midX = ( startX + endX ) / 2;
    midY = ( startY + endY ) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if( isSelf ){
    dispX = -1;
    dispY = 1;
  } else if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    }
  } else if( isMultibezier || isCompound ){
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if( cpts.length / 2 % 2 === 0 ){
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0001 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0001 );
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.4999 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.4999 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.5 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.5 );
    }

    dispX = ( bp1x - bp0x );
    dispY = ( bp1y - bp0y );
  }

  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -( pts[ i3 ] - pts[ i2 ] );
      dispY = -( pts[ i3 + 1] - pts[ i2 + 1] );
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );

  // target
  //

  if( isSegments ){
    dispX = endX - rs.segpts[ rs.segpts.length - 2 ];
    dispY = endY - rs.segpts[ rs.segpts.length - 1 ];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var l = pts.length;
    var bX = math.qbezierAt( pts[l-6], pts[l-4], pts[l-2], 0.9 );
    var bY = math.qbezierAt( pts[l-5], pts[l-3], pts[l-1], 0.9 );

    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
};

BRp.calculateLabelAngles = function( ele ){
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var rot = ele.pstyle( 'text-rotation' );
  var rotStr = rot.strValue;

  if( rotStr === 'none' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else if( isEdge && rotStr === 'autorotate' ){
    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
    rs.targetLabelAngle = rs.targetLabelAutoAngle;
  } else if( rotStr === 'autorotate' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
  }
};

BRp.manualEndptToPx = function( node, prop ){
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if( prop.value.length === 2 ){
    var p = [
      prop.pfValue[0],
      prop.pfValue[1]
    ];

    if( prop.units[0] === '%' ){
      p[0] = p[0] * w;
    }

    if( prop.units[1] === '%' ){
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;

    return p;
  } else {
    var angle = prop.pfValue[0];

    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max( w, h );

    var p = [
      npos.x + Math.cos( angle ) * l,
      npos.y + Math.sin( angle ) * l
    ];

    return r.nodeShapes[ this.getNodeShape( node ) ].intersectLine(
      npos.x, npos.y,
      w, h,
      p[0], p[1],
      0
    );
  }
};

BRp.findEndpoints = function( edge ){
  var r = this;
  var intersect;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var src_p = source._private;
  var tgt_p = target._private;

  var srcPos = src_p.position;
  var tgtPos = tgt_p.position;

  var tgtArShape = edge.pstyle( 'target-arrow-shape' ).value;
  var srcArShape = edge.pstyle( 'source-arrow-shape' ).value;

  var tgtDist = edge.pstyle( 'target-distance-from-node' ).pfValue;
  var srcDist = edge.pstyle( 'source-distance-from-node' ).pfValue;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var tgtManEndpt = edge.pstyle('target-endpoint');

  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;

  var p1; // last known point of edge on target side
  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape
  var p2_i; // point to intersect with source shape

  if( bezier ){
    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
    var cpEnd = multi ? [ rs.ctrlpts[ rs.ctrlpts.length - 2], rs.ctrlpts[ rs.ctrlpts.length - 1] ] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if( lines ){
    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if( tgtManEndpt.value === 'inside-to-node' ){
    intersect = [ tgtPos.x, tgtPos.y ];
  } else if( tgtManEndpt.units ){
    intersect = this.manualEndptToPx( target, tgtManEndpt );
  } else if( tgtManEndpt.value === 'outside-to-line' ){
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if( tgtManEndpt.value === 'outside-to-node' ){
      p1_i = p1;
    } else if( tgtManEndpt.value === 'outside-to-line' ){
      p1_i = [ srcPos.x, srcPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( target ) ].intersectLine(
      tgtPos.x,
      tgtPos.y,
      target.outerWidth(),
      target.outerHeight(),
      p1_i[0],
      p1_i[1],
      0
    );
  }

  var arrowEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].spacing( edge ) + tgtDist
  );
  var edgeEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].gap( edge ) + tgtDist
  );

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if( srcManEndpt.value === 'inside-to-node' ){
    intersect = [ srcPos.x, srcPos.y ];
  } else if( srcManEndpt.units ){
    intersect = this.manualEndptToPx( source, srcManEndpt );
  } else if( srcManEndpt.value === 'outside-to-line' ){
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if( srcManEndpt.value === 'outside-to-node' ){
      p2_i = p2;
    } else if( srcManEndpt.value === 'outside-to-line' ){
      p2_i = [ tgtPos.x, tgtPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( source ) ].intersectLine(
      srcPos.x,
      srcPos.y,
      source.outerWidth(),
      source.outerHeight(),
      p2_i[0],
      p2_i[1],
      0
    );
  }

  var arrowStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].spacing( edge ) + srcDist
  );
  var edgeStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].gap( edge ) + srcDist
  );

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if( hasEndpts ){
    if( !is.number( rs.startX ) || !is.number( rs.startY ) || !is.number( rs.endX ) || !is.number( rs.endY ) ){
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getArrowWidth = BRp.getArrowHeight = function( edgeWidth, scale ){
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[ edgeWidth + ', ' + scale ];
  if( cachedVal ){
    return cachedVal;
  }

  cachedVal =  Math.max( Math.pow( edgeWidth * 13.37, 0.9 ), 29 ) * scale;
  cache[ edgeWidth + ', ' + scale ] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

},{"../../../collection/zsort":32,"../../../is":82,"../../../math":84,"../../../util":99,"../../../window":107}],59:[function(_dereq_,module,exports){
'use strict';

var BRp = {};

BRp.getCachedImage = function( url, crossOrigin, onLoad ){
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[ url ];

  if( cache ){
    if( !cache.image.complete ){
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[ url ] = imageCache[ url ] || {};

    var image = cache.image = new Image(); // eslint-disable-line no-undef
    image.addEventListener('load', onLoad);

    // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978
    var dataUriPrefix = 'data:';
    var isDataUri = url.substring( 0, dataUriPrefix.length ).toLowerCase() === dataUriPrefix;
    if( !isDataUri ){
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;

    return image;
  }
};

module.exports = BRp;

},{}],60:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../../is' );
var util = _dereq_( '../../../util' );

var BaseRenderer = function( options ){ this.init( options ); };
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];

BRp.init = function( options ){
  var r = this;

  r.options = options;

  r.cy = options.cy;

  r.container = options.cy.container();

  r.selection = [ undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [ 0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95 ];

  //--Pointer-related data
  r.hoverData = {down: null, last: null,
      downTime: null, triggerMode: null,
      dragging: false,
      initialPan: [ null, null ], capture: false};

  r.dragData = {possibleDragElements: []};

  r.touchData = {
    start: null, capture: false,

    // These 3 fields related to tap, taphold events
    startPosition: [ null, null, null, null, null, null ],
    singleTouchStartTime: null,
    singleTouchMoved: true,

    now: [ null, null, null, null, null, null ],
    earlier: [ null, null, null, null, null, null ]
  };

  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = options.motionBlur; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = { // higher priority execs before lower one
    animations:   400,
    eleCalcs:     300,
    eleTxrDeq:    200,
    lyrTxrDeq:    100
  };

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
  r.load();
};

BRp.notify = function( params ){
  var types;
  var r = this;

  // the renderer can't be notified after it's destroyed
  if( this.destroyed ){ return; }

  if( is.array( params.type ) ){
    types = params.type;

  } else {
    types = [ params.type ];
  }

  var has = {};
  for( var i = 0; i < types.length; i++ ){
    var type = types[ i ];

    has[ type ] = true;
  } // for

  if( has['destroy'] ){
    r.destroy();
    return;
  }

  if( has['add'] || has['remove'] || has['load'] || has['zorder'] ){
    r.invalidateCachedZSortedEles();
  }

  if( has['viewport'] ){
    r.redrawHint( 'select', true );
  }

  if( has['load'] || has['resize'] ){
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize( r.container );
  }

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function(){
  var r = this;

  r.destroyed = true;

  r.cy.stopAnimationLoop();

  for( var i = 0; i < r.bindings.length; i++ ){
    var binding = r.bindings[ i ];
    var b = binding;
    var tgt = b.target;

    ( tgt.off || tgt.removeEventListener ).apply( tgt, b.args );
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if( r.removeObserver ){
    r.removeObserver.disconnect();
  }

  if( r.styleObserver ){
    r.styleObserver.disconnect();
  }

  if( r.labelCalcDiv ){
    try {
      document.body.removeChild( r.labelCalcDiv ); // eslint-disable-line no-undef
    } catch( e ){
      // ie10 issue #1014
    }
  }
};

[
  _dereq_( './arrow-shapes' ),
  _dereq_( './coord-ele-math' ),
  _dereq_( './images' ),
  _dereq_( './load-listeners' ),
  _dereq_( './node-shapes' ),
  _dereq_( './redraw' )
].forEach( function( props ){
  util.extend( BRp, props );
} );

module.exports = BR;

},{"../../../is":82,"../../../util":99,"./arrow-shapes":57,"./coord-ele-math":58,"./images":59,"./load-listeners":61,"./node-shapes":62,"./redraw":63}],61:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../../is' );
var util = _dereq_( '../../../util' );
var math = _dereq_( '../../../math' );
var Event = _dereq_( '../../../event' );

var BRp = {};

BRp.registerBinding = function( target, event, handler, useCapture ){
  var args = Array.prototype.slice.apply( arguments, [1] ); // copy
  var b = this.binder( target );

  return b.on.apply( b, args );
};

BRp.binder = function( tgt ){
  var r = this;

  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement( tgt );

  if( r.supportsPassiveEvents == null ){

    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty( {}, 'passive', {
        get: function(){
          supportsPassive = true;
        }
      } );

      window.addEventListener( 'test', null, opts );
    } catch( err ){}

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function( event, handler, useCapture ){
    var args = Array.prototype.slice.call( arguments );

    if( tgtIsDom && r.supportsPassiveEvents ){ // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });

    ( tgt.addEventListener || tgt.on ).apply( tgt, args );

    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp.nodeIsDraggable = function( node ){
  return (
    node
    && node.isNode()
    && !node.locked()
    && node.grabbable()
  );
};

BRp.nodeIsGrabbable = function( node ){
  return (
    this.nodeIsDraggable( node )
    && node.interactive()
  );
};

BRp.load = function(){
  var r = this;

  var triggerEvents = function( target, names, e, props ){
    if( target == null ){
      target = r.cy;
    }

    for( var i = 0; i < names.length; i++ ){
      var name = names[ i ];

      var event = new Event( e, util.extend( { type: name }, props ) );
      target.trigger( event );
    }
  };

  var isMultSelKeyDown = function( e ){
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function( down, downs ){
    var allowPassthrough = true;

    if( r.cy.hasCompoundNodes() && down && down.isEdge() ){
      // a compound node below the edge => no passthrough panning
      for( var i = 0; downs && i < downs.length; i++ ){
        var down = downs[i];

        if( down.isNode() && down.isParent() ){
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var getDragListIds = function( opts ){
    var listHasId;

    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for( var i = 0; i < opts.addToList.length; i++ ){
          var ele = opts.addToList[ i ];

          opts.addToList.hasId[ ele.id() ] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  var setGrabbed = function( ele ){
    ele[0]._private.grabbed = true;
  };

  var setFreed = function( ele ){
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function( ele, opts ){
    var listHasId = getDragListIds( opts );

    if( !listHasId[ ele.id() ] ){
      opts.addToList.push( ele );
      listHasId[ ele.id() ] = true;

      setGrabbed( ele );
    }
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function( node, opts ){
    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    var innerNodes = node.descendants();

    if( opts.inDragLayer ){
      innerNodes.forEach( setInDragLayer );
      innerNodes.connectedEdges().forEach( setInDragLayer );
    }

    if( opts.addToList ){
      innerNodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  // adds the given nodes and its neighbourhood to the drag layer
  var addNodesToDrag = function( nodes, opts ){
    opts = opts || {};

    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if( opts.inDragLayer ){
      nodes.forEach( setInDragLayer );

      nodes.neighborhood().stdFilter(function( ele ){
        return !hasCompoundNodes || ele.isEdge();
      }).forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }

    addDescendantsToDrag( nodes, opts ); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer( nodes, {
      inDragLayer: opts.inDragLayer
    } );

    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function( grabbedEles ){
    if( !grabbedEles ){ return; }

    grabbedEles.hasId = {}; // clear the id list

    // just go over all elements rather than doing a bunch of (possibly expensive) traversals
    r.getCachedZSortedEles().forEach(function( ele ){
      setFreed( ele );
      setOutDragLayer( ele );
      removeGrabTarget( ele );
    });

    r.updateCachedGrabbedEles();
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function( node, opts ){

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    // find top-level parent
    var parent = node.ancestors().orphans();

    // no parent node: no nodes to add to the drag layer
    if( parent.same( node ) ){
      return;
    }

    var nodes = parent.descendants().spawnSelf()
      .merge( parent )
      .unmerge( node )
      .unmerge( node.descendants() )
    ;

    var edges = nodes.connectedEdges();

    if( opts.inDragLayer ){
      edges.forEach( setInDragLayer );
      nodes.forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';

  // watch for when the cy container is removed from the dom
  if( haveMutationsApi ){
    r.removeObserver = new MutationObserver( function( mutns ){ // eslint-disable-line no-undef
      for( var i = 0; i < mutns.length; i++ ){
        var mutn = mutns[ i ];
        var rNodes = mutn.removedNodes;

        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
          var rNode = rNodes[ j ];

          if( rNode === r.container ){
            r.destroy();
            break;
          }
        } }
      }
    } );

    if( r.container.parentNode ){
      r.removeObserver.observe( r.container.parentNode, { childList: true } );
    }
  } else {
    r.registerBinding( r.container, 'DOMNodeRemoved', function( e ){
      r.destroy();
    } );
  }

  var onResize = util.debounce( function(){
    r.cy.invalidateSize();
    r.invalidateContainerClientCoordsCache();

    r.matchCanvasSize( r.container );
    r.redrawHint( 'eles', true );
    r.redrawHint( 'drag', true );
    r.redraw();
  }, 100 );

  if( haveMutationsApi ){
    r.styleObserver = new MutationObserver( onResize ); // eslint-disable-line no-undef

    r.styleObserver.observe( r.container, { attributes: true } );
  }

  // auto resize
  r.registerBinding( window, 'resize', onResize ); // eslint-disable-line no-undef

  var invalCtnrBBOnScroll = function( domEle ){
    r.registerBinding( domEle, 'scroll', function( e ){
      r.invalidateContainerClientCoordsCache();
    } );
  };

  var bbCtnr = r.cy.container();

  for( ;; ){

    invalCtnrBBOnScroll( bbCtnr );

    if( bbCtnr.parentNode ){
      bbCtnr = bbCtnr.parentNode;
    } else {
      break;
    }

  }

  // stop right click menu from appearing on cy
  r.registerBinding( r.container, 'contextmenu', function( e ){
    e.preventDefault();
  } );

  var inBoxSelection = function(){
    return r.selection[4] !== 0;
  };

  var eventInContainer = function( e ){
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];

    var positions = e.touches ? e.touches : [ e ];
    var atLeastOnePosInside = false;

    for( var i = 0; i < positions.length; i++ ){
      var p = positions[i];

      if( x <= p.clientX && p.clientX <= x + width
        && y <= p.clientY && p.clientY <= y + height
      ){
        atLeastOnePosInside = true;
        break;
      }
    }

    if( !atLeastOnePosInside ){ return false; }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while( tParent ){
      if( tParent === container ){
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if( !containerIsTarget ){ return false; } // if target is outisde cy container, then this event is not for us

    return true;
  };

  // Primary key
  r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){
    if( !eventInContainer(e) ){ return; }

    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var select = r.selection;
    var nears = r.findNearestElements( pos[0], pos[1], true, false );
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout( function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.trigger( new Event( e, {
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            } ) );
          } else {
            cy.trigger( new Event( e, {
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            } ) );
          }
        }

      }, r.tapholdDuration );
    };

    // Right click button
    if( e.which == 3 ){

      r.hoverData.cxtStarted = true;

      var cxtEvt = new Event( e, {
        type: 'cxttapstart',
        position: { x: pos[0], y: pos[1] }
      } );

      if( near ){
        near.activate();
        near.trigger( cxtEvt );

        r.hoverData.down = near;
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.downTime = (new Date()).getTime();
      r.hoverData.cxtDragged = false;

    // Primary button
    } else if( e.which == 1 ){

      if( near ){
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if( near != null ){

          if( r.nodeIsGrabbable( near ) ){

            var makeEvent = function( type ){
              return new Event( e, {
                type: type,
                position: { x: pos[0], y: pos[1] }
              } );
            };

            var triggerGrab = function( ele ){
              ele.trigger( makeEvent('grab') );
            };

            setGrabTarget( near );

            if( !near.selected() ){

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag( near, { addToList: draggedElements } );

              near.trigger( makeEvent('grabon') ).trigger( makeEvent('grab') );

            } else {
              draggedElements = r.dragData.possibleDragElements = [  ];

              var selectedNodes = cy.$( function( ele ){ return ele.isNode() && ele.selected() && r.nodeIsGrabbable( ele ); } );

              addNodesToDrag( selectedNodes, { addToList: draggedElements } );

              near.trigger( makeEvent('grabon') );

              selectedNodes.forEach( triggerGrab );
            }

            r.redrawHint( 'eles', true );
            r.redrawHint( 'drag', true );

          }

        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = (new Date()).getTime();
      }

      triggerEvents( near, [ 'mousedown', 'tapstart', 'vmousedown' ], e, {
        position: { x: pos[0], y: pos[1] }
      } );

      if( near == null ){
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );

        r.redraw();
      } else if( near.isEdge() ){
        select[4] = 1; // for future pan
      }

      checkForTaphold();

    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];

  }, false );

  r.registerBinding( window, 'mousemove', function mousemoveHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;

    var near = null;
    if( !r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting ){
      near = r.findNearestElement( pos[0], pos[1], true, false );
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [ pos[0] - select[2], pos[1] - select[3] ];

    var draggedElements = r.dragData.possibleDragElements;

    var isOverThresholdDrag;

    if( mdownGPos ){
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown( e );

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function(){
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if( dragDelta.length === 0 ){
        dragDelta.push( disp[0] );
        dragDelta.push( disp[1] );
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };


    preventDefault = true;

    triggerEvents( near, [ 'mousemove', 'vmousemove', 'tapdrag' ], e, {
      position: { x: pos[0], y: pos[1] }
    } );

    var goIntoBoxMode = function(){
      r.data.bgActivePosistion = undefined;

      if( !r.hoverData.selecting ){
        cy.trigger('boxstart');
      }

      select[4] = 1;
      r.hoverData.selecting = true;

      r.redrawHint( 'select', true );
      r.redraw();
    };

    // trigger context drag if rmouse down
    if( r.hoverData.which === 3 ){
      // but only if over threshold
      if( isOverThresholdDrag ){
        var cxtEvt = new Event( e, {
          type: 'cxtdrag',
          position: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new Event( e, {
              type: 'cxtdragout',
              position: { x: pos[0], y: pos[1] }
            } ) );
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new Event( e, {
              type: 'cxtdragover',
              position: { x: pos[0], y: pos[1] }
            } ) );
          }

        }
      }

    // Check if we are drag panning the entire graph
    } else if( r.hoverData.dragging ){
      preventDefault = true;

      if( cy.panningEnabled() && cy.userPanningEnabled() ){
        var deltaP;

        if( r.hoverData.justStartedPan ){
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: ( pos[0] - mdPos[0] ) * zoom,
            y: ( pos[1] - mdPos[1] ) * zoom
          };

          r.hoverData.justStartedPan = false;

        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };

        }

        cy.panBy( deltaP );

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport( e.clientX, e.clientY );

    // Checks primary button down & out of time & mouse not moved much
    } else if(
        select[4] == 1 && (down == null || down.isEdge())
    ){

      if( isOverThresholdDrag ){

        if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
          goIntoBoxMode();

        } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
          var allowPassthrough = allowPanningPassthrough( down, r.hoverData.downs );

          if( allowPassthrough ){
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;

            r.data.bgActivePosistion = math.array2point( mdownPos );

            r.redrawHint( 'select', true );
            r.redraw();
          }
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      }

    } else {
      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      if( ( !down || !down.grabbed() ) && near != last ){

        if( last ){
          triggerEvents( last, [ 'mouseout', 'tapdragout' ], e, {
            position: { x: pos[0], y: pos[1] }
          } );
        }

        if( near ){
          triggerEvents( near, [ 'mouseover', 'tapdragover' ], e, {
            position: { x: pos[0], y: pos[1] }
          } );
        }

        r.hoverData.last = near;
      }

      if( down && r.nodeIsDraggable( down ) ){

        if( isOverThresholdDrag ){ // then we can take action

          if( cy.boxSelectionEnabled() && multSelKeyDown ){ // then selection overrides
            if( down && down.grabbed() ){
              freeDraggedElements( draggedElements );

              down.trigger('free');
            }

            goIntoBoxMode();

          } else { // otherwise drag
            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ){
              r.redrawHint( 'eles', true );
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            // now, add the elements to the drag layer if not done already
            if( !r.hoverData.draggingEles ){
              addNodesToDrag( cy.collection( draggedElements ), { inDragLayer: true } );
            }

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[ i ];

              // Locked nodes not draggable, as well as non-visible nodes
              if( r.nodeIsDraggable( dEle ) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( is.number( disp[0] ) && is.number( disp[1] ) ){
                  var updatePos = !dEle.isParent();

                  if( updatePos ){
                    dPos.x += disp[0];
                    dPos.y += disp[1];
                  }

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = cy.collection( toTrigger );

            tcol.dirtyCompoundBoundsCache();
            tcol.trigger( 'position drag' );

            r.redrawHint( 'drag', true );
            r.redraw();
          }

        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0]; select[3] = pos[1];

    if( preventDefault ){
      if( e.stopPropagation ) e.stopPropagation();
      if( e.preventDefault ) e.preventDefault();
      return false;
    }
  }, false );

  r.registerBinding( window, 'mouseup', function mouseupHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;
    if( !capture ){ return; }
    r.hoverData.capture = false;

    var cy = r.cy; var pos = r.projectIntoViewport( e.clientX, e.clientY ); var select = r.selection;
    var near = r.findNearestElement( pos[0], pos[1], true, false );
    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown( e );

    if( r.data.bgActivePosistion ){
      r.redrawHint( 'select', true );
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if( down ){
      down.unactivate();
    }

    if( r.hoverData.which === 3 ){
      var cxtEvt = new Event( e, {
        type: 'cxttapend',
        position: { x: pos[0], y: pos[1] }
      } );

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( !r.hoverData.cxtDragged ){
        var cxtTap = new Event( e, {
          type: 'cxttap',
          position: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtTap );
        } else {
          cy.trigger( cxtTap );
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;

    } else if( r.hoverData.which === 1 ){

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if( (down == null) // not mousedown on node
        && !r.dragData.didDrag // didn't move the node around
        && !r.hoverData.selecting // not box selection
        && !r.hoverData.dragged // didn't pan
        && !isMultSelKeyDown( e )
      ){

        cy.$( function( ele ){ return ele.selected(); } ).unselect();

        if( draggedElements.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents( near, [ 'mouseup', 'tapend', 'vmouseup' ], e, {
        position: { x: pos[0], y: pos[1] }
      } );

      if(
        !r.dragData.didDrag // didn't move a node around
        && !r.hoverData.dragged // didn't pan
        && !r.hoverData.selecting // not box selection
      ){
        triggerEvents( down, ['click', 'tap', 'vclick'], e, {
          position: { x: pos[0], y: pos[1] }
        } );
      }

      // Single selection
      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
        if( near != null && near._private.selectable ){

          if( r.hoverData.dragging ){
            // if panning, don't change selection state
          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
            if( near.selected() ){
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if( !multSelKeyDown ){
              cy.$( ':selected' ).unmerge( near ).unselect();
              near.select();
            }
          }

          r.redrawHint( 'eles', true );
        }
      }

      if( r.hoverData.selecting ){
        var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

        r.redrawHint( 'select', true );

        if( box.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        cy.trigger('boxend');

        var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

        if( cy.selectionType() === 'additive' ){
          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        } else {
          if( !multSelKeyDown ){
            cy.$( ':selected' ).unmerge( box ).unselect();
          }

          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        }

        // always need redraw in case eles unselectable
        r.redraw();

      }

      // Cancel drag pan
      if( r.hoverData.dragging ){
        r.hoverData.dragging = false;

        r.redrawHint( 'select', true );
        r.redrawHint( 'eles', true );

        r.redraw();
      }

      if( !select[4] ) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        var downWasGrabbed = down && down.grabbed();

        freeDraggedElements( draggedElements );

        if( downWasGrabbed ){ down.trigger('free'); }
      }

    } // else not right mouse

    select[4] = 0; r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;

  }, false );

  var wheelHandler = function( e ){


    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport( e.clientX, e.clientY );
    var rpos = [ pos[0] * cy.zoom() + cy.pan().x,
                  pos[1] * cy.zoom() + cy.pan().y ];

    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout( r.data.wheelTimeout );
      r.data.wheelTimeout = setTimeout( function(){
        r.data.wheelZooming = false;

        r.redrawHint( 'eles', true );
        r.redraw();
      }, 150 );

      var diff;

      if( e.deltaY != null ){
        diff = e.deltaY / -250;
      } else if( e.wheelDeltaY != null ){
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom( {
        level: cy.zoom() * Math.pow( 10, diff ),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      } );
    }

  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding( r.container, 'wheel', wheelHandler, true );

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding( window, 'scroll', function scrollHandler( e ){ // eslint-disable-line no-undef
    r.scrollingPage = true;

    clearTimeout( r.scrollingPageTimeout );
    r.scrollingPageTimeout = setTimeout( function(){
      r.scrollingPage = false;
    }, 250 );
  }, true );

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container
  r.registerBinding( r.container, 'mouseout', function mouseOutHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseout',
      position: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  r.registerBinding( r.container, 'mouseover', function mouseOverHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseover',
      position: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function( x1, y1, x2, y2 ){
    return Math.sqrt( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) );
  };

  var distanceSq = function( x1, y1, x2, y2 ){
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding( r.container, 'touchstart', touchstartHandler = function( e ){
    if( !eventInContainer(e) ){ return; }

    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    // record starting points for pinch-to-zoom
    if( e.touches[1] ){

      freeDraggedElements( r.dragData.touchDragEles );

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside =
           0 <= f1x1 && f1x1 <= containerWidth
        && 0 <= f2x1 && f2x1 <= containerWidth
        && 0 <= f1y1 && f1y1 <= containerHeight
        && 0 <= f2y1 && f2y1 <= containerHeight
      ;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
      center1 = [ (f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2 ];
      modelCenter1 = [
        (center1[0] - pan.x) / zoom,
        (center1[1] - pan.y) / zoom
      ];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

        var near1 = r.findNearestElement( now[0], now[1], true, true );
        var near2 = r.findNearestElement( now[2], now[3], true, true );

        if( near1 && near1.isNode() ){
          near1.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near1;

        } else if( near2 && near2.isNode() ){
          near2.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near2;

        } else {
          cy.trigger( new Event( e, {
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          } ) );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;

      }

    }

    if( e.touches[2] ){
      // ignore
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      var nears = r.findNearestElements( now[0], now[1], true, true );
      var near = nears[0];

      if( near != null ){
        near.activate();

        r.touchData.start = near;
        r.touchData.starts = nears;

        if( r.nodeIsGrabbable( near ) ){

          var draggedEles = r.dragData.touchDragEles = [];
          var selectedNodes = null;

          r.redrawHint( 'eles', true );
          r.redrawHint( 'drag', true );

          if( near.selected() ){
            // reset drag elements, since near will be added again

            selectedNodes = cy.$( function( ele ){
              return ele.selected() && r.nodeIsGrabbable( ele );
            } );

            addNodesToDrag( selectedNodes, { addToList: draggedEles } );
          } else {
            addNodeToDrag( near, { addToList: draggedEles } );
          }

          setGrabTarget( near );

          var makeEvent = function( type ){
            return new Event( e, {
              type: type,
              position: { x: now[0], y: now[1] }
            } );
          };

          near.trigger( makeEvent('grabon') )

          if( selectedNodes ){
            selectedNodes.forEach(function( n ){ n.trigger( makeEvent('grab') ); });
          } else {
            near.trigger( makeEvent('grab') );
          }
        }
      }

      triggerEvents( near, [ 'touchstart', 'tapstart', 'vmousedown' ], e, {
        position: { x: now[0], y: now[1] }
      } );

      if( near == null ){
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );
        r.redraw();
      }


      // Tap, taphold
      // -----

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout( r.touchData.tapholdTimeout );
      r.touchData.tapholdTimeout = setTimeout( function(){
        if(
            r.touchData.singleTouchMoved === false
            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
            && !r.touchData.selecting // box selection shouldn't allow taphold through
        ){
          triggerEvents( r.touchData.start, [ 'taphold' ], e, {
            position: { x: now[0], y: now[1] }
          } );

          if( !r.touchData.start ){
            cy.$( ':selected' ).unselect();
          }

        }
      }, r.tapholdDuration );
    }

    if( e.touches.length >= 1 ){
      var sPos = r.touchData.startPosition = [];

      for( var i = 0; i < now.length; i++ ){
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];

      r.touchData.startGPosition = [ touch0.clientX, touch0.clientY ];
    }

  }, false );

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) { // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if( capture && e.touches[0] && startGPos ){
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    }

    // context swipe cancelling
    if( capture && r.touchData.cxt ){
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
        r.touchData.cxt = false;

        r.data.bgActivePosistion = undefined;

        r.redrawHint( 'select', true );

        var cxtEvt = new Event( e, {
          type: 'cxttapend',
          position: { x: now[0], y: now[1] }
        } );

        if( r.touchData.start ){
          r.touchData.start
            .unactivate()
            .trigger( cxtEvt )
          ;

          r.touchData.start = null;
        } else {
          cy.trigger( cxtEvt );
        }
      }

    }

    // context swipe
    if( capture && r.touchData.cxt ){
      var cxtEvt = new Event( e, {
        type: 'cxtdrag',
        position: { x: now[0], y: now[1] }
      } );
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      if( r.touchData.start ){
        r.touchData.start.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement( now[0], now[1], true, true );

      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

        if( r.touchData.cxtOver ){
          r.touchData.cxtOver.trigger( new Event( e, {
            type: 'cxtdragout',
            position: { x: now[0], y: now[1] }
          } ) );
        }

        r.touchData.cxtOver = near;

        if( near ){
          near.trigger( new Event( e, {
            type: 'cxtdragover',
            position: { x: now[0], y: now[1] }
          } ) );

        }

      }

    // box selection
    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();

      if( !r.touchData.selecting ){
        cy.trigger('boxstart');
      }

      r.touchData.selecting = true;

      r.redrawHint( 'select', true );

      if( !select || select.length === 0 || select[0] === undefined ){
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

    // pinch to zoom
    } else if( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ){ // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;
      if( draggedEles ){
        r.redrawHint( 'drag', true );

        for( var i = 0; i < draggedEles.length; i++ ){
          var de_p = draggedEles[i]._private;

          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;


      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if( twoFingersStartInside ){
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if( r.touchData.start && r.touchData.start.active() ){
          var draggedEles = r.dragData.touchDragEles;

          freeDraggedElements( draggedEles );

          r.redrawHint( 'drag', true );
          r.redrawHint( 'eles', true );

          r.touchData.start
            .unactivate()
            .trigger( 'free' )
          ;
        }

        cy.viewport( {
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        } );

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
      if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
      if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    } else if( e.touches[0] ){
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near;

      if( !r.hoverData.draggingEles && !r.swipePanning ){
        near = r.findNearestElement( now[0], now[1], true, true );
      }

      if( capture && start != null ){
        e.preventDefault();
      }

      // dragging nodes
      if( capture && start != null && r.nodeIsDraggable( start ) ){

        if( isOverThresholdDrag ){ // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          if( justStartedDrag ){
            addNodesToDrag( cy.collection( draggedEles ), { inDragLayer: true } );
          }

          for( var k = 0; k < draggedEles.length; k++ ){
            var draggedEle = draggedEles[ k ];

            if( r.nodeIsDraggable( draggedEle ) && draggedEle.grabbed() ){
              r.dragData.didDrag = true;
              var dPos = draggedEle._private.position;
              var updatePos = !draggedEle.isParent();

              if( updatePos && is.number( disp[0] ) && is.number( disp[1] ) ){
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if( justStartedDrag ){
                r.redrawHint( 'eles', true );

                var dragDelta = r.touchData.dragDelta;

                if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }

              }
            }
          }

          var tcol = cy.collection( draggedEles );

          tcol.dirtyCompoundBoundsCache();
          tcol.trigger( 'position drag' );

          r.hoverData.draggingEles = true;

          r.redrawHint( 'drag', true );

          if(
               r.touchData.startPosition[0] == earlier[0]
            && r.touchData.startPosition[1] == earlier[1]
          ){

            r.redrawHint( 'eles', true );
          }

          r.redraw();
        } else { // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if( dragDelta.length === 0 ){
            dragDelta.push( disp[0] );
            dragDelta.push( disp[1] );
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents( (start || near), [ 'touchmove', 'tapdrag', 'vmousemove' ], e, {
          position: { x: now[0], y: now[1] }
        } );

        if( ( !start || !start.grabbed() ) && near != last ){
          if( last ){ last.trigger( new Event( e, { type: 'tapdragout', position: { x: now[0], y: now[1] } } ) ); }
          if( near ){ near.trigger( new Event( e, { type: 'tapdragover', position: { x: now[0], y: now[1] } } ) ); }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      if( capture ){
        for( var i = 0; i < now.length; i++ ){
          if( now[ i ]
            && r.touchData.startPosition[ i ]
            && isOverThresholdDrag ){

            r.touchData.singleTouchMoved = true;
          }
        }
      }

      // panning
      if(
          capture
          && ( start == null || start.isEdge() )
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){

        var allowPassthrough = allowPanningPassthrough( start, r.touchData.starts );

        if( allowPassthrough ){
          e.preventDefault();

          if( r.swipePanning ){
            cy.panBy( {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            } );

          } else if( isOverThresholdDrag ){
            r.swipePanning = true;

            cy.panBy( {
              x: dx * zoom,
              y: dy * zoom
            } );

            if( start ){
              start.unactivate();

              if( !r.data.bgActivePosistion ){
                r.data.bgActivePosistion = math.array2point( r.touchData.startPosition );
              }

              r.redrawHint( 'select', true );

              r.touchData.start = null;
            }
          }

        }

        // Re-project
        var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY );
        now[0] = pos[0]; now[1] = pos[1];
      }
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }
    //r.redraw();

  }, false );

  var touchcancelHandler;
  r.registerBinding( window, 'touchcancel', touchcancelHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    r.touchData.capture = false;

    if( start ){
      start.unactivate();
    }
  } );

  var touchendHandler;
  r.registerBinding( window, 'touchend', touchendHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if( capture ){
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    if( start ){
      start.unactivate();
    }

    var ctxTapend;
    if( r.touchData.cxt ){
      ctxTapend = new Event( e, {
        type: 'cxttapend',
        position: { x: now[0], y: now[1] }
      } );

      if( start ){
        start.trigger( ctxTapend );
      } else {
        cy.trigger( ctxTapend );
      }

      if( !r.touchData.cxtDragged ){
        var ctxTap = new Event( e, {
          type: 'cxttap',
          position: { x: now[0], y: now[1] }
        } );

        if( start ){
          start.trigger( ctxTap );
        } else {
          cy.trigger( ctxTap );
        }

      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
      r.touchData.selecting = false;

      var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint( 'select', true );

      cy.trigger('boxend');

      var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

      box
        .trigger('box')
        .stdFilter( eleWouldBeSelected )
          .select()
          .trigger('boxselect')
      ;

      if( box.nonempty() ){
        r.redrawHint( 'eles', true );
      }

      r.redraw();
    }

    if( start != null ){
      start.unactivate();
    }

    if( e.touches[2] ){
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      // ignore

    // Last touch released
    } else if( !e.touches[0] ){

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;

      if( start != null ){

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements( draggedEles );

        r.redrawHint( 'drag', true );
        r.redrawHint( 'eles', true );

        if( startWasGrabbed ){
          start.trigger( 'free' );
        }

        triggerEvents( start, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          position: { x: now[0], y: now[1] }
        } );

        start.unactivate();

        r.touchData.start = null;

      } else {
        var near = r.findNearestElement( now[0], now[1], true, true );

        triggerEvents( near, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          position: { x: now[0], y: now[1] }
        } );

      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if( start != null
          && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable
          && rdist2 < r.touchTapThreshold2
          && !r.pinching // pinch to zoom should not affect selection
      ){

        if( cy.selectionType() === 'single' ){
          cy.$( ':selected' ).unmerge( start ).unselect();
          start.select();
        } else {
          if( start.selected() ){
            start.unselect();
          } else {
            start.select();
          }
        }

        r.redrawHint( 'eles', true );
      }

      // Tap event, roughly same as mouse click event for touch
      if( !r.touchData.singleTouchMoved ){
        triggerEvents( start, [ 'tap', 'vclick' ], e, {
          position: { x: now[0], y: now[1] }
        } );
      }

      r.touchData.singleTouchMoved = true;
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }

    r.dragData.didDrag = false; // reset for next mousedown

    if( e.touches.length === 0 ){
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
    }

    if( e.touches.length < 2 ){
      r.pinching = false;
      r.redrawHint( 'eles', true );
      r.redraw();
    }

    //r.redraw();

  }, false );

  // fallback compatibility layer for ms pointer events
  if( typeof TouchEvent === 'undefined' ){

    var pointers = [];

    var makeTouch = function( e ){
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function( e ){
      return {
        event: e,
        touch: makeTouch( e )
      };
    };

    var addPointer = function( e ){
      pointers.push( makePointer( e ) );
    };

    var removePointer = function( e ){
      for( var i = 0; i < pointers.length; i++ ){
        var p = pointers[ i ];

        if( p.event.pointerId === e.pointerId ){
          pointers.splice( i, 1 );
          return;
        }
      }
    };

    var updatePointer = function( e ){
      var p = pointers.filter( function( p ){
        return p.event.pointerId === e.pointerId;
      } )[0];

      p.event = e;
      p.touch = makeTouch( e );
    };

    var addTouchesToEvent = function( e ){
      e.touches = pointers.map( function( p ){
        return p.touch;
      } );
    };

    r.registerBinding( r.container, 'pointerdown', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      addPointer( e );

      addTouchesToEvent( e );
      touchstartHandler( e );
    } );

    r.registerBinding( r.container, 'pointerup', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchendHandler( e );
    } );

    r.registerBinding( r.container, 'pointercancel', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchcancelHandler( e );
    } );

    r.registerBinding( r.container, 'pointermove', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      updatePointer( e );

      addTouchesToEvent( e );
      touchmoveHandler( e );
    } );

  }
};

module.exports = BRp;

},{"../../../event":45,"../../../is":82,"../../../math":84,"../../../util":99}],62:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');
var util = _dereq_('../../../util');

var BRp = {};

BRp.generatePolygon = function( name, points ){
  return ( this.nodeShapes[ name ] = {
    renderer: this,

    name: name,

    points: points,

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( 'polygon', context, centerX, centerY, width, height, this.points );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.polygonIntersectLine(
          x, y,
          this.points,
          nodeX,
          nodeY,
          width / 2, height / 2,
          padding )
        ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      return math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height, [0, -1], padding )
      ;
    }
  } );
};

BRp.generateEllipse = function(){
  return ( this.nodeShapes['ellipse'] = {
    renderer: this,

    name: 'ellipse',

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding )
      ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      x -= centerX;
      y -= centerY;

      x /= (width / 2 + padding);
      y /= (height / 2 + padding);

      return x * x + y * y <= 1;
    }
  } );
};

BRp.generateRoundRectangle = function(){
  return ( this.nodeShapes['roundrectangle'] = {
    renderer: this,

    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding )
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius( width, height );

      // Check hBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){
        return true;
      }

      // Check vBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x * x + y * y <= 1);
      };


      // Check top left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check top right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      return false;
    }
  } );
};

BRp.generateCutRectangle = function(){
  return ( this.nodeShapes['cutrectangle'] = {
    renderer: this,

    name: 'cutrectangle',

    cornerLength: math.getCutRectangleCornerLength(),

    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    generateCutTrianglePts: function( width, height, centerX, centerY ){
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;

      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
      return {
        topLeft: [ xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl ],
        topRight: [ xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl ],
        bottomRight: [ xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl ],
        bottomLeft: [ xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl ]
      };
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      var cPts = this.generateCutTrianglePts( width + 2*padding, height+2*padding, nodeX, nodeY );
      var pts = [].concat.apply([],
       [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4),
         cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)
       ]);

      return math.polygonIntersectLine( x, y, pts, nodeX, nodeY );
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      // Check hBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding ) ){
        return true;
      }

      // Check vBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding ) ){
        return true;
      }
      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return math.pointInsidePolygonPoints( x, y, cutTrianglePts.topLeft)
       || math.pointInsidePolygonPoints( x, y, cutTrianglePts.topRight )
       || math.pointInsidePolygonPoints( x, y, cutTrianglePts.bottomRight )
       || math.pointInsidePolygonPoints( x, y, cutTrianglePts.bottomLeft );
    }

  } );
};

BRp.generateBarrel = function(){
  return ( this.nodeShapes['barrel'] = {
    renderer: this,

    name: 'barrel',

    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding )
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius( width, height );

      // Check hBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){
        return true;
      }

      // Check vBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x * x + y * y <= 1);
      };


      // Check top left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check top right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      return false;
    }
  } );
};


BRp.registerNodeShapes = function(){
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  this.generateEllipse();

  this.generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare( 3, 0 ) );

  this.generatePolygon( 'rectangle', math.generateUnitNgonPointsFitToSquare( 4, 0 ) );
  nodeShapes[ 'square' ] = nodeShapes[ 'rectangle' ];

  this.generateRoundRectangle();

  this.generateCutRectangle();

  this.generateBarrel();

  this.generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );

  this.generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare( 5, 0 ) );

  this.generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare( 6, 0 ) );

  this.generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare( 7, 0 ) );

  this.generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare( 8, 0 ) );

  var star5Points = new Array( 20 );
  {
    var outerPoints = math.generateUnitNgonPoints( 5, 0 );
    var innerPoints = math.generateUnitNgonPoints( 5, Math.PI / 5 );

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt( 5 ));
    innerRadius *= 1.57;

    for( var i = 0;i < innerPoints.length / 2;i++ ){
      innerPoints[ i * 2] *= innerRadius;
      innerPoints[ i * 2 + 1] *= innerRadius;
    }

    for( var i = 0;i < 20 / 4;i++ ){
      star5Points[ i * 4] = outerPoints[ i * 2];
      star5Points[ i * 4 + 1] = outerPoints[ i * 2 + 1];

      star5Points[ i * 4 + 2] = innerPoints[ i * 2];
      star5Points[ i * 4 + 3] = innerPoints[ i * 2 + 1];
    }
  }

  star5Points = math.fitPolygonToSquare( star5Points );

  this.generatePolygon( 'star', star5Points );

  this.generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );

  this.generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

  nodeShapes.makePolygon = function( points ){

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join( '$' );
    var name = 'polygon-' + key;
    var shape;

    if( (shape = this[ name ]) ){ // got cached shape
      return shape;
    }

    // create and cache new shape
    return renderer.generatePolygon( name, points );
  };

};

module.exports = BRp;

},{"../../../math":84,"../../../util":99}],63:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../../util' );

var BRp = {};

BRp.timeToRender = function(){
  return this.redrawTotalTime / this.redrawCount;
};

BRp.redraw = function( options ){
  options = options || util.staticEmptyObject();

  var r = this;

  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }
  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp.beforeRender = function( fn, priority ){
  // the renderer can't add tick callbacks when destroyed
  if( this.destroyed ){ return; }

  priority = priority || 0;

  var cbs = this.beforeRenderCallbacks;

  cbs.push({ fn: fn, priority: priority });

  // higher priority callbacks executed first
  cbs.sort(function( a, b ){ return b.priority - a.priority; });
};

var beforeRenderCallbacks = function( r, willDraw, startTime ){
  var cbs = r.beforeRenderCallbacks;

  for( var i = 0; i < cbs.length; i++ ){
    cbs[i].fn( willDraw, startTime );
  }
};

BRp.startRenderLoop = function(){
  var r = this;

  if( r.renderLoopStarted ){
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function( requestTime ){
    if( r.destroyed ){ return; }

    if( r.requestedFrame && !r.skipFrame ){
      beforeRenderCallbacks( r, true, requestTime );

      var startTime = util.performanceNow();

      r.render( r.renderOptions );

      var endTime = r.lastDrawTime = util.performanceNow();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks( r, false, requestTime );
    }

    r.skipFrame = false;

    util.requestAnimationFrame( renderFn );
  };

  util.requestAnimationFrame( renderFn );

};

module.exports = BRp;

},{"../../../util":99}],64:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.arrowShapeImpl = function( name ){
  return ( impl || (impl = {
    'polygon': function( context, points ){
      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        context.lineTo( pt.x, pt.y );
      }
    },

    'triangle-backcurve': function( context, points, controlPoint ){
      var firstPt;

      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo( pt.x, pt.y );
      }

      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
    },

    'triangle-tee': function( context, trianglePoints, teePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }

      if( context.beginPath ){ context.beginPath(); }

        var teePts = teePoints;
        var firstTeePt = teePoints[0];
        context.moveTo( firstTeePt.x, firstTeePt.y );

        for( var i = 0; i < teePts.length; i++ ){
          var pt = teePts[ i ];

          context.lineTo( pt.x, pt.y );
        }
      if( context.closePath ){ context.closePath(); }
    },

    'triangle-cross': function( context, trianglePoints, crossLinePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }


      if( context.beginPath ){ context.beginPath(); }

      var crossLinePts = crossLinePoints;
      var firstTeePt = crossLinePoints[0];
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for( var i = 0; i < crossLinePts.length; i++ ){
        var pt = crossLinePts[ i ];

        context.lineTo( pt.x, pt.y );
      }
      if( context.closePath ){ context.closePath(); }
    },

    'circle': function( context, rx, ry, r ){
      context.arc( rx, ry, r, 0, Math.PI * 2, false );
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],65:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.drawEdge = function( context, edge, shiftToOriginWithBb, drawLabel, drawOverlayInstead ){
  var rs = edge._private.rscratch;
  var usePaths = this.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if( rs.badLine || isNaN(rs.allpts[0]) ){ // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  if( !edge.visible() ){ return; }

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  var overlayPadding = edge.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = edge.pstyle( 'overlay-opacity' ).value;
  var overlayColor = edge.pstyle( 'overlay-color' ).value;

  // Edge color & opacity
  if( drawOverlayInstead ){

    if( overlayOpacity === 0 ){ // exit early if no overlay
      return;
    }

    this.strokeStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );
    context.lineCap = 'round';

    if( rs.edgeType == 'self' && !usePaths ){
      context.lineCap = 'butt';
    }

  } else {
    var lineColor = edge.pstyle( 'line-color' ).value;

    this.strokeStyle( context, lineColor[0], lineColor[1], lineColor[2], edge.pstyle( 'opacity' ).value );

    context.lineCap = 'butt';
  }

  context.lineJoin = 'round';

  var edgeWidth = edge.pstyle( 'width' ).pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
  var lineStyle = drawOverlayInstead ? 'solid' : edge.pstyle( 'line-style' ).value;
  context.lineWidth = edgeWidth;

  this.drawEdgePath(
    edge,
    context,
    rs.allpts,
    lineStyle,
    edgeWidth
  );

  this.drawArrowheads( context, edge, drawOverlayInstead );

  if( !drawOverlayInstead ){
    this.drawEdge( context, edge, false, drawLabel, true );
  }

  this.drawElementText( context, edge, drawLabel );

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }
};


CRp.drawEdgePath = function( edge, context, pts, type, width ){
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if( usePaths ){
    var pathCacheKey = pts.join( '$' );
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if( keyMatches ){
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( canvasCxt.setLineDash ){ // for very outofdate browsers
    switch( type ){
      case 'dotted':
        canvasCxt.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        canvasCxt.setLineDash( [ 6, 3 ] );
        break;

      case 'solid':
        canvasCxt.setLineDash( [ ] );
        break;
    }
  }

  if( !pathCacheHit && !rs.badLine ){
    if( context.beginPath ){ context.beginPath(); }
    context.moveTo( pts[0], pts[1] );

    switch( rs.edgeType ){
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for( var i = 2; i + 3 < pts.length; i += 4 ){
          context.quadraticCurveTo( pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] );
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for( var i = 2; i + 1 < pts.length; i += 2 ){
          context.lineTo( pts[ i ], pts[ i + 1] );
        }
        break;
    }
  }

  context = canvasCxt;
  if( usePaths ){
    context.stroke( path );
  } else {
    context.stroke();
  }

  // reset any line dashes
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

};

CRp.drawArrowheads = function( context, edge, drawOverlayInstead ){
  if( drawOverlayInstead ){ return; } // don't do anything for overlays

  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
  }

  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );

  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
  }
};

CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
  if( isNaN( x ) || x == null || isNaN( y ) || y == null || isNaN( angle ) || angle == null ){ return; }

  var self = this;
  var arrowShape = edge.pstyle( prefix + '-arrow-shape' ).value;
  if( arrowShape === 'none' ) { return; }

  var arrowClearFill = edge.pstyle( prefix + '-arrow-fill' ).value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle( prefix + '-arrow-fill' ).value;
  var edgeWidth = edge.pstyle( 'width' ).pfValue;
  var opacity = edge.pstyle( 'opacity' ).value;

  var gco = context.globalCompositeOperation;

  var shapeImpl = self.arrowShapes[ arrowShape ];

  // check if the shape needs both fill and stroke operations to be drawn
  if( shapeImpl.forceStroke && arrowFill === 'filled' ){
    arrowFill = 'both';
  }

  if( opacity !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle( context, 255, 255, 255, 1 );
    self.strokeStyle( context, 255, 255, 255, 1 );

    self.drawArrowShape( edge, prefix, context,
      arrowClearFill, edgeWidth, arrowShape, x, y, angle
    );

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = edge.pstyle( prefix + '-arrow-color' ).value;
  self.fillStyle( context, color[0], color[1], color[2], opacity );
  self.strokeStyle( context, color[0], color[1], color[2], opacity );

  self.drawArrowShape( edge, prefix, context,
    arrowFill, edgeWidth, arrowShape, x, y, angle
  );
};

CRp.drawArrowShape = function( edge, arrowType, context, fill, edgeWidth, shape, x, y, angle ){
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var scale = edge.pstyle( 'arrow-scale' ).value;
  var size = this.getArrowWidth( edgeWidth, scale );
  var shapeImpl = r.arrowShapes[ shape ];

  if( usePaths ){
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[ arrowType ] === pathCacheKey;
    if( alreadyCached ){
      path = context = rs.arrowPathCache[ arrowType ];
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.arrowPathCacheKey[ arrowType ] = pathCacheKey;
      rs.arrowPathCache[ arrowType ] = path;
    }
  }

  if( context.beginPath ){ context.beginPath(); }

  if( !pathCacheHit ){
    shapeImpl.draw( context, size, angle, translation, edgeWidth );
  }

  if( !shapeImpl.leavePathOpen && context.closePath ){
    context.closePath();
  }

  context = canvasContext;

  if( fill === 'filled' || fill === 'both' ){
    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  if( fill === 'hollow' || fill === 'both' ){
    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
    context.lineJoin = 'miter';

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  }
};

module.exports = CRp;

},{}],66:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_( '../../../math' );

var CRp = {};

CRp.drawElement = function( context, ele, shiftToOriginWithBb, showLabel ){
  var r = this;

  if( ele.isNode() ){
    r.drawNode( context, ele, shiftToOriginWithBb, showLabel );
  } else {
    r.drawEdge( context, ele, shiftToOriginWithBb, showLabel );
  }
};

CRp.drawCachedElement = function( context, ele, pxRatio, extent ){
  var r = this;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  if( !extent || math.boundingBoxesIntersect( bb, extent ) ){
    var cache = r.data.eleTxrCache.getElement( ele, bb, pxRatio );

    if( cache ){
      context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );
    } else { // if the element is not cacheable, then draw directly
      r.drawElement( context, ele );
    }
  }
};

CRp.drawElements = function( context, eles ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawElement( context, ele );
  }
};

CRp.drawCachedElements = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawCachedNodes = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    if( !ele.isNode() ){ continue; }

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawLayeredElements = function( context, eles, pxRatio, extent ){
  var r = this;

  var layers = r.data.lyrTxrCache.getLayers( eles, pxRatio );

  if( layers ){
    for( var i = 0; i < layers.length; i++ ){
      var layer = layers[i];
      var bb = layer.bb;

      if( bb.w === 0 || bb.h === 0 ){ continue; }

      context.drawImage( layer.canvas, bb.x1, bb.y1, bb.w, bb.h );
    }
  } else { // fall back on plain caching if no layers
    r.drawCachedElements( context, eles, pxRatio, extent );
  }
};

CRp.drawDebugPoints = function( context, eles ){
  var draw = function( x, y, color ){
    context.fillStyle = color;
    context.fillRect( x - 1, y - 1, 3, 3 );
  }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.isNode() ){
      var p = ele.position();

      draw( p.x, p.y, 'magenta' );
    } else {
      var pts = rs.allpts;

      for( var j = 0; j + 1 < pts.length; j += 2 ){
        var x = pts[ j ];
        var y = pts[ j + 1 ];

        draw( x, y, 'cyan' );
      }

      draw( rs.midX, rs.midY, 'yellow' );
    }
  }
};

module.exports = CRp;

},{"../../../math":84}],67:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../../util' );
var getIndexedStyle = util.getIndexedStyle.bind( util );

var CRp = {};

CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
  var r = this;

  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if( iw <= 0 || ih <= 0 || w <= 0 || h <= 0 ){
    return;
  }

  context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
};

CRp.drawInscribedImage = function( context, img, node, index ){
  var r = this;
  var nodeX = node._private.position.x;
  var nodeY = node._private.position.y;
  var fit = getIndexedStyle( node, 'background-fit', 'value', index );
  var repeat = getIndexedStyle( node, 'background-repeat', 'value', index );
  var nodeW = node.width();
  var nodeH = node.height();
  var rs = node._private.rscratch;
  var clip = node.pstyle( 'background-clip' ).value;
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle( node, 'background-image-opacity', 'value', index );

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if( null == imgW || null == imgH ){
    document.body.appendChild( img ); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild( img ); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if( getIndexedStyle( node, 'background-width', 'value', index ) !== 'auto' ){
    if( getIndexedStyle( node, 'background-width', 'units', index ) === '%' ){
      w = getIndexedStyle( node, 'background-width', 'pfValue', index ) * nodeW;
    } else {
      w = getIndexedStyle( node, 'background-width', 'pfValue', index );
    }
  }

  if( getIndexedStyle( node, 'background-height', 'value', index ) !== 'auto' ){
    if( getIndexedStyle( node, 'background-height', 'units', index ) === '%' ){
      h = getIndexedStyle( node, 'background-height', 'pfValue', index ) * nodeH;
    } else {
      h = getIndexedStyle( node, 'background-height', 'pfValue', index );
    }
  }

  if( w === 0 || h === 0 ){
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if( fit === 'contain' ){
    var scale = Math.min( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;

  } else if( fit === 'cover' ){
    var scale = Math.max( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;
  }

  var x = (nodeX - nodeW / 2); // left
  if( getIndexedStyle( node, 'background-position-x', 'units', index ) === '%' ){
    x += (nodeW - w) * getIndexedStyle( node, 'background-position-x', 'pfValue', index );
  } else {
    x += getIndexedStyle( node, 'background-position-x', 'pfValue', index );
  }

  var y = (nodeY - nodeH / 2); // top
  if( getIndexedStyle( node, 'background-position-y', 'units', index ) === '%' ){
    y += (nodeH - h) * getIndexedStyle( node, 'background-position-y', 'pfValue', index );
  } else {
    y += getIndexedStyle( node, 'background-position-y', 'pfValue', index );
  }

  if( rs.pathCache ){
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if( repeat === 'no-repeat' ){

    if( shouldClip ){
      context.save();

      if( rs.pathCache ){
        context.clip( rs.pathCache );
      } else {
        r.nodeShapes[ r.getNodeShape( node ) ].draw(
          context,
          nodeX, nodeY,
          nodeW, nodeH );

        context.clip();
      }
    }

    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );

    if( shouldClip ){
      context.restore();
    }
  } else {
    var pattern = context.createPattern( img, repeat );
    context.fillStyle = pattern;

    r.nodeShapes[ r.getNodeShape( node ) ].draw(
        context,
        nodeX, nodeY,
        nodeW, nodeH );

    context.translate( x, y );
    context.fill();
    context.translate( -x, -y );
  }

  context.globalAlpha = gAlpha;

};

module.exports = CRp;

},{"../../../util":99}],68:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../../util' );
var math = _dereq_( '../../../math' );

var CRp = {};

CRp.eleTextBiggerThanMin = function( ele, scale ){
  if( !scale ){
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil( math.log2( zoom * pxRatio ) ); // the effective texture level

    scale = Math.pow( 2, lvl );
  }

  var computedSize = ele.pstyle( 'font-size' ).pfValue * scale;
  var minSize = ele.pstyle( 'min-zoomed-font-size' ).pfValue;

  if( computedSize < minSize ){
    return false;
  }

  return true;
};

CRp.drawElementText = function( context, ele, force ){
  var r = this;

  if( force === undefined ){
    if( !r.eleTextBiggerThanMin( ele ) ){ return; }
  } else {
    if( !force ){ return; }
  }

  if( ele.isNode() ){
    var label = ele.pstyle( 'label' );

    if( !label || !label.value ){ return; }

    var textHalign = ele.pstyle( 'text-halign' ).strValue;
    var textValign = ele.pstyle( 'text-valign' ).strValue;

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    context.textBaseline = 'bottom';
  } else {
    var label = ele.pstyle( 'label' );
    var srcLabel = ele.pstyle( 'source-label' );
    var tgtLabel = ele.pstyle( 'target-label' );

    if(
      ( !label || !label.value )
      && ( !srcLabel || !srcLabel.value )
      && ( !tgtLabel || !tgtLabel.value )
    ){
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }


  r.drawText( context, ele );

  if( ele.isEdge() ){
    r.drawText( context, ele, 'source' );

    r.drawText( context, ele, 'target' );
  }
};

CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

CRp.getFontCache = function( context ){
  var cache;

  this.fontCaches = this.fontCaches || [];

  for( var i = 0; i < this.fontCaches.length; i++ ){
    cache = this.fontCaches[ i ];

    if( cache.context === context ){
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push( cache );

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function( context, ele ){
  // Font style
  var parentOpacity = ele.effectiveOpacity();
  var labelStyle = ele.pstyle( 'font-style' ).strValue;
  var labelSize = ele.pstyle( 'font-size' ).pfValue + 'px';
  var labelFamily = ele.pstyle( 'font-family' ).strValue;
  var labelWeight = ele.pstyle( 'font-weight' ).strValue;
  var opacity = ele.pstyle( 'text-opacity' ).value * ele.pstyle( 'opacity' ).value * parentOpacity;
  var outlineOpacity = ele.pstyle( 'text-outline-opacity' ).value * opacity;
  var color = ele.pstyle( 'color' ).value;
  var outlineColor = ele.pstyle( 'text-outline-color' ).value;

  var fontCacheKey = ele._private.fontKey;
  var cache = this.getFontCache( context );

  if( cache.key !== fontCacheKey ){
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle( context, color[ 0 ], color[ 1 ], color[ 2 ], opacity );

  this.strokeStyle( context, outlineColor[ 0 ], outlineColor[ 1 ], outlineColor[ 2 ], outlineOpacity );
};

function roundRect( ctx, x, y, width, height, radius ){
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo( x + radius, y );
  ctx.lineTo( x + width - radius, y );
  ctx.quadraticCurveTo( x + width, y, x + width, y + radius );
  ctx.lineTo( x + width, y + height - radius );
  ctx.quadraticCurveTo( x + width, y + height, x + width - radius, y + height );
  ctx.lineTo( x + radius, y + height );
  ctx.quadraticCurveTo( x, y + height, x, y + height - radius );
  ctx.lineTo( x, y + radius );
  ctx.quadraticCurveTo( x, y, x + radius, y );
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function( context, ele, prefix ){
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = ele.effectiveOpacity();
  if( parentOpacity === 0 || ele.pstyle( 'text-opacity' ).value === 0 ){
    return;
  }

  var textX = util.getPrefixedProperty( rscratch, 'labelX', prefix );
  var textY = util.getPrefixedProperty( rscratch, 'labelY', prefix );
  var text = this.getLabelText( ele, prefix );

  if( text != null && text !== '' && !isNaN( textX ) && !isNaN( textY ) ){
    this.setupTextStyle( context, ele );

    var pdash = prefix ? prefix + '-' : '';
    var textW = util.getPrefixedProperty( rscratch, 'labelWidth', prefix );
    var textH = util.getPrefixedProperty( rscratch, 'labelHeight', prefix );
    var textAngle = util.getPrefixedProperty( rscratch, 'labelAngle', prefix );
    var marginX = ele.pstyle( pdash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( pdash + 'text-margin-y' ).pfValue;

    var isEdge = ele.isEdge();
    var isNode = ele.isNode();

    var halign = ele.pstyle( 'text-halign' ).value;
    var valign = ele.pstyle( 'text-valign' ).value;

    if( isEdge ){
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;

    var rotation = ele.pstyle( 'text-rotation' );
    var theta;

    if( rotation.strValue === 'autorotate' ){
      theta = isEdge ? textAngle : 0;
    } else if( rotation.strValue === 'none' ){
      theta = 0;
    } else {
      theta = rotation.pfValue;
    }

    if( theta !== 0 ){
      var orgTextX = textX;
      var orgTextY = textY;

      context.translate( orgTextX, orgTextY );
      context.rotate( theta );

      textX = 0;
      textY = 0;
    }

    switch( valign ){
      case 'top':
        break;
      case 'center':
        textY += textH / 2;
        break;
      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle( 'text-background-opacity' ).value;
    var borderOpacity = ele.pstyle( 'text-border-opacity' ).value;
    var textBorderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var backgroundPadding = ele.pstyle( 'text-background-padding' ).pfValue;

    if( backgroundOpacity > 0 || ( textBorderWidth > 0 && borderOpacity > 0 ) ){
      var bgX = textX - backgroundPadding;

      switch( halign ){
        case 'left':
          bgX -= textW;
          break;
        case 'center':
          bgX -= textW / 2;
          break;
        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2*backgroundPadding;
      var bgH = textH + 2*backgroundPadding;

      if( backgroundOpacity > 0 ){
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle( 'text-background-color' ).value;

        context.fillStyle = 'rgba(' + textBackgroundColor[ 0 ] + ',' + textBackgroundColor[ 1 ] + ',' + textBackgroundColor[ 2 ] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle( 'text-background-shape' ).strValue;
        if( styleShape == 'roundrectangle' ){
          roundRect( context, bgX, bgY, bgW, bgH, 2 );
        } else {
          context.fillRect( bgX, bgY, bgW, bgH );
        }
        context.fillStyle = textFill;
      }

      if( textBorderWidth > 0 && borderOpacity > 0 ){
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle( 'text-border-color' ).value;
        var textBorderStyle = ele.pstyle( 'text-border-style' ).value;

        context.strokeStyle = 'rgba(' + textBorderColor[ 0 ] + ',' + textBorderColor[ 1 ] + ',' + textBorderColor[ 2 ] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if( context.setLineDash ){ // for very outofdate browsers
          switch( textBorderStyle ){
            case 'dotted':
              context.setLineDash( [ 1, 1 ] );
              break;
            case 'dashed':
              context.setLineDash( [ 4, 2 ] );
              break;
            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
              context.setLineDash( [] );
              break;
            case 'solid':
              context.setLineDash( [] );
              break;
          }
        }

        context.strokeRect( bgX, bgY, bgW, bgH );

        if( textBorderStyle === 'double' ){
          var whiteWidth = textBorderWidth / 2;

          context.strokeRect( bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2 );
        }

        if( context.setLineDash ){ // for very outofdate browsers
          context.setLineDash( [] );
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }

    }

    var lineWidth = 2 * ele.pstyle( 'text-outline-width' ).pfValue; // *2 b/c the stroke is drawn centred on the middle

    if( lineWidth > 0 ){
      context.lineWidth = lineWidth;
    }

    if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
      var lines = util.getPrefixedProperty( rscratch, 'labelWrapCachedLines', prefix );
      var lineHeight = textH / lines.length;

      switch( valign ){
        case 'top':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
        case 'center':
        case 'bottom':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
      }

      for( var l = 0; l < lines.length; l++ ){
        if( lineWidth > 0 ){
          context.strokeText( lines[ l ], textX, textY );
        }

        context.fillText( lines[ l ], textX, textY );

        textY += lineHeight;
      }

    } else {
      if( lineWidth > 0 ){
        context.strokeText( text, textX, textY );
      }

      context.fillText( text, textX, textY );
    }

    if( theta !== 0 ){
      context.rotate( -theta );
      context.translate( -orgTextX, -orgTextY );
    }
  }
};

module.exports = CRp;

},{"../../../math":84,"../../../util":99}],69:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../../is' );
var util = _dereq_( '../../../util' );
var getIndexedStyle = util.getIndexedStyle.bind( util );

var CRp = {};

CRp.drawNode = function( context, node, shiftToOriginWithBb, drawLabel ){
  var r = this;
  var nodeWidth, nodeHeight;
  var rs = node._private.rscratch;
  var _p = node._private;
  var pos = pos || _p.position;

  if( !is.number( pos.x ) || !is.number( pos.y ) ){
    return; // can't draw node with undefined position
  }

  if( !node.visible() ){ return; }

  var parentOpacity = node.effectiveOpacity();

  var usePaths = this.usePaths();
  var path;
  var pathCacheHit = false;

  var padding = node.padding();

  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;

  context.lineWidth = node.pstyle( 'border-width' ).pfValue;

  //
  // setup shift

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  //
  // load bg image

  var bgImgProp = node.pstyle( 'background-image' );
  var urls = bgImgProp.value;
  var url;
  var urlDefined = [];
  var image = [];
  var numImages = urls.length;
  for( var i = 0; i < numImages; i++ ){
    url = urls[i];
    urlDefined[i] = url != null && url !== 'none';
    if( urlDefined[i] ){
      var bgImgCrossOrigin = getIndexedStyle(node, 'background-image-crossorigin', 'value', i);

      // get image, and if not loaded then ask to redraw when later loaded
      image[i] = this.getCachedImage( url, bgImgCrossOrigin, function(){
        node.rtrigger('background');
      } );
    }
  }

  //
  // setup styles

  var bgColor = node.pstyle( 'background-color' ).value;
  var borderColor = node.pstyle( 'border-color' ).value;
  var borderStyle = node.pstyle( 'border-style' ).value;

  this.fillStyle( context, bgColor[0], bgColor[1], bgColor[2], node.pstyle( 'background-opacity' ).value * parentOpacity );

  this.strokeStyle( context, borderColor[0], borderColor[1], borderColor[2], node.pstyle( 'border-opacity' ).value * parentOpacity );

  context.lineJoin = 'miter'; // so borders are square with the node shape

  if( context.setLineDash ){ // for very outofdate browsers
    switch( borderStyle ){
      case 'dotted':
        context.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        context.setLineDash( [ 4, 2 ] );
        break;

      case 'solid':
      case 'double':
        context.setLineDash( [ ] );
        break;
    }
  }


  //
  // draw shape

  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if( usePaths ){
    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + ( styleShape === 'polygon' ? '$' + shapePts.join('$') : '' );

    context.translate( pos.x, pos.y );

    if( rs.pathCacheKey === pathCacheKey ){
      path = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( !pathCacheHit ){

    var npos = pos;

    if( usePaths ){
      npos = {
        x: 0,
        y: 0
      };
    }

    r.nodeShapes[ this.getNodeShape( node ) ].draw(
          ( path || context ),
          npos.x,
          npos.y,
          nodeWidth,
          nodeHeight );
  }

  if( usePaths ){
    context.fill( path );
  } else {
    context.fill();
  }

  //
  // bg image

  var prevBging = _p.backgrounding;
  var totalCompleted = 0;

  for( var i = 0; i < numImages; i++ ){
    if( ( urlDefined[i] ) && image[i].complete ){
      totalCompleted++;
      this.drawInscribedImage( context, image[i], node, i );
    }
  }

  _p.backgrounding = !(totalCompleted === numImages);
  if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
    node.updateStyle( false );
  }

  //
  // pie

  var darkness = node.pstyle( 'background-blacken' ).value;
  var borderWidth = node.pstyle( 'border-width' ).pfValue;

  if( this.hasPie( node ) ){
    this.drawPie( context, node, parentOpacity );

    // redraw path for blacken and border
    if( darkness !== 0 || borderWidth !== 0 ){

      if( !usePaths ){
        r.nodeShapes[ this.getNodeShape( node ) ].draw(
            context,
            pos.x,
            pos.y,
            nodeWidth,
            nodeHeight );
      }
    }
  }

  //
  // darken/lighten

  if( darkness > 0 ){
    this.fillStyle( context, 0, 0, 0, darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }

  } else if( darkness < 0 ){
    this.fillStyle( context, 255, 255, 255, -darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  //
  // border

  if( borderWidth > 0 ){

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }

    if( borderStyle === 'double' ){
      context.lineWidth = node.pstyle( 'border-width' ).pfValue / 3;

      var gco = context.globalCompositeOperation;
      context.globalCompositeOperation = 'destination-out';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }

      context.globalCompositeOperation = gco;
    }

  }

  if( usePaths ){
    context.translate( -pos.x, -pos.y );
  }

  // reset in case we changed the border style
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

  //
  // label

  r.drawElementText( context, node, drawLabel );

  //
  // overlay

  var overlayPadding = node.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = node.pstyle( 'overlay-opacity' ).value;
  var overlayColor = node.pstyle( 'overlay-color' ).value;

  if( overlayOpacity > 0 ){
    this.fillStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );

    r.nodeShapes[ 'roundrectangle' ].draw(
      context,
      node._private.position.x,
      node._private.position.y,
      nodeWidth + overlayPadding * 2,
      nodeHeight + overlayPadding * 2
    );

    context.fill();
  }

  //
  // clean up shift

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }

};

// does the node have at least one pie piece?
CRp.hasPie = function( node ){
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function( context, node, nodeOpacity, pos ){
  node = node[0]; // ensure ele ref

  var _p = node._private;
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle( 'pie-size' );
  var nodeW = node.width();
  var nodeH = node.height();
  var pos = pos || _p.position;
  var x = pos.x;
  var y = pos.y;
  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if( usePaths ){
    x = 0;
    y = 0;
  }

  if( pieSize.units === '%' ){
    radius = radius * pieSize.pfValue;
  } else if( pieSize.pfValue !== undefined ){
    radius = pieSize.pfValue / 2;
  }

  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
    var size = node.pstyle( 'pie-' + i + '-background-size' ).value;
    var color = node.pstyle( 'pie-' + i + '-background-color' ).value;
    var opacity = node.pstyle( 'pie-' + i + '-background-opacity' ).value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if( percent + lastPercent > 1 ){
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
      continue;
    }

    context.beginPath();
    context.moveTo( x, y );
    context.arc( x, y, radius, angleStart, angleEnd );
    context.closePath();

    this.fillStyle( context, color[0], color[1], color[2], opacity );

    context.fill();

    lastPercent += percent;
  }

};


module.exports = CRp;

},{"../../../is":82,"../../../util":99}],70:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var util = _dereq_( '../../../util' );

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function(){
  var context = this.data.contexts[0];

  if( this.forcedPixelRatio != null ){
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp.paintCache = function( context ){
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for( var i = 0; i < caches.length; i++ ){
    cache = caches[ i ];

    if( cache.context === context ){
      needToCreateCache = false;
      break;
    }
  }

  if( needToCreateCache ){
    cache = {
      context: context
    };
    caches.push( cache );
  }

  return cache;
};

CRp.fillStyle = function( context, r, g, b, a ){
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function( context, r, g, b, a ){
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

// Resize canvas
CRp.matchCanvasSize = function( container ){
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if(
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ] ||
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ]
  ){
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for( var i = 0; i < r.CANVAS_LAYERS; i++ ){
    canvas = data.canvases[ i ];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for( var i = 0; i < r.BUFFER_COUNT; i++ ){
    canvas = data.bufferCanvases[ i ];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;
  if( pixelRatio <= 1 ){
    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;

};

CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
  this.render( {
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  } );
};

CRp.render = function( options ){
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy; var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if( !forcedContext ){
    if( r.prevPxRatio !== pixelRatio ){
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize( r.container );

      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if( !forcedContext && r.motionBlurTimeout ){
    clearTimeout( r.motionBlurTimeout );
  }

  if( motionBlur ){
    if( r.mbFrames == null ){
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if( r.mbFrames > r.minMbLowQualFrames ){
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if( r.clearingMotionBlur ){
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if( r.textureDrawLastFrame && !textureDraw ){
    needDraw[ r.NODE ] = true;
    needDraw[ r.SELECT_BOX ] = true;
  }

  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
    r.motionBlurPxRatio = 1;
  }

  if( forcedPan ){
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = r.getCachedZSortedEles();

  function mbclear( context, x, y, w, h ){
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
    context.fillRect( x, y, w, h );

    context.globalCompositeOperation = gco;
  }

  function setContextTransform( context, clear ){
    var ePan, eZoom, w, h;

    if( !r.clearingMotionBlur && (context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] || context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ]) ){
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( clear === 'motionBlur' ){
      mbclear( context, 0, 0, w, h );
    } else if( !forcedContext && (clear === undefined || clear) ){
      context.clearRect( 0, 0, w, h );
    }

    if( !drawAllLayers ){
      context.translate( ePan.x, ePan.y );
      context.scale( eZoom, eZoom );
    }
    if( forcedPan ){
      context.translate( forcedPan.x, forcedPan.y );
    }
    if( forcedZoom ){
      context.scale( forcedZoom, forcedZoom );
    }
  }

  if( !textureDraw ){
    r.textureDrawLastFrame = false;
  }

  if( textureDraw ){
    r.textureDrawLastFrame = true;

    var bb;

    if( !r.textureCache ){
      r.textureCache = {};

      bb = r.textureCache.bb = cy.mutableElements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];

      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];

      cxt.setTransform( 1, 0, 0, 1, 0, 0 );
      cxt.clearRect( 0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult );

      r.render( {
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      } );

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[ r.DRAG ] = false;
    needDraw[ r.NODE ] = false;

    var context = data.contexts[ r.NODE ];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( motionBlur ){
      mbclear( context, 0, 0, vp.width, vp.height );
    } else {
      context.clearRect( 0, 0, vp.width, vp.height );
    }

    var outsideBgColor = coreStyle[ 'outside-texture-bg-color' ].value;
    var outsideBgOpacity = coreStyle[ 'outside-texture-bg-opacity' ].value;
    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
    context.fillRect( 0, 0, vp.width, vp.height );

    var zoom = cy.zoom();

    setContextTransform( context, false );

    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );
    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );

  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
  var hideEdges = r.hideEdgesOnViewport && vpManip;

  var needMbClear = [];

  needMbClear[ r.NODE ] = !needDraw[ r.NODE ] && motionBlur && !r.clearedForMotionBlur[ r.NODE ] || r.clearingMotionBlur;
  if( needMbClear[ r.NODE ] ){ r.clearedForMotionBlur[ r.NODE ] = true; }

  needMbClear[ r.DRAG ] = !needDraw[ r.DRAG ] && motionBlur && !r.clearedForMotionBlur[ r.DRAG ] || r.clearingMotionBlur;
  if( needMbClear[ r.DRAG ] ){ r.clearedForMotionBlur[ r.DRAG ] = true; }

  if( needDraw[ r.NODE ] || drawAllLayers || drawOnlyNodeLayer || needMbClear[ r.NODE ] ){
    var useBuffer = motionBlur && !needMbClear[ r.NODE ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[ r.NODE ] );
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform( context, clear );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.nondrag, pixelRatio, extent );
    } else {
      r.drawLayeredElements( context, eles.nondrag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.nondrag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.NODE ] = false;
    }
  }

  if( !drawOnlyNodeLayer && (needDraw[ r.DRAG ] || drawAllLayers || needMbClear[ r.DRAG ]) ){
    var useBuffer = motionBlur && !needMbClear[ r.DRAG ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[ r.DRAG ] );

    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.drag, pixelRatio, extent );
    } else {
      r.drawCachedElements( context, eles.drag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.drag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.DRAG ] = false;
    }
  }

  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[ r.SELECT_BOX ] && !drawAllLayers)) ){
    var context = forcedContext || data.contexts[ r.SELECT_BOX ];

    setContextTransform( context );

    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle[ 'selection-box-border-width' ].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba('
        + coreStyle[ 'selection-box-color' ].value[0] + ','
        + coreStyle[ 'selection-box-color' ].value[1] + ','
        + coreStyle[ 'selection-box-color' ].value[2] + ','
        + coreStyle[ 'selection-box-opacity' ].value + ')';

      context.fillRect(
        r.selection[0],
        r.selection[1],
        r.selection[2] - r.selection[0],
        r.selection[3] - r.selection[1] );

      if( borderWidth > 0 ){
        context.strokeStyle = 'rgba('
          + coreStyle[ 'selection-box-border-color' ].value[0] + ','
          + coreStyle[ 'selection-box-border-color' ].value[1] + ','
          + coreStyle[ 'selection-box-border-color' ].value[2] + ','
          + coreStyle[ 'selection-box-opacity' ].value + ')';

        context.strokeRect(
          r.selection[0],
          r.selection[1],
          r.selection[2] - r.selection[0],
          r.selection[3] - r.selection[1] );
      }
    }

    if( data.bgActivePosistion && !r.hoverData.selecting ){
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = 'rgba('
        + coreStyle[ 'active-bg-color' ].value[0] + ','
        + coreStyle[ 'active-bg-color' ].value[1] + ','
        + coreStyle[ 'active-bg-color' ].value[2] + ','
        + coreStyle[ 'active-bg-opacity' ].value + ')';

      context.beginPath();
      context.arc( pos.x, pos.y, coreStyle[ 'active-bg-size' ].pfValue / zoom, 0, 2 * Math.PI );
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if( r.showFps && timeToRender ){
      timeToRender = Math.round( timeToRender );
      var fps = Math.round( 1000 / timeToRender );

      context.setTransform( 1, 0, 0, 1, 0, 0 );

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20 );

      var maxFps = 60;
      context.strokeRect( 0, 30, 250, 20 );
      context.fillRect( 0, 30, 250 * Math.min( fps / maxFps, 1 ), 20 );
    }

    if( !drawAllLayers ){
      needDraw[ r.SELECT_BOX ] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if( motionBlur && mbPxRatio !== 1 ){
    var cxtNode = data.contexts[ r.NODE ];
    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];

    var cxtDrag = data.contexts[ r.DRAG ];
    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];

    var drawMotionBlur = function( cxt, txt, needClear ){
      cxt.setTransform( 1, 0, 0, 1, 0, 0 );

      if( needClear || !motionBlurFadeEffect ){
        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
      } else {
        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
      }

      var pxr = mbPxRatio;

      cxt.drawImage(
        txt, // img
        0, 0, // sx, sy
        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
        0, 0, // x, y
        r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if( needDraw[ r.NODE ] || needMbClear[ r.NODE ] ){
      drawMotionBlur( cxtNode, txtNode, needMbClear[ r.NODE ] );
      needDraw[ r.NODE ] = false;
    }

    if( needDraw[ r.DRAG ] || needMbClear[ r.DRAG ] ){
      drawMotionBlur( cxtDrag, txtDrag, needMbClear[ r.DRAG ] );
      needDraw[ r.DRAG ] = false;
    }
  }

  r.prevViewport = vp;

  if( r.clearingMotionBlur ){
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if( motionBlur ){
    r.motionBlurTimeout = setTimeout( function(){
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[ r.NODE ] = false;
      r.clearedForMotionBlur[ r.DRAG ] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[ r.NODE ] = true;
      needDraw[ r.DRAG ] = true;

      r.redraw();
    }, motionBlurDelay );
  }

  if( !forcedContext ){
    cy.trigger('render');
  }

};

module.exports = CRp;

},{"../../../util":99}],71:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_( '../../../math' );

var CRp = {};

// @O Polygon drawing
CRp.drawPolygonPath = function(
  context, x, y, width, height, points ){

  var halfW = width / 2;
  var halfH = height / 2;

  if( context.beginPath ){ context.beginPath(); }

  context.moveTo( x + halfW * points[0], y + halfH * points[1] );

  for( var i = 1; i < points.length / 2; i++ ){
    context.lineTo( x + halfW * points[ i * 2], y + halfH * points[ i * 2 + 1] );
  }

  context.closePath();
};

// Round rectangle drawing
CRp.drawRoundRectanglePath = function(
  context, x, y, width, height ){

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius( width, height );

  if( context.beginPath ){ context.beginPath(); }

  // Start at top middle
  context.moveTo( x, y - halfHeight );
  // Arc from middle top to right side
  context.arcTo( x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius );
  // Arc from right side to bottom
  context.arcTo( x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius );
  // Arc from bottom to left side
  context.arcTo( x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius );
  // Arc from left side to topBorder
  context.arcTo( x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius );
  // Join line
  context.lineTo( x, y - halfHeight );


  context.closePath();
};

CRp.drawCutRectanglePath = function(
  context, x, y, width, height ){

    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerLength = math.getCutRectangleCornerLength();

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x - halfWidth + cornerLength, y - halfHeight );

    context.lineTo( x + halfWidth - cornerLength, y - halfHeight );
    context.lineTo( x + halfWidth, y - halfHeight + cornerLength );
    context.lineTo( x + halfWidth, y + halfHeight - cornerLength );
    context.lineTo( x + halfWidth - cornerLength, y + halfHeight );
    context.lineTo( x - halfWidth + cornerLength,  y + halfHeight );
    context.lineTo( x - halfWidth, y + halfHeight - cornerLength );
    context.lineTo( x - halfWidth, y - halfHeight + cornerLength );

    context.closePath();
};

CRp.drawBarrelPath = function(
  context, x, y, width, height ){

    var halfWidth = width / 2;
    var halfHeight = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    var xBegin = x - halfWidth;
    var xEnd = x + halfWidth;
    var yBegin = y - halfHeight;
    var yEnd = y + halfHeight;
    context.moveTo(xBegin, yBegin + .05 * height);

    context.lineTo(xBegin, yBegin + .95 * height);
    context.quadraticCurveTo(xBegin, yEnd, xBegin + 0.25 * width, yEnd);

    context.lineTo(xBegin + 0.75 * width, yEnd);
    context.quadraticCurveTo(xEnd, yEnd, xEnd, yBegin + 0.95 * height)

    context.lineTo(xEnd, yBegin + 0.05 * height);
    context.quadraticCurveTo(xEnd, yBegin, xBegin + 0.75 * width, yBegin);

    context.lineTo(xBegin + .25 * width, yBegin);
    context.quadraticCurveTo(xBegin, yBegin, xBegin, yBegin + 0.05 * height);



    context.closePath();
};


var sin0 = Math.sin( 0 );
var cos0 = Math.cos( 0 );

var sin = {};
var cos = {};

var ellipseStepSize = Math.PI / 40;

for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
  sin[ i ] = Math.sin( i );
  cos[ i ] = Math.cos( i );
}

CRp.drawEllipsePath = function( context, centerX, centerY, width, height ){
    if( context.beginPath ){ context.beginPath(); }

    if( context.ellipse ){
      context.ellipse( centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI );
    } else {
      var xPos, yPos;
      var rw = width / 2;
      var rh = height / 2;
      for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
        xPos = centerX - (rw * sin[ i ]) * sin0 + (rw * cos[ i ]) * cos0;
        yPos = centerY + (rh * cos[ i ]) * sin0 + (rh * sin[ i ]) * cos0;

        if( i === 0 ){
          context.moveTo( xPos, yPos );
        } else {
          context.lineTo( xPos, yPos );
        }
      }
    }

    context.closePath();
  };

module.exports = CRp;

},{"../../../math":84}],72:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_( '../../../math' );
var util = _dereq_( '../../../util' );
var Heap = _dereq_( '../../../heap' );
var defs = _dereq_( './texture-cache-defs' );

var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024;  // the maximum height of a texture
var minUtility = 0.5; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};

var ElementTextureCache = function( renderer ){
  var self = this;

  self.renderer = renderer;
  self.onDequeues = [];

  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;

ETCp.reasons = getTxrReasons;

// the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function( txrH ){
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};

  return ( self.eleImgCaches[ txrH ] = self.eleImgCaches[ txrH ] || [] );
};

// the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function( txrH ){
  var self = this;

  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[ txrH ] = rtxtrQs[ txrH ] || [];

  return rtxtrQ;
};

// queue of element draw requests at different scale levels
ETCp.getElementQueue = function(){
  var self = this;

  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function( a, b ){
    return b.reqs - a.reqs;
  });

  return q;
};

// queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementIdToQueue = function(){
  var self = this;

  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

  return id2q;
};

ETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){
  var self = this;
  var r = this.renderer;
  var rs = ele._private.rscratch;
  var zoom = r.cy.zoom();

  if( bb.w === 0 || bb.h === 0 ){ return null; }

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );
  }

  if( lvl < minLvl ){
    lvl = minLvl;
  } else if( zoom >= maxZoom || lvl > maxLvl ){
    return null;
  }

  var scale = Math.pow( 2, lvl );
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var caches = rs.imgCaches = rs.imgCaches || {};
  var eleCache = caches[lvl];

  if( eleCache ){
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if( eleScaledH <= minTxrH ){
    txrH = minTxrH;
  } else if( eleScaledH <= txrStepH ){
    txrH = txrStepH;
  } else {
    txrH = Math.ceil( eleScaledH / txrStepH ) * txrStepH;
  }

  if(
    eleScaledH > maxTxrH
    || eleScaledW > maxTxrW
    || ( !allowEdgeTxrCaching && ele.isEdge() )
    || ( !allowParentTxrCaching && ele.isParent() )
  ){
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue( txrH );

  // first try the second last one in case it has space at the end
  var txr = txrQ[ txrQ.length - 2 ];

  var addNewTxr = function(){
    return self.recycleTexture( txrH, eleScaledW ) || self.addTexture( txrH, eleScaledW );
  };

  // try the last one if there is no second last one
  if( !txr ){
    txr = txrQ[ txrQ.length - 1 ];
  }

  // if the last one doesn't exist, we need a first one
  if( !txr ){
    txr = addNewTxr();
  }

  // if there's no room in the current texture, we need a new one
  if( txr.width - txr.usedWidth < eleScaledW ){
    txr = addNewTxr();
  }

  var scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );
  var scalableFrom = function( otherCache ){
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;

  var higherCache; // the nearest cache with a higher level
  for( var l = lvl + 1; l <= maxLvl; l++ ){
    var c = caches[l];

    if( c ){ higherCache = c; break; }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function(){
    txr.context.drawImage(
      oneUpCache.texture.canvas,
      oneUpCache.x, 0,
      oneUpCache.width, oneUpCache.height,
      txr.usedWidth, 0,
      eleScaledW, eleScaledH
    );
  };

  if( scalableFrom(oneUpCache) ){
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();

  } else if( scalableFrom(higherCache) ){
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level

    if( highQualityReq ){
      for( var l = higherCache.level; l > lvl; l-- ){
        oneUpCache = self.getElement( ele, bb, pxRatio, l, getTxrReasons.downscale );
      }

      downscale();

    } else {
      self.queueElement( ele, bb, higherCache.level - 1 );

      return higherCache;
    }
  } else {

    var lowerCache; // the nearest cache with a lower level
    if( !deqing && !highQualityReq && !downscaleReq ){
      for( var l = lvl - 1; l >= minLvl; l-- ){
        var c = caches[l];

        if( c ){ lowerCache = c; break; }
      }
    }

    if( scalableFrom(lowerCache) ){
      // then use the lower quality cache for now and queue the better one for later

      self.queueElement( ele, bb, lvl );

      return lowerCache;
    }

    txr.context.translate( txr.usedWidth, 0 );
    txr.context.scale( scale, scale );

    r.drawElement( txr.context, ele, bb, scaledLabelShown );

    txr.context.scale( 1/scale, 1/scale );
    txr.context.translate( -txr.usedWidth, 0 );
  }

  eleCache = caches[lvl] = {
    ele: ele,
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };

  txr.usedWidth += Math.ceil( eleScaledW + eleTxrSpacing );

  txr.eleCaches.push( eleCache );

  self.checkTextureFullness( txr );

  return eleCache;
};

ETCp.invalidateElement = function( ele ){
  var self = this;
  var caches = ele._private.rscratch.imgCaches;

  if( caches ){
    for( var lvl = minLvl; lvl <= maxLvl; lvl++ ){
      var cache = caches[ lvl ];

      if( cache ){
        var txr = cache.texture;

        // remove space from the texture it belongs to
        txr.invalidatedWidth += cache.width;

        // remove refs with the element
        caches[ lvl ] = null;
        util.removeFromArray( txr.eleCaches, cache );

        // might have to remove the entire texture if it's not efficiently using its space
        self.checkTextureUtility( txr );
      }
    }
  }
};

ETCp.checkTextureUtility = function( txr ){
  // invalidate all entries in the cache if the cache size is small
  if( txr.invalidatedWidth >= minUtility * txr.width ){
    this.retireTexture( txr );
  }
};

ETCp.checkTextureFullness = function( txr ){
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things

  var self = this;
  var txrQ = self.getTextureQueue( txr.height );

  if( txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks ){
    util.removeFromArray( txrQ, txr );
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function( txr ){
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue( txrH );

  // retire the texture from the active / searchable queue:

  util.removeFromArray( txrQ, txr );

  txr.retired = true;

  // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for( var i = 0; i < eleCaches.length; i++ ){
    var eleCache = eleCaches[i];
    var ele = eleCache.ele;
    var lvl = eleCache.level;
    var imgCaches = ele._private.rscratch.imgCaches;

    if( imgCaches ){
      imgCaches[ lvl ] = null;
    }
  }

  util.clearArray( eleCaches );

  // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  rtxtrQ.push( txr );
};

ETCp.addTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var txr = {};

  txrQ.push( txr );

  txr.eleCaches = [];

  txr.height = txrH;
  txr.width = Math.max( defTxrWidth, minW );
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;

  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  txr.canvas.width = txr.width;
  txr.canvas.height = txr.height;

  txr.context = txr.canvas.getContext('2d');

  return txr;
};

ETCp.recycleTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  for( var i = 0; i < rtxtrQ.length; i++ ){
    var txr = rtxtrQ[i];

    if( txr.width >= minW ){
      txr.retired = false;

      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;

      util.clearArray( txr.eleCaches );

      txr.context.clearRect( 0, 0, txr.width, txr.height );

      util.removeFromArray( rtxtrQ, txr );
      txrQ.push( txr );

      return txr;
    }
  }
};

ETCp.queueElement = function( ele, bb, lvl ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var id = ele.id();
  var existingReq = id2q[ id ];

  if( existingReq ){ // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max( existingReq.level, lvl );
    existingReq.reqs++;

    q.updateItem( existingReq );
  } else {
    var req = {
      ele: ele,
      bb: bb,
      position: math.copyPosition( ele.position() ),
      level: lvl,
      reqs: 1
    };

    if( ele.isEdge() ){
      req.positions = {
        source: math.copyPosition( ele.source().position() ),
        target: math.copyPosition( ele.target().position() )
      };
    }

    q.push( req );

    id2q[ id ] = req;
  }
};

ETCp.dequeue = function( pxRatio, extent ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var dequeued = [];

  for( var i = 0; i < maxDeqSize; i++ ){
    if( q.size() > 0 ){
      var req = q.pop();

      id2q[ req.ele.id() ] = null;

      dequeued.push( req );

      var ele = req.ele;
      var bb;

      if(
        ( ele.isEdge()
          && (
            !math.arePositionsSame( ele.source().position(), req.positions.source )
            || !math.arePositionsSame( ele.target().position(), req.positions.target )
          )
        )
        || ( !math.arePositionsSame( ele.position(), req.position ) )
      ){
        bb = ele.boundingBox();
      } else {
        bb = req.bb;
      }

      self.getElement( req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue );
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.onDequeue = function( fn ){ this.onDequeues.push( fn ); };
ETCp.offDequeue = function( fn ){ util.removeFromArray( this.onDequeues, fn ); };

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio, extent ){
    return self.dequeue( pxRatio, extent );
  },
  onDeqd: function( self, deqd ){
    for( var i = 0; i < self.onDequeues.length; i++ ){
      var fn = self.onDequeues[i];

      fn( deqd );
    }
  },
  shouldRedraw: function( self, deqd, pxRatio, extent ){
    for( var i = 0; i < deqd.length; i++ ){
      var bb = deqd[i].bb;

      if( math.boundingBoxesIntersect( bb, extent ) ){
        return true;
      }
    }

    return false;
  },
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

module.exports = ElementTextureCache;

},{"../../../heap":80,"../../../math":84,"../../../util":99,"./texture-cache-defs":77}],73:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../../../is' );

var CRp = {};

CRp.createBuffer = function( w, h ){
  var buffer = document.createElement( 'canvas' ); // eslint-disable-line no-undef
  buffer.width = w;
  buffer.height = h;

  return [ buffer, buffer.getContext( '2d' ) ];
};

CRp.bufferCanvasImage = function( options ){
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil( bb.w ) : ctrRect[2];
  var height = options.full ? Math.ceil( bb.h ) : ctrRect[3];
  var specdMaxDims = is.number( options.maxWidth ) || is.number( options.maxHeight );
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if( options.scale !== undefined ){
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if( specdMaxDims ){
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if( is.number( options.maxWidth ) ){
      maxScaleW = scale * options.maxWidth / width;
    }

    if( is.number( options.maxHeight ) ){
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min( maxScaleW, maxScaleH );

    width *= scale;
    height *= scale;
  }

  if( !specdMaxDims ){
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement( 'canvas' ); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext( '2d' );

  // Rasterize the layers, but only if container has nonzero size
  if( width > 0 && height > 0 ){

    buffCxt.clearRect( 0, 0, width, height );

    if( options.bg ){
      buffCxt.fillStyle = options.bg;
      buffCxt.rect( 0, 0, width, height );
      buffCxt.fill();
    }

    buffCxt.globalCompositeOperation = 'source-over';

    var zsortedEles = this.getCachedZSortedEles();

    if( options.full ){ // draw the full bounds of the graph
      buffCxt.translate( -bb.x1 * scale, -bb.y1 * scale );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    } else { // draw the current view
      var pan = cy.pan();

      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };

      scale *= cy.zoom();

      buffCxt.translate( translation.x, translation.y );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    }
  }

  return buffCanvas;
};

function b64ToBlob( b64, mimeType ){
  var bytes = atob( b64 );
  var buff = new ArrayBuffer( bytes.length );
  var buffUint8 = new Uint8Array( buff );

  for( var i = 0; i < bytes.length; i++ ){
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob( [buff], { type: mimeType } );
}

function b64UriToB64( b64uri ){
  var i = b64uri.indexOf(',');

  return b64uri.substr( i + 1 );
};

function output( options, canvas, mimeType ){
  var b64Uri = canvas.toDataURL( mimeType, options.quality );

  switch( options.output ){
    case 'blob':
      return b64ToBlob( b64UriToB64( b64Uri ), mimeType );

    case 'base64':
      return b64UriToB64( b64Uri );

    case 'base64uri':
    default:
      return b64Uri;
  }
}

CRp.png = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/png' );
};

CRp.jpg = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/jpeg' );
};

module.exports = CRp;

},{"../../../is":82}],74:[function(_dereq_,module,exports){
/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

'use strict';

var util = _dereq_( '../../../util' );
var is = _dereq_( '../../../is' );
var ElementTextureCache = _dereq_('./ele-texture-cache');
var LayeredTextureCache = _dereq_('./layered-texture-cache');

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer( options ){
  var r = this;

  r.data = {
    canvases: new Array( CRp.CANVAS_LAYERS ),
    contexts: new Array( CRp.CANVAS_LAYERS ),
    canvasNeedsRedraw: new Array( CRp.CANVAS_LAYERS ),

    bufferCanvases: new Array( CRp.BUFFER_COUNT ),
    bufferContexts: new Array( CRp.CANVAS_LAYERS ),
  };

  r.data.canvasContainer = document.createElement( 'div' ); // eslint-disable-line no-undef
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute( 'style', '-webkit-tap-highlight-color: rgba(0,0,0,0);' );
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild( r.data.canvasContainer );
  container.setAttribute( 'style', ( container.getAttribute( 'style' ) || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);' );

  for( var i = 0; i < CRp.CANVAS_LAYERS; i++ ){
    var canvas = r.data.canvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.contexts[ i ] = canvas.getContext( '2d' );
    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
    canvas.style.position = 'absolute';
    canvas.setAttribute( 'data-id', 'layer' + i );
    canvas.style.zIndex = String( CRp.CANVAS_LAYERS - i );
    r.data.canvasContainer.appendChild( canvas );

    r.data.canvasNeedsRedraw[ i ] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[ CRp.NODE ].setAttribute( 'data-id', 'layer' + CRp.NODE + '-node' );
  r.data.canvases[ CRp.SELECT_BOX ].setAttribute( 'data-id', 'layer' + CRp.SELECT_BOX + '-selectbox' );
  r.data.canvases[ CRp.DRAG ].setAttribute( 'data-id', 'layer' + CRp.DRAG + '-drag' );

  for( var i = 0; i < CRp.BUFFER_COUNT; i++ ){
    r.data.bufferCanvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.bufferContexts[ i ] = r.data.bufferCanvases[ i ].getContext( '2d' );
    r.data.bufferCanvases[ i ].style.position = 'absolute';
    r.data.bufferCanvases[ i ].setAttribute( 'data-id', 'buffer' + i );
    r.data.bufferCanvases[ i ].style.zIndex = String( -i - 1 );
    r.data.bufferCanvases[ i ].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;

  r.data.eleTxrCache = new ElementTextureCache( r );
  r.data.lyrTxrCache = new LayeredTextureCache( r, r.data.eleTxrCache );

  r.onUpdateEleCalcs(function invalidateTextureCaches( willDraw, eles ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var rs = ele._private.rstyle;
      var de = rs.dirtyEvents;

      if( ele.isNode() && de && de.length === 1 && de['position'] ){
        // then keep cached ele texture
      } else {
        r.data.eleTxrCache.invalidateElement( ele );
      }
    }

    if( eles.length > 0 ){
      r.data.lyrTxrCache.invalidateElements( eles );
    }
  });
}

CRp.redrawHint = function( group, bool ){
  var r = this;

  switch( group ){
    case 'eles':
      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function( on ){
  if( on === undefined ){
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function(){
  return pathsImpld && this.pathsEnabled;
};

[
  _dereq_( './arrow-shapes' ),
  _dereq_( './drawing-elements' ),
  _dereq_( './drawing-edges' ),
  _dereq_( './drawing-images' ),
  _dereq_( './drawing-label-text' ),
  _dereq_( './drawing-nodes' ),
  _dereq_( './drawing-redraw' ),
  _dereq_( './drawing-shapes' ),
  _dereq_( './export-image' ),
  _dereq_( './node-shapes' )
].forEach( function( props ){
  util.extend( CRp, props );
} );

module.exports = CR;

},{"../../../is":82,"../../../util":99,"./arrow-shapes":64,"./drawing-edges":65,"./drawing-elements":66,"./drawing-images":67,"./drawing-label-text":68,"./drawing-nodes":69,"./drawing-redraw":70,"./drawing-shapes":71,"./ele-texture-cache":72,"./export-image":73,"./layered-texture-cache":75,"./node-shapes":76}],75:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../../util' );
var math = _dereq_( '../../../math' );
var Heap = _dereq_( '../../../heap' );
var is = _dereq_( '../../../is' );
var defs = _dereq_( './texture-cache-defs' );

var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function( renderer, eleTxrCache ){
  var self = this;

  var r = self.renderer = renderer;

  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;

  self.lastInvalidationTime = util.performanceNow() - 2*invalidThreshold;

  self.skipping = false;

  r.beforeRender(function( willDraw, now ){
    if( now - self.lastInvalidationTime <= invalidThreshold ){
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  });

  var qSort = function(a, b){
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap( qSort );

  self.eleTxrCache = eleTxrCache;

  self.setupEleCacheInvalidation();

  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;

var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;

LTCp.makeLayer = function( bb, lvl ){
  var scale = Math.pow( 2, lvl );

  var w = Math.ceil( bb.w * scale );
  var h = Math.ceil( bb.h * scale );

  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

  canvas.width = w;
  canvas.height = h;

  var layer = {
    id: (layerIdPool = ++layerIdPool % MAX_INT ),
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  };

  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;

  // do the transform on creation to save cycles (it's the same for all eles)
  cxt.scale( scale, scale );
  cxt.translate( dx, dy );

  return layer;
};

LTCp.getLayers = function( eles, pxRatio, lvl ){
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;

  self.firstGet = false;

  // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );

    if( lvl < minLvl ){
      lvl = minLvl;
    } else if( zoom >= maxZoom || lvl > maxLvl ){
      return null;
    }
  }

  self.validateLayersElesOrdering( lvl, eles );

  var layersByLvl = self.layersByLevel;
  var scale = Math.pow( 2, lvl );
  var layers = layersByLvl[ lvl ] = layersByLvl[ lvl ] || [];
  var bb;

  var lvlComplete = self.levelIsComplete( lvl, eles );
  var tmpLayers;

  var checkTempLevels = function(){
    var canUseAsTmpLvl = function( l ){
      self.validateLayersElesOrdering( l, eles );

      if( self.levelIsComplete( l, eles ) ){
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function( dir ){
      if( tmpLayers ){ return; }

      for( var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir ){
        if( canUseAsTmpLvl(l) ){ break; }
      }
    };

    checkLvls( +1 );
    checkLvls( -1 );

    // remove the invalid layers; they will be replaced as needed later in this function
    for( var i = layers.length - 1; i >= 0; i-- ){
      var layer = layers[i];

      if( layer.invalid ){
        util.removeFromArray( layers, layer );
      }
    }
  };

  if( !lvlComplete ){
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon

    checkTempLevels();

  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function(){
    if( !bb ){
      bb = math.makeBoundingBox();

      for( var i = 0; i < eles.length; i++ ){
        math.updateBoundingBox( bb, eles[i].boundingBox() );
      }
    }

    return bb;
  };

  var makeLayer = function( opts ){
    opts = opts || {};

    var after = opts.after;

    getBb();

    var area = ( bb.w * scale ) * ( bb.h * scale );

    if( area > maxLayerArea ){
      return null;
    }

    var layer = self.makeLayer( bb, lvl );

    if( after != null ){
      var index = layers.indexOf( after ) + 1;

      layers.splice( index, 0, layer );
    } else if( opts.insert === undefined || opts.insert ){
      // no after specified => first layer made so put at start
      layers.unshift( layer );
    }

    // if( tmpLayers ){
      //self.queueLayer( layer );
    // }

    return layer;
  };

  if( self.skipping && !firstGet ){
    // log('skip layers');
    return null;
  }

  // log('do layers');

  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = alwaysQueue && !firstGet;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    // log('look at ele', ele.id());

    var existingLayer = caches[ lvl ];

    if( existingLayer ){
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if(
      !layer
      || layer.eles.length >= maxElesPerLayer
      || !math.boundingBoxInBoundingBox( layer.bb, ele.boundingBox() )
    ){
      // log('make new layer for ele %s', ele.id());

      layer = makeLayer({ insert: true, after: layer });

      // if now layer can be built then we can't use layers at this level
      if( !layer ){ return null; }

      // log('new layer with id %s', layer.id);
    }

    if( tmpLayers || allowLazyQueueing ){
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer( layer, ele );
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer( layer, ele, lvl, pxRatio );
    }

    layer.eles.push( ele );

    caches[ lvl ] = layer;
  }

  // log('--');

  if( tmpLayers ){ // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if( allowLazyQueueing ){
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
};

// a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function( lvl, pxRatio ){
  return lvl;
};

function imgSmoothing( context, bool ){
  if( context.imageSmoothingEnabled != null ){
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
}

LTCp.drawEleInLayer = function( layer, ele, lvl, pxRatio ){
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  var eleCache = self.eleTxrCache;
  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

  lvl = self.getEleLevelForLayerLevel( lvl, pxRatio );

  var cache = useEleTxrCaching ? eleCache.getElement( ele, bb, null, lvl, reason ) : null;

  if( cache ){
    if( disableEleImgSmoothing ){ imgSmoothing( context, false ); }

    context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );

    if( disableEleImgSmoothing ){ imgSmoothing( context, true ); }
  } else { // if the element is not cacheable, then draw directly
    r.drawElement( context, ele );
  }
};

LTCp.levelIsComplete = function( lvl, eles ){
  var self = this;
  var layers = self.layersByLevel[ lvl ];

  if( !layers || layers.length === 0 ){ return false; }

  var numElesInLayers = 0;

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];

    // if there are any eles needed to be drawn yet, the level is not complete
    if( layer.reqs > 0 ){ return false; }

    // if the layer is invalid, the level is not complete
    if( layer.invalid ){ return false; }

    numElesInLayers += layer.eles.length;
  }

  // we should have exactly the number of eles passed in to be complete
  if( numElesInLayers !== eles.length ){ return false; }

  return true;
};

LTCp.validateLayersElesOrdering = function( lvl, eles ){
  var layers = this.layersByLevel[ lvl ];

  if( !layers ){ return; }

  // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];
    var offset = -1;

    // find the offset
    for( var j = 0; j < eles.length; j++ ){
      if( layer.eles[0] === eles[j] ){
        offset = j;
        break;
      }
    }

    if( offset < 0 ){
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer( layer );
      continue;
    }

    // the eles in the layer must be in the same continuous order, else the layer is invalid

    var o = offset;

    for( var j = 0; j < layer.eles.length; j++ ){
      if( layer.eles[j] !== eles[o+j] ){
        // log('invalidate based on ordering', layer.id);

        this.invalidateLayer( layer );
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function( eles, update ){
  var self = this;
  var isEles = is.element( eles[0] );

  // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way
  for( var i = 0; i < eles.length; i++ ){
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for( var l = minLvl; l <= maxLvl; l++ ){
      var layer = caches[l];

      if( !layer ){ continue; }

      // if update is a request from the ele cache, then it affects only
      // the matching level
      if( req && self.getEleLevelForLayerLevel( layer.level ) !== req.level ){
        continue;
      }

      update( layer, ele, req );
    }
  }
};

LTCp.haveLayers = function(){
  var self = this;
  var haveLayers = false;

  for( var l = minLvl; l <= maxLvl; l++ ){
    var layers = self.layersByLevel[l];

    if( layers && layers.length > 0 ){
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function( eles ){
  var self = this;

  self.lastInvalidationTime = util.performanceNow();

  // log('update invalidate layer time from eles');

  if( eles.length === 0 || !self.haveLayers() ){ return; }

  self.updateElementsInLayers( eles, function invalAssocLayers( layer, ele, req ){
    self.invalidateLayer( layer );
  } );
};

LTCp.invalidateLayer = function( layer ){
  // log('update invalidate layer time');

  this.lastInvalidationTime = util.performanceNow();

  if( layer.invalid ){ return; } // save cycles

  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[ lvl ];

   // log('invalidate layer', layer.id );

  util.removeFromArray( layers, layer );
  // layer.eles = [];

  layer.elesQueue = [];

  layer.invalid = true;

  if( layer.replacement ){
    layer.replacement.invalid = true;
  }

  for( var i = 0; i < eles.length; i++ ){
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if( caches ){
      caches[ lvl ] = null;
    }
  }
};

LTCp.refineElementTextures = function( eles ){
  var self = this;

  // log('refine', eles.length);

  self.updateElementsInLayers( eles, function refineEachEle( layer, ele, req ){
    var rLyr = layer.replacement;

    if( !rLyr ){
      rLyr = layer.replacement = self.makeLayer( layer.bb, layer.level );
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;

       // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if( !rLyr.reqs ){
      for( var i = 0; i < rLyr.eles.length; i++ ){
        self.queueLayer( rLyr, rLyr.eles[i] );
      }

       // log('queue replacement layer refinement', rLyr.id);
    }
  } );
};

LTCp.setupEleCacheInvalidation = function(){
  var self = this;
  var eleDeqs = [];

  if( !useEleTxrCaching ){ return; }

  var updatedElesInLayers = util.debounce( function(){
    self.refineElementTextures( eleDeqs );

    eleDeqs = [];
  }, refineEleDebounceTime );

  self.eleTxrCache.onDequeue(function( reqs ){
    for( var i = 0; i < reqs.length; i++ ){
      eleDeqs.push( reqs[i] );
    }

    updatedElesInLayers();
  });
};

LTCp.queueLayer = function( layer, ele ){
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};

  // if a layer is going to be replaced, queuing is a waste of time
  if( layer.replacement ){ return; }

  if( ele ){
    if( hasId[ ele.id() ] ){
      return;
    }

    elesQ.push( ele );
    hasId[ ele.id() ] = true;
  }

  if( layer.reqs ){
    layer.reqs++;

    q.updateItem( layer );
  } else {
    layer.reqs = 1;

    q.push( layer );
  }
};

LTCp.dequeue = function( pxRatio ){
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while( eleDeqs < maxDeqSize ){
    if( q.size() === 0 ){ break; }

    var layer = q.peek();

    // if a layer has been or will be replaced, then don't waste time with it
    if( layer.replacement ){
       // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    }

    // if this is a replacement layer that has been superceded, then forget it
    if( layer.replaces && layer !== layer.replaces.replacement ){
       // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if( layer.invalid ){
       // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if( ele ){
       // log('dequeue layer %s', layer.id);

      self.drawEleInLayer( layer, ele, layer.level, pxRatio );

      eleDeqs++;
    }

    if( deqd.length === 0 ){
      // we need only one entry in deqd to queue redrawing etc
      deqd.push( true );
    }

    // if the layer has all its eles done, then remove from the queue
    if( layer.elesQueue.length === 0 ){
      q.pop();

      layer.reqs = 0;

       // log('dequeue of layer %s complete', layer.id);

      // when a replacement layer is dequeued, it replaces the old layer in the level
      if( layer.replaces ){
        self.applyLayerReplacement( layer );
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function( layer ){
  var self = this;
  var layersInLevel = self.layersByLevel[ layer.level ];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf( replaced );

  // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)
  if( index < 0 || replaced.invalid ){
     // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[ index ] = layer; // replace level ref

  // replace refs in eles
  for( var i = 0; i < layer.eles.length; i++ ){
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if( cache ){
      cache[ layer.level ] = layer;
    }
  }

   // log('apply replacement layer %s over %s', layer.id, replaced.id);

  self.requestRedraw();
};

LTCp.requestRedraw = util.debounce( function(){
  var r = this.renderer;

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );
  r.redraw();
}, 100 );

LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio ){
    return self.dequeue( pxRatio );
  },
  onDeqd: util.noop,
  shouldRedraw: util.trueify,
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

module.exports = LayeredTextureCache;

},{"../../../heap":80,"../../../is":82,"../../../math":84,"../../../util":99,"./texture-cache-defs":77}],76:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.nodeShapeImpl = function( name, context, centerX, centerY, width, height, points ){
  switch( name ){
    case 'ellipse':
      return this.drawEllipsePath( context, centerX, centerY, width, height );
    case 'polygon':
      return this.drawPolygonPath( context, centerX, centerY, width, height, points );
    case 'roundrectangle':
      return this.drawRoundRectanglePath( context, centerX, centerY, width, height );
    case 'cutrectangle':
      return this.drawCutRectanglePath( context, centerX, centerY, width, height );
    case 'barrel':
      return this.drawBarrelPath( context, centerX, centerY, width, height );
  }
};

module.exports = CRp;

},{}],77:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../../../util' );

var fullFpsTime = 1000/60; // assume 60 frames per second

module.exports = {
  setupDequeueing: function( opts ){
    return function setupDequeueingImpl(){
      var self = this;
      var r = this.renderer;

      if( self.dequeueingSetup ){
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util.debounce( function(){
        r.redrawHint( 'eles', true );
        r.redrawHint( 'drag', true );

        r.redraw();
      }, opts.deqRedrawThreshold );

      var dequeue = function( willDraw, frameStartTime ){
        var startTime = util.performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio();

        while( true ){
          var now = util.performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if( renderTime < fullFpsTime ){
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time

            var timeAvailable = fullFpsTime - ( willDraw ? avgRenderTime : 0 );

            if( frameDuration >= opts.deqFastCost * timeAvailable ){
              break;
            }
          } else {
            if( willDraw ){
              if(
                   duration >= opts.deqCost * renderTime
                || duration >= opts.deqAvgCost * avgRenderTime
              ){
                break;
              }
            } else if( frameDuration >= opts.deqNoDrawCost * fullFpsTime ){
              break;
            }
          }

          var thisDeqd = opts.deq( self, pixelRatio, extent );

          if( thisDeqd.length > 0 ){
            for( var i = 0; i < thisDeqd.length; i++ ){
              deqd.push( thisDeqd[i] );
            }
          } else {
            break;
          }
        }

        // callbacks on dequeue
        if( deqd.length > 0 ){
          opts.onDeqd( self, deqd );

          if( !willDraw && opts.shouldRedraw( self, deqd, pixelRatio, extent ) ){
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || util.noop;

      r.beforeRender( dequeue, priority( self ) );
    };
  }
};

},{"../../../util":99}],78:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'null', impl: _dereq_( './null' ) },
  { name: 'base', impl: _dereq_( './base' ) },
  { name: 'canvas', impl: _dereq_( './canvas' ) }
];

},{"./base":60,"./canvas":74,"./null":79}],79:[function(_dereq_,module,exports){
'use strict';

function NullRenderer( options ){
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function(){};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function(){ this.notifications++; },
  init: noop
};

module.exports = NullRenderer;

},{}],80:[function(_dereq_,module,exports){
/*!
Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;

PSF LICENSE AGREEMENT FOR PYTHON 2.7.2

1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
*/

'use strict';
// Generated by CoffeeScript 1.8.0

var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

floor = Math.floor, min = Math.min;


/*
Default comparison function to be used
 */

defaultCmp = function( x, y ){
  if( x < y ){
    return -1;
  }
  if( x > y ){
    return 1;
  }
  return 0;
};


/*
Insert item x in list a, and keep it sorted assuming a is sorted.

If x is already in a, insert it to the right of the rightmost x.

Optional args lo (default 0) and hi (default a.length) bound the slice
of a to be searched.
 */

insort = function( a, x, lo, hi, cmp ){
  var mid;
  if( lo == null ){
    lo = 0;
  }
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( lo < 0 ){
    throw new Error( 'lo must be non-negative' );
  }
  if( hi == null ){
    hi = a.length;
  }
  while( lo < hi ){
    mid = floor( (lo + hi) / 2 );
    if( cmp( x, a[ mid ] ) < 0 ){
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return ([].splice.apply( a, [ lo, lo - lo ].concat( x ) ), x);
};


/*
Push item onto heap, maintaining the heap invariant.
 */

heappush = function( array, item, cmp ){
  if( cmp == null ){
    cmp = defaultCmp;
  }
  array.push( item );
  return _siftdown( array, 0, array.length - 1, cmp );
};


/*
Pop the smallest item off the heap, maintaining the heap invariant.
 */

heappop = function( array, cmp ){
  var lastelt, returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if( array.length ){
    returnitem = array[0];
    array[0] = lastelt;
    _siftup( array, 0, cmp );
  } else {
    returnitem = lastelt;
  }
  return returnitem;
};


/*
Pop and return the current smallest value, and add the new item.

This is more efficient than heappop() followed by heappush(), and can be
more appropriate when using a fixed size heap. Note that the value
returned may be larger than item! That constrains reasonable use of
this routine unless written as part of a conditional replacement:
    if item > array[0]
      item = heapreplace(array, item)
 */

heapreplace = function( array, item, cmp ){
  var returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup( array, 0, cmp );
  return returnitem;
};


/*
Fast version of a heappush followed by a heappop.
 */

heappushpop = function( array, item, cmp ){
  var _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( array.length && cmp( array[0], item ) < 0 ){
    _ref = [ array[0], item ], item = _ref[0], array[0] = _ref[1];
    _siftup( array, 0, cmp );
  }
  return item;
};


/*
Transform list into a heap, in-place, in O(array.length) time.
 */

heapify = function( array, cmp ){
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  _ref1 = (function(){
    _results1 = [];
    for( var _j = 0, _ref = floor( array.length / 2 ); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j-- ){ _results1.push( _j ); }
    return _results1;
  }).apply( this ).reverse();
  _results = [];
  for( _i = 0, _len = _ref1.length; _i < _len; _i++ ){
    i = _ref1[ _i ];
    _results.push( _siftup( array, i, cmp ) );
  }
  return _results;
};


/*
Update the position of the given item in the heap.
This function should be called every time the item is being modified.
 */

updateItem = function( array, item, cmp ){
  var pos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  pos = array.indexOf( item );
  if( pos === -1 ){
    return;
  }
  _siftdown( array, 0, pos, cmp );
  return _siftup( array, pos, cmp );
};


/*
Find the n largest elements in a dataset.
 */

nlargest = function( array, n, cmp ){
  var elem, result, _i, _len, _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  result = array.slice( 0, n );
  if( !result.length ){
    return result;
  }
  heapify( result, cmp );
  _ref = array.slice( n );
  for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
    elem = _ref[ _i ];
    heappushpop( result, elem, cmp );
  }
  return result.sort( cmp ).reverse();
};


/*
Find the n smallest elements in a dataset.
 */

nsmallest = function( array, n, cmp ){
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( n * 10 <= array.length ){
    result = array.slice( 0, n ).sort( cmp );
    if( !result.length ){
      return result;
    }
    los = result[ result.length - 1];
    _ref = array.slice( n );
    for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
      elem = _ref[ _i ];
      if( cmp( elem, los ) < 0 ){
        insort( result, elem, 0, null, cmp );
        result.pop();
        los = result[ result.length - 1];
      }
    }
    return result;
  }
  heapify( array, cmp );
  _results = [];
  for( i = _j = 0, _ref1 = min( n, array.length ); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j ){
    _results.push( heappop( array, cmp ) );
  }
  return _results;
};

_siftdown = function( array, startpos, pos, cmp ){
  var newitem, parent, parentpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  newitem = array[ pos ];
  while( pos > startpos ){
    parentpos = (pos - 1) >> 1;
    parent = array[ parentpos ];
    if( cmp( newitem, parent ) < 0 ){
      array[ pos ] = parent;
      pos = parentpos;
      continue;
    }
    break;
  }
  return array[ pos ] = newitem;
};

_siftup = function( array, pos, cmp ){
  var childpos, endpos, newitem, rightpos, startpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  endpos = array.length;
  startpos = pos;
  newitem = array[ pos ];
  childpos = 2 * pos + 1;
  while( childpos < endpos ){
    rightpos = childpos + 1;
    if( rightpos < endpos && !(cmp( array[ childpos ], array[ rightpos ] ) < 0) ){
      childpos = rightpos;
    }
    array[ pos ] = array[ childpos ];
    pos = childpos;
    childpos = 2 * pos + 1;
  }
  array[ pos ] = newitem;
  return _siftdown( array, startpos, pos, cmp );
};

Heap = (function(){
  Heap.push = heappush;

  Heap.pop = heappop;

  Heap.replace = heapreplace;

  Heap.pushpop = heappushpop;

  Heap.heapify = heapify;

  Heap.updateItem = updateItem;

  Heap.nlargest = nlargest;

  Heap.nsmallest = nsmallest;

  function Heap( cmp ){
    this.cmp = cmp != null ? cmp : defaultCmp;
    this.nodes = [];
  }

  Heap.prototype.push = function( x ){
    return heappush( this.nodes, x, this.cmp );
  };

  Heap.prototype.pop = function(){
    return heappop( this.nodes, this.cmp );
  };

  Heap.prototype.peek = function(){
    return this.nodes[0];
  };

  Heap.prototype.contains = function( x ){
    return this.nodes.indexOf( x ) !== -1;
  };

  Heap.prototype.replace = function( x ){
    return heapreplace( this.nodes, x, this.cmp );
  };

  Heap.prototype.pushpop = function( x ){
    return heappushpop( this.nodes, x, this.cmp );
  };

  Heap.prototype.heapify = function(){
    return heapify( this.nodes, this.cmp );
  };

  Heap.prototype.updateItem = function( x ){
    return updateItem( this.nodes, x, this.cmp );
  };

  Heap.prototype.clear = function(){
    return this.nodes = [];
  };

  Heap.prototype.empty = function(){
    return this.nodes.length === 0;
  };

  Heap.prototype.size = function(){
    return this.nodes.length;
  };

  Heap.prototype.clone = function(){
    var heap;
    heap = new Heap();
    heap.nodes = this.nodes.slice( 0 );
    return heap;
  };

  Heap.prototype.toArray = function(){
    return this.nodes.slice( 0 );
  };

  Heap.prototype.insert = Heap.prototype.push;

  Heap.prototype.top = Heap.prototype.peek;

  Heap.prototype.front = Heap.prototype.peek;

  Heap.prototype.has = Heap.prototype.contains;

  Heap.prototype.copy = Heap.prototype.clone;

  return Heap;

})();

module.exports = Heap;

},{}],81:[function(_dereq_,module,exports){
'use strict';

_dereq_('./-preamble');

var window = _dereq_( './window' );
var is = _dereq_( './is' );
var Core = _dereq_( './core' );
var extension = _dereq_( './extension' );
var Stylesheet = _dereq_( './stylesheet' );

var cytoscape = function( options ){ // jshint ignore:line
  // if no options specified, use default
  if( options === undefined ){
    options = {};
  }

  // create instance
  if( is.plainObject( options ) ){
    return new Core( options );
  }

  // allow for registration of extensions
  else if( is.string( options ) ){
    return extension.apply( extension, arguments );
  }
};

// e.g. cytoscape.use( require('cytoscape-foo'), bar )
cytoscape.use = function( ext ){
  var args = Array.prototype.slice.call( arguments, 1 ); // args to pass to ext

  args.unshift( cytoscape ); // cytoscape is first arg to ext

  ext.apply( null, args );
};

// replaced by build system
cytoscape.version = _dereq_('./version');

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

},{"./-preamble":1,"./core":37,"./extension":46,"./is":82,"./stylesheet":97,"./version":106,"./window":107}],82:[function(_dereq_,module,exports){
'use strict';

/*global HTMLElement DocumentTouch */

var window = _dereq_( './window' );
var navigator = window ? window.navigator : null;
var document = window ? window.document : null;

var typeofstr = typeof '';
var typeofobj = typeof {};
var typeoffn = typeof function(){};
var typeofhtmlele = typeof HTMLElement;

var instanceStr = function( obj ){
  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
};

var is = {
  defined: function( obj ){
    return obj != null; // not undefined or null
  },

  string: function( obj ){
    return obj != null && typeof obj == typeofstr;
  },

  fn: function( obj ){
    return obj != null && typeof obj === typeoffn;
  },

  array: function( obj ){
    return Array.isArray ? Array.isArray( obj ) : obj != null && obj instanceof Array;
  },

  plainObject: function( obj ){
    return obj != null && typeof obj === typeofobj && !is.array( obj ) && obj.constructor === Object;
  },

  object: function( obj ){
    return obj != null && typeof obj === typeofobj;
  },

  number: function( obj ){
    return obj != null && typeof obj === typeof 1 && !isNaN( obj );
  },

  integer: function( obj ){
    return is.number( obj ) && Math.floor( obj ) === obj;
  },

  bool: function( obj ){
    return obj != null && typeof obj === typeof true;
  },

  htmlElement: function( obj ){
    if( 'undefined' === typeofhtmlele ){
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function( obj ){
    return is.element( obj ) || is.collection( obj );
  },

  element: function( obj ){
    return instanceStr( obj ) === 'collection' && obj._private.single;
  },

  collection: function( obj ){
    return instanceStr( obj ) === 'collection' && !obj._private.single;
  },

  core: function( obj ){
    return instanceStr( obj ) === 'core';
  },

  style: function( obj ){
    return instanceStr( obj ) === 'style';
  },

  stylesheet: function( obj ){
    return instanceStr( obj ) === 'stylesheet';
  },

  event: function( obj ){
    return instanceStr( obj ) === 'event';
  },

  thread: function( obj ){
    return instanceStr( obj ) === 'thread';
  },

  fabric: function( obj ){
    return instanceStr( obj ) === 'fabric';
  },

  emptyString: function( obj ){
    if( obj === undefined || obj === null ){ // null is empty
      return true;
    } else if( obj === '' || obj.match( /^\s+$/ ) ){
      return true; // empty string is empty
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function( obj ){
    if( obj && is.string( obj ) && obj !== '' && !obj.match( /^\s+$/ ) ){
      return true;
    }

    return false;
  },

  domElement: function( obj ){
    if( typeof HTMLElement === 'undefined' ){
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function( obj ){
    return is.plainObject( obj ) &&
      is.number( obj.x1 ) && is.number( obj.x2 ) &&
      is.number( obj.y1 ) && is.number( obj.y2 )
    ;
  },

  promise: function( obj ){
    return is.object( obj ) && is.fn( obj.then );
  },

  touch: function(){
    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
  },

  gecko: function(){
    return window && ( typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style) );
  },

  webkit: function(){
    return window && ( typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style) );
  },

  chromium: function(){
    return window && ( typeof chrome !== 'undefined' );
  },

  khtml: function(){
    return navigator && navigator.vendor.match( /kde/i ); // probably a better way to detect this...
  },

  khtmlEtc: function(){
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function(){
    return navigator && navigator.userAgent.match( /msie|trident|edge/i ); // probably a better way to detect this...
  },

  windows: function(){
    return navigator && navigator.appVersion.match( /Win/i );
  },

  mac: function(){
    return navigator && navigator.appVersion.match( /Mac/i );
  },

  linux: function(){
    return navigator && navigator.appVersion.match( /Linux/i );
  },

  unix: function(){
    return navigator && navigator.appVersion.match( /X11/i );
  }
};

module.exports = is;

},{"./window":107}],83:[function(_dereq_,module,exports){
function ObjectMap(){
  this._obj = {};
}

var p = ObjectMap.prototype;

p.set = function( key, val ){
  this._obj[ key ] = val;
};

p.delete = function( key ){
  this._obj[ key ] = null;
};

p.has = function( key ){
  return this._obj[ key ] != null;
};

p.get = function( key ){
  return this._obj[ key ];
};

module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;

},{}],84:[function(_dereq_,module,exports){
'use strict';

var math = {};

math.arePositionsSame = function( p1, p2 ){
  return p1.x === p2.x && p1.y === p2.y;
};

math.copyPosition = function( p ){
  return { x: p.x, y: p.y };
};

math.array2point = function( arr ){
  return {
    x: arr[0],
    y: arr[1]
  };
};

math.deg2rad = function( deg ){
  return Math.PI * deg / 180;
};

math.log2 = Math.log2 || function( n ){
  return Math.log( n ) / Math.log( 2 );
};

math.signum = function( x ){
  if( x > 0 ){
    return 1;
  } else if( x < 0 ){
    return -1;
  } else {
    return 0;
  }
};

math.dist = function( p1, p2 ){
  return Math.sqrt( math.sqdist( p1, p2 ) );
};

math.sqdist = function( p1, p2 ){
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx * dx + dy * dy;
};

// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
math.qbezierAt = function( p0, p1, p2, t ){
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};

math.qbezierPtAt = function( p0, p1, p2, t ){
  return {
    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
  };
};

math.lineAt = function( p0, p1, t, d ){
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };

  var vecDist = math.dist( p0, p1 );

  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };

  t = t == null ? 0 : t;

  var d = d != null ? d : t * vecDist;

  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};

math.lineAtDist = function( p0, p1, d ){
  return math.lineAt( p0, p1, undefined, d );
};

// get angle at A via cosine law
math.triangleAngle = function( A, B, C ){
  var a = math.dist( B, C );
  var b = math.dist( A, C );
  var c = math.dist( A, B );

  return Math.acos( (a*a + b*b - c*c)/(2*a*b) );
};

math.bound = function( min, val, max ){
  return Math.max( min, Math.min( max, val ) );
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function( bb ){
  if( bb == null ){
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if( bb.x1 != null && bb.y1 != null ){
    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.updateBoundingBox = function( bb1, bb2 ){
  // update bb1 with bb2 bounds

  bb1.x1 = Math.min( bb1.x1, bb2.x1 );
  bb1.x2 = Math.max( bb1.x2, bb2.x2 );
  bb1.w = bb1.x2 - bb1.x1;

  bb1.y1 = Math.min( bb1.y1, bb2.y1 );
  bb1.y2 = Math.max( bb1.y2, bb2.y2 );
  bb1.h = bb1.y2 - bb1.y1;
};

math.expandBoundingBoxByPoint = function( bb, x, y ){
  bb.x1 = Math.min( bb.x1, x );
  bb.x2 = Math.max( bb.x2, x );
  bb.w = bb.x2 - bb.x1;

  bb.y1 = Math.min( bb.y1, y );
  bb.y2 = Math.max( bb.y2, y );
  bb.h = bb.y2 - bb.y1;
};

math.expandBoundingBox = function( bb, padding ){
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;

  return bb;
};

math.boundingBoxesIntersect = function( bb1, bb2 ){
  // case: one bb to right of other
  if( bb1.x1 > bb2.x2 ){ return false; }
  if( bb2.x1 > bb1.x2 ){ return false; }

  // case: one bb to left of other
  if( bb1.x2 < bb2.x1 ){ return false; }
  if( bb2.x2 < bb1.x1 ){ return false; }

  // case: one bb above other
  if( bb1.y2 < bb2.y1 ){ return false; }
  if( bb2.y2 < bb1.y1 ){ return false; }

  // case: one bb below other
  if( bb1.y1 > bb2.y2 ){ return false; }
  if( bb2.y1 > bb1.y2 ){ return false; }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function( bb, x, y ){
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function( bb, pt ){
  return this.inBoundingBox( bb, pt.x, pt.y );
};

math.boundingBoxInBoundingBox = function( bb1, bb2 ){
  return (
       math.inBoundingBox( bb1, bb2.x1, bb2.y1 )
    && math.inBoundingBox( bb1, bb2.x2, bb2.y2 )
  );
};

math.roundRectangleIntersectLine = function(
  x, y, nodeX, nodeY, width, height, padding ){

  var cornerRadius = this.getRoundRectangleRadius( width, height );

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topLeftCenterX, topLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= topLeftCenterX
      && arcIntersections[1] <= topLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topRightCenterX, topRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= topRightCenterX
      && arcIntersections[1] <= topRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= bottomRightCenterX
      && arcIntersections[1] >= bottomRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= bottomLeftCenterX
      && arcIntersections[1] >= bottomLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function( x, y, lx1, ly1, lx2, ly2, tolerance ){
  var t = tolerance;

  var x1 = Math.min( lx1, lx2 );
  var x2 = Math.max( lx1, lx2 );
  var y1 = Math.min( ly1, ly2 );
  var y2 = Math.max( ly1, ly2 );

  return x1 - t <= x && x <= x2 + t
    && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function(
  x, y, x1, y1, x2, y2, x3, y3, tolerance ){

  var bb = {
    x1: Math.min( x1, x3, x2 ) - tolerance,
    x2: Math.max( x1, x3, x2 ) + tolerance,
    y1: Math.min( y1, y3, y2 ) - tolerance,
    y2: Math.max( y1, y3, y2 ) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }

};

math.solveCubic = function( a, b, c, d, result ){

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant, q, r, dum1, s, t, term1, r13;

  q = (3.0 * c - (b * b)) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = (b / 3.0);

  if( discriminant > 0 ){
    s = r + Math.sqrt( discriminant );
    s = ((s < 0) ? -Math.pow( -s, (1.0 / 3.0) ) : Math.pow( s, (1.0 / 3.0) ));
    t = r - Math.sqrt( discriminant );
    t = ((t < 0) ? -Math.pow( -t, (1.0 / 3.0) ) : Math.pow( t, (1.0 / 3.0) ));
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt( 3.0 ) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if( discriminant === 0 ){
    r13 = ((r < 0) ? -Math.pow( -r, (1.0 / 3.0) ) : Math.pow( r, (1.0 / 3.0) ));
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos( r / Math.sqrt( dum1 ) );
  r13 = 2.0 * Math.sqrt( q );
  result[0] = -term1 + r13 * Math.cos( dum1 / 3.0 );
  result[2] = -term1 + r13 * Math.cos( (dum1 + 2.0 * Math.PI) / 3.0 );
  result[4] = -term1 + r13 * Math.cos( (dum1 + 4.0 * Math.PI) / 3.0 );

  return;
};

math.sqdistToQuadraticBezier = function(
  x, y, x1, y1, x2, y2, x3, y3 ){

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3
    + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3
    + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x
    + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x
    + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic( a, b, c, d, roots );

  var zeroThreshold = 0.0000001;

  var params = [];

  for( var index = 0; index < 6; index += 2 ){
    if( Math.abs( roots[ index + 1] ) < zeroThreshold
        && roots[ index ] >= 0
        && roots[ index ] <= 1.0 ){
      params.push( roots[ index ] );
    }
  }

  params.push( 1.0 );
  params.push( 0.0 );

  var minDistanceSquared = -1;
  var closestParam;

  var curX, curY, distSquared;
  for( var i = 0; i < params.length; i++ ){
    curX = Math.pow( 1.0 - params[ i ], 2.0 ) * x1
      + 2.0 * (1 - params[ i ]) * params[ i ] * x2
      + params[ i ] * params[ i ] * x3;

    curY = Math.pow( 1 - params[ i ], 2.0 ) * y1
      + 2 * (1.0 - params[ i ]) * params[ i ] * y2
      + params[ i ] * params[ i ] * y3;

    distSquared = Math.pow( curX - x, 2 ) + Math.pow( curY - y, 2 );
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if( minDistanceSquared >= 0 ){
      if( distSquared < minDistanceSquared ){
        minDistanceSquared = distSquared;
        closestParam = params[ i ];
      }
    } else {
      minDistanceSquared = distSquared;
      closestParam = params[ i ];
    }
  }

  return minDistanceSquared;
};

math.sqdistToFiniteLine = function( x, y, x1, y1, x2, y2 ){
  var offset = [ x - x1, y - y1 ];
  var line = [ x2 - x1, y2 - y1 ];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if( dotProduct < 0 ){
    return hypSq;
  }

  if( adjSq > lineSq ){
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function( x, y, points ){
  var x1, y1, x2, y2;
  var y3;

  // Intersect with vertical line through (x, y)
  var up = 0;
  var down = 0;
  for( var i = 0; i < points.length / 2; i++ ){

    x1 = points[ i * 2];
    y1 = points[ i * 2 + 1];

    if( i + 1 < points.length / 2 ){
      x2 = points[ (i + 1) * 2];
      y2 = points[ (i + 1) * 2 + 1];
    } else {
      x2 = points[ (i + 1 - points.length / 2) * 2];
      y2 = points[ (i + 1 - points.length / 2) * 2 + 1];
    }

    if( x1 == x && x2 == x ){
      // then ignore
    } else if( (x1 >= x && x >= x2)
      || (x1 <= x && x <= x2) ){

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if( y3 > y ){
        up++;
      }

      if( y3 < y ){
        down++;
      }

    } else {
      continue;
    }

  }

  if( up % 2 === 0 ){
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function(
  x, y, basePoints, centerX, centerY, width, height, direction, padding ){

  //var direction = arguments[6];
  var transformedPoints = new Array( basePoints.length );

  // Gives negative angle
  var angle;

  if( direction[0] != null ){
    angle = Math.atan( direction[1] / direction[0] );

    if( direction[0] < 0 ){
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos( -angle );
  var sin = Math.sin( -angle );

  //    console.log("base: " + basePoints);
  for( var i = 0; i < transformedPoints.length / 2; i++ ){
    transformedPoints[ i * 2] =
      width / 2 * (basePoints[ i * 2] * cos
        - basePoints[ i * 2 + 1] * sin);

    transformedPoints[ i * 2 + 1] =
      height / 2 * (basePoints[ i * 2 + 1] * cos
        + basePoints[ i * 2] * sin);

    transformedPoints[ i * 2] += centerX;
    transformedPoints[ i * 2 + 1] += centerY;
  }

  var points;

  if( padding > 0 ){
    var expandedLineSet = this.expandPolygon(
      transformedPoints,
      -padding );

    points = this.joinLines( expandedLineSet );
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints( x, y, points );
};

math.joinLines = function( lineSet ){

  var vertices = new Array( lineSet.length / 2 );

  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for( var i = 0; i < lineSet.length / 4; i++ ){
    currentLineStartX = lineSet[ i * 4];
    currentLineStartY = lineSet[ i * 4 + 1];
    currentLineEndX = lineSet[ i * 4 + 2];
    currentLineEndY = lineSet[ i * 4 + 3];

    if( i < lineSet.length / 4 - 1 ){
      nextLineStartX = lineSet[ (i + 1) * 4];
      nextLineStartY = lineSet[ (i + 1) * 4 + 1];
      nextLineEndX = lineSet[ (i + 1) * 4 + 2];
      nextLineEndY = lineSet[ (i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(
      currentLineStartX, currentLineStartY,
      currentLineEndX, currentLineEndY,
      nextLineStartX, nextLineStartY,
      nextLineEndX, nextLineEndY,
      true );

    vertices[ i * 2] = intersection[0];
    vertices[ i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function( points, pad ){

  var expandedLineSet = new Array( points.length * 2 );

  var currentPointX, currentPointY, nextPointX, nextPointY;

  for( var i = 0; i < points.length / 2; i++ ){
    currentPointX = points[ i * 2];
    currentPointY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextPointX = points[ (i + 1) * 2];
      nextPointY = points[ (i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = (nextPointY - currentPointY);
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt( offsetX * offsetX + offsetY * offsetY );
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[ i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[ i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function(
  x, y, centerX, centerY, ellipseWradius, ellipseHradius ){

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt( dispX * dispX + dispY * dispY );

  var newLength = len - 1;

  if( newLength < 0 ){
    return [];
  }

  var lenProportion = newLength / len;

  return [ (centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y ];
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function(
  x1, y1, x2, y2, centerX, centerY, radius ){

  // Calculate d, direction vector of line
  var d = [ x2 - x1, y2 - y1 ]; // Direction vector of line
  var c = [ centerX, centerY ]; // Center of circle
  var f = [ x1 - centerX, y1 - centerY ];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;

  var discriminant = b * b - 4 * a * c;

  if( discriminant < 0 ){
    return [];
  }

  var t1 = (-b + Math.sqrt( discriminant )) / (2 * a);
  var t2 = (-b - Math.sqrt( discriminant )) / (2 * a);

  var tMin = Math.min( t1, t2 );
  var tMax = Math.max( t1, t2 );
  var inRangeParams = [];

  if( tMin >= 0 && tMin <= 1 ){
    inRangeParams.push( tMin );
  }

  if( tMax >= 0 && tMax <= 1 ){
    inRangeParams.push( tMax );
  }

  if( inRangeParams.length === 0 ){
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if( inRangeParams.length > 1 ){

    if( inRangeParams[0] == inRangeParams[1] ){
      return [ nearIntersectionX, nearIntersectionY ];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [ nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY ];
    }

  } else {
    return [ nearIntersectionX, nearIntersectionY ];
  }

};

math.findCircleNearPoint = function( centerX, centerY,
  radius, farX, farY ){

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt( displacementX * displacementX
    + displacementY * displacementY );

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [ centerX + unitDisplacementX * radius,
    centerY + unitDisplacementY * radius ];
};

math.findMaxSqDistanceToOrigin = function( points ){
  var maxSqDistance = 0.000001;
  var sqDistance;

  for( var i = 0; i < points.length / 2; i++ ){

    sqDistance = points[ i * 2] * points[ i * 2]
      + points[ i * 2 + 1] * points[ i * 2 + 1];

    if( sqDistance > maxSqDistance ){
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.midOfThree = function( a, b, c ){
  if( (b <= a && a <= c) || (c <= a && a <= b) ){
    return a;
  } else if( (a <= b && b <= c) || (c <= b && b <= a) ){
    return b;
  } else {
    return c;
  }
};

// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
math.finiteLinesIntersect = function(
  x1, y1, x2, y2,
  x3, y3, x4, y4,
  infiniteLines
){

  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;

  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;

  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b  = dy43 * dx21 - dx43 * dy21;

  if( u_b !== 0 ){
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    var flptThreshold = 0.001;
    var min = 0 - flptThreshold;
    var max = 1 + flptThreshold;

    if( min <= ua && ua <= max && min <= ub && ub <= max ){
      return [ x1 + ua * dx21, y1 + ua * dy21 ];

    } else {
      if( !infiniteLines ){
        return [];
      } else {
        return [ x1 + ua * dx21, y1 + ua * dy21 ];
      }
    }
  } else {
    if( ua_t === 0 || ub_t === 0 ){

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if( this.midOfThree( x1, x2, x4 ) === x4 ){
        return [ x4, y4 ];
      }

      // Check start point of second line
      if( this.midOfThree( x1, x2, x3 ) === x3 ){
        return [ x3, y3 ];
      }

      // Endpoint of first line
      if( this.midOfThree( x3, x4, x2 ) === x2 ){
        return [ x2, y2 ];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)
math.polygonIntersectLine = function(
  x, y, basePoints, centerX, centerY, width, height, padding ){

  var intersections = [];
  var intersection;

  var transformedPoints = new Array( basePoints.length );

  var doTransform = true;
  if( arguments.length === 5 ){
    doTransform = false;
  }

  var points;

  if( doTransform ){
    for( var i = 0; i < transformedPoints.length / 2; i++ ){
      transformedPoints[ i * 2] = basePoints[ i * 2] * width + centerX;
      transformedPoints[ i * 2 + 1] = basePoints[ i * 2 + 1] * height + centerY;
    }

    if( padding > 0 ){
      var expandedLineSet = math.expandPolygon(
        transformedPoints,
        -padding );

      points = math.joinLines( expandedLineSet );
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX, currentY, nextX, nextY;

  for( var i = 0; i < points.length / 2; i++ ){

    currentX = points[ i * 2];
    currentY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextX = points[ (i + 1) * 2];
      nextY = points[ (i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(
      x, y, centerX, centerY,
      currentX, currentY,
      nextX, nextY );

    if( intersection.length !== 0 ){
      intersections.push( intersection[0], intersection[1] );
    }
  }

  return intersections;
};

math.shortenIntersection = function(
  intersection, offset, amount ){

  var disp = [ intersection[0] - offset[0], intersection[1] - offset[1] ];

  var length = Math.sqrt( disp[0] * disp[0] + disp[1] * disp[1] );

  var lenRatio = (length - amount) / length;

  if( lenRatio < 0 ){
    lenRatio = 0.00001;
  }

  return [ offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1] ];
};

math.generateUnitNgonPointsFitToSquare = function( sides, rotationRadians ){
  var points = math.generateUnitNgonPoints( sides, rotationRadians );
  points = math.fitPolygonToSquare( points );

  return points;
};

math.fitPolygonToSquare = function( points ){
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ];
    y = points[2 * i + 1];

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ] = points[2 * i ] * sx;
    y = points[2 * i + 1] = points[2 * i + 1] * sy;

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  if( minY < -1 ){
    for( var i = 0; i < sides; i++ ){
      y = points[2 * i + 1] = points[2 * i + 1] + (-1 - minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function( sides, rotationRadians ){

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ?
    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  //    console.log(nodeShapes['square']);
  startAngle += rotationRadians;

  var points = new Array( sides * 2 );

  var currentAngle, x, y;
  for( var i = 0; i < sides; i++ ){
    currentAngle = i * increment + startAngle;

    x = points[2 * i ] = Math.cos( currentAngle );// * (1 + i/2);
    y = points[2 * i + 1] = Math.sin( -currentAngle );//  * (1 + i/2);
  }

  return points;
};

math.getRoundRectangleRadius = function( width, height ){

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min( width / 4, height / 4, 8 );
};

math.getCutRectangleCornerLength = function(){
  return 8;
};

module.exports = math;

},{}],85:[function(_dereq_,module,exports){
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

'use strict';

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function( executor ){
  /*  optionally support non-constructor/plain-function call  */
  if( !(this instanceof api) )
    return new api( executor );

  /*  initialize object  */
  this.id           = 'Thenable/1.0.7';
  this.state        = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled  = [];            /*  initial handlers  */
  this.onRejected   = [];            /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind( this )
  };

  /*  support optional executor function  */
  if( typeof executor === 'function' )
    executor.call( this, this.fulfill.bind( this ), this.reject.bind( this ) );
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function( value ){ return deliver( this, STATE_FULFILLED, 'fulfillValue', value ); },
  reject:  function( value ){ return deliver( this, STATE_REJECTED,  'rejectReason', value ); },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function( onFulfilled, onRejected ){
    var curr = this;
    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(
      resolver( onFulfilled, next, 'fulfill' ) );             /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(
      resolver( onRejected,  next, 'reject' ) );             /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute( curr );
    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function( curr, state, name, value ){
  if( curr.state === STATE_PENDING ){
    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[ name ] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute( curr );
  }
  return curr;
};

/*  execute all handlers  */
var execute = function( curr ){
  if( curr.state === STATE_FULFILLED )
    execute_handlers( curr, 'onFulfilled', curr.fulfillValue );
  else if( curr.state === STATE_REJECTED )
    execute_handlers( curr, 'onRejected',  curr.rejectReason );
};

/*  execute particular set of handlers  */
var execute_handlers = function( curr, name, value ){
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if( curr[ name ].length === 0 )
    return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[ name ];
  curr[ name ] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function(){
    for( var i = 0; i < handlers.length; i++ )
      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
  if( typeof setImmediate === 'function' )
    setImmediate( func );
  else
    setTimeout( func, 0 );
};

/*  generate a resolver function  */
var resolver = function( cb, next, method ){
  return function( value ){
    if( typeof cb !== 'function' )                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[ method ].call( next, value );                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
      var result;
      try { result = cb( value ); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
      catch( e ){
        next.reject( e );                                  /*  [Promises/A+ 2.2.7.2]  */
        return;
      }
      resolve( next, result );                               /*  [Promises/A+ 2.2.7.1]  */
    }
  };
};

/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
var resolve = function( promise, x ){
  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
  if( promise === x || promise.proxy === x ){
    promise.reject( new TypeError( 'cannot resolve promise with itself' ) );
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if( (typeof x === 'object' && x !== null) || typeof x === 'function' ){
    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch( e ){
      promise.reject( e );                                   /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if( typeof then === 'function' ){
    var resolved = false;
    try {
      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
      then.call( x,
        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
        function( y ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          if( y === x )                                 /*  [Promises/A+ 3.6]  */
            promise.reject( new TypeError( 'circular thenable chain' ) );
          else
            resolve( promise, y );
        },

        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
        function( r ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject( r );
        }
      );
    }
    catch( e ){
      if( !resolved )                                       /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject( e );                               /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill( x );                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// so we always have Promise.all()
api.all = function( ps ){
  return new api(function( resolveAll, rejectAll ){
    var vals = new Array( ps.length );
    var doneCount = 0;

    var fulfill = function( i, val ){
      vals[ i ] = val;
      doneCount++;

      if( doneCount === ps.length ){
        resolveAll( vals );
      }
    };

    for( var i = 0; i < ps.length; i++ ){
      (function( i ){
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if( isPromise ){
          p.then( function( val ){
            fulfill( i, val );
          }, function( err ){
            rejectAll( err );
          } );
        } else {
          var val = p;
          fulfill( i, val );
        }
      })( i );
    }

  } );
};

api.resolve = function( val ){
  return new api(function( resolve, reject ){ resolve( val ); });
};

api.reject = function( val ){
  return new api(function( resolve, reject ){ reject( val ); });
};

module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

},{}],86:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( './is' );
var util = _dereq_( './util' );

var stateSelectors = [
  {
    selector: ':selected',
    matches: function( ele ){ return ele.selected(); }
  },
  {
    selector: ':unselected',
    matches: function( ele ){ return !ele.selected(); }
  },
  {
    selector: ':selectable',
    matches: function( ele ){ return ele.selectable(); }
  },
  {
    selector: ':unselectable',
    matches: function( ele ){ return !ele.selectable(); }
  },
  {
    selector: ':locked',
    matches: function( ele ){ return ele.locked(); }
  },
  {
    selector: ':unlocked',
    matches: function( ele ){ return !ele.locked(); }
  },
  {
    selector: ':visible',
    matches: function( ele ){ return ele.visible(); }
  },
  {
    selector: ':hidden',
    matches: function( ele ){ return !ele.visible(); }
  },
  {
    selector: ':transparent',
    matches: function( ele ){ return ele.transparent(); }
  },
  {
    selector: ':grabbed',
    matches: function( ele ){ return ele.grabbed(); }
  },
  {
    selector: ':free',
    matches: function( ele ){ return !ele.grabbed(); }
  },
  {
    selector: ':removed',
    matches: function( ele ){ return ele.removed(); }
  },
  {
    selector: ':inside',
    matches: function( ele ){ return !ele.removed(); }
  },
  {
    selector: ':grabbable',
    matches: function( ele ){ return ele.grabbable(); }
  },
  {
    selector: ':ungrabbable',
    matches: function( ele ){ return !ele.grabbable(); }
  },
  {
    selector: ':animated',
    matches: function( ele ){ return ele.animated(); }
  },
  {
    selector: ':unanimated',
    matches: function( ele ){ return !ele.animated(); }
  },
  {
    selector: ':parent',
    matches: function( ele ){ return ele.isParent(); }
  },
  {
    selector: ':childless',
    matches: function( ele ){ return ele.isChildless(); }
  },
  {
    selector: ':child',
    matches: function( ele ){ return ele.isChild(); }
  },
  {
    selector: ':orphan',
    matches: function( ele ){ return ele.isOrphan(); }
  },
  {
    selector: ':nonorphan',
    matches: function( ele ){ return ele.isChild(); }
  },
  {
    selector: ':loop',
    matches: function( ele ){ return ele.isLoop(); }
  },
  {
    selector: ':simple',
    matches: function( ele ){ return ele.isSimple(); }
  },
  {
    selector: ':active',
    matches: function( ele ){ return ele.active(); }
  },
  {
    selector: ':inactive',
    matches: function( ele ){ return !ele.active(); }
  },
  {
    selector: ':backgrounding',
    matches: function( ele ){ return ele.backgrounding(); }
  },
  {
    selector: ':nonbackgrounding',
    matches: function( ele ){ return !ele.backgrounding(); }
  }
].sort(function( a, b ){ // n.b. selectors that are starting substrings of others must have the longer ones first
  return util.sort.descending( a.selector, b.selector );
});

var stateSelectorMatches = function( sel, ele ){
  var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || (function(){
    var selToFn = {};
    var s;

    for( var i = 0; i < stateSelectors.length; i++ ){
      s = stateSelectors[i];

      selToFn[ s.selector ] = s.matches;
    }

    return selToFn;
  })();

  return lookup[ sel ]( ele );
};

var stateSelectorRegex = '(' + stateSelectors.map(function( s ){ return s.selector; }).join('|') + ')';

var Selector = function( selector ){
  var self = this;

  self._private = {
    selectorText: null,
    invalid: true
  };

  // storage for parsed queries
  var newQuery = function(){
    return {
      length: 0, // how many expressions per query

      classes: [],
      colonSelectors: [],
      data: [],
      group: null,
      ids: [],
      meta: [],

      // fake selectors
      collection: null, // a collection to match against
      filter: null, // filter function

      // these are defined in the upward direction rather than down (e.g. child)
      // because we need to go up in Selector.filter()
      parent: null, // parent query obj
      ancestor: null, // ancestor query obj
      subject: null, // defines subject in compound query (subject query obj; points to self if subject)

      // use these only when subject has been defined
      child: null,
      descendant: null
    };
  };

  if( !selector || ( is.string( selector ) && selector.match( /^\s*$/ ) ) ){

    self.length = 0;

  } else if( selector === '*' || selector === 'edge' || selector === 'node' ){

    // make single, group-only selectors cheap to make and cheap to filter

    self[0] = newQuery();
    self[0].group = selector === '*' ? selector : selector + 's';
    self[0].groupOnly = true;
    self[0].length = 1;
    self._private.invalid = false;
    self._private.selectorText = selector;
    self.length = 1;

  } else if( is.elementOrCollection( selector ) ){

    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self[0].length = 1;
    self.length = 1;

  } else if( is.fn( selector ) ){

    self[0] = newQuery();
    self[0].filter = selector;
    self[0].length = 1;
    self.length = 1;

  } else if( is.string( selector ) ){

    // the current subject in the query
    var currentSubject = null;

    // tokens in the query language
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'", // string literals (used in data selectors) -- doublequotes | singlequotes
      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
    tokens.className = tokens.variable; // a class name (follows variable conventions)
    tokens.id = tokens.variable; // an element id (follows variable conventions)

    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
    // so that values get compared properly in Selector.filter()
    var cleanMetaChars = function( str ){
      return str.replace( new RegExp( '\\\\(' + tokens.metaChar + ')', 'g' ), function( match, $1, offset, original ){
        return $1;
      } );
    };

    // add @ variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];
      tokens.comparatorOp += '|@' + op;
    }

    // add ! variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];

      if( op.indexOf( '!' ) >= 0 ){ continue; } // skip ops that explicitly contain !
      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

      tokens.comparatorOp += '|\\!' + op;
    }

    // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
    // - when you add something here, also add to Selector.toString()
    var exprs = [
      {
        name: 'group',
        query: true,
        regex: '(node|edge|\\*)',
        populate: function( group ){
          this.group = group === '*' ? group : group + 's';
        }
      },

      {
        name: 'state',
        query: true,
        regex: stateSelectorRegex,
        populate: function( state ){
          this.colonSelectors.push( state );
        }
      },

      {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function( id ){
          this.ids.push( cleanMetaChars( id ) );
        }
      },

      {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function( className ){
          this.classes.push( cleanMetaChars( className ) );
        }
      },

      {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( variable ){
          this.data.push( {
            field: cleanMetaChars( variable )
          } );
        }
      },

      {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function( variable, comparatorOp, value ){
          var valueIsString = new RegExp( '^' + tokens.string + '$' ).exec( value ) != null;

          if( valueIsString ){
            value = value.substring( 1, value.length - 1 );
          } else {
            value = parseFloat( value );
          }

          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: comparatorOp,
            value: value
          } );
        }
      },

      {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( boolOp, variable ){
          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: boolOp
          } );
        }
      },

      {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function( meta, comparatorOp, number ){
          this.meta.push( {
            field: cleanMetaChars( meta ),
            operator: comparatorOp,
            value: parseFloat( number )
          } );
        }
      },

      {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function(){
          // go on to next query
          self[ ++i ] = newQuery();
          currentSubject = null;
        }
      },

      {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function(){
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = this;
          childQuery.subject = currentSubject;

          // we're now populating the child query with expressions that follow
          self[ i ] = childQuery;
        }
      },

      {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function(){
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = this;
          descendantQuery.subject = currentSubject;

          // we're now populating the descendant query with expressions that follow
          self[ i ] = descendantQuery;
        }
      },

      {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function(){
          if( currentSubject != null && this.subject != this ){
            util.error( 'Redefinition of subject in selector `' + selector + '`' );
            return false;
          }

          currentSubject = this;
          this.subject = this;
        }

      }
    ];

    self._private.selectorText = selector;
    var remaining = selector;
    var i = 0;

    // of all the expressions, find the first match in the remaining text
    var consumeExpr = function( expectation ){
      var expr;
      var match;
      var name;

      for( var j = 0; j < exprs.length; j++ ){
        var e = exprs[ j ];
        var n = e.name;

        // ignore this expression if it doesn't meet the expectation function
        if( is.fn( expectation ) && !expectation( n, e ) ){ continue; }

        var m = remaining.match( new RegExp( '^' + e.regex ) );

        if( m != null ){
          match = m;
          expr = e;
          name = n;

          var consumed = m[0];
          remaining = remaining.substring( consumed.length );

          break; // we've consumed one expr, so we can return now
        }
      }

      return {
        expr: expr,
        match: match,
        name: name
      };
    };

    // consume all leading whitespace
    var consumeWhitespace = function(){
      var match = remaining.match( /^\s+/ );

      if( match ){
        var consumed = match[0];
        remaining = remaining.substring( consumed.length );
      }
    };

    self[0] = newQuery(); // get started

    consumeWhitespace(); // get rid of leading whitespace
    for( ;; ){
      var check = consumeExpr();

      if( check.expr == null ){
        util.error( 'The selector `' + selector + '`is invalid' );
        return;
      } else {
        var args = [];
        for( var j = 1; j < check.match.length; j++ ){
          args.push( check.match[ j ] );
        }

        self[i].length++;

        // let the token populate the selector object (i.e. in self[i])
        var ret = check.expr.populate.apply( self[ i ], args );

        if( ret === false ){ return; } // exit if population failed
      }

      // we're done when there's nothing left to parse
      if( remaining.match( /^\s*$/ ) ){
        break;
      }
    }

    self.length = i + 1;

    // adjust references for subject
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( query.subject != null ){
        // go up the tree until we reach the subject
        for( ;; ){
          if( query.subject == query ){ break; } // done if subject is self

          if( query.parent != null ){ // swap parent/child reference
            var parent = query.parent;
            var child = query;

            child.parent = null;
            parent.child = child;

            query = parent; // go up the tree
          } else if( query.ancestor != null ){ // swap ancestor/descendant
            var ancestor = query.ancestor;
            var descendant = query;

            descendant.ancestor = null;
            ancestor.descendant = descendant;

            query = ancestor; // go up the tree
          } else {
            util.error( 'When adjusting references for the selector `' + query + '`, neither parent nor ancestor was found' );
            break;
          }
        } // for

        self[ j ] = query.subject; // subject should be the root query
      } // if
    } // for

  } else {
    util.error( 'A selector must be created from a string; found ' + selector );
    return;
  }

  self._private.invalid = false;

};

var selfn = Selector.prototype;

selfn.size = function(){
  return this.length;
};

selfn.eq = function( i ){
  return this[ i ];
};

var queryMatches = function( query, ele ){
  var ele_p = ele._private;

  // make single group-only selectors really cheap to check since they're the most common ones
  if( query.groupOnly ){
    return query.group === '*' || query.group === ele_p.group;
  }

  // check group
  if( query.group != null && query.group != '*' && query.group != ele_p.group ){
    return false;
  }

  var cy = ele.cy();

  // check colon selectors
  var allColonSelectorsMatch = true;
  for( var k = 0; k < query.colonSelectors.length; k++ ){
    var sel = query.colonSelectors[ k ];

    allColonSelectorsMatch = stateSelectorMatches( sel, ele );

    if( !allColonSelectorsMatch ) break;
  }
  if( !allColonSelectorsMatch ) return false;

  // check id
  var allIdsMatch = true;
  for( var k = 0; k < query.ids.length; k++ ){
    var id = query.ids[ k ];
    var actualId = ele_p.data.id;

    allIdsMatch = allIdsMatch && (id == actualId);

    if( !allIdsMatch ) break;
  }
  if( !allIdsMatch ) return false;

  // check classes
  var allClassesMatch = true;
  for( var k = 0; k < query.classes.length; k++ ){
    var cls = query.classes[ k ];

    allClassesMatch = allClassesMatch && ele.hasClass( cls );

    if( !allClassesMatch ) break;
  }
  if( !allClassesMatch ) return false;

  // generic checking for data/metadata
  var operandsMatch = function( params ){
    var allDataMatches = true;
    for( var k = 0; k < query[ params.name ].length; k++ ){
      var data = query[ params.name ][ k ];
      var operator = data.operator;
      var value = data.value;
      var field = data.field;
      var matches;

      if( operator != null && value != null ){

        var fieldVal = params.fieldValue( field );
        var fieldStr = !is.string( fieldVal ) && !is.number( fieldVal ) ? '' : '' + fieldVal;
        var valStr = '' + value;

        var caseInsensitive = false;
        if( operator.indexOf( '@' ) >= 0 ){
          fieldStr = fieldStr.toLowerCase();
          valStr = valStr.toLowerCase();

          operator = operator.replace( '@', '' );
          caseInsensitive = true;
        }

        var notExpr = false;
        if( operator.indexOf( '!' ) >= 0 ){
          operator = operator.replace( '!', '' );
          notExpr = true;
        }

        // if we're doing a case insensitive comparison, then we're using a STRING comparison
        // even if we're comparing numbers
        if( caseInsensitive ){
          value = valStr.toLowerCase();
          fieldVal = fieldStr.toLowerCase();
        }

        var isIneqCmp = false;

        switch( operator ){
        case '*=':
          matches = fieldStr.indexOf( valStr ) >= 0;
          break;
        case '$=':
          matches = fieldStr.indexOf( valStr, fieldStr.length - valStr.length ) >= 0;
          break;
        case '^=':
          matches = fieldStr.indexOf( valStr ) === 0;
          break;
        case '=':
          matches = fieldVal === value;
          break;
        case '>':
          isIneqCmp = true;
          matches = fieldVal > value;
          break;
        case '>=':
          isIneqCmp = true;
          matches = fieldVal >= value;
          break;
        case '<':
          isIneqCmp = true;
          matches = fieldVal < value;
          break;
        case '<=':
          isIneqCmp = true;
          matches = fieldVal <= value;
          break;
        default:
          matches = false;
          break;
        }

        // apply the not op, but null vals for inequalities should always stay non-matching
        if( notExpr && ( fieldVal != null || !isIneqCmp ) ){
          matches = !matches;
        }
      } else if( operator != null ){
        switch( operator ){
        case '?':
          matches = params.fieldTruthy( field );
          break;
        case '!':
          matches = !params.fieldTruthy( field );
          break;
        case '^':
          matches = params.fieldUndefined( field );
          break;
        }
      } else {
        matches = !params.fieldUndefined( field );
      }

      if( !matches ){
        allDataMatches = false;
        break;
      }
    } // for

    return allDataMatches;
  }; // operandsMatch

  // check data matches
  var allDataMatches = operandsMatch( {
    name: 'data',
    fieldValue: function( field ){
      return ele_p.data[ field ];
    },
    fieldUndefined: function( field ){
      return ele_p.data[ field ] === undefined;
    },
    fieldTruthy: function( field ){
      if( ele_p.data[ field ] ){
        return true;
      }
      return false;
    }
  } );

  if( !allDataMatches ){
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch( {
    name: 'meta',
    fieldValue: function( field ){
      return ele[ field ]();
    },
    fieldUndefined: function( field ){
      return ele[ field ]() == null;
    },
    fieldTruthy: function( field ){
      if( ele[ field ]() ){
        return true;
      }
      return false;
    }
  } );

  if( !allMetaMatches ){
    return false;
  }

  // check collection
  if( query.collection != null ){
    var matchesAny = query.collection.hasElementWithId( ele.id() );

    if( !matchesAny ){
      return false;
    }
  }

  // check filter function
  if( query.filter != null && ele.collection().some( query.filter ) ){
    return false;
  }

  // check parent/child relations
  var confirmRelations = function( query, eles ){
    if( query != null ){
      var matches = false;

      if( !cy.hasCompoundNodes() ){
        return false;
      }

      eles = eles(); // save cycles if query == null

      // query must match for at least one element (may be recursive)
      for( var i = 0; i < eles.length; i++ ){
        if( queryMatches( query, eles[ i ] ) ){
          matches = true;
          break;
        }
      }

      return matches;
    } else {
      return true;
    }
  };

  if( !confirmRelations( query.parent, function(){
    return ele.parent();
  } ) ){ return false; }

  if( !confirmRelations( query.ancestor, function(){
    return ele.parents();
  } ) ){ return false; }

  if( !confirmRelations( query.child, function(){
    return ele.children();
  } ) ){ return false; }

  if( !confirmRelations( query.descendant, function(){
    return ele.descendants();
  } ) ){ return false; }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
selfn.filter = function( collection ){
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return cy.collection();
  }

  // for 1 id #foo queries, just get the element
  if( self.length === 1 && self[0].length === 1 && self[0].ids.length === 1 ){
    return collection.getElementById( self[0].ids[0] ).collection();
  }

  var selectorFunction = function( element, i ){
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( queryMatches( query, element ) ){
        return true;
      }
    }

    return false;
  };

  if( self._private.selectorText == null ){
    selectorFunction = function(){ return true; };
  }

  var filteredCollection = collection.filter( selectorFunction );

  return filteredCollection;
}; // filter

// does selector match a single element?
selfn.matches = function( ele ){
  var self = this;

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return false;
  }

  for( var j = 0; j < self.length; j++ ){
    var query = self[ j ];

    if( queryMatches( query, ele ) ){
      return true;
    }
  }

  return false;
}; // filter

// ith query to string
selfn.toString = selfn.selector = function(){

  var str = '';

  var clean = function( obj ){
    if( obj == null ){
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function( val ){
    if( is.string( val ) ){
      return '"' + val + '"';
    } else {
      return clean( val );
    }
  };

  var space = function( val ){
    return ' ' + val + ' ';
  };

  var queryToString = function( query ){
    var str = '';

    if( query.subject === query ){
      str += '$';
    }

    var group = clean( query.group );
    str += group.substring( 0, group.length - 1 );

    for( var j = 0; j < query.data.length; j++ ){
      var data = query.data[ j ];

      if( data.value ){
        str += '[' + data.field + space( clean( data.operator ) ) + cleanVal( data.value ) + ']';
      } else {
        str += '[' + clean( data.operator ) + data.field + ']';
      }
    }

    for( var j = 0; j < query.meta.length; j++ ){
      var meta = query.meta[ j ];
      str += '[[' + meta.field + space( clean( meta.operator ) ) + cleanVal( meta.value ) + ']]';
    }

    for( var j = 0; j < query.colonSelectors.length; j++ ){
      var sel = query.colonSelectors[ i ];
      str += sel;
    }

    for( var j = 0; j < query.ids.length; j++ ){
      var sel = '#' + query.ids[ i ];
      str += sel;
    }

    for( var j = 0; j < query.classes.length; j++ ){
      var sel = '.' + query.classes[ j ];
      str += sel;
    }

    if( query.parent != null ){
      str = queryToString( query.parent ) + ' > ' + str;
    }

    if( query.ancestor != null ){
      str = queryToString( query.ancestor ) + ' ' + str;
    }

    if( query.child != null ){
      str += ' > ' + queryToString( query.child );
    }

    if( query.descendant != null ){
      str += ' ' + queryToString( query.descendant );
    }

    return str;
  };

  for( var i = 0; i < this.length; i++ ){
    var query = this[ i ];

    str += queryToString( query );

    if( this.length > 1 && i < this.length - 1 ){
      str += ', ';
    }
  }

  return str;
};

module.exports = Selector;

},{"./is":82,"./util":99}],87:[function(_dereq_,module,exports){
function ObjectSet(){
  this._obj = {};
}

var p = ObjectSet.prototype;

p.add = function( val ){
  this._obj[ val ] = 1;
};

p.remove = function( val ){
  this._obj[ val ] = 0;
};

p.has = function( val ){
  return this._obj[ val ] === 1;
};

module.exports = typeof Set !== 'undefined' ? Set : ObjectSet;

},{}],88:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function( eles ){
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if( _p.newStyle ){ // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};

    self.cleanElements( eles, true );
  }

  for( var ie = 0; ie < eles.length; ie++ ){
    var ele = eles[ ie ];

    var cxtMeta = self.getContextMeta( ele );

    if( cxtMeta.empty ){
      continue;
    } else {
      updatedEles.merge( ele );
    }

    var cxtStyle = self.getContextStyle( cxtMeta );
    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

    self.updateTransitions( ele, app.diffProps );
    self.updateStyleHints( ele );

  } // for elements

  _p.newStyle = false;

  return updatedEles;
};

styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[ dualCxtKey ];

  if( cachedVal ){
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var oldHasCxt = oldCxtKey[ i ] === 't';
    var newHasCxt = newCxtKey[ i ] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if( cxtHasDiffed || cxtHasMappedProps ){
      var props;

      if( cxtHasDiffed && cxtHasMappedProps ){
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if( cxtHasDiffed ){
        props = cxt.properties; // need to check them all
      } else if( cxtHasMappedProps ){
        props = cxt.mappedProperties; // only need to check mapped
      }

      for( var j = 0; j < props.length; j++ ){
        var prop = props[ j ];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for( var k = i + 1; k < self.length; k++ ){
          var laterCxt = self[ k ];
          var hasLaterCxt = newCxtKey[ k ] === 't';

          if( !hasLaterCxt ){ continue; } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
        }

        if( !addedProp[ name ] && !laterCxtOverrides ){
          addedProp[ name ] = true;
          diffProps.push( name );
        }
      } // for props
    } // if

  } // for contexts

  cache[ dualCxtKey ] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function( ele ){
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if( self._private.newStyle ){
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for( var i = 0; i < self.length; i++ ){
    var context = self[ i ];
    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

    if( contextSelectorMatches ){
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff( prevKey, cxtKey );

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function( cxtMeta ){
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if( cxtStyles[ cxtKey ] ){ return cxtStyles[ cxtKey ]; }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var hasCxt = cxtKey[ i ] === 't';

    if( !hasCxt ){ continue; }

    for( var j = 0; j < cxt.properties.length; j++ ){
      var prop = cxt.properties[ j ];

      style[ prop.name ] = prop;
    }
  }

  cxtStyles[ cxtKey ] = style;
  return style;
};

styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for( var i = 0; i < diffProps.length; i++ ){
    var diffPropName = diffProps[ i ];
    var cxtProp = cxtStyle[ diffPropName ];
    var eleProp = ele.pstyle( diffPropName );

    if( !cxtProp ){ // no context prop means delete
      if( !eleProp ){
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if( eleProp.bypass ){
        cxtProp = { name: diffPropName, deleteBypassed: true };
      } else {
        cxtProp = { name: diffPropName, delete: true };
      }
    }

    // save cycles when the context prop doesn't need to be applied
    if( eleProp === cxtProp ){ continue; }

    var retDiffProp = retDiffProps[ diffPropName ] = {
      prev: eleProp
    };

    self.applyParsedProperty( ele, cxtProp );

    retDiffProp.next = ele.pstyle( diffPropName );

    if( retDiffProp.next && retDiffProp.next.bypass ){
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function(ele){
  var _p = ele._private;
  var self = this;

  if( ele.removed() ){ return; }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if( _p.group === 'nodes' ){
    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
      var size = ele.pstyle( 'pie-' + i + '-background-size' ).value;

      if( size > 0 ){
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = ele.pstyle( 'text-transform' ).strValue;
  var content = ele.pstyle( 'label' ).strValue;
  var srcContent = ele.pstyle( 'source-label' ).strValue;
  var tgtContent = ele.pstyle( 'target-label' ).strValue;
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ele.pstyle( 'font-size' ).pfValue + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  // var variant = style['font-variant'].strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;
  var valign = ele.pstyle( 'text-valign' ).strValue;
  var halign = ele.pstyle( 'text-valign' ).strValue;
  var oWidth = ele.pstyle( 'text-outline-width' ).pfValue;
  var wrap = ele.pstyle( 'text-wrap' ).strValue;
  var wrapW = ele.pstyle( 'text-max-width' ).pfValue;
  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
  _p.labelStyleKey = labelStyleKey;
  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
  _p.labelKey = labelStyleKey + '$' + content;
  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function( ele, parsedProp ){
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal, flatProp;
  var types = self.types;
  var type = self.properties[ prop.name ].type;
  var propIsBypass = prop.bypass;
  var origProp = style[ prop.name ];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  // edges connected to compound nodes can not be haystacks
  if(
    parsedProp.name === 'curve-style'
    && parsedProp.value === 'haystack'
    && ele.isEdge()
    && ( ele.isLoop() || ele.source().isParent() || ele.target().isParent() )
  ){
    prop = parsedProp = this.parse( parsedProp.name, 'bezier', propIsBypass );
  }

  if( prop.delete ){ // delete the property and use the default value on falsey value
    style[ prop.name ] = undefined;

    return true;
  }

  if( prop.deleteBypassed ){ // delete the property that the
    if( !origProp ){
      return true; // can't delete if no prop

    } else if( origProp.bypass ){ // delete bypassed
      origProp.bypassed = undefined;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  }

  // check if we need to delete the current bypass
  if( prop.deleteBypass ){ // then this property is just here to indicate we need to delete
    if( !origProp ){
      return true; // property is already not defined

    } else if( origProp.bypass ){ // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[ prop.name ] = origProp.bypassed;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function(){
    util.error( 'Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined' );
  };

  // put the property in the style objects
  switch( prop.mapped ){ // flatten the property if mapped
  case types.mapData:
    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal = _p.data;

    for( var i = 0; i < fields.length && fieldVal; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    }

    var percent;
    if( !is.number( fieldVal ) ){ // then keep the mapping but assume 0% for now
      percent = 0;
    } else {
      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
    }

    // make sure to bound percent value
    if( percent < 0 ){
      percent = 0;
    } else if( percent > 1 ){
      percent = 1;
    }

    if( type.color ){
      var r1 = prop.valueMin[0];
      var r2 = prop.valueMax[0];
      var g1 = prop.valueMin[1];
      var g2 = prop.valueMax[1];
      var b1 = prop.valueMin[2];
      var b2 = prop.valueMax[2];
      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

      var clr = [
        Math.round( r1 + (r2 - r1) * percent ),
        Math.round( g1 + (g2 - g1) * percent ),
        Math.round( b1 + (b2 - b1) * percent ),
        Math.round( a1 + (a2 - a1) * percent )
      ];

      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
        name: prop.name,
        value: clr,
        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
      };

    } else if( type.number ){
      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
      flatProp = this.parse( prop.name, calcValue, prop.bypass, flatPropMapping );

    } else {
      return false; // can only map to colours and numbers
    }

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  // direct mapping
  case types.data:
    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal = _p.data;

    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    } }

    flatProp = this.parse( prop.name, fieldVal, prop.bypass, flatPropMapping );

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      var flatPropVal = origProp ? origProp.strValue : '';

      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case types.fn:
    var fn = prop.value;
    var fnRetVal = fn( ele );

    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, flatPropMapping );
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case undefined:
    break; // just set the property

  default:
    return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if( propIsBypass ){
    if( origPropIsBypass ){ // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else { // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[ prop.name ] = prop; // and set

  } else { // prop is not bypass
    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else { // then just replace the old prop with the new one
      style[ prop.name ] = prop;
    }
  }

  this.checkZOrderTrigger( ele, prop.name, origProp ? origProp.value : null, prop.value );

  return true;
};

styfn.cleanElements = function( eles, keepBypasses ){
  var self = this;
  var props = self.properties;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( !keepBypasses ){
      ele._private.style = {};
    } else {
      var style = ele._private.style;

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        var eleProp = style[ prop.name ];

        if( eleProp ){
          if( eleProp.bypass ){
            eleProp.bypassed = null;
          } else {
            style[ prop.name ] = null;
          }
        }
      }
    }
  }
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function(){
  var cy = this._private.cy;
  var eles = cy.mutableElements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function( eles ){
  var self = this;
  var cy = this._private.cy;
  var updatedEles = cy.collection();

  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var style = ele._private.style;
    var updatedEle = false;

    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
      var prop = self.properties[ j ];
      var propInStyle = style[ prop.name ];

      if( propInStyle && propInStyle.mapping ){
        var mapping = propInStyle.mapping;

        this.applyParsedProperty( ele, mapping ); // reapply the mapping property

        updatedEle = true;
      }
    }

    if( updatedEle ){
      this.updateStyleHints( ele );

      updatedEles.merge( ele );
    }
  }

  return updatedEles;
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function( ele, diffProps, isBypass ){
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle( 'transition-property' ).value;
  var duration = ele.pstyle( 'transition-duration' ).pfValue;
  var delay = ele.pstyle( 'transition-delay' ).pfValue;

  if( props.length > 0 && duration > 0 ){

    var css = {};

    // build up the style to animate towards
    var anyPrev = false;
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      var styProp = ele.pstyle( prop );
      var diffProp = diffProps[ prop ];

      if( !diffProp ){ continue; }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if( !fromProp ){ continue; }

      // consider px values
      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

      // consider numerical values
      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

      // consider colour values
      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
        diff = fromProp.value[0] !== toProp.value[0]
          || fromProp.value[1] !== toProp.value[1]
          || fromProp.value[2] !== toProp.value[2]
        ;

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if( diff ){
        css[ prop ] = toProp.strValue; // to val
        this.applyBypass( ele, prop, initVal ); // from val
        anyPrev = true;
      }

    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if( !anyPrev ){ return; }

    _p.transitioning = true;

    ele.stop();

    if( delay > 0 ){
      ele.delay( delay );
    }

    ele.animate( {
      css: css
    }, {
      duration: duration,
      easing: ele.pstyle( 'transition-timing-function' ).value,
      queue: false,
      complete: function(){
        if( !isBypass ){
          self.removeBypasses( ele, props );
        }

        _p.transitioning = false;
      }
    } );

  } else if( _p.transitioning ){
    ele.stop();

    this.removeBypasses( ele, props );

    _p.transitioning = false;
  }
};

styfn.checkZOrderTrigger = function( ele, name, fromValue, toValue ){
  var prop = this.properties[ name ];

  if( prop.triggersZOrder && ( fromValue == null || prop.triggersZOrder( fromValue, toValue ) ) ){
    this._private.cy.notify({
      type: 'zorder',
      eles: ele
    });
  }
};

module.exports = styfn;

},{"../is":82,"../util":99}],89:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var util = _dereq_( '../util' );

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function( eles, name, value, updateTransitions ){
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if( name === '*' || name === '**' ){ // apply to all property names

    if( value !== undefined ){
      for( var i = 0; i < self.properties.length; i++ ){
        var prop = self.properties[ i ];
        var name = prop.name;

        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }

  } else if( is.string( name ) ){ // then parse the single property
    var parsedProp = this.parse( name, value, true );

    if( parsedProp ){
      props.push( parsedProp );
    }
  } else if( is.plainObject( name ) ){ // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var name = prop.name;
      var value = specifiedProps[ name ];

      if( value === undefined ){ // try camel case name too
        value = specifiedProps[ util.dash2camel( name ) ];
      }

      if( value !== undefined ){
        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }
  } else { // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if( props.length === 0 ){ return false; }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var diffProps = {};
    var diffProp;

    for( var j = 0; j < props.length; j++ ){ // for each prop
      var prop = props[ j ];

      if( updateTransitions ){
        var prevProp = ele.pstyle( prop.name );
        diffProp = diffProps[ prop.name ] = { prev: prevProp };
      }

      ret = this.applyParsedProperty( ele, prop ) || ret;

      if( updateTransitions ){
        diffProp.next = ele.pstyle( prop.name );
      }

    } // for props

    if( ret ){
      this.updateStyleHints( ele );
    }

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function( eles, name, value ){
  name = util.camel2dash( name );

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var prop = ele._private.style[ name ];
    var type = this.properties[ name ].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if( !prop || !prop.bypass ){ // need a bypass if one doesn't exist
      this.applyBypass( ele, name, value );
      continue;
    }

    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

    prop.value = value;

    if( prop.pfValue != null ){
      prop.pfValue = value;
    }

    if( isColor ){
      prop.strValue = 'rgb(' + value.join( ',' ) + ')';
    } else if( isMulti ){
      prop.strValue = value.join( ' ' );
    } else {
      prop.strValue = '' + value;
    }

    this.checkZOrderTrigger( ele, name, oldValue, value );
  }
};

styfn.removeAllBypasses = function( eles, updateTransitions ){
  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
};

styfn.removeBypasses = function( eles, props, updateTransitions ){
  var isBypass = true;

  for( var j = 0; j < eles.length; j++ ){
    var ele = eles[ j ];
    var diffProps = {};

    for( var i = 0; i < props.length; i++ ){
      var name = props[ i ];
      var prop = this.properties[ name ];
      var prevProp = ele.pstyle( prop.name );

      if( !prevProp || !prevProp.bypass ){
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass
      var parsedProp = this.parse( name, value, true );
      var diffProp = diffProps[ prop.name ] = { prev: prevProp };

      this.applyParsedProperty( ele, parsedProp );

      diffProp.next = ele.pstyle( prop.name );
    } // for props

    this.updateStyleHints( ele );

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles
};

module.exports = styfn;

},{"../is":82,"../util":99}],90:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_( '../window' );

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function(){
  var px = this.containerCss( 'font-size' );

  if( px != null ){
    return parseFloat( px );
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function( propName ){
  var cy = this._private.cy;
  var domElement = cy.container();

  if( window && domElement && window.getComputedStyle ){
    return window.getComputedStyle( domElement ).getPropertyValue( propName );
  }
};

module.exports = styfn;

},{"../window":107}],91:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function( ele, prop ){
  if( prop ){
    return this.getStylePropertyValue( ele, prop, true );
  } else {
    return this.getRawStyle( ele, true );
  }
};

// gets the raw style for an element
styfn.getRawStyle = function( ele, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var rstyle = {};

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );

      if( val != null ){
        rstyle[ prop.name ] = val;
        rstyle[ util.dash2camel( prop.name ) ] = val;
      }
    }

    return rstyle;
  }
};

styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var prop = self.properties[ propName ];

    if( prop.alias ){
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle( prop.name );
    var zoom = ele.cy().zoom();

    if( styleProp ){
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat( styleProp.pfValue ).map( function( pfValue ){
        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
      } ).join( ' ' ) : styleProp.strValue;

      return val;
    }
  }
};

styfn.getAnimationStartStyle = function( ele, aniProps ){
  var rstyle = {};

  for( var i = 0; i < aniProps.length; i++ ){
    var aniProp = aniProps[ i ];
    var name = aniProp.name;

    var styleProp = ele.pstyle( name );

    if( styleProp !== undefined ){ // then make a prop of it
      if( is.plainObject( styleProp ) ){
        styleProp = this.parse( name, styleProp.strValue );
      } else {
        styleProp = this.parse( name, styleProp );
      }
    }

    if( styleProp ){
      rstyle[ name ] = styleProp;
    }
  }

  return rstyle;
};

styfn.getPropsList = function( propsObj ){
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if( style ){
    var names = Object.keys( style );

    for( var i = 0; i < names.length; i++ ){
      var name = names[i];
      var val = style[ name ];
      var prop = props[ name ] || props[ util.camel2dash( name ) ];
      var styleProp = this.parse( prop.name, val );

      rstyle.push( styleProp );
    }
  }

  return rstyle;
};

module.exports = styfn;

},{"../is":82,"../util":99}],92:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );
var util = _dereq_( '../util' );
var Selector = _dereq_( '../selector' );

var Style = function( cy ){

  if( !(this instanceof Style) ){
    return new Style( cy );
  }

  if( !is.core( cy ) ){
    util.error( 'A style must have a core reference' );
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };

  this.length = 0;

  this.resetToDefault();
};

var styfn = Style.prototype;

styfn.instanceString = function(){
  return 'style';
};

// remove all contexts
styfn.clear = function(){
  for( var i = 0; i < this.length; i++ ){
    this[ i ] = undefined;
  }
  this.length = 0;

  var _p = this._private;

  _p.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function(){
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function(){
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function( selectorStr ){
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );

  var i = this.length++; // new context means new index
  this[ i ] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function(){
  var self = this;
  var args = arguments;

  switch( args.length ){
  case 1:
    var map = args[0];

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        this.cssRule( prop.name, mapVal );
      }
    }

    break;

  case 2:
    this.cssRule( args[0], args[1] );
    break;

  default:
    break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function( name, value ){
  // name-value pair
  var property = this.parse( name, value );

  // add property to current context if valid
  if( property ){
    var i = this.length - 1;
    this[ i ].properties.push( property );
    this[ i ].properties[ property.name ] = property; // allow access by name as well

    if( property.name.match( /pie-(\d+)-background-size/ ) && property.value ){
      this._private.hasPie = true;
    }

    if( property.mapped ){
      this[ i ].mappedProperties.push( property );
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[ i ].selector;
    if( currentSelectorIsCore ){
      this._private.coreStyle[ property.name ] = property;
    }
  }

  return this; // chaining
};

// static function
Style.fromJson = function( cy, json ){
  var style = new Style( cy );

  style.fromJson( json );

  return style;
};

Style.fromString = function( cy, string ){
  return new Style( cy ).fromString( string );
};

[
  _dereq_( './apply' ),
  _dereq_( './bypass' ),
  _dereq_( './container' ),
  _dereq_( './get-for-ele' ),
  _dereq_( './json' ),
  _dereq_( './string-sheet' ),
  _dereq_( './properties' ),
  _dereq_( './parse' )
].forEach( function( props ){
  util.extend( styfn, props );
} );


Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

},{"../is":82,"../selector":86,"../util":99,"./apply":88,"./bypass":89,"./container":90,"./get-for-ele":91,"./json":93,"./parse":94,"./properties":95,"./string-sheet":96}],93:[function(_dereq_,module,exports){
'use strict';

var styfn = {};

styfn.applyFromJson = function( json ){
  var style = this;

  for( var i = 0; i < json.length; i++ ){
    var context = json[ i ];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys( props );

    style.selector( selector ); // apply selector

    for( var j = 0; j < names.length; j++ ){
      var name = names[j];
      var value = props[ name ];

      style.css( name, value ); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function( json ){
  var style = this;

  style.resetToDefault();
  style.applyFromJson( json );

  return style;
};

// get json from cy.style() api
styfn.json = function(){
  var json = [];

  for( var i = this.defaultLength; i < this.length; i++ ){
    var cxt = this[ i ];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];
      css[ prop.name ] = prop.strValue;
    }

    json.push( {
      selector: !selector ? 'core' : selector.toString(),
      style: css
    } );
  }

  return json;
};

module.exports = styfn;

},{}],94:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );
var math = _dereq_( '../math' );

var styfn = {};

// a caching layer for property parsing
styfn.parse = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  if( is.fn( value ) ){
    return self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  var flatKey = ( propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ) ? 'dontcare' : propIsFlat;
  var argHash = [ name, value, propIsBypass, flatKey ].join( '$' );
  var propCache = self.propCache = self.propCache || {};
  var ret;

  if( !(ret = propCache[ argHash ]) ){
    ret = propCache[ argHash ] = self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element
  if( propIsBypass || propIsFlat === 'mapping' ){
    // need a copy since props are mutated later in their lifecycles
    ret = util.copy( ret );

    if( ret ){
      ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn.parseImplWarn = function( name, value, propIsBypass, propIsFlat ){
  var prop = this.parseImpl( name, value, propIsBypass, propIsFlat );

  if( !prop && value != null ){
    util.error('The style property `%s: %s` is invalid', name, value);
  }

  return prop;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn.parseImpl = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[ name ];
  var passedValue = value;
  var types = self.types;

  if( !property ){ return null; } // return null on property of unknown name
  if( value === undefined || value === null ){ return null; } // can't assign null

  // the property may be an alias
  if( property.alias ){
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string( value );
  if( valueIsString ){ // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if( !type ){ return null; } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if( propIsBypass && (value === '' || value === null) ){
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if( is.fn( value ) ){
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data, mapData;
  if( !valueIsString || propIsFlat ){
    // then don't bother to do the expensive regex checks

  } else if( data = new RegExp( types.data.regex ).exec( value ) ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass

    var mapped = types.data;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };

  } else if( mapData = new RegExp( types.mapData.regex ).exec( value ) ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass
    if( type.multiple ){ return false; } // impossible to map to num

    var mapped = types.mapData;

    // we can map only if the type is a colour or a number
    if( !(type.color || type.number) ){ return false; }

    var valueMin = this.parse( name, mapData[4] ); // parse to validate
    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

    var valueMax = this.parse( name, mapData[5] ); // parse to validate
    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if( valueMin.value === valueMax.value ){
      return false; // can't make much of a mapper without a range

    } else if( type.color ){
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
        && c1[1] === c2[1] // green
        && c1[2] === c2[2] // blue
        && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (
            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
            &&
            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          )
        )
      ;

      if( same ){ return false; } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: mapped,
      field: mapData[1],
      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
      fieldMax: parseFloat( mapData[3] ),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if( type.multiple && propIsFlat !== 'multiple' ){
    var vals;

    if( valueIsString ){
      vals = value.split( /\s+/ );
    } else if( is.array( value ) ){
      vals = value;
    } else {
      vals = [ value ];
    }

    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var hasEnum = false;

    for( var i = 0; i < vals.length; i++ ){
      var p = self.parse( name, vals[i], propIsBypass, 'multiple' );

      hasEnum = hasEnum || is.string( p.value );

      valArr.push( p.value );
      pfValArr.push( p.pfValue != null ? p.pfValue : p.value );
      unitsArr.push( p.units );
    }

    if( type.validate && !type.validate( valArr, unitsArr ) ){
      return null;
    }

    if( type.singleEnum && hasEnum ){
      if( valArr.length === 1 && is.string( valArr[0] ) ){
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: valArr.join( ' ' ),
      bypass: propIsBypass,
      units: unitsArr
    };
  }

  // several types also allow enums
  var checkEnums = function(){
    for( var i = 0; i < type.enums.length; i++ ){
      var en = type.enums[ i ];

      if( en === value ){
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if( type.number ){
    var units;
    var implicitUnits = 'px'; // not set => px

    if( type.units ){ // use specified units if set
      units = type.units;
    }

    if( type.implicitUnits ){
      implicitUnits = type.implicitUnits;
    }

    if( !type.unitless ){
      if( valueIsString ){
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if( units ){ unitsRegex = units; } // only allow explicit units if so set
        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );

        if( match ){
          value = match[1];
          units = match[2] || implicitUnits;
        }

      } else if( !units || type.implicitUnits ){
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat( value );

    // if not a number and enums not allowed, then the value is invalid
    if( isNaN( value ) && type.enums === undefined ){
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if( isNaN( value ) && type.enums !== undefined ){
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if( type.integer && !is.integer( value ) ){
      return null;
    }

    // check value is within range
    if( ( type.min !== undefined && ( value < type.min || (type.strictMin && value === type.min) ) )
    ||  ( type.max !== undefined && ( value > type.max || (type.strictMax && value === type.max) ) )
    ){
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if( type.unitless || (units !== 'px' && units !== 'em') ){
      ret.pfValue = value;
    } else {
      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
    }

    // normalise value in ms
    if( units === 'ms' || units === 's' ){
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if( units === 'deg' || units === 'rad' ){
      ret.pfValue = units === 'rad' ? value : math.deg2rad( value );
    }

    // normalize value in %
    if( units === '%' ){
      ret.pfValue = value / 100;
    }

    return ret;

  } else if( type.propList ){

    var props = [];
    var propsStr = '' + value;

    if( propsStr === 'none' ){
      // leave empty

    } else { // go over each prop

      var propsSplit = propsStr.split( ',' );
      for( var i = 0; i < propsSplit.length; i++ ){
        var propName = propsSplit[ i ].trim();

        if( self.properties[ propName ] ){
          props.push( propName );
        }
      }

      if( props.length === 0 ){ return null; }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join( ', ' ),
      bypass: propIsBypass
    };

  } else if( type.color ){
    var tuple = util.color2tuple( value );

    if( !tuple ){ return null; }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: '' + value,
      bypass: propIsBypass,
      roundValue: true
    };

  } else if( type.regex || type.regexes ){

    // first check enums
    if( type.enums ){
      var enumProp = checkEnums();

      if( enumProp ){ return enumProp; }
    }

    var regexes = type.regexes ? type.regexes : [ type.regex ];

    for( var i = 0; i < regexes.length; i++ ){
      var regex = new RegExp( regexes[ i ] ); // make a regex from the type string
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };

      }
    }

    return null; // didn't match any

  } else if( type.string ){
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };

  } else if( type.enums ){ // check enums last because it's a combo type in others
    return checkEnums();

  } else {
    return null; // not a type we can handle
  }

};

module.exports = styfn;

},{"../is":82,"../math":84,"../util":99}],95:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var is = _dereq_( '../is' );

var styfn = {};

(function(){
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
  var mapData = function( prefix ){
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };
  var urlRegexes = [
    '^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$',
    '^(none)$',
    '^(.+)$'
  ];

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: [ 'parent', 'origin' ] },
    nodeSize: { number: true, min: 0, enums: [ 'label' ] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    sizeMaybePercent: { number: true, min: 0, allowPercent: true },
    paddingRelativeTo: { enums: [ 'width', 'height', 'average', 'min', 'max' ] },
    bgWH: { number: true, min: 0, allowPercent: true, enums: [ 'auto' ], multiple: true },
    bgPos: { number: true, allowPercent: true, multiple: true },
    bgRepeat: { enums: [ 'repeat', 'repeat-x', 'repeat-y', 'no-repeat' ], multiple: true },
    bgFit: { enums: [ 'none', 'contain', 'cover' ], multiple: true },
    bgCrossOrigin: { enums: [ 'anonymous', 'use-credentials' ], multiple: true },
    bgClip: { enums: [ 'none', 'node' ] },
    color: { color: true },
    bool: { enums: [ 'yes', 'no' ] },
    lineStyle: { enums: [ 'solid', 'dotted', 'dashed' ] },
    borderStyle: { enums: [ 'solid', 'dotted', 'dashed', 'double' ] },
    curveStyle: { enums: [ 'bezier', 'unbundled-bezier', 'haystack', 'segments' ] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontVariant: { enums: [ 'small-caps', 'normal' ] },
    fontStyle: { enums: [ 'italic', 'normal', 'oblique' ] },
    fontWeight: { enums: [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900 ] },
    textDecoration: { enums: [ 'none', 'underline', 'overline', 'line-through' ] },
    textTransform: { enums: [ 'none', 'uppercase', 'lowercase' ] },
    textWrap: { enums: [ 'none', 'wrap', 'ellipsis' ] },
    textBackgroundShape: { enums: [ 'rectangle', 'roundrectangle' ]},
    nodeShape: { enums: [ 'rectangle', 'roundrectangle', 'cutrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon' ] },
    compoundIncludeLabels: { enums: [ 'include', 'exclude' ] },
    arrowShape: { enums: [ 'tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none' ] },
    arrowFill: { enums: [ 'filled', 'hollow' ] },
    display: { enums: [ 'element', 'none' ] },
    visibility: { enums: [ 'hidden', 'visible' ] },
    zCompoundDepth: { enums: [ 'bottom', 'orphan', 'auto', 'top' ] },
    zIndexCompare: { enums: [ 'auto', 'manual' ] },
    valign: { enums: [ 'top', 'center', 'bottom' ] },
    halign: { enums: [ 'left', 'center', 'right' ] },
    text: { string: true },
    data: { mapping: true, regex: data( 'data' ) },
    layoutData: { mapping: true, regex: data( 'layoutData' ) },
    scratch: { mapping: true, regex: data( 'scratch' ) },
    mapData: { mapping: true, regex: mapData( 'mapData' ) },
    mapLayoutData: { mapping: true, regex: mapData( 'mapLayoutData' ) },
    mapScratch: { mapping: true, regex: mapData( 'mapScratch' ) },
    fn: { mapping: true, fn: true },
    url: { regexes: urlRegexes, singleRegexMatchValue: true },
    urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: [ 'none', 'autorotate' ] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    edgeDistances: { enums: ['intersection', 'node-position'] },
    edgeEndpoint: {
      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
      enums: [ 'inside-to-node', 'outside-to-node', 'outside-to-line' ], singleEnum: true,
      validate: function( valArr, unitsArr ){
        switch( valArr.length ){
          case 2: // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
          case 1: // can be enum, deg, or rad only
            return is.string( valArr[0] ) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
          default:
            return false;
        }
      }
    },
    easing: {
      regexes: [
        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
      ],
      enums: [
        'linear',
        'ease', 'ease-in', 'ease-out', 'ease-in-out',
        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
      ]
    }
  };

  var zOrderDiff = {
    zeroNonZero: function( val1, val2 ){
      if( val1 === 0 && val2 !== 0 ){
        return true;
      } else if( val1 !== 0 && val2 === 0 ){
        return true;
      } else {
        return false;
      }
    },
    anyDiff: function( val1, val2 ){
      return val1 !== val2;
    }
  };

  var zd = zOrderDiff;

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
    // main label
    { name: 'label', type: t.text },
    { name: 'text-rotation', type: t.textRotation },
    { name: 'text-margin-x', type: t.bidirectionalSize },
    { name: 'text-margin-y', type: t.bidirectionalSize },

    // source label
    { name: 'source-label', type: t.text },
    { name: 'source-text-rotation', type: t.textRotation },
    { name: 'source-text-margin-x', type: t.bidirectionalSize },
    { name: 'source-text-margin-y', type: t.bidirectionalSize },
    { name: 'source-text-offset', type: t.size },

    // target label
    { name: 'target-label', type: t.text },
    { name: 'target-text-rotation', type: t.textRotation },
    { name: 'target-text-margin-x', type: t.bidirectionalSize },
    { name: 'target-text-margin-y', type: t.bidirectionalSize },
    { name: 'target-text-offset', type: t.size },

    // common label style
    { name: 'text-valign', type: t.valign },
    { name: 'text-halign', type: t.halign },
    { name: 'color', type: t.color },
    { name: 'text-outline-color', type: t.color },
    { name: 'text-outline-width', type: t.size },
    { name: 'text-outline-opacity', type: t.zeroOneNumber },
    { name: 'text-opacity', type: t.zeroOneNumber },
    { name: 'text-background-color', type: t.color },
    { name: 'text-background-opacity', type: t.zeroOneNumber },
    { name: 'text-background-padding', type: t.size },
    { name: 'text-border-opacity', type: t.zeroOneNumber },
    { name: 'text-border-color', type: t.color },
    { name: 'text-border-width', type: t.size },
    { name: 'text-border-style', type: t.borderStyle },
    { name: 'text-background-shape', type: t.textBackgroundShape},
    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
    { name: 'text-transform', type: t.textTransform },
    { name: 'text-wrap', type: t.textWrap },
    { name: 'text-max-width', type: t.size },
    { name: 'text-events', type: t.bool },
    { name: 'font-family', type: t.fontFamily },
    { name: 'font-style', type: t.fontStyle },
    // { name: 'font-variant', type: t.fontVariant }, // not useful
    { name: 'font-weight', type: t.fontWeight },
    { name: 'font-size', type: t.size },
    { name: 'min-zoomed-font-size', type: t.size },

    // behaviour
    { name: 'events', type: t.bool },

    // visibility
    { name: 'display', type: t.display, triggersZOrder: zd.anyDiff },
    { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff },
    { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero },
    { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff },
    { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff },
    { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

    // overlays
    { name: 'overlay-padding', type: t.size },
    { name: 'overlay-color', type: t.color },
    { name: 'overlay-opacity', type: t.zeroOneNumber },

    // transition anis
    { name: 'transition-property', type: t.propList },
    { name: 'transition-duration', type: t.time },
    { name: 'transition-delay', type: t.time },
    { name: 'transition-timing-function', type: t.easing },

    // node body
    { name: 'height', type: t.nodeSize },
    { name: 'width', type: t.nodeSize },
    { name: 'shape', type: t.nodeShape },
    { name: 'shape-polygon-points', type: t.polygonPointList },
    { name: 'background-color', type: t.color },
    { name: 'background-opacity', type: t.zeroOneNumber },
    { name: 'background-blacken', type: t.nOneOneNumber },
    { name: 'padding', type: t.sizeMaybePercent },
    { name: 'padding-relative-to', type: t.paddingRelativeTo },

    // node border
    { name: 'border-color', type: t.color },
    { name: 'border-opacity', type: t.zeroOneNumber },
    { name: 'border-width', type: t.size },
    { name: 'border-style', type: t.borderStyle },

    // node background images
    { name: 'background-image', type: t.urls },
    { name: 'background-image-crossorigin', type: t.bgCrossOrigin },
    { name: 'background-image-opacity', type: t.zeroOneNumbers },
    { name: 'background-position-x', type: t.bgPos },
    { name: 'background-position-y', type: t.bgPos },
    { name: 'background-repeat', type: t.bgRepeat },
    { name: 'background-fit', type: t.bgFit },
    { name: 'background-clip', type: t.bgClip },
    { name: 'background-width', type: t.bgWH },
    { name: 'background-height', type: t.bgWH },

    // compound props
    { name: 'position', type: t.position },
    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },
    { name: 'min-width', type: t.size },
    { name: 'min-width-bias-left', type: t.sizeMaybePercent },
    { name: 'min-width-bias-right', type: t.sizeMaybePercent },
    { name: 'min-height', type: t.size },
    { name: 'min-height-bias-top', type: t.sizeMaybePercent },
    { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

    // edge line
    { name: 'line-style', type: t.lineStyle },
    { name: 'line-color', type: t.color },
    { name: 'curve-style', type: t.curveStyle },
    { name: 'haystack-radius', type: t.zeroOneNumber },
    { name: 'source-endpoint', type: t.edgeEndpoint },
    { name: 'target-endpoint', type: t.edgeEndpoint },
    { name: 'control-point-step-size', type: t.size },
    { name: 'control-point-distances', type: t.bidirectionalSizes },
    { name: 'control-point-weights', type: t.numbers },
    { name: 'segment-distances', type: t.bidirectionalSizes },
    { name: 'segment-weights', type: t.numbers },
    { name: 'edge-distances', type: t.edgeDistances },
    { name: 'arrow-scale', type: t.positiveNumber },
    { name: 'loop-direction', type: t.angle },
    { name: 'loop-sweep', type: t.angle },
    { name: 'source-distance-from-node', type: t.size },
    { name: 'target-distance-from-node', type: t.size },

    // these are just for the core
    { name: 'selection-box-color', type: t.color },
    { name: 'selection-box-opacity', type: t.zeroOneNumber },
    { name: 'selection-box-border-color', type: t.color },
    { name: 'selection-box-border-width', type: t.size },
    { name: 'active-bg-color', type: t.color },
    { name: 'active-bg-opacity', type: t.zeroOneNumber },
    { name: 'active-bg-size', type: t.size },
    { name: 'outside-texture-bg-color', type: t.color },
    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
  ];

  // define aliases
  var aliases = styfn.aliases = [
    { name: 'content', pointsTo: 'label' },
    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
    { name: 'control-point-weight', pointsTo: 'control-point-weights' },
    { name: 'edge-text-rotation', pointsTo: 'text-rotation' },
    { name: 'padding-left', pointsTo: 'padding' },
    { name: 'padding-right', pointsTo: 'padding' },
    { name: 'padding-top', pointsTo: 'padding' },
    { name: 'padding-bottom', pointsTo: 'padding' }
  ];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push( { name: 'pie-size', type: t.sizeMaybePercent } );
  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
    props.push( { name: 'pie-' + i + '-background-color', type: t.color } );
    props.push( { name: 'pie-' + i + '-background-size', type: t.percent } );
    props.push( { name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber } );
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = [ 'source', 'mid-source', 'target', 'mid-target' ];
  [
    { name: 'arrow-shape', type: t.arrowShape },
    { name: 'arrow-color', type: t.color },
    { name: 'arrow-fill', type: t.arrowFill }
  ].forEach( function( prop ){
    arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push( { name: name, type: type } );
    } );
  }, {} );

  // list of property names
  styfn.propertyNames = props.map( function( p ){ return p.name; } );

  // allow access of properties by name ( e.g. style.properties.height )
  for( var i = 0; i < props.length; i++ ){
    var prop = props[ i ];

    props[ prop.name ] = prop; // allow lookup by name
  }

  // map aliases
  for( var i = 0; i < aliases.length; i++ ){
    var alias = aliases[ i ];
    var pointsToProp = props[ alias.pointsTo ];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push( aliasProp );

    props[ alias.name ] = aliasProp; // allow lookup by name
  }
})();

styfn.getDefaultProperty = function( name ){
  return this.getDefaultProperties()[ name ];
};

styfn.getDefaultProperties = util.memoize( function(){
  var rawProps = util.extend( {
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    // 'font-variant': fontVariant,
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',

    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [
    { name: 'pie-{{i}}-background-color', value: 'black' },
    { name: 'pie-{{i}}-background-size', value: '0%' },
    { name: 'pie-{{i}}-background-opacity', value: 1 }
  ].reduce( function( css, prop ){
    for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
      var name = prop.name.replace( '{{i}}', i );
      var val = prop.value;

      css[ name ] = val;
    }

    return css;
  }, {} ), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'edge-distances': 'intersection',
    'curve-style': 'bezier',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-135deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node'
  }, [
    { name: 'arrow-shape', value: 'none' },
    { name: 'arrow-color', value: '#999' },
    { name: 'arrow-fill', value: 'filled' }
  ].reduce( function( css, prop ){
    styfn.arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var val = prop.value;

      css[ name ] = val;
    } );

    return css;
  }, {} ) );

  var parsedProps = {};

  for( var i = 0; i < this.properties.length; i++ ){
    var prop = this.properties[i];

    if( prop.pointsTo ){ continue; }

    var name = prop.name;
    var val = rawProps[ name ];
    var parsedProp = this.parse( name, val );

    parsedProps[ name ] = parsedProp;
  }

  return parsedProps;
} );

styfn.addDefaultStylesheet = function(){
  this
    .selector( '$node > node' ) // compound (parent) node properties
      .css( {
        'shape': 'rectangle',
        'padding': 10,
        'background-color': '#eee',
        'border-color': '#ccc',
        'border-width': 1
      } )
    .selector( 'edge' ) // just edge properties
      .css( {
        'width': 3,
        'curve-style': 'haystack'
      } )
    .selector( ':selected' )
      .css( {
        'background-color': '#0169D9',
        'line-color': '#0169D9',
        'source-arrow-color': '#0169D9',
        'target-arrow-color': '#0169D9',
        'mid-source-arrow-color': '#0169D9',
        'mid-target-arrow-color': '#0169D9'
      } )
    .selector( 'node:parent:selected' )
      .css( {
        'background-color': '#CCE1F9',
        'border-color': '#aec8e5'
      } )
    .selector( ':active' )
      .css( {
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      } )
    .selector( 'core' ) // just core properties
      .css( {
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125
      } )
  ;

  this.defaultLength = this.length;
};

module.exports = styfn;

},{"../is":82,"../util":99}],96:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_( '../util' );
var Selector = _dereq_( '../selector' );

var styfn = {};

styfn.applyFromString = function( string ){
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;

  // remove comments from the style string
  remaining = remaining.replace( /[/][*](\s|.)+?[*][/]/g, '' );

  function removeSelAndBlockFromRemaining(){
    // remove the parsed selector and block from the remaining text to parse
    if( remaining.length > selAndBlockStr.length ){
      remaining = remaining.substr( selAndBlockStr.length );
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem(){
    // remove the parsed property and value from the remaining block text to parse
    if( blockRem.length > propAndValStr.length ){
      blockRem = blockRem.substr( propAndValStr.length );
    } else {
      blockRem = '';
    }
  }

  while( true ){
    var nothingLeftToParse = remaining.match( /^\s*$/ );
    if( nothingLeftToParse ){ break; }

    var selAndBlock = remaining.match( /^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/ );

    if( !selAndBlock ){
      util.error( 'Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining );
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if( selectorStr !== 'core' ){
      var selector = new Selector( selectorStr );
      if( selector._private.invalid ){
        util.error( 'Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr );

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while( true ){
      var nothingLeftToParse = blockRem.match( /^\s*$/ );
      if( nothingLeftToParse ){ break; }

      var propAndVal = blockRem.match( /^\s*(.+?)\s*:\s*(.+?)\s*;/ );

      if( !propAndVal ){
        util.error( 'Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr );
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[ propStr ];
      if( !prop ){
        util.error( 'Skipping property: Invalid property name in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse( propStr, valStr );

      if( !parsedProp ){
        util.error( 'Skipping property: Invalid property definition in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push( {
        name: propStr,
        val: valStr
      } );
      removePropAndValFromRem();
    }

    if( invalidBlock ){
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector( selectorStr );
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      style.css( prop.name, prop.val );
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function( string ){
  var style = this;

  style.resetToDefault();
  style.applyFromString( string );

  return style;
};

module.exports = styfn;

},{"../selector":86,"../util":99}],97:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( './is' );
var util = _dereq_( './util' );
var Style = _dereq_( './style' );

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function(){
  if( !(this instanceof Stylesheet) ){
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function(){
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function( selector ){
  var i = this.length++;

  this[ i ] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function( name, value ){
  var i = this.length - 1;

  if( is.string( name ) ){
    this[ i ].properties.push( {
      name: name,
      value: value
    } );
  } else if( is.plainObject( name ) ){
    var map = name;

    for( var j = 0; j < Style.properties.length; j++ ){
      var prop = Style.properties[ j ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){ // also try camel case name
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        var name = prop.name;
        var value = mapVal;

        this[ i ].properties.push( {
          name: name,
          value: value
        } );
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function( cy ){
  var style = new Style( cy );

  for( var i = 0; i < this.length; i++ ){
    var context = this[ i ];
    var selector = context.selector;
    var props = context.properties;

    style.selector( selector ); // apply selector

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];

      style.css( prop.name, prop.value ); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

},{"./is":82,"./style":92,"./util":99}],98:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function( hex ){
    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== '#' ){ return; }

    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;

    if( shortHex ){
      r = parseInt( hex[1] + hex[1], base );
      g = parseInt( hex[2] + hex[2], base );
      b = parseInt( hex[3] + hex[3], base );
    } else {
      r = parseInt( hex[1] + hex[2], base );
      g = parseInt( hex[3] + hex[4], base );
      b = parseInt( hex[5] + hex[6], base );
    }

    return [ r, g, b ];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function( hsl ){
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb( p, q, t ){
      if( t < 0 ) t += 1;
      if( t > 1 ) t -= 1;
      if( t < 1 / 6 ) return p + (q - p) * 6 * t;
      if( t < 1 / 2 ) return q;
      if( t < 2 / 3 ) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    var m = new RegExp( '^' + this.regex.hsla + '$' ).exec( hsl );
    if( m ){

      // get hue
      h = parseInt( m[1] );
      if( h < 0 ){
        h = ( 360 - (-1 * h % 360) ) % 360;
      } else if( h > 360 ){
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat( m[2] );
      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
      s = s / 100; // normalise on [0, 1]

      l = parseFloat( m[3] );
      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
      l = l / 100; // normalise on [0, 1]

      a = m[4];
      if( a !== undefined ){
        a = parseFloat( a );

        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if( s === 0 ){
        r = g = b = Math.round( l * 255 ); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round( 255 * hue2rgb( p, q, h + 1 / 3 ) );
        g = Math.round( 255 * hue2rgb( p, q, h ) );
        b = Math.round( 255 * hue2rgb( p, q, h - 1 / 3 ) );
      }

      ret = [ r, g, b, a ];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function( rgb ){
    var ret;

    var m = new RegExp( '^' + this.regex.rgba + '$' ).exec( rgb );
    if( m ){
      ret = [];

      var isPct = [];
      for( var i = 1; i <= 3; i++ ){
        var channel = m[ i ];

        if( channel[ channel.length - 1 ] === '%' ){
          isPct[ i ] = true;
        }
        channel = parseFloat( channel );

        if( isPct[ i ] ){
          channel = channel / 100 * 255; // normalise to [0, 255]
        }

        if( channel < 0 || channel > 255 ){ return; } // invalid channel value

        ret.push( Math.floor( channel ) );
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

      var alpha = m[4];
      if( alpha !== undefined ){
        alpha = parseFloat( alpha );

        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

        ret.push( alpha );
      }
    }

    return ret;
  },

  colorname2tuple: function( color ){
    return this.colors[ color.toLowerCase() ];
  },

  color2tuple: function( color ){
    return ( is.array( color ) ? color : null )
      || this.colorname2tuple( color )
      || this.hex2tuple( color )
      || this.rgb2tuple( color )
      || this.hsl2tuple( color );
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [ 240, 248, 255 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [0, 0, 0],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 135 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    cyan: [0, 255, 255 ],
    darkblue: [0, 0, 139 ],
    darkcyan: [0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [0, 100, 0],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    grey: [ 128, 128, 128 ],
    green: [0, 128, 0],
    greenyellow: [ 173, 255, 47 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [0, 255, 0],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    magenta: [ 255, 0, 255 ],
    maroon: [ 128, 0, 0],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0],
    orangered: [ 255, 69, 0],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    red: [ 255, 0, 0],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 192 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0],
    yellowgreen: [ 154, 205, 50 ]
  }
};

},{"../is":82}],99:[function(_dereq_,module,exports){
'use strict';

/*global console */

var is = _dereq_( '../is' );
var math = _dereq_( '../math' );

var util = {

  trueify: function(){ return true; },

  falsify: function(){ return false; },

  zeroify: function(){ return 0; },

  noop: function(){},

  error: function( msg ){
    /* eslint-disable */
    if( console.error ){
      console.error.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    } else {
      console.log.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    }
    /* eslint-enable */
  },

  clone: function( obj ){
    return this.extend( {}, obj );
  },

  // gets a shallow copy of the argument
  copy: function( obj ){
    if( obj == null ){
      return obj;
    } if( is.array( obj ) ){
      return obj.slice();
    } else if( is.plainObject( obj ) ){
      return this.clone( obj );
    } else {
      return obj;
    }
  },

  uuid: function(
      a,b                // placeholders
  ){
      for(               // loop :)
          b=a='';        // b - result , a - numeric variable
          a++<36;        //
          b+=a*51&52  // if "a" is not 9 or 14 or 19 or 24
                      ?  //  return a random number or 4
             (
               a^15      // if "a" is not 15
                  ?      // genetate a random number from 0 to 15
               8^Math.random()*
               (a^20?16:4)  // unless "a" is 20, in which case a random number from 8 to 11
                  :
               4            //  otherwise 4
               ).toString(16)
                      :
             '-'            //  in other cases (if "a" is 9,14,19,24) insert "-"
          );
      return b;
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind( math );

util._staticEmptyObject = {};

util.staticEmptyObject = function(){
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign : function( tgt ){
  var args = arguments;

  for( var i = 1; i < args.length; i++ ){
    var obj = args[ i ];

    if( !obj ){ continue; }

    var keys = Object.keys( obj );

    for( var j = 0; j < keys.length; j++ ){
      var k = keys[j];

      tgt[ k ] = obj[ k ];
    }
  }

  return tgt;
};

util.default = function( val, def ){
  if( val === undefined ){
    return def;
  } else {
    return val;
  }
};

util.removeFromArray = function( arr, ele, manyCopies ){
  for( var i = arr.length; i >= 0; i-- ){
    if( arr[i] === ele ){
      arr.splice( i, 1 );

      if( !manyCopies ){ break; }
    }
  }
};

util.clearArray = function( arr ){
  arr.splice( 0, arr.length );
};

util.push = function( arr ){
  var args = Array.prototype.slice.call( arguments, 1 );
  Array.prototype.push.apply( arr, args );
};

util.getPrefixedProperty = function( obj, propName, prefix ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[ propName ];
};

util.setPrefixedProperty = function( obj, propName, prefix, value ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[ propName ] = value;
};

util.getIndexedStyle = function( node, property, subproperty, index ){
  var pstyle = node.pstyle( property )[subproperty][index];
  return pstyle != null ? pstyle : node.cy().style().getDefaultProperty( property )[subproperty][0];
};

[
  _dereq_( './colors' ),
  _dereq_( './maps' ),
  { memoize: _dereq_( './memoize' ) },
  _dereq_( './regex' ),
  _dereq_( './strings' ),
  _dereq_( './timing' ),
  _dereq_( './sort' )
].forEach( function( req ){
  util.extend( util, req );
} );

module.exports = util;

},{"../is":82,"../math":84,"./colors":98,"./maps":100,"./memoize":101,"./regex":102,"./sort":103,"./strings":104,"./timing":105}],100:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_( '../is' );

module.exports = {
  // has anything been set in the map
  mapEmpty: function( map ){
    var empty = true;

    if( map != null ){
      return Object.keys( map ).length === 0;
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function( options ){
    var array = this.getMap( options );

    if( array == null ){ // if empty, put initial array
      this.setMap( this.extend( {}, options, {
        value: [ options.value ]
      } ) );
    } else {
      array.push( options.value );
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function( options ){
    var obj = options.map;
    var key;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to set map with object key' );
      }

      if( i < keys.length - 1 ){

        // extend the map if necessary
        if( obj[ key ] == null ){
          obj[ key ] = {};
        }

        obj = obj[ key ];
      } else {
        // set the value
        obj[ key ] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to get map with object key' );
      }

      obj = obj[ key ];

      if( obj == null ){
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to delete map with object key' );
      }

      var lastKey = i === options.keys.length - 1;
      if( lastKey ){

        if( keepChildren ){ // then only delete child fields not in keepChildren
          var children = Object.keys( obj );

          for( var j = 0; j < children.length; j++ ){
            var child = children[j];

            if( !keepChildren[ child ] ){
              obj[ child ] = undefined;
            }
          }
        } else {
          obj[ key ] = undefined;
        }

      } else {
        obj = obj[ key ];
      }
    }
  }
};

},{"../is":82}],101:[function(_dereq_,module,exports){
'use strict';

module.exports = function memoize( fn, keyFn ){
  if( !keyFn ){
    keyFn = function(){
      if( arguments.length === 1 ){
        return arguments[0];
      } else if( arguments.length === 0 ){
        return 'undefined';
      }

      var args = [];

      for( var i = 0; i < arguments.length; i++ ){
        args.push( arguments[ i ] );
      }

      return args.join( '$' );
    };
  }

  var memoizedFn = function(){
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply( self, args );
    var cache = memoizedFn.cache;

    if( !(ret = cache[ k ]) ){
      ret = cache[ k ] = fn.apply( self, args );
    }

    return ret;
  };

  memoizedFn.cache = {};

  return memoizedFn;
};

},{}],102:[function(_dereq_,module,exports){
'use strict';

var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

},{}],103:[function(_dereq_,module,exports){
function ascending( a, b ){
  if( a < b ){
    return -1;
  } else if( a > b ){
    return 1;
  } else {
    return 0;
  }
}

function descending( a, b ){
  return -1 * ascending( a, b );
}

module.exports = {
  sort: {
    ascending: ascending,
    descending: descending
  }
};

},{}],104:[function(_dereq_,module,exports){
'use strict';

var memoize = _dereq_( './memoize' );
var is = _dereq_( '../is' );

module.exports = {

  camel2dash: memoize( function( str ){
    return str.replace( /([A-Z])/g, function( v ){
      return '-' + v.toLowerCase();
    } );
  } ),

  dash2camel: memoize( function( str ){
    return str.replace( /(-\w)/g, function( v ){
      return v[1].toUpperCase();
    } );
  } ),

  prependCamel: memoize( function( prefix, str ){
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function( prefix, str ){
    return prefix + '$' + str;
  } ),

  capitalize: function( str ){
    if( is.emptyString( str ) ){
      return str;
    }

    return str.charAt( 0 ).toUpperCase() + str.substring( 1 );
  }

};

},{"../is":82,"./memoize":101}],105:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_( '../window' );
var is = _dereq_( '../is' );
var performance = window ? window.performance : null;

var util = {};

var raf = !window ? function( fn ){
  if( fn ){
    setTimeout( function(){
      fn( pnow() );
    }, 1000 / 60 );
  }
} : (function(){
  if( window.requestAnimationFrame ){
    return function( fn ){ window.requestAnimationFrame( fn ); };
  } else if( window.mozRequestAnimationFrame ){
    return function( fn ){ window.mozRequestAnimationFrame( fn ); };
  } else if( window.webkitRequestAnimationFrame ){
    return function( fn ){ window.webkitRequestAnimationFrame( fn ); };
  } else if( window.msRequestAnimationFrame ){
    return function( fn ){ window.msRequestAnimationFrame( fn ); };
  }
})();

util.requestAnimationFrame = function( fn ){
  raf( fn );
};

var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };

util.performanceNow = pnow;

// ported lodash throttle function
util.throttle = function( func, wait, options ){
  var leading = true,
      trailing = true;

  if( options === false ){
    leading = false;
  } else if( is.plainObject( options ) ){
    leading = 'leading' in options ? options.leading : leading;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  options = options || {};
  options.leading = leading;
  options.maxWait = wait;
  options.trailing = trailing;

  return util.debounce( func, wait, options );
};

util.now = function(){
  return Date.now();
};

util.debounce = function( func, wait, options ){ // ported lodash debounce function
  var util = this;
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if( !is.fn( func ) ){
    return;
  }
  wait = Math.max( 0, wait ) || 0;
  if( options === true ){
    var leading = true;
    trailing = false;
  } else if( is.plainObject( options ) ){
    leading = options.leading;
    maxWait = 'maxWait' in options && (Math.max( wait, options.maxWait ) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function(){
    var remaining = wait - (util.now() - stamp);
    if( remaining <= 0 ){
      if( maxTimeoutId ){
        clearTimeout( maxTimeoutId );
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if( isCalled ){
        lastCalled = util.now();
        result = func.apply( thisArg, args );
        if( !timeoutId && !maxTimeoutId ){
          args = thisArg = null;
        }
      }
    } else {
      timeoutId = setTimeout( delayed, remaining );
    }
  };

  var maxDelayed = function(){
    if( timeoutId ){
      clearTimeout( timeoutId );
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if( trailing || (maxWait !== wait) ){
      lastCalled = util.now();
      result = func.apply( thisArg, args );
      if( !timeoutId && !maxTimeoutId ){
        args = thisArg = null;
      }
    }
  };

  return function(){
    args = arguments;
    stamp = util.now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if( maxWait === false ){
      var leadingCall = leading && !timeoutId;
    } else {
      if( !maxTimeoutId && !leading ){
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0;

      if( isCalled ){
        if( maxTimeoutId ){
          maxTimeoutId = clearTimeout( maxTimeoutId );
        }
        lastCalled = stamp;
        result = func.apply( thisArg, args );
      }
      else if( !maxTimeoutId ){
        maxTimeoutId = setTimeout( maxDelayed, remaining );
      }
    }
    if( isCalled && timeoutId ){
      timeoutId = clearTimeout( timeoutId );
    }
    else if( !timeoutId && wait !== maxWait ){
      timeoutId = setTimeout( delayed, wait );
    }
    if( leadingCall ){
      isCalled = true;
      result = func.apply( thisArg, args );
    }
    if( isCalled && !timeoutId && !maxTimeoutId ){
      args = thisArg = null;
    }
    return result;
  };
};

module.exports = util;

},{"../is":82,"../window":107}],106:[function(_dereq_,module,exports){
module.exports = "2.7.14";

},{}],107:[function(_dereq_,module,exports){
module.exports = ( typeof window === 'undefined' ? null : window ); // eslint-disable-line no-undef

},{}],108:[function(_dereq_,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = baseKeysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function mergeDefaults(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, mergeDefaults);
  return apply(mergeWith, undefined, args);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with seven arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = defaultsDeep;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],109:[function(_dereq_,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],110:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],111:[function(_dereq_,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sbgnmlToCytoscape = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],2:[function(_dereq_,module,exports){

},{}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';

var buffer = _dereq_('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":4}],4:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":7}],5:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":9}],6:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],10:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],11:[function(_dereq_,module,exports){
(function (root, factory){
  'use strict';

  /*istanbul ignore next:cant test*/
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else {
    // Browser globals
    root.objectPath = factory();
  }
})(this, function(){
  'use strict';

  var toStr = Object.prototype.toString;
  function hasOwnProperty(obj, prop) {
    if(obj == null) {
      return false
    }
    //to handle objects with null prototypes (too edge case?)
    return Object.prototype.hasOwnProperty.call(obj, prop)
  }

  function isEmpty(value){
    if (!value) {
      return true;
    }
    if (isArray(value) && value.length === 0) {
        return true;
    } else if (typeof value !== 'string') {
        for (var i in value) {
            if (hasOwnProperty(value, i)) {
                return false;
            }
        }
        return true;
    }
    return false;
  }

  function toString(type){
    return toStr.call(type);
  }

  function isObject(obj){
    return typeof obj === 'object' && toString(obj) === "[object Object]";
  }

  var isArray = Array.isArray || function(obj){
    /*istanbul ignore next:cant test*/
    return toStr.call(obj) === '[object Array]';
  }

  function isBoolean(obj){
    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';
  }

  function getKey(key){
    var intKey = parseInt(key);
    if (intKey.toString() === key) {
      return intKey;
    }
    return key;
  }

  function factory(options) {
    options = options || {}

    var objectPath = function(obj) {
      return Object.keys(objectPath).reduce(function(proxy, prop) {
        if(prop === 'create') {
          return proxy;
        }

        /*istanbul ignore else*/
        if (typeof objectPath[prop] === 'function') {
          proxy[prop] = objectPath[prop].bind(objectPath, obj);
        }

        return proxy;
      }, {});
    };

    function hasShallowProperty(obj, prop) {
      return (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop))
    }

    function getShallowProperty(obj, prop) {
      if (hasShallowProperty(obj, prop)) {
        return obj[prop];
      }
    }

    function set(obj, path, value, doNotReplace){
      if (typeof path === 'number') {
        path = [path];
      }
      if (!path || path.length === 0) {
        return obj;
      }
      if (typeof path === 'string') {
        return set(obj, path.split('.').map(getKey), value, doNotReplace);
      }
      var currentPath = path[0];
      var currentValue = getShallowProperty(obj, currentPath);
      if (path.length === 1) {
        if (currentValue === void 0 || !doNotReplace) {
          obj[currentPath] = value;
        }
        return currentValue;
      }

      if (currentValue === void 0) {
        //check if we assume an array
        if(typeof path[1] === 'number') {
          obj[currentPath] = [];
        } else {
          obj[currentPath] = {};
        }
      }

      return set(obj[currentPath], path.slice(1), value, doNotReplace);
    }

    objectPath.has = function (obj, path) {
      if (typeof path === 'number') {
        path = [path];
      } else if (typeof path === 'string') {
        path = path.split('.');
      }

      if (!path || path.length === 0) {
        return !!obj;
      }

      for (var i = 0; i < path.length; i++) {
        var j = getKey(path[i]);

        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||
          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {
          obj = obj[j];
        } else {
          return false;
        }
      }

      return true;
    };

    objectPath.ensureExists = function (obj, path, value){
      return set(obj, path, value, true);
    };

    objectPath.set = function (obj, path, value, doNotReplace){
      return set(obj, path, value, doNotReplace);
    };

    objectPath.insert = function (obj, path, value, at){
      var arr = objectPath.get(obj, path);
      at = ~~at;
      if (!isArray(arr)) {
        arr = [];
        objectPath.set(obj, path, arr);
      }
      arr.splice(at, 0, value);
    };

    objectPath.empty = function(obj, path) {
      if (isEmpty(path)) {
        return void 0;
      }
      if (obj == null) {
        return void 0;
      }

      var value, i;
      if (!(value = objectPath.get(obj, path))) {
        return void 0;
      }

      if (typeof value === 'string') {
        return objectPath.set(obj, path, '');
      } else if (isBoolean(value)) {
        return objectPath.set(obj, path, false);
      } else if (typeof value === 'number') {
        return objectPath.set(obj, path, 0);
      } else if (isArray(value)) {
        value.length = 0;
      } else if (isObject(value)) {
        for (i in value) {
          if (hasShallowProperty(value, i)) {
            delete value[i];
          }
        }
      } else {
        return objectPath.set(obj, path, null);
      }
    };

    objectPath.push = function (obj, path /*, values */){
      var arr = objectPath.get(obj, path);
      if (!isArray(arr)) {
        arr = [];
        objectPath.set(obj, path, arr);
      }

      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };

    objectPath.coalesce = function (obj, paths, defaultValue) {
      var value;

      for (var i = 0, len = paths.length; i < len; i++) {
        if ((value = objectPath.get(obj, paths[i])) !== void 0) {
          return value;
        }
      }

      return defaultValue;
    };

    objectPath.get = function (obj, path, defaultValue){
      if (typeof path === 'number') {
        path = [path];
      }
      if (!path || path.length === 0) {
        return obj;
      }
      if (obj == null) {
        return defaultValue;
      }
      if (typeof path === 'string') {
        return objectPath.get(obj, path.split('.'), defaultValue);
      }

      var currentPath = getKey(path[0]);
      var nextObj = getShallowProperty(obj, currentPath)
      if (nextObj === void 0) {
        return defaultValue;
      }

      if (path.length === 1) {
        return nextObj;
      }

      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
    };

    objectPath.del = function del(obj, path) {
      if (typeof path === 'number') {
        path = [path];
      }

      if (obj == null) {
        return obj;
      }

      if (isEmpty(path)) {
        return obj;
      }
      if(typeof path === 'string') {
        return objectPath.del(obj, path.split('.'));
      }

      var currentPath = getKey(path[0]);
      if (!hasShallowProperty(obj, currentPath)) {
        return obj;
      }

      if(path.length === 1) {
        if (isArray(obj)) {
          obj.splice(currentPath, 1);
        } else {
          delete obj[currentPath];
        }
      } else {
        return objectPath.del(obj[currentPath], path.slice(1));
      }

      return obj;
    }

    return objectPath;
  }

  var mod = factory();
  mod.create = factory;
  mod.withInheritedProps = factory({includeInheritedProps: true})
  return mod;
});

},{}],12:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,_dereq_('_process'))

},{"_process":13}],13:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],14:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":15}],15:[function(_dereq_,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":17,"./_stream_writable":19,"core-util-is":5,"inherits":8,"process-nextick-args":12}],16:[function(_dereq_,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":18,"core-util-is":5,"inherits":8}],17:[function(_dereq_,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = _dereq_('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = _dereq_('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = _dereq_('buffer').Buffer;
/*<replacement>*/
var bufferShim = _dereq_('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'))

},{"./_stream_duplex":15,"./internal/streams/BufferList":20,"_process":13,"buffer":4,"buffer-shims":3,"core-util-is":5,"events":6,"inherits":8,"isarray":10,"process-nextick-args":12,"string_decoder/":27,"util":2}],18:[function(_dereq_,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":15,"core-util-is":5,"inherits":8}],19:[function(_dereq_,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = _dereq_('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = _dereq_('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = _dereq_('buffer').Buffer;
/*<replacement>*/
var bufferShim = _dereq_('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,_dereq_('_process'))

},{"./_stream_duplex":15,"_process":13,"buffer":4,"buffer-shims":3,"core-util-is":5,"events":6,"inherits":8,"process-nextick-args":12,"util-deprecate":28}],20:[function(_dereq_,module,exports){
'use strict';

var Buffer = _dereq_('buffer').Buffer;
/*<replacement>*/
var bufferShim = _dereq_('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":4,"buffer-shims":3}],21:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":16}],22:[function(_dereq_,module,exports){
(function (process){
var Stream = (function (){
  try {
    return _dereq_('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,_dereq_('_process'))

},{"./lib/_stream_duplex.js":15,"./lib/_stream_passthrough.js":16,"./lib/_stream_readable.js":17,"./lib/_stream_transform.js":18,"./lib/_stream_writable.js":19,"_process":13}],23:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":18}],24:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":19}],25:[function(_dereq_,module,exports){
(function (Buffer){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = _dereq_('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = _dereq_('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // character classes and tokens
  var whitespace = '\r\n\t '

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.

  // (Letter | "_" | ":")
  var quote = '\'"'
  var attribEnd = whitespace + '>'
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // turn all the string character sets into character class objects.
  whitespace = charClass(whitespace)

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  quote = charClass(quote)
  attribEnd = charClass(attribEnd)

  function charClass (str) {
    return str.split('').reduce(function (s, c) {
      s[c] = true
      return s
    }, {})
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function is (charclass, c) {
    return charclass[c]
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  function not (charclass, c) {
    return !is(charclass, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (not(whitespace, c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (is(whitespace, c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (is(quote, c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (is(quote, c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (is(quote, c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (is(whitespace, c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && is(whitespace, c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (not(whitespace, c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (is(whitespace, c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (is(whitespace, c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (is(whitespace, c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (is(whitespace, c)) {
            continue
          } else if (is(quote, c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (is(whitespace, c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (not(attribEnd, c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (is(whitespace, c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (not(whitespace, c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (is(whitespace, c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this,_dereq_("buffer").Buffer)

},{"buffer":4,"stream":26,"string_decoder":27}],26:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = _dereq_('events').EventEmitter;
var inherits = _dereq_('inherits');

inherits(Stream, EE);
Stream.Readable = _dereq_('readable-stream/readable.js');
Stream.Writable = _dereq_('readable-stream/writable.js');
Stream.Duplex = _dereq_('readable-stream/duplex.js');
Stream.Transform = _dereq_('readable-stream/transform.js');
Stream.PassThrough = _dereq_('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":8,"readable-stream/duplex.js":14,"readable-stream/passthrough.js":21,"readable-stream/readable.js":22,"readable-stream/transform.js":23,"readable-stream/writable.js":24}],27:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = _dereq_('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":4}],28:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(_dereq_,module,exports){
(function (process){
/*jslint node:true */

module.exports = {
    sanitize: function (text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
    },
    copyOptions: function (options) {
        var key, copy = {};
        for (key in options) {
            if (options.hasOwnProperty(key)) {
                copy[key] = options[key];
            }
        }
        return copy;
    },
    ensureFlagExists: function (item, options) {
        if (!(item in options) || typeof options[item] !== 'boolean') {
            options[item] = false;
        }
    },
    ensureSpacesExists: function (options) {
        if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {
            options.spaces = 0;
        }
    },
    ensureKeyExists: function (key, options) {
        if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
            options[key + 'Key'] = options.compact ? '_' + key : key;
        }
    },
    getCommandLineHelp: function (command, requiredArgs, optionalArgs) {
        var reqArgs = requiredArgs.reduce(function (res, arg) {return res + ' <' + arg.arg + '>';}, '');
        var output = 'Usage: ' + command + reqArgs + ' [options]' + '\n';
        requiredArgs.forEach(function (argument) {
            output += '  <' + argument.arg + '>' + Array(20 - argument.arg.length).join(' ') + argument.desc + '\n';
        });
        output += '\nOptions:' + '\n';
        optionalArgs.forEach(function (argument) {
            output += '  --' + argument.arg + Array(20 - argument.arg.length).join(' ') + argument.desc + '\n';
        });
        return output;
    },
    mapCommandLineArgs: function (requiredArgs, optionalArgs) {
        var options = {}, r, o, a = 2;
        for (r = 0; r < requiredArgs.length; r += 1) {
            if (a < process.argv.length && process.argv[a].substr(0, 1) !== '-' && process.argv[a] !== 'JASMINE_CONFIG_PATH=./jasmine.json') {
                options[requiredArgs[r].option] = process.argv[a++];
            } else {
                break;
            }
        }
        for (; a < process.argv.length; a += 1) {
            for (o = 0; o < optionalArgs.length; o += 1) {
                if (optionalArgs[o].alias === process.argv[a].slice(1) || optionalArgs[o].arg === process.argv[a].slice(2)) {
                    break;
                }
            }
            if (o < optionalArgs.length) {
                switch (optionalArgs[o].type) {
                    case 'file': case 'string': case 'number':
                        if (a + 1 < process.argv.length) {
                            a += 1;
                            options[optionalArgs[o].option] = (optionalArgs[o].type === 'number' ? Number(process.argv[a]) : process.argv[a]);
                        }
                        break;
                    case 'flag':
                        options[optionalArgs[o].option] = true; break;
                }
            }
        }
        return options;
    }
};
}).call(this,_dereq_('_process'))

},{"_process":13}],30:[function(_dereq_,module,exports){
/*jslint node:true */

var xml2js = _dereq_('./xml2js');
var xml2json = _dereq_('./xml2json');
var js2xml = _dereq_('./js2xml');
var json2xml = _dereq_('./json2xml');

module.exports = {
    xml2js: xml2js,
    xml2json: xml2json,
    js2xml: js2xml,
    json2xml: json2xml
};
},{"./js2xml":31,"./json2xml":32,"./xml2js":33,"./xml2json":34}],31:[function(_dereq_,module,exports){
var common = _dereq_('./common');

function validateOptions (userOptions) {
    var options = common.copyOptions(userOptions);
    common.ensureFlagExists('ignoreDeclaration', options);
    common.ensureFlagExists('ignoreAttributes', options);
    common.ensureFlagExists('ignoreText', options);
    common.ensureFlagExists('ignoreComment', options);
    common.ensureFlagExists('ignoreCdata', options);
    common.ensureFlagExists('compact', options);
    common.ensureFlagExists('fullTagEmptyElement', options);
    common.ensureSpacesExists(options);
    if (typeof options.spaces === 'number') {
        options.spaces = Array(options.spaces + 1).join(' ');
    }
    common.ensureKeyExists('declaration', options);
    common.ensureKeyExists('attributes', options);
    common.ensureKeyExists('text', options);
    common.ensureKeyExists('comment', options);
    common.ensureKeyExists('cdata', options);
    common.ensureKeyExists('type', options);
    common.ensureKeyExists('name', options);
    common.ensureKeyExists('elements', options);
    return options;
}

function writeIndentation (options, depth, firstLine) {
    return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes (attributes) {
    var key, result = '';
    for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
            result += ' ' + key + '="' + attributes[key] + '"';
        }
    }
    return result;
}

function writeDeclaration (declaration, options) {
    return '<?xml' + writeAttributes(declaration[options.attributesKey]) + '?>';
}

function writeComment (element, options) {
    return options.ignoreComment ? '' : '<!--' + element[options.commentKey] + '-->';
}

function writeCdata (element, options) {
    return options.ignoreCdata ? '' : '<![CDATA[' + element[options.cdataKey] + ']]>';
}

function writeText (element, options) {
    return options.ignoreText ? '' : element[options.textKey].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

function writeElement (element, options, depth) {
    var xml = '';
    xml += '<' + element.name;
    if (element[options.attributesKey]) {
        xml += writeAttributes(element[options.attributesKey]);
    }
    if (options.fullTagEmptyElement || (element[options.elementsKey] && element[options.elementsKey].length) || (element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve')) {
        xml += '>';
        if (element[options.elementsKey] && element[options.elementsKey].length) {
            xml += writeElements(element[options.elementsKey], options, depth + 1);
        }
        xml += (options.spaces && element[options.elementsKey] && element[options.elementsKey].length && (element[options.elementsKey].length > 1 || element[options.elementsKey][0].type !== 'text') ? '\n' + Array(depth + 1).join(options.spaces) : '');
        xml += '</' + element.name + '>';
    } else {
        xml += '/>';
    }
    return xml;
}

function writeElements (elements, options, depth, firstLine) {
    var indent = writeIndentation(options, depth, firstLine);
    return elements.reduce(function (xml, element) {
        switch (element.type) {
            case 'element': return xml + indent + writeElement(element, options, depth);
            case 'comment': return xml + indent + writeComment(element, options);
            case 'cdata': return xml + indent + writeCdata(element, options);
            case 'text': return xml + writeText(element, options);
        }
    }, '');
}

function hasContent (element, options, skipText) {
    var key;
    for (key in element) {
        if (element.hasOwnProperty(key)) {
            switch (key) {
                case options.textKey:
                    if (!skipText) {
                        return true;
                    }
                    break; // skip to next key
                case options.parentKey:
                case options.attributesKey:
                    break; // skip to next key
                case options.cdataKey:
                case options.commentKey:
                case options.declarationKey:
                    return true;
                default:
                    return true;
            }
        }
    }
    return false;
}

function writeElementCompact (element, name, options, depth, indent) {
    var xml = '';
    if (name) {
        xml += '<' + name;
        if (element[options.attributesKey]) {
            xml += writeAttributes(element[options.attributesKey]);
        }
        if (options.fullTagEmptyElement || hasContent(element, options) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve') {
            xml += '>';
        } else {
            xml += '/>';
            return xml;
        }
    }
    xml += writeElementsCompact(element, options, depth + 1, false);
    if (name) {
        xml += (indent ? writeIndentation(options, depth, false) : '') + '</' + name + '>';
    }
    return xml;
}

function writeElementsCompact (element, options, depth, firstLine) {
    var key, xml = '';
    for (key in element) {
        if (element.hasOwnProperty(key)) {
            switch (key) {
                case options.declarationKey: xml += writeDeclaration(element[options.declarationKey], options); break;
                case options.attributesKey: case options.parentKey: break; // skip
                case options.textKey: xml += writeText(element, options); break;
                case options.cdataKey: xml += writeIndentation(options, depth, firstLine) + writeCdata(element, options); break;
                case options.commentKey: xml += writeIndentation(options, depth, firstLine) + writeComment(element, options); break;
                default:
                    if (element[key] instanceof Array) {
                        element[key].forEach(function (el) {
                            xml += writeIndentation(options, depth, firstLine) + writeElementCompact(el, key, options, depth, hasContent(el, options, true));
                        });
                    } else {
                        xml += writeIndentation(options, depth, firstLine) + writeElementCompact(element[key], key, options, depth, hasContent(element[key], options, true));
                    }
            }
            firstLine = firstLine && !xml;
        }
    }
    return xml;
}

module.exports = function (js, options) {
    'use strict';
    options = validateOptions(options);
    var xml = '';
    if (options.compact) {
        xml = writeElementsCompact(js, options, 0, true);
    } else {
        if (js[options.declarationKey]) {
            xml += writeDeclaration(js[options.declarationKey], options);
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
            xml += writeElements(js[options.elementsKey], options, 0, !xml);
        }
    }
    return xml;
};
},{"./common":29}],32:[function(_dereq_,module,exports){
(function (Buffer){
var js2xml = _dereq_('./js2xml.js');

module.exports = function (json, options) {
    'use strict';
    if (json instanceof Buffer) {
        json = json.toString();
    }
    var js = null;
    if (typeof (json) === 'string') {
        try {
            js = JSON.parse(json);
        } catch (e) {
            throw new Error("The JSON structure is invalid");
        }
    } else {
        js = json;
    }
    return js2xml(js, options);
};
}).call(this,_dereq_("buffer").Buffer)

},{"./js2xml.js":31,"buffer":4}],33:[function(_dereq_,module,exports){
var sax = _dereq_('sax');
var expat /*= require('node-expat');*/ = {on: function () {}, parse: function () {}};
var common = _dereq_('./common');

var options;
var pureJsParser = 1; //true;
var currentElement;

function validateOptions (userOptions) {
    options = common.copyOptions(userOptions);
    common.ensureFlagExists('ignoreDeclaration', options);
    common.ensureFlagExists('ignoreAttributes', options);
    common.ensureFlagExists('ignoreText', options);
    common.ensureFlagExists('ignoreComment', options);
    common.ensureFlagExists('ignoreCdata', options);
    common.ensureFlagExists('compact', options);
    common.ensureFlagExists('alwaysChildren', options);
    common.ensureFlagExists('addParent', options);
    common.ensureFlagExists('trim', options);
    common.ensureFlagExists('nativeType', options);
    common.ensureFlagExists('sanitize', options);
    common.ensureKeyExists('declaration', options);
    common.ensureKeyExists('attributes', options);
    common.ensureKeyExists('text', options);
    common.ensureKeyExists('comment', options);
    common.ensureKeyExists('cdata', options);
    common.ensureKeyExists('type', options);
    common.ensureKeyExists('name', options);
    common.ensureKeyExists('elements', options);
    common.ensureKeyExists('parent', options);
    return options;
}

function nativeType (value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
        return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === 'true') {
        return true;
    } else if (bValue === 'false') {
        return false;
    }
    return value;
}

function addField (type, value, options) {
    if (options.compact) {
        currentElement[options[type + 'Key']] = (currentElement[options[type + 'Key']] ? currentElement[options[type + 'Key']] + '\n' : '') + value;
    } else {
        if (!currentElement[options.elementsKey]) {
            currentElement[options.elementsKey] = [];
        }
        var element = {};
        element[options.typeKey] = type;
        element[options[type + 'Key']] = value;
        if (options.addParent) {
            element[options.parentKey] = currentElement;
        }
        currentElement[options.elementsKey].push(element);
    }
}

function onDeclaration (declaration) {
    if (options.ignoreDeclaration) {
        return;
    }
    if (currentElement[options.declarationKey]) {
        return;
    }
    currentElement[options.declarationKey] = {};
    while (declaration.body) {
        var attribute = declaration.body.match(/([\w:-]+)\s*=\s*"([^"]*)"|'([^']*)'|(\w+)\s*/);
        if (!attribute) {
            break;
        }
        if (!currentElement[options.declarationKey][options.attributesKey]) {
            currentElement[options.declarationKey][options.attributesKey] = {};
        }
        currentElement[options.declarationKey][options.attributesKey][attribute[1]] = attribute[2];
        declaration.body = declaration.body.slice(attribute[0].length); // advance the string
    }
    if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
}

function onStartElement (name, attributes) {
    var key, element;
    if (typeof name === 'object') {
        attributes = name.attributes;
        name = name.name;
    }
    if (options.trim && attributes) {
        for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
                attributes[key] = attributes[key].trim();
            }
        }
    }
    if (options.compact) {
        element = {};
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = {};
            for (key in attributes) {
                if (attributes.hasOwnProperty(key)) {
                    element[options.attributesKey][key] = attributes[key];
                }
            }
        }
        element[options.parentKey] = currentElement;
        if (!(name in currentElement)) {
            currentElement[name] = element;
        } else {
            if (!(currentElement[name] instanceof Array)) {
                currentElement[name] = [currentElement[name]];
            }
            currentElement[name].push(element);
        }
        currentElement = element;
    } else {
        if (!currentElement[options.elementsKey]) {
            currentElement[options.elementsKey] = [];
        }
        element = {};
        element[options.typeKey] = 'element';
        element[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
            element[options.attributesKey] = attributes;
        }
        element[options.parentKey] = currentElement;
        if (options.alwaysChildren) {
            element[options.elementsKey] = [];
        }
        currentElement[options.elementsKey].push(element);
        currentElement = element;
    }
}

function onText (text) {
    //console.log('currentElement:', currentElement);
    if (options.ignoreText) {
        return;
    }
    if (!text.trim()) {
        return;
    }
    if (options.trim) {
        text = text.trim();
    }
    if (options.nativeType) {
        text = nativeType(text);
    }
    if (options.sanitize) {
        text = common.sanitize(text);
    }
    addField('text', text, options);
}

function onComment (comment) {
    if (options.ignoreComment) {
        return;
    }
    if (options.trim) {
        comment = comment.trim();
    }
    if (options.sanitize) {
        comment = common.sanitize(comment);
    }
    addField('comment', comment, options);
}

function onEndElement (name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
        delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
}

function onCdata (cdata) {
    if (options.ignoreCdata) {
        return;
    }
    if (options.trim) {
        cdata = cdata.trim();
    }
    addField('cdata', cdata, options);
}

function onError (error) {
    error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {
    
    var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
    var result = {};
    currentElement = result;
    
    options = validateOptions(userOptions);
    
    if (pureJsParser) {
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.onprocessinginstruction = onDeclaration;
    } else {
        parser.on('startElement', onStartElement);
        parser.on('text', onText);
        parser.on('comment', onComment);
        parser.on('endElement', onEndElement);
        parser.on('error', onError);
        //parser.on('startCdata', onStartCdata);
        //parser.on('endCdata', onEndCdata);
        //parser.on('entityDecl', onEntityDecl);
    }
    
    if (pureJsParser) {
        parser.write(xml).close();
    } else {
        if (!parser.parse(xml)) {
            throw new Error('XML parsing error: ' + parser.getError());
        }
    }
    
    if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
    }
    
    return result;

};
},{"./common":29,"sax":25}],34:[function(_dereq_,module,exports){
var common = _dereq_('./common');
var xml2js = _dereq_('./xml2js');

function validateOptions (userOptions) {
    var options = common.copyOptions(userOptions);
    common.ensureSpacesExists(options);
    return options;
}

module.exports = function(xml, userOptions) {
    'use strict';
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js(xml, options);
    parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
    if ('addParent' in options && options.addParent) {
        json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);
    } else {
        json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};
},{"./common":29,"./xml2js":33}],35:[function(_dereq_,module,exports){
'use strict';

var objPath = _dereq_('object-path');

var getId = function getId(arc) {
  return objPath.get(arc, '_attributes.id');
};

var getClass = function getClass(arc) {
  return objPath.get(arc, '_attributes.class', '');
};

var getSource = function getSource(arc, nodeIdSet, portIdMap) {
  var portSource = getPortSource(arc);
  return nodeIdSet.has(portSource) ? portSource : portIdMap.get(portSource);
};

var getTarget = function getTarget(arc, nodeIdSet, portIdMap) {
  var portTarget = getPortTarget(arc);
  return nodeIdSet.has(portTarget) ? portTarget : portIdMap.get(portTarget);
};

var getPortSource = function getPortSource(arc) {
  return objPath.get(arc, '_attributes.source', '');
};

var getPortTarget = function getPortTarget(arc) {
  return objPath.get(arc, '_attributes.target', '');
};

var getCardinality = function getCardinality(glyph) {
  return parseInt(objPath.get(glyph, 'label._attributes.text', ''));
};

var getBendPointPositions = function getBendPointPositions(arc) {
  return [].concat(objPath.get(arc, 'next', [])).map(function (bendPoint) {
    return {
      x: parseInt(bendPoint.x),
      y: parseInt(bendPoint.y)
    };
  });
};

var convertArc = function convertArc(arc, nodeIdSet, portIdMap) {
  return {
    data: {
      id: getId(arc),
      'class': getClass(arc),
      cardinality: arc.glyph ? getCardinality(arc.glyph) : 0,
      source: getSource(arc, nodeIdSet, portIdMap),
      target: getTarget(arc, nodeIdSet, portIdMap),
      bendPointPositions: getBendPointPositions(arc),
      portSource: getPortSource(arc),
      portTarget: getPortTarget(arc)
    }
  };
};

var validArc = function validArc(arc, nodeIdSet, portIdMap) {
  var srcNodeId = getSource(arc, nodeIdSet, portIdMap);
  var tgtNodeId = getTarget(arc, nodeIdSet, portIdMap);

  return nodeIdSet.has(srcNodeId) && nodeIdSet.has(tgtNodeId);
};

var convertEdges = function convertEdges(arcs, nodeIdSet, portIdMap) {
  return arcs.filter(function (arc) {
    return validArc(arc, nodeIdSet, portIdMap);
  }).map(function (arc) {
    return convertArc(arc, nodeIdSet, portIdMap);
  });
};
module.exports = convertEdges;

},{"object-path":11}],36:[function(_dereq_,module,exports){
'use strict';

var converter = _dereq_('./sbgnmlConverter');

module.exports = function (text) {
  return converter(text);
};

},{"./sbgnmlConverter":39}],37:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var objPath = _dereq_('object-path');

var validSbgnClass = _dereq_('./sbgnTags');

var getCenteredBbox = function getCenteredBbox(glyph) {
  var _objPath$get = objPath.get(glyph, 'bbox._attributes', { x: 0, y: 0, w: 0, h: 0 }),
      x = _objPath$get.x,
      y = _objPath$get.y,
      w = _objPath$get.w,
      h = _objPath$get.h;

  return {
    x: parseFloat(x) + parseFloat(w) / 2,
    y: parseFloat(y) + parseFloat(h) / 2,
    w: parseFloat(w),
    h: parseFloat(h)
  };
};

var getId = function getId(glyph) {
  return objPath.get(glyph, '_attributes.id');
};

var getClass = function getClass(glyph) {
  return objPath.get(glyph, '_attributes.class', '');
};

var getLabel = function getLabel(glyph) {
  return objPath.get(glyph, 'label._attributes.text', '');
};

var getParent = function getParent(glyph) {
  return objPath.get(glyph, '_attributes.compartmentRef', '');
};

var getClonemarker = function getClonemarker(glyph) {
  return glyph.clone !== undefined;
};

var getState = function getState(glyph) {
  return {
    variable: objPath.get(glyph, 'state._attributes.variable', ''),
    value: objPath.get(glyph, 'state._attributes.value', '')
  };
};

var getStateVar = function getStateVar(glyph) {
  return {
    id: getId(glyph),
    'class': getClass(glyph),
    state: getState(glyph)
  };
};

var getUnitOfInformation = function getUnitOfInformation(glyph) {
  return {
    id: getId(glyph),
    'class': getClass(glyph),
    label: {
      text: objPath.get(glyph, 'label._attributes.text', '')
    }
  };
};

var getStateVars = function getStateVars(glyph) {
  return getChildrenArray(glyph).filter(function (child) {
    return getClass(child) === 'state variable';
  }).map(function (stateVar) {
    return getStateVar(stateVar);
  });
};

var getUnitsOfInformation = function getUnitsOfInformation(glyph) {
  return getChildrenArray(glyph).filter(function (child) {
    return getClass(child) === 'unit of information';
  }).map(function (g) {
    return getUnitOfInformation(g);
  });
};

var getChildren = function getChildren(glyph) {
  return getChildrenArray(glyph).filter(function (child) {
    return getClass(child) !== 'unit of information' && getClass(child) !== 'state variable';
  });
};

var getChildrenArray = function getChildrenArray(glyph) {
  return [].concat(objPath.get(glyph, 'glyph', []));
};

var convertGlyph = function convertGlyph(glyph) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  return {
    data: {
      id: getId(glyph),
      'class': getClass(glyph),
      label: getLabel(glyph),
      parent: glyph.parent || getParent(glyph) || parent, // immediate parent takes precendence over compartments
      clonemarker: getClonemarker(glyph),
      stateVariables: getStateVars(glyph),
      unitsOfInformation: getUnitsOfInformation(glyph),
      bbox: getCenteredBbox(glyph)
    }
  };
};
var getPorts = function getPorts(glyph) {
  return [].concat(objPath.get(glyph, 'port', [])).map(function (port) {
    return {
      id: getId(port),
      bbox: getCenteredBbox(port)
    };
  });
};

module.exports = function (glyphs) {
  var nodeIdSet = new Set();
  var portIdMap = new Map();
  var stack = [];
  var nodes = [];

  stack.push.apply(stack, _toConsumableArray(glyphs));
  while (stack.length > 0) {
    var currGlyph = stack.pop();
    var currGlyphId = getId(currGlyph);
    var processedGlyph = convertGlyph(currGlyph);

    if (validSbgnClass(processedGlyph.data['class'])) {
      nodes.push(processedGlyph);
      nodeIdSet.add(currGlyphId);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = getPorts(currGlyph)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var port = _step.value;

          portIdMap.set(port.id, currGlyphId);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var children = getChildren(currGlyph);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          child.parent = currGlyphId;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      stack.push.apply(stack, _toConsumableArray(children));
    }
  }

  return {
    nodes: nodes,
    nodeIdSet: nodeIdSet,
    portIdMap: portIdMap
  };
};

},{"./sbgnTags":38,"object-path":11}],38:[function(_dereq_,module,exports){
'use strict';

var handledSbgnClasses = new Set().add('unspecified entity').add('simple chemical').add('macromolecule').add('nucleic acid feature').add('perturbing agent').add('source and sink').add('complex').add('process').add('omitted process').add('uncertain process').add('association').add('dissociation').add('phenotype').add('tag').add('consumption').add('production').add('modulation').add('stimulation').add('catalysis').add('inhibition').add('necessary stimulation').add('logic arc').add('equivalence arc').add('and operator').add('or operator').add('not operator').add('and').add('or').add('not').add('nucleic acid feature multimer').add('macromolecule multimer').add('simple chemical multimer').add('complex multimer').add('compartment');

module.exports = function (sbgnClass) {
  return handledSbgnClasses.has(sbgnClass);
};

},{}],39:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var convert = _dereq_('xml-js');
var objPath = _dereq_('object-path');

var nodesConverter = _dereq_('./nodesConverter');
var edgesConverter = _dereq_('./edgesConverter');

module.exports = function (sbgnmlText) {

  if (sbgnmlText === null) {
    throw new Error('\'' + sbgnmlText + ' is invalid input.');
  }

  var converted = convert.xml2js(sbgnmlText, { compact: true, spaces: 2, trim: true, nativeType: true });

  var result = objPath.get(converted, 'sbgn.map', undefined);
  if (result === undefined) {
    return { nodes: [], edges: [] };
  }

  var glyphs = [];
  var arcs = [];
  if (result.glyph) {
    glyphs.push.apply(glyphs, _toConsumableArray(result.glyph));
  }
  if (result.arc) {
    arcs.push.apply(arcs, _toConsumableArray(result.arc));
  }

  var _nodesConverter = nodesConverter(glyphs),
      nodes = _nodesConverter.nodes,
      nodeIdSet = _nodesConverter.nodeIdSet,
      portIdMap = _nodesConverter.portIdMap;

  var edges = edgesConverter(arcs, nodeIdSet, portIdMap);

  return { nodes: nodes, edges: edges };
};

},{"./edgesConverter":35,"./nodesConverter":37,"object-path":11,"xml-js":30}]},{},[36])(36)
});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],112:[function(_dereq_,module,exports){
var util = _dereq_('util');
var extend = _dereq_('xtend');

var supported = function() {
	if(typeof document === 'undefined' || typeof document.createElement !== 'function') return false;

	var canvas = document.createElement('canvas');
	if(typeof canvas.getContext !== 'function') return false;

	var context = canvas.getContext('2d');
	return !!context && (typeof context.measureText === 'function');
};

var initialize = function() {
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');

	var width = function(str, options) {
		options = extend({
			style: 'normal',
			variant: 'normal',
			weight: 'normal',
			size: 'medium',
			family: 'sans-serif',
			align: 'start',
			baseline: 'alphabetic'
		}, options);

		var size = options.size;
		if(typeof size === 'number') size = size + 'px';

		context.font = util.format('%s %s %s %s %s',
			options.style,
			options.variant,
			options.weight,
			size,
			options.family);
		context.textAlign = options.align;
		context.textBaseline = options.baseline;

		return context.measureText(str).width;
	};

	width.supported = true;
	return width;
};

module.exports = supported() ? initialize() : (function() {
	var width = function() {
		return 0;
	};

	width.supported = false;
	return width;
}());

},{"util":115,"xtend":116}],113:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],114:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],115:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":114,"_process":110,"inherits":113}],116:[function(_dereq_,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],117:[function(_dereq_,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cytoscape = _dereq_('cytoscape');
var defaultsDeep = _dereq_('lodash.defaultsdeep');

var sbgnStyleSheet = _dereq_('./sbgnStyle/graph');
var renderGraph = _dereq_('./renderGraph');

var defaultOptions = {
  boxSelectionEnabled: true,
  showOverlay: false,
  minZoom: false,
  maxZoom: false,
  motionBlur: false,
  wheelSensitivity: 0.1
};

var SBGNRenderer = function (_Cytoscape) {
  _inherits(SBGNRenderer, _Cytoscape);

  function SBGNRenderer(options) {
    _classCallCheck(this, SBGNRenderer);

    options = defaultsDeep({}, defaultOptions, options);

    if (!options.style) {
      options.style = sbgnStyleSheet(Cytoscape);
    }

    return _possibleConstructorReturn(this, (SBGNRenderer.__proto__ || Object.getPrototypeOf(SBGNRenderer)).call(this, defaultsDeep({}, defaultOptions, options)));
  }

  return SBGNRenderer;
}(Cytoscape);

SBGNRenderer.stylesheet = function () {
  return sbgnStyleSheet(Cytoscape);
};

SBGNRenderer.renderGraph = renderGraph;

module.exports = SBGNRenderer;

},{"./renderGraph":118,"./sbgnStyle/graph":127,"cytoscape":81,"lodash.defaultsdeep":108}],118:[function(_dereq_,module,exports){
'use strict';

var convertSbgnml = _dereq_('sbgnml-to-cytoscape');

var removeDisconnectedNodes = function removeDisconnectedNodes(cy) {
  var compartmentChildren = cy.nodes('[class="compartment"]').children();
  compartmentChildren.filterFn(function (ele) {
    return ele.neighborhood().length === 0;
  }).remove();

  var danglingNodes = cy.nodes('[class != "compartment"], [class != "complex"], [class != "complex multimer"]');
  danglingNodes.filterFn(function (ele) {
    return !ele.isChild() && ele.neighborhood.length === 0;
  }).remove();
};

var expandCollapseComplexNodesBilkent = function expandCollapseComplexNodesBilkent(cy) {
  cy.expandCollapse({
    fisheye: false,
    animate: true,
    undoable: false,
    cueEnabled: false
  });

  cy.nodes().on('expandcollapse.afterexpand', function (evt) {
    var node = evt.target;
    cy.zoomingEnabled(false);
    node.children().layout({
      name: 'grid',
      fit: 'false',
      avoidOverlap: true,
      condense: true,
      rows: node.children().size() / 2,
      cols: node.children().size() / 2,
      boundingBox: node.boundingBox()
    }).run();
    cy.zoomingEnabled(true);
  });

  var complexes = cy.nodes('[class="complex"], [class="complex multimer"]');
  var api = cy.expandCollapse('get');

  api.collapse(complexes);

  cy.on('tap', 'node[class="complex"], node[class="complex multimer"]', {}, function (evt) {

    var node = evt.target;
    if (api.isCollapsible(node)) {
      api.collapseRecursively(node);
    } else {
      api.expand(node);
    }
  });
};

var reduceGraphComplexity = function reduceGraphComplexity(cy) {
  removeDisconnectedNodes(cy);
  expandCollapseComplexNodesBilkent(cy);
};

var renderGraph = function renderGraph(cy, sbgnmlText) {
  var graphJSON = convertSbgnml(sbgnmlText);

  cy.batch(function () {
    cy.remove('*');
    cy.add(graphJSON);

    var nodePositions = {};
    for (var i = 0; i < graphJSON.nodes.length; i++) {
      var xPos = graphJSON.nodes[i].data.bbox.x;
      var yPos = graphJSON.nodes[i].data.bbox.y;
      nodePositions[graphJSON.nodes[i].data.id] = { 'x': xPos, 'y': yPos };
    }

    cy.layout({
      name: 'preset',
      positions: nodePositions,
      fit: true,
      padding: 50
    }).run();
  });

  reduceGraphComplexity(cy);
};

module.exports = renderGraph;

},{"sbgnml-to-cytoscape":111}],119:[function(_dereq_,module,exports){
'use strict';

var sbgnData = _dereq_('./util/sbgn.js');

var sbgnNodeDimensions = new Map().set('unspecified entity', { w: 40, h: 40 }).set('simple chemical', { w: 60, h: 60 }).set('simple chemical multimer', { w: 60, h: 60 }).set('macromolecule', { w: 100, h: 60 }).set('macromolecule multimer', { w: 100, h: 60 }).set('nucleic acid feature', { w: 100, h: 60 }).set('nucleic acid feature multimer', { w: 100, h: 60 }).set('complex', { w: 45, h: 45 }).set('complex multimer', { w: 250, h: 250 }).set('source and sink', { w: 60, h: 60 }).set('perturbing agent', { w: 140, h: 60 }).set('phenotype', { w: 140, h: 60 }).set('process', { w: 25, h: 25 }).set('uncertain process', { w: 25, h: 25 }).set('omitted process', { w: 25, h: 25 }).set('association', { w: 25, h: 25 }).set('dissociation', { w: 25, h: 25 }).set('compartment', { w: 200, h: 100 }).set('tag', { w: 100, h: 65 }).set('and', { w: 40, h: 40 }).set('or', { w: 40, h: 40 }).set('not', { w: 40, h: 40 });

var get = function get(node) {
  var sbgnClass = sbgnData.sbgnClass(node);
  var dim = sbgnNodeDimensions.get(sbgnClass);
  if (dim === undefined) {
    throw new TypeError(sbgnClass + ' does not have a default width / height');
  }
  return dim;
};

var width = function width(node) {
  return get(node).w;
};

var height = function height(node) {
  return get(node).h;
};

module.exports = {
  height: height,
  width: width,
  get: get
};

},{"./util/sbgn.js":128}],120:[function(_dereq_,module,exports){
'use strict';

var sbgnData = _dereq_('./util/sbgn.js');
var elementStyle = {};

elementStyle.sbgnShape = function (node) {
  var sbgnClass = sbgnData.sbgnClass(node);
  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'phenotype') {
    return 'hexagon';
  }

  if (sbgnClass == 'compartment') {
    return 'barrel';
  }

  if (sbgnClass == 'process' || sbgnClass == 'omitted process' || sbgnClass == 'uncertain process') {
    return 'square';
  }

  if (sbgnClass == 'perturbing agent' || sbgnClass == 'tag' || sbgnClass == 'source and sink') {
    return 'polygon';
  }

  if (sbgnClass == 'dissociation' || sbgnClass == 'association' || sbgnClass == 'simple chemical') {
    return 'ellipse';
  }

  if (sbgnClass == 'nucleic acid feature' || sbgnClass == 'macromolecule') {
    return 'roundrectangle';
  }

  if (sbgnClass == 'complex') {
    return 'cutrectangle';
  }
  return 'ellipse';
};

elementStyle.sbgnArrowShape = function (edge) {
  var sbgnClass = sbgnData.sbgnClass(edge);
  if (sbgnClass == 'necessary stimulation') {
    return 'triangle-cross';
  }
  if (sbgnClass == 'inhibition') {
    return 'tee';
  }
  if (sbgnClass == 'catalysis') {
    return 'circle';
  }
  if (sbgnClass == 'stimulation' || sbgnClass == 'production') {
    return 'triangle';
  }
  if (sbgnClass == 'modulation') {
    return 'diamond';
  }
  return 'none';
};

elementStyle.sbgnContent = function (node) {
  var sbgnClass = sbgnData.sbgnClass(node);
  var content = '';

  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'macromolecule' || sbgnClass == 'simple chemical' || sbgnClass == 'phenotype' || sbgnClass == 'unspecified entity' || sbgnClass == 'nucleic acid feature' || sbgnClass == 'perturbing agent' || sbgnClass == 'tag') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'compartment') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'complex') {
    if (node.children().length == 0) {
      if (node.data('label')) {
        content = node.data('label');
      } else if (node.data('infoLabel')) {
        content = node.data('infoLabel');
      } else {
        content = '';
      }
    } else {
      content = '';
    }
  } else if (sbgnClass == 'and') {
    content = 'AND';
  } else if (sbgnClass == 'or') {
    content = 'OR';
  } else if (sbgnClass == 'not') {
    content = 'NOT';
  } else if (sbgnClass == 'omitted process') {
    content = '\\\\';
  } else if (sbgnClass == 'uncertain process') {
    content = '?';
  }

  return content;
};

var dynamicLabelTextSize = function dynamicLabelTextSize(nodeHeight) {
  var sizeCoefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return nodeHeight / 2.45 * sizeCoefficient;
};

elementStyle.labelTextSize = function (node) {
  var sbgnClass = sbgnData.sbgnClass(node);
  var nh = 40; // dont use node.width() leads to expensive cyclic updates

  // Dirty legacy hack.  These types of nodes are not supposed to have labels
  // but apparently they need to have a text size
  if (sbgnClass === 'association' || sbgnClass === 'dissociation') {
    return 20;
  }

  if (sbgnClass === 'and' || sbgnClass === 'or' || sbgnClass === 'not') {
    return dynamicLabelTextSize(nh, 1);
  }

  if (sbgnClass.endsWith('process')) {
    return dynamicLabelTextSize(nh, 1.5);
  }

  if (sbgnClass.includes('complex')) {
    return 16;
  }

  if (sbgnClass === 'compartment') {
    return 50;
  }

  return dynamicLabelTextSize(nh);
};

elementStyle.cardinalityDistance = function (edge) {
  var srcPos = edge.source().position();
  var tgtPos = edge.target().position();

  var distance = Math.sqrt(Math.pow(srcPos.x - tgtPos.x, 2) + Math.pow(srcPos.y - tgtPos.y, 2));
  return distance * 0.15;
};

module.exports = elementStyle;

},{"./util/sbgn.js":128}],121:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var textWidth = _dereq_('text-width');

var baseShapes = _dereq_('./baseShapes.js');

var stateVarLabel = function stateVarLabel(stateVar) {
  var variable = stateVar.state.variable;
  var value = stateVar.state.value;
  if (value && variable) {
    return value + '@' + variable;
  }
  if (value) {
    return value;
  }

  if (variable) {
    return variable;
  }
  return '';
};

var auxiliaryItems = {
  stateVariable: function stateVariable(x, y, radius, stateVar) {

    var fontSize = 12;

    var stateVarStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1.5').set('fill', 'white').set('fill-opacity', '1');

    var textStyle = new Map().set('alignment-baseline', 'middle').set('font-size', '' + fontSize).set('font-family', 'Helvetica Neue, Helvetica, sans-serif').set('text-anchor', 'middle').set('stroke', 'black');

    var tw = textWidth(stateVarLabel(stateVar, { family: textStyle.get('font-family'), size: fontSize }), 20);
    var stateVarWidth = Math.max(tw * .5, 20);

    var statevariableSvg = '\n      ' + baseShapes.ellipse(x, y, stateVarWidth, radius, stateVarStyle) + '\n      ' + baseShapes.text(stateVarLabel(stateVar), x, y, textStyle) + '\n    ';

    return statevariableSvg;
  },
  unitOfInformation: function unitOfInformation(x, y, width, height, unitInfo) {

    var fontSize = 12;
    var text = unitInfo.label.text;

    var uinfoRectStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1.5').set('fill', 'white').set('fill-opacity', '1');

    var textStyle = new Map().set('alignment-baseline', 'middle').set('font-size', '' + fontSize).set('font-family', 'Helvetica Neue, Helvetica, sans-serif').set('text-anchor', 'middle').set('stroke', 'black');

    var uInfoWidth = textWidth(text, { family: textStyle.get('font-family'), size: fontSize }) + 5;

    var unitOfInformationSvg = '\n      ' + baseShapes.roundRectangle(x - uInfoWidth / 2, y, uInfoWidth, height, uinfoRectStyle) + '\n      ' + baseShapes.text(unitInfo.label.text, x, y + height / 2, textStyle) + '\n    ';

    return unitOfInformationSvg;
  },
  cloneMarker: function cloneMarker(nodeWidth, nodeHeight, shapeFn, shapeFnArgs) {
    var clipId = 'clonemarker';

    var cloneMarkerStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1.5').set('clip-path', 'url(#' + clipId + ')').set('fill', '#D2D2D2');

    var cloneMarkerSvg = '\n      ' + baseShapes.clipPath(clipId, baseShapes.rectangle, [0, 3 * nodeHeight / 4, nodeWidth, nodeHeight, new Map()]) + '\n      ' + shapeFn.apply(undefined, _toConsumableArray(shapeFnArgs).concat([cloneMarkerStyle])) + '\n    ';

    return cloneMarkerSvg;
  },
  multimer: function multimer(shapeFn, shapeFnArgs) {
    var clipId = 'multimer';

    var multimerStyle = new Map().set('stroke', '#6A6A6A').set('fill', 'none').set('stroke-width', '3').set('clip-path', 'url(#' + clipId + ')');

    var multimerSvg = '\n      ' + baseShapes.clipPath(clipId, shapeFn, shapeFnArgs, new Map()) + '\n      ' + shapeFn.apply(undefined, _toConsumableArray(shapeFnArgs).concat([multimerStyle])) + '\n    ';
    return multimerSvg;
  }
};

module.exports = auxiliaryItems;

},{"./baseShapes.js":122,"text-width":112}],122:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var styleMap2Str = _dereq_('../util/svg.js').styleMap2Str;

var baseRectangle = function baseRectangle(x, y, w, h, r1, r2, r3, r4, styleMap) {
  return '\n  <path ' + styleMap2Str(styleMap) + ' d=\'\n    M ' + (x + r1) + ' ' + y + '\n    L ' + (x + w - r2) + ' ' + y + ' Q ' + (x + w) + ' ' + y + ' ' + (x + w) + ' ' + (y + r2) + '\n    L ' + (x + w) + ' ' + (y + h - r3) + ' Q ' + (x + w) + ' ' + (y + h) + ' ' + (x + w - r3) + ' ' + (y + h) + '\n    L ' + (x + r4) + ' ' + (y + h) + ' Q ' + x + ' ' + (y + h) + ' ' + x + ' ' + (y + h - r4) + '\n    L ' + x + ' ' + (y + r1) + ' Q ' + x + ' ' + y + ' ' + (x + r1) + ' ' + y + '\n    Z\'\n  />\n  ';
};

var baseShapes = {
  barrel: function barrel(x, y, width, height, styleMap) {
    return '\n\n    <g ' + styleMap2Str(styleMap) + '>\n      <path d="M ' + (0 * width + x) + ' ' + (.03 * height + y) + ' L ' + (0 * width + x) + ' ' + (.97 * height + y) + ' Q ' + (0.06 * width + x) + ' ' + (height + y) + ' ' + (0.25 * width + x) + ' ' + (height + y) + '"/>\n\n      <path d="M ' + (0.25 * width + x) + ' ' + (height + y) + ' L ' + (0.75 * width + x) + ' ' + (height + y) + ' Q ' + (0.95 * width + x) + ' ' + (height + y) + ' ' + (width + x) + ' ' + (0.95 * height + y) + '"/>\n\n      <path d="M ' + (width + x) + ' ' + (.95 * height + y) + ' L ' + (width + x) + ' ' + (0.05 * height + y) + ' Q ' + (width + x) + ' ' + (0 * height + y) + ' ' + (0.75 * width + x) + ' ' + (0 * height + y) + '"/>\n\n      <path d="M ' + (0.75 * width + x) + ' ' + (0 * height + y) + ' L ' + (0.25 * width + x) + ' ' + (0 * height + y) + ' Q ' + (0.06 * width + x) + ' ' + (0 * height + y) + ' ' + (0 * width + x) + ' ' + (0.03 * height + y) + '"/>\n    </g>\n\n    ';
  },
  circle: function circle(cx, cy, r, styleMap) {
    return '<circle cx=\'' + cx + '\' cy=\'' + cy + '\' r=\'' + r + '\' ' + styleMap2Str(styleMap) + ' />';
  },
  clipPath: function clipPath(id, baseShapeFn, baseShapeFnArgs, styleMap) {
    return '\n      <defs>\n        <clipPath id=\'' + id + '\' ' + styleMap2Str(styleMap) + '>\n        ' + baseShapeFn.apply(undefined, _toConsumableArray(baseShapeFnArgs)) + '\n        </clipPath>\n      </defs>\n    ';
  },
  concaveHexagon: function concaveHexagon(x, y, width, height, styleMap) {
    return '\n    <polygon ' + styleMap2Str(styleMap) + '\n      points=\'' + (x + 0) + ', ' + (y + 0) + ', ' + (x + width) + ', ' + (y + 0) + ', ' + (x + 0.85 * width) + ', ' + (y + 0.5 * height) + ', ' + (x + width) + ', ' + (y + height) + ', ' + (x + 0) + ', ' + (y + height) + ', ' + (x + 0.15 * width) + ', ' + (y + 0.5 * height) + '\'\n    />';
  },
  cutRectangle: function cutRectangle(x, y, width, height, cornerLength, styleMap) {
    return '\n    <polygon ' + styleMap2Str(styleMap) + '\n      points=\'\n      ' + (x + 0 * width) + ' ' + (y + cornerLength) + ' ' + (x + cornerLength) + ' ' + (y + 0 * height) + ' ' + (x + width - cornerLength) + ' ' + (y + 0 * height) + ' ' + (x + width) + ' ' + (y + cornerLength) + '\n      ' + (x + width) + ' ' + (y + height - cornerLength) + ' ' + (x + width - cornerLength) + ' ' + (y + height) + ' ' + (x + cornerLength) + ' ' + (y + height) + ' ' + (x + 0 * width) + ' ' + (y + height - cornerLength) + '\n      \'\n    />\n    ';
  },
  ellipse: function ellipse(cx, cy, rx, ry, styleMap) {
    return '\n      <ellipse cx=\'' + cx + '\' cy=\'' + cy + '\' rx=\'' + rx + '\' ry=\'' + ry + '\' ' + styleMap2Str(styleMap) + ' />\n    ';
  },
  hexagon: function hexagon(x, y, width, height, styleMap) {
    return '\n    <polygon ' + styleMap2Str(styleMap) + '\n      points=\'' + (x + 0) + ', ' + (y + 0.5 * height) + ', ' + (x + 0.25 * width) + ', ' + (y + 0 * height) + ', ' + (x + 0.75 * width) + ', ' + (y + 0 * height) + ', ' + (x + width) + ', ' + (y + 0.5 * height) + ', ' + (x + 0.75 * width) + ', ' + (y + height) + ', ' + (x + 0.25 * width) + ', ' + (y + height) + '\'\n    />';
  },
  line: function line(x1, y1, x2, y2, styleMap) {
    return '<line x1=\'' + x1 + '\' y1=\'' + y1 + '\' x2=\'' + x2 + '\' y2=\'' + y2 + '\' ' + styleMap2Str(styleMap) + ' />';
  },
  rectangle: function rectangle(x, y, width, height, styleMap) {
    return baseRectangle(x, y, width, height, 0, 0, 0, 0, styleMap);
  },
  roundBottomRectangle: function roundBottomRectangle(x, y, width, height, styleMap) {
    return baseRectangle(x, y, width, height, 0, 0, .3 * height, .3 * height, styleMap);
  },
  roundRectangle: function roundRectangle(x, y, width, height, styleMap) {
    return baseRectangle(x, y, width, height, .1 * width, .1 * width, .1 * width, .1 * width, styleMap);
  },
  square: function square(x, y, length, styleMap) {
    return baseRectangle(x, y, length, length, 0, 0, 0, 0, styleMap);
  },
  text: function text(t, x, y, styleMap) {
    return '<text x=\'' + x + '\' y=\'' + y + '\' ' + styleMap2Str(styleMap) + '>' + t + '</text>';
  }
};

module.exports = baseShapes;

},{"../util/svg.js":129}],123:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var svgStr = _dereq_('../util/svg').svgStr;
var sbgnData = _dereq_('../util/sbgn');

var auxiliaryItems = _dereq_('./auxiliaryItems');
var baseShapes = _dereq_('./baseShapes');

var containerNodes = {
  compartment: function compartment(node) {
    var nh = node.outerHeight();
    var nw = node.outerWidth();

    var style = new Map().set('stroke-width', '3.75').set('fill', 'none').set('stroke', '#6A6A6A');

    var unitInfos = sbgnData.getUnitInfos(node);
    var uinfoW = Math.min(100, 0.4 * nw);
    var uinfoH = Math.min(25, 0.2 * nh);

    var shapeArgs = [10, 5, nw - 20, nh - 10];

    if (unitInfos.length > 0) {
      shapeArgs = [10, uinfoH / 2, nw - 20, nh - 10];
    }

    var compartmentSvg = '\n      ' + baseShapes.barrel.apply(baseShapes, _toConsumableArray(shapeArgs).concat([style])) + '\n      ' + (unitInfos.length > 0 ? auxiliaryItems.unitOfInformation(nh / 3, 5, uinfoW, uinfoH, unitInfos[0]) : '') + '\n    ';
    return svgStr(compartmentSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = containerNodes;

},{"../util/sbgn":128,"../util/svg":129,"./auxiliaryItems":121,"./baseShapes":122}],124:[function(_dereq_,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var memoize = _dereq_('lodash.memoize');

var baseShapes = _dereq_('./baseShapes');
var auxiliaryItems = _dereq_('./auxiliaryItems');

var svgStr = _dereq_('../util/svg').svgStr;
var getUnitInfos = _dereq_('../util/sbgn').getUnitInfos;
var getStateVars = _dereq_('../util/sbgn').getStateVars;
var hasClonemarker = _dereq_('../util/sbgn').hasClonemarker;
var isMultimer = _dereq_('../util/sbgn').isMultimer;
var dimensions = _dereq_('../dimensions');

var entityPoolNodes = {
  unspecifiedEntity: function unspecifiedEntity(node) {
    var _dimensions$get = dimensions.get(node),
        nw = _dimensions$get.w,
        nh = _dimensions$get.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var shapeArgs = [nw / 2, nh / 2, (nh - 2) / 2, (nw - 2) / 2];

    var unspecEntitySvg = '\n      ' + baseShapes.ellipse.apply(baseShapes, shapeArgs.concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw, nh, baseShapes.ellipse, shapeArgs) : '') + '\n    ';
    return svgStr(unspecEntitySvg, nw, nh, 0, 0, nw, nh);
  },
  simpleChemical: function simpleChemical(node) {
    var _dimensions$get2 = dimensions.get(node),
        nw = _dimensions$get2.w,
        nh = _dimensions$get2.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'white').set('fill-opacity', '1');

    var multimerShapeArgs = [(nw + 3) / 2, (nh + 3) / 2, (Math.min(nw, nh) - 2 - 5) / 2];
    var shapeArgs = [nw / 2, nh / 2, (Math.min(nh, nw) - 2) / 2];

    var uInfos = getUnitInfos(node);
    if (uInfos.length > 0) {
      shapeArgs = [nw / 2, nh / 2, (Math.min(nh, nw) - 2 - 5) / 2];
    }

    if (isMultimer(node)) {
      shapeArgs = [(nw - 3) / 2, (nh - 3) / 2, (Math.min(nh, nw) - 2 - 7) / 2];
    }

    var simpleChemicalSvg = '\n      ' + (isMultimer(node) ? auxiliaryItems.multimer(baseShapes.circle, multimerShapeArgs) : '') + '\n      ' + baseShapes.circle.apply(baseShapes, _toConsumableArray(shapeArgs).concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw, nh, baseShapes.circle, shapeArgs) : '') + '\n      ' + (uInfos.length > 0 ? auxiliaryItems.unitOfInformation(nw / 2, 1, 0.4 * nw, 0.2 * nh, uInfos[0]) : '') + '\n    ';

    return svgStr(simpleChemicalSvg, nw, nh, 0, 0, nw, nh);
  },


  macromolecule: memoize(function (node) {
    var _dimensions$get3 = dimensions.get(node),
        nw = _dimensions$get3.w,
        nh = _dimensions$get3.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none').set('fill', 'white').set('fill-opacity', '1');

    var multimerShapeArgs = [15, 10, .8 * nw, .8 * nh];
    var shapeArgs = [5, 5, nw - 10, nh - 10];

    var uInfos = getUnitInfos(node);
    var sVars = getStateVars(node);

    if (uInfos.length > 0) {
      shapeArgs = [5, 5, .9 * nw, .9 * nh];
    }

    if (sVars.length > 0) {
      shapeArgs[3] = .85 * nh;
    }

    if (isMultimer(node)) {
      shapeArgs = [5, 5, .83 * nw, .78 * nh];
    }

    var macromoleculeSvg = '\n      ' + (isMultimer(node) ? auxiliaryItems.multimer(baseShapes.roundRectangle, multimerShapeArgs) : '') + '\n      ' + baseShapes.roundRectangle.apply(baseShapes, _toConsumableArray(shapeArgs).concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw - 3, nh - 3, baseShapes.roundRectangle, shapeArgs) : '') + '\n      ' + (uInfos.length > 0 ? auxiliaryItems.unitOfInformation(nw / 3, 1, 0.4 * nw, 0.2 * nh, uInfos[0]) : '') + '\n      ' + (sVars.length > 0 ? auxiliaryItems.stateVariable(2 * nw / 4, nh - 0.225 * nh / 2, 0.1 * nh, sVars[0]) : '') + '\n    ';
    return svgStr(macromoleculeSvg, nw, nh, 0, 0, nw, nh);
  }, function macromoleculeShapeKey(node) {
    return '' + node.outerWidth() + '$' + node.outerHeight() + '$' + JSON.stringify(node.data());
  }),

  nucleicAcidFeature: function nucleicAcidFeature(node) {
    var _dimensions$get4 = dimensions.get(node),
        nw = _dimensions$get4.w,
        nh = _dimensions$get4.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none').set('fill', 'white').set('fill-opacity', '1');

    var multimerShapeArgs = [15, 10, .8 * nw, .8 * nh];
    var shapeArgs = [1.5, 1.5, nw - 3, nh - 3];

    var uInfos = getUnitInfos(node);
    var sVars = getStateVars(node);

    if (uInfos.length > 0) {
      shapeArgs = [5, 5, .9 * nw, .88 * nh];
    }

    if (sVars.length > 0) {
      shapeArgs[3] = .85 * nh;
    }

    if (isMultimer(node)) {
      shapeArgs = [5, 5, .83 * nw, .78 * nh];
    }

    var nucleicAcidFeatureSvg = '\n      ' + (isMultimer(node) ? auxiliaryItems.multimer(baseShapes.roundBottomRectangle, multimerShapeArgs) : '') + '\n      ' + baseShapes.roundBottomRectangle.apply(baseShapes, _toConsumableArray(shapeArgs).concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw, nh, baseShapes.roundBottomRectangle, shapeArgs) : '') + '\n      ' + (uInfos.length > 0 ? auxiliaryItems.unitOfInformation(nw / 3, 1, 0.4 * nw, 0.2 * nh, uInfos[0]) : '') + '\n      ' + (sVars.length > 0 ? auxiliaryItems.stateVariable(2 * nw / 4, nh - 0.225 * nh / 2, 0.1 * nh, sVars[0]) : '') + '\n    ';
    return svgStr(nucleicAcidFeatureSvg, nw, nh, 0, 0, nw, nh);
  },
  complex: function complex(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'white').set('fill-opacity', '1');

    var shapeArgs = [1, 2, nw - 2, nh - 5, 10];
    var multimerShapeArgs = [15, 15, .93 * nw, .93 * nh, 10];

    var uInfos = getUnitInfos(node);
    var sVars = getStateVars(node);

    if (uInfos.length > 0) {
      shapeArgs[0] += 5;
      shapeArgs[1] += 10;
      shapeArgs[2] *= .95;
      shapeArgs[3] *= .9;
    }

    if (sVars.length > 0) {
      shapeArgs[3] = .85 * nh;
    }

    if (isMultimer(node)) {
      shapeArgs = [5, 10, .93 * nw, .9 * nh, 10];
    }

    var uinfoW = Math.min(100, 0.4 * nw);
    var uinfoH = Math.min(25, 0.2 * nh);
    var sVarRadius = 15;

    var complexSvg = '\n      ' + (isMultimer(node) ? auxiliaryItems.multimer(baseShapes.cutRectangle, multimerShapeArgs) : '') + '\n      ' + baseShapes.cutRectangle.apply(baseShapes, _toConsumableArray(shapeArgs).concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw, nh, baseShapes.cutRectangle, shapeArgs) : '') + '\n      ' + (uInfos.length > 0 ? auxiliaryItems.unitOfInformation(nw / 3, 1, uinfoW, uinfoH, uInfos[0]) : '') + '\n      ' + (sVars.length > 0 ? auxiliaryItems.stateVariable(2 * nw / 4, shapeArgs[3] + shapeArgs[1] - 5, sVarRadius, sVars[0]) : '') + '\n    ';
    return svgStr(complexSvg, nw, nh, 0, 0, nw, nh);
  },
  sourceAndSink: function sourceAndSink(node) {
    var _dimensions$get5 = dimensions.get(node),
        nw = _dimensions$get5.w,
        nh = _dimensions$get5.h;

    var centerX = nw / 2;
    var centerY = nh / 2;
    var radius = (nw - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-linecap', 'square').set('stroke-width', '1.5').set('fill', 'none');

    var shapeArgs = [centerX, centerY, radius];

    var sourceAndSinkSvg = '\n      ' + baseShapes.circle.apply(baseShapes, shapeArgs.concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw, nh, baseShapes.circle, shapeArgs) : '') + '\n      ' + baseShapes.line(0, nh, nw, 0, styleMap) + '\n    ';

    return svgStr(sourceAndSinkSvg, nw, nh, 0, 0, nw, nh);
  },
  perturbingAgent: function perturbingAgent(node) {
    var _dimensions$get6 = dimensions.get(node),
        nw = _dimensions$get6.w,
        nh = _dimensions$get6.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var shapeArgs = [1, 1, nw - 4, nh - 2];

    var uInfos = getUnitInfos(node);

    if (uInfos.length > 0) {
      shapeArgs = [5, 5, .9 * nw, .9 * nh];
    }

    var perturbingAgentSvg = '\n      ' + baseShapes.concaveHexagon.apply(baseShapes, _toConsumableArray(shapeArgs).concat([styleMap])) + '\n      ' + (hasClonemarker(node) ? auxiliaryItems.cloneMarker(nw - 3, nh - 3, baseShapes.concaveHexagon, shapeArgs) : '') + '\n      ' + (uInfos.length > 0 ? auxiliaryItems.unitOfInformation(nw / 3, 1, 0.4 * nw, 0.2 * nh, uInfos[0]) : '') + '\n    ';
    return svgStr(perturbingAgentSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = entityPoolNodes;

},{"../dimensions":119,"../util/sbgn":128,"../util/svg":129,"./auxiliaryItems":121,"./baseShapes":122,"lodash.memoize":109}],125:[function(_dereq_,module,exports){
'use strict';

var containerNodes = _dereq_('./containerNodes.js');
var entityPoolNodes = _dereq_('./entityPoolNodes.js');
var processNodes = _dereq_('./processNodes.js');

var sbgnData = _dereq_('../util/sbgn.js');

var sbgnNodeShapeMap = new Map()
// process nodes
.set('process', processNodes.process).set('omitted process', processNodes.process).set('uncertain process', processNodes.process).set('association', processNodes.association).set('dissociation', processNodes.dissociation).set('phenotype', processNodes.phenotype)

// entity pool nodes
.set('source and sink', entityPoolNodes.sourceAndSink).set('unspecified entity', entityPoolNodes.unspecifiedEntity).set('simple chemical', entityPoolNodes.simpleChemical).set('simple chemical multimer', entityPoolNodes.simpleChemical).set('macromolecule', entityPoolNodes.macromolecule).set('macromolecule multimer', entityPoolNodes.macromolecule).set('nucleic acid feature', entityPoolNodes.nucleicAcidFeature).set('nucleic acid feature multimer', entityPoolNodes.nucleicAcidFeature).set('complex', entityPoolNodes.complex).set('complex multimer', entityPoolNodes.complex).set('perturbing agent', entityPoolNodes.perturbingAgent)

// container nodes
.set('compartment', containerNodes.compartment);

var draw = function draw(node) {
  var sbgnClass = sbgnData.sbgnClass(node);
  var shapeFn = sbgnNodeShapeMap.get(sbgnClass);
  if (shapeFn === undefined) {
    throw new TypeError(sbgnClass + ' does not have a shape implementation');
  }
  return shapeFn(node);
};

module.exports = {
  draw: draw
};

},{"../util/sbgn.js":128,"./containerNodes.js":123,"./entityPoolNodes.js":124,"./processNodes.js":126}],126:[function(_dereq_,module,exports){
'use strict';

var baseShapes = _dereq_('./baseShapes');
var auxiliaryItems = _dereq_('./auxiliaryItems');

var svgStr = _dereq_('../util/svg').svgStr;
var dimensions = _dereq_('../dimensions');

var processNodes = {
  process: function process(node) {
    var _dimensions$get = dimensions.get(node),
        nw = _dimensions$get.w,
        nh = _dimensions$get.h;

    var squareStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var processSvg = '\n      ' + baseShapes.square(1, 1, Math.min(nw, nh) - 2, squareStyle) + '\n    ';
    return svgStr(processSvg, nw, nh, 0, 0, nw, nh);
  },
  association: function association(node) {
    var _dimensions$get2 = dimensions.get(node),
        nw = _dimensions$get2.w,
        nh = _dimensions$get2.h;

    var centerX = nw / 2;
    var centerY = nh / 2;
    var radius = (Math.min(nw, nh) - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', '#6A6A6A').set('fill-opacity', '0');

    var associationSvg = '\n      ' + baseShapes.circle(centerX, centerY, radius, styleMap) + '\n    ';
    return svgStr(associationSvg, nw, nh, 0, 0, nw, nh);
  },
  dissociation: function dissociation(node) {
    var _dimensions$get3 = dimensions.get(node),
        nw = _dimensions$get3.w,
        nh = _dimensions$get3.h;

    var centerX = nw / 2;
    var centerY = nh / 2;
    var outerRadius = (Math.min(nw, nh) - 2) / 2;
    var innerRadius = (Math.min(nw, nh) - 2) / 3;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var dissociationSvg = '\n      ' + baseShapes.circle(centerX, centerY, outerRadius, styleMap) + '\n      ' + baseShapes.circle(centerX, centerY, innerRadius, styleMap) + '\n    ';
    return svgStr(dissociationSvg, nw, nh, 0, 0, nw, nh);
  },
  phenotype: function phenotype(node) {
    var _dimensions$get4 = dimensions.get(node),
        nw = _dimensions$get4.w,
        nh = _dimensions$get4.h;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var shapeArgs = [1, 1, nw - 3, nh - 3];

    var phenotypeSvg = '\n      ' + baseShapes.hexagon.apply(baseShapes, shapeArgs.concat([styleMap])) + '\n      ' + (node.data('clonemarker') ? auxiliaryItems.cloneMarker(nw - 3, nh - 3, baseShapes.hexagon, shapeArgs) : '') + '\n    ';
    return svgStr(phenotypeSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = processNodes;

},{"../dimensions":119,"../util/svg":129,"./auxiliaryItems":121,"./baseShapes":122}],127:[function(_dereq_,module,exports){
'use strict';

var elementStyle = _dereq_('./element.js');

var sbgnShapes = _dereq_('./glyph');
var sbgnDimensions = _dereq_('./dimensions');

var isMultimer = _dereq_('./util/sbgn.js').isMultimer;
var hasAuxItems = _dereq_('./util/sbgn.js').hasAuxItems;

var sbgnStyleSheet = function sbgnStyleSheet(cytoscape) {

  return cytoscape.stylesheet()
  // general node style
  .selector('node').css({
    'shape': function shape(node) {
      return elementStyle.sbgnShape(node);
    },
    'content': function content(node) {
      return elementStyle.sbgnContent(node);
    },
    'font-size': function fontSize(node) {
      return elementStyle.labelTextSize(node);
    },
    'text-valign': 'center',
    'text-halign': 'center',
    'border-width': 1.5,
    'border-color': '#555',
    'background-color': '#f6f6f6',
    'background-opacity': 0.5,
    'text-opacity': 1,
    'opacity': 1
  }).selector('node:selected').css({
    'background-color': '#d67614',
    'target-arrow-color': '#000',
    'text-outline-color': '#000'
  }).selector('node:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '14'
  })

  // every process/entity pool node needs these properties
  .selector('\n          node[class="process"], node[class="uncertain process"], node[class="omitted process"],\n          node[class="association"], node[class="dissociation"],\n          node[class="phenotype"],\n          node[class="source and sink"],\n          node[class="perturbing agent"],\n          node[class="unspecified entity"],\n          node[class="nucleic acid feature"], node[class="nucleic acid feature multimer"],\n          node[class="macromolecule"], node[class="macromolecule multimer"],\n          node[class="simple chemical"], node[class="simple chemical multimer"]\n        ').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node);
    },
    'width': function width(node) {
      return sbgnDimensions.width(node);
    },
    'height': function height(node) {
      return sbgnDimensions.height(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  })

  // process node specific style
  .selector('node[class="association"], node[class="dissociation"]').css({
    'background-opacity': 1
  }).selector('node[class="association"]').css({
    'background-color': '#6B6B6B'
  })

  // entity pool node specific styles
  .selector('node[class="source and sink"]').css({
    'shape-polygon-points': '-0.86, 0.5, -0.75, 0.65, -1, 0.95, -0.95, 1, -0.65, 0.75, -0.5, 0.86, 0, 1, 0.5, 0.86, 0.71, 0.71, 0.86, 0.5, 1, 0, 0.86, -0.5, 0.75, -0.65, 1, -0.95, 0.95, -1, 0.65, -0.75, 0.5, -0.86, 0, -1, -0.5, -0.86, -0.71, -0.71, -0.86, -0.5, -1, 0'
  }).selector('node[class="tag"]').css({
    'width': function width(node) {
      return sbgnDimensions.width(node);
    },
    'height': function height(node) {
      return sbgnDimensions.height(node);
    },
    'shape-polygon-points': '-1, -1,   0.25, -1,   1, 0,    0.25, 1,    -1, 1'
  }).selector('node[class="perturbing agent"]').css({
    'shape-polygon-points': '-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95'
  })

  // entity pool nodes that have one or more of (units of information, state variables, multimer)
  .selector('\n          node[class="nucleic acid feature"], node[class="nucleic acid feature multimer"],\n          node[class="macromolecule"], node[class="macromolecule multimer"],\n          node[class="simple chemical"], node[class="simple chemical multimer"],\n          node[class="perturbing agent"]\n        ').css({
    'padding': function padding(node) {
      return isMultimer(node) || hasAuxItems(node) ? 5 : 0;
    },
    'background-width': function backgroundWidth(node) {
      return isMultimer(node) || hasAuxItems(node) ? '120%' : '100%';
    },
    'background-height': function backgroundHeight(node) {
      return isMultimer(node) || hasAuxItems(node) ? '120%' : '100%';
    }
  })

  // compound node specific style
  .selector('node[class="complex"], node[class="complex multimer"], node[class="compartment"]').css({
    'compound-sizing-wrt-labels': 'exclude',
    'background-opacity': .2,
    'text-valign': 'bottom',
    'text-halign': 'center',
    'min-width': function minWidth(node) {
      return sbgnDimensions.width(node);
    },
    'min-height': function minHeight(node) {
      return sbgnDimensions.height(node);
    }
  }).selector('node[class="compartment"]').css({
    'padding': '10%',
    'padding-relative-to': 'max'
  })

  // edge styling
  .selector('edge').css({
    'curve-style': 'bezier',
    'line-color': '#555',
    'target-arrow-fill': 'hollow',
    'source-arrow-fill': 'hollow',
    'width': 1.5,
    'target-arrow-color': '#555',
    'source-arrow-color': '#555',
    'text-border-color': '#555',
    'color': '#555'
  }).selector('edge:selected').css({
    'color': '#d67614',
    'line-color': '#d67614',
    'text-border-color': '#d67614',
    'source-arrow-color': '#d67614',
    'target-arrow-color': '#d67614'
  }).selector('edge:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '8'
  }).selector('edge[cardinality > 0]').css({
    'text-rotation': 'autorotate',
    'text-background-shape': 'rectangle',
    'text-border-opacity': '1',
    'text-border-width': '1',
    'text-background-color': 'white',
    'text-background-opacity': '1'
  }).selector('edge[class="consumption"][cardinality > 0], edge[class="production"][cardinality > 0]').css({
    'source-label': function sourceLabel(edge) {
      return '' + edge.data('cardinality');
    },
    'source-text-margin-y': '-10',
    'source-text-offset': function sourceTextOffset(edge) {
      return elementStyle.cardinalityDistance(edge);
    }
  }).selector('edge[class]').css({
    'target-arrow-shape': function targetArrowShape(edge) {
      return elementStyle.sbgnArrowShape(edge);
    },
    'source-arrow-shape': 'none'
  }).selector('edge[class="inhibition"]').css({
    'target-arrow-fill': 'filled'
  }).selector('edge[class="production"]').css({
    'target-arrow-fill': 'filled'
  })

  // core
  .selector('core').css({
    'selection-box-color': '#d67614',
    'selection-box-opacity': '0.2', 'selection-box-border-color': '#d67614'
  });
};

module.exports = sbgnStyleSheet;

},{"./dimensions":119,"./element.js":120,"./glyph":125,"./util/sbgn.js":128}],128:[function(_dereq_,module,exports){
'use strict';

var sbgnDataHandler = {
  isMultimer: function isMultimer(node) {
    return node.data('class').includes('multimer');
  },
  hasClonemarker: function hasClonemarker(node) {
    return node.data('clonemarker');
  },
  getStateVars: function getStateVars(node) {
    return node.data('stateVariables');
  },
  getUnitInfos: function getUnitInfos(node) {
    return node.data('unitsOfInformation');
  },
  hasAuxItems: function hasAuxItems(node) {
    return node.data('stateVariables').length + node.data('unitsOfInformation').length > 0;
  },
  sbgnClass: function sbgnClass(element) {
    return element.data('class');
  }
};

module.exports = sbgnDataHandler;

},{}],129:[function(_dereq_,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var styleMap2Str = function styleMap2Str(styleMap) {
  if (!styleMap) {
    return '';
  }

  var s = '';

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = styleMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          k = _step$value[0],
          v = _step$value[1];

      s += k + '=' + "'" + v + "'" + ' ';
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return s;
};

var svg = function svg(svgStr) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var vbX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var vbY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var vbWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
  var vbHeight = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 100;

  var parser = new DOMParser();
  var svgText = '<svg xmlns=\'http://www.w3.org/2000/svg\' version=\'1.1\' width=\'' + width + '\' height=\'' + height + '\' viewBox=\'' + vbX + ' ' + vbY + ' ' + vbWidth + ' ' + vbHeight + '\'>' + svgStr + '</svg>';
  return parser.parseFromString(svgText, 'text/xml').documentElement;
};

var svgStr = function svgStr(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight) {
  var s = svg(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight);
  var data = 'data:image/svg+xml;base64,' + btoa(s.outerHTML);

  return data;
};

module.exports = {
  svgStr: svgStr,
  styleMap2Str: styleMap2Str
};

},{}]},{},[117])(117)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy8tcHJlYW1ibGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvYS1zdGFyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2JlbGxtYW4tZm9yZC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vYWxnb3JpdGhtcy9iZXR3ZWVubmVzcy1jZW50cmFsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2Jmcy1kZnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvY2xvc2VuZXNzLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGVncmVlLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGlqa3N0cmEuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZmxveWQtd2Fyc2hhbGwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMva2VyZ2VyLXN0ZWluLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2tydXNrYWwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvcGFnZS1yYW5rLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9jb21wYXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vY29tcG91bmRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kZWdyZWUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2RpbWVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2VsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9ncm91cC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2l0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vbGF5b3V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9zdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vc3dpdGNoLWZ1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vdHJhdmVyc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24venNvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FkZC1yZW1vdmUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FuaW1hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9sYXlvdXQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL25vdGlmaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3NlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3ZpZXdwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXZlbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvYnJlYWR0aGZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY29uY2VudHJpYy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvbGF5b3V0L2Nvc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9ncmlkLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcHJlc2V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9iYXNlL2Fycm93LXNoYXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9jb29yZC1lbGUtbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9pbWFnZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvbG9hZC1saXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2Uvbm9kZS1zaGFwZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvcmVkcmF3LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvYXJyb3ctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1lZGdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctZWxlbWVudHMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLWltYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbGFiZWwtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbm9kZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLXJlZHJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZWxlLXRleHR1cmUtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9leHBvcnQtaW1hZ2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2xheWVyZWQtdGV4dHVyZS1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL25vZGUtc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvdGV4dHVyZS1jYWNoZS1kZWZzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvbnVsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2hlYXAuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2lzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2FwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvYnlwYXNzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvY29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvZ2V0LWZvci1lbGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2pzb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL3Byb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9zdHJpbmctc2hlZXQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZXNoZWV0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9jb2xvcnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy91dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9tYXBzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9yZWdleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvdGltaW5nLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZGVmYXVsdHNkZWVwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5tZW1vaXplL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9vYmplY3QtcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3htbC1qcy9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy94bWwtanMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy94bWwtanMvbGliL2pzMnhtbC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMveG1sLWpzL2xpYi9qc29uMnhtbC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMveG1sLWpzL2xpYi94bWwyanMuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3htbC1qcy9saWIveG1sMmpzb24uanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvc3JjL2VkZ2VzQ29udmVydGVyLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvbm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9zcmMvbm9kZXNDb252ZXJ0ZXIuanMiLCJub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L25vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL2Rpc3Qvc3JjL3NiZ25UYWdzLmpzIiwibm9kZV9tb2R1bGVzL3NiZ25tbC10by1jeXRvc2NhcGUvZGlzdC9ub2RlX21vZHVsZXMvc2Jnbm1sLXRvLWN5dG9zY2FwZS9kaXN0L3NyYy9zYmdubWxDb252ZXJ0ZXIuanMiLCJub2RlX21vZHVsZXMvdGV4dC13aWR0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9yZW5kZXJHcmFwaC5qcyIsInNyYy9zYmduU3R5bGUvZGltZW5zaW9ucy5qcyIsInNyYy9zYmduU3R5bGUvZWxlbWVudC5qcyIsInNyYy9zYmduU3R5bGUvZ2x5cGgvYXV4aWxpYXJ5SXRlbXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2Jhc2VTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2NvbnRhaW5lck5vZGVzLmpzIiwic3JjL3NiZ25TdHlsZS9nbHlwaC9lbnRpdHlQb29sTm9kZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2luZGV4LmpzIiwic3JjL3NiZ25TdHlsZS9nbHlwaC9wcm9jZXNzTm9kZXMuanMiLCJzcmMvc2JnblN0eWxlL2dyYXBoLmpzIiwic3JjL3NiZ25TdHlsZS91dGlsL3NiZ24uanMiLCJzcmMvc2JnblN0eWxlL3V0aWwvc3ZnLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3R0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2psQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2M0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9oQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTs7QUNEQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BMQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzU2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3aURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkEsSUFBTSxVQUFVLFFBQVEsYUFBUixDQUFoQjs7QUFFQSxJQUFNLFFBQVEsU0FBUixLQUFRLENBQUMsR0FBRDtBQUFBLFNBQVMsUUFBUSxHQUFSLENBQVksR0FBWixFQUFpQixnQkFBakIsQ0FBVDtBQUFBLENBQWQ7O0FBRUEsSUFBTSxXQUFXLFNBQVgsUUFBVyxDQUFDLEdBQUQ7QUFBQSxTQUFTLFFBQVEsR0FBUixDQUFZLEdBQVosRUFBaUIsbUJBQWpCLEVBQXNDLEVBQXRDLENBQVQ7QUFBQSxDQUFqQjs7QUFFQSxJQUFNLFlBQVksU0FBWixTQUFZLENBQUMsR0FBRCxFQUFNLFNBQU4sRUFBaUIsU0FBakIsRUFBK0I7QUFDL0MsTUFBTSxhQUFhLGNBQWMsR0FBZCxDQUFuQjtBQUNBLFNBQU8sVUFBVSxHQUFWLENBQWMsVUFBZCxJQUE0QixVQUE1QixHQUF5QyxVQUFVLEdBQVYsQ0FBYyxVQUFkLENBQWhEO0FBQ0QsQ0FIRDs7QUFLQSxJQUFNLFlBQVksU0FBWixTQUFZLENBQUMsR0FBRCxFQUFNLFNBQU4sRUFBaUIsU0FBakIsRUFBK0I7QUFDL0MsTUFBTSxhQUFhLGNBQWMsR0FBZCxDQUFuQjtBQUNBLFNBQU8sVUFBVSxHQUFWLENBQWMsVUFBZCxJQUE0QixVQUE1QixHQUF5QyxVQUFVLEdBQVYsQ0FBYyxVQUFkLENBQWhEO0FBQ0QsQ0FIRDs7QUFLQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFDLEdBQUQ7QUFBQSxTQUFTLFFBQVEsR0FBUixDQUFZLEdBQVosRUFBaUIsb0JBQWpCLEVBQXVDLEVBQXZDLENBQVQ7QUFBQSxDQUF0Qjs7QUFFQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFDLEdBQUQ7QUFBQSxTQUFTLFFBQVEsR0FBUixDQUFZLEdBQVosRUFBaUIsb0JBQWpCLEVBQXVDLEVBQXZDLENBQVQ7QUFBQSxDQUF0Qjs7QUFFQSxJQUFNLGlCQUFpQixTQUFqQixjQUFpQixDQUFDLEtBQUQ7QUFBQSxTQUFXLFNBQVMsUUFBUSxHQUFSLENBQVksS0FBWixFQUFtQix3QkFBbkIsRUFBNkMsRUFBN0MsQ0FBVCxDQUFYO0FBQUEsQ0FBdkI7O0FBRUEsSUFBTSx3QkFBd0IsU0FBeEIscUJBQXdCLENBQUMsR0FBRCxFQUFTO0FBQ3JDLFNBQU8sR0FBRyxNQUFILENBQVUsUUFBUSxHQUFSLENBQVksR0FBWixFQUFpQixNQUFqQixFQUF5QixFQUF6QixDQUFWLEVBQ04sR0FETSxDQUNGLFVBQUMsU0FBRCxFQUFlO0FBQ2xCLFdBQU87QUFDTCxTQUFHLFNBQVMsVUFBVSxDQUFuQixDQURFO0FBRUwsU0FBRyxTQUFTLFVBQVUsQ0FBbkI7QUFGRSxLQUFQO0FBSUQsR0FOTSxDQUFQO0FBT0QsQ0FSRDs7QUFXQSxJQUFNLGFBQWEsU0FBYixVQUFhLENBQUMsR0FBRCxFQUFNLFNBQU4sRUFBaUIsU0FBakIsRUFBK0I7QUFDaEQsU0FBTztBQUNMLFVBQU07QUFDSixVQUFJLE1BQU0sR0FBTixDQURBO0FBRUosZUFBUyxTQUFTLEdBQVQsQ0FGTDtBQUdKLG1CQUFhLElBQUksS0FBSixHQUFZLGVBQWUsSUFBSSxLQUFuQixDQUFaLEdBQXVDLENBSGhEO0FBSUosY0FBUSxVQUFVLEdBQVYsRUFBZSxTQUFmLEVBQTBCLFNBQTFCLENBSko7QUFLSixjQUFRLFVBQVUsR0FBVixFQUFlLFNBQWYsRUFBMEIsU0FBMUIsQ0FMSjtBQU1KLDBCQUFvQixzQkFBc0IsR0FBdEIsQ0FOaEI7QUFPSixrQkFBWSxjQUFjLEdBQWQsQ0FQUjtBQVFKLGtCQUFZLGNBQWMsR0FBZDtBQVJSO0FBREQsR0FBUDtBQVlELENBYkQ7O0FBZUEsSUFBTSxXQUFXLFNBQVgsUUFBVyxDQUFDLEdBQUQsRUFBTSxTQUFOLEVBQWlCLFNBQWpCLEVBQStCO0FBQzlDLE1BQU0sWUFBWSxVQUFVLEdBQVYsRUFBZSxTQUFmLEVBQTBCLFNBQTFCLENBQWxCO0FBQ0EsTUFBTSxZQUFZLFVBQVUsR0FBVixFQUFlLFNBQWYsRUFBMEIsU0FBMUIsQ0FBbEI7O0FBRUEsU0FBUSxVQUFVLEdBQVYsQ0FBYyxTQUFkLENBQUQsSUFBK0IsVUFBVSxHQUFWLENBQWMsU0FBZCxDQUF0QztBQUNELENBTEQ7O0FBT0EsSUFBTSxlQUFlLFNBQWYsWUFBZSxDQUFDLElBQUQsRUFBTyxTQUFQLEVBQWtCLFNBQWxCLEVBQWdDO0FBQ25ELFNBQU8sS0FDTixNQURNLENBQ0MsVUFBQyxHQUFEO0FBQUEsV0FBUyxTQUFTLEdBQVQsRUFBYyxTQUFkLEVBQXlCLFNBQXpCLENBQVQ7QUFBQSxHQURELEVBRU4sR0FGTSxDQUVGLFVBQUMsR0FBRDtBQUFBLFdBQVMsV0FBVyxHQUFYLEVBQWdCLFNBQWhCLEVBQTJCLFNBQTNCLENBQVQ7QUFBQSxHQUZFLENBQVA7QUFHRCxDQUpEO0FBS0EsT0FBTyxPQUFQLEdBQWlCLFlBQWpCOzs7OztBQzVEQSxJQUFJLFlBQVksUUFBUSxtQkFBUixDQUFoQjs7QUFHQSxPQUFPLE9BQVAsR0FBaUIsVUFBQyxJQUFELEVBQVU7QUFDekIsU0FBTyxVQUFVLElBQVYsQ0FBUDtBQUNELENBRkQ7Ozs7Ozs7QUNIQSxJQUFNLFVBQVUsUUFBUSxhQUFSLENBQWhCOztBQUVBLElBQU0saUJBQWlCLFFBQVEsWUFBUixDQUF2Qjs7QUFFQSxJQUFNLGtCQUFrQixTQUFsQixlQUFrQixDQUFDLEtBQUQsRUFBVztBQUFBLHFCQUNOLFFBQVEsR0FBUixDQUFZLEtBQVosRUFBbUIsa0JBQW5CLEVBQXVDLEVBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxDQUFWLEVBQWEsR0FBRyxDQUFoQixFQUFtQixHQUFHLENBQXRCLEVBQXZDLENBRE07QUFBQSxNQUMxQixDQUQwQixnQkFDNUIsQ0FENEI7QUFBQSxNQUNyQixDQURxQixnQkFDdkIsQ0FEdUI7QUFBQSxNQUNoQixDQURnQixnQkFDbEIsQ0FEa0I7QUFBQSxNQUNYLENBRFcsZ0JBQ2IsQ0FEYTs7QUFHakMsU0FBTztBQUNMLE9BQUcsV0FBVyxDQUFYLElBQWtCLFdBQVcsQ0FBWCxJQUFnQixDQURoQztBQUVMLE9BQUcsV0FBVyxDQUFYLElBQWtCLFdBQVcsQ0FBWCxJQUFnQixDQUZoQztBQUdMLE9BQUcsV0FBVyxDQUFYLENBSEU7QUFJTCxPQUFHLFdBQVcsQ0FBWDtBQUpFLEdBQVA7QUFNRCxDQVREOztBQVdBLElBQU0sUUFBUSxTQUFSLEtBQVEsQ0FBQyxLQUFEO0FBQUEsU0FBVyxRQUFRLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLGdCQUFuQixDQUFYO0FBQUEsQ0FBZDs7QUFFQSxJQUFNLFdBQVcsU0FBWCxRQUFXLENBQUMsS0FBRDtBQUFBLFNBQVcsUUFBUSxHQUFSLENBQVksS0FBWixFQUFtQixtQkFBbkIsRUFBd0MsRUFBeEMsQ0FBWDtBQUFBLENBQWpCOztBQUVBLElBQU0sV0FBVyxTQUFYLFFBQVcsQ0FBQyxLQUFEO0FBQUEsU0FBVyxRQUFRLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLHdCQUFuQixFQUE2QyxFQUE3QyxDQUFYO0FBQUEsQ0FBakI7O0FBRUEsSUFBTSxZQUFZLFNBQVosU0FBWSxDQUFDLEtBQUQ7QUFBQSxTQUFXLFFBQVEsR0FBUixDQUFZLEtBQVosRUFBbUIsNEJBQW5CLEVBQWlELEVBQWpELENBQVg7QUFBQSxDQUFsQjs7QUFFQSxJQUFNLGlCQUFpQixTQUFqQixjQUFpQixDQUFDLEtBQUQ7QUFBQSxTQUFXLE1BQU0sS0FBTixLQUFnQixTQUEzQjtBQUFBLENBQXZCOztBQUVBLElBQU0sV0FBVyxTQUFYLFFBQVcsQ0FBQyxLQUFELEVBQVc7QUFDMUIsU0FBTztBQUNMLGNBQVUsUUFBUSxHQUFSLENBQVksS0FBWixFQUFtQiw0QkFBbkIsRUFBaUQsRUFBakQsQ0FETDtBQUVMLFdBQU8sUUFBUSxHQUFSLENBQVksS0FBWixFQUFtQix5QkFBbkIsRUFBOEMsRUFBOUM7QUFGRixHQUFQO0FBSUQsQ0FMRDs7QUFPQSxJQUFNLGNBQWMsU0FBZCxXQUFjLENBQUMsS0FBRCxFQUFXO0FBQzdCLFNBQU87QUFDTCxRQUFJLE1BQU0sS0FBTixDQURDO0FBRUwsYUFBUyxTQUFTLEtBQVQsQ0FGSjtBQUdMLFdBQU8sU0FBUyxLQUFUO0FBSEYsR0FBUDtBQUtELENBTkQ7O0FBUUEsSUFBTSx1QkFBdUIsU0FBdkIsb0JBQXVCLENBQUMsS0FBRCxFQUFXO0FBQ3RDLFNBQU87QUFDTCxRQUFJLE1BQU0sS0FBTixDQURDO0FBRUwsYUFBUyxTQUFTLEtBQVQsQ0FGSjtBQUdMLFdBQU87QUFDTCxZQUFNLFFBQVEsR0FBUixDQUFZLEtBQVosRUFBbUIsd0JBQW5CLEVBQTZDLEVBQTdDO0FBREQ7QUFIRixHQUFQO0FBT0QsQ0FSRDs7QUFVQSxJQUFNLGVBQWUsU0FBZixZQUFlLENBQUMsS0FBRCxFQUFXO0FBQzlCLFNBQU8saUJBQWlCLEtBQWpCLEVBQ0osTUFESSxDQUNHLFVBQUMsS0FBRDtBQUFBLFdBQVksU0FBUyxLQUFULE1BQW9CLGdCQUFoQztBQUFBLEdBREgsRUFFSixHQUZJLENBRUEsVUFBQyxRQUFEO0FBQUEsV0FBYyxZQUFZLFFBQVosQ0FBZDtBQUFBLEdBRkEsQ0FBUDtBQUdELENBSkQ7O0FBTUEsSUFBTSx3QkFBd0IsU0FBeEIscUJBQXdCLENBQUMsS0FBRCxFQUFXO0FBQ3ZDLFNBQU8saUJBQWlCLEtBQWpCLEVBQ0osTUFESSxDQUNHLFVBQUMsS0FBRDtBQUFBLFdBQVksU0FBUyxLQUFULE1BQW9CLHFCQUFoQztBQUFBLEdBREgsRUFFSixHQUZJLENBRUEsVUFBQyxDQUFEO0FBQUEsV0FBTyxxQkFBcUIsQ0FBckIsQ0FBUDtBQUFBLEdBRkEsQ0FBUDtBQUdELENBSkQ7O0FBTUEsSUFBTSxjQUFjLFNBQWQsV0FBYyxDQUFDLEtBQUQsRUFBVztBQUM3QixTQUFPLGlCQUFpQixLQUFqQixFQUF3QixNQUF4QixDQUErQixVQUFDLEtBQUQsRUFBVztBQUMvQyxXQUFPLFNBQVMsS0FBVCxNQUFvQixxQkFBcEIsSUFBNkMsU0FBUyxLQUFULE1BQW9CLGdCQUF4RTtBQUNELEdBRk0sQ0FBUDtBQUdELENBSkQ7O0FBTUEsSUFBTSxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQUMsS0FBRCxFQUFXO0FBQ2xDLFNBQU8sR0FBRyxNQUFILENBQVUsUUFBUSxHQUFSLENBQVksS0FBWixFQUFtQixPQUFuQixFQUE0QixFQUE1QixDQUFWLENBQVA7QUFDRCxDQUZEOztBQUlBLElBQU0sZUFBZSxTQUFmLFlBQWUsQ0FBQyxLQUFELEVBQXNCO0FBQUEsTUFBZCxNQUFjLHVFQUFQLEVBQU87O0FBQ3pDLFNBQU87QUFDTCxVQUFNO0FBQ0osVUFBSSxNQUFNLEtBQU4sQ0FEQTtBQUVKLGVBQVMsU0FBUyxLQUFULENBRkw7QUFHSixhQUFPLFNBQVMsS0FBVCxDQUhIO0FBSUosY0FBUSxNQUFNLE1BQU4sSUFBZ0IsVUFBVSxLQUFWLENBQWhCLElBQW9DLE1BSnhDLEVBSWlEO0FBQ3JELG1CQUFhLGVBQWUsS0FBZixDQUxUO0FBTUosc0JBQWdCLGFBQWEsS0FBYixDQU5aO0FBT0osMEJBQW9CLHNCQUFzQixLQUF0QixDQVBoQjtBQVFKLFlBQU0sZ0JBQWdCLEtBQWhCO0FBUkY7QUFERCxHQUFQO0FBWUQsQ0FiRDtBQWNBLElBQU0sV0FBVyxTQUFYLFFBQVcsQ0FBQyxLQUFELEVBQVc7QUFDMUIsU0FBTyxHQUFHLE1BQUgsQ0FBVSxRQUFRLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLENBQVYsRUFBMEMsR0FBMUMsQ0FBOEMsVUFBQyxJQUFELEVBQVU7QUFDN0QsV0FBTztBQUNMLFVBQUksTUFBTSxJQUFOLENBREM7QUFFTCxZQUFNLGdCQUFnQixJQUFoQjtBQUZELEtBQVA7QUFJRCxHQUxNLENBQVA7QUFNRCxDQVBEOztBQVNBLE9BQU8sT0FBUCxHQUFpQixVQUFDLE1BQUQsRUFBWTtBQUMzQixNQUFNLFlBQVksSUFBSSxHQUFKLEVBQWxCO0FBQ0EsTUFBTSxZQUFZLElBQUksR0FBSixFQUFsQjtBQUNBLE1BQU0sUUFBUSxFQUFkO0FBQ0EsTUFBTSxRQUFRLEVBQWQ7O0FBRUEsUUFBTSxJQUFOLGlDQUFjLE1BQWQ7QUFDQSxTQUFPLE1BQU0sTUFBTixHQUFlLENBQXRCLEVBQXlCO0FBQ3ZCLFFBQU0sWUFBWSxNQUFNLEdBQU4sRUFBbEI7QUFDQSxRQUFNLGNBQWMsTUFBTSxTQUFOLENBQXBCO0FBQ0EsUUFBTSxpQkFBaUIsYUFBYSxTQUFiLENBQXZCOztBQUVBLFFBQUksZUFBZSxlQUFlLElBQWYsQ0FBb0IsT0FBcEIsQ0FBZixDQUFKLEVBQWtEO0FBQ2hELFlBQU0sSUFBTixDQUFXLGNBQVg7QUFDQSxnQkFBVSxHQUFWLENBQWMsV0FBZDs7QUFGZ0Q7QUFBQTtBQUFBOztBQUFBO0FBSWhELDZCQUFtQixTQUFTLFNBQVQsQ0FBbkIsOEhBQXdDO0FBQUEsY0FBN0IsSUFBNkI7O0FBQ3RDLG9CQUFVLEdBQVYsQ0FBYyxLQUFLLEVBQW5CLEVBQXVCLFdBQXZCO0FBQ0Q7QUFOK0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRaEQsVUFBTSxXQUFXLFlBQVksU0FBWixDQUFqQjtBQVJnRDtBQUFBO0FBQUE7O0FBQUE7QUFTaEQsOEJBQWtCLFFBQWxCLG1JQUE0QjtBQUFBLGNBQW5CLEtBQW1COztBQUMxQixnQkFBTSxNQUFOLEdBQWUsV0FBZjtBQUNEO0FBWCtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBYWhELFlBQU0sSUFBTixpQ0FBYyxRQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPO0FBQ0wsV0FBTyxLQURGO0FBRUwsZUFBVyxTQUZOO0FBR0wsZUFBVztBQUhOLEdBQVA7QUFLRCxDQWxDRDs7Ozs7QUM3RkEsSUFBTSxxQkFBcUIsSUFBSSxHQUFKLEdBQzFCLEdBRDBCLENBQ3RCLG9CQURzQixFQUUxQixHQUYwQixDQUV0QixpQkFGc0IsRUFHMUIsR0FIMEIsQ0FHdEIsZUFIc0IsRUFJMUIsR0FKMEIsQ0FJdEIsc0JBSnNCLEVBSzFCLEdBTDBCLENBS3RCLGtCQUxzQixFQU0xQixHQU4wQixDQU10QixpQkFOc0IsRUFPMUIsR0FQMEIsQ0FPdEIsU0FQc0IsRUFRMUIsR0FSMEIsQ0FRdEIsU0FSc0IsRUFTMUIsR0FUMEIsQ0FTdEIsaUJBVHNCLEVBVTFCLEdBVjBCLENBVXRCLG1CQVZzQixFQVcxQixHQVgwQixDQVd0QixhQVhzQixFQVkxQixHQVowQixDQVl0QixjQVpzQixFQWExQixHQWIwQixDQWF0QixXQWJzQixFQWMxQixHQWQwQixDQWN0QixLQWRzQixFQWUxQixHQWYwQixDQWV0QixhQWZzQixFQWdCMUIsR0FoQjBCLENBZ0J0QixZQWhCc0IsRUFpQjFCLEdBakIwQixDQWlCdEIsWUFqQnNCLEVBa0IxQixHQWxCMEIsQ0FrQnRCLGFBbEJzQixFQW1CMUIsR0FuQjBCLENBbUJ0QixXQW5Cc0IsRUFvQjFCLEdBcEIwQixDQW9CdEIsWUFwQnNCLEVBcUIxQixHQXJCMEIsQ0FxQnRCLHVCQXJCc0IsRUFzQjFCLEdBdEIwQixDQXNCdEIsV0F0QnNCLEVBdUIxQixHQXZCMEIsQ0F1QnRCLGlCQXZCc0IsRUF3QjFCLEdBeEIwQixDQXdCdEIsY0F4QnNCLEVBeUIxQixHQXpCMEIsQ0F5QnRCLGFBekJzQixFQTBCMUIsR0ExQjBCLENBMEJ0QixjQTFCc0IsRUEyQjFCLEdBM0IwQixDQTJCdEIsS0EzQnNCLEVBNEIxQixHQTVCMEIsQ0E0QnRCLElBNUJzQixFQTZCMUIsR0E3QjBCLENBNkJ0QixLQTdCc0IsRUE4QjFCLEdBOUIwQixDQThCdEIsK0JBOUJzQixFQStCMUIsR0EvQjBCLENBK0J0Qix3QkEvQnNCLEVBZ0MxQixHQWhDMEIsQ0FnQ3RCLDBCQWhDc0IsRUFpQzFCLEdBakMwQixDQWlDdEIsa0JBakNzQixFQWtDMUIsR0FsQzBCLENBa0N0QixhQWxDc0IsQ0FBM0I7O0FBb0NBLE9BQU8sT0FBUCxHQUFpQixVQUFDLFNBQUQ7QUFBQSxTQUFlLG1CQUFtQixHQUFuQixDQUF1QixTQUF2QixDQUFmO0FBQUEsQ0FBakI7Ozs7Ozs7QUN0Q0EsSUFBTSxVQUFVLFFBQVEsUUFBUixDQUFoQjtBQUNBLElBQU0sVUFBVSxRQUFRLGFBQVIsQ0FBaEI7O0FBRUEsSUFBTSxpQkFBaUIsUUFBUSxrQkFBUixDQUF2QjtBQUNBLElBQU0saUJBQWlCLFFBQVEsa0JBQVIsQ0FBdkI7O0FBR0EsT0FBTyxPQUFQLEdBQWlCLFVBQUMsVUFBRCxFQUFnQjs7QUFFL0IsTUFBSSxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBSSxLQUFKLFFBQWMsVUFBZCx3QkFBTjtBQUNEOztBQUVELE1BQU0sWUFBWSxRQUFRLE1BQVIsQ0FBZSxVQUFmLEVBQTJCLEVBQUMsU0FBUyxJQUFWLEVBQWdCLFFBQVEsQ0FBeEIsRUFBMkIsTUFBTSxJQUFqQyxFQUF1QyxZQUFZLElBQW5ELEVBQTNCLENBQWxCOztBQUVBLE1BQU0sU0FBUyxRQUFRLEdBQVIsQ0FBWSxTQUFaLEVBQXVCLFVBQXZCLEVBQW1DLFNBQW5DLENBQWY7QUFDQSxNQUFJLFdBQVcsU0FBZixFQUEwQjtBQUN4QixXQUFPLEVBQUMsT0FBTyxFQUFSLEVBQVksT0FBTyxFQUFuQixFQUFQO0FBQ0Q7O0FBRUQsTUFBTSxTQUFTLEVBQWY7QUFDQSxNQUFNLE9BQU8sRUFBYjtBQUNBLE1BQUksT0FBTyxLQUFYLEVBQWtCO0FBQ2hCLFdBQU8sSUFBUCxrQ0FBZSxPQUFPLEtBQXRCO0FBQ0Q7QUFDRCxNQUFJLE9BQU8sR0FBWCxFQUFnQjtBQUNkLFNBQUssSUFBTCxnQ0FBYSxPQUFPLEdBQXBCO0FBQ0Q7O0FBcEI4Qix3QkFzQnlCLGVBQWUsTUFBZixDQXRCekI7QUFBQSxNQXNCakIsS0F0QmlCLG1CQXNCeEIsS0F0QndCO0FBQUEsTUFzQkMsU0F0QkQsbUJBc0JWLFNBdEJVO0FBQUEsTUFzQlksU0F0QlosbUJBc0JZLFNBdEJaOztBQXVCL0IsTUFBTSxRQUFRLGVBQWUsSUFBZixFQUFxQixTQUFyQixFQUFnQyxTQUFoQyxDQUFkOztBQUVBLFNBQU8sRUFBQyxPQUFPLEtBQVIsRUFBZSxPQUFPLEtBQXRCLEVBQVA7QUFDRCxDQTFCRDs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNuQkEsSUFBSSxZQUFZLFFBQVEsV0FBUixDQUFoQjtBQUNBLElBQUksZUFBZSxRQUFRLHFCQUFSLENBQW5COztBQUVBLElBQUksaUJBQWlCLFFBQVEsbUJBQVIsQ0FBckI7QUFDQSxJQUFJLGNBQWMsUUFBUSxlQUFSLENBQWxCOztBQUVBLElBQUksaUJBQWlCO0FBQ25CLHVCQUFxQixJQURGO0FBRW5CLGVBQWEsS0FGTTtBQUduQixXQUFTLEtBSFU7QUFJbkIsV0FBUyxLQUpVO0FBS25CLGNBQVksS0FMTztBQU1uQixvQkFBa0I7QUFOQyxDQUFyQjs7SUFTTSxZOzs7QUFDSix3QkFBYSxPQUFiLEVBQXNCO0FBQUE7O0FBQ3BCLGNBQVUsYUFBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBQVY7O0FBRUEsUUFBSSxDQUFDLFFBQVEsS0FBYixFQUFvQjtBQUNsQixjQUFRLEtBQVIsR0FBZ0IsZUFBZSxTQUFmLENBQWhCO0FBQ0Q7O0FBTG1CLHVIQU9iLGFBQWMsRUFBZCxFQUFrQixjQUFsQixFQUFrQyxPQUFsQyxDQVBhO0FBUXJCOzs7RUFUd0IsUzs7QUFZM0IsYUFBYSxVQUFiLEdBQTBCLFlBQVU7QUFDbEMsU0FBTyxlQUFlLFNBQWYsQ0FBUDtBQUNELENBRkQ7O0FBSUEsYUFBYSxXQUFiLEdBQTJCLFdBQTNCOztBQUdBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7Ozs7QUNsQ0EsSUFBTSxnQkFBZ0IsUUFBUSxxQkFBUixDQUF0Qjs7QUFFQSxJQUFNLDBCQUEwQixTQUExQix1QkFBMEIsQ0FBQyxFQUFELEVBQVE7QUFDdEMsTUFBTSxzQkFBc0IsR0FBRyxLQUFILENBQVMsdUJBQVQsRUFBa0MsUUFBbEMsRUFBNUI7QUFDQSxzQkFBb0IsUUFBcEIsQ0FBNkIsVUFBQyxHQUFEO0FBQUEsV0FBUyxJQUFJLFlBQUosR0FBbUIsTUFBbkIsS0FBOEIsQ0FBdkM7QUFBQSxHQUE3QixFQUF1RSxNQUF2RTs7QUFFQSxNQUFNLGdCQUFnQixHQUFHLEtBQUgsQ0FBUywrRUFBVCxDQUF0QjtBQUNBLGdCQUFjLFFBQWQsQ0FBdUIsVUFBQyxHQUFEO0FBQUEsV0FBUyxDQUFDLElBQUksT0FBSixFQUFELElBQWtCLElBQUksWUFBSixDQUFpQixNQUFqQixLQUE0QixDQUF2RDtBQUFBLEdBQXZCLEVBQWlGLE1BQWpGO0FBQ0QsQ0FORDs7QUFRQSxJQUFNLG9DQUFvQyxTQUFwQyxpQ0FBb0MsQ0FBQyxFQUFELEVBQVE7QUFDaEQsS0FBRyxjQUFILENBQWtCO0FBQ2hCLGFBQVMsS0FETztBQUVoQixhQUFTLElBRk87QUFHaEIsY0FBVSxLQUhNO0FBSWhCLGdCQUFZO0FBSkksR0FBbEI7O0FBT0EsS0FBRyxLQUFILEdBQVcsRUFBWCxDQUFjLDRCQUFkLEVBQTRDLFVBQVUsR0FBVixFQUFlO0FBQ3pELFFBQU0sT0FBTyxJQUFJLE1BQWpCO0FBQ0EsT0FBRyxjQUFILENBQWtCLEtBQWxCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLE1BQWhCLENBQXVCO0FBQ3JCLFlBQUssTUFEZ0I7QUFFckIsV0FBSyxPQUZnQjtBQUdyQixvQkFBYyxJQUhPO0FBSXJCLGdCQUFVLElBSlc7QUFLckIsWUFBTSxLQUFLLFFBQUwsR0FBZ0IsSUFBaEIsS0FBeUIsQ0FMVjtBQU1yQixZQUFNLEtBQUssUUFBTCxHQUFnQixJQUFoQixLQUF5QixDQU5WO0FBT3JCLG1CQUFhLEtBQUssV0FBTDtBQVBRLEtBQXZCLEVBUUcsR0FSSDtBQVNBLE9BQUcsY0FBSCxDQUFrQixJQUFsQjtBQUNELEdBYkQ7O0FBZUEsTUFBTSxZQUFZLEdBQUcsS0FBSCxDQUFTLCtDQUFULENBQWxCO0FBQ0EsTUFBTSxNQUFNLEdBQUcsY0FBSCxDQUFrQixLQUFsQixDQUFaOztBQUVBLE1BQUksUUFBSixDQUFhLFNBQWI7O0FBRUEsS0FBRyxFQUFILENBQU0sS0FBTixFQUFhLHVEQUFiLEVBQXNFLEVBQXRFLEVBQTBFLFVBQUMsR0FBRCxFQUFTOztBQUVqRixRQUFNLE9BQU8sSUFBSSxNQUFqQjtBQUNBLFFBQUksSUFBSSxhQUFKLENBQWtCLElBQWxCLENBQUosRUFBNkI7QUFDM0IsVUFBSSxtQkFBSixDQUF3QixJQUF4QjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksTUFBSixDQUFXLElBQVg7QUFDRDtBQUNGLEdBUkQ7QUFTRCxDQXJDRDs7QUF3Q0EsSUFBTSx3QkFBd0IsU0FBeEIscUJBQXdCLENBQUMsRUFBRCxFQUFRO0FBQ3BDLDBCQUF3QixFQUF4QjtBQUNBLG9DQUFrQyxFQUFsQztBQUNELENBSEQ7O0FBS0EsSUFBTSxjQUFjLFNBQWQsV0FBYyxDQUFDLEVBQUQsRUFBSyxVQUFMLEVBQW9CO0FBQ3RDLE1BQU0sWUFBWSxjQUFjLFVBQWQsQ0FBbEI7O0FBRUEsS0FBRyxLQUFILENBQVMsWUFBVTtBQUNqQixPQUFHLE1BQUgsQ0FBVSxHQUFWO0FBQ0EsT0FBRyxHQUFILENBQU8sU0FBUDs7QUFFQSxRQUFJLGdCQUFnQixFQUFwQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLEtBQVYsQ0FBZ0IsTUFBcEMsRUFBNEMsR0FBNUMsRUFBaUQ7QUFDL0MsVUFBSSxPQUFPLFVBQVUsS0FBVixDQUFnQixDQUFoQixFQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUE2QixDQUF4QztBQUNBLFVBQUksT0FBTyxVQUFVLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBNkIsQ0FBeEM7QUFDQSxvQkFBYyxVQUFVLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUIsSUFBbkIsQ0FBd0IsRUFBdEMsSUFBNEMsRUFBQyxLQUFLLElBQU4sRUFBWSxLQUFLLElBQWpCLEVBQTVDO0FBQ0Q7O0FBRUQsT0FBRyxNQUFILENBQVU7QUFDUixZQUFNLFFBREU7QUFFUixpQkFBVyxhQUZIO0FBR1IsV0FBSyxJQUhHO0FBSVIsZUFBUztBQUpELEtBQVYsRUFLRyxHQUxIO0FBTUQsR0FqQkQ7O0FBbUJBLHdCQUFzQixFQUF0QjtBQUNELENBdkJEOztBQXlCQSxPQUFPLE9BQVAsR0FBaUIsV0FBakI7Ozs7O0FDaEZBLElBQU0sV0FBVyxRQUFRLGdCQUFSLENBQWpCOztBQUVBLElBQU0scUJBQXFCLElBQUksR0FBSixHQUMxQixHQUQwQixDQUN0QixvQkFEc0IsRUFDQSxFQUFDLEdBQUcsRUFBSixFQUFRLEdBQUcsRUFBWCxFQURBLEVBRTFCLEdBRjBCLENBRXRCLGlCQUZzQixFQUVILEVBQUMsR0FBRyxFQUFKLEVBQVEsR0FBRyxFQUFYLEVBRkcsRUFHMUIsR0FIMEIsQ0FHdEIsMEJBSHNCLEVBR00sRUFBQyxHQUFHLEVBQUosRUFBUSxHQUFHLEVBQVgsRUFITixFQUkxQixHQUowQixDQUl0QixlQUpzQixFQUlMLEVBQUMsR0FBRyxHQUFKLEVBQVMsR0FBRyxFQUFaLEVBSkssRUFLMUIsR0FMMEIsQ0FLdEIsd0JBTHNCLEVBS0ksRUFBQyxHQUFHLEdBQUosRUFBUyxHQUFHLEVBQVosRUFMSixFQU0xQixHQU4wQixDQU10QixzQkFOc0IsRUFNRSxFQUFDLEdBQUcsR0FBSixFQUFTLEdBQUcsRUFBWixFQU5GLEVBTzFCLEdBUDBCLENBT3RCLCtCQVBzQixFQU9XLEVBQUMsR0FBRyxHQUFKLEVBQVMsR0FBRyxFQUFaLEVBUFgsRUFRMUIsR0FSMEIsQ0FRdEIsU0FSc0IsRUFRWCxFQUFDLEdBQUcsRUFBSixFQUFRLEdBQUcsRUFBWCxFQVJXLEVBUzFCLEdBVDBCLENBU3RCLGtCQVRzQixFQVNGLEVBQUMsR0FBRyxHQUFKLEVBQVMsR0FBRyxHQUFaLEVBVEUsRUFVMUIsR0FWMEIsQ0FVdEIsaUJBVnNCLEVBVUgsRUFBQyxHQUFHLEVBQUosRUFBUSxHQUFHLEVBQVgsRUFWRyxFQVcxQixHQVgwQixDQVd0QixrQkFYc0IsRUFXRixFQUFDLEdBQUcsR0FBSixFQUFTLEdBQUcsRUFBWixFQVhFLEVBYTFCLEdBYjBCLENBYXRCLFdBYnNCLEVBYVQsRUFBQyxHQUFHLEdBQUosRUFBUyxHQUFHLEVBQVosRUFiUyxFQWMxQixHQWQwQixDQWN0QixTQWRzQixFQWNYLEVBQUMsR0FBRSxFQUFILEVBQU8sR0FBRyxFQUFWLEVBZFcsRUFlMUIsR0FmMEIsQ0FldEIsbUJBZnNCLEVBZUQsRUFBQyxHQUFFLEVBQUgsRUFBTyxHQUFHLEVBQVYsRUFmQyxFQWdCMUIsR0FoQjBCLENBZ0J0QixpQkFoQnNCLEVBZ0JILEVBQUMsR0FBRSxFQUFILEVBQU8sR0FBRyxFQUFWLEVBaEJHLEVBaUIxQixHQWpCMEIsQ0FpQnRCLGFBakJzQixFQWlCUCxFQUFDLEdBQUUsRUFBSCxFQUFPLEdBQUcsRUFBVixFQWpCTyxFQWtCMUIsR0FsQjBCLENBa0J0QixjQWxCc0IsRUFrQk4sRUFBQyxHQUFFLEVBQUgsRUFBTyxHQUFHLEVBQVYsRUFsQk0sRUFvQjFCLEdBcEIwQixDQW9CdEIsYUFwQnNCLEVBb0JQLEVBQUMsR0FBRyxHQUFKLEVBQVMsR0FBRyxHQUFaLEVBcEJPLEVBc0IxQixHQXRCMEIsQ0FzQnRCLEtBdEJzQixFQXNCZixFQUFDLEdBQUcsR0FBSixFQUFTLEdBQUcsRUFBWixFQXRCZSxFQXVCMUIsR0F2QjBCLENBdUJ0QixLQXZCc0IsRUF1QmYsRUFBQyxHQUFHLEVBQUosRUFBUSxHQUFHLEVBQVgsRUF2QmUsRUF3QjFCLEdBeEIwQixDQXdCdEIsSUF4QnNCLEVBd0JoQixFQUFDLEdBQUcsRUFBSixFQUFRLEdBQUcsRUFBWCxFQXhCZ0IsRUF5QjFCLEdBekIwQixDQXlCdEIsS0F6QnNCLEVBeUJmLEVBQUMsR0FBRyxFQUFKLEVBQVEsR0FBRyxFQUFYLEVBekJlLENBQTNCOztBQTZCQSxJQUFNLE1BQU0sU0FBTixHQUFNLENBQUMsSUFBRCxFQUFVO0FBQ3BCLE1BQU0sWUFBWSxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBbEI7QUFDQSxNQUFNLE1BQU0sbUJBQW1CLEdBQW5CLENBQXVCLFNBQXZCLENBQVo7QUFDQSxNQUFJLFFBQVEsU0FBWixFQUF1QjtBQUNyQixVQUFNLElBQUksU0FBSixDQUFpQixTQUFqQiw2Q0FBTjtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0QsQ0FQRDs7QUFTQSxJQUFNLFFBQVEsU0FBUixLQUFRLENBQUMsSUFBRCxFQUFVO0FBQ3RCLFNBQU8sSUFBSSxJQUFKLEVBQVUsQ0FBakI7QUFDRCxDQUZEOztBQUlBLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxJQUFELEVBQVU7QUFDdkIsU0FBTyxJQUFJLElBQUosRUFBVSxDQUFqQjtBQUNELENBRkQ7O0FBSUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2YsVUFBUSxNQURPO0FBRWYsU0FBTyxLQUZRO0FBR2YsT0FBSztBQUhVLENBQWpCOzs7OztBQ2hEQSxJQUFNLFdBQVcsUUFBUSxnQkFBUixDQUFqQjtBQUNBLElBQUksZUFBZSxFQUFuQjs7QUFFQSxhQUFhLFNBQWIsR0FBeUIsVUFBQyxJQUFELEVBQVU7QUFDakMsTUFBSSxZQUFZLFNBQVMsU0FBVCxDQUFtQixJQUFuQixDQUFoQjtBQUNBLE1BQUksVUFBVSxRQUFWLENBQW1CLFdBQW5CLENBQUosRUFBcUM7QUFDbkMsZ0JBQVksVUFBVSxPQUFWLENBQWtCLFdBQWxCLEVBQStCLEVBQS9CLENBQVo7QUFDRDs7QUFFRCxNQUFJLGFBQWEsV0FBakIsRUFBOEI7QUFDNUIsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLGFBQWpCLEVBQWdDO0FBQzlCLFdBQU8sUUFBUDtBQUNEOztBQUVELE1BQUksYUFBYSxTQUFiLElBQTBCLGFBQWEsaUJBQXZDLElBQTRELGFBQWEsbUJBQTdFLEVBQWtHO0FBQ2hHLFdBQU8sUUFBUDtBQUNEOztBQUVELE1BQUksYUFBYSxrQkFBYixJQUFtQyxhQUFhLEtBQWhELElBQ0MsYUFBYSxpQkFEbEIsRUFDcUM7QUFDbkMsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLGNBQWIsSUFBK0IsYUFBYSxhQUE1QyxJQUE2RCxhQUFhLGlCQUE5RSxFQUFpRztBQUMvRixXQUFPLFNBQVA7QUFDRDs7QUFFRCxNQUFLLGFBQWEsc0JBQWIsSUFBdUMsYUFBYSxlQUF6RCxFQUEwRTtBQUN4RSxXQUFPLGdCQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLFNBQWpCLEVBQTRCO0FBQzFCLFdBQU8sY0FBUDtBQUNEO0FBQ0QsU0FBTyxTQUFQO0FBQ0QsQ0FuQ0Q7O0FBcUNBLGFBQWEsY0FBYixHQUE4QixVQUFDLElBQUQsRUFBVTtBQUN0QyxNQUFJLFlBQVksU0FBUyxTQUFULENBQW1CLElBQW5CLENBQWhCO0FBQ0EsTUFBSSxhQUFhLHVCQUFqQixFQUEwQztBQUN4QyxXQUFPLGdCQUFQO0FBQ0Q7QUFDRCxNQUFJLGFBQWEsWUFBakIsRUFBK0I7QUFDN0IsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJLGFBQWEsV0FBakIsRUFBOEI7QUFDNUIsV0FBTyxRQUFQO0FBQ0Q7QUFDRCxNQUFJLGFBQWEsYUFBYixJQUE4QixhQUFhLFlBQS9DLEVBQTZEO0FBQzNELFdBQU8sVUFBUDtBQUNEO0FBQ0QsTUFBSSxhQUFhLFlBQWpCLEVBQStCO0FBQzdCLFdBQU8sU0FBUDtBQUNEO0FBQ0QsU0FBTyxNQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBLGFBQWEsV0FBYixHQUEyQixVQUFDLElBQUQsRUFBVTtBQUNuQyxNQUFJLFlBQVksU0FBUyxTQUFULENBQW1CLElBQW5CLENBQWhCO0FBQ0EsTUFBSSxVQUFVLEVBQWQ7O0FBRUEsTUFBSSxVQUFVLFFBQVYsQ0FBbUIsV0FBbkIsQ0FBSixFQUFxQztBQUNuQyxnQkFBWSxVQUFVLE9BQVYsQ0FBa0IsV0FBbEIsRUFBK0IsRUFBL0IsQ0FBWjtBQUNEOztBQUVELE1BQUksYUFBYSxlQUFiLElBQWdDLGFBQWEsaUJBQTdDLElBQ0csYUFBYSxXQURoQixJQUVHLGFBQWEsb0JBRmhCLElBRXdDLGFBQWEsc0JBRnJELElBR0csYUFBYSxrQkFIaEIsSUFHc0MsYUFBYSxLQUh2RCxFQUc4RDtBQUM1RCxjQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsSUFBcUIsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFyQixHQUEwQyxFQUFwRDtBQUNELEdBTEQsTUFNSyxJQUFHLGFBQWEsYUFBaEIsRUFBOEI7QUFDakMsY0FBVSxLQUFLLElBQUwsQ0FBVSxPQUFWLElBQXFCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBckIsR0FBMEMsRUFBcEQ7QUFDRCxHQUZJLE1BR0EsSUFBRyxhQUFhLFNBQWhCLEVBQTBCO0FBQzdCLFFBQUcsS0FBSyxRQUFMLEdBQWdCLE1BQWhCLElBQTBCLENBQTdCLEVBQStCO0FBQzdCLFVBQUcsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFILEVBQXNCO0FBQ3BCLGtCQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBVjtBQUNELE9BRkQsTUFHSyxJQUFHLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBSCxFQUEwQjtBQUM3QixrQkFBVSxLQUFLLElBQUwsQ0FBVSxXQUFWLENBQVY7QUFDRCxPQUZJLE1BR0Q7QUFDRixrQkFBVSxFQUFWO0FBQ0Q7QUFDRixLQVZELE1BV0k7QUFDRixnQkFBVSxFQUFWO0FBQ0Q7QUFDRixHQWZJLE1BZ0JBLElBQUksYUFBYSxLQUFqQixFQUF3QjtBQUMzQixjQUFVLEtBQVY7QUFDRCxHQUZJLE1BR0EsSUFBSSxhQUFhLElBQWpCLEVBQXVCO0FBQzFCLGNBQVUsSUFBVjtBQUNELEdBRkksTUFHQSxJQUFJLGFBQWEsS0FBakIsRUFBd0I7QUFDM0IsY0FBVSxLQUFWO0FBQ0QsR0FGSSxNQUdBLElBQUksYUFBYSxpQkFBakIsRUFBb0M7QUFDdkMsY0FBVSxNQUFWO0FBQ0QsR0FGSSxNQUdBLElBQUksYUFBYSxtQkFBakIsRUFBc0M7QUFDekMsY0FBVSxHQUFWO0FBQ0Q7O0FBRUQsU0FBTyxPQUFQO0FBQ0QsQ0FsREQ7O0FBb0RBLElBQU0sdUJBQXVCLFNBQXZCLG9CQUF1QixDQUFDLFVBQUQsRUFBcUM7QUFBQSxNQUF4QixlQUF3Qix1RUFBTixDQUFNOztBQUNoRSxTQUFRLGFBQWEsSUFBZCxHQUFzQixlQUE3QjtBQUNELENBRkQ7O0FBSUEsYUFBYSxhQUFiLEdBQTZCLFVBQUMsSUFBRCxFQUFVO0FBQ3JDLE1BQU0sWUFBWSxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBbEI7QUFDQSxNQUFNLEtBQUssRUFBWCxDQUZxQyxDQUV0Qjs7QUFFZjtBQUNBO0FBQ0EsTUFBSSxjQUFjLGFBQWQsSUFBK0IsY0FBYyxjQUFqRCxFQUFpRTtBQUMvRCxXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJLGNBQWMsS0FBZCxJQUF1QixjQUFjLElBQXJDLElBQTZDLGNBQWMsS0FBL0QsRUFBc0U7QUFDcEUsV0FBTyxxQkFBcUIsRUFBckIsRUFBeUIsQ0FBekIsQ0FBUDtBQUNEOztBQUVELE1BQUksVUFBVSxRQUFWLENBQW1CLFNBQW5CLENBQUosRUFBbUM7QUFDakMsV0FBTyxxQkFBcUIsRUFBckIsRUFBeUIsR0FBekIsQ0FBUDtBQUNEOztBQUVELE1BQUksVUFBVSxRQUFWLENBQW1CLFNBQW5CLENBQUosRUFBbUM7QUFDakMsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSSxjQUFjLGFBQWxCLEVBQWlDO0FBQy9CLFdBQU8sRUFBUDtBQUNEOztBQUVELFNBQU8scUJBQXFCLEVBQXJCLENBQVA7QUFDRCxDQTNCRDs7QUE2QkEsYUFBYSxtQkFBYixHQUFtQyxVQUFDLElBQUQsRUFBVTtBQUMzQyxNQUFNLFNBQVMsS0FBSyxNQUFMLEdBQWMsUUFBZCxFQUFmO0FBQ0EsTUFBTSxTQUFTLEtBQUssTUFBTCxHQUFjLFFBQWQsRUFBZjs7QUFFQSxNQUFNLFdBQVcsS0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLENBQVUsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUE1QixFQUFnQyxDQUFoQyxJQUFxQyxLQUFLLEdBQUwsQ0FBVSxPQUFPLENBQVAsR0FBVyxPQUFPLENBQTVCLEVBQWdDLENBQWhDLENBQS9DLENBQWpCO0FBQ0EsU0FBTyxXQUFXLElBQWxCO0FBQ0QsQ0FORDs7QUFRQSxPQUFPLE9BQVAsR0FBaUIsWUFBakI7Ozs7Ozs7QUN6SkEsSUFBTSxZQUFZLFFBQVEsWUFBUixDQUFsQjs7QUFFQSxJQUFNLGFBQWEsUUFBUSxpQkFBUixDQUFuQjs7QUFFQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFDLFFBQUQsRUFBYztBQUNsQyxNQUFNLFdBQVcsU0FBUyxLQUFULENBQWUsUUFBaEM7QUFDQSxNQUFNLFFBQVEsU0FBUyxLQUFULENBQWUsS0FBN0I7QUFDQSxNQUFJLFNBQVMsUUFBYixFQUF1QjtBQUNyQixXQUFVLEtBQVYsU0FBbUIsUUFBbkI7QUFDRDtBQUNELE1BQUksS0FBSixFQUFXO0FBQ1QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSSxRQUFKLEVBQWM7QUFDWixXQUFPLFFBQVA7QUFDRDtBQUNELFNBQU8sRUFBUDtBQUNELENBZEQ7O0FBZ0JBLElBQU0saUJBQWlCO0FBRXJCLGVBRnFCLHlCQUVOLENBRk0sRUFFSCxDQUZHLEVBRUEsTUFGQSxFQUVRLFFBRlIsRUFFa0I7O0FBRXJDLFFBQU0sV0FBVyxFQUFqQjs7QUFFQSxRQUFNLGdCQUFnQixJQUFJLEdBQUosR0FDckIsR0FEcUIsQ0FDakIsUUFEaUIsRUFDUCxTQURPLEVBRXJCLEdBRnFCLENBRWpCLGNBRmlCLEVBRUQsS0FGQyxFQUdyQixHQUhxQixDQUdqQixNQUhpQixFQUdULE9BSFMsRUFJckIsR0FKcUIsQ0FJakIsY0FKaUIsRUFJRCxHQUpDLENBQXRCOztBQU1BLFFBQU0sWUFBWSxJQUFJLEdBQUosR0FDakIsR0FEaUIsQ0FDYixvQkFEYSxFQUNTLFFBRFQsRUFFakIsR0FGaUIsQ0FFYixXQUZhLE9BRUcsUUFGSCxFQUdqQixHQUhpQixDQUdiLGFBSGEsRUFHRSx1Q0FIRixFQUlqQixHQUppQixDQUliLGFBSmEsRUFJRSxRQUpGLEVBS2pCLEdBTGlCLENBS2IsUUFMYSxFQUtILE9BTEcsQ0FBbEI7O0FBT0EsUUFBTSxLQUFLLFVBQVUsY0FBYyxRQUFkLEVBQXdCLEVBQUUsUUFBUSxVQUFVLEdBQVYsQ0FBYyxhQUFkLENBQVYsRUFBd0MsTUFBTSxRQUE5QyxFQUF4QixDQUFWLEVBQTRGLEVBQTVGLENBQVg7QUFDQSxRQUFNLGdCQUFnQixLQUFLLEdBQUwsQ0FBUyxLQUFLLEVBQWQsRUFBa0IsRUFBbEIsQ0FBdEI7O0FBRUEsUUFBTSxnQ0FFRixXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsYUFBekIsRUFBd0MsTUFBeEMsRUFBZ0QsYUFBaEQsQ0FGRSxnQkFHRixXQUFXLElBQVgsQ0FBZ0IsY0FBYyxRQUFkLENBQWhCLEVBQXlDLENBQXpDLEVBQTRDLENBQTVDLEVBQStDLFNBQS9DLENBSEUsV0FBTjs7QUFNQSxXQUFPLGdCQUFQO0FBQ0QsR0E3Qm9CO0FBK0JyQixtQkEvQnFCLDZCQStCRixDQS9CRSxFQStCQyxDQS9CRCxFQStCSSxLQS9CSixFQStCVyxNQS9CWCxFQStCbUIsUUEvQm5CLEVBK0I2Qjs7QUFFaEQsUUFBTSxXQUFXLEVBQWpCO0FBQ0EsUUFBTSxPQUFPLFNBQVMsS0FBVCxDQUFlLElBQTVCOztBQUVBLFFBQU0saUJBQWlCLElBQUksR0FBSixHQUN0QixHQURzQixDQUNsQixRQURrQixFQUNSLFNBRFEsRUFFdEIsR0FGc0IsQ0FFbEIsY0FGa0IsRUFFRixLQUZFLEVBR3RCLEdBSHNCLENBR2xCLE1BSGtCLEVBR1YsT0FIVSxFQUl0QixHQUpzQixDQUlsQixjQUprQixFQUlGLEdBSkUsQ0FBdkI7O0FBTUEsUUFBTSxZQUFZLElBQUksR0FBSixHQUNqQixHQURpQixDQUNiLG9CQURhLEVBQ1MsUUFEVCxFQUVqQixHQUZpQixDQUViLFdBRmEsT0FFRyxRQUZILEVBR2pCLEdBSGlCLENBR2IsYUFIYSxFQUdFLHVDQUhGLEVBSWpCLEdBSmlCLENBSWIsYUFKYSxFQUlFLFFBSkYsRUFLakIsR0FMaUIsQ0FLYixRQUxhLEVBS0gsT0FMRyxDQUFsQjs7QUFPQSxRQUFNLGFBQWEsVUFBVSxJQUFWLEVBQWdCLEVBQUUsUUFBUSxVQUFVLEdBQVYsQ0FBYyxhQUFkLENBQVYsRUFBd0MsTUFBTSxRQUE5QyxFQUFoQixJQUEyRSxDQUE5Rjs7QUFFQSxRQUFNLG9DQUVGLFdBQVcsY0FBWCxDQUEwQixJQUFLLGFBQWEsQ0FBNUMsRUFBZ0QsQ0FBaEQsRUFBbUQsVUFBbkQsRUFBK0QsTUFBL0QsRUFBdUUsY0FBdkUsQ0FGRSxnQkFHRixXQUFXLElBQVgsQ0FBZ0IsU0FBUyxLQUFULENBQWUsSUFBL0IsRUFBcUMsQ0FBckMsRUFBd0MsSUFBTSxTQUFTLENBQXZELEVBQTRELFNBQTVELENBSEUsV0FBTjs7QUFNQSxXQUFPLG9CQUFQO0FBQ0QsR0ExRG9CO0FBNERyQixhQTVEcUIsdUJBNERSLFNBNURRLEVBNERHLFVBNURILEVBNERlLE9BNURmLEVBNER3QixXQTVEeEIsRUE0RHFDO0FBQ3hELFFBQU0sU0FBUyxhQUFmOztBQUVBLFFBQU0sbUJBQW1CLElBQUksR0FBSixHQUN4QixHQUR3QixDQUNwQixRQURvQixFQUNWLFNBRFUsRUFFeEIsR0FGd0IsQ0FFcEIsY0FGb0IsRUFFSixLQUZJLEVBR3hCLEdBSHdCLENBR3BCLFdBSG9CLFlBR0MsTUFIRCxRQUl4QixHQUp3QixDQUlwQixNQUpvQixFQUlaLFNBSlksQ0FBekI7O0FBTUEsUUFBTSw4QkFFRixXQUFXLFFBQVgsQ0FBb0IsTUFBcEIsRUFBNEIsV0FBVyxTQUF2QyxFQUFtRCxDQUFDLENBQUQsRUFBSSxJQUFJLFVBQUosR0FBaUIsQ0FBckIsRUFBd0IsU0FBeEIsRUFBbUMsVUFBbkMsRUFBK0MsSUFBSSxHQUFKLEVBQS9DLENBQW5ELENBRkUsZ0JBR0YsNENBQVcsV0FBWCxVQUF3QixnQkFBeEIsR0FIRSxXQUFOOztBQU1BLFdBQU8sY0FBUDtBQUNELEdBNUVvQjtBQThFckIsVUE5RXFCLG9CQThFWCxPQTlFVyxFQThFRixXQTlFRSxFQThFVztBQUM5QixRQUFNLFNBQVMsVUFBZjs7QUFFQSxRQUFNLGdCQUFnQixJQUFJLEdBQUosR0FDckIsR0FEcUIsQ0FDakIsUUFEaUIsRUFDUCxTQURPLEVBRXJCLEdBRnFCLENBRWpCLE1BRmlCLEVBRVQsTUFGUyxFQUdyQixHQUhxQixDQUdqQixjQUhpQixFQUdELEdBSEMsRUFJckIsR0FKcUIsQ0FJakIsV0FKaUIsWUFJSSxNQUpKLE9BQXRCOztBQU1BLFFBQU0sMkJBRUYsV0FBVyxRQUFYLENBQW9CLE1BQXBCLEVBQTRCLE9BQTVCLEVBQXFDLFdBQXJDLEVBQWtELElBQUksR0FBSixFQUFsRCxDQUZFLGdCQUdGLDRDQUFXLFdBQVgsVUFBd0IsYUFBeEIsR0FIRSxXQUFOO0FBS0EsV0FBTyxXQUFQO0FBQ0Q7QUE3Rm9CLENBQXZCOztBQWdHQSxPQUFPLE9BQVAsR0FBaUIsY0FBakI7Ozs7Ozs7QUNwSEEsSUFBTSxlQUFlLFFBQVEsZ0JBQVIsRUFBMEIsWUFBL0M7O0FBRUEsSUFBSSxnQkFBZ0IsU0FBaEIsYUFBZ0IsQ0FBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixFQUF0QixFQUEwQixFQUExQixFQUE4QixFQUE5QixFQUFrQyxFQUFsQyxFQUFzQyxRQUF0QyxFQUFnRDtBQUNsRSx3QkFDUSxhQUFhLFFBQWIsQ0FEUixzQkFFTSxJQUFJLEVBRlYsVUFFZ0IsQ0FGaEIsaUJBR00sSUFBSSxDQUFKLEdBQVEsRUFIZCxVQUdvQixDQUhwQixZQUcyQixJQUFJLENBSC9CLFVBR29DLENBSHBDLFVBR3lDLElBQUksQ0FIN0MsV0FHa0QsSUFBSSxFQUh0RCxrQkFJTSxJQUFJLENBSlYsV0FJZ0IsSUFBSSxDQUFKLEdBQVEsRUFKeEIsYUFJZ0MsSUFBSSxDQUpwQyxXQUl5QyxJQUFJLENBSjdDLFdBSWtELElBQUksQ0FBSixHQUFRLEVBSjFELFdBSWdFLElBQUksQ0FKcEUsa0JBS00sSUFBSSxFQUxWLFdBS2dCLElBQUksQ0FMcEIsWUFLMkIsQ0FMM0IsVUFLZ0MsSUFBSSxDQUxwQyxVQUt5QyxDQUx6QyxVQUs4QyxJQUFJLENBQUosR0FBUSxFQUx0RCxpQkFNTSxDQU5OLFVBTVcsSUFBSSxFQU5mLFlBTXVCLENBTnZCLFNBTTRCLENBTjVCLFVBTWlDLElBQUksRUFOckMsVUFNMkMsQ0FOM0M7QUFVRCxDQVhEOztBQWFBLElBQU0sYUFBYTtBQUNqQixRQURpQixrQkFDVCxDQURTLEVBQ04sQ0FETSxFQUNILEtBREcsRUFDSSxNQURKLEVBQ1ksUUFEWixFQUNzQjtBQUNyQywyQkFFSyxhQUFhLFFBQWIsQ0FGTCw2QkFHZSxJQUFFLEtBQUYsR0FBVSxDQUh6QixXQUc4QixNQUFJLE1BQUosR0FBYSxDQUgzQyxhQUdrRCxJQUFFLEtBQUYsR0FBVSxDQUg1RCxXQUdpRSxNQUFJLE1BQUosR0FBYSxDQUg5RSxhQUdxRixPQUFLLEtBQUwsR0FBYSxDQUhsRyxXQUd1RyxTQUFTLENBSGhILFdBR3FILE9BQUssS0FBTCxHQUFhLENBSGxJLFdBR3VJLFNBQVMsQ0FIaEosa0NBS2UsT0FBSyxLQUFMLEdBQWEsQ0FMNUIsV0FLaUMsU0FBUyxDQUwxQyxhQUtpRCxPQUFLLEtBQUwsR0FBYSxDQUw5RCxXQUttRSxTQUFTLENBTDVFLGFBS21GLE9BQUssS0FBTCxHQUFhLENBTGhHLFdBS3FHLFNBQVMsQ0FMOUcsV0FLbUgsUUFBUSxDQUwzSCxXQUtnSSxPQUFLLE1BQUwsR0FBYyxDQUw5SSxrQ0FPZSxRQUFRLENBUHZCLFdBTzRCLE1BQUksTUFBSixHQUFhLENBUHpDLGFBT2dELFFBQVEsQ0FQeEQsV0FPNkQsT0FBSyxNQUFMLEdBQWMsQ0FQM0UsYUFPa0YsUUFBUSxDQVAxRixXQU8rRixJQUFFLE1BQUYsR0FBVyxDQVAxRyxXQU8rRyxPQUFLLEtBQUwsR0FBYSxDQVA1SCxXQU9pSSxJQUFFLE1BQUYsR0FBVyxDQVA1SSxrQ0FTZSxPQUFLLEtBQUwsR0FBYSxDQVQ1QixXQVNpQyxJQUFFLE1BQUYsR0FBVyxDQVQ1QyxhQVNtRCxPQUFLLEtBQUwsR0FBYSxDQVRoRSxXQVNxRSxJQUFFLE1BQUYsR0FBVyxDQVRoRixhQVN1RixPQUFLLEtBQUwsR0FBYSxDQVRwRyxXQVN5RyxJQUFFLE1BQUYsR0FBVyxDQVRwSCxXQVN5SCxJQUFFLEtBQUYsR0FBVSxDQVRuSSxXQVN3SSxPQUFLLE1BQUwsR0FBYyxDQVR0SjtBQWFELEdBZmdCO0FBaUJqQixRQWpCaUIsa0JBaUJULEVBakJTLEVBaUJMLEVBakJLLEVBaUJELENBakJDLEVBaUJFLFFBakJGLEVBaUJZO0FBQzNCLDZCQUFzQixFQUF0QixnQkFBaUMsRUFBakMsZUFBMkMsQ0FBM0MsV0FBaUQsYUFBYSxRQUFiLENBQWpEO0FBQ0QsR0FuQmdCO0FBcUJqQixVQXJCaUIsb0JBcUJQLEVBckJPLEVBcUJILFdBckJHLEVBcUJVLGVBckJWLEVBcUIyQixRQXJCM0IsRUFxQnFDO0FBQ3BELHVEQUVvQixFQUZwQixXQUUyQixhQUFhLFFBQWIsQ0FGM0IsbUJBR00sZ0RBQWUsZUFBZixFQUhOO0FBT0QsR0E3QmdCO0FBK0JqQixnQkEvQmlCLDBCQStCRCxDQS9CQyxFQStCRSxDQS9CRixFQStCSyxLQS9CTCxFQStCWSxNQS9CWixFQStCb0IsUUEvQnBCLEVBK0I4QjtBQUM3QywrQkFDVyxhQUFhLFFBQWIsQ0FEWCwwQkFFWSxJQUFJLENBRmhCLFlBRXNCLElBQUksQ0FGMUIsWUFFZ0MsSUFBSSxLQUZwQyxZQUU4QyxJQUFJLENBRmxELFlBRXdELElBQUksT0FBSyxLQUZqRSxZQUUyRSxJQUFJLE1BQUksTUFGbkYsWUFFOEYsSUFBSSxLQUZsRyxZQUU0RyxJQUFJLE1BRmhILFlBRTJILElBQUksQ0FGL0gsWUFFcUksSUFBSSxNQUZ6SSxZQUVxSixJQUFJLE9BQUssS0FGOUosWUFFd0ssSUFBSSxNQUFJLE1BRmhMO0FBSUQsR0FwQ2dCO0FBc0NqQixjQXRDaUIsd0JBc0NILENBdENHLEVBc0NBLENBdENBLEVBc0NHLEtBdENILEVBc0NVLE1BdENWLEVBc0NrQixZQXRDbEIsRUFzQ2dDLFFBdENoQyxFQXNDMEM7QUFDekQsK0JBQ1csYUFBYSxRQUFiLENBRFgsa0NBR0ksSUFBSSxJQUFFLEtBSFYsV0FHbUIsSUFBSSxZQUh2QixXQUd1QyxJQUFJLFlBSDNDLFdBRzJELElBQUksSUFBRSxNQUhqRSxXQUcyRSxJQUFJLEtBQUosR0FBWSxZQUh2RixXQUd1RyxJQUFJLElBQUUsTUFIN0csV0FHdUgsSUFBSSxLQUgzSCxXQUdvSSxJQUFJLFlBSHhJLGtCQUlJLElBQUksS0FKUixXQUlpQixJQUFJLE1BQUosR0FBYSxZQUo5QixXQUk4QyxJQUFJLEtBQUosR0FBWSxZQUoxRCxXQUkwRSxJQUFJLE1BSjlFLFdBSXdGLElBQUksWUFKNUYsV0FJNEcsSUFBSSxNQUpoSCxXQUkwSCxJQUFJLElBQUUsS0FKaEksV0FJeUksSUFBSSxNQUFKLEdBQWEsWUFKdEo7QUFRRCxHQS9DZ0I7QUFpRGpCLFNBakRpQixtQkFpRFIsRUFqRFEsRUFpREosRUFqREksRUFpREEsRUFqREEsRUFpREksRUFqREosRUFpRFEsUUFqRFIsRUFpRGtCO0FBQ2pDLHNDQUNpQixFQURqQixnQkFDNEIsRUFENUIsZ0JBQ3VDLEVBRHZDLGdCQUNrRCxFQURsRCxXQUN5RCxhQUFhLFFBQWIsQ0FEekQ7QUFHRCxHQXJEZ0I7QUF1RGpCLFNBdkRpQixtQkF1RFIsQ0F2RFEsRUF1REwsQ0F2REssRUF1REYsS0F2REUsRUF1REssTUF2REwsRUF1RGEsUUF2RGIsRUF1RHVCO0FBQ3RDLCtCQUNXLGFBQWEsUUFBYixDQURYLDBCQUVZLElBQUksQ0FGaEIsWUFFc0IsSUFBSSxNQUFJLE1BRjlCLFlBRXlDLElBQUksT0FBSyxLQUZsRCxZQUU0RCxJQUFJLElBQUUsTUFGbEUsWUFFNkUsSUFBSSxPQUFLLEtBRnRGLFlBRWdHLElBQUksSUFBRSxNQUZ0RyxZQUVpSCxJQUFJLEtBRnJILFlBRStILElBQUksTUFBSSxNQUZ2SSxZQUVrSixJQUFJLE9BQUssS0FGM0osWUFFcUssSUFBSSxNQUZ6SyxZQUVvTCxJQUFJLE9BQUssS0FGN0wsWUFFdU0sSUFBSSxNQUYzTTtBQUlELEdBNURnQjtBQThEakIsTUE5RGlCLGdCQThEWCxFQTlEVyxFQThEUCxFQTlETyxFQThESCxFQTlERyxFQThEQyxFQTlERCxFQThESyxRQTlETCxFQThEZTtBQUM5QiwyQkFBb0IsRUFBcEIsZ0JBQStCLEVBQS9CLGdCQUEwQyxFQUExQyxnQkFBcUQsRUFBckQsV0FBNEQsYUFBYSxRQUFiLENBQTVEO0FBQ0QsR0FoRWdCO0FBa0VqQixXQWxFaUIscUJBa0VOLENBbEVNLEVBa0VILENBbEVHLEVBa0VBLEtBbEVBLEVBa0VPLE1BbEVQLEVBa0VlLFFBbEVmLEVBa0V5QjtBQUN4QyxXQUFPLGNBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixLQUFwQixFQUEyQixNQUEzQixFQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxDQUE1QyxFQUErQyxRQUEvQyxDQUFQO0FBQ0QsR0FwRWdCO0FBc0VqQixzQkF0RWlCLGdDQXNFSyxDQXRFTCxFQXNFUSxDQXRFUixFQXNFVyxLQXRFWCxFQXNFa0IsTUF0RWxCLEVBc0UwQixRQXRFMUIsRUFzRW9DO0FBQ25ELFdBQU8sY0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCLEVBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLEtBQUcsTUFBNUMsRUFBb0QsS0FBRyxNQUF2RCxFQUErRCxRQUEvRCxDQUFQO0FBQ0QsR0F4RWdCO0FBMEVqQixnQkExRWlCLDBCQTBFRCxDQTFFQyxFQTBFRSxDQTFFRixFQTBFSyxLQTFFTCxFQTBFWSxNQTFFWixFQTBFb0IsUUExRXBCLEVBMEU4QjtBQUM3QyxXQUFPLGNBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixLQUFwQixFQUEyQixNQUEzQixFQUFtQyxLQUFHLEtBQXRDLEVBQTZDLEtBQUcsS0FBaEQsRUFBdUQsS0FBRyxLQUExRCxFQUFpRSxLQUFHLEtBQXBFLEVBQTJFLFFBQTNFLENBQVA7QUFDRCxHQTVFZ0I7QUE4RWpCLFFBOUVpQixrQkE4RVQsQ0E5RVMsRUE4RU4sQ0E5RU0sRUE4RUgsTUE5RUcsRUE4RUssUUE5RUwsRUE4RWU7QUFDOUIsV0FBTyxjQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsTUFBcEIsRUFBNEIsTUFBNUIsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsRUFBMEMsQ0FBMUMsRUFBNkMsQ0FBN0MsRUFBZ0QsUUFBaEQsQ0FBUDtBQUNELEdBaEZnQjtBQWtGakIsTUFsRmlCLGdCQWtGWCxDQWxGVyxFQWtGUixDQWxGUSxFQWtGTCxDQWxGSyxFQWtGRixRQWxGRSxFQWtGUTtBQUN2QiwwQkFBbUIsQ0FBbkIsZUFBNEIsQ0FBNUIsV0FBa0MsYUFBYSxRQUFiLENBQWxDLFNBQTRELENBQTVEO0FBQ0Q7QUFwRmdCLENBQW5COztBQXlGQSxPQUFPLE9BQVAsR0FBaUIsVUFBakI7Ozs7Ozs7QUN4R0EsSUFBTSxTQUFTLFFBQVEsYUFBUixFQUF1QixNQUF0QztBQUNBLElBQU0sV0FBVyxRQUFRLGNBQVIsQ0FBakI7O0FBRUEsSUFBTSxpQkFBaUIsUUFBUSxrQkFBUixDQUF2QjtBQUNBLElBQU0sYUFBYSxRQUFRLGNBQVIsQ0FBbkI7O0FBRUEsSUFBTSxpQkFBaUI7QUFFckIsYUFGcUIsdUJBRVIsSUFGUSxFQUVGO0FBQ2pCLFFBQU0sS0FBSyxLQUFLLFdBQUwsRUFBWDtBQUNBLFFBQU0sS0FBSyxLQUFLLFVBQUwsRUFBWDs7QUFFQSxRQUFNLFFBQVEsSUFBSSxHQUFKLEdBQ1gsR0FEVyxDQUNQLGNBRE8sRUFDUyxNQURULEVBRVgsR0FGVyxDQUVQLE1BRk8sRUFFQyxNQUZELEVBR1gsR0FIVyxDQUdQLFFBSE8sRUFHRyxTQUhILENBQWQ7O0FBS0EsUUFBTSxZQUFZLFNBQVMsWUFBVCxDQUFzQixJQUF0QixDQUFsQjtBQUNBLFFBQU0sU0FBUyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsTUFBSSxFQUFsQixDQUFmO0FBQ0EsUUFBTSxTQUFTLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxNQUFJLEVBQWpCLENBQWY7O0FBRUEsUUFBSSxZQUFZLENBQUMsRUFBRCxFQUFLLENBQUwsRUFBUSxLQUFLLEVBQWIsRUFBaUIsS0FBSyxFQUF0QixDQUFoQjs7QUFFQSxRQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixrQkFBWSxDQUFDLEVBQUQsRUFBTSxTQUFTLENBQWYsRUFBbUIsS0FBSyxFQUF4QixFQUE0QixLQUFLLEVBQWpDLENBQVo7QUFDRDs7QUFFRCxRQUFNLDhCQUVGLFdBQVcsTUFBWCxzQ0FBcUIsU0FBckIsVUFBZ0MsS0FBaEMsR0FGRSxpQkFHRixVQUFVLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIsZUFBZSxpQkFBZixDQUFrQyxLQUFLLENBQXZDLEVBQTJDLENBQTNDLEVBQThDLE1BQTlDLEVBQXNELE1BQXRELEVBQThELFVBQVUsQ0FBVixDQUE5RCxDQUF2QixHQUFxRyxFQUhuRyxZQUFOO0FBS0EsV0FBTyxPQUFPLGNBQVAsRUFBdUIsRUFBdkIsRUFBMkIsRUFBM0IsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsRUFBcUMsRUFBckMsRUFBeUMsRUFBekMsQ0FBUDtBQUNEO0FBM0JvQixDQUF2Qjs7QUE4QkEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7Ozs7O0FDcENBLElBQU0sVUFBVSxRQUFRLGdCQUFSLENBQWhCOztBQUVBLElBQU0sYUFBYSxRQUFRLGNBQVIsQ0FBbkI7QUFDQSxJQUFNLGlCQUFpQixRQUFRLGtCQUFSLENBQXZCOztBQUVBLElBQU0sU0FBUyxRQUFRLGFBQVIsRUFBdUIsTUFBdEM7QUFDQSxJQUFNLGVBQWUsUUFBUSxjQUFSLEVBQXdCLFlBQTdDO0FBQ0EsSUFBTSxlQUFlLFFBQVEsY0FBUixFQUF3QixZQUE3QztBQUNBLElBQU0saUJBQWlCLFFBQVEsY0FBUixFQUF3QixjQUEvQztBQUNBLElBQU0sYUFBYSxRQUFRLGNBQVIsRUFBd0IsVUFBM0M7QUFDQSxJQUFNLGFBQWEsUUFBUSxlQUFSLENBQW5COztBQUdBLElBQU0sa0JBQWtCO0FBRXRCLG1CQUZzQiw2QkFFSCxJQUZHLEVBRUc7QUFBQSwwQkFDQSxXQUFXLEdBQVgsQ0FBZSxJQUFmLENBREE7QUFBQSxRQUNiLEVBRGEsbUJBQ2hCLENBRGdCO0FBQUEsUUFDTixFQURNLG1CQUNULENBRFM7O0FBR3ZCLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLE1BSEksQ0FBakI7O0FBS0EsUUFBSSxZQUFZLENBQUMsS0FBSyxDQUFOLEVBQVMsS0FBSyxDQUFkLEVBQWlCLENBQUUsS0FBSyxDQUFQLElBQWEsQ0FBOUIsRUFBaUMsQ0FBRSxLQUFLLENBQVAsSUFBYSxDQUE5QyxDQUFoQjs7QUFFQSxRQUFJLCtCQUVBLFdBQVcsT0FBWCxtQkFBc0IsU0FBdEIsU0FBaUMsUUFBakMsR0FGQSxpQkFHQSxlQUFlLElBQWYsSUFBdUIsZUFBZSxXQUFmLENBQTJCLEVBQTNCLEVBQStCLEVBQS9CLEVBQW1DLFdBQVcsT0FBOUMsRUFBdUQsU0FBdkQsQ0FBdkIsR0FBMkYsRUFIM0YsWUFBSjtBQUtBLFdBQU8sT0FBTyxlQUFQLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLEVBQXRDLEVBQTBDLEVBQTFDLENBQVA7QUFDRCxHQWxCcUI7QUFvQnRCLGdCQXBCc0IsMEJBb0JOLElBcEJNLEVBb0JBO0FBQUEsMkJBQ0csV0FBVyxHQUFYLENBQWUsSUFBZixDQURIO0FBQUEsUUFDVixFQURVLG9CQUNiLENBRGE7QUFBQSxRQUNILEVBREcsb0JBQ04sQ0FETTs7QUFLcEIsUUFBTSxXQUFXLElBQUksR0FBSixHQUNoQixHQURnQixDQUNaLFFBRFksRUFDRixTQURFLEVBRWhCLEdBRmdCLENBRVosY0FGWSxFQUVJLEdBRkosRUFHaEIsR0FIZ0IsQ0FHWixNQUhZLEVBR0osT0FISSxFQUloQixHQUpnQixDQUlaLGNBSlksRUFJSSxHQUpKLENBQWpCOztBQU1BLFFBQU0sb0JBQW9CLENBQUMsQ0FBQyxLQUFLLENBQU4sSUFBVyxDQUFaLEVBQWUsQ0FBQyxLQUFLLENBQU4sSUFBVyxDQUExQixFQUE2QixDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQW5CLEdBQXVCLENBQXhCLElBQTZCLENBQTFELENBQTFCO0FBQ0EsUUFBSSxZQUFZLENBQUUsRUFBRCxHQUFPLENBQVIsRUFBWSxFQUFELEdBQU8sQ0FBbEIsRUFBcUIsQ0FBQyxLQUFLLEdBQUwsQ0FBUyxFQUFULEVBQWEsRUFBYixJQUFtQixDQUFwQixJQUF5QixDQUE5QyxDQUFoQjs7QUFFQSxRQUFNLFNBQVMsYUFBYSxJQUFiLENBQWY7QUFDQSxRQUFJLE9BQU8sTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNyQixrQkFBWSxDQUFFLEVBQUQsR0FBTyxDQUFSLEVBQVksRUFBRCxHQUFPLENBQWxCLEVBQXFCLENBQUMsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBbkIsR0FBd0IsQ0FBekIsSUFBOEIsQ0FBbkQsQ0FBWjtBQUNEOztBQUVELFFBQUksV0FBVyxJQUFYLENBQUosRUFBc0I7QUFDcEIsa0JBQVksQ0FBQyxDQUFDLEtBQUssQ0FBTixJQUFXLENBQVosRUFBZSxDQUFDLEtBQUssQ0FBTixJQUFXLENBQTFCLEVBQTZCLENBQUMsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBbkIsR0FBdUIsQ0FBeEIsSUFBNkIsQ0FBMUQsQ0FBWjtBQUNEOztBQUVELFFBQU0sa0NBRUYsV0FBVyxJQUFYLElBQW1CLGVBQWUsUUFBZixDQUF3QixXQUFXLE1BQW5DLEVBQTJDLGlCQUEzQyxDQUFuQixHQUFtRixFQUZqRixpQkFHRixXQUFXLE1BQVgsc0NBQXFCLFNBQXJCLFVBQWdDLFFBQWhDLEdBSEUsaUJBSUYsZUFBZSxJQUFmLElBQXVCLGVBQWUsV0FBZixDQUEyQixFQUEzQixFQUErQixFQUEvQixFQUFtQyxXQUFXLE1BQTlDLEVBQXNELFNBQXRELENBQXZCLEdBQTBGLEVBSnhGLGtCQUtGLE9BQU8sTUFBUCxHQUFnQixDQUFoQixHQUFvQixlQUFlLGlCQUFmLENBQWtDLEtBQUssQ0FBdkMsRUFBMkMsQ0FBM0MsRUFBOEMsTUFBSSxFQUFsRCxFQUFzRCxNQUFJLEVBQTFELEVBQThELE9BQU8sQ0FBUCxDQUE5RCxDQUFwQixHQUErRixFQUw3RixZQUFOOztBQVFBLFdBQU8sT0FBTyxpQkFBUCxFQUEwQixFQUExQixFQUE4QixFQUE5QixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxFQUF4QyxFQUE0QyxFQUE1QyxDQUFQO0FBQ0QsR0FwRHFCOzs7QUFzRHRCLGlCQUFlLFFBQVMsVUFBUyxJQUFULEVBQWU7QUFBQSwyQkFDZCxXQUFXLEdBQVgsQ0FBZSxJQUFmLENBRGM7QUFBQSxRQUMzQixFQUQyQixvQkFDOUIsQ0FEOEI7QUFBQSxRQUNwQixFQURvQixvQkFDdkIsQ0FEdUI7O0FBR3JDLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLE1BSEksRUFJaEIsR0FKZ0IsQ0FJWixNQUpZLEVBSUosT0FKSSxFQUtoQixHQUxnQixDQUtaLGNBTFksRUFLSSxHQUxKLENBQWpCOztBQU9BLFFBQU0sb0JBQW9CLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxLQUFHLEVBQVosRUFBZ0IsS0FBRyxFQUFuQixDQUExQjtBQUNBLFFBQUksWUFBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sS0FBSyxFQUFaLEVBQWdCLEtBQUssRUFBckIsQ0FBaEI7O0FBRUEsUUFBTSxTQUFTLGFBQWEsSUFBYixDQUFmO0FBQ0EsUUFBTSxRQUFRLGFBQWEsSUFBYixDQUFkOztBQUVBLFFBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGtCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxLQUFHLEVBQVYsRUFBYyxLQUFHLEVBQWpCLENBQVo7QUFDRDs7QUFFRCxRQUFJLE1BQU0sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGdCQUFVLENBQVYsSUFBZSxNQUFJLEVBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxXQUFXLElBQVgsQ0FBSixFQUFzQjtBQUNwQixrQkFBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sTUFBSSxFQUFYLEVBQWUsTUFBSSxFQUFuQixDQUFaO0FBQ0Q7O0FBRUQsUUFBSSxpQ0FFQSxXQUFXLElBQVgsSUFBbUIsZUFBZSxRQUFmLENBQXdCLFdBQVcsY0FBbkMsRUFBbUQsaUJBQW5ELENBQW5CLEdBQTJGLEVBRjNGLGlCQUdBLFdBQVcsY0FBWCxzQ0FBNkIsU0FBN0IsVUFBd0MsUUFBeEMsR0FIQSxpQkFJQSxlQUFlLElBQWYsSUFBdUIsZUFBZSxXQUFmLENBQTJCLEtBQUssQ0FBaEMsRUFBbUMsS0FBSyxDQUF4QyxFQUEyQyxXQUFXLGNBQXRELEVBQXNFLFNBQXRFLENBQXZCLEdBQTBHLEVBSjFHLGtCQUtBLE9BQU8sTUFBUCxHQUFnQixDQUFoQixHQUFvQixlQUFlLGlCQUFmLENBQWtDLEtBQUssQ0FBdkMsRUFBMkMsQ0FBM0MsRUFBOEMsTUFBSSxFQUFsRCxFQUFzRCxNQUFJLEVBQTFELEVBQThELE9BQU8sQ0FBUCxDQUE5RCxDQUFwQixHQUErRixFQUwvRixrQkFNQSxNQUFNLE1BQU4sR0FBZSxDQUFmLEdBQW1CLGVBQWUsYUFBZixDQUE4QixJQUFJLEVBQUosR0FBUyxDQUF2QyxFQUEyQyxLQUFNLFFBQU0sRUFBTixHQUFXLENBQTVELEVBQWdFLE1BQUksRUFBcEUsRUFBd0UsTUFBTSxDQUFOLENBQXhFLENBQW5CLEdBQXVHLEVBTnZHLFlBQUo7QUFRQSxXQUFPLE9BQU8sZ0JBQVAsRUFBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsRUFBdkMsRUFBMkMsRUFBM0MsQ0FBUDtBQUNELEdBckNjLEVBcUNaLFNBQVMscUJBQVQsQ0FBZ0MsSUFBaEMsRUFBc0M7QUFDdkMsV0FBTyxLQUNMLEtBQUssVUFBTCxFQURLLEdBQ2UsR0FEZixHQUVMLEtBQUssV0FBTCxFQUZLLEdBRWdCLEdBRmhCLEdBR0wsS0FBSyxTQUFMLENBQWdCLEtBQUssSUFBTCxFQUFoQixDQUhGO0FBS0QsR0EzQ2MsQ0F0RE87O0FBbUd0QixvQkFuR3NCLDhCQW1HRixJQW5HRSxFQW1HSTtBQUFBLDJCQUNELFdBQVcsR0FBWCxDQUFlLElBQWYsQ0FEQztBQUFBLFFBQ2QsRUFEYyxvQkFDakIsQ0FEaUI7QUFBQSxRQUNQLEVBRE8sb0JBQ1YsQ0FEVTs7QUFJeEIsUUFBTSxXQUFXLElBQUksR0FBSixHQUNoQixHQURnQixDQUNaLFFBRFksRUFDRixTQURFLEVBRWhCLEdBRmdCLENBRVosY0FGWSxFQUVJLEdBRkosRUFHaEIsR0FIZ0IsQ0FHWixNQUhZLEVBR0osTUFISSxFQUloQixHQUpnQixDQUlaLE1BSlksRUFJSixPQUpJLEVBS2hCLEdBTGdCLENBS1osY0FMWSxFQUtJLEdBTEosQ0FBakI7O0FBT0EsUUFBTSxvQkFBb0IsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEtBQUcsRUFBWixFQUFnQixLQUFHLEVBQW5CLENBQTFCO0FBQ0EsUUFBSSxZQUFZLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxLQUFLLENBQWhCLEVBQW1CLEtBQUssQ0FBeEIsQ0FBaEI7O0FBRUEsUUFBTSxTQUFTLGFBQWEsSUFBYixDQUFmO0FBQ0EsUUFBTSxRQUFRLGFBQWEsSUFBYixDQUFkOztBQUVBLFFBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGtCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxLQUFHLEVBQVYsRUFBYyxNQUFJLEVBQWxCLENBQVo7QUFDRDs7QUFFRCxRQUFJLE1BQU0sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGdCQUFVLENBQVYsSUFBZSxNQUFJLEVBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxXQUFXLElBQVgsQ0FBSixFQUFzQjtBQUNwQixrQkFBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sTUFBSSxFQUFYLEVBQWUsTUFBSSxFQUFuQixDQUFaO0FBQ0Q7O0FBRUQsUUFBSSxzQ0FFQSxXQUFXLElBQVgsSUFBbUIsZUFBZSxRQUFmLENBQXdCLFdBQVcsb0JBQW5DLEVBQXlELGlCQUF6RCxDQUFuQixHQUFpRyxFQUZqRyxpQkFHQSxXQUFXLG9CQUFYLHNDQUFtQyxTQUFuQyxVQUE4QyxRQUE5QyxHQUhBLGlCQUlBLGVBQWUsSUFBZixJQUF1QixlQUFlLFdBQWYsQ0FBMkIsRUFBM0IsRUFBK0IsRUFBL0IsRUFBbUMsV0FBVyxvQkFBOUMsRUFBb0UsU0FBcEUsQ0FBdkIsR0FBd0csRUFKeEcsa0JBS0EsT0FBTyxNQUFQLEdBQWdCLENBQWhCLEdBQW9CLGVBQWUsaUJBQWYsQ0FBa0MsS0FBSyxDQUF2QyxFQUEyQyxDQUEzQyxFQUE4QyxNQUFJLEVBQWxELEVBQXNELE1BQUksRUFBMUQsRUFBOEQsT0FBTyxDQUFQLENBQTlELENBQXBCLEdBQStGLEVBTC9GLGtCQU1BLE1BQU0sTUFBTixHQUFlLENBQWYsR0FBbUIsZUFBZSxhQUFmLENBQThCLElBQUksRUFBSixHQUFTLENBQXZDLEVBQTJDLEtBQU0sUUFBTSxFQUFOLEdBQVcsQ0FBNUQsRUFBZ0UsTUFBSSxFQUFwRSxFQUF3RSxNQUFNLENBQU4sQ0FBeEUsQ0FBbkIsR0FBdUcsRUFOdkcsWUFBSjtBQVFBLFdBQU8sT0FBTyxxQkFBUCxFQUE4QixFQUE5QixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxFQUE1QyxFQUFnRCxFQUFoRCxDQUFQO0FBQ0QsR0F6SXFCO0FBMkl0QixTQTNJc0IsbUJBMkliLElBM0lhLEVBMklQO0FBQ2IsUUFBSSxLQUFLLEtBQUssS0FBTCxFQUFUO0FBQ0EsUUFBSSxLQUFLLEtBQUssTUFBTCxFQUFUOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsY0FGVSxFQUVNLEdBRk4sRUFHZCxHQUhjLENBR1YsTUFIVSxFQUdGLE9BSEUsRUFJZCxHQUpjLENBSVYsY0FKVSxFQUlNLEdBSk4sQ0FBZjs7QUFNQSxRQUFJLFlBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsRUFBdUIsRUFBdkIsQ0FBaEI7QUFDQSxRQUFNLG9CQUFvQixDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsTUFBSSxFQUFiLEVBQWlCLE1BQUksRUFBckIsRUFBeUIsRUFBekIsQ0FBMUI7O0FBRUEsUUFBTSxTQUFTLGFBQWEsSUFBYixDQUFmO0FBQ0EsUUFBTSxRQUFRLGFBQWEsSUFBYixDQUFkOztBQUVBLFFBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGdCQUFVLENBQVYsS0FBZ0IsQ0FBaEI7QUFDQSxnQkFBVSxDQUFWLEtBQWdCLEVBQWhCO0FBQ0EsZ0JBQVUsQ0FBVixLQUFnQixHQUFoQjtBQUNBLGdCQUFVLENBQVYsS0FBZ0IsRUFBaEI7QUFDRDs7QUFFRCxRQUFJLE1BQU0sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGdCQUFVLENBQVYsSUFBZSxNQUFJLEVBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxXQUFXLElBQVgsQ0FBSixFQUFzQjtBQUNwQixrQkFBWSxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsTUFBSSxFQUFaLEVBQWdCLEtBQUcsRUFBbkIsRUFBdUIsRUFBdkIsQ0FBWjtBQUNEOztBQUVELFFBQU0sU0FBUyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsTUFBSSxFQUFsQixDQUFmO0FBQ0EsUUFBTSxTQUFTLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxNQUFJLEVBQWpCLENBQWY7QUFDQSxRQUFNLGFBQWEsRUFBbkI7O0FBRUEsUUFBSSwyQkFFQSxXQUFXLElBQVgsSUFBbUIsZUFBZSxRQUFmLENBQXdCLFdBQVcsWUFBbkMsRUFBaUQsaUJBQWpELENBQW5CLEdBQXlGLEVBRnpGLGlCQUdBLFdBQVcsWUFBWCxzQ0FBMkIsU0FBM0IsVUFBc0MsUUFBdEMsR0FIQSxpQkFJQSxlQUFlLElBQWYsSUFBdUIsZUFBZSxXQUFmLENBQTJCLEVBQTNCLEVBQStCLEVBQS9CLEVBQW1DLFdBQVcsWUFBOUMsRUFBNEQsU0FBNUQsQ0FBdkIsR0FBZ0csRUFKaEcsa0JBS0EsT0FBTyxNQUFQLEdBQWdCLENBQWhCLEdBQW9CLGVBQWUsaUJBQWYsQ0FBa0MsS0FBSyxDQUF2QyxFQUEyQyxDQUEzQyxFQUE4QyxNQUE5QyxFQUFzRCxNQUF0RCxFQUE4RCxPQUFPLENBQVAsQ0FBOUQsQ0FBcEIsR0FBK0YsRUFML0Ysa0JBTUEsTUFBTSxNQUFOLEdBQWUsQ0FBZixHQUFtQixlQUFlLGFBQWYsQ0FBOEIsSUFBSSxFQUFKLEdBQVMsQ0FBdkMsRUFBMkMsVUFBVSxDQUFWLElBQWUsVUFBVSxDQUFWLENBQWYsR0FBOEIsQ0FBekUsRUFBNEUsVUFBNUUsRUFBd0YsTUFBTSxDQUFOLENBQXhGLENBQW5CLEdBQXVILEVBTnZILFlBQUo7QUFRQSxXQUFPLE9BQU8sVUFBUCxFQUFtQixFQUFuQixFQUF1QixFQUF2QixFQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQyxFQUFqQyxFQUFxQyxFQUFyQyxDQUFQO0FBQ0QsR0F2THFCO0FBeUx0QixlQXpMc0IseUJBeUxQLElBekxPLEVBeUxEO0FBQUEsMkJBQ0ksV0FBVyxHQUFYLENBQWUsSUFBZixDQURKO0FBQUEsUUFDVCxFQURTLG9CQUNaLENBRFk7QUFBQSxRQUNGLEVBREUsb0JBQ0wsQ0FESzs7QUFJbkIsUUFBTSxVQUFVLEtBQUssQ0FBckI7QUFDQSxRQUFNLFVBQVUsS0FBSyxDQUFyQjtBQUNBLFFBQU0sU0FBUyxDQUFDLEtBQUssQ0FBTixJQUFXLENBQTFCOztBQUVBLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGdCQUZZLEVBRU0sUUFGTixFQUdoQixHQUhnQixDQUdaLGNBSFksRUFHSSxLQUhKLEVBSWhCLEdBSmdCLENBSVosTUFKWSxFQUlKLE1BSkksQ0FBakI7O0FBTUEsUUFBTSxZQUFZLENBQUMsT0FBRCxFQUFVLE9BQVYsRUFBbUIsTUFBbkIsQ0FBbEI7O0FBRUEsUUFBTSxnQ0FFRixXQUFXLE1BQVgsbUJBQXFCLFNBQXJCLFNBQWdDLFFBQWhDLEdBRkUsaUJBR0YsZUFBZSxJQUFmLElBQXVCLGVBQWUsV0FBZixDQUEyQixFQUEzQixFQUErQixFQUEvQixFQUFtQyxXQUFXLE1BQTlDLEVBQXNELFNBQXRELENBQXZCLEdBQTBGLEVBSHhGLGlCQUlGLFdBQVcsSUFBWCxDQUFnQixDQUFoQixFQUFtQixFQUFuQixFQUF1QixFQUF2QixFQUEyQixDQUEzQixFQUE4QixRQUE5QixDQUpFLFdBQU47O0FBT0EsV0FBTyxPQUFPLGdCQUFQLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDLEVBQXVDLEVBQXZDLEVBQTJDLEVBQTNDLENBQVA7QUFDRCxHQWpOcUI7QUFtTnRCLGlCQW5Oc0IsMkJBbU5MLElBbk5LLEVBbU5DO0FBQUEsMkJBQ0UsV0FBVyxHQUFYLENBQWUsSUFBZixDQURGO0FBQUEsUUFDWCxFQURXLG9CQUNkLENBRGM7QUFBQSxRQUNKLEVBREksb0JBQ1AsQ0FETzs7QUFHckIsUUFBTSxXQUFXLElBQUksR0FBSixHQUNoQixHQURnQixDQUNaLFFBRFksRUFDRixTQURFLEVBRWhCLEdBRmdCLENBRVosY0FGWSxFQUVJLEdBRkosRUFHaEIsR0FIZ0IsQ0FHWixNQUhZLEVBR0osTUFISSxDQUFqQjs7QUFLQSxRQUFJLFlBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEtBQUssQ0FBWixFQUFlLEtBQUssQ0FBcEIsQ0FBaEI7O0FBRUEsUUFBTSxTQUFTLGFBQWEsSUFBYixDQUFmOztBQUVBLFFBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGtCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxLQUFHLEVBQVYsRUFBYyxLQUFHLEVBQWpCLENBQVo7QUFDRDs7QUFFRCxRQUFNLGtDQUVGLFdBQVcsY0FBWCxzQ0FBNkIsU0FBN0IsVUFBd0MsUUFBeEMsR0FGRSxpQkFHRixlQUFlLElBQWYsSUFBdUIsZUFBZSxXQUFmLENBQTJCLEtBQUssQ0FBaEMsRUFBbUMsS0FBSyxDQUF4QyxFQUEyQyxXQUFXLGNBQXRELEVBQXNFLFNBQXRFLENBQXZCLEdBQTBHLEVBSHhHLGtCQUlGLE9BQU8sTUFBUCxHQUFnQixDQUFoQixHQUFvQixlQUFlLGlCQUFmLENBQWtDLEtBQUssQ0FBdkMsRUFBMkMsQ0FBM0MsRUFBOEMsTUFBSSxFQUFsRCxFQUFzRCxNQUFJLEVBQTFELEVBQThELE9BQU8sQ0FBUCxDQUE5RCxDQUFwQixHQUErRixFQUo3RixZQUFOO0FBTUEsV0FBTyxPQUFPLGtCQUFQLEVBQTJCLEVBQTNCLEVBQStCLEVBQS9CLEVBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLENBQVA7QUFDRDtBQTFPcUIsQ0FBeEI7O0FBNk9BLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7Ozs7QUMxUEEsSUFBTSxpQkFBaUIsUUFBUSxxQkFBUixDQUF2QjtBQUNBLElBQU0sa0JBQWtCLFFBQVEsc0JBQVIsQ0FBeEI7QUFDQSxJQUFNLGVBQWUsUUFBUSxtQkFBUixDQUFyQjs7QUFFQSxJQUFNLFdBQVcsUUFBUSxpQkFBUixDQUFqQjs7QUFFQSxJQUFNLG1CQUFtQixJQUFJLEdBQUo7QUFDekI7QUFEeUIsQ0FFeEIsR0FGd0IsQ0FFcEIsU0FGb0IsRUFFVCxhQUFhLE9BRkosRUFHeEIsR0FId0IsQ0FHcEIsaUJBSG9CLEVBR0QsYUFBYSxPQUhaLEVBSXhCLEdBSndCLENBSXBCLG1CQUpvQixFQUlDLGFBQWEsT0FKZCxFQUt4QixHQUx3QixDQUtwQixhQUxvQixFQUtMLGFBQWEsV0FMUixFQU14QixHQU53QixDQU1wQixjQU5vQixFQU1KLGFBQWEsWUFOVCxFQU94QixHQVB3QixDQU9wQixXQVBvQixFQU9QLGFBQWEsU0FQTjs7QUFTekI7QUFUeUIsQ0FVeEIsR0FWd0IsQ0FVcEIsaUJBVm9CLEVBVUQsZ0JBQWdCLGFBVmYsRUFXeEIsR0FYd0IsQ0FXcEIsb0JBWG9CLEVBV0UsZ0JBQWdCLGlCQVhsQixFQVl4QixHQVp3QixDQVlwQixpQkFab0IsRUFZRCxnQkFBZ0IsY0FaZixFQWF4QixHQWJ3QixDQWFwQiwwQkFib0IsRUFhUSxnQkFBZ0IsY0FieEIsRUFjeEIsR0Fkd0IsQ0FjcEIsZUFkb0IsRUFjSCxnQkFBZ0IsYUFkYixFQWV4QixHQWZ3QixDQWVwQix3QkFmb0IsRUFlTSxnQkFBZ0IsYUFmdEIsRUFnQnhCLEdBaEJ3QixDQWdCcEIsc0JBaEJvQixFQWdCSSxnQkFBZ0Isa0JBaEJwQixFQWlCeEIsR0FqQndCLENBaUJwQiwrQkFqQm9CLEVBaUJhLGdCQUFnQixrQkFqQjdCLEVBa0J4QixHQWxCd0IsQ0FrQnBCLFNBbEJvQixFQWtCVCxnQkFBZ0IsT0FsQlAsRUFtQnhCLEdBbkJ3QixDQW1CcEIsa0JBbkJvQixFQW1CQSxnQkFBZ0IsT0FuQmhCLEVBb0J4QixHQXBCd0IsQ0FvQnBCLGtCQXBCb0IsRUFvQkEsZ0JBQWdCLGVBcEJoQjs7QUFzQnpCO0FBdEJ5QixDQXVCeEIsR0F2QndCLENBdUJwQixhQXZCb0IsRUF1QkwsZUFBZSxXQXZCVixDQUF6Qjs7QUEwQkEsSUFBTSxPQUFPLFNBQVAsSUFBTyxDQUFDLElBQUQsRUFBVTtBQUNyQixNQUFNLFlBQVksU0FBUyxTQUFULENBQW1CLElBQW5CLENBQWxCO0FBQ0EsTUFBSSxVQUFVLGlCQUFpQixHQUFqQixDQUFxQixTQUFyQixDQUFkO0FBQ0EsTUFBSSxZQUFZLFNBQWhCLEVBQTJCO0FBQ3pCLFVBQU0sSUFBSSxTQUFKLENBQWlCLFNBQWpCLDJDQUFOO0FBQ0Q7QUFDRCxTQUFPLFFBQVEsSUFBUixDQUFQO0FBQ0QsQ0FQRDs7QUFTQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixRQUFNO0FBRFMsQ0FBakI7Ozs7O0FDekNBLElBQU0sYUFBYSxRQUFRLGNBQVIsQ0FBbkI7QUFDQSxJQUFNLGlCQUFpQixRQUFRLGtCQUFSLENBQXZCOztBQUVBLElBQU0sU0FBUyxRQUFRLGFBQVIsRUFBdUIsTUFBdEM7QUFDQSxJQUFNLGFBQWEsUUFBUSxlQUFSLENBQW5COztBQUVBLElBQU0sZUFBZTtBQUVuQixTQUZtQixtQkFFVixJQUZVLEVBRUo7QUFBQSwwQkFDVSxXQUFXLEdBQVgsQ0FBZSxJQUFmLENBRFY7QUFBQSxRQUNILEVBREcsbUJBQ04sQ0FETTtBQUFBLFFBQ0ksRUFESixtQkFDQyxDQUREOztBQUdiLFFBQU0sY0FBYyxJQUFJLEdBQUosR0FDbkIsR0FEbUIsQ0FDZixRQURlLEVBQ0wsU0FESyxFQUVuQixHQUZtQixDQUVmLGNBRmUsRUFFQyxHQUZELEVBR25CLEdBSG1CLENBR2YsTUFIZSxFQUdQLE1BSE8sQ0FBcEI7O0FBS0EsUUFBTSwwQkFFRixXQUFXLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBM0MsRUFBOEMsV0FBOUMsQ0FGRSxXQUFOO0FBSUEsV0FBTyxPQUFPLFVBQVAsRUFBbUIsRUFBbkIsRUFBdUIsRUFBdkIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsQ0FBUDtBQUNELEdBZmtCO0FBaUJuQixhQWpCbUIsdUJBaUJOLElBakJNLEVBaUJBO0FBQUEsMkJBQ00sV0FBVyxHQUFYLENBQWUsSUFBZixDQUROO0FBQUEsUUFDUCxFQURPLG9CQUNWLENBRFU7QUFBQSxRQUNBLEVBREEsb0JBQ0gsQ0FERzs7QUFHakIsUUFBTSxVQUFVLEtBQUssQ0FBckI7QUFDQSxRQUFNLFVBQVUsS0FBSyxDQUFyQjtBQUNBLFFBQU0sU0FBUyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQXhDOztBQUVBLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLFNBSEksRUFJaEIsR0FKZ0IsQ0FJWixjQUpZLEVBSUksR0FKSixDQUFqQjs7QUFNQSxRQUFNLDhCQUVGLFdBQVcsTUFBWCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxNQUFwQyxFQUE0QyxRQUE1QyxDQUZFLFdBQU47QUFJQSxXQUFPLE9BQU8sY0FBUCxFQUF1QixFQUF2QixFQUEyQixFQUEzQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxDQUFQO0FBQ0QsR0FuQ2tCO0FBcUNuQixjQXJDbUIsd0JBcUNMLElBckNLLEVBcUNDO0FBQUEsMkJBQ0ssV0FBVyxHQUFYLENBQWUsSUFBZixDQURMO0FBQUEsUUFDUixFQURRLG9CQUNYLENBRFc7QUFBQSxRQUNELEVBREMsb0JBQ0osQ0FESTs7QUFHbEIsUUFBTSxVQUFVLEtBQUssQ0FBckI7QUFDQSxRQUFNLFVBQVUsS0FBSyxDQUFyQjtBQUNBLFFBQU0sY0FBYyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQTdDO0FBQ0EsUUFBTSxjQUFjLENBQUMsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBcEIsSUFBeUIsQ0FBN0M7O0FBRUEsUUFBTSxXQUFXLElBQUksR0FBSixHQUNoQixHQURnQixDQUNaLFFBRFksRUFDRixTQURFLEVBRWhCLEdBRmdCLENBRVosY0FGWSxFQUVJLEdBRkosRUFHaEIsR0FIZ0IsQ0FHWixNQUhZLEVBR0osTUFISSxDQUFqQjs7QUFLQSxRQUFNLCtCQUVGLFdBQVcsTUFBWCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxXQUFwQyxFQUFpRCxRQUFqRCxDQUZFLGdCQUdGLFdBQVcsTUFBWCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxXQUFwQyxFQUFpRCxRQUFqRCxDQUhFLFdBQU47QUFLQSxXQUFPLE9BQU8sZUFBUCxFQUF3QixFQUF4QixFQUE0QixFQUE1QixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxFQUF0QyxFQUEwQyxFQUExQyxDQUFQO0FBQ0QsR0F4RGtCO0FBMERuQixXQTFEbUIscUJBMERSLElBMURRLEVBMERGO0FBQUEsMkJBQ1EsV0FBVyxHQUFYLENBQWUsSUFBZixDQURSO0FBQUEsUUFDTCxFQURLLG9CQUNSLENBRFE7QUFBQSxRQUNFLEVBREYsb0JBQ0QsQ0FEQzs7QUFHZixRQUFNLFdBQVcsSUFBSSxHQUFKLEdBQ2hCLEdBRGdCLENBQ1osUUFEWSxFQUNGLFNBREUsRUFFaEIsR0FGZ0IsQ0FFWixjQUZZLEVBRUksR0FGSixFQUdoQixHQUhnQixDQUdaLE1BSFksRUFHSixNQUhJLENBQWpCOztBQUtBLFFBQU0sWUFBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sS0FBSyxDQUFaLEVBQWUsS0FBSyxDQUFwQixDQUFsQjs7QUFFQSxRQUFJLDRCQUVBLFdBQVcsT0FBWCxtQkFBc0IsU0FBdEIsU0FBaUMsUUFBakMsR0FGQSxpQkFHQSxLQUFLLElBQUwsQ0FBVSxhQUFWLElBQTJCLGVBQWUsV0FBZixDQUEyQixLQUFLLENBQWhDLEVBQW1DLEtBQUssQ0FBeEMsRUFBMkMsV0FBVyxPQUF0RCxFQUErRCxTQUEvRCxDQUEzQixHQUF1RyxFQUh2RyxZQUFKO0FBS0EsV0FBTyxPQUFPLFlBQVAsRUFBcUIsRUFBckIsRUFBeUIsRUFBekIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsRUFBbUMsRUFBbkMsRUFBdUMsRUFBdkMsQ0FBUDtBQUNEO0FBMUVrQixDQUFyQjs7QUE2RUEsT0FBTyxPQUFQLEdBQWlCLFlBQWpCOzs7OztBQ25GQSxJQUFNLGVBQWUsUUFBUSxjQUFSLENBQXJCOztBQUVBLElBQU0sYUFBYSxRQUFRLFNBQVIsQ0FBbkI7QUFDQSxJQUFNLGlCQUFpQixRQUFRLGNBQVIsQ0FBdkI7O0FBRUEsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsRUFBMEIsVUFBN0M7QUFDQSxJQUFNLGNBQWMsUUFBUSxnQkFBUixFQUEwQixXQUE5Qzs7QUFFQSxJQUFJLGlCQUFpQixTQUFqQixjQUFpQixDQUFVLFNBQVYsRUFBcUI7O0FBRXhDLFNBQU8sVUFBVSxVQUFWO0FBQ0Q7QUFEQyxHQUVBLFFBRkEsQ0FFUyxNQUZULEVBR0EsR0FIQSxDQUdJO0FBQ0gsYUFBUyxlQUFDLElBQUQ7QUFBQSxhQUFVLGFBQWEsU0FBYixDQUF1QixJQUF2QixDQUFWO0FBQUEsS0FETjtBQUVILGVBQVcsaUJBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxXQUFiLENBQXlCLElBQXpCLENBQVY7QUFBQSxLQUZSO0FBR0gsaUJBQWEsa0JBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxhQUFiLENBQTJCLElBQTNCLENBQVY7QUFBQSxLQUhWO0FBSUgsbUJBQWUsUUFKWjtBQUtILG1CQUFlLFFBTFo7QUFNSCxvQkFBZ0IsR0FOYjtBQU9ILG9CQUFnQixNQVBiO0FBUUgsd0JBQW9CLFNBUmpCO0FBU0gsMEJBQXNCLEdBVG5CO0FBVUgsb0JBQWdCLENBVmI7QUFXSCxlQUFXO0FBWFIsR0FISixFQWdCQSxRQWhCQSxDQWdCUyxlQWhCVCxFQWlCQSxHQWpCQSxDQWlCSTtBQUNILHdCQUFvQixTQURqQjtBQUVILDBCQUFzQixNQUZuQjtBQUdILDBCQUFzQjtBQUhuQixHQWpCSixFQXNCQSxRQXRCQSxDQXNCUyxhQXRCVCxFQXVCQSxHQXZCQSxDQXVCSTtBQUNILDBCQUFzQixHQURuQixFQUN3QixpQkFBaUIsU0FEekM7QUFFSCx1QkFBbUI7QUFGaEIsR0F2Qko7O0FBNkJEO0FBN0JDLEdBOEJBLFFBOUJBLG9sQkF5Q0EsR0F6Q0EsQ0F5Q0k7QUFDSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLElBQWhCLENBQVY7QUFBQSxLQURqQjtBQUVILGFBQVMsZUFBQyxJQUFEO0FBQUEsYUFBVSxlQUFlLEtBQWYsQ0FBcUIsSUFBckIsQ0FBVjtBQUFBLEtBRk47QUFHSCxjQUFVLGdCQUFDLElBQUQ7QUFBQSxhQUFVLGVBQWUsTUFBZixDQUFzQixJQUF0QixDQUFWO0FBQUEsS0FIUDtBQUlILHNCQUFrQixNQUpmO0FBS0gsd0JBQW9CLE1BTGpCO0FBTUgseUJBQXFCLE1BTmxCO0FBT0gsdUJBQW1CLE1BUGhCO0FBUUgseUJBQXFCLFdBUmxCO0FBU0gsb0JBQWdCO0FBVGIsR0F6Q0o7O0FBc0REO0FBdERDLEdBdURBLFFBdkRBLENBdURTLHVEQXZEVCxFQXdEQSxHQXhEQSxDQXdESTtBQUNILDBCQUFzQjtBQURuQixHQXhESixFQTJEQSxRQTNEQSxDQTJEUywyQkEzRFQsRUE0REEsR0E1REEsQ0E0REk7QUFDSCx3QkFBb0I7QUFEakIsR0E1REo7O0FBaUVEO0FBakVDLEdBa0VBLFFBbEVBLENBa0VTLCtCQWxFVCxFQW1FQSxHQW5FQSxDQW1FSTtBQUNILDRCQUF3QjtBQURyQixHQW5FSixFQXNFQSxRQXRFQSxDQXNFUyxtQkF0RVQsRUF1RUEsR0F2RUEsQ0F1RUk7QUFDSCxhQUFTLGVBQUMsSUFBRDtBQUFBLGFBQVUsZUFBZSxLQUFmLENBQXFCLElBQXJCLENBQVY7QUFBQSxLQUROO0FBRUgsY0FBVSxnQkFBQyxJQUFEO0FBQUEsYUFBVSxlQUFlLE1BQWYsQ0FBc0IsSUFBdEIsQ0FBVjtBQUFBLEtBRlA7QUFHSCw0QkFBd0I7QUFIckIsR0F2RUosRUE0RUEsUUE1RUEsQ0E0RVMsZ0NBNUVULEVBNkVBLEdBN0VBLENBNkVJO0FBQ0gsNEJBQXdCO0FBRHJCLEdBN0VKOztBQWtGRDtBQWxGQyxHQW1GQSxRQW5GQSxxVEF5RkEsR0F6RkEsQ0F5Rkk7QUFDSCxlQUFXLGlCQUFDLElBQUQ7QUFBQSxhQUFZLFdBQVcsSUFBWCxLQUFvQixZQUFZLElBQVosQ0FBckIsR0FBMEMsQ0FBMUMsR0FBOEMsQ0FBekQ7QUFBQSxLQURSO0FBRUgsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFZLFdBQVcsSUFBWCxLQUFvQixZQUFZLElBQVosQ0FBckIsR0FBMEMsTUFBMUMsR0FBbUQsTUFBOUQ7QUFBQSxLQUZqQjtBQUdILHlCQUFxQiwwQkFBQyxJQUFEO0FBQUEsYUFBWSxXQUFXLElBQVgsS0FBb0IsWUFBWSxJQUFaLENBQXJCLEdBQTBDLE1BQTFDLEdBQW1ELE1BQTlEO0FBQUE7QUFIbEIsR0F6Rko7O0FBZ0dEO0FBaEdDLEdBaUdBLFFBakdBLENBaUdTLGtGQWpHVCxFQWtHQSxHQWxHQSxDQWtHSTtBQUNILGtDQUE4QixTQUQzQjtBQUVILDBCQUFzQixFQUZuQjtBQUdILG1CQUFlLFFBSFo7QUFJSCxtQkFBZSxRQUpaO0FBS0gsaUJBQWEsa0JBQUMsSUFBRDtBQUFBLGFBQVUsZUFBZSxLQUFmLENBQXFCLElBQXJCLENBQVY7QUFBQSxLQUxWO0FBTUgsa0JBQWMsbUJBQUMsSUFBRDtBQUFBLGFBQVUsZUFBZSxNQUFmLENBQXNCLElBQXRCLENBQVY7QUFBQTtBQU5YLEdBbEdKLEVBMkdBLFFBM0dBLENBMkdTLDJCQTNHVCxFQTRHQSxHQTVHQSxDQTRHSTtBQUNILGVBQVcsS0FEUjtBQUVILDJCQUF1QjtBQUZwQixHQTVHSjs7QUFpSEQ7QUFqSEMsR0FrSEEsUUFsSEEsQ0FrSFMsTUFsSFQsRUFtSEEsR0FuSEEsQ0FtSEk7QUFDSCxtQkFBZSxRQURaO0FBRUgsa0JBQWMsTUFGWDtBQUdILHlCQUFxQixRQUhsQjtBQUlILHlCQUFxQixRQUpsQjtBQUtILGFBQVMsR0FMTjtBQU1ILDBCQUFzQixNQU5uQjtBQU9ILDBCQUFzQixNQVBuQjtBQVFILHlCQUFxQixNQVJsQjtBQVNILGFBQVM7QUFUTixHQW5ISixFQThIQSxRQTlIQSxDQThIUyxlQTlIVCxFQStIQSxHQS9IQSxDQStISTtBQUNILGFBQVMsU0FETjtBQUVILGtCQUFjLFNBRlg7QUFHSCx5QkFBcUIsU0FIbEI7QUFJSCwwQkFBc0IsU0FKbkI7QUFLSCwwQkFBc0I7QUFMbkIsR0EvSEosRUFzSUEsUUF0SUEsQ0FzSVMsYUF0SVQsRUF1SUEsR0F2SUEsQ0F1SUk7QUFDSCwwQkFBc0IsR0FEbkIsRUFDd0IsaUJBQWlCLFNBRHpDO0FBRUgsdUJBQW1CO0FBRmhCLEdBdklKLEVBMklBLFFBM0lBLENBMklTLHVCQTNJVCxFQTRJQSxHQTVJQSxDQTRJSTtBQUNILHFCQUFpQixZQURkO0FBRUgsNkJBQXlCLFdBRnRCO0FBR0gsMkJBQXVCLEdBSHBCO0FBSUgseUJBQXFCLEdBSmxCO0FBS0gsNkJBQXlCLE9BTHRCO0FBTUgsK0JBQTJCO0FBTnhCLEdBNUlKLEVBb0pBLFFBcEpBLENBb0pTLHVGQXBKVCxFQXFKQSxHQXJKQSxDQXFKSTtBQUNILG9CQUFnQixxQkFBQyxJQUFEO0FBQUEsYUFBVSxLQUFLLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBZjtBQUFBLEtBRGI7QUFFSCw0QkFBd0IsS0FGckI7QUFHSCwwQkFBc0IsMEJBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxtQkFBYixDQUFpQyxJQUFqQyxDQUFWO0FBQUE7QUFIbkIsR0FySkosRUEwSkEsUUExSkEsQ0EwSlMsYUExSlQsRUEySkEsR0EzSkEsQ0EySkk7QUFDSCwwQkFBc0IsMEJBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxjQUFiLENBQTRCLElBQTVCLENBQVY7QUFBQSxLQURuQjtBQUVILDBCQUFzQjtBQUZuQixHQTNKSixFQStKQSxRQS9KQSxDQStKUywwQkEvSlQsRUFnS0EsR0FoS0EsQ0FnS0k7QUFDSCx5QkFBcUI7QUFEbEIsR0FoS0osRUFtS0EsUUFuS0EsQ0FtS1MsMEJBbktULEVBb0tBLEdBcEtBLENBb0tJO0FBQ0gseUJBQXFCO0FBRGxCLEdBcEtKOztBQXlLRDtBQXpLQyxHQTBLQSxRQTFLQSxDQTBLUyxNQTFLVCxFQTJLQSxHQTNLQSxDQTJLSTtBQUNILDJCQUF1QixTQURwQjtBQUVILDZCQUF5QixLQUZ0QixFQUU2Qiw4QkFBOEI7QUFGM0QsR0EzS0osQ0FBUDtBQStLRCxDQWpMRDs7QUFtTEEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7OztBQzNMQSxJQUFNLGtCQUFrQjtBQUN0QixZQURzQixzQkFDVixJQURVLEVBQ0o7QUFDaEIsV0FBTyxLQUFLLElBQUwsQ0FBVSxPQUFWLEVBQW1CLFFBQW5CLENBQTRCLFVBQTVCLENBQVA7QUFDRCxHQUhxQjtBQUl0QixnQkFKc0IsMEJBSU4sSUFKTSxFQUlBO0FBQ3BCLFdBQU8sS0FBSyxJQUFMLENBQVUsYUFBVixDQUFQO0FBQ0QsR0FOcUI7QUFPdEIsY0FQc0Isd0JBT1IsSUFQUSxFQU9GO0FBQ2xCLFdBQU8sS0FBSyxJQUFMLENBQVUsZ0JBQVYsQ0FBUDtBQUNELEdBVHFCO0FBVXRCLGNBVnNCLHdCQVVSLElBVlEsRUFVRjtBQUNsQixXQUFPLEtBQUssSUFBTCxDQUFVLG9CQUFWLENBQVA7QUFDRCxHQVpxQjtBQWF0QixhQWJzQix1QkFhVCxJQWJTLEVBYUg7QUFDakIsV0FBUSxLQUFLLElBQUwsQ0FBVSxnQkFBVixFQUE0QixNQUE1QixHQUFxQyxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxNQUFyRSxHQUE4RSxDQUF0RjtBQUNELEdBZnFCO0FBZ0J0QixXQWhCc0IscUJBZ0JYLE9BaEJXLEVBZ0JGO0FBQ2xCLFdBQU8sUUFBUSxJQUFSLENBQWEsT0FBYixDQUFQO0FBQ0Q7QUFsQnFCLENBQXhCOztBQXFCQSxPQUFPLE9BQVAsR0FBaUIsZUFBakI7Ozs7Ozs7QUNyQkEsSUFBTSxlQUFlLFNBQWYsWUFBZSxDQUFDLFFBQUQsRUFBYztBQUNqQyxNQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLEVBQVI7O0FBTGlDO0FBQUE7QUFBQTs7QUFBQTtBQU9qQyx5QkFBbUIsUUFBbkIsOEhBQTZCO0FBQUE7QUFBQSxVQUFuQixDQUFtQjtBQUFBLFVBQWhCLENBQWdCOztBQUMzQixXQUFLLElBQUksR0FBSixHQUFVLEdBQVYsR0FBZ0IsQ0FBaEIsR0FBb0IsR0FBcEIsR0FBMEIsR0FBL0I7QUFDRDtBQVRnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVdqQyxTQUFPLENBQVA7QUFDRCxDQVpEOztBQWNBLElBQU0sTUFBTSxTQUFOLEdBQU0sQ0FBQyxNQUFELEVBQXdGO0FBQUEsTUFBL0UsS0FBK0UsdUVBQXZFLEdBQXVFO0FBQUEsTUFBbEUsTUFBa0UsdUVBQXpELEdBQXlEO0FBQUEsTUFBcEQsR0FBb0QsdUVBQTlDLENBQThDO0FBQUEsTUFBM0MsR0FBMkMsdUVBQXJDLENBQXFDO0FBQUEsTUFBbEMsT0FBa0MsdUVBQXhCLEdBQXdCO0FBQUEsTUFBbkIsUUFBbUIsdUVBQVIsR0FBUTs7QUFDbEcsTUFBTSxTQUFTLElBQUksU0FBSixFQUFmO0FBQ0EsTUFBSSxpRkFBeUUsS0FBekUsb0JBQTJGLE1BQTNGLHFCQUErRyxHQUEvRyxTQUFzSCxHQUF0SCxTQUE2SCxPQUE3SCxTQUF3SSxRQUF4SSxXQUFxSixNQUFySixXQUFKO0FBQ0EsU0FBTyxPQUFPLGVBQVAsQ0FBdUIsT0FBdkIsRUFBZ0MsVUFBaEMsRUFBNEMsZUFBbkQ7QUFDRCxDQUpEOztBQU1BLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxPQUFELEVBQVUsYUFBVixFQUF5QixjQUF6QixFQUF5QyxRQUF6QyxFQUFtRCxRQUFuRCxFQUE2RCxZQUE3RCxFQUEyRSxhQUEzRSxFQUE2RjtBQUMxRyxNQUFJLElBQUksSUFBSSxPQUFKLEVBQWEsYUFBYixFQUE0QixjQUE1QixFQUE0QyxRQUE1QyxFQUFzRCxRQUF0RCxFQUFnRSxZQUFoRSxFQUE4RSxhQUE5RSxDQUFSO0FBQ0EsTUFBSSxPQUFPLCtCQUErQixLQUFLLEVBQUUsU0FBUCxDQUExQzs7QUFFQSxTQUFPLElBQVA7QUFDRCxDQUxEOztBQU9BLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFVBQVEsTUFETztBQUVmLGdCQUFjO0FBRkMsQ0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG4vKiFcblxuQ3l0b3NjYXBlLmpzIHt7VkVSU0lPTn19IChNSVQgbGljZW5zZWQpXG5cbkNvcHlyaWdodCAoYykgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbnRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxudGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xudXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbm9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCDigJxBUyBJU+KAnSwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoICcuL3Byb21pc2UnICk7XG5cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiggdGFyZ2V0LCBvcHRzLCBvcHRzMiApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgQW5pbWF0aW9uKSApe1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCB0YXJnZXQsIG9wdHMsIG9wdHMyICk7XG4gIH1cblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gdXRpbC5leHRlbmQoIHtcbiAgICBkdXJhdGlvbjogMTAwMFxuICB9LCBvcHRzLCBvcHRzMiApO1xuXG4gIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgX3AucGxheWluZyA9IGZhbHNlO1xuICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgX3AucHJvZ3Jlc3MgPSAwO1xuICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgX3AuZnJhbWVzID0gW107XG5cbiAgaWYoIF9wLmNvbXBsZXRlICYmIGlzLmZuKCBfcC5jb21wbGV0ZSApICl7XG4gICAgX3AuY29tcGxldGVzLnB1c2goIF9wLmNvbXBsZXRlICk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxudXRpbC5leHRlbmQoIGFuaWZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAnYW5pbWF0aW9uJzsgfSxcblxuICBob29rOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggIV9wLmhvb2tlZCApe1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiggX3AucXVldWUgKXtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKCB0aGlzICk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIF9wLnRhcmdldCApICl7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbCggX3AudGFyZ2V0ICk7XG4gICAgICB9XG5cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmKCBfcC5wcm9ncmVzcyA9PT0gMSApe1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheWluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFwcGx5aW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJld2luZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyggMCApO1xuICB9LFxuXG4gIGZhc3Rmb3J3YXJkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKCAxICk7XG4gIH0sXG5cbiAgdGltZTogZnVuY3Rpb24oIHQgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIHQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzICogX3AuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKCB0IC8gX3AuZHVyYXRpb24gKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uKCBwICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiggcCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiggd2FzUGxheWluZyApe1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb21wbGV0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG5cbiAgcmV2ZXJzZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiggYSwgYiApe1xuICAgICAgdmFyIF9wYSA9IF9wWyBhIF07XG5cbiAgICAgIF9wWyBhIF0gPSBfcFsgYiBdO1xuICAgICAgX3BbIGIgXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCggJ3pvb20nLCAnc3RhcnRab29tJyApO1xuICAgIHN3YXAoICdwYW4nLCAnc3RhcnRQYW4nICk7XG4gICAgc3dhcCggJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nICk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbIGkgXTtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVsgbmFtZSBdO1xuXG4gICAgICBfcC5zdGFydFN0eWxlWyBuYW1lIF0gPSBwcm9wO1xuICAgICAgX3Auc3R5bGVbIGkgXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgIH1cblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwcm9taXNlOiBmdW5jdGlvbiggdHlwZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgYXJyLnB1c2goIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gKTtcbiAgICB9ICk7XG4gIH1cblxufSApO1xuXG5hbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGFTdGFyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgdmFyIHJlY29uc3RydWN0UGF0aCA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBjYW1lRnJvbU1hcCwgcGF0aEFjdW0gKXtcbiAgICAgIC8vIEJhc2UgY2FzZVxuICAgICAgaWYoIHN0YXJ0ID09IGVuZCApe1xuICAgICAgICBwYXRoQWN1bS51bnNoaWZ0KCBjeS5nZXRFbGVtZW50QnlJZCggZW5kICkgKTtcbiAgICAgICAgcmV0dXJuIHBhdGhBY3VtO1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kIGluIGNhbWVGcm9tTWFwICl7XG4gICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNhbWVGcm9tTWFwWyBlbmQgXTtcbiAgICAgICAgdmFyIHByZXZpb3VzRWRnZSA9IGNhbWVGcm9tRWRnZVsgZW5kIF07XG5cbiAgICAgICAgcGF0aEFjdW0udW5zaGlmdCggY3kuZ2V0RWxlbWVudEJ5SWQoIHByZXZpb3VzRWRnZSApICk7XG4gICAgICAgIHBhdGhBY3VtLnVuc2hpZnQoIGN5LmdldEVsZW1lbnRCeUlkKCBlbmQgKSApO1xuXG4gICAgICAgIHJldHVybiByZWNvbnN0cnVjdFBhdGgoIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsXG4gICAgICAgICAgICAgICAgICAgICBjYW1lRnJvbU1hcCxcbiAgICAgICAgICAgICAgICAgICAgIHBhdGhBY3VtICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIG9wZW5TZXQgd2hpY2ggaGFzIG1pbmltdW0gZlNjb3JlXG4gICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbiggb3BlblNldCwgZlNjb3JlICl7XG4gICAgICBpZiggb3BlblNldC5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciB0ZW1wU2NvcmUgPSBmU2NvcmVbIG9wZW5TZXRbMF0gXTtcbiAgICAgIGZvciggdmFyIGkgPSAxOyBpIDwgb3BlblNldC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcyA9IGZTY29yZVsgb3BlblNldFsgaSBdIF07XG4gICAgICAgIGlmKCBzIDwgdGVtcFNjb3JlICl7XG4gICAgICAgICAgdGVtcFNjb3JlID0gcztcbiAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUG9zO1xuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiggb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICB2YXIgc291cmNlID0gaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSA/XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB0aGlzLmZpbHRlciggb3B0aW9ucy5yb290IClbMF0gOlxuICAgICAgICBvcHRpb25zLnJvb3RbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZ29hbCAtIG1hbmRhdG9yeSFcbiAgICBpZiggb3B0aW9ucy5nb2FsICE9IG51bGwgKXtcbiAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcoIG9wdGlvbnMuZ29hbCApID9cbiAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgIHRoaXMuZmlsdGVyKCBvcHRpb25zLmdvYWwgKVswXSA6XG4gICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBIZXVyaXN0aWMgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmhldXJpc3RpYyAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLmhldXJpc3RpYyApICl7XG4gICAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgfVxuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKCBlICl7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNpZCA9IHNvdXJjZS5pZCgpO1xuICAgIHZhciB0aWQgPSB0YXJnZXQuaWQoKTtcblxuICAgIHZhciBjbG9zZWRTZXQgPSBbXTtcbiAgICB2YXIgb3BlblNldCA9IFsgc2lkIF07XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG5cbiAgICBnU2NvcmVbIHNpZCBdID0gMDtcbiAgICBmU2NvcmVbIHNpZCBdID0gaGV1cmlzdGljKCBzb3VyY2UgKTtcblxuICAgIC8vIENvdW50ZXJcbiAgICB2YXIgc3RlcHMgPSAwO1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgd2hpbGUoIG9wZW5TZXQubGVuZ3RoID4gMCApe1xuICAgICAgdmFyIG1pblBvcyA9IGZpbmRNaW4oIG9wZW5TZXQsIGZTY29yZSApO1xuICAgICAgdmFyIGNNaW4gPSBjeS5nZXRFbGVtZW50QnlJZCggb3BlblNldFsgbWluUG9zIF0gKTtcbiAgICAgIHZhciBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBzdGVwcysrO1xuXG4gICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgaWYoIGNNaW5JZCA9PSB0aWQgKXtcbiAgICAgICAgdmFyIHJQYXRoID0gcmVjb25zdHJ1Y3RQYXRoKCBzaWQsIHRpZCwgY2FtZUZyb20sIFtdICk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgICBkaXN0YW5jZTogZ1Njb3JlWyBjTWluSWQgXSxcbiAgICAgICAgICBwYXRoOiBlbGVzLnNwYXduKCByUGF0aCApLFxuICAgICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgIGNsb3NlZFNldC5wdXNoKCBjTWluSWQgKTtcbiAgICAgIC8vIFJlbW92ZSBjTWluIGZyb20gYm91bmRhcnkgbm9kZXNcbiAgICAgIG9wZW5TZXQuc3BsaWNlKCBtaW5Qb3MsIDEgKTtcblxuICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGUgPSB2d0VkZ2VzWyBpIF07XG5cbiAgICAgICAgLy8gZWRnZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcbiAgICAgICAgaWYoICF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoIGUuaWQoKSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gY01pbiBtdXN0IGJlIHRoZSBzb3VyY2Ugb2YgZWRnZSBpZiBkaXJlY3RlZFxuICAgICAgICBpZiggZGlyZWN0ZWQgJiYgZS5kYXRhKCdzb3VyY2UnKSAhPT0gY01pbklkICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIHdTcmMgPSBlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgd1RndCA9IGUudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIHcgPSB3U3JjLmlkKCkgIT09IGNNaW5JZCA/IHdTcmMgOiB3VGd0O1xuICAgICAgICB2YXIgd2lkID0gdy5pZCgpO1xuXG4gICAgICAgIC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmKCAhdGhpcy5oYXNFbGVtZW50V2l0aElkKCB3aWQgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcbiAgICAgICAgaWYoIGNsb3NlZFNldC5pbmRleE9mKCB3aWQgKSAhPSAtMSApe1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG4gICAgICAgIHZhciB0ZW1wU2NvcmUgPSBnU2NvcmVbIGNNaW5JZCBdICsgd2VpZ2h0Rm4oIGUgKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgIGlmKCBvcGVuU2V0LmluZGV4T2YoIHdpZCApID09IC0xICl7XG4gICAgICAgICAgZ1Njb3JlWyB3aWQgXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbIHdpZCBdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKCB3ICk7XG4gICAgICAgICAgb3BlblNldC5wdXNoKCB3aWQgKTsgLy8gQWRkIG5vZGUgdG8gb3BlblNldFxuICAgICAgICAgIGNhbWVGcm9tWyB3aWQgXSA9IGNNaW5JZDtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2VbIHdpZCBdID0gZS5pZCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuICAgICAgICBpZiggdGVtcFNjb3JlIDwgZ1Njb3JlWyB3aWQgXSApe1xuICAgICAgICAgIGdTY29yZVsgd2lkIF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlWyB3aWQgXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyggdyApO1xuICAgICAgICAgIGNhbWVGcm9tWyB3aWQgXSA9IGNNaW5JZDtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICBkaXN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gZWxlc2ZuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgKXtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSApe1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsdGVyKCBvcHRpb25zLnJvb3QgKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgaWQycG9zaXRpb25bIG5vZGVzWyBpIF0uaWQoKSBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICB2YXIgY29zdCA9IFtdO1xuICAgIHZhciBwcmVkZWNlc3NvciA9IFtdO1xuICAgIHZhciBwcmVkRWRnZSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZiggbm9kZXNbIGkgXS5pZCgpID09PSBzb3VyY2UuaWQoKSApe1xuICAgICAgICBjb3N0WyBpIF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29zdFsgaSBdID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBwcmVkZWNlc3NvclsgaSBdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEVkZ2VzIHJlbGF4YXRpb25cbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGUgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgZSBdLnRhcmdldCgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKCBlZGdlc1sgZSBdICk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBjb3N0WyBzb3VyY2VJbmRleCBdICsgd2VpZ2h0O1xuICAgICAgICBpZiggdGVtcCA8IGNvc3RbIHRhcmdldEluZGV4IF0gKXtcbiAgICAgICAgICBjb3N0WyB0YXJnZXRJbmRleCBdID0gdGVtcDtcbiAgICAgICAgICBwcmVkZWNlc3NvclsgdGFyZ2V0SW5kZXggXSA9IHNvdXJjZUluZGV4O1xuICAgICAgICAgIHByZWRFZGdlWyB0YXJnZXRJbmRleCBdID0gZWRnZXNbIGUgXTtcbiAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgIGlmKCAhZGlyZWN0ZWQgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGNvc3RbIHRhcmdldEluZGV4IF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgaWYoIHRlbXAgPCBjb3N0WyBzb3VyY2VJbmRleCBdICl7XG4gICAgICAgICAgICBjb3N0WyBzb3VyY2VJbmRleCBdID0gdGVtcDtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yWyBzb3VyY2VJbmRleCBdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBwcmVkRWRnZVsgc291cmNlSW5kZXggXSA9IGVkZ2VzWyBlIF07XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFmbGFnICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBmbGFnICl7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGUgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgZSBdLnRhcmdldCgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKCBlZGdlc1sgZSBdICk7XG5cbiAgICAgICAgaWYoIGNvc3RbIHNvdXJjZUluZGV4IF0gKyB3ZWlnaHQgPCBjb3N0WyB0YXJnZXRJbmRleCBdICl7XG4gICAgICAgICAgdXRpbC5lcnJvciggJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnICk7XG4gICAgICAgICAgcmV0dXJuIHsgcGF0aFRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICBkaXN0YW5jZVRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiB0cnVlfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3RcbiAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIHBvc2l0aW9uMmlkLnB1c2goIG5vZGVzWyBpIF0uaWQoKSApO1xuICAgIH1cblxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKCB0byApe1xuICAgICAgICBpZiggaXMuc3RyaW5nKCB0byApICl7XG4gICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIoIHRvIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvc3RbIGlkMnBvc2l0aW9uWyB0b0lkIF0gXTtcbiAgICAgIH0sXG5cbiAgICAgIHBhdGhUbzogZnVuY3Rpb24oIHRvICl7XG5cbiAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKCBwcmVkZWNlc3NvciwgZnJvbVBvcywgdG9Qb3MsIHBvc2l0aW9uMmlkLCBhY3VtUGF0aCwgcHJlZEVkZ2UgKXtcbiAgICAgICAgICBmb3IoIDs7ICl7XG4gICAgICAgICAgICAvLyBBZGQgdG9JZCB0byBwYXRoXG4gICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbIHRvUG9zIF0gKSApO1xuICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggcHJlZEVkZ2VbIHRvUG9zIF0gKTtcblxuICAgICAgICAgICAgaWYoIGZyb21Qb3MgPT09IHRvUG9zICl7XG4gICAgICAgICAgICAgIC8vIHJlYWNoZWQgc3RhcnRpbmcgbm9kZVxuICAgICAgICAgICAgICByZXR1cm4gYWN1bVBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIHBhdGggZXhpc3RzLCBkaXNjYXJ0IGFjdW11bGF0ZWQgcGF0aCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgdmFyIHByZWRQb3MgPSBwcmVkZWNlc3NvclsgdG9Qb3MgXTtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgcHJlZFBvcyA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9Qb3MgPSBwcmVkUG9zO1xuICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIHRvICkgKXtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlciggdG8gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBbXTtcblxuICAgICAgICAvLyBUaGlzIHJldHVybnMgYSByZXZlcnNlZCBwYXRoXG4gICAgICAgIHZhciByZXMgPSAgcmVjb25zdHJ1Y3RQYXRoQXV4KCBwcmVkZWNlc3NvcixcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblsgc291cmNlLmlkKCkgXSxcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblsgdG9JZCBdLFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uMmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgcHJlZEVkZ2UgKTtcblxuICAgICAgICAvLyBHZXQgaXQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIHJldHVybiBpdFxuICAgICAgICBpZiggcmVzICE9IG51bGwgKXtcbiAgICAgICAgICByZXMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd24oIHJlcyApO1xuICAgICAgfSxcblxuICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogZmFsc2VcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlcztcblxuICB9IC8vIGJlbGxtYW5Gb3JkXG5cbn0pOyAvLyBlbGVzZm5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcbnZhciBIZWFwID0gcmVxdWlyZSggJy4uLy4uL2hlYXAnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFdlaWdodCAtIG9wdGlvbmFsXG4gICAgdmFyIHdlaWdodGVkLCB3ZWlnaHRGbjtcbiAgICBpZiggaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB3ZWlnaHRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdlaWdodGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGlyZWN0ZWQgLSBkZWZhdWx0IGZhbHNlXG4gICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsID8gb3B0aW9ucy5kaXJlY3RlZCA6IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIC8vIHN0YXJ0aW5nXG4gICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIEEgPSB7fTtcbiAgICB2YXIgX0MgPSB7fTtcbiAgICB2YXIgbWF4ID0gMDtcbiAgICB2YXIgQyA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oIGtleSwgdmFsICl7XG4gICAgICAgIF9DWyBrZXkgXSA9IHZhbDtcblxuICAgICAgICBpZiggdmFsID4gbWF4ICl7IG1heCA9IHZhbDsgfVxuICAgICAgfSxcblxuICAgICAgZ2V0OiBmdW5jdGlvbigga2V5ICl7IHJldHVybiBfQ1sga2V5IF07IH1cbiAgICB9O1xuXG4gICAgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdiA9IFZbIGkgXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG5cbiAgICAgIGlmKCBkaXJlY3RlZCApe1xuICAgICAgICBBWyB2aWQgXSA9IHYub3V0Z29lcnMoKS5ub2RlcygpOyAvLyBnZXQgb3V0Z29lcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQVsgdmlkIF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH1cblxuICAgICAgQy5zZXQoIHZpZCwgMCApO1xuICAgIH1cblxuICAgIGZvciggdmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKyApe1xuICAgICAgdmFyIHNpZCA9IFZbc10uaWQoKTtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgIH0pOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB2aWQgPSBWWyBpIF0uaWQoKTtcblxuICAgICAgICBQWyB2aWQgXSA9IFtdO1xuICAgICAgICBnWyB2aWQgXSA9IDA7XG4gICAgICAgIGRbIHZpZCBdID0gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGdbIHNpZCBdID0gMTsgLy8gc2lnbWFcbiAgICAgIGRbIHNpZCBdID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICBRLnB1c2goIHNpZCApO1xuXG4gICAgICB3aGlsZSggIVEuZW1wdHkoKSApe1xuICAgICAgICB2YXIgdiA9IFEucG9wKCk7XG5cbiAgICAgICAgUy5wdXNoKCB2ICk7XG5cbiAgICAgICAgaWYoIHdlaWdodGVkICl7XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBBW3ZdLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgdyA9IEFbdl1bal07XG4gICAgICAgICAgICB2YXIgdkVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCB2ICk7XG5cbiAgICAgICAgICAgIHZhciBlZGdlO1xuICAgICAgICAgICAgaWYoIHZFbGUuZWRnZXNUbyggdyApLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgICAgZWRnZSA9IHZFbGUuZWRnZXNUbyggdyApWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyggdkVsZSApWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuKCBlZGdlICk7XG5cbiAgICAgICAgICAgIHcgPSB3LmlkKCk7XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID4gZFt2XSArIGVkZ2VXZWlnaHQgKXtcbiAgICAgICAgICAgICAgZFt3XSA9IGRbdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmKCBRLm5vZGVzLmluZGV4T2YoIHcgKSA8IDAgKXsgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKCB3ICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0oIHcgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdbd10gPSAwO1xuICAgICAgICAgICAgICBQW3ddID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID09IGRbdl0gKyBlZGdlV2VpZ2h0ICl7XG4gICAgICAgICAgICAgIGdbd10gPSBnW3ddICsgZ1t2XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKCB2ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgQVt2XS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHcgPSBBW3ZdW2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID09IEluZmluaXR5ICl7XG4gICAgICAgICAgICAgIFEucHVzaCggdyApO1xuXG4gICAgICAgICAgICAgIGRbd10gPSBkW3ZdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRbd10gPT0gZFt2XSArIDEgKXtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goIHYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSB7fTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBlWyBWWyBpIF0uaWQoKSBdID0gMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFMubGVuZ3RoID4gMCApe1xuICAgICAgICB2YXIgdyA9IFMucG9wKCk7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBQW3ddLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHYgPSBQW3ddW2pdO1xuXG4gICAgICAgICAgZVt2XSA9IGVbdl0gKyAoZ1t2XSAvIGdbd10pICogKDEgKyBlW3ddKTtcblxuICAgICAgICAgIGlmKCB3ICE9IFZbc10uaWQoKSApe1xuICAgICAgICAgICAgQy5zZXQoIHcsIEMuZ2V0KCB3ICkgKyBlW3ddICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IGN5LmZpbHRlciggbm9kZSApLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQy5nZXQoIG5vZGUgKTtcbiAgICAgIH0sXG5cbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgaWYgKCBtYXggPT0gMCApXG4gICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgaWYoIGlzLnN0cmluZyggbm9kZSApICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIoIG5vZGUgKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEMuZ2V0KCBub2RlICkgLyBtYXg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsaWFzXG4gICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG59KTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5iYyA9IGVsZXNmbi5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gIHBhcmFtcyA9IHtcbiAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gIH07XG5cbiAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiggaXMucGxhaW5PYmplY3QoIHJvb3RzICkgJiYgIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIHJvb3RzICkgKXtcbiAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cyB8fCBvcHRpb25zLnJvb3Q7XG4gICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpcy5mbiggZm4gKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgZm4gPSBpcy5mbiggZm4gKSA/IGZuIDogZnVuY3Rpb24oKXt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgdiA9IHJvb3RzID0gaXMuc3RyaW5nKCByb290cyApID8gdGhpcy5maWx0ZXIoIHJvb3RzICkgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuXG4gICAgLy8gZW5xdWV1ZSB2XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrICl7XG4gICAgICBpZiggdlsgaSBdLmlzTm9kZSgpICl7XG4gICAgICAgIFEudW5zaGlmdCggdlsgaSBdICk7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5iZnMgKXtcbiAgICAgICAgICBWWyB2WyBpIF0uaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbIGkgXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWQyZGVwdGhbIHZbIGkgXS5pZCgpIF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlKCBRLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcblxuICAgICAgaWYoIHBhcmFtcy5kZnMgKXtcbiAgICAgICAgaWYoIFZbIHYuaWQoKSBdICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgVlsgdi5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHYgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbIHYuaWQoKSBdO1xuICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICByZXQgPSBmbiggdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoICk7XG5cbiAgICAgIGlmKCByZXQgPT09IHRydWUgKXtcbiAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyggZGlyZWN0ZWQgPyBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuZGF0YSggJ3NvdXJjZScgKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkICkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1sgaSBdO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoIGZ1bmN0aW9uKCBuICl7IHJldHVybiBuLmlkKCkgIT09IHYuaWQoKTsgfSApLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICBpZiggdy5sZW5ndGggIT09IDAgJiYgIVZbIHcuaWQoKSBdICl7XG4gICAgICAgICAgdyA9IHdbMF07XG5cbiAgICAgICAgICBRLnB1c2goIHcgKTtcblxuICAgICAgICAgIGlmKCBwYXJhbXMuYmZzICl7XG4gICAgICAgICAgICBWWyB3LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25uZWN0ZWRCeVsgdy5pZCgpIF0gPSBlO1xuXG4gICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbIGkgXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICBpZiggZWRnZSApe1xuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKCBmb3VuZCApXG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiA9ICh7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKCB7IGJmczogdHJ1ZSB9ICksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCggeyBkZnM6IHRydWUgfSApXG59KTtcblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmJmcyA9IGVsZXNmbi5icmVhZHRoRmlyc3RTZWFyY2g7XG5lbGVzZm4uZGZzID0gZWxlc2ZuLmRlcHRoRmlyc3RTZWFyY2g7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICBpZiggaGFybW9uaWMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgaGFybW9uaWMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgIHZhciBtYXhDbG9zZW5lc3MgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoIHsgd2VpZ2h0OiBvcHRpb25zLndlaWdodCwgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQgfSApO1xuXG4gICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICBpZiggaSAhPSBqICl7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZSggbm9kZXNbIGkgXSwgbm9kZXNbIGogXSApO1xuXG4gICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhaGFybW9uaWMgKXtcbiAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiggbWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcyApe1xuICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBjbG9zZW5lc3Nlc1sgbm9kZXNbIGkgXS5pZCgpIF0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIGlmKCBtYXhDbG9zZW5lc3MgPT0gMCApeyByZXR1cm4gMDsgfVxuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIoIG5vZGUgKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzWyBub2RlIF0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSApe1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmZpbHRlciggb3B0aW9ucy5yb290IClbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcm9vdCA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyB3ZWlnaHQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3ZWlnaHQgPSBmdW5jdGlvbigpe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgJiYgaXMuYm9vbCggb3B0aW9ucy5kaXJlY3RlZCApICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBoYXJtb25pYyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSgge1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSApO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBpZiggbm9kZXNbIGkgXS5pZCgpICE9IHJvb3QuaWQoKSApe1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8oIG5vZGVzWyBpIF0gKTtcblxuICAgICAgICBpZiggaGFybW9uaWMgKXtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbn0pOyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmNjID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHk7XG5lbGVzZm4uY2NuID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmKCAhZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtyb290OiBub2RlfSApICk7XG4gICAgICAgIGlmKCBtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSApXG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgZGVncmVlc1sgbm9kZS5pZCgpIF0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIGlmKCBtYXhEZWdyZWUgPT0gMCApXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVncmVlc1sgbm9kZSBdIC8gbWF4RGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heEluZGVncmVlID0gMDtcbiAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkoIHV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9ICkgKTtcblxuICAgICAgICBpZiggbWF4SW5kZWdyZWUgPCBjdXJyRGVncmVlLmluZGVncmVlIClcbiAgICAgICAgICBtYXhJbmRlZ3JlZSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG5cbiAgICAgICAgaWYoIG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlIClcbiAgICAgICAgICBtYXhPdXRkZWdyZWUgPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcblxuICAgICAgICBpbmRlZ3JlZXNbIG5vZGUuaWQoKSBdID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1sgbm9kZS5pZCgpIF0gPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgaWYgKCBtYXhJbmRlZ3JlZSA9PSAwIClcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgICAgaWYoIGlzLnN0cmluZyggbm9kZSApICl7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIoIG5vZGUgKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbIG5vZGUgXSAvIG1heEluZGVncmVlO1xuICAgICAgICB9LFxuICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgaWYgKCBtYXhPdXRkZWdyZWUgPT0gMCApXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlc1sgbm9kZSBdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJvb3QgIT0gbnVsbCApe1xuICAgICAgdmFyIHJvb3QgPSBpcy5zdHJpbmcoIG9wdGlvbnMucm9vdCApID8gdGhpcy5maWx0ZXIoIG9wdGlvbnMucm9vdCApWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHdlaWdodCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgKXtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5hbHBoYSAhPSBudWxsICYmIGlzLm51bWJlciggb3B0aW9ucy5hbHBoYSApICl7XG4gICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgfVxuXG5cbiAgICBpZiggIWRpcmVjdGVkICl7XG4gICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5FZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5FZGdlc1sgaSBdO1xuICAgICAgICBzICs9IHdlaWdodEZuKCBlZGdlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coIGssIDEgLSBhbHBoYSApICogTWF0aC5wb3coIHMsIGFscGhhIClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmNvbWluZyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoICdlZGdlW3RhcmdldCA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nICkuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgdmFyIG91dGdvaW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcyggJ2VkZ2Vbc291cmNlID0gXCInICsgcm9vdC5pZCgpICsgJ1wiXScgKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgIHZhciBrX291dCA9IG91dGdvaW5nLmxlbmd0aDtcbiAgICAgIHZhciBzX2luID0gMDtcbiAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGluY29taW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBpbmNvbWluZy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGluY29taW5nWyBpIF07XG4gICAgICAgIHNfaW4gKz0gd2VpZ2h0Rm4oIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG91dGdvaW5nLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gb3V0Z29pbmdbIGkgXTtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0Rm4oIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KCBrX2luLCAxIC0gYWxwaGEgKSAqIE1hdGgucG93KCBzX2luLCBhbHBoYSApLFxuICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KCBrX291dCwgMSAtIGFscGhhICkgKiBNYXRoLnBvdyggc19vdXQsIGFscGhhIClcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uZGMgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbi5kY24gPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG52YXIgSGVhcCA9IHJlcXVpcmUoICcuLi8uLi9oZWFwJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICBkaWprc3RyYTogZnVuY3Rpb24oIHJvb3QsIHdlaWdodEZuLCBkaXJlY3RlZCApe1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggcm9vdCApICYmICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCByb290ICkgKXtcbiAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB3ZWlnaHRGbiA9IGlzLmZuKCB3ZWlnaHRGbiApID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgdmFyIHNvdXJjZSA9IGlzLnN0cmluZyggcm9vdCApID8gdGhpcy5maWx0ZXIoIHJvb3QgKVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5maWx0ZXIoIGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuICFlbGUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICByZXR1cm4gZGlzdFsgbm9kZS5pZCgpIF07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24oIG5vZGUsIGQgKXtcbiAgICAgIGRpc3RbIG5vZGUuaWQoKSBdID0gZDtcblxuICAgICAgUS51cGRhdGVJdGVtKCBub2RlICk7XG4gICAgfTtcblxuICAgIHZhciBRID0gbmV3IEhlYXAoIGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICByZXR1cm4gZ2V0RGlzdCggYSApIC0gZ2V0RGlzdCggYiApO1xuICAgIH0gKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcblxuICAgICAgZGlzdFsgbm9kZS5pZCgpIF0gPSBub2RlLnNhbWUoIHNvdXJjZSApID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24oIHUsIHYgKXtcbiAgICAgIHZhciB1dnMgPSAoIGRpcmVjdGVkID8gdS5lZGdlc1RvKCB2ICkgOiB1LmVkZ2VzV2l0aCggdiApICkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gdXZzWyBpIF07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbiggZWRnZSApO1xuXG4gICAgICAgIGlmKCB3ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UgKXtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSggUS5zaXplKCkgPiAwICl7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCggdSApO1xuICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcblxuICAgICAga25vd25EaXN0WyB1aWQgXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBub2RlcyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbIGkgXTtcbiAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4oIHUsIHYgKTtcblxuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiggYWx0IDwgZ2V0RGlzdCggdiApICl7XG4gICAgICAgICAgc2V0RGlzdCggdiwgYWx0ICk7XG5cbiAgICAgICAgICBwcmV2WyB2aWQgXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9IC8vIHdoaWxlXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyggbm9kZSApID8gbm9kZXMuZmlsdGVyKCBub2RlIClbMF0gOiBub2RlWzBdO1xuXG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbIHRhcmdldC5pZCgpIF07XG4gICAgICB9LFxuXG4gICAgICBwYXRoVG86IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcoIG5vZGUgKSA/IG5vZGVzLmZpbHRlciggbm9kZSApWzBdIDogbm9kZVswXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYoIHRhcmdldC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgUy51bnNoaWZ0KCB0YXJnZXQgKTtcblxuICAgICAgICAgIHdoaWxlKCBwcmV2WyB1LmlkKCkgXSApe1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2WyB1LmlkKCkgXTtcblxuICAgICAgICAgICAgUy51bnNoaWZ0KCBwLmVkZ2UgKTtcbiAgICAgICAgICAgIFMudW5zaGlmdCggcC5ub2RlICk7XG5cbiAgICAgICAgICAgIHUgPSBwLm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oIFMgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oIGUgKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgaWQycG9zaXRpb25bIG5vZGVzWyBpIF0uaWQoKSBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBkaXN0ID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KCBudW1Ob2RlcyApO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgIGlmKCBpID09IGogKXtcbiAgICAgICAgICBuZXdSb3dbIGogXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um93WyBqIF0gPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzdC5wdXNoKCBuZXdSb3cgKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgbmV4dCA9IFtdO1xuICAgIHZhciBlZGdlTmV4dCA9IFtdO1xuXG4gICAgdmFyIGluaXRNYXRyaXggPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkoIG51bU5vZGVzICk7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIG5ld1Jvd1sgaiBdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG5leHQucHVzaCggbmV3Um93ICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRNYXRyaXgoIG5leHQgKTtcbiAgICBpbml0TWF0cml4KCBlZGdlTmV4dCApO1xuXG4gICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrICl7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS50YXJnZXQoKS5pZCgpIF07XG4gICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oIGVkZ2VzWyBpIF0gKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgaWYoIGRpc3RbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPiB3ZWlnaHQgKXtcbiAgICAgICAgZGlzdFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IHdlaWdodDtcbiAgICAgICAgbmV4dFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IHRhcmdldEluZGV4O1xuICAgICAgICBlZGdlTmV4dFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IGVkZ2VzWyBpIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VzXG4gICAgaWYoICFkaXJlY3RlZCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKysgKXtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBpIF0udGFyZ2V0KCkuaWQoKSBdO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbiggZWRnZXNbIGkgXSApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYoIGRpc3RbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPiB3ZWlnaHQgKXtcbiAgICAgICAgICBkaXN0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gd2VpZ2h0O1xuICAgICAgICAgIG5leHRbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IGVkZ2VzWyBpIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IoIHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKysgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICBpZiggZGlzdFsgaSBdWyBrIF0gKyBkaXN0WyBrIF1bIGogXSA8IGRpc3RbIGkgXVsgaiBdICl7XG4gICAgICAgICAgICBkaXN0WyBpIF1bIGogXSA9IGRpc3RbIGkgXVsgayBdICsgZGlzdFsgayBdWyBqIF07XG4gICAgICAgICAgICBuZXh0WyBpIF1bIGogXSA9IG5leHRbIGkgXVsgayBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3RcbiAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIHBvc2l0aW9uMmlkLnB1c2goIG5vZGVzWyBpIF0uaWQoKSApO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24oIGZyb20sIHRvICl7XG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIGZyb20gKSApe1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlciggZnJvbSApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIHRvICkgKXtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlciggdG8gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdFsgaWQycG9zaXRpb25bIGZyb21JZCBdIF1bIGlkMnBvc2l0aW9uWyB0b0lkIF0gXTtcbiAgICAgIH0sXG5cbiAgICAgIHBhdGg6IGZ1bmN0aW9uKCBmcm9tLCB0byApe1xuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oIGZyb20sIHRvLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQgKXtcbiAgICAgICAgICBpZiggZnJvbSA9PT0gdG8gKXtcbiAgICAgICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbIGZyb20gXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggbmV4dFsgZnJvbSBdWyB0byBdID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGggPSBbIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFsgZnJvbSBdICkgXTtcbiAgICAgICAgICB2YXIgcHJldiA9IGZyb207XG4gICAgICAgICAgd2hpbGUoIGZyb20gIT09IHRvICl7XG4gICAgICAgICAgICBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgIGZyb20gPSBuZXh0WyBmcm9tIF1bIHRvIF07XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZU5leHRbIHByZXYgXVsgZnJvbSBdO1xuICAgICAgICAgICAgcGF0aC5wdXNoKCBlZGdlICk7XG5cbiAgICAgICAgICAgIHBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkWyBmcm9tIF0gKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXMuc3RyaW5nKCBmcm9tICkgKXtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoIGZyb20gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXMuc3RyaW5nKCB0byApICl7XG4gICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIoIHRvIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhBcnIgPSByZWNvbnN0cnVjdFBhdGhBdXgoIGlkMnBvc2l0aW9uWyBmcm9tSWQgXSxcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblsgdG9JZCBdLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgZWRnZU5leHQgKTtcblxuICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbiggcGF0aEFyciApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gIH0gLy8gZmxveWRXYXJzaGFsbFxuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbltcbiAgcmVxdWlyZSggJy4vYmZzLWRmcycgKSxcbiAgcmVxdWlyZSggJy4vZGlqa3N0cmEnICksXG4gIHJlcXVpcmUoICcuL2tydXNrYWwnICksXG4gIHJlcXVpcmUoICcuL2Etc3RhcicgKSxcbiAgcmVxdWlyZSggJy4vZmxveWQtd2Fyc2hhbGwnICksXG4gIHJlcXVpcmUoICcuL2JlbGxtYW4tZm9yZCcgKSxcbiAgcmVxdWlyZSggJy4va2VyZ2VyLXN0ZWluJyApLFxuICByZXF1aXJlKCAnLi9wYWdlLXJhbmsnICksXG4gIHJlcXVpcmUoICcuL2RlZ3JlZS1jZW50cmFsaXR5JyApLFxuICByZXF1aXJlKCAnLi9jbG9zZW5lc3MtY2VudHJhbGl0eScgKSxcbiAgcmVxdWlyZSggJy4vYmV0d2Vlbm5lc3MtY2VudHJhbGl0eScgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gIC8vIFJldHVybnMgdGhlIGNvcnJlY3QgYW5zd2VyIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuICBrYXJnZXJTdGVpbjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4gICAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG4gICAgdmFyIGNvbGFwc2UgPSBmdW5jdGlvbiggZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcyApe1xuICAgICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbIGVkZ2VJbmRleCBdO1xuICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFsgc291cmNlSW4gXTtcbiAgICAgIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFsgdGFyZ2V0SW4gXTtcblxuICAgICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzLmZpbHRlciggZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgaWYoIG5vZGVNYXBbIGVkZ2VbMV0gXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwWyBlZGdlWzJdIF0gPT09IHBhcnRpdGlvbjIgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIG5vZGVNYXBbIGVkZ2VbMV0gXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwWyBlZGdlWzJdIF0gPT09IHBhcnRpdGlvbjEgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9ICk7XG5cbiAgICAgIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZXdFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzWyBpIF07XG4gICAgICAgIGlmKCBlZGdlWzFdID09PSBwYXJ0aXRpb24yICl7IC8vIENoZWNrIHNvdXJjZVxuICAgICAgICAgIG5ld0VkZ2VzWyBpIF0gPSBlZGdlLnNsaWNlKCAwICk7XG4gICAgICAgICAgbmV3RWRnZXNbIGkgXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH0gZWxzZSBpZiggZWRnZVsyXSA9PT0gcGFydGl0aW9uMiApeyAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgICBuZXdFZGdlc1sgaSBdID0gZWRnZS5zbGljZSggMCApO1xuICAgICAgICAgIG5ld0VkZ2VzWyBpIF1bMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVNYXAubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIG5vZGVNYXBbIGkgXSA9PT0gcGFydGl0aW9uMiApe1xuICAgICAgICAgIG5vZGVNYXBbIGkgXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xuICAgIH07XG5cblxuICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24oIG1ldGFOb2RlTWFwLFxuICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzLFxuICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0ICl7XG4gICAgICAvLyBTdG9wIGNvbmRpdGlvblxuICAgICAgaWYoIHNpemUgPD0gc2l6ZUxpbWl0ICl7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKCAoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCkgKTtcblxuICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICB2YXIgbmV3RWRnZXMgPSBjb2xhcHNlKCBlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyApO1xuXG4gICAgICByZXR1cm4gY29udHJhY3RVbnRpbCggbWV0YU5vZGVNYXAsXG4gICAgICAgICAgICAgICAgIG5ld0VkZ2VzLFxuICAgICAgICAgICAgICAgICBzaXplIC0gMSxcbiAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0ICk7XG4gICAgfTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlciggZnVuY3Rpb24oIGUgKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9ICk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoIE1hdGgucG93KCBNYXRoLmxvZyggbnVtTm9kZXMgKSAvIE1hdGguTE4yLCAyICkgKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKCBudW1Ob2RlcyAvIE1hdGguc3FydCggMiApICk7XG5cbiAgICBpZiggbnVtTm9kZXMgPCAyICl7XG4gICAgICB1dGlsLmVycm9yKCAnQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nICk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZDJwb3NpdGlvblsgbm9kZXNbIGkgXS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKyApe1xuICAgICAgdmFyIGUgPSBlZGdlc1sgaSBdO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaCggWyBpLCBpZDJwb3NpdGlvblsgZS5zb3VyY2UoKS5pZCgpIF0sIGlkMnBvc2l0aW9uWyBlLnRhcmdldCgpLmlkKCkgXSBdICk7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dDtcblxuICAgIC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgIHZhciBvcmlnaW5hbE1ldGFOb2RlID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBvcmlnaW5hbE1ldGFOb2RlLnB1c2goIGkgKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IoIHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKysgKXtcbiAgICAgIC8vIENyZWF0ZSBuZXcgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgdmFyIG1ldGFOb2RlTWFwID0gb3JpZ2luYWxNZXRhTm9kZS5zbGljZSggMCApO1xuXG4gICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbCggbWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLCBudW1Ob2Rlcywgc3RvcFNpemUgKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgIHZhciBtZXRhTm9kZU1hcDIgPSBtZXRhTm9kZU1hcC5zbGljZSggMCApO1xuXG4gICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwoIG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMiApO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKCBtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyICk7XG5cbiAgICAgIC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG4gICAgICBpZiggcmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplICl7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0ID0gWyByZXMxLCBtZXRhTm9kZU1hcCBdO1xuICAgICAgfSBlbHNlIGlmKCByZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUgKXtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXQgPSBbIHJlczIsIG1ldGFOb2RlTWFwMiBdO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlc0VkZ2VzID0gKG1pbkN1dFswXSkubWFwKCBmdW5jdGlvbiggZSApeyByZXR1cm4gZWRnZXNbIGVbMF0gXTsgfSApO1xuICAgIHZhciBwYXJ0aXRpb24xID0gW107XG4gICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dFsxXVswXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdWyBpIF07XG4gICAgICBpZiggcGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uICl7XG4gICAgICAgIHBhcnRpdGlvbjEucHVzaCggbm9kZXNbIGkgXSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5wdXNoKCBub2Rlc1sgaSBdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGN1dDogZWxlcy5zcGF3biggY3ksIHJlc0VkZ2VzICksXG4gICAgICBwYXJ0aXRpb24xOiBlbGVzLnNwYXduKCBwYXJ0aXRpb24xICksXG4gICAgICBwYXJ0aXRpb24yOiBlbGVzLnNwYXduKCBwYXJ0aXRpb24yIClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufSk7IC8vIGVsZXNmblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBrcnVza2FsOiBmdW5jdGlvbiggd2VpZ2h0Rm4gKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB3ZWlnaHRGbiA9IGlzLmZuKCB3ZWlnaHRGbiApID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgZnVuY3Rpb24gZmluZFNldCggZWxlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFsgaSBdO1xuXG4gICAgICAgIGlmKCBlbGVzLmFueVNhbWUoIGVsZSApICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQSA9IGN5LmNvbGxlY3Rpb24oIGN5LCBbXSApO1xuICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBmb3Jlc3QucHVzaCggbm9kZXNbIGkgXS5jb2xsZWN0aW9uKCkgKTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgdmFyIFMgPSBlZGdlcy50b0FycmF5KCkuc29ydCggZnVuY3Rpb24oIGEsIGIgKXtcbiAgICAgIHZhciB3ZWlnaHRBID0gd2VpZ2h0Rm4oIGEgKTtcbiAgICAgIHZhciB3ZWlnaHRCID0gd2VpZ2h0Rm4oIGIgKTtcblxuICAgICAgcmV0dXJuIHdlaWdodEEgLSB3ZWlnaHRCO1xuICAgIH0gKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgUy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBTWyBpIF07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VSA9IGZpbmRTZXQoIHUgKTtcbiAgICAgIHZhciBzZXRWID0gZmluZFNldCggdiApO1xuXG4gICAgICBpZiggc2V0VS5pbmRleCAhPT0gc2V0Vi5pbmRleCApe1xuICAgICAgICBBID0gQS5hZGQoIGVkZ2UgKTtcblxuICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgZm9yZXN0WyBzZXRVLmluZGV4IF0gPSBzZXRVLmVsZXMuYWRkKCBzZXRWLmVsZXMgKTtcbiAgICAgICAgZm9yZXN0LnNwbGljZSggc2V0Vi5pbmRleCwgMSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlcy5hZGQoIEEgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIHBhZ2VSYW5rOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG5vcm1hbGl6ZVZlY3RvciA9IGZ1bmN0aW9uKCB2ZWN0b3IgKXtcbiAgICAgIHZhciBsZW5ndGggPSB2ZWN0b3IubGVuZ3RoO1xuXG4gICAgICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRvdGFsICs9IHZlY3RvclsgaSBdO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZlY3RvclsgaSBdID0gdmVjdG9yWyBpIF0gLyB0b3RhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZGFtcGluZ0ZhY3RvciAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5kYW1waW5nRmFjdG9yICE9IG51bGwgKXtcbiAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gb3B0aW9ucy5kYW1waW5nRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IDAuODsgLy8gRGVmYXVsdCBkYW1waW5nIGZhY3RvclxuICAgIH1cblxuICAgIC8vIGRlc2lyZWQgcHJlY2lzaW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICBvcHRpb25zLnByZWNpc2lvbiAhPSBudWxsICl7XG4gICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDAxOyAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIH1cblxuICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5pdGVyYXRpb25zICE9IG51bGwgKXtcbiAgICAgIHZhciBudW1JdGVyID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbnVtSXRlciA9IDIwMDsgLy8gRGVmYXVsdCBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgIH1cblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJlxuICAgICAgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZDJwb3NpdGlvblsgbm9kZXNbIGkgXS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICB2YXIgbWF0cml4ID0gW107XG4gICAgdmFyIGNvbHVtblN1bSA9IFtdO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpY1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgdmFyIG5ld1JvdyA9IFtdO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgIG5ld1Jvdy5wdXNoKCAwLjAgKTtcbiAgICAgIH1cbiAgICAgIG1hdHJpeC5wdXNoKCBuZXdSb3cgKTtcbiAgICAgIGNvbHVtblN1bS5wdXNoKCAwLjAgKTtcbiAgICB9XG5cbiAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbIGkgXTtcbiAgICAgIHZhciBzID0gaWQycG9zaXRpb25bIGVkZ2Uuc291cmNlKCkuaWQoKSBdO1xuICAgICAgdmFyIHQgPSBpZDJwb3NpdGlvblsgZWRnZS50YXJnZXQoKS5pZCgpIF07XG4gICAgICB2YXIgdyA9IHdlaWdodEZuKCBlZGdlICk7XG5cbiAgICAgIC8vIFVwZGF0ZSBtYXRyaXhcbiAgICAgIG1hdHJpeFsgdCBdWyBzIF0gKz0gdztcblxuICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgIGNvbHVtblN1bVsgcyBdICs9IHc7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG4gICAgdmFyIHAgPSAxLjAgLyBudW1Ob2RlcyArIGFkZGl0aW9uYWxQcm9iOyAvLyBTaG9ydGhhbmRcbiAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgIGlmKCBjb2x1bW5TdW1bIGogXSA9PT0gMCApe1xuICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgICBtYXRyaXhbIGkgXVsgaiBdID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICAgIG1hdHJpeFsgaSBdWyBqIF0gPSBtYXRyaXhbIGkgXVsgaiBdIC8gY29sdW1uU3VtWyBqIF0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG4gICAgdmFyIGVpZ2VudmVjdG9yID0gW107XG4gICAgdmFyIG51bGxWZWN0b3IgPSBbXTtcbiAgICB2YXIgcHJldmlvdXM7XG5cbiAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgZWlnZW52ZWN0b3IucHVzaCggMS4wICk7XG4gICAgICBudWxsVmVjdG9yLnB1c2goIDAuMCApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGl0ZXIgPSAwOyBpdGVyIDwgbnVtSXRlcjsgaXRlcisrICl7XG4gICAgICAvLyBOZXcgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICB2YXIgdGVtcCA9IG51bGxWZWN0b3Iuc2xpY2UoIDAgKTtcblxuICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgICAgdGVtcFsgaSBdICs9IG1hdHJpeFsgaSBdWyBqIF0gKiBlaWdlbnZlY3RvclsgaiBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vcm1hbGl6ZVZlY3RvciggdGVtcCApO1xuICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcblxuICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgZGlmZiArPSBNYXRoLnBvdyggcHJldmlvdXNbIGkgXSAtIGVpZ2VudmVjdG9yWyBpIF0sIDIgKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgaWYoIGRpZmYgPCBlcHNpbG9uICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgcmVzID0ge1xuICAgICAgcmFuazogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgaWYoIGlzLnN0cmluZyggbm9kZSApICl7XG4gICAgICAgICAgLy8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgbm9kZUlkID0gKGN5LmZpbHRlciggbm9kZSApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgbm9kZSBvYmplY3RcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlaWdlbnZlY3RvclsgaWQycG9zaXRpb25bIG5vZGVJZCBdIF07XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4uL2RlZmluZScgKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBjbGFzc2VzOiBmdW5jdGlvbiggY2xhc3NlcyApe1xuICAgIGNsYXNzZXMgPSAoIGNsYXNzZXMgfHwgJycgKS5tYXRjaCggL1xcUysvZyApIHx8IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzTWFwID0ge307XG5cbiAgICAvLyBmaWxsIGluIGNsYXNzZXMgbWFwXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1sgaSBdO1xuXG4gICAgICBjbGFzc2VzTWFwWyBjbHMgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGVsZSA9IHNlbGZbIGogXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzWyBpIF07XG4gICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXNbIGNscyBdO1xuXG4gICAgICAgIGlmKCAhZWxlSGFzQ2xhc3MgKXtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcbiAgICAgIGlmKCAhY2hhbmdlZEVsZSApe1xuICAgICAgICB2YXIgY2xhc3NlcyA9IE9iamVjdC5rZXlzKCBlbGVDbGFzc2VzICk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZUNscyA9IGNsYXNzZXNbaV07XG4gICAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlc1sgZWxlQ2xzIF07XG4gICAgICAgICAgdmFyIHNwZWNkQ2xhc3MgPSBjbGFzc2VzTWFwWyBlbGVDbHMgXTsgLy8gaS5lLiB0aGlzIGNsYXNzIGlzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cblxuICAgICAgICAgIGlmKCBlbGVIYXNDbGFzcyAmJiAhc3BlY2RDbGFzcyApe1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGNoYW5nZWRFbGUgKXtcbiAgICAgICAgX3AuY2xhc3NlcyA9IHV0aWwuY29weSggY2xhc3Nlc01hcCApO1xuXG4gICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgdGhpcy5zcGF3biggY2hhbmdlZCApXG4gICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgIC50cmlnZ2VyKCAnY2xhc3MnIClcbiAgICAgIDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICBhZGRDbGFzczogZnVuY3Rpb24oIGNsYXNzZXMgKXtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyggY2xhc3NlcywgdHJ1ZSApO1xuICB9LFxuXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuICggZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXNbIGNsYXNzTmFtZSBdICkgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzU3RyLCB0b2dnbGUgKXtcbiAgICB2YXIgY2xhc3NlcyA9IGNsYXNzZXNTdHIubWF0Y2goIC9cXFMrL2cgKSB8fCBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZlsgaSBdO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzWyBqIF07XG4gICAgICAgIHZhciBlbGVDbGFzc2VzID0gZWxlLl9wcml2YXRlLmNsYXNzZXM7XG4gICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZUNsYXNzZXNbIGNscyBdO1xuICAgICAgICB2YXIgc2hvdWxkQWRkID0gdG9nZ2xlIHx8ICh0b2dnbGUgPT09IHVuZGVmaW5lZCAmJiAhaGFzQ2xhc3MpO1xuXG4gICAgICAgIGlmKCBzaG91bGRBZGQgKXtcbiAgICAgICAgICBlbGVDbGFzc2VzWyBjbHMgXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggIWhhc0NsYXNzICYmICFjaGFuZ2VkRWxlICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJlbW92ZVxuICAgICAgICAgIGVsZUNsYXNzZXNbIGNscyBdID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiggaGFzQ2xhc3MgJiYgIWNoYW5nZWRFbGUgKXtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG4gICAgfSAvLyBmb3IgaSBlbGVzXG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICB0aGlzLnNwYXduKCBjaGFuZ2VkIClcbiAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgLnRyaWdnZXIoICdjbGFzcycgKVxuICAgICAgO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggY2xhc3NlcyApe1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKCBjbGFzc2VzLCBmYWxzZSApO1xuICB9LFxuXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzLCBkdXJhdGlvbiApe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCBkdXJhdGlvbiA9PSBudWxsICl7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYoIGR1cmF0aW9uID09PSAwICl7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG5cbiAgICBzZWxmLmFkZENsYXNzKCBjbGFzc2VzICk7XG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICB9LCBkdXJhdGlvbiApO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoJy4uL3NlbGVjdG9yJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBhbGxBcmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yICk7XG5cbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoIGVsZSApO1xuICAgIH0pO1xuICB9LFxuXG4gIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKCBzZWxlY3RvciApO1xuXG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoIGVsZSApO1xuICAgIH0pO1xuICB9LFxuXG4gIHNvbWU6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbIGkgXSwgaSwgdGhpcyApIDogZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1sgaSBdLCBpLCB0aGlzIF0gKTtcblxuICAgICAgaWYoIHJldCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZXZlcnk6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbIGkgXSwgaSwgdGhpcyApIDogZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1sgaSBdLCBpLCB0aGlzIF0gKTtcblxuICAgICAgaWYoICFyZXQgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAvLyBjaGVhcCBleHRyYSBjaGVja1xuICAgIGlmKCB0aGlzLmxlbmd0aCAhPT0gY29sbGVjdGlvbi5sZW5ndGggKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKCBlbGUuaWQoKSApO1xuICAgIH0pO1xuICB9LFxuXG4gIGFueVNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoIGVsZS5pZCgpICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgdmFyIG5ob29kID0gdGhpcy5uZWlnaGJvcmhvb2QoKTtcblxuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBuaG9vZC5oYXNFbGVtZW50V2l0aElkKCBlbGUuaWQoKSApO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZCggZWxlLmlkKCkgKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmVsZXNmbi5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuLmFsbEFyZU5laWdoYm9ycztcbmVsZXNmbi5oYXMgPSBlbGVzZm4uY29udGFpbnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgcGFyZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuICAgIGlmKCB0aGlzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbMF0uX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICBpZiggcGFyZW50ICl7IHJldHVybiBwYXJlbnQ7IH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgaWYoIHBhcmVudCApe1xuICAgICAgICBwYXJlbnRzLnB1c2goIHBhcmVudCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIHBhcmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICAgIHBhcmVudHMucHVzaCggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGFuY2VzdG9ycztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcblxuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG5cbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QoIHBhcmVudHMgKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBvcnBoYW5zOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlciggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjaGlsZHJlbjogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCggZWxlLl9wcml2YXRlLmNoaWxkcmVuICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGNoaWxkcmVuLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBpc1BhcmVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG5cbiAgaXNDaGlsZGxlc3M6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9LFxuXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgaXNPcnBoYW46IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPT0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKCBlbGVzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcblxuICAgICAgICBpZiggZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSApe1xuICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFkZCggdGhpcy5jaGlsZHJlbigpICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4uYW5jZXN0b3JzID0gZWxlc2ZuLnBhcmVudHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4uL2RlZmluZScgKTtcbnZhciBmbiwgZWxlc2ZuO1xuXG5mbiA9IGVsZXNmbiA9ICh7XG5cbiAgZGF0YTogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcnNjcmF0Y2g6IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKCB7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9ICksXG5cbiAgaWQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG5cbn0pO1xuXG4vLyBhbGlhc2VzXG5mbi5hdHRyID0gZm4uZGF0YTtcbmZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgaWYoIHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpICl7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1sgaSBdO1xuXG4gICAgICAgIGlmKCAhaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayggbm9kZSwgZWRnZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVncmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oIGZ1bmN0aW9uKCBub2RlLCBlZGdlICl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggZWRnZS50YXJnZXQoKSApICl7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9ICksXG5cbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKCBmdW5jdGlvbiggbm9kZSwgZWRnZSApe1xuICAgIGlmKCBlZGdlLnRhcmdldCgpLnNhbWUoIG5vZGUgKSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSApLFxuXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oIGZ1bmN0aW9uKCBub2RlLCBlZGdlICl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggbm9kZSApICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9IClcbn0gKTtcblxuZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oIGRlZ3JlZUZuLCBjYWxsYmFjayApe1xuICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgZGVncmVlID0gZWxlWyBkZWdyZWVGbiBdKCBpbmNsdWRlTG9vcHMgKTtcbiAgICAgIGlmKCBkZWdyZWUgIT09IHVuZGVmaW5lZCAmJiAocmV0ID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2soIGRlZ3JlZSwgcmV0ICkpICl7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdkZWdyZWUnLCBmdW5jdGlvbiggZGVncmVlLCBtaW4gKXtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9ICksXG5cbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ2RlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1heCApe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0gKSxcblxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdpbmRlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1pbiApe1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0gKSxcblxuICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdpbmRlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1heCApe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0gKSxcblxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCAnb3V0ZGVncmVlJywgZnVuY3Rpb24oIGRlZ3JlZSwgbWluICl7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSApLFxuXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdvdXRkZWdyZWUnLCBmdW5jdGlvbiggZGVncmVlLCBtYXggKXtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9IClcbn0gKTtcblxudXRpbC5leHRlbmQoIGVsZXNmbiwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdG90YWwgKz0gbm9kZXNbIGkgXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vbWF0aCcgKTtcbnZhciBmbiwgZWxlc2ZuO1xuXG5mbiA9IGVsZXNmbiA9ICh7XG5cbiAgcG9zaXRpb246IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICdydHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyAneCcsICd5JyBdLFxuICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCkgJiYgIWVsZS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfSApLFxuXG4gIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgc2lsZW50UG9zaXRpb246IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB2YWxpZEtleXM6IFsgJ3gnLCAneScgXSxcbiAgICBvblNldDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgfSxcbiAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpICYmICFlbGUuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH0gKSxcblxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MsIHNpbGVudCApe1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggcG9zICkgKXtcbiAgICAgIGlmKCBzaWxlbnQgKXtcbiAgICAgICAgdGhpcy5zaWxlbnRQb3NpdGlvbiggcG9zICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKCBwb3MgKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggaXMuZm4oIHBvcyApICl7XG4gICAgICB2YXIgZm4gPSBwb3M7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuXG4gICAgICAgIHZhciBwb3MgPSBmbiggZWxlLCBpICk7XG5cbiAgICAgICAgaWYoIHBvcyAmJiAhZWxlLmxvY2tlZCgpICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICAgIHZhciBlbGVQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgZWxlUG9zLnggPSBwb3MueDtcbiAgICAgICAgICBlbGVQb3MueSA9IHBvcy55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICAgIGlmKCBzaWxlbnQgKXtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCAncG9zaXRpb24nICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ0cmlnZ2VyKCAncG9zaXRpb24nICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiggcG9zICl7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKCBwb3MsIHRydWUgKTtcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcnBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyggZGltICkgKTtcblxuICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG5cbiAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvblsgZGltIF0gPSAoIHZhbCAtIHBhblsgZGltIF0gKSAvIHpvb207XG4gICAgICAgICAgfSBlbHNlIGlmKCBycG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvIHpvb20sXG4gICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvIHpvb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydHJpZ2dlciggJ3Bvc2l0aW9uJyApO1xuICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICBycG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBycG9zWyBkaW0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyggZGltICkgKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uWyBkaW0gXSA9IHZhbCArIG9yaWdpblsgZGltIF07XG4gICAgICAgICAgfSBlbHNlIGlmKCBwcG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgICB0aGlzLnJ0cmlnZ2VyKCAncG9zaXRpb24nICk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICBwcG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54IC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBvcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1sgZGltIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KCBvcHRpb25zICk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkxOiB5MSxcbiAgICAgIHkyOiB5MixcbiAgICAgIHc6IHgyIC0geDEsXG4gICAgICBoOiB5MiAtIHkxXG4gICAgfTtcbiAgfSxcblxuICBkaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHEgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgcS5wdXNoKCB0aGlzW2ldICk7XG4gICAgfVxuXG4gICAgd2hpbGUoIHEubGVuZ3RoID4gMCApe1xuICAgICAgdmFyIGVsZSA9IHEuc2hpZnQoKTtcblxuICAgICAgZWxlLl9wcml2YXRlLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSBmYWxzZTtcblxuICAgICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIGVsZS50cmlnZ2VyKCdib3VuZHMnKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5pc0NoaWxkKCkgKXtcbiAgICAgICAgcS5wdXNoKCBlbGUucGFyZW50KCkgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB1cGRhdGVDb21wb3VuZEJvdW5kczogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgdXBkYXRlZCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCBwYXJlbnQgKXtcbiAgICAgIGlmKCAhcGFyZW50LmlzUGFyZW50KCkgKXsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBfcCA9IHBhcmVudC5fcHJpdmF0ZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnICkudmFsdWUgPT09ICdpbmNsdWRlJztcblxuICAgICAgdmFyIG1pbiA9IHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoICdtaW4td2lkdGgnICkucGZWYWx1ZSxcbiAgICAgICAgICBsZWZ0OiBwYXJlbnQucHN0eWxlKCAnbWluLXdpZHRoLWJpYXMtbGVmdCcgKSxcbiAgICAgICAgICByaWdodDogcGFyZW50LnBzdHlsZSggJ21pbi13aWR0aC1iaWFzLXJpZ2h0JyApXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSggJ21pbi1oZWlnaHQnICkucGZWYWx1ZSxcbiAgICAgICAgICB0b3A6IHBhcmVudC5wc3R5bGUoICdtaW4taGVpZ2h0LWJpYXMtdG9wJyApLFxuICAgICAgICAgIGJvdHRvbTogcGFyZW50LnBzdHlsZSggJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nIClcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goIHtcbiAgICAgICAgaW5jbHVkZUxhYmVsczogaW5jbHVkZUxhYmVscyxcbiAgICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcblxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgY29tcG91bmQgYm91bmRzIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgcmVndWxhclxuICAgICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICAgIH0gKTtcbiAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZUJpYXNWYWx1ZXMoIHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50ICl7XG4gICAgICAgIHZhciBiaWFzRGlmZiA9IDA7XG4gICAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG5cbiAgICAgICAgaWYoIHByb3BEaWZmID4gMCAmJiBiaWFzVG90YWwgPiAwICl7XG4gICAgICAgICAgYmlhc0RpZmYgPSAoIHByb3BCaWFzIC8gYmlhc1RvdGFsICkgKiBwcm9wRGlmZjtcbiAgICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSAoIHByb3BCaWFzQ29tcGxlbWVudCAvIGJpYXNUb3RhbCApICogcHJvcERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiaWFzRGlmZjogYmlhc0RpZmYsXG4gICAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVBhZGRpbmdWYWx1ZXMoIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdPYmplY3QsIHJlbGF0aXZlVG8gKSB7XG4gICAgICAgIC8vIEFzc3VtaW5nIHBlcmNlbnRhZ2UgaXMgbnVtYmVyIGZyb20gMCB0byAxXG4gICAgICAgIGlmKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICclJykge1xuICAgICAgICAgIHN3aXRjaChyZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG4gICAgICAgICAgICBjYXNlICdhdmVyYWdlJzpcbiAgICAgICAgICAgICAgcmV0dXJuICggd2lkdGggPiAwICkgJiYgKCBoZWlnaHQgPiAwICkgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiAoIHdpZHRoICsgaGVpZ2h0ICkgLyAyIDogMDtcbiAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICAgIHJldHVybiAoIHdpZHRoID4gMCApICYmICggaGVpZ2h0ID4gMCApID8gKCAoIHdpZHRoID4gaGVpZ2h0ICkgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCApIDogMDtcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgIHJldHVybiAoIHdpZHRoID4gMCApICYmICggaGVpZ2h0ID4gMCApID8gKCAoIHdpZHRoID4gaGVpZ2h0ICkgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCApIDogMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICByZXR1cm4gcGFkZGluZ09iamVjdC5wZlZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG4gICAgICBpZiggbWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDAgKXtcbiAgICAgICAgbGVmdFZhbCA9ICggbGVmdFZhbCAqIDEwMCApIC8gbWluLndpZHRoLnZhbDtcbiAgICAgIH1cbiAgICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcbiAgICAgIGlmKCBtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDAgKXtcbiAgICAgICAgcmlnaHRWYWwgPSAoIHJpZ2h0VmFsICogMTAwICkgLyBtaW4ud2lkdGgudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG4gICAgICBpZiggbWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwICl7XG4gICAgICAgIHRvcFZhbCA9ICggdG9wVmFsICogMTAwICkgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuICAgICAgaWYoIG1pbi5oZWlnaHQuYm90dG9tLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCApe1xuICAgICAgICBib3R0b21WYWwgPSAoIGJvdHRvbVZhbCAqIDEwMCApIC8gbWluLmhlaWdodC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKCBtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwgKTtcbiAgICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcblxuICAgICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKCBtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsICk7XG4gICAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcblxuICAgICAgX3AuYXV0b1BhZGRpbmcgPSBjb21wdXRlUGFkZGluZ1ZhbHVlcyggYmIudywgYmIuaCwgZWxlLnBzdHlsZSggJ3BhZGRpbmcnICksIGVsZS5wc3R5bGUoICdwYWRkaW5nLXJlbGF0aXZlLXRvJyApLnZhbHVlICk7XG5cbiAgICAgIF9wLmF1dG9XaWR0aCA9IE1hdGgubWF4KGJiLncsIG1pbi53aWR0aC52YWwpO1xuICAgICAgcG9zLnggPSAoLSBkaWZmTGVmdCArIGJiLngxICsgYmIueDIgKyBkaWZmUmlnaHQpIC8gMjtcblxuICAgICAgX3AuYXV0b0hlaWdodCA9IE1hdGgubWF4KGJiLmgsIG1pbi5oZWlnaHQudmFsKTtcbiAgICAgIHBvcy55ID0gKC0gZGlmZkJvdHRvbSArIGJiLnkxICsgYmIueTIgKyBkaWZmVG9wKSAvIDI7XG5cbiAgICAgIHVwZGF0ZWQucHVzaCggcGFyZW50ICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYoICFfcC5jb21wb3VuZEJvdW5kc0NsZWFuICl7XG4gICAgICAgIHVwZGF0ZSggZWxlICk7XG5cbiAgICAgICAgaWYoICFjeS5fcHJpdmF0ZS5iYXRjaGluZ1N0eWxlICl7XG4gICAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbnZhciBub25pbmYgPSBmdW5jdGlvbiggeCApe1xuICBpZiggeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5ICl7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiggYiwgeDEsIHkxLCB4MiwgeTIgKXtcbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gIGlmKCB4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgYi54MSA9IHgxIDwgYi54MSA/IHgxIDogYi54MTtcbiAgYi54MiA9IHgyID4gYi54MiA/IHgyIDogYi54MjtcbiAgYi55MSA9IHkxIDwgYi55MSA/IHkxIDogYi55MTtcbiAgYi55MiA9IHkyID4gYi55MiA/IHkyIDogYi55Mjtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24oIGIsIGIyICl7XG4gIHJldHVybiB1cGRhdGVCb3VuZHMoIGIsIGIyLngxLCBiMi55MSwgYjIueDIsIGIyLnkyICk7XG59O1xuXG52YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIGZpZWxkLCBwcmVmaXggKXtcbiAgcmV0dXJuIHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggb2JqLCBmaWVsZCwgcHJlZml4ICk7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24oIGJvdW5kcywgZWxlLCBwcmVmaXgsIG9wdGlvbnMgKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgaGFsZkFyVyA9IHJzdHlsZS5hcnJvd1dpZHRoIC8gMjtcbiAgdmFyIGFycm93VHlwZSA9IGVsZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctc2hhcGUnICkudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiggYXJyb3dUeXBlICE9PSAnbm9uZScgKXtcbiAgICBpZiggcHJlZml4ID09PSAnc291cmNlJyApe1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiggcHJlZml4ID09PSAndGFyZ2V0JyApe1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfVxuXG4gICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIHggLSBoYWxmQXJXLCB5IC0gaGFsZkFyVywgeCArIGhhbGZBclcsIHkgKyBoYWxmQXJXICk7XG4gIH1cbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiggYm91bmRzLCBlbGUsIHByZWZpeCwgb3B0aW9ucyApe1xuICB2YXIgcHJlZml4RGFzaDtcblxuICBpZiggcHJlZml4ICl7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAnbGFiZWwnICkuc3RyVmFsdWU7XG5cbiAgaWYoIGxhYmVsICl7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LWhhbGlnbicgKTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtdmFsaWduJyApO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eSggcnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCApO1xuICAgIHZhciBsYWJlbEhlaWdodCA9IHByZWZpeGVkUHJvcGVydHkoIHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4ICk7XG4gICAgdmFyIGxhYmVsWCA9IHByZWZpeGVkUHJvcGVydHkoIHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCApO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KCByc3R5bGUsICdsYWJlbFknLCBwcmVmaXggKTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcgKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZSggcHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JyApLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKCBwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nICk7XG4gICAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyApLnBmVmFsdWU7XG5cbiAgICB2YXIgbGggPSBsYWJlbEhlaWdodCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGggKyAyICogcGFkZGluZztcbiAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgaWYoIGlzRWRnZSApe1xuICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoKCBoYWxpZ24udmFsdWUgKXtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCggdmFsaWduLnZhbHVlICl7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0F1dG9yb3RhdGUgPSAoIGlzRWRnZSAmJiByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnICk7XG4gICAgdmFyIGlzUGZWYWx1ZSA9ICggcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDAgKTtcblxuICAgIGlmKCBpc0F1dG9yb3RhdGUgfHwgaXNQZlZhbHVlICl7XG4gICAgICB2YXIgdGhldGEgPSBpc0F1dG9yb3RhdGUgPyBwcmVmaXhlZFByb3BlcnR5KCBfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4ICkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24oIHgsIHkgKXtcbiAgICAgICAgeCA9IHggLSBsYWJlbFg7XG4gICAgICAgIHkgPSB5IC0gbGFiZWxZO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBsYWJlbFgsXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBsYWJlbFlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZSggbHgxLCBseTEgKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZSggbHgxLCBseTIgKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZSggbHgyLCBseTEgKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZSggbHgyLCBseTIgKTtcblxuICAgICAgbHgxID0gTWF0aC5taW4oIHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLnggKTtcbiAgICAgIGx4MiA9IE1hdGgubWF4KCBweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54ICk7XG4gICAgICBseTEgPSBNYXRoLm1pbiggcHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSApO1xuICAgICAgbHkyID0gTWF0aC5tYXgoIHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkgKTtcbiAgICB9XG5cbiAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KCBvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCApO1xuICAgIGx4MiArPSBtYXJnaW5YICsgTWF0aC5tYXgoIG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoICk7XG4gICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heCggb3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGggKTtcbiAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KCBvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCApO1xuXG4gICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5MiApO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uKCBlbGUsIG9wdGlvbnMgKXtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3lfcC5zdHlsZUVuYWJsZWQ7XG5cbiAgdmFyIGJvdW5kcyA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeTE6IEluZmluaXR5LFxuICAgIHgyOiAtSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCAnZGlzcGxheScgKS52YWx1ZSA6ICdlbGVtZW50JztcbiAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MiwgeCwgeTtcbiAgdmFyIGRpc3BsYXllZCA9IGRpc3BsYXkgIT09ICdub25lJztcblxuICBpZiggZGlzcGxheWVkICl7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gMDtcbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdmVybGF5cyApe1xuICAgICAgb3ZlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCAnb3ZlcmxheS1vcGFjaXR5JyApLnZhbHVlO1xuXG4gICAgICBpZiggb3ZlcmxheU9wYWNpdHkgIT09IDAgKXtcbiAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCAnb3ZlcmxheS1wYWRkaW5nJyApLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgd0hhbGYgPSAwO1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgdyA9IGVsZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlO1xuICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICB9XG5cbiAgICBpZiggaXNOb2RlICYmIG9wdGlvbnMuaW5jbHVkZU5vZGVzICl7XG4gICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICB4ID0gcG9zLng7XG4gICAgICB5ID0gcG9zLnk7XG4gICAgICB2YXIgdyA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaGFsZlcgPSB3IC8gMjtcbiAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgaGFsZkggPSBoIC8gMjtcblxuICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICBleDEgPSB4IC0gaGFsZlcgLSBvdmVybGF5UGFkZGluZztcbiAgICAgIGV4MiA9IHggKyBoYWxmVyArIG92ZXJsYXlQYWRkaW5nO1xuICAgICAgZXkxID0geSAtIGhhbGZIIC0gb3ZlcmxheVBhZGRpbmc7XG4gICAgICBleTIgPSB5ICsgaGFsZkggKyBvdmVybGF5UGFkZGluZztcblxuICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5MiApO1xuXG4gICAgfSBlbHNlIGlmKCBpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgKXtcbiAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGUgfHwge307XG5cbiAgICAgIC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgZXgxID0gTWF0aC5taW4oIHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFggKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgoIHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFggKTtcbiAgICAgICAgZXkxID0gTWF0aC5taW4oIHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkgKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgoIHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkgKTtcblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcblxuICAgICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZWNpc2UgaGF5c3RhY2tzXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBlbGUucHN0eWxlKCAnY3VydmUtc3R5bGUnICkuc3RyVmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgIGV4MiA9IGhwdHNbMV0ueDtcbiAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgIGlmKCBleDEgPiBleDIgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGV5MTtcbiAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZiApO1xuXG4gICAgICAvLyBoYW5kbGUgcG9pbnRzIGFsb25nIGVkZ2VcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB0cyA9IHJzdHlsZS5iZXppZXJQdHMgfHwgcnN0eWxlLmxpbmVQdHMgfHwgW107XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgcHQgPSBwdHNbIGogXTtcblxuICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgZXkxID0gcHQueSAtIHdIYWxmO1xuICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgaWYoIHB0cy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICB2YXIgbjEgPSBfcC5zb3VyY2U7XG4gICAgICAgICAgdmFyIG4xX3AgPSBuMS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgbjFwb3MgPSBuMV9wLnBvc2l0aW9uO1xuXG4gICAgICAgICAgdmFyIG4yID0gX3AudGFyZ2V0O1xuICAgICAgICAgIHZhciBuMl9wID0gbjIuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIG4ycG9zID0gbjJfcC5wb3NpdGlvbjtcblxuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG5cbiAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcbiAgICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgICBleTIgKz0gd0hhbGY7XG5cbiAgICAgICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gLy8gZWRnZXNcblxuICAgIC8vIG92ZXJsYXlcbiAgICAvLy8vLy8vLy8vXG5cbiAgICBpZiggc3R5bGVFbmFibGVkICl7XG5cbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcblxuICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSAtIG92ZXJsYXlQYWRkaW5nLCBleTEgLSBvdmVybGF5UGFkZGluZywgZXgyICsgb3ZlcmxheVBhZGRpbmcsIGV5MiArIG92ZXJsYXlQYWRkaW5nICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlICl7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coIGJvdW5kcywgZWxlLCAnbWlkLXNvdXJjZScsIG9wdGlvbnMgKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyggYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jywgb3B0aW9ucyApO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KCBib3VuZHMsIGVsZSwgJ3NvdXJjZScsIG9wdGlvbnMgKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyggYm91bmRzLCBlbGUsICd0YXJnZXQnLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVMYWJlbHMgKXtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbCggYm91bmRzLCBlbGUsIG51bGwsIG9wdGlvbnMgKTtcblxuICAgICAgaWYoIGlzRWRnZSApe1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoIGJvdW5kcywgZWxlLCAnc291cmNlJywgb3B0aW9ucyApO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoIGJvdW5kcywgZWxlLCAndGFyZ2V0Jywgb3B0aW9ucyApO1xuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cbiAgYm91bmRzLngxID0gbm9uaW5mKCBib3VuZHMueDEgKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKCBib3VuZHMueTEgKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKCBib3VuZHMueDIgKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKCBib3VuZHMueTIgKTtcbiAgYm91bmRzLncgPSBub25pbmYoIGJvdW5kcy54MiAtIGJvdW5kcy54MSApO1xuICBib3VuZHMuaCA9IG5vbmluZiggYm91bmRzLnkyIC0gYm91bmRzLnkxICk7XG5cbiAgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG4gIGlmKCBib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCApe1xuICAgIG1hdGguZXhwYW5kQm91bmRpbmdCb3goIGJvdW5kcywgMSApO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbnZhciB0ZiA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgaWYoIHZhbCApe1xuICAgIHJldHVybiAndCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdmJztcbiAgfVxufTtcblxudmFyIGdldEtleSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIHZhciBrZXkgPSAnJztcblxuICBrZXkgKz0gdGYoIG9wdHMuaW5jdWRlTm9kZXMgKTtcbiAga2V5ICs9IHRmKCBvcHRzLmluY2x1ZGVFZGdlcyApO1xuICBrZXkgKz0gdGYoIG9wdHMuaW5jbHVkZUxhYmVscyApO1xuICBrZXkgKz0gdGYoIG9wdHMuaW5jbHVkZU92ZXJsYXlzICk7XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbnZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiggZWxlLCBvcHRzICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGJiO1xuICB2YXIgaGVhZGxlc3MgPSBlbGUuY3koKS5oZWFkbGVzcygpO1xuICB2YXIga2V5ID0gb3B0cyA9PT0gZGVmQmJPcHRzID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KCBvcHRzICk7XG5cbiAgaWYoICFvcHRzLnVzZUNhY2hlIHx8IGhlYWRsZXNzIHx8ICFfcC5iYkNhY2hlIHx8ICFfcC5iYkNhY2hlW2tleV0gKXtcbiAgICBiYiA9IGJvdW5kaW5nQm94SW1wbCggZWxlLCBvcHRzICk7XG5cbiAgICBpZiggIWhlYWRsZXNzICl7XG4gICAgICBfcC5iYkNhY2hlID0gX3AuYmJDYWNoZSB8fCB7fTtcbiAgICAgIF9wLmJiQ2FjaGVba2V5XSA9IGJiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYiA9IF9wLmJiQ2FjaGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBiYjtcbn07XG5cbnZhciBkZWZCYk9wdHMgPSB7XG4gIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlT3ZlcmxheXM6IHRydWUsXG4gIHVzZUNhY2hlOiB0cnVlXG59O1xuXG52YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KCBkZWZCYk9wdHMgKTtcblxuZWxlc2ZuLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCB1c2VDYWNoZSApe1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICBpZiggcmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkICl7XG4gICAgcmVuZGVyZXIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCB0aGlzLCB1c2VDYWNoZSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmaWxsZWRCYk9wdHMoIG9wdGlvbnMgKXtcbiAgcmV0dXJuIHtcbiAgICBpbmNsdWRlTm9kZXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlTm9kZXMsIGRlZkJiT3B0cy5pbmNsdWRlTm9kZXMgKSxcbiAgICBpbmNsdWRlRWRnZXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlRWRnZXMsIGRlZkJiT3B0cy5pbmNsdWRlRWRnZXMgKSxcbiAgICBpbmNsdWRlTGFiZWxzOiB1dGlsLmRlZmF1bHQoIG9wdGlvbnMuaW5jbHVkZUxhYmVscywgZGVmQmJPcHRzLmluY2x1ZGVMYWJlbHMgKSxcbiAgICBpbmNsdWRlT3ZlcmxheXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMsIGRlZkJiT3B0cy5pbmNsdWRlT3ZlcmxheXMgKSxcbiAgICB1c2VDYWNoZTogdXRpbC5kZWZhdWx0KCBvcHRpb25zLnVzZUNhY2hlLCBkZWZCYk9wdHMudXNlQ2FjaGUgKVxuICB9O1xufVxuXG5lbGVzZm4uYm91bmRpbmdCb3ggPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuICBpZiggdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5fcHJpdmF0ZS5iYkNhY2hlICYmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHRydWUpICl7XG4gICAgaWYoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgb3B0aW9ucyA9IGRlZkJiT3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZpbGxlZEJiT3B0cyggb3B0aW9ucyApO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZWRCb3VuZGluZ0JveEltcGwoIHRoaXNbMF0sIG9wdGlvbnMgKTtcbiAgfVxuXG4gIHZhciBib3VuZHMgPSB7XG4gICAgeDE6IEluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkyOiAtSW5maW5pdHlcbiAgfTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMoIG9wdGlvbnMgKTtcblxuICB2YXIgZWxlcyA9IHRoaXM7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggb3B0cy51c2VDYWNoZSApO1xuICB9XG5cbiAgdmFyIHVwZGF0ZWRFZGdlID0ge307IC8vIHVzZSB0byBhdm9pZCBkdXBsaWNhdGVkIGVkZ2UgdXBkYXRlc1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBlbGUuaXNFZGdlKCkgJiYgZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZSA9PT0gJ2JlemllcicgJiYgIXVwZGF0ZWRFZGdlWyBlbGUuaWQoKSBdICl7XG4gICAgICB2YXIgZWRnZXMgPSBlbGUucGFyYWxsZWxFZGdlcygpO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7IC8vIG1ha2UgYWxsIGFzIHVwZGF0ZWRcbiAgICAgICAgdXBkYXRlZEVkZ2VbIGVkZ2VzW2pdLmlkKCkgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVkZ2VzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggb3B0cy51c2VDYWNoZSApOyAvLyBuLmIuIGVsZS5wYXJhbGxlbEVkZ2VzKCkgc2luZ2xlIGlzIGNhY2hlZFxuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goIGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKCBlbGUsIG9wdHMgKSApO1xuICB9XG5cbiAgYm91bmRzLngxID0gbm9uaW5mKCBib3VuZHMueDEgKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKCBib3VuZHMueTEgKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKCBib3VuZHMueDIgKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKCBib3VuZHMueTIgKTtcbiAgYm91bmRzLncgPSBub25pbmYoIGJvdW5kcy54MiAtIGJvdW5kcy54MSApO1xuICBib3VuZHMuaCA9IG5vbmluZiggYm91bmRzLnkyIC0gYm91bmRzLnkxICk7XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8vIHByaXZhdGUgaGVscGVyIHRvIGdldCBib3VuZGluZyBib3ggZm9yIGN1c3RvbSBub2RlIHBvc2l0aW9uc1xuLy8gLSBnb29kIGZvciBwZXJmIGluIGNlcnRhaW4gY2FzZXMgYnV0IGN1cnJlbnRseSByZXF1aXJlcyBkaXJ0eWluZyB0aGUgcmVuZGVyZWQgc3R5bGVcbi8vIC0gd291bGQgYmUgYmV0dGVyIHRvIG5vdCBtb2RpZnkgdGhlIG5vZGVzIGJ1dCB0aGUgbm9kZXMgYXJlIHJlYWQgZGlyZWN0bHkgZXZlcnl3aGVyZSBpbiB0aGUgcmVuZGVyZXIuLi5cbi8vIC0gdHJ5IHRvIHVzZSBmb3Igb25seSB0aGluZ3MgbGlrZSBkaXNjcmV0ZSBsYXlvdXRzIHdoZXJlIHRoZSBub2RlIHBvc2l0aW9uIHdvdWxkIGNoYW5nZSBhbnl3YXlcbmVsZXNmbi5ib3VuZGluZ0JveEF0ID0gZnVuY3Rpb24oIGZuICl7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9sZFBvcyA9IHt9O1xuXG4gIGlmKCBpcy5wbGFpbk9iamVjdCggZm4gKSApe1xuICAgIHZhciBvYmogPSBmbjtcblxuICAgIGZuID0gZnVuY3Rpb24oKXsgcmV0dXJuIG9iajsgfTtcbiAgfVxuXG4gIC8vIHNhdmUgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIHNldCB0aGUgbmV3IG9uZSwgcGVyIG5vZGVcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIHBvcyA9IG4uX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIG5ld1BvcyA9IGZuLmNhbGwoIG4sIGksIG4gKTtcblxuICAgIG9sZFBvc1sgbi5pZCgpIF0gPSB7IHg6IHBvcy54LCB5OiBwb3MueSB9O1xuXG4gICAgcG9zLnggPSBuZXdQb3MueDtcbiAgICBwb3MueSA9IG5ld1Bvcy55O1xuICB9XG5cbiAgdGhpcy50cmlnZ2VyKCdkaXJ0eScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgbWFudWFsbHkgZGlydGllZCByZW5kZXJlZCBkaW0gY2FsY3NcblxuICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KHsgdXNlQ2FjaGU6IGZhbHNlIH0pO1xuXG4gIC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCBwZXIgbm9kZVxuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgcG9zID0gbi5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgb2xkID0gb2xkUG9zWyBuLmlkKCkgXTtcblxuICAgIHBvcy54ID0gb2xkLng7XG4gICAgcG9zLnkgPSBvbGQueTtcbiAgfVxuXG4gIHRoaXMudHJpZ2dlcignZGlydHknKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIG1hbnVhbGx5IGRpcnRpZWQgcmVuZGVyZWQgZGltIGNhbGNzXG5cbiAgcmV0dXJuIGJiO1xufTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IHV0aWwuY2FwaXRhbGl6ZSggb3B0cy5uYW1lICk7XG4gIG9wdHMuYXV0b05hbWUgPSAnYXV0bycgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMubGFiZWxOYW1lID0gJ2xhYmVsJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5vdXRlck5hbWUgPSAnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSA9IHV0aWwuY2FwaXRhbGl6ZSggb3B0cy5vdXRlck5hbWUgKTtcblxuICBmblsgb3B0cy5uYW1lIF0gPSBmdW5jdGlvbiBkaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGlmKCBlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgICAgICAgcmV0dXJuIF9wWyBvcHRzLmF1dG9OYW1lIF0gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkID0gZWxlLnBzdHlsZSggb3B0cy5uYW1lICk7XG5cbiAgICAgICAgc3dpdGNoKCBkLnN0clZhbHVlICl7XG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgcmV0dXJuIF9wLnJzdHlsZVsgb3B0cy5sYWJlbE5hbWUgXSB8fCAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZC5wZlZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm5bICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWUgXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICB2YXIgZGltID0gZWxlWyBvcHRzLm5hbWUgXSgpO1xuICAgICAgICB2YXIgYm9yZGVyID0gZWxlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlOyAvLyBuLmIuIDEvMiBlYWNoIHNpZGVcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBhZGRpbmcoKTtcblxuICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsgJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgZCA9IGVsZVsgb3B0cy5uYW1lIF0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG5cbiAgZm5bICdyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBvZCA9IGVsZVsgb3B0cy5vdXRlck5hbWUgXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoIHtcbiAgbmFtZTogJ3dpZHRoJ1xufSApO1xuXG5kZWZpbmVEaW1GbnMoIHtcbiAgbmFtZTogJ2hlaWdodCdcbn0gKTtcblxuZWxlc2ZuLnBhZGRpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgIGlmKCBfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICB9XG59XG5cbi8vIGFsaWFzZXNcbmZuLm1vZGVsUG9zaXRpb24gPSBmbi5wb2ludCA9IGZuLnBvc2l0aW9uO1xuZm4ubW9kZWxQb3NpdGlvbnMgPSBmbi5wb2ludHMgPSBmbi5wb3NpdGlvbnM7XG5mbi5yZW5kZXJlZFBvaW50ID0gZm4ucmVuZGVyZWRQb3NpdGlvbjtcbmZuLnJlbGF0aXZlUG9pbnQgPSBmbi5yZWxhdGl2ZVBvc2l0aW9uO1xuZm4uYm91bmRpbmdib3ggPSBmbi5ib3VuZGluZ0JveDtcbmZuLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbi5yZW5kZXJlZEJvdW5kaW5nQm94O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxuLy8gcmVwcmVzZW50cyBhIG5vZGUgb3IgYW4gZWRnZVxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggY3ksIHBhcmFtcywgcmVzdG9yZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlc3RvcmUgPSAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2UpO1xuXG4gIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFpcy5jb3JlKCBjeSApICl7XG4gICAgdXRpbC5lcnJvciggJ0FuIGVsZW1lbnQgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UgYW5kIHBhcmFtZXRlcnMgc2V0JyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDtcblxuICAvLyB0cnkgdG8gYXV0b21hdGljYWxseSBpbmZlciB0aGUgZ3JvdXAgaWYgdW5zcGVjaWZpZWRcbiAgaWYoIGdyb3VwID09IG51bGwgKXtcbiAgICBpZiggcGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwgKXtcbiAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGdyb3VwXG4gIGlmKCBncm91cCAhPT0gJ25vZGVzJyAmJiBncm91cCAhPT0gJ2VkZ2VzJyApe1xuICAgIHV0aWwuZXJyb3IoICdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBncm91cCArICdgJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGVsZW1lbnQgYXJyYXktbGlrZSwganVzdCBsaWtlIGEgY29sbGVjdGlvblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xuXG4gIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgc2luZ2xlOiB0cnVlLCAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sIC8vIGRhdGEgb2JqZWN0XG4gICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7fSwgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBhdXRvUGFkZGluZzogdW5kZWZpbmVkLFxuICAgIGNvbXBvdW5kQm91bmRzQ2xlYW46IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBjb21wb3VuZCBkaW1lbnNpb25zIG5lZWQgdG8gYmUgcmVjYWxjdWxhdGVkIHRoZSBuZXh0IHRpbWUgZGltZW5zaW9ucyBhcmUgcmVhZFxuICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgIGdyb3VwOiBncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHJlbW92ZWQ6IHRydWUsIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIGFjdGl2ZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IHt9LCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSwgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcmVmXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9IC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gIH07XG5cbiAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgX3AucG9zaXRpb24gPSB7XG4gICAgICB4OiAocnBvcy54IC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHk6IChycG9zLnkgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgfVxuXG4gIGlmKCBpcy5zdHJpbmcoIHBhcmFtcy5jbGFzc2VzICkgKXtcbiAgICB2YXIgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KCAvXFxzKy8gKTtcbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1sgaSBdO1xuICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICBfcC5jbGFzc2VzWyBjbHMgXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYoIHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzICl7XG4gICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3MgKTtcbiAgfVxuXG4gIGlmKCByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSApe1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBvbjogZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgb25lOiBkZWZpbmUub24oIHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9uY2U6IGRlZmluZS5vbiggeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0gKSxcbiAgb2ZmOiBkZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpLCAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG5cbiAgcnRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZXh0cmFQYXJhbXMgKXsgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYoIHRoaXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgdGhpcy5jeSgpLm5vdGlmeSgge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSApO1xuXG4gICAgdGhpcy50cmlnZ2VyKCBldmVudCwgZXh0cmFQYXJhbXMgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXM6XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oIGVsZXNmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSggJy4uL3NlbGVjdG9yJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oIGVsZSwgaSApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCBlbGUsIGkgKXtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uKCBmaWx0ZXIsIHRoaXNBcmcgKXtcbiAgICBpZiggZmlsdGVyID09PSB1bmRlZmluZWQgKXsgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyggZmlsdGVyICkgfHwgaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZmlsdGVyICkgKXtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IoIGZpbHRlciApLmZpbHRlciggdGhpcyApO1xuICAgIH0gZWxzZSBpZiggaXMuZm4oIGZpbHRlciApICl7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICAgIHZhciBpbmNsdWRlID0gdGhpc0FyZyA/IGZpbHRlci5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogZmlsdGVyKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICAgIGZpbHRlckVsZXMubWVyZ2UoIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWx0ZXJFbGVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gIH0sXG5cbiAgbm90OiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiggaXMuc3RyaW5nKCB0b1JlbW92ZSApICl7XG4gICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIoIHRvUmVtb3ZlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIHJNYXAgPSB0b1JlbW92ZS5fcHJpdmF0ZS5tYXA7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbIGkgXTtcblxuICAgICAgICB2YXIgcmVtb3ZlID0gck1hcC5oYXMoIGVsZW1lbnQuaWQoKSApO1xuICAgICAgICBpZiggIXJlbW92ZSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgICB9XG5cbiAgfSxcblxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QoIHRoaXMgKTtcbiAgfSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgaWYoIGlzLnN0cmluZyggb3RoZXIgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgdmFyIG1hcDIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUubWFwIDogY29sMS5fcHJpdmF0ZS5tYXA7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGlkID0gY29sWyBpIF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBlbnRyeSA9IG1hcDIuZ2V0KCBpZCApO1xuXG4gICAgICBpZiggZW50cnkgKXtcbiAgICAgICAgZWxlbWVudHMucHVzaCggZW50cnkuZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gIH0sXG5cbiAgeG9yOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoIGlzLnN0cmluZyggb3RoZXIgKSApe1xuICAgICAgb3RoZXIgPSBjeS4kKCBvdGhlciApO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gY29sWyBpIF07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoIGlkICk7XG5cbiAgICAgICAgaWYoICFpbk90aGVyICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBhZGQoIGNvbDEsIGNvbDIgKTtcbiAgICBhZGQoIGNvbDIsIGNvbDEgKTtcblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cyApO1xuICB9LFxuXG4gIGRpZmY6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBvdGhlciApICl7XG4gICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSBbXTtcbiAgICB2YXIgcmlnaHQgPSBbXTtcbiAgICB2YXIgYm90aCA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyLCByZXRFbGVzICl7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbIGkgXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZCggaWQgKTtcblxuICAgICAgICBpZiggaW5PdGhlciApe1xuICAgICAgICAgIGJvdGgucHVzaCggZWxlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0RWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGFkZCggY29sMSwgY29sMiwgbGVmdCApO1xuICAgIGFkZCggY29sMiwgY29sMSwgcmlnaHQgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnNwYXduKCBsZWZ0LCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICByaWdodDogdGhpcy5zcGF3biggcmlnaHQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIGJvdGg6IHRoaXMuc3Bhd24oIGJvdGgsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgIH07XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICF0b0FkZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyggdG9BZGQgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgZWxlbWVudHMucHVzaCggdGhpc1sgaSBdICk7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IHRoaXMuX3ByaXZhdGUubWFwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuXG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXMoIHRvQWRkWyBpIF0uaWQoKSApO1xuICAgICAgaWYoIGFkZCApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCB0b0FkZFsgaSBdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gIH0sXG5cbiAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIG1lcmdlOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgaWYoICF0b0FkZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIHRvQWRkICYmIGlzLnN0cmluZyggdG9BZGQgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbIGkgXTtcbiAgICAgIHZhciBpZCA9IHRvQWRkRWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXMoIGlkICk7XG5cbiAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcblxuICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG5cbiAgICAgICAgbWFwLnNldCggaWQsIHsgZWxlOiB0b0FkZEVsZSwgaW5kZXg6IGluZGV4IH0gKTtcbiAgICAgIH0gZWxzZSB7IC8vIHJlcGxhY2VcbiAgICAgICAgdmFyIGluZGV4ID0gbWFwLmdldCggaWQgKS5pbmRleDtcblxuICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoIGlkLCB7IGVsZTogdG9BZGRFbGUsIGluZGV4OiBpbmRleCB9ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGUgPSBlbGVbMF07XG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7XG4gICAgdmFyIGVudHJ5ID0gIG1hcC5nZXQoIGlkICk7XG5cbiAgICBpZiggIWVudHJ5ICl7XG4gICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICB9XG5cbiAgICB2YXIgaSA9IGVudHJ5LmluZGV4O1xuXG4gICAgLy8gcmVtb3ZlIGVsZVxuICAgIHRoaXNbIGkgXSA9IHVuZGVmaW5lZDtcbiAgICBtYXAuZGVsZXRlKCBpZCApO1xuXG4gICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICBpZiggdGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUgKXtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1sgbGFzdEVsZUkgXTtcbiAgICAgIHZhciBsYXN0RWxlSWQgPSBsYXN0RWxlLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICAgIHRoaXNbIGxhc3RFbGVJIF0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzWyBpIF0gPSBsYXN0RWxlO1xuICAgICAgbWFwLnNldCggbGFzdEVsZUlkLCB7IGVsZTogbGFzdEVsZSwgaW5kZXg6IGkgfSApO1xuICAgIH1cblxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgdGhpcy5sZW5ndGgtLTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIHRvUmVtb3ZlICYmIGlzLnN0cmluZyggdG9SZW1vdmUgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICB0b1JlbW92ZSA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUoIHRvUmVtb3ZlWyBpIF0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBtYXA6IGZ1bmN0aW9uKCBtYXBGbiwgdGhpc0FyZyApe1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IG1hcEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICkgOiBtYXBGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgIGFyci5wdXNoKCByZXQgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuXG4gIHJlZHVjZTogZnVuY3Rpb24oIGZuLCBpbml0aWFsVmFsdWUgKXtcbiAgICB2YXIgdmFsID0gaW5pdGlhbFZhbHVlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFsID0gZm4oIHZhbCwgZWxlc1tpXSwgaSwgZWxlcyApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggdmFsID4gbWF4ICl7XG4gICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWF4LFxuICAgICAgZWxlOiBtYXhFbGVcbiAgICB9O1xuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggdmFsIDwgbWluICl7XG4gICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWluLFxuICAgICAgZWxlOiBtaW5FbGVcbiAgICB9O1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xudmFyIGZuID0gZWxlc2ZuO1xuZm5bICd1JyBdID0gZm5bICd8JyBdID0gZm5bICcrJyBdID0gZm4udW5pb24gPSBmbi5vciA9IGZuLmFkZDtcbmZuWyAnXFxcXCcgXSA9IGZuWyAnIScgXSA9IGZuWyAnLScgXSA9IGZuLmRpZmZlcmVuY2UgPSBmbi5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbi5zdWJ0cmFjdCA9IGZuLm5vdDtcbmZuWyAnbicgXSA9IGZuWyAnJicgXSA9IGZuWyAnLicgXSA9IGZuLmFuZCA9IGZuLmludGVyc2VjdGlvbiA9IGZuLmludGVyc2VjdDtcbmZuWyAnXicgXSA9IGZuWyAnKCspJyBdID0gZm5bICcoLSknIF0gPSBmbi5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4uc3ltZGlmZiA9IGZuLnhvcjtcbmZuLmZuRmlsdGVyID0gZm4uZmlsdGVyRm4gPSBmbi5zdGRGaWx0ZXIgPSBmbi5maWx0ZXI7XG5mbi5jb21wbGVtZW50ID0gZm4uYWJzY29tcCA9IGZuLmFic29sdXRlQ29tcGxlbWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBpc05vZGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcblxuICBpc0VkZ2U6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcblxuICBpc0xvb3A6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpID09PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gIH0sXG5cbiAgaXNTaW1wbGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpICE9PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gIH0sXG5cbiAgZ3JvdXA6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyb3VwO1xuICAgIH1cbiAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcbnZhciBNYXAgPSByZXF1aXJlKCcuLi9tYXAnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9zZXQnKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcblxuLy8gZmFjdG9yeSBmb3IgZ2VuZXJhdGluZyBlZGdlIGlkcyB3aGVuIG5vIGlkIGlzIHNwZWNpZmllZCBmb3IgYSBuZXcgZWxlbWVudFxudmFyIGlkRmFjdG9yeSA9IHtcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKCBjeSwgZWxlbWVudCwgdHJ5VGhpc0lkICl7XG4gICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB1dGlsLnV1aWQoKTtcblxuICAgIHdoaWxlKCBjeS5oYXNFbGVtZW50V2l0aElkKCBpZCApICl7XG4gICAgICBpZCA9IHV0aWwudXVpZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxufTtcblxuLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24oIGN5LCBlbGVtZW50cywgb3B0aW9ucyApe1xuICBpZiggY3kgPT09IHVuZGVmaW5lZCB8fCAhaXMuY29yZSggY3kgKSApe1xuICAgIHV0aWwuZXJyb3IoICdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcblxuICBpZiggIWVsZW1lbnRzICl7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgfSBlbHNlIGlmKCBlbGVtZW50cy5sZW5ndGggPiAwICYmIGlzLnBsYWluT2JqZWN0KCBlbGVtZW50c1swXSApICYmICFpcy5lbGVtZW50KCBlbGVtZW50c1swXSApICl7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgdmFyIGVsZXMgPSBbXTtcbiAgICB2YXIgZWxlc0lkcyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIganNvbiA9IGVsZW1lbnRzWyBpIF07XG5cbiAgICAgIGlmKCBqc29uLmRhdGEgPT0gbnVsbCApe1xuICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG4gICAgICBpZiggZGF0YS5pZCA9PSBudWxsICl7XG4gICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBqc29uICk7XG4gICAgICB9IGVsc2UgaWYoIGN5Lmhhc0VsZW1lbnRXaXRoSWQoIGRhdGEuaWQgKSB8fCBlbGVzSWRzLmhhcyggZGF0YS5pZCApICl7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgZWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgIGVsZXNJZHMuYWRkKCBkYXRhLmlkICk7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1sgaSBdO1xuICAgIGlmKCAhZWxlbWVudCApeyAgY29udGludWU7IH1cblxuICAgIHZhciBpZCA9IGVsZW1lbnQuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgIGlmKCAhb3B0aW9ucyB8fCAoIG9wdGlvbnMudW5pcXVlICYmICFtYXAuaGFzKGlkKSApICl7XG4gICAgICBtYXAuc2V0KCBpZCwge1xuICAgICAgICBpbmRleDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGVsZTogZWxlbWVudFxuICAgICAgfSApO1xuXG4gICAgICB0aGlzWyB0aGlzLmxlbmd0aCBdID0gZWxlbWVudDtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgbWFwOiBtYXBcbiAgfTtcblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmKCBjcmVhdGVkRWxlbWVudHMgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdjb2xsZWN0aW9uJztcbn07XG5cbmVsZXNmbi5zcGF3biA9IGZ1bmN0aW9uKCBjeSwgZWxlcywgb3B0cyApe1xuICBpZiggIWlzLmNvcmUoIGN5ICkgKXsgLy8gY3kgaXMgb3B0aW9uYWxcbiAgICBvcHRzID0gZWxlcztcbiAgICBlbGVzID0gY3k7XG4gICAgY3kgPSB0aGlzLmN5KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oIGN5LCBlbGVzLCBvcHRzICk7XG59O1xuXG5lbGVzZm4uc3Bhd25TZWxmID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuc3Bhd24oIHRoaXMgKTtcbn07XG5cbmVsZXNmbi5jeSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xufTtcblxuZWxlc2ZuLmVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpc1swXTtcbn07XG5cbmVsZXNmbi5jb2xsZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgaWYoIGlzLmNvbGxlY3Rpb24oIHRoaXMgKSApe1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBbIHRoaXMgXSApO1xuICB9XG59O1xuXG5lbGVzZm4udW5pcXVlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG59O1xuXG5lbGVzZm4uaGFzRWxlbWVudFdpdGhJZCA9IGZ1bmN0aW9uKCBpZCApe1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKCBpZCApO1xufTtcblxuZWxlc2ZuLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oIGlkICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldCggaWQgKTtcblxuICByZXR1cm4gZW50cnkgPyBlbnRyeS5lbGUgOiBuZXcgQ29sbGVjdGlvbiggY3kgKTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG59O1xuXG5lbGVzZm4ucG9vbEluZGV4ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgdmFyIGlkID0gdGhpcy5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gIHJldHVybiBlbGVzLl9wcml2YXRlLm1hcC5nZXQoIGlkICkuaW5kZXg7XG59O1xuXG5lbGVzZm4uanNvbiA9IGZ1bmN0aW9uKCBvYmogKXtcbiAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgaWYoIGVsZSA9PSBudWxsICYmIG9iaiApeyByZXR1cm4gdGhpczsgfSAvLyBjYW4ndCBzZXQgdG8gbm8gZWxlc1xuXG4gIGlmKCBlbGUgPT0gbnVsbCApeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcblxuICBpZiggaXMucGxhaW5PYmplY3QoIG9iaiApICl7IC8vIHNldFxuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYoIG9iai5kYXRhICl7XG4gICAgICBlbGUuZGF0YSggb2JqLmRhdGEgKTtcbiAgICB9XG5cbiAgICBpZiggb2JqLnBvc2l0aW9uICl7XG4gICAgICBlbGUucG9zaXRpb24oIG9iai5wb3NpdGlvbiApO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBncm91cCAtLSBpbW11dGFibGVcblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uKCBrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSApe1xuICAgICAgdmFyIG9ial9rID0gb2JqWyBrIF07XG5cbiAgICAgIGlmKCBvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwWyBrIF0gKXtcbiAgICAgICAgaWYoIG9ial9rICl7XG4gICAgICAgICAgZWxlWyB0cnVlRm5OYW1lIF0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVbIGZhbHNlRm5OYW1lIF0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja1N3aXRjaCggJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnICk7XG5cbiAgICBjaGVja1N3aXRjaCggJ3NlbGVjdGVkJywgJ3NlbGVjdCcsICd1bnNlbGVjdCcgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknICk7XG5cbiAgICBjaGVja1N3aXRjaCggJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnZ3JhYmJhYmxlJywgJ2dyYWJpZnknLCAndW5ncmFiaWZ5JyApO1xuXG4gICAgaWYoIG9iai5jbGFzc2VzICE9IG51bGwgKXtcbiAgICAgIGVsZS5jbGFzc2VzKCBvYmouY2xhc3NlcyApO1xuICAgIH1cblxuICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9IGVsc2UgaWYoIG9iaiA9PT0gdW5kZWZpbmVkICl7IC8vIGdldFxuXG4gICAgdmFyIGpzb24gPSB7XG4gICAgICBkYXRhOiB1dGlsLmNvcHkoIHAuZGF0YSApLFxuICAgICAgcG9zaXRpb246IHV0aWwuY29weSggcC5wb3NpdGlvbiApLFxuICAgICAgZ3JvdXA6IHAuZ3JvdXAsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgY2xhc3NlczogbnVsbFxuICAgIH07XG5cbiAgICBqc29uLmNsYXNzZXMgPSBPYmplY3Qua2V5cyggcC5jbGFzc2VzICkuZmlsdGVyKGZ1bmN0aW9uKCBjbHMgKXtcbiAgICAgIHJldHVybiBwLmNsYXNzZXNbY2xzXTtcbiAgICB9KS5qb2luKCcgJyk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcblxuZWxlc2ZuLmpzb25zID0gZnVuY3Rpb24oKXtcbiAgdmFyIGpzb25zID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG5cbiAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gIH1cblxuICByZXR1cm4ganNvbnM7XG59O1xuXG5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgdmFyIGNsb25lID0gbmV3IEVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApOyAvLyBOQiBubyByZXN0b3JlXG5cbiAgICBlbGVzQXJyLnB1c2goIGNsb25lICk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oIGN5LCBlbGVzQXJyICk7XG59O1xuZWxlc2ZuLmNvcHkgPSBlbGVzZm4uY2xvbmU7XG5cbmVsZXNmbi5yZXN0b3JlID0gZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgZWxlbWVudHM7XG4gIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICB2YXIgZWxlID0gc2VsZlsgaSBdO1xuXG4gICAgaWYoICFlbGUucmVtb3ZlZCgpICl7XG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG4gICAgaWYoIGVsZS5pc05vZGUoKSApeyAvLyBwdXQgdG8gZnJvbnQgb2YgYXJyYXkgaWYgbm9kZVxuICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgfSBlbHNlIHsgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICB9XG4gIH1cblxuICBlbGVtZW50cyA9IG5vZGVzLmNvbmNhdCggZWRnZXMgKTtcblxuICB2YXIgaTtcbiAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgZWxlbWVudHMuc3BsaWNlKCBpLCAxICk7XG4gICAgaS0tO1xuICB9O1xuXG4gIC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcbiAgZm9yKCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZW1lbnRzWyBpIF07XG5cbiAgICB2YXIgX3ByaXZhdGUgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGRhdGEgPSBfcHJpdmF0ZS5kYXRhO1xuXG4gICAgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcbiAgICBlbGUuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuICAgIGlmKCBkYXRhLmlkID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBlbGUgKTtcblxuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCBkYXRhLmlkICkgKXtcbiAgICAgIGRhdGEuaWQgPSAnJyArIGRhdGEuaWQ7IC8vIG5vdyBpdCdzIGEgc3RyaW5nXG5cbiAgICB9IGVsc2UgaWYoIGlzLmVtcHR5U3RyaW5nKCBkYXRhLmlkICkgfHwgIWlzLnN0cmluZyggZGF0YS5pZCApICl7XG4gICAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyApO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmKCBjeS5oYXNFbGVtZW50V2l0aElkKCBkYXRhLmlkICkgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgZGF0YS5pZCArICdgJyApO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBkYXRhLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3Igbm9kZXNcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIHBvcyA9IF9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIG5vZGVzIGhhdmUgYSBkZWZpbmVkIHBvc2l0aW9uXG5cbiAgICAgIGlmKCBwb3MueCA9PSBudWxsICl7XG4gICAgICAgIHBvcy54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYoIHBvcy55ID09IG51bGwgKXtcbiAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuXG4gICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbICdzb3VyY2UnLCAndGFyZ2V0JyBdO1xuICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKysgKXtcblxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbIGogXTtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFbIGZpZWxkIF07XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggdmFsICkgKXtcbiAgICAgICAgICB2YWwgPSBkYXRhWyBmaWVsZCBdID0gJycgKyBkYXRhWyBmaWVsZCBdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiggdmFsID09IG51bGwgfHwgdmFsID09PSAnJyApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkICk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoICFjeS5oYXNFbGVtZW50V2l0aElkKCB2YWwgKSApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcgKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGJhZFNvdXJjZU9yVGFyZ2V0ICl7IHJlbW92ZUZyb21FbGVtZW50cygpOyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG4gICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuXG4gICAgLy8gY3JlYXRlIG1vY2sgaWRzIC8gaW5kZXhlcyBtYXBzIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwKCk7XG4gICAgX3ByaXZhdGUubWFwLnNldCggaWQsIHsgZWxlOiBlbGUsIGluZGV4OiAwIH0gKTtcblxuICAgIF9wcml2YXRlLnJlbW92ZWQgPSBmYWxzZTtcbiAgICBjeS5hZGRUb1Bvb2woIGVsZSApO1xuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApeyAvLyBlYWNoIG5vZGVcbiAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgdmFyIGRhdGEgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICBpZiggaXMubnVtYmVyKCBkYXRhLnBhcmVudCApICl7IC8vIHRoZW4gYXV0b21ha2Ugc3RyaW5nXG4gICAgICBkYXRhLnBhcmVudCA9ICcnICsgZGF0YS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudElkID0gZGF0YS5wYXJlbnQ7XG5cbiAgICB2YXIgc3BlY2lmaWVkUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbDtcblxuICAgIGlmKCBzcGVjaWZpZWRQYXJlbnQgKXtcbiAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKTtcblxuICAgICAgaWYoIHBhcmVudC5lbXB0eSgpICl7XG4gICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlKCAhYW5jZXN0b3IuZW1wdHkoKSApe1xuICAgICAgICAgIGlmKCBub2RlLnNhbWUoIGFuY2VzdG9yICkgKXtcbiAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgIHNlbGZBc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXNlbGZBc1BhcmVudCApe1xuICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKCBub2RlICk7XG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICAgICAgICAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcbiAgICAgICAgICBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cbiAgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgKXtcbiAgICB2YXIgcmVzdG9yZWQgPSBuZXcgQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlc3RvcmVkLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gcmVzdG9yZWRbaV07XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgICAgdmFyIHBlZGdlcyA9IGVsZS5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG4gICAgICBlbGUuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgICAgZWxlLnRhcmdldCgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG5cbiAgICB2YXIgdG9VcGRhdGVTdHlsZTtcblxuICAgIGlmKCBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSBjeS5jb2xsZWN0aW9uKCkubWVyZ2UoIHJlc3RvcmVkICkubWVyZ2UoIHJlc3RvcmVkLmNvbm5lY3RlZE5vZGVzKCkgKS5tZXJnZSggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkO1xuICAgIH1cblxuICAgIHRvVXBkYXRlU3R5bGUudXBkYXRlU3R5bGUoIG5vdGlmeVJlbmRlcmVyICk7XG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHJlc3RvcmVkLnJ0cmlnZ2VyKCAnYWRkJyApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlZC50cmlnZ2VyKCAnYWRkJyApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1vdmVkID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyggbm9kZSApe1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgYWRkKCBlZGdlc1sgaSBdICk7XG4gICAgfVxuICB9XG5cblxuICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICBmdW5jdGlvbiBhZGRDaGlsZHJlbiggbm9kZSApe1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICBhZGQoIGNoaWxkcmVuWyBpIF0gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGQoIGVsZSApe1xuICAgIHZhciBhbHJlYWR5QWRkZWQgPSAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdO1xuICAgIGlmKCBhbHJlYWR5QWRkZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaCggZWxlICk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoIGVsZSApO1xuICAgICAgYWRkQ2hpbGRyZW4oIGVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdCggZWxlICk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgLy8gKG1heSBiZSByZW1vdmluZyBtb3JlIHRoYW4gc3BlY2lmaWVkIGR1ZSB0byBjb25uZWN0ZWQgZWRnZXMgZXRjKVxuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICB2YXIgZWxlID0gc2VsZlsgaSBdO1xuXG4gICAgYWRkKCBlbGUgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYoIG5vZGUsIGVkZ2UgKXtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIGNvbm5lY3RlZEVkZ2VzLCBlZGdlICk7XG5cbiAgICAvLyByZW1vdmluZyBhbiBlZGdlcyBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciBpdHMgbm9kZXNcbiAgICBub2RlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmcyggZWRnZSApe1xuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgIGVkZ2UucGFyYWxsZWxFZGdlcygpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuXG4gIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZiggcGFyZW50LCBlbGUgKXtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuICAgIHZhciBwaWQgPSBwYXJlbnQuaWQoKTtcblxuICAgIHV0aWwucmVtb3ZlRnJvbUFycmF5KCBjaGlsZHJlbiwgZWxlICk7XG5cbiAgICBpZiggIWFsdGVyZWRQYXJlbnRzLmlkc1sgcGlkIF0gKXtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1sgcGlkIF0gPSB0cnVlO1xuICAgICAgYWx0ZXJlZFBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGZyb20gY29yZSBwb29sXG4gIGN5LnJlbW92ZUZyb21Qb29sKCBlbGVzVG9SZW1vdmUgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbIGkgXTtcblxuICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgIGVsZS5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICByZW1vdmVFZGdlUmVmKCB0Z3QsIGVsZSApO1xuICAgICAgcmVtb3ZlUGFyYWxsZWxSZWZzKCBlbGUgKTtcblxuICAgIH0gZWxzZSB7IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpO1xuXG4gICAgICBpZiggcGFyZW50Lmxlbmd0aCAhPT0gMCApe1xuICAgICAgICByZW1vdmVDaGlsZFJlZiggcGFyZW50LCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlWyBpIF07XG5cbiAgICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCB0aGlzLmN5KCksIHJlbW92ZWQgKTtcbiAgaWYoIHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwICl7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHRoaXMuY3koKS5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIGVsZXM6IHJlbW92ZWRFbGVtZW50c1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJlbW92ZWRFbGVtZW50cy50cmlnZ2VyKCAncmVtb3ZlJyApO1xuICB9XG5cbiAgLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgYWx0ZXJlZFBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gYWx0ZXJlZFBhcmVudHNbIGkgXTtcblxuICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgZWxlLnVwZGF0ZVN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgcmVtb3ZlZCApO1xufTtcblxuZWxlc2ZuLm1vdmUgPSBmdW5jdGlvbiggc3RydWN0ICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICB2YXIgc3JjSWQgPSBzdHJ1Y3Quc291cmNlO1xuICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgdmFyIHNyY0V4aXN0cyA9IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHNyY0lkICk7XG4gICAgdmFyIHRndEV4aXN0cyA9IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHRndElkICk7XG5cbiAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgICAgaWYoIHNyY0V4aXN0cyApeyBqc29uLmRhdGEuc291cmNlID0gc3JjSWQ7IH1cblxuICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG5cbiAgICAgICAgICBqc29uLnNjcmF0Y2ggPSBlbGUuX3ByaXZhdGUuc2NyYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApO1xuICAgIH1cblxuICB9IGVsc2UgaWYoIHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApeyAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgIHZhciBwYXJlbnRJZCA9IHN0cnVjdC5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHBhcmVudElkICk7XG5cbiAgICBpZiggcGFyZW50RXhpc3RzICl7XG4gICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG4gICAgICB2YXIgZGVzY3MgPSB0aGlzLmRlc2NlbmRhbnRzKCk7XG4gICAgICB2YXIgZGVzY3NFdGNKc29ucyA9IGRlc2NzLnVuaW9uKCBkZXNjcy51bmlvbiggdGhpcyApLmNvbm5lY3RlZEVkZ2VzKCkgKS5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpOyAvLyBOQjogYWxzbyByZW1vdmVzIGRlc2NlbmRhbnRzIGFuZCB0aGVpciBjb25uZWN0ZWQgZWRnZXNcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuXG4gICAgICAgICAganNvbi5zY3JhdGNoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMuY29uY2F0KCBkZXNjc0V0Y0pzb25zICkgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG59O1xuXG5bXG4gIHJlcXVpcmUoICcuL2FsZ29yaXRobXMnICksXG4gIHJlcXVpcmUoICcuL2FuaW1hdGlvbicgKSxcbiAgcmVxdWlyZSggJy4vY2xhc3MnICksXG4gIHJlcXVpcmUoICcuL2NvbXBhcmF0b3JzJyApLFxuICByZXF1aXJlKCAnLi9jb21wb3VuZHMnICksXG4gIHJlcXVpcmUoICcuL2RhdGEnICksXG4gIHJlcXVpcmUoICcuL2RlZ3JlZScgKSxcbiAgcmVxdWlyZSggJy4vZGltZW5zaW9ucycgKSxcbiAgcmVxdWlyZSggJy4vZXZlbnRzJyApLFxuICByZXF1aXJlKCAnLi9maWx0ZXInICksXG4gIHJlcXVpcmUoICcuL2dyb3VwJyApLFxuICByZXF1aXJlKCAnLi9pbmRleCcgKSxcbiAgcmVxdWlyZSggJy4vaXRlcmF0aW9uJyApLFxuICByZXF1aXJlKCAnLi9sYXlvdXQnICksXG4gIHJlcXVpcmUoICcuL3N0eWxlJyApLFxuICByZXF1aXJlKCAnLi9zd2l0Y2gtZnVuY3Rpb25zJyApLFxuICByZXF1aXJlKCAnLi90cmF2ZXJzaW5nJyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggZWxlc2ZuLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB6SW5kZXhTb3J0ID0gcmVxdWlyZSggJy4venNvcnQnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBmb3JFYWNoOiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICBpZiggaXMuZm4oIGZuICkgKXtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gZm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCB0aGlzIF0gKSA6IGZuKCBlbGUsIGksIHRoaXMgKTtcblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgYXJyYXkucHVzaCggdGhpc1sgaSBdICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIHNsaWNlOiBmdW5jdGlvbiggc3RhcnQsIGVuZCApe1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYoIGVuZCA9PSBudWxsICl7XG4gICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICB9XG5cbiAgICBpZiggc3RhcnQgPT0gbnVsbCApe1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmKCBzdGFydCA8IDAgKXtcbiAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICB9XG5cbiAgICBpZiggZW5kIDwgMCApe1xuICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKyApe1xuICAgICAgYXJyYXkucHVzaCggdGhpc1sgaSBdICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGFycmF5ICk7XG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH0sXG5cbiAgZXE6IGZ1bmN0aW9uKCBpICl7XG4gICAgcmV0dXJuIHRoaXNbIGkgXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGxhc3Q6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbIHRoaXMubGVuZ3RoIC0gMSBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH0sXG5cbiAgbm9uZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gIH0sXG5cbiAgc29ydDogZnVuY3Rpb24oIHNvcnRGbiApe1xuICAgIGlmKCAhaXMuZm4oIHNvcnRGbiApICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydCggc29ydEZuICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggc29ydGVkICk7XG4gIH0sXG5cbiAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnNvcnQoIHpJbmRleFNvcnQgKTtcbiAgfSxcblxuICB6RGVwdGg6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYoICFlbGUgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgLy8gdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuXG4gICAgaWYoIGdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcblxuICAgICAgaWYoICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuXG4gICAgICByZXR1cm4gTWF0aC5tYXgoIHNyY0RlcHRoLCB0Z3REZXB0aCwgMCApOyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudFxuICAgIH1cbiAgfVxufSk7XG5cbmVsZXNmbi5lYWNoID0gZWxlc2ZuLmZvckVhY2g7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9wcm9taXNlJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gdXNpbmcgc3RhbmRhcmQgbGF5b3V0IG9wdGlvbnMsIGFwcGx5IHBvc2l0aW9uIGZ1bmN0aW9uICh3LyBvciB3L28gYW5pbWF0aW9uKVxuICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBsYXlvdXQsIG9wdGlvbnMsIGZuICl7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbGF5b3V0RWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gbm9kZXMgJiBlZGdlc1xuXG4gICAgLy8gbWVtb2l6ZWQgdmVyc2lvbiBvZiBwb3NpdGlvbiBmdW5jdGlvblxuICAgIHZhciBmbk1lbSA9IHV0aWwubWVtb2l6ZSggZm4sIGZ1bmN0aW9uKCBub2RlLCBpICl7XG4gICAgICByZXR1cm4gbm9kZS5pZCgpICsgJyQnICsgaTtcbiAgICB9ICk7XG5cbiAgICBsYXlvdXQudHJpZ2dlciggeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9ICk7XG5cbiAgICBsYXlvdXQuYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgdmFyIGNhbGN1bGF0ZVNwYWNpbmcgPSBmdW5jdGlvbiggc3BhY2luZywgbm9kZXNCYiwgcG9zICl7XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiBub2Rlc0JiLngxICsgbm9kZXNCYi53IC8gMixcbiAgICAgICAgeTogbm9kZXNCYi55MSArIG5vZGVzQmIuaCAvIDJcbiAgICAgIH07XG5cbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0geyAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgc3BhY2luZ1ZlY3Rvci54LFxuICAgICAgICB5OiBjZW50ZXIueSArIHNwYWNpbmdWZWN0b3IueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHNwYWNpbmdCYiA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBmbk1lbSggbm9kZSwgaSApO1xuXG4gICAgICAgIG1hdGguZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KCBiYiwgcG9zLngsIHBvcy55ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuXG4gICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgdmFyIGJiID0gc3BhY2luZ0JiKCk7XG5cbiAgICAgIHZhciBmaW5hbFBvcyA9IHt9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBuZXdQb3MgPSBmbk1lbSggbm9kZSwgaSApO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIGlmKCAhaXMubnVtYmVyKCBwb3MueCApIHx8ICFpcy5udW1iZXIoIHBvcy55ICkgKXtcbiAgICAgICAgICBub2RlLnNpbGVudFBvc2l0aW9uKCB7IHg6IDAsIHk6IDAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDEgKXtcbiAgICAgICAgICB2YXIgc3BhY2luZyA9IE1hdGguYWJzKCBvcHRpb25zLnNwYWNpbmdGYWN0b3IgKTtcblxuICAgICAgICAgIG5ld1BvcyA9IGNhbGN1bGF0ZVNwYWNpbmcoIHNwYWNpbmcsIGJiLCBuZXdQb3MgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsUG9zWyBub2RlLmlkKCkgXSA9IG5ld1BvcztcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICAgIHZhciBuZXdQb3MgPSBmaW5hbFBvc1sgbm9kZS5pZCgpIF07XG5cbiAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKCB7XG4gICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0gKTtcblxuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKCBhbmkgKTtcblxuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgdmFyIGZpdEFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgZml0OiB7XG4gICAgICAgICAgICBib3VuZGluZ0JveDogbGF5b3V0RWxlcy5ib3VuZGluZ0JveEF0KGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5hbFBvc1sgbm9kZS5pZCgpIF07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcblxuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKCBmaXRBbmkgKTtcblxuICAgICAgICBmaXRBbmkucGxheSgpO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhbiAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciB6b29tUGFuQW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20sXG4gICAgICAgICAgcGFuOiBvcHRpb25zLnBhbixcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goIHpvb21QYW5BbmkgKTtcblxuICAgICAgICB6b29tUGFuQW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gICAgICBQcm9taXNlLmFsbCggbGF5b3V0LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCBhbmkgKXtcbiAgICAgICAgcmV0dXJuIGFuaS5wcm9taXNlKCk7XG4gICAgICB9KSApLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3AgKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9ICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDEgKXtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyggb3B0aW9ucy5zcGFjaW5nRmFjdG9yICk7XG4gICAgICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuXG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyggZnVuY3Rpb24oIG5vZGUsIGkgKXtcbiAgICAgICAgICB2YXIgcG9zID0gZm5NZW0oIG5vZGUsIGkgKTtcblxuICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVTcGFjaW5nKCBzcGFjaW5nLCBiYiwgcG9zICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucG9zaXRpb25zKCBmbiApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy56b29tICE9IG51bGwgKXtcbiAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLnBhbiApe1xuICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5vbmUoICdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkgKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0gKTtcblxuICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3AgKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGxheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICByZXR1cm4gY3kubWFrZUxheW91dCggdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSApICk7XG4gIH1cblxufSk7XG5cbi8vIGFsaWFzZXM6XG5lbGVzZm4uY3JlYXRlTGF5b3V0ID0gZWxlc2ZuLm1ha2VMYXlvdXQgPSBlbGVzZm4ubGF5b3V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuXG4gICAgICBiRWxlcy5tZXJnZSggdGhpcyApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgIH1cblxuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzO1xuXG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYoIGhhc0NvbXBvdW5kcyApeyAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSggdGhpcy5kZXNjZW5kYW50cygpICkubWVyZ2UoIHRoaXMucGFyZW50cygpICk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRFbGVzID0gc3R5bGUuYXBwbHkoIHVwZGF0ZWRFbGVzICk7XG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIGNoYW5nZWRFbGVzLnJ0cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMudHJpZ2dlciggJ3N0eWxlJyApOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8ganVzdCB1cGRhdGUgdGhlIG1hcHBlcnMgaW4gdGhlIGVsZW1lbnRzJyBzdHlsZXM7IGNoZWFwZXIgdGhhbiBlbGVzLnVwZGF0ZVN0eWxlKClcbiAgdXBkYXRlTWFwcGVyczogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciBjaGFuZ2VkRWxlcyA9IHN0eWxlLnVwZGF0ZU1hcHBlcnMoIHRoaXMgKTtcblxuICAgIHRoaXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCBub3RpZnlSZW5kZXJlciApO1xuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICBjaGFuZ2VkRWxlcy5ydHJpZ2dlciggJ3N0eWxlJyApOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZWRFbGVzLnRyaWdnZXIoICdzdHlsZScgKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQgdGhlIGludGVybmFsIHBhcnNlZCBzdHlsZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgcGFyc2VkU3R5bGU6IGZ1bmN0aW9uKCBwcm9wZXJ0eSApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH1cblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVbIHByb3BlcnR5IF0gfHwgY3kuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkoIHByb3BlcnR5ICk7XG4gICAgfVxuICB9LFxuXG4gIG51bWVyaWNTdHlsZTogZnVuY3Rpb24oIHByb3BlcnR5ICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfVxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUoIHByb3BlcnR5ICk7XG5cbiAgICAgIHJldHVybiBwc3R5bGUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkID8gcHN0eWxlLnBmVmFsdWUgOiBwc3R5bGUudmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCAhZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSggcHJvcGVydHkgKS51bml0cztcbiAgICB9XG4gIH0sXG5cbiAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgY3NzIHByb3BlcnR5IGFzIGEgcmVuZGVyZWQgdmFsdWUgKGkuZS4gb24tc2NyZWVuIHZhbHVlKVxuICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICByZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKCBlbGUsIHByb3BlcnR5ICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggbmFtZSApICl7IC8vIHRoZW4gZXh0ZW5kIHRoZSBieXBhc3NcbiAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICBzdHlsZS5hcHBseUJ5cGFzcyggdGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG5cbiAgICAgIHRoaXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICAgIHRoaXMucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBuYW1lICkgKXtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIG5hbWUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgIHRoaXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICAgICAgdGhpcy5ydHJpZ2dlciggJ3N0eWxlJyApOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCBuYW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZSggZWxlICk7XG4gICAgICB9IGVsc2UgeyAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHJlbW92ZVN0eWxlOiBmdW5jdGlvbiggbmFtZXMgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyggZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KCAvXFxzKy8gKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoIGVsZSwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICAgIHRoaXMucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jc3MoICdkaXNwbGF5JywgJ2VsZW1lbnQnICk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNzcyggJ2Rpc3BsYXknLCAnbm9uZScgKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWU7XG5cbiAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApeyByZXR1cm4gcGFyZW50T3BhY2l0eTsgfVxuXG4gICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuXG4gICAgICBpZiggcGFyZW50cyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1sgaSBdO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSggJ29wYWNpdHknICkudmFsdWU7XG5cbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oIHNwZWNzICl7XG4gIHZhciBvayA9IHNwZWNzLm9rO1xuICB2YXIgZWRnZU9rVmlhTm9kZSA9IHNwZWNzLmVkZ2VPa1ZpYU5vZGUgfHwgc3BlY3Mub2s7XG4gIHZhciBwYXJlbnRPayA9IHNwZWNzLnBhcmVudE9rIHx8IHNwZWNzLm9rO1xuXG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYoICFvayggZWxlICkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgaWYoIGhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgICAgICAgICBpZiggcGFyZW50cyApeyBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzWyBpIF07XG5cbiAgICAgICAgICAgIGlmKCAhcGFyZW50T2soIHBhcmVudCApICl7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgIH0gfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWRnZU9rVmlhTm9kZSggX3Auc291cmNlICkgJiYgZWRnZU9rVmlhTm9kZSggX3AudGFyZ2V0ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbGVUYWtlc1VwU3BhY2UgPSBmdW5jdGlvbiggZWxlICl7XG4gIHJldHVybiAoXG4gICAgZWxlLnBzdHlsZSggJ2Rpc3BsYXknICkudmFsdWUgPT09ICdlbGVtZW50J1xuICAgICYmIGVsZS53aWR0aCgpICE9PSAwXG4gICAgJiYgKCBlbGUuaXNOb2RlKCkgPyBlbGUuaGVpZ2h0KCkgIT09IDAgOiB0cnVlIClcbiAgKTtcbn07XG5cbmVsZXNmbi50YWtlc1VwU3BhY2UgPSBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVUYWtlc1VwU3BhY2Vcbn0pO1xuXG52YXIgZWxlSW50ZXJhY3RpdmUgPSBmdW5jdGlvbiggZWxlICl7XG4gIHJldHVybiAoXG4gICAgZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnXG4gICAgJiYgZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZSdcbiAgICAmJiBlbGVUYWtlc1VwU3BhY2UoIGVsZSApXG4gICk7XG59O1xuXG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBmdW5jdGlvbiggcGFyZW50ICl7XG4gIHJldHVybiAoXG4gICAgcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZSdcbiAgICAmJiBlbGVUYWtlc1VwU3BhY2UoIHBhcmVudCApXG4gICk7XG59O1xuXG5lbGVzZm4uaW50ZXJhY3RpdmUgPSBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVJbnRlcmFjdGl2ZSxcbiAgcGFyZW50T2s6IHBhcmVudEludGVyYWN0aXZlLFxuICBlZGdlT2tWaWFOb2RlOiBlbGVUYWtlc1VwU3BhY2Vcbn0pO1xuXG5lbGVzZm4ubm9uaW50ZXJhY3RpdmUgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiggZWxlICl7XG4gICAgcmV0dXJuICFlbGUuaW50ZXJhY3RpdmUoKTtcbiAgfVxufTtcblxudmFyIGVsZVZpc2libGUgPSBmdW5jdGlvbiggZWxlICl7XG4gIHJldHVybiAoXG4gICAgZWxlLnBzdHlsZSggJ3Zpc2liaWxpdHknICkudmFsdWUgPT09ICd2aXNpYmxlJ1xuICAgICYmIGVsZS5wc3R5bGUoICdvcGFjaXR5JyApLnBmVmFsdWUgIT09IDBcbiAgICAmJiBlbGVUYWtlc1VwU3BhY2UoIGVsZSApXG4gICk7XG59O1xuXG52YXIgZWRnZVZpc2libGVWaWFOb2RlID0gZWxlVGFrZXNVcFNwYWNlO1xuXG5lbGVzZm4udmlzaWJsZSA9IGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZVZpc2libGUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVkZ2VWaXNpYmxlVmlhTm9kZVxufSk7XG5cbmVsZXNmbi5oaWRkZW4gPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiggZWxlICl7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59O1xuXG5cbmVsZXNmbi5ieXBhc3MgPSBlbGVzZm4uY3NzID0gZWxlc2ZuLnN0eWxlO1xuZWxlc2ZuLnJlbmRlcmVkQ3NzID0gZWxlc2ZuLnJlbmRlcmVkU3R5bGU7XG5lbGVzZm4ucmVtb3ZlQnlwYXNzID0gZWxlc2ZuLnJlbW92ZUNzcyA9IGVsZXNmbi5yZW1vdmVTdHlsZTtcbmVsZXNmbi5wc3R5bGUgPSBlbGVzZm4ucGFyc2VkU3R5bGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaEZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBkYXRhLCBoYW5kbGVyIClcbiAgICBpZiggYXJncy5sZW5ndGggPT09IDIgKXtcbiAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICAgIHRoaXMub24oIHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlciApO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICl7XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICB0aGlzLm9uKCBwYXJhbXMuZXZlbnQsIGhhbmRsZXIgKTtcbiAgICB9XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KClcbiAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICAgIHZhciBhYmxlID0gIXBhcmFtcy5hYmxlRmllbGQgfHwgZWxlLl9wcml2YXRlWyBwYXJhbXMuYWJsZUZpZWxkIF07XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlWyBwYXJhbXMuZmllbGQgXSAhPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUFibGUgKXtcbiAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZSggZWxlICk7XG5cbiAgICAgICAgICBpZiggb3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgIGlmKCAhb3ZlcnJpZGVBYmxlICl7IHJldHVybiB0aGlzOyB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFibGUgKXtcbiAgICAgICAgICBlbGUuX3ByaXZhdGVbIHBhcmFtcy5maWVsZCBdID0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgaWYoIGNoYW5nZWQgKXtcbiAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKCBjaGFuZ2VkRWxlcyApO1xuICAgICAgY2hhbmdlZENvbGwudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuICAgICAgY2hhbmdlZENvbGwudHJpZ2dlciggcGFyYW1zLmV2ZW50ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldCggcGFyYW1zICl7XG4gIGVsZXNmblsgcGFyYW1zLmZpZWxkIF0gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUZpZWxkICl7XG4gICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZCggZWxlICk7XG5cbiAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlWyBwYXJhbXMuZmllbGQgXTtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuWyBwYXJhbXMub24gXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKCB7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSApO1xuXG4gIGVsZXNmblsgcGFyYW1zLm9mZiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oIHtcbiAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IGZhbHNlXG4gIH0gKTtcbn1cblxuZGVmaW5lU3dpdGNoU2V0KCB7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oIGVsZSApe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdsb2NrJyxcbiAgb2ZmOiAndW5sb2NrJ1xufSApO1xuXG5kZWZpbmVTd2l0Y2hTZXQoIHtcbiAgZmllbGQ6ICdncmFiYmFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiggZWxlICl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2dyYWJpZnknLFxuICBvZmY6ICd1bmdyYWJpZnknXG59ICk7XG5cbmRlZmluZVN3aXRjaFNldCgge1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24oIGVsZSApe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSApO1xuXG5kZWZpbmVTd2l0Y2hTZXQoIHtcbiAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oIGVsZSApe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSApO1xuXG5lbGVzZm4uZGVzZWxlY3QgPSBlbGVzZm4udW5zZWxlY3Q7XG5cbmVsZXNmbi5ncmFiYmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gIH1cbn07XG5cbmRlZmluZVN3aXRjaFNldCgge1xuICBmaWVsZDogJ2FjdGl2ZScsXG4gIG9uOiAnYWN0aXZhdGUnLFxuICBvZmY6ICd1bmFjdGl2YXRlJ1xufSApO1xuXG5lbGVzZm4uaW5hY3RpdmUgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYoIGVsZSApe1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxudmFyIGNhY2hlID0gZnVuY3Rpb24oIGZuLCBuYW1lICl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZSggYXJnMSwgYXJnMiwgYXJnMywgYXJnNCApe1xuICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiggc2VsZWN0b3JPckVsZXMgPT0gbnVsbCApe1xuICAgICAga2V5ID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggc2VsZWN0b3JPckVsZXMgKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEgKXtcbiAgICAgIGtleSA9ICcjJyArIHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgfVxuXG4gICAgaWYoIGVsZXMubGVuZ3RoID09PSAxICYmIGtleSApe1xuICAgICAgdmFyIF9wID0gZWxlc1swXS5fcHJpdmF0ZTtcbiAgICAgIHZhciB0Y2ggPSBfcC50cmF2ZXJzYWxDYWNoZSA9IF9wLnRyYXZlcnNhbENhY2hlIHx8IHt9O1xuICAgICAgdmFyIGNoID0gdGNoWyBuYW1lIF0gPSB0Y2hbIG5hbWUgXSB8fCB7fTtcbiAgICAgIHZhciBjYWNoZUhpdCA9IGNoWyBrZXkgXTtcblxuICAgICAgaWYoIGNhY2hlSGl0ICl7XG4gICAgICAgIHJldHVybiBjYWNoZUhpdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoIGNoWyBrZXkgXSA9IGZuLmNhbGwoIGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKSApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCggZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzcXVhbGlmaWVkID0gZmFsc2U7XG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgICAgKCBwYXJhbXMubm9JbmNvbWluZ0VkZ2VzICYmIHRndCA9PT0gZWxlICYmIHNyYyAhPT0gZWxlIClcbiAgICAgICAgICB8fCAoIHBhcmFtcy5ub091dGdvaW5nRWRnZXMgJiYgc3JjID09PSBlbGUgJiYgdGd0ICE9PSBlbGUgKVxuICAgICAgICApe1xuICAgICAgICAgIGRpc3F1YWxpZmllZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFkaXNxdWFsaWZpZWQgKXtcbiAgICAgICAgcmV0LnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByZXQsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59O1xuXG52YXIgZGVmaW5lRGFnT25lSG9wID0gZnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgICBpZiggIWVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1sgaiBdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5vdXRnb2luZyAmJiBzcmMgPT09IGVsZSApe1xuICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKCB0Z3QgKTtcbiAgICAgICAgfSBlbHNlIGlmKCBwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUgKXtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgb0VsZXMucHVzaCggc3JjICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59O1xuXG52YXIgZGVmaW5lRGFnQWxsSG9wcyA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICB2YXIgc0VsZXNJZHMgPSB7fTtcblxuICAgIGZvciggOzsgKXtcbiAgICAgIHZhciBuZXh0ID0gcGFyYW1zLm91dGdvaW5nID8gZWxlcy5vdXRnb2VycygpIDogZWxlcy5pbmNvbWVycygpO1xuXG4gICAgICBpZiggbmV4dC5sZW5ndGggPT09IDAgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuICAgICAgdmFyIG5ld05leHQgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmV4dC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbiA9IG5leHRbIGkgXTtcbiAgICAgICAgdmFyIG5pZCA9IG4uaWQoKTtcblxuICAgICAgICBpZiggIXNFbGVzSWRzWyBuaWQgXSApe1xuICAgICAgICAgIHNFbGVzSWRzWyBuaWQgXSA9IHRydWU7XG4gICAgICAgICAgc0VsZXMucHVzaCggbiApO1xuICAgICAgICAgIG5ld05leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbmV3TmV4dCApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuICAgICAgZWxlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9O1xufTtcblxuZWxlc2ZuLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiggKXtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdGhpc1tpXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gIH1cbn07XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vSW5jb21pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vT3V0Z29pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZSggZGVmaW5lRGFnT25lSG9wKHsgb3V0Z29pbmc6IHRydWUgfSkgLCAnb3V0Z29lcnMnICksXG5cbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHsgb3V0Z29pbmc6IHRydWUgfSksXG5cbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZSggZGVmaW5lRGFnT25lSG9wKHsgaW5jb21pbmc6IHRydWUgfSksICdpbmNvbWVycycgKSxcblxuICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICBwcmVkZWNlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoeyBpbmNvbWluZzogdHJ1ZSB9KVxufSApO1xuXG5cbi8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbIGogXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjO1xuXG4gICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgIGlmKCBvdGhlck5vZGUubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIG90aGVyTm9kZVswXSApOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcbiAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZVswXSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICggdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSwgJ25laWdoYm9yaG9vZCcpLFxuXG4gIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuYWRkKCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCggc2VsZWN0b3IgKTtcbiAgfVxufSApO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4ubmVpZ2hib3VyaG9vZCA9IGVsZXNmbi5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4uY2xvc2VkTmVpZ2hib3VyaG9vZCA9IGVsZXNmbi5jbG9zZWROZWlnaGJvcmhvb2Q7XG5lbGVzZm4ub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4ub3Blbk5laWdoYm9yaG9vZDtcblxuLy8gRWRnZSBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlciggc2VsZWN0b3IgKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuXG4gIHRhcmdldDogY2FjaGUoZnVuY3Rpb24gdGFyZ2V0SW1wbCggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldCB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoIHNlbGVjdG9yICkgOiB0Z3Q7XG4gIH0sICd0YXJnZXQnKSxcblxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbigge1xuICAgIGF0dHI6ICdzb3VyY2UnXG4gIH0gKSxcblxuICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbigge1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0gKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKCBzZWxlY3RvciApe1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlWyBwYXJhbXMuYXR0ciBdO1xuXG4gICAgICBpZiggc3JjICl7XG4gICAgICAgIHNvdXJjZXMucHVzaCggc3JjICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNvdXJjZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgZWRnZXNXaXRoOiBjYWNoZSggZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcsIHRydWUgKSxcblxuICBlZGdlc1RvOiBjYWNoZSggZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oIHtcbiAgICB0aGlzSXNTcmM6IHRydWVcbiAgfSApLCAnZWRnZXNUbycsIHRydWUgKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiggcGFyYW1zICl7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwoIG90aGVyTm9kZXMgKXtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgaWYoIGlzLnN0cmluZyggb3RoZXJOb2RlcyApICl7XG4gICAgICBvdGhlck5vZGVzID0gY3kuJCggb3RoZXJOb2RlcyApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKyApe1xuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1sgaCBdLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbIGkgXTtcbiAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGhpc1RvT3RoZXIgPSB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoIGVkZ2VEYXRhLnNvdXJjZSApICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZCggZWRnZURhdGEudGFyZ2V0ICk7XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZCggZWRnZURhdGEuc291cmNlICkgJiYgdGhpcy5oYXNFbGVtZW50V2l0aElkKCBlZGdlRGF0YS50YXJnZXQgKTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgIGlmKCAhZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYoIHAudGhpc0lzU3JjIHx8IHAudGhpc0lzVGd0ICl7XG4gICAgICAgICAgaWYoIHAudGhpc0lzU3JjICYmICF0aGlzVG9PdGhlciApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgaWYoIHAudGhpc0lzVGd0ICYmICFvdGhlclRvVGhpcyApeyBjb250aW51ZTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApO1xuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBlbGVzWyBpIF07XG4gICAgICBpZiggIW5vZGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzWyBqIF07XG4gICAgICAgIHJldEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LCAnY29ubmVjdGVkRWRnZXMnKSxcblxuICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWxlc1sgaSBdO1xuICAgICAgaWYoICFlZGdlLmlzRWRnZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHJldEVsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sICdjb25uZWN0ZWROb2RlcycpLFxuXG4gIHBhcmFsbGVsRWRnZXM6IGNhY2hlKCBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oKSwgJ3BhcmFsbGVsRWRnZXMnICksXG5cbiAgY29kaXJlY3RlZEVkZ2VzOiBjYWNoZSggZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCB7XG4gICAgY29kaXJlY3RlZDogdHJ1ZVxuICB9ICksICdjb2RpcmVjdGVkRWRnZXMnIClcbn0gKTtcblxuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCBwYXJhbXMgKXtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gIH07XG4gIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwYXJhbGxlbEVkZ2VzSW1wbCggc2VsZWN0b3IgKXsgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgIC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlMSA9IGVkZ2VzWyBpIF07XG4gICAgICB2YXIgZWRnZTFfcCA9IGVkZ2UxLl9wcml2YXRlO1xuICAgICAgdmFyIHNyYzEgPSBlZGdlMV9wLnNvdXJjZTtcbiAgICAgIHZhciBzcmNpZDEgPSBzcmMxLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgdGd0aWQxID0gZWRnZTFfcC5kYXRhLnRhcmdldDtcbiAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbIGogXTtcbiAgICAgICAgdmFyIGVkZ2UyZGF0YSA9IGVkZ2UyLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICB2YXIgc3JjaWQyID0gZWRnZTJkYXRhLnNvdXJjZTtcblxuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICBpZiggKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkKSB8fCAoIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZTIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcblxufVxuXG4vLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoIGVsZXNmbiwge1xuICBjb21wb25lbnRzOiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBzZWxmLnNwYXduKCk7XG4gICAgdmFyIHVudmlzaXRlZCA9IHNlbGYubm9kZXMoKS5zcGF3blNlbGYoKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdmFyIHZpc2l0SW5Db21wb25lbnQgPSBmdW5jdGlvbiggbm9kZSwgY29tcG9uZW50ICl7XG4gICAgICB2aXNpdGVkLm1lcmdlKCBub2RlICk7XG4gICAgICB1bnZpc2l0ZWQudW5tZXJnZSggbm9kZSApO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKCBub2RlICk7XG4gICAgfTtcblxuICAgIGlmKCB1bnZpc2l0ZWQuZW1wdHkoKSApeyByZXR1cm4gc2VsZi5zcGF3bigpOyB9XG5cbiAgICBkbyB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKCBjb21wb25lbnQgKTtcblxuICAgICAgdmFyIHJvb3QgPSB1bnZpc2l0ZWRbMF07XG4gICAgICB2aXNpdEluQ29tcG9uZW50KCByb290LCBjb21wb25lbnQgKTtcblxuICAgICAgc2VsZi5iZnMoe1xuICAgICAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgICAgIHJvb3RzOiByb290LFxuICAgICAgICB2aXNpdDogZnVuY3Rpb24oIHYsIGUsIHUsIGksIGRlcHRoICl7XG4gICAgICAgICAgdmlzaXRJbkNvbXBvbmVudCggdiwgY29tcG9uZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcblxuICAgIH0gd2hpbGUoIHVudmlzaXRlZC5sZW5ndGggPiAwICk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50cy5tYXAoZnVuY3Rpb24oIGNvbXBvbmVudCApe1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gY29tcG9uZW50LmNvbm5lY3RlZEVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuYW55U2FtZSggZWRnZS5zb3VyY2UoKSApICYmIGNvbXBvbmVudC5hbnlTYW1lKCBlZGdlLnRhcmdldCgpICk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNvbXBvbmVudC51bmlvbiggY29ubmVjdGVkRWRnZXMgKTtcbiAgICB9KTtcbiAgfVxufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiAgRWxlbWVudHMgYXJlIGRyYXduIGluIGEgc3BlY2lmaWMgb3JkZXIgYmFzZWQgb24gY29tcG91bmQgZGVwdGggKGxvdyB0byBoaWdoKSwgdGhlIGVsZW1lbnQgdHlwZSAobm9kZXMgYWJvdmUgZWRnZXMpLFxuICogIGFuZCB6LWluZGV4IChsb3cgdG8gaGlnaCkuICBUaGVzZSBzdHlsZXMgYWZmZWN0IGhvdyB0aGlzIGFwcGxpZXM6XG4gKlxuICogIHotY29tcG91bmQtZGVwdGg6IE1heSBiZSBgYm90dG9tIHwgb3JwaGFuIHwgYXV0byB8IHRvcGAuICBUaGUgZmlyc3QgZHJhd24gaXMgYGJvdHRvbWAsIHRoZW4gYG9ycGhhbmAgd2hpY2ggaXMgdGhlXG4gKiAgICAgIHNhbWUgZGVwdGggYXMgdGhlIHJvb3Qgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLCBmb2xsb3dlZCBieSB0aGUgZGVmYXVsdCB2YWx1ZSBgYXV0b2Agd2hpY2ggZHJhd3MgaW4gb3JkZXIgZnJvbVxuICogICAgICByb290IHRvIGxlYXZlcyBvZiB0aGUgY29tcG91bmQgZ3JhcGguICBUaGUgbGFzdCBkcmF3biBpcyBgdG9wYC5cbiAqICB6LWluZGV4LWNvbXBhcmU6IE1heSBiZSBgYXV0byB8IG1hbnVhbGAuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgYXV0b2Agd2hpY2ggYWx3YXlzIGRyYXdzIGVkZ2VzIHVuZGVyIG5vZGVzLlxuICogICAgICBgbWFudWFsYCBpZ25vcmVzIHRoaXMgY29udmVudGlvbiBhbmQgZHJhd3MgYmFzZWQgb24gdGhlIGB6LWluZGV4YCB2YWx1ZSBzZXR0aW5nLlxuICogIHotaW5kZXg6IEFuIGludGVnZXIgdmFsdWUgdGhhdCBhZmZlY3RzIHRoZSByZWxhdGl2ZSBkcmF3IG9yZGVyIG9mIGVsZW1lbnRzLiAgSW4gZ2VuZXJhbCwgYW4gZWxlbWVudCB3aXRoIGEgaGlnaGVyXG4gKiAgICAgIGB6LWluZGV4YCB3aWxsIGJlIGRyYXduIG9uIHRvcCBvZiBhbiBlbGVtZW50IHdpdGggYSBsb3dlciBgei1pbmRleGAuXG4gKi9cbnZhciB6SW5kZXhTb3J0ID0gZnVuY3Rpb24oIGEsIGIgKXtcbiAgdmFyIGN5ID0gYS5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICBmdW5jdGlvbiBnZXREZXB0aChlbGUpe1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoICd6LWNvbXBvdW5kLWRlcHRoJyApO1xuICAgIGlmICggc3R5bGUudmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgcmV0dXJuIGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUuekRlcHRoKCkgOiAwXG4gICAgfSBlbHNlIGlmICggc3R5bGUudmFsdWUgPT09ICdib3R0b20nICl7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCBzdHlsZS52YWx1ZSA9PT0gJ3RvcCcgKXtcbiAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgIH1cbiAgICAvLyAnb3JwaGFuJ1xuICAgIHJldHVybiAwXG4gIH1cbiAgdmFyIGRlcHRoRGlmZiA9IGdldERlcHRoKGEpIC0gZ2V0RGVwdGgoYik7XG4gIGlmICggZGVwdGhEaWZmICE9PSAwICl7XG4gICAgcmV0dXJuIGRlcHRoRGlmZlxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKXtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCAnei1pbmRleC1jb21wYXJlJyApO1xuICAgIGlmICggc3R5bGUudmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwXG4gICAgfVxuICAgIC8vICdtYW51YWwnXG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG4gIGlmICggZWxlRGlmZiAhPT0gMCApe1xuICAgIHJldHVybiBlbGVEaWZmXG4gIH1cblxuICB2YXIgekRpZmYgPSBhLnBzdHlsZSggJ3otaW5kZXgnICkudmFsdWUgLSBiLnBzdHlsZSggJ3otaW5kZXgnICkudmFsdWU7XG4gIGlmICggekRpZmYgIT09IDAgKXtcbiAgICByZXR1cm4gekRpZmZcbiAgfVxuICAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHpJbmRleFNvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoICcuLi9jb2xsZWN0aW9uJyApO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAnLi4vY29sbGVjdGlvbi9lbGVtZW50JyApO1xuXG52YXIgY29yZWZuID0ge1xuICBhZGQ6IGZ1bmN0aW9uKCBvcHRzICl7XG5cbiAgICB2YXIgZWxlbWVudHM7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIC8vIGFkZCB0aGUgZWxlbWVudHNcbiAgICBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggb3B0cyApICl7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgIGlmKCBlbGVzLl9wcml2YXRlLmN5ID09PSBjeSApeyAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuXG4gICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICAgICAganNvbnMucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggY3ksIGpzb25zICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiggaXMuYXJyYXkoIG9wdHMgKSApe1xuICAgICAgdmFyIGpzb25zID0gb3B0cztcblxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggY3ksIGpzb25zICk7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgIGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBvcHRzICkgJiYgKGlzLmFycmF5KCBvcHRzLm5vZGVzICkgfHwgaXMuYXJyYXkoIG9wdHMuZWRnZXMgKSkgKXtcbiAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgdmFyIGdycyA9IFsgJ25vZGVzJywgJ2VkZ2VzJyBdO1xuICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JzWyBpIF07XG4gICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFsgZ3JvdXAgXTtcblxuICAgICAgICBpZiggaXMuYXJyYXkoIGVsZXNBcnJheSApICl7XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKyApe1xuICAgICAgICAgICAgdmFyIGpzb24gPSB1dGlsLmV4dGVuZCggeyBncm91cDogZ3JvdXAgfSwgZWxlc0FycmF5WyBqIF0gKTtcblxuICAgICAgICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgZWxzZSB7XG4gICAgICB2YXIganNvbiA9IG9wdHM7XG4gICAgICBlbGVtZW50cyA9IChuZXcgRWxlbWVudCggY3ksIGpzb24gKSkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKSApe1xuICAgICAgLy8gYWxyZWFkeSBoYXZlIHJpZ2h0IHJlZlxuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBjb2xsZWN0aW9uICkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKCksXG5cbiAgYWRkVG9BbmltYXRpb25Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoIGVsZXMgKTtcbiAgfSxcblxuICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgc3RhcnRBbmltYXRpb25Mb29wOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IHRydWU7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cbiAgICBmdW5jdGlvbiBnbG9iYWxBbmltYXRpb25TdGVwKCl7XG4gICAgICBpZiggIWN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nICl7IHJldHVybjsgfVxuXG4gICAgICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24gYW5pbWF0aW9uU3RlcCggbm93ICl7XG4gICAgICAgIGhhbmRsZUVsZW1lbnRzKCBub3cgKTtcbiAgICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpO1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG5cbiAgICBpZiggcmVuZGVyZXIgJiYgcmVuZGVyZXIuYmVmb3JlUmVuZGVyICl7IC8vIGxldCB0aGUgcmVuZGVyZXIgc2NoZWR1bGUgYW5pbWF0aW9uc1xuICAgICAgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKCBmdW5jdGlvbiByZW5kZXJlckFuaW1hdGlvblN0ZXAoIHdpbGxEcmF3LCBub3cgKXtcbiAgICAgICAgaGFuZGxlRWxlbWVudHMoIG5vdyApO1xuICAgICAgfSwgcmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5hbmltYXRpb25zICk7XG4gICAgfSBlbHNlIHsgLy8gbWFuYWdlIHRoZSBhbmltYXRpb24gbG9vcCBvdXJzZWx2ZXNcbiAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnRzKCBub3cgKXtcbiAgICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50KCBlbGUsIGlzQ29yZSApe1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIHZhciBxdWV1ZSA9IF9wLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgdmFyIHJhbkFuaXMgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYW5jZWwgYWxsIGFuaW1hdGlvbnMgb24gZGlzcGxheTpub25lIGVsZVxuICAgICAgICBpZiggIWlzQ29yZSAmJiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJyApe1xuICAgICAgICAgIC8vIHB1dCBhbGwgY3VycmVudCBhbmQgcXVldWUgYW5pbWF0aW9ucyBpbiB0aGlzIHRpY2sncyBjdXJyZW50IGxpc3RcbiAgICAgICAgICAvLyBhbmQgZW1wdHkgdGhlIGxpc3RzIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNwbGljZSggMCwgY3VycmVudC5sZW5ndGggKS5jb25jYXQoIHF1ZXVlLnNwbGljZSggMCwgcXVldWUubGVuZ3RoICkgKTtcblxuICAgICAgICAgIC8vIHN0b3AgYWxsIGFuaW1hdGlvbnNcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKysgKXsgY3VycmVudFtpXS5zdG9wKCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICBpZiggY3VycmVudC5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiggbmV4dCApe1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKCBuZXh0ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBjYWxsYmFja3MgKXtcbiAgICAgICAgICBmb3IoIHZhciBqID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tICl7XG4gICAgICAgICAgICB2YXIgY2IgPSBjYWxsYmFja3NbIGogXTtcblxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKCAwLCBjYWxsYmFja3MubGVuZ3RoICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcbiAgICAgICAgZm9yKCB2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICAgICAgICB2YXIgYW5pID0gY3VycmVudFsgaSBdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBhbmlfcC5zdG9wcGVkICl7XG4gICAgICAgICAgICBjdXJyZW50LnNwbGljZSggaSwgMSApO1xuXG4gICAgICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzKCBhbmlfcC5mcmFtZXMgKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhbmlfcC5wbGF5aW5nICYmICFhbmlfcC5hcHBseWluZyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgLy8gYW4gYXBwbHkoKSB3aGlsZSBwbGF5aW5nIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgIGlmKCBhbmlfcC5wbGF5aW5nICYmIGFuaV9wLmFwcGx5aW5nICl7XG4gICAgICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhYW5pX3Auc3RhcnRlZCApe1xuICAgICAgICAgICAgc3RhcnRBbmltYXRpb24oIGVsZSwgYW5pLCBub3cgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGVwKCBlbGUsIGFuaSwgbm93LCBpc0NvcmUgKTtcblxuICAgICAgICAgIGlmKCBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmZyYW1lcyApO1xuXG4gICAgICAgICAgaWYoIGFuaS5jb21wbGV0ZWQoKSApe1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcyggYW5pX3AuY29tcGxldGVzICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBkb25lRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5BbmlzO1xuICAgICAgfSAvLyBoYW5kbGVFbGVtZW50XG5cbiAgICAgIC8vIGhhbmRsZSBhbGwgZWxlc1xuICAgICAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBlIF07XG4gICAgICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuXG4gICAgICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcblxuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICBpZiggcmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgaWYoIGVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2RyYXcnLFxuICAgICAgICAgICAgZWxlczogZWxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgICAgIGVsZXMudW5tZXJnZSggZG9uZUVsZXMgKTtcblxuICAgICAgY3kudHJpZ2dlcignc3RlcCcpO1xuXG4gICAgfSAvLyBoYW5kbGVFbGVtZW50c1xuXG4gICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oIHNlbGYsIGFuaSwgbm93ICl7XG4gICAgICB2YXIgaXNDb3JlID0gaXMuY29yZSggc2VsZiApO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICB2YXIgZWxlID0gc2VsZjtcbiAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgYW5pX3Auc3RhcnRQb3NpdGlvbiA9IGFuaV9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgIHk6IHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pX3Auc3RhcnRTdHlsZSA9IGFuaV9wLnN0YXJ0U3R5bGUgfHwgc3R5bGUuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSggZWxlLCBhbmlfcC5zdHlsZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggaXNDb3JlICl7XG4gICAgICAgIHZhciBwYW4gPSBjeS5fcHJpdmF0ZS5wYW47XG5cbiAgICAgICAgYW5pX3Auc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbiB8fCB7XG4gICAgICAgICAgeDogcGFuLngsXG4gICAgICAgICAgeTogcGFuLnlcbiAgICAgICAgfTtcblxuICAgICAgICBhbmlfcC5zdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb20gIT0gbnVsbCA/IGFuaV9wLnN0YXJ0Wm9vbSA6IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICB9XG5cbiAgICAgIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCBzZWxmLCBhbmksIG5vdywgaXNDb3JlICl7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcblxuICAgICAgaWYoICFhbmlfcC5lYXNpbmdJbXBsICl7XG5cbiAgICAgICAgaWYoIHBFYXNpbmcgPT0gbnVsbCApeyAvLyB1c2UgZGVmYXVsdFxuICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyAnbGluZWFyJyBdO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIHBFYXNpbmcgKSApe1xuICAgICAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSggJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgcEVhc2luZyApO1xuXG4gICAgICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgICBpZiggaXMuc3RyaW5nKCBlYXNpbmdWYWxzICkgKXtcbiAgICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKCAyICkubWFwKCBmdW5jdGlvbiggbiApeyByZXR1cm4gK247IH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYXJncy5sZW5ndGggPiAwICl7IC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgICAgIGlmKCBuYW1lID09PSAnc3ByaW5nJyApe1xuICAgICAgICAgICAgICBhcmdzLnB1c2goIGFuaV9wLmR1cmF0aW9uICk7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyBuYW1lIF0uYXBwbHkoIG51bGwsIGFyZ3MgKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1sgbmFtZSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICAgICAgdmFyIHBlcmNlbnQ7XG5cbiAgICAgIGlmKCBhbmlfcC5kdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuZGVsYXkgPT0gbnVsbCApeyAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICBpZiggZW5kUG9zICYmIGlzRWxlcyApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueCwgZW5kUG9zLnggKSApe1xuICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBvcy55LCBlbmRQb3MueSApICl7XG4gICAgICAgICAgICBwb3MueSA9IGVhc2UoIHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICAgICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICAgICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQYW4ueCwgZW5kUGFuLnggKSApe1xuICAgICAgICAgICAgcGFuLnggPSBlYXNlKCBzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICBwYW4ueSA9IGVhc2UoIHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoICdwYW4nICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgICAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgaWYoIGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0Wm9vbSwgZW5kWm9vbSApICl7XG4gICAgICAgICAgICBfcC56b29tID0gZWFzZSggc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoICd6b29tJyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCAndmlld3BvcnQnICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcbiAgICAgICAgaWYoIHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgICB2YXIgZW5kID0gcHJvcDtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pX3Auc3RhcnRTdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZSggc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nICk7XG5cbiAgICAgICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKCBzZWxmLCBuYW1lLCBlYXNlZFZhbCApO1xuICAgICAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3N0eWxlJyk7XG5cbiAgICAgICAgfSAvLyBpZlxuXG4gICAgICB9XG5cbiAgICAgIGFuaV9wLnByb2dyZXNzID0gcGVyY2VudDtcblxuICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWQoIHN0YXJ0LCBlbmQgKXtcbiAgICAgIGlmKCBzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlciggc3RhcnQgKSAmJiBpcy5udW1iZXIoIGVuZCApICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmKCAoc3RhcnQpICYmIChlbmQpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lcyBwMCA9IDAsIHAzID0gMVxuICAgIGZ1bmN0aW9uIGV2YWxDdWJpY0JlemllciggcDEsIHAyLCB0ICl7XG4gICAgICB2YXIgb25lX3QgPSAxIC0gdDtcbiAgICAgIHZhciB0c3EgPSB0ICogdDtcblxuICAgICAgcmV0dXJuICggMyAqIG9uZV90ICogb25lX3QgKiB0ICogcDEgKSArICggMyAqIG9uZV90ICogdHNxICogcDIgKSArIHRzcSAqIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3ViaWNCZXppZXIoIHAxLCBwMiApe1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwZXJjZW50ICl7XG4gICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBldmFsQ3ViaWNCZXppZXIoIHAxLCBwMiwgcGVyY2VudCApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4gICAgLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgICAgICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbiAgICB2YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSAoZnVuY3Rpb24oKXtcbiAgICAgIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKCBzdGF0ZSApe1xuICAgICAgICByZXR1cm4gKC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCkgLSAoc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKCBpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlICl7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHsgZHg6IHN0YXRlLnYsIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZSggc3RhdGUgKSB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcHJpbmdJbnRlZ3JhdGVTdGF0ZSggc3RhdGUsIGR0ICl7XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZSggc3RhdGUgKVxuICAgICAgICB9LFxuICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKCBzdGF0ZSwgZHQgKiAwLjUsIGEgKSxcbiAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZSggc3RhdGUsIGR0ICogMC41LCBiICksXG4gICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoIHN0YXRlLCBkdCwgYyApLFxuICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcblxuICAgICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgICAgc3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSggdGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uICl7XG5cbiAgICAgICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICB2OiAwLFxuICAgICAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICAgICAgZnJpY3Rpb246IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICBoYXZlX2R1cmF0aW9uLCBkdCwgbGFzdF9zdGF0ZTtcblxuICAgICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCggdGVuc2lvbiApIHx8IDUwMDtcbiAgICAgICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KCBmcmljdGlvbiApIHx8IDIwO1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG5cbiAgICAgICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgICAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgICAgICBoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG5cbiAgICAgICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cbiAgICAgICAgaWYoIGhhdmVfZHVyYXRpb24gKXtcbiAgICAgICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSggdGVuc2lvbiwgZnJpY3Rpb24gKTtcbiAgICAgICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuICAgICAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR0ID0gRFQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSggdHJ1ZSApe1xuICAgICAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgICAgICBsYXN0X3N0YXRlID0gc3ByaW5nSW50ZWdyYXRlU3RhdGUoIGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCApO1xuICAgICAgICAgIC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cbiAgICAgICAgICBwYXRoLnB1c2goIDEgKyBsYXN0X3N0YXRlLnggKTtcbiAgICAgICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgICAgICBpZiggIShNYXRoLmFicyggbGFzdF9zdGF0ZS54ICkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMoIGxhc3Rfc3RhdGUudiApID4gdG9sZXJhbmNlKSApe1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cbiAgICAgICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiggcGVyY2VudENvbXBsZXRlICl7IHJldHVybiBwYXRoWyAocGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkpIHwgMCBdOyB9O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGVhc2luZ3MgPSB7XG4gICAgICAnbGluZWFyJzogZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgICAgICdlYXNlJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuMSwgMC4yNSwgMSApLFxuICAgICAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllciggMC40MiwgMCwgMSwgMSApLFxuICAgICAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoIDAsIDAsIDAuNTgsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKCAwLjQyLCAwLCAwLjU4LCAxICksXG5cbiAgICAgIC8vIHNpbmVcbiAgICAgICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllciggMC40NywgMCwgMC43NDUsIDAuNzE1ICksXG4gICAgICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKCAwLjM5LCAwLjU3NSwgMC41NjUsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoIDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1ICksXG5cbiAgICAgIC8vIHF1YWRcbiAgICAgICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllciggMC41NSwgMC4wODUsIDAuNjgsIDAuNTMgKSxcbiAgICAgICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUgKSxcblxuICAgICAgLy8gY3ViaWNcbiAgICAgICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoIDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSApLFxuICAgICAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuMjE1LCAwLjYxLCAwLjM1NSwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEgKSxcblxuICAgICAgLy8gcXVhcnRcbiAgICAgICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuMTY1LCAwLjg0LCAwLjQ0LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllciggMC43NywgMCwgMC4xNzUsIDEgKSxcblxuICAgICAgLy8gcXVpbnRcbiAgICAgICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoIDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoIDAuMjMsIDEsIDAuMzIsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKCAwLjg2LCAwLCAwLjA3LCAxICksXG5cbiAgICAgIC8vIGV4cG9cbiAgICAgICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllciggMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1ICksXG4gICAgICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAwLjE5LCAxLCAwLjIyLCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAxLCAwLCAwLCAxICksXG5cbiAgICAgIC8vIGNpcmNcbiAgICAgICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllciggMC42LCAwLjA0LCAwLjk4LCAwLjMzNSApLFxuICAgICAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllciggMC4wNzUsIDAuODIsIDAuMTY1LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKCAwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYgKSxcblxuXG4gICAgICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAgICAgJ3NwcmluZyc6IGZ1bmN0aW9uKCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKXtcbiAgICAgICAgaWYoIGR1cmF0aW9uID09PSAwICl7IC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICAgICAgcmV0dXJuIGVhc2luZ3MubGluZWFyOyAvLyBkdXJhdGlvbiAwID0+IGp1bXAgdG8gZW5kIHNvIGltcGwgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCggdGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwZXJjZW50ICl7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyggcGVyY2VudCApO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgJ2N1YmljLWJlemllcic6IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXIoIHgxLCB5MSwgeDIsIHkyICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVhc2UoIHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4gKXtcbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCwgZW5kO1xuXG4gICAgICBpZiggc3RhcnRQcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBzdGFydFByb3AudmFsdWUgIT0gbnVsbCApe1xuICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcC5wZlZhbHVlICE9IG51bGwgPyBzdGFydFByb3AucGZWYWx1ZSA6IHN0YXJ0UHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wO1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kUHJvcC5wZlZhbHVlICE9IG51bGwgfHwgZW5kUHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgIGVuZCA9IGVuZFByb3AucGZWYWx1ZSAhPSBudWxsID8gZW5kUHJvcC5wZlZhbHVlIDogZW5kUHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IGVuZFByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5udW1iZXIoIHN0YXJ0ICkgJiYgaXMubnVtYmVyKCBlbmQgKSApe1xuICAgICAgICByZXR1cm4gZWFzaW5nRm4oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKTtcblxuICAgICAgfSBlbHNlIGlmKCBpcy5hcnJheSggc3RhcnQgKSAmJiBpcy5hcnJheSggZW5kICkgKXtcbiAgICAgICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgc2kgPSBzdGFydFsgaSBdO1xuICAgICAgICAgIHZhciBlaSA9IGVuZFsgaSBdO1xuXG4gICAgICAgICAgaWYoIHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCApe1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVhc2luZ0ZuKCBzaSwgZWksIHBlcmNlbnQgKTtcblxuICAgICAgICAgICAgaWYoIHN0YXJ0UHJvcC5yb3VuZFZhbHVlICl7IHZhbCA9IE1hdGgucm91bmQoIHZhbCApOyB9XG5cbiAgICAgICAgICAgIGVhc2VkQXJyLnB1c2goIHZhbCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNlZEFyci5wdXNoKCBlaSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlYXNlZEFycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgY29yZWZuID0gKHtcbiAgb246IGRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gIG9uZTogZGVmaW5lLm9uKCB7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSApLFxuICBvbmNlOiBkZWZpbmUub24oIHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9mZjogZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKSAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBjb3JlZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIHBuZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyggb3B0aW9ucyApO1xuICB9LFxuXG4gIGpwZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyggb3B0aW9ucyApO1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uanBlZyA9IGNvcmVmbi5qcGc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uL3dpbmRvdycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoICcuLi9jb2xsZWN0aW9uJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCAnLi4vcHJvbWlzZScgKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIHZhciBjeSA9IHRoaXM7XG5cbiAgb3B0cyA9IHV0aWwuZXh0ZW5kKCB7fSwgb3B0cyApO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcblxuICAvLyBhbGxvdyBmb3IgcGFzc2luZyBhIHdyYXBwZWQganF1ZXJ5IG9iamVjdFxuICAvLyBlLmcuIGN5dG9zY2FwZSh7IGNvbnRhaW5lcjogJCgnI2N5JykgfSlcbiAgaWYoIGNvbnRhaW5lciAmJiAhaXMuaHRtbEVsZW1lbnQoIGNvbnRhaW5lciApICYmIGlzLmh0bWxFbGVtZW50KCBjb250YWluZXJbMF0gKSApe1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuXG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgcmVnID0gcmVnIHx8IHt9O1xuXG4gIGlmKCByZWcgJiYgcmVnLmN5ICl7XG4gICAgcmVnLmN5LmRlc3Ryb3koKTtcblxuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gIGlmKCBjb250YWluZXIgKXsgY29udGFpbmVyLl9jeXJlZyA9IHJlZzsgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gIHJlZy5jeSA9IGN5O1xuXG4gIHZhciBoZWFkID0gd2luZG93ICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gIHZhciBvcHRpb25zID0gb3B0cztcbiAgb3B0aW9ucy5sYXlvdXQgPSB1dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnIH0sIG9wdGlvbnMubGF5b3V0ICk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSB1dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCcgfSwgb3B0aW9ucy5yZW5kZXJlciApO1xuXG4gIHZhciBkZWZWYWwgPSBmdW5jdGlvbiggZGVmLCB2YWwsIGFsdFZhbCApe1xuICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYoIGFsdFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gYWx0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLCAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLCAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKCB0aGlzICksIC8vIGVsZW1lbnRzIGluIHRoZSBncmFwaFxuICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24oIHRoaXMgKSwgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICBzY3JhdGNoOiB7fSwgLy8gc2NyYXRjaCBvYmplY3QgZm9yIGNvcmVcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgcmVuZGVyZXI6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSwgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSwgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCggdHJ1ZSwgb3B0aW9ucy56b29taW5nRW5hYmxlZCApLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKCB0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCApLFxuICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQgKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCggdHJ1ZSwgb3B0aW9ucy51c2VyUGFubmluZ0VuYWJsZWQgKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCApLFxuICAgIGF1dG9sb2NrOiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMgKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzICksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSApLFxuICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICB6b29tOiBpcy5udW1iZXIoIG9wdGlvbnMuem9vbSApID8gb3B0aW9ucy56b29tIDogMSxcbiAgICBwYW46IHtcbiAgICAgIHg6IGlzLnBsYWluT2JqZWN0KCBvcHRpb25zLnBhbiApICYmIGlzLm51bWJlciggb3B0aW9ucy5wYW4ueCApID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICB5OiBpcy5wbGFpbk9iamVjdCggb3B0aW9ucy5wYW4gKSAmJiBpcy5udW1iZXIoIG9wdGlvbnMucGFuLnkgKSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2VcbiAgfTtcblxuICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgdmFyIHNlbFR5cGUgPSBvcHRpb25zLnNlbGVjdGlvblR5cGU7XG4gIGlmKCBzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgKHNlbFR5cGUgIT09ICdhZGRpdGl2ZScgJiYgc2VsVHlwZSAhPT0gJ3NpbmdsZScpICl7XG4gICAgLy8gdGhlbiBzZXQgZGVmYXVsdFxuXG4gICAgX3Auc2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xuICB9IGVsc2Uge1xuICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICB9XG5cbiAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1pblpvb20gKSAmJiBpcy5udW1iZXIoIG9wdGlvbnMubWF4Wm9vbSApICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWluWm9vbSApICYmIG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgX3AubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWF4Wm9vbSApICYmIG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfVxuXG4gIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uKCBleHREYXRhLCBuZXh0ICl7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZSggaXMucHJvbWlzZSApO1xuXG4gICAgaWYoIGFueUlzUHJvbWlzZSApe1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKCBleHREYXRhICkudGhlbiggbmV4dCApOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoIGV4dERhdGEgKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgIH1cbiAgfTtcblxuICAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG4gIGN5LmluaXRSZW5kZXJlciggdXRpbC5leHRlbmQoIHtcbiAgICBoaWRlRWRnZXNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQsXG4gICAgdGV4dHVyZU9uVmlld3BvcnQ6IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQsXG4gICAgd2hlZWxTZW5zaXRpdml0eTogaXMubnVtYmVyKCBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgKSAmJiBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgPiAwID8gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5IDogMSxcbiAgICBtb3Rpb25CbHVyOiBvcHRpb25zLm1vdGlvbkJsdXIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5tb3Rpb25CbHVyLCAvLyBvZmYgYnkgZGVmYXVsdFxuICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICBwaXhlbFJhdGlvOiBpcy5udW1iZXIoIG9wdGlvbnMucGl4ZWxSYXRpbyApICYmIG9wdGlvbnMucGl4ZWxSYXRpbyA+IDAgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiB1bmRlZmluZWQsXG4gICAgZGVza3RvcFRhcFRocmVzaG9sZDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA0IDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkLFxuICAgIHRvdWNoVGFwVGhyZXNob2xkOiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA4IDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZFxuICB9LCBvcHRpb25zLnJlbmRlcmVyICkgKTtcblxuICB2YXIgc2V0RWxlc0FuZExheW91dCA9IGZ1bmN0aW9uKCBlbGVtZW50cywgb25sb2FkLCBvbmRvbmUgKXtcbiAgICBjeS5ub3RpZmljYXRpb25zKCBmYWxzZSApO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgaWYoIG9sZEVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBlbGVtZW50cyApIHx8IGlzLmFycmF5KCBlbGVtZW50cyApICl7XG4gICAgICAgIGN5LmFkZCggZWxlbWVudHMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5vbmUoICdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKCB0cnVlICk7XG4gICAgICBjeS50cmlnZ2VyKCBlICk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgY3kubm90aWZ5KCB7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgZWxlczogY3kubXV0YWJsZUVsZW1lbnRzKClcbiAgICAgIH0gKTtcblxuICAgICAgY3kub25lKCAnbG9hZCcsIG9ubG9hZCApO1xuICAgICAgY3kudHJpZ2dlciggJ2xvYWQnICk7XG4gICAgfSApLm9uZSggJ2xheW91dHN0b3AnLCBmdW5jdGlvbigpe1xuICAgICAgY3kub25lKCAnZG9uZScsIG9uZG9uZSApO1xuICAgICAgY3kudHJpZ2dlciggJ2RvbmUnICk7XG4gICAgfSApO1xuXG4gICAgdmFyIGxheW91dE9wdHMgPSB1dGlsLmV4dGVuZCgge30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0ICk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGN5LmxheW91dCggbGF5b3V0T3B0cyApLnJ1bigpO1xuICB9O1xuXG4gIGxvYWRFeHREYXRhKFsgb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50cyBdLCBmdW5jdGlvbiggdGhlbnMgKXtcbiAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgdmFyIGluaXRFbGVzID0gdGhlbnNbMV07XG5cbiAgICAvLyBpbml0IHN0eWxlXG4gICAgaWYoIF9wLnN0eWxlRW5hYmxlZCApe1xuICAgICAgY3kuc2V0U3R5bGUoIGluaXRTdHlsZSApO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIHNldEVsZXNBbmRMYXlvdXQoIGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYoIGlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgY3kub24oICdyZWFkeScsIG9wdGlvbnMucmVhZHkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZm4gPSByZWFkaWVzWyBpIF07XG4gICAgICAgIGN5Lm9uKCAncmVhZHknLCBmbiApO1xuICAgICAgfVxuICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cbiAgICAgIGN5LnRyaWdnZXIoICdyZWFkeScgKTtcbiAgICB9LCBvcHRpb25zLmRvbmUgKTtcblxuICB9ICk7XG59O1xuXG52YXIgY29yZWZuID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbnV0aWwuZXh0ZW5kKCBjb3JlZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICdjb3JlJztcbiAgfSxcblxuICBpc1JlYWR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICB9LFxuXG4gIGlzRGVzdHJveWVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmRlc3Ryb3llZDtcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgaWYoIHRoaXMuaXNSZWFkeSgpICl7XG4gICAgICB0aGlzLnRyaWdnZXIoICdyZWFkeScsIFtdLCBmbiApOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oICdyZWFkeScsIGZuICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmKCBjeS5pc0Rlc3Ryb3llZCgpICkgcmV0dXJuO1xuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCAnZGVzdHJveScgKTtcblxuICAgIGN5Ll9wcml2YXRlLmRlc3Ryb3llZCA9IHRydWU7XG5cbiAgICByZXR1cm4gY3k7XG4gIH0sXG5cbiAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24oIGlkICl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuaGFzRWxlbWVudFdpdGhJZCggaWQgKTtcbiAgfSxcblxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24oIGlkICl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gIH0sXG5cbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zZWxlY3Rpb25UeXBlO1xuICB9LFxuXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcblxuICBoZWFkbGVzczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJztcbiAgfSxcblxuICBzdHlsZUVuYWJsZWQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuXG4gIGFkZFRvUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLm1lcmdlKCBlbGVzICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoIGVsZXMgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gIH0sXG5cbiAgb3B0aW9uczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdXRpbC5jb3B5KCB0aGlzLl9wcml2YXRlLm9wdGlvbnMgKTtcbiAgfSxcblxuICBqc29uOiBmdW5jdGlvbiggb2JqICl7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KCBvYmogKSApeyAvLyBzZXRcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiggb2JqLmVsZW1lbnRzICl7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24oIGpzb25zLCBnciApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbIGkgXTtcbiAgICAgICAgICAgIHZhciBpZCA9IGpzb24uZGF0YS5pZDtcbiAgICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuICAgICAgICAgICAgaWRJbkpzb25bIGlkIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiggZWxlLmxlbmd0aCAhPT0gMCApeyAvLyBleGlzdGluZyBlbGVtZW50IHNob3VsZCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAgIGVsZS5qc29uKCBqc29uICk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2hvdWxkIGJlIGFkZGVkXG4gICAgICAgICAgICAgIGlmKCBnciApe1xuICAgICAgICAgICAgICAgIGN5LmFkZCggdXRpbC5leHRlbmQoIHsgZ3JvdXA6IGdyIH0sIGpzb24gKSApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5LmFkZCgganNvbiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBpcy5hcnJheSggb2JqLmVsZW1lbnRzICkgKXsgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyggb2JqLmVsZW1lbnRzICk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbICdub2RlcycsICdlZGdlcycgXTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGdycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGdyID0gZ3JzWyBpIF07XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBvYmouZWxlbWVudHNbIGdyIF07XG5cbiAgICAgICAgICAgIGlmKCBpcy5hcnJheSggZWxlbWVudHMgKSApe1xuICAgICAgICAgICAgICB1cGRhdGVFbGVzKCBlbGVtZW50cywgZ3IgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbGVtZW50cyBub3Qgc3BlY2lmaWVkIGluIGpzb24gc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgZWxlcy5zdGRGaWx0ZXIoIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uWyBlbGUuaWQoKSBdO1xuICAgICAgICB9ICkucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvYmouc3R5bGUgKXtcbiAgICAgICAgY3kuc3R5bGUoIG9iai5zdHlsZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggb2JqLnpvb20gIT0gbnVsbCAmJiBvYmouem9vbSAhPT0gX3Auem9vbSApe1xuICAgICAgICBjeS56b29tKCBvYmouem9vbSApO1xuICAgICAgfVxuXG4gICAgICBpZiggb2JqLnBhbiApe1xuICAgICAgICBpZiggb2JqLnBhbi54ICE9PSBfcC5wYW4ueCB8fCBvYmoucGFuLnkgIT09IF9wLnBhbi55ICl7XG4gICAgICAgICAgY3kucGFuKCBvYmoucGFuICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICAgJ21pblpvb20nLCAnbWF4Wm9vbScsICd6b29taW5nRW5hYmxlZCcsICd1c2VyWm9vbWluZ0VuYWJsZWQnLFxuICAgICAgICAncGFubmluZ0VuYWJsZWQnLCAndXNlclBhbm5pbmdFbmFibGVkJyxcbiAgICAgICAgJ2JveFNlbGVjdGlvbkVuYWJsZWQnLFxuICAgICAgICAnYXV0b2xvY2snLCAnYXV0b3VuZ3JhYmlmeScsICdhdXRvdW5zZWxlY3RpZnknXG4gICAgICBdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZiA9IGZpZWxkc1sgaSBdO1xuXG4gICAgICAgIGlmKCBvYmpbIGYgXSAhPSBudWxsICl7XG4gICAgICAgICAgY3lbIGYgXSggb2JqWyBmIF0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9IGVsc2UgaWYoIG9iaiA9PT0gdW5kZWZpbmVkICl7IC8vIGdldFxuICAgICAgdmFyIGpzb24gPSB7fTtcblxuICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgZWxlcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuXG4gICAgICAgIGlmKCAhanNvbi5lbGVtZW50c1sgZ3JvdXAgXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbIGdyb3VwIF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpzb24uZWxlbWVudHNbIGdyb3VwIF0ucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgfSApO1xuXG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQgKXtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBjeS5fcHJpdmF0ZS5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gY3kuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSB1dGlsLmNvcHkoIGN5Ll9wcml2YXRlLnBhbiApO1xuICAgICAganNvbi5ib3hTZWxlY3Rpb25FbmFibGVkID0gY3kuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIGpzb24ucmVuZGVyZXIgPSB1dGlsLmNvcHkoIGN5Ll9wcml2YXRlLm9wdGlvbnMucmVuZGVyZXIgKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH0sXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9IClcblxufSApO1xuXG5jb3JlZm4uJGlkID0gY29yZWZuLmdldEVsZW1lbnRCeUlkO1xuXG5bXG4gIHJlcXVpcmUoICcuL2FkZC1yZW1vdmUnICksXG4gIHJlcXVpcmUoICcuL2FuaW1hdGlvbicgKSxcbiAgcmVxdWlyZSggJy4vZXZlbnRzJyApLFxuICByZXF1aXJlKCAnLi9leHBvcnQnICksXG4gIHJlcXVpcmUoICcuL2xheW91dCcgKSxcbiAgcmVxdWlyZSggJy4vbm90aWZpY2F0aW9uJyApLFxuICByZXF1aXJlKCAnLi9yZW5kZXJlcicgKSxcbiAgcmVxdWlyZSggJy4vc2VhcmNoJyApLFxuICByZXF1aXJlKCAnLi9zdHlsZScgKSxcbiAgcmVxdWlyZSggJy4vdmlld3BvcnQnIClcbl0uZm9yRWFjaCggZnVuY3Rpb24oIHByb3BzICl7XG4gIHV0aWwuZXh0ZW5kKCBjb3JlZm4sIHByb3BzICk7XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgbGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiggb3B0aW9ucyA9PSBudWxsICl7XG4gICAgICB1dGlsLmVycm9yKCAnTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5uYW1lID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0JyApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHZhciBMYXlvdXQgPSBjeS5leHRlbnNpb24oICdsYXlvdXQnLCBuYW1lICk7XG5cbiAgICBpZiggTGF5b3V0ID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGFwcGx5IGxheW91dDogTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZXM7XG4gICAgaWYoIGlzLnN0cmluZyggb3B0aW9ucy5lbGVzICkgKXtcbiAgICAgIGVsZXMgPSBjeS4kKCBvcHRpb25zLmVsZXMgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGVsZXM6IGVsZXNcbiAgICB9ICkgKTtcblxuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cblxufSk7XG5cbmNvcmVmbi5jcmVhdGVMYXlvdXQgPSBjb3JlZm4ubWFrZUxheW91dCA9IGNvcmVmbi5sYXlvdXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZWZuID0gKHtcbiAgbm90aWZ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC5iYXRjaGluZ05vdGlmeSApe1xuICAgICAgdmFyIGJFbGVzID0gX3AuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgdmFyIGJUeXBlcyA9IF9wLmJhdGNoTm90aWZ5VHlwZXM7XG5cbiAgICAgIGlmKCBwYXJhbXMuZWxlcyApe1xuICAgICAgICBiRWxlcy5tZXJnZSggcGFyYW1zLmVsZXMgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdICl7XG4gICAgICAgIGJUeXBlcy5wdXNoKCBwYXJhbXMudHlwZSApO1xuICAgICAgICBiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICB9XG5cbiAgICBpZiggIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkICl7IHJldHVybjsgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG5cbiAgICAvLyBleGl0IGlmIGRlc3Ryb3koKSBjYWxsZWQgb24gY29yZSBvciByZW5kZXJlciBpbiBiZXR3ZWVuIGZyYW1lcyAjMTQ5OSAjMTUyOFxuICAgIGlmKCB0aGlzLmlzRGVzdHJveWVkKCkgfHwgIXJlbmRlcmVyICl7IHJldHVybjsgfVxuXG4gICAgcmVuZGVyZXIubm90aWZ5KCBwYXJhbXMgKTtcbiAgfSxcblxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBib29sID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoIGZhbHNlICk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoIHRydWUgKTtcbiAgfSxcblxuICBzdGFydEJhdGNoOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PSBudWxsICl7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PT0gMCApe1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIF9wLmJhdGNoQ291bnQtLTtcblxuICAgIGlmKCBfcC5iYXRjaENvdW50ID09PSAwICl7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBmYWxzZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBfcC5iYXRjaGluZ05vdGlmeSA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogX3AuYmF0Y2hOb3RpZnlUeXBlcyxcbiAgICAgICAgZWxlczogX3AuYmF0Y2hOb3RpZnlFbGVzXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYmF0Y2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGJhdGNoRGF0YTogZnVuY3Rpb24oIG1hcCApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5iYXRjaCggZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyggbWFwICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBbIGlkIF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuICAgICAgICBlbGUuZGF0YSggZGF0YSApO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICByZW5kZXJUbzogZnVuY3Rpb24oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgIHIucmVuZGVyVG8oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlcmVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuXG4gIGZvcmNlUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHRoaXMubm90aWZ5KCB7XG4gICAgICB0eXBlOiAnZHJhdydcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZXNpemU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5ub3RpZnkoIHtcbiAgICAgIHR5cGU6ICdyZXNpemUnXG4gICAgfSApO1xuXG4gICAgdGhpcy50cmlnZ2VyKCAncmVzaXplJyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbiggJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lICk7XG4gICAgaWYoIFJlbmRlcmVyUHJvdG8gPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgJXNgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jywgb3B0aW9ucy5uYW1lICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJPcHRzID0gdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3lcbiAgICB9ICk7XG5cbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKCByT3B0cyApO1xuICB9LFxuXG4gIGRlc3Ryb3lSZW5kZXJlcjogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kubm90aWZ5KCB7IHR5cGU6ICdkZXN0cm95JyB9ICk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICB2YXIgZG9tRWxlID0gY3kuY29udGFpbmVyKCk7XG4gICAgaWYoIGRvbUVsZSApe1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlKCBkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICl7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZCggZG9tRWxlLmNoaWxkTm9kZXNbMF0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG51bGw7IC8vIHRvIGJlIGV4dHJhIHNhZmUsIHJlbW92ZSB0aGUgcmVmXG4gIH0sXG5cbiAgb25SZW5kZXI6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG5cbiAgb2ZmUmVuZGVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgfVxuXG59KTtcblxuY29yZWZuLmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuLnJlc2l6ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4uL2NvbGxlY3Rpb24nICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24oIGVsZXMsIG9wdHMgKXtcblxuICAgIGlmKCBpcy5zdHJpbmcoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBlbGVzICkgKXtcbiAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLCBlbGVzLCBvcHRzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzICk7XG4gIH0sXG5cbiAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBub2RlcyA9IHRoaXMuJCggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICB9ICk7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuXG4gIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLiQoIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSApO1xuXG4gICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHJldHVybiBlZGdlcztcbiAgfSxcblxuICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcblxuICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICB9XG4gIH0sXG5cbiAgbXV0YWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG5cbn0pO1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4uZWxlbWVudHMgPSBjb3JlZm4uZmlsdGVyID0gY29yZWZuLiQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgU3R5bGUgPSByZXF1aXJlKCAnLi4vc3R5bGUnICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIHN0eWxlOiBmdW5jdGlvbiggbmV3U3R5bGUgKXtcbiAgICBpZiggbmV3U3R5bGUgKXtcbiAgICAgIHZhciBzID0gdGhpcy5zZXRTdHlsZSggbmV3U3R5bGUgKTtcblxuICAgICAgcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcblxuICBzZXRTdHlsZTogZnVuY3Rpb24oIHN0eWxlICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBpcy5zdHlsZXNoZWV0KCBzdHlsZSApICl7XG4gICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUoIHRoaXMgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIHN0eWxlICkgKXtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbUpzb24oIHRoaXMsIHN0eWxlICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyggc3R5bGUgKSApe1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tU3RyaW5nKCB0aGlzLCBzdHlsZSApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUoIHRoaXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoICcuLi93aW5kb3cnICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIGF1dG9sb2NrOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgem9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBib3hTZWxlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFuOiBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgY2FzZSAwOiAvLyAucGFuKClcbiAgICAgIHJldHVybiBwYW47XG5cbiAgICBjYXNlIDE6XG5cbiAgICAgIGlmKCBpcy5zdHJpbmcoIGFyZ3NbMF0gKSApeyAvLyAucGFuKCd4JylcbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgcmV0dXJuIHBhblsgZGltIF07XG5cbiAgICAgIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIGFyZ3NbMF0gKSApeyAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggeCApICl7XG4gICAgICAgICAgcGFuLnggPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggeSApICl7XG4gICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHZpZXdwb3J0JyApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6IC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICBpZiggKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBpcy5udW1iZXIoIHZhbCApICl7XG4gICAgICAgIHBhblsgZGltIF0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB2aWV3cG9ydCcgKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoIHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFuQnk6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgY2FzZSAxOlxuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGFyZ3NbMF0gKSApeyAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggeCApICl7XG4gICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoIHkgKSApe1xuICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoICdwYW4gdmlld3BvcnQnICk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjogLy8gLnBhbkJ5KCd4JywgMTAwKVxuICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIGlzLm51bWJlciggdmFsICkgKXtcbiAgICAgICAgcGFuWyBkaW0gXSArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB2aWV3cG9ydCcgKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoIHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZml0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoIGVsZW1lbnRzLCBwYWRkaW5nICk7XG5cbiAgICBpZiggdmlld3BvcnRTdGF0ZSApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLnpvb20gPSB2aWV3cG9ydFN0YXRlLnpvb207XG4gICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcblxuICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHpvb20gdmlld3BvcnQnICk7XG5cbiAgICAgIHRoaXMubm90aWZ5KCB7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgIGlmKCBpcy5udW1iZXIoIGVsZW1lbnRzICkgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkICl7IC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmI7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBlbGVtZW50cyApICl7XG4gICAgICB2YXIgc2VsID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuJCggc2VsICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmJvdW5kaW5nQm94KCBlbGVtZW50cyApICl7IC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG5cbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgICB9IGVsc2UgaWYoICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBlbGVtZW50cyApICl7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBpcy5udW1iZXIoIHBhZGRpbmcgKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgaWYoICFpc05hTiggdyApICYmICFpc05hTiggaCApICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTiggYmIudyApICYmICFpc05hTiggYmIuaCApICYmICBiYi53ID4gMCAmJiBiYi5oID4gMCApe1xuICAgICAgem9vbSA9IE1hdGgubWluKCAodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCApO1xuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgdmFyIHBhbiA9IHsgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKCBiYi54MSArIGJiLngyICkpIC8gMixcbiAgICAgICAgeTogKGggLSB6b29tICogKCBiYi55MSArIGJiLnkyICkpIC8gMlxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBwYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIG1pblpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgaWYoIHpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggem9vbSApICl7XG4gICAgICB0aGlzLl9wcml2YXRlLm1pblpvb20gPSB6b29tO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG1heFpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgaWYoIHpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggem9vbSApICl7XG4gICAgICB0aGlzLl9wcml2YXRlLm1heFpvb20gPSB6b29tO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHpvb206IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgIHZhciB6b29tO1xuXG4gICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSB6b29tXG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIHBhcmFtcyApICl7IC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICB6b29tID0gcGFyYW1zO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggcGFyYW1zICkgKXsgLy8gdGhlbiB6b29tIGFib3V0IGEgcG9pbnRcbiAgICAgIHpvb20gPSBwYXJhbXMubGV2ZWw7XG5cbiAgICAgIGlmKCBwYXJhbXMucG9zaXRpb24gKXtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXMucG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgICAgdmFyIHogPSB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgICAgcG9zID0geyAvLyBjb252ZXJ0IHRvIHJlbmRlcmVkIHB4XG4gICAgICAgICAgeDogcC54ICogeiArIHBhbi54LFxuICAgICAgICAgIHk6IHAueSAqIHogKyBwYW4ueVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYoIHBvcyAmJiAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICB9XG5cbiAgICBpZiggIWlzLm51bWJlciggem9vbSApIHx8ICggcG9zICYmICghaXMubnVtYmVyKCBwb3MueCApIHx8ICFpcy5udW1iZXIoIHBvcy55ICkpICkgKXtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjYW4ndCB6b29tIHdpdGggaW52YWxpZCBwYXJhbXNcbiAgICB9XG5cbiAgICAvLyBjcm9wIHpvb21cbiAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgaWYoIHBvcyApeyAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgdmFyIHBhbjEgPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciB6b29tMSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICAgIHZhciB6b29tMiA9IHpvb207XG5cbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbSA9IHpvb207XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjI7XG5cbiAgICAgIHZhciBwb3NDaGFuZ2VkID0gcGFuMS54ICE9PSBwYW4yLnggfHwgcGFuMS55ICE9PSBwYW4yLnk7XG4gICAgICB0aGlzLnRyaWdnZXIoICcgem9vbSAnICsgKHBvc0NoYW5nZWQgPyAnIHBhbiAnIDogJycpICsgJyB2aWV3cG9ydCAnICk7XG5cbiAgICB9IGVsc2UgeyAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgIHRoaXMudHJpZ2dlciggJ3pvb20gdmlld3BvcnQnICk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoIHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdmlld3BvcnQ6IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgem9vbURlZmQgPSB0cnVlO1xuICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnRzID0gW107IC8vIHRvIHRyaWdnZXJcbiAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgIGlmKCAhb3B0cyApeyByZXR1cm4gdGhpczsgfVxuICAgIGlmKCAhaXMubnVtYmVyKCBvcHRzLnpvb20gKSApeyB6b29tRGVmZCA9IGZhbHNlOyB9XG4gICAgaWYoICFpcy5wbGFpbk9iamVjdCggb3B0cy5wYW4gKSApeyBwYW5EZWZkID0gZmFsc2U7IH1cbiAgICBpZiggIXpvb21EZWZkICYmICFwYW5EZWZkICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICBpZiggem9vbURlZmQgKXtcbiAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuXG4gICAgICBpZiggeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC56b29tID0gejtcblxuICAgICAgICBldmVudHMucHVzaCggJ3pvb20nICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgIGlmKCBpcy5udW1iZXIoIHAueCApICl7XG4gICAgICAgIF9wLnBhbi54ID0gcC54O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlciggcC55ICkgKXtcbiAgICAgICAgX3AucGFuLnkgPSBwLnk7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggIXBhbkZhaWxlZCApe1xuICAgICAgICBldmVudHMucHVzaCggJ3BhbicgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZXZlbnRzLmxlbmd0aCA+IDAgKXtcbiAgICAgIGV2ZW50cy5wdXNoKCAndmlld3BvcnQnICk7XG4gICAgICB0aGlzLnRyaWdnZXIoIGV2ZW50cy5qb2luKCAnICcgKSApO1xuXG4gICAgICB0aGlzLm5vdGlmeSgge1xuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiggZWxlbWVudHMgKXtcbiAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oIGVsZW1lbnRzICk7XG5cbiAgICBpZiggcGFuICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcblxuICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHZpZXdwb3J0JyApO1xuXG4gICAgICB0aGlzLm5vdGlmeSggeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGdldENlbnRlclBhbjogZnVuY3Rpb24oIGVsZW1lbnRzLCB6b29tICl7XG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyggZWxlbWVudHMgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0gZWxzZSBpZiggIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGVsZW1lbnRzICkgKXtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB2YXIgYmIgPSBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fcHJpdmF0ZS56b29tIDogem9vbTtcblxuICAgIHZhciBwYW4gPSB7IC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tICogKCBiYi54MSArIGJiLngyICkpIC8gMixcbiAgICAgIHk6IChoIC0gem9vbSAqICggYmIueTEgKyBiYi55MiApKSAvIDJcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBhbjtcbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24oKXtcbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQoIHtcbiAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICB6b29tOiAxXG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgaW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fcHJpdmF0ZS5zaXplQ2FjaGUgPSBudWxsO1xuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuXG4gICAgcmV0dXJuICggX3Auc2l6ZUNhY2hlID0gX3Auc2l6ZUNhY2hlIHx8ICggY29udGFpbmVyID8gKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250YWluZXIgKTtcbiAgICAgIHZhciB2YWwgPSBmdW5jdGlvbiggbmFtZSApeyByZXR1cm4gcGFyc2VGbG9hdCggc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApICk7IH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC0gdmFsKCdwYWRkaW5nLWxlZnQnKSAtIHZhbCgncGFkZGluZy1yaWdodCcpIC0gdmFsKCdib3JkZXItbGVmdC13aWR0aCcpIC0gdmFsKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAtIHZhbCgncGFkZGluZy10b3AnKSAtIHZhbCgncGFkZGluZy1ib3R0b20nKSAtIHZhbCgnYm9yZGVyLXRvcC13aWR0aCcpIC0gdmFsKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgICAgIH07XG4gICAgfSkoKSA6IHsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfSApICk7XG4gIH0sXG5cbiAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLndpZHRoO1xuICB9LFxuXG4gIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICB9LFxuXG4gIGV4dGVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuXG4gICAgdmFyIGIgPSB7XG4gICAgICB4MTogKCByYi54MSAtIHBhbi54ICkgLyB6b29tLFxuICAgICAgeDI6ICggcmIueDIgLSBwYW4ueCApIC8gem9vbSxcbiAgICAgIHkxOiAoIHJiLnkxIC0gcGFuLnkgKSAvIHpvb20sXG4gICAgICB5MjogKCByYi55MiAtIHBhbi55ICkgLyB6b29tXG4gICAgfTtcblxuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgcmV0dXJuIGI7XG4gIH0sXG5cbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4Mjogd2lkdGgsXG4gICAgICB5MjogaGVpZ2h0LFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHRcbiAgICB9O1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuY29yZWZuLmNlbnRyZSA9IGNvcmVmbi5jZW50ZXI7XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb3JlZm4uYXV0b2xvY2tOb2RlcyA9IGNvcmVmbi5hdXRvbG9jaztcbmNvcmVmbi5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSBjb3JlZm4uYXV0b3VuZ3JhYmlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxuLy8gKHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIHRoZSBjb3JlIGFuZCBjb2xsZWN0aW9ucywgZm9yIGV4YW1wbGUpXG5cbi8vIGUuZy5cbi8vIHZhciBmb28gPSBkZWZpbmUuZm9vKHsgLyogcGFyYW1zLi4uICovIH0pXG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSggJy4vc2VsZWN0b3InICk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoICcuL3Byb21pc2UnICk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCAnLi9ldmVudCcgKTtcbnZhciBBbmltYXRpb24gPSByZXF1aXJlKCAnLi9hbmltYXRpb24nICk7XG5cbnZhciBkZWZpbmUgPSB7XG5cbiAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgZGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30sIC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7fSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIHNlbGYgKXsgcmV0dXJuIHRydWU7IH1cbiAgICB9O1xuICAgIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmO1xuXG4gICAgICAvLyAuZGF0YSgnZm9vJywgLi4uKVxuICAgICAgaWYoIGlzLnN0cmluZyggbmFtZSApICl7IC8vIHNldCBvciBnZXQgcHJvcGVydHlcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJylcbiAgICAgICAgaWYoIHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG5cbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBuYW1lIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1sgbmFtZSBdO1xuICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgICAgICAgIGlmKCBwLmNhblNldCggYWxsWyBpIF0gKSApe1xuICAgICAgICAgICAgICAgIGFsbFsgaSBdLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgaXMucGxhaW5PYmplY3QoIG5hbWUgKSApeyAvLyBleHRlbmRcbiAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgIHZhciBrLCB2O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBvYmogKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBrID0ga2V5c1sgaSBdO1xuICAgICAgICAgIHYgPSBvYmpbIGsgXTtcblxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGsgXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbal07XG5cbiAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBlbGUgKSApe1xuICAgICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBrIF0gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgaWYoIHAudXBkYXRlU3R5bGUgKXsgc2VsZi51cGRhdGVTdHlsZSgpOyB9XG5cbiAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICBwLm9uU2V0KCBzZWxmICk7XG5cbiAgICAgICAgaWYoIHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQgKXtcbiAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0JpbmRpbmcgJiYgaXMuZm4oIG5hbWUgKSApeyAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgIHNlbGYub24oIHAuYmluZGluZ0V2ZW50LCBmbiApO1xuXG4gICAgICAvLyAuZGF0YSgpXG4gICAgICB9IGVsc2UgaWYoIHAuYWxsb3dHZXR0aW5nICYmIG5hbWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXQgd2hvbGUgb2JqZWN0XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbIHAuZmllbGQgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gZGF0YVxuXG4gIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICB9O1xuICAgIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKCBuYW1lcyApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG4gICAgICBpZiggaXMuc3RyaW5nKCBuYW1lcyApICl7IC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICB2YXIga2V5cyA9IG5hbWVzLnNwbGl0KCAvXFxzKy8gKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApeyAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbIGkgXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoIGtleSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgICAgICBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF1bIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwLnRyaWdnZXJFdmVudCApe1xuICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLmV2ZW50ICk7XG4gICAgICAgIH1cblxuICAgICAgLy8gLnJlbW92ZURhdGEoKVxuICAgICAgfSBlbHNlIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG5cbiAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgIHZhciBfcHJpdmF0ZUZpZWxkcyA9IGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXTtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBfcHJpdmF0ZUZpZWxkcyApO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWxpZEtleVRvRGVsZXRlID0gIXAuaW1tdXRhYmxlS2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgIGlmKCB2YWxpZEtleVRvRGVsZXRlICl7XG4gICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcC50cmlnZ2VyRXZlbnQgKXtcbiAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIHJlbW92ZURhdGFcblxuICAvLyBldmVudCBmdW5jdGlvbiByZXVzYWJsZSBzdHVmZlxuICBldmVudDoge1xuICAgIHJlZ2V4OiAvKFxcdyspKFxcLig/Olxcdyt8XFwqKSk/LywgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcbiAgICB1bml2ZXJzYWxOYW1lc3BhY2U6ICcuKicsIC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG4gICAgb3B0aW9uYWxUeXBlUmVnZXg6IC8oXFx3Kyk/KFxcLig/Olxcdyt8XFwqKSk/LyxcbiAgICBmYWxzZUNhbGxiYWNrOiBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH1cbiAgfSxcblxuICAvLyBldmVudCBiaW5kaW5nXG4gIG9uOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgdW5iaW5kU2VsZk9uVHJpZ2dlcjogZmFsc2UsXG4gICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBmYWxzZVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gb25JbXBsKCBldmVudHMsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjayApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBldmVudHNJc1N0cmluZyA9IGlzLnN0cmluZyggZXZlbnRzICk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBzZWxlY3RvciApICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGRhdGFcbiAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKCBpcy5mbiggc2VsZWN0b3IgKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5mbiggZGF0YSApIHx8IGRhdGEgPT09IGZhbHNlICl7IC8vIGRhdGEgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIGNhbGxiYWNrLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmdcbiAgICAgIC8vIChjYW4ndCBzcGVhayBmb3IgbWFwcGVkIGV2ZW50cyBhcmcgdmVyc2lvbilcbiAgICAgIGlmKCAhKGlzLmZuKCBjYWxsYmFjayApIHx8IGNhbGxiYWNrID09PSBmYWxzZSkgJiYgZXZlbnRzSXNTdHJpbmcgKXtcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIGNvbnZlcnQgdG8gbWFwXG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICBldmVudHMgPSBtYXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGV2ZW50cyApO1xuXG4gICAgICBmb3IoIHZhciBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgdmFyIGV2dHMgPSBrZXlzW2tdO1xuXG4gICAgICAgIGNhbGxiYWNrID0gZXZlbnRzWyBldnRzIF07XG4gICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICBjYWxsYmFjayA9IGRlZmluZS5ldmVudC5mYWxzZUNhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFpcy5mbiggY2FsbGJhY2sgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KCAvXFxzKy8gKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGV2dCA9IGV2dHNbIGkgXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoIGV2dCApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLCAvLyBleHRyYSBkYXRhIGluIGV2ZW50T2JqLmRhdGFcbiAgICAgICAgICAgICAgZGVsZWdhdGVkOiBzZWxlY3RvciA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZXZ0IGlzIGRlbGVnYXRlZFxuICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsIC8vIHRoZSBzZWxlY3RvciB0byBtYXRjaCBmb3IgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICAgICAgICBzZWxPYmo6IG5ldyBTZWxlY3Rvciggc2VsZWN0b3IgKSwgLy8gY2FjaGVkIHNlbGVjdG9yIG9iamVjdCB0byBzYXZlIHJlYnVpbGRpbmdcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSwgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgICAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IHAudW5iaW5kU2VsZk9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogcC51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyLFxuICAgICAgICAgICAgICBiaW5kZXJzOiBhbGwgLy8gd2hvIGJvdW5kIHRvZ2V0aGVyXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICB2YXIgX3AgPSBhbGxbIGogXS5fcHJpdmF0ZSA9IGFsbFsgaiBdLl9wcml2YXRlIHx8IHt9O1xuXG4gICAgICAgICAgICAgIF9wLmxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICAgICAgX3AubGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcbiAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gb25cblxuICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24oIHByb3RvICl7XG4gICAgdmFyIHAgPSBwcm90bztcblxuICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgcC5yZW1vdmVMaXN0ZW5lciA9IHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmO1xuICAgIHAuZW1pdCA9IHAudHJpZ2dlcjtcblxuICAgIC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcbiAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgICAgICBzZWxmLm9mZi5hcHBseSggc2VsZiwgb2ZmQXJncyApO1xuXG4gICAgICAgICAgcmVzb2x2ZSggZSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdCggWyBjYWxsYmFjayBdICk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdCggW10gKTtcblxuICAgICAgICBzZWxmLm9uLmFwcGx5KCBzZWxmLCBvbkFyZ3MgKTtcbiAgICAgIH0gKTtcbiAgICB9O1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gb2ZmSW1wbCggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKCBldmVudHMgKTtcblxuICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKXsgLy8gdGhlbiB1bmJpbmQgYWxsXG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBhbGxbIGkgXS5fcHJpdmF0ZSA9IGFsbFsgaSBdLl9wcml2YXRlIHx8IHt9O1xuXG4gICAgICAgICAgX3AubGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLmZuKCBzZWxlY3RvciApIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBtYXBbIGV2ZW50cyBdID0gY2FsbGJhY2s7XG4gICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZXZlbnRzICk7XG5cbiAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKyApe1xuICAgICAgICB2YXIgZXZ0cyA9IGtleXNba107XG5cbiAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbIGV2dHMgXTtcblxuICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KCAvXFxzKy8gKTtcbiAgICAgICAgZm9yKCB2YXIgaCA9IDA7IGggPCBldnRzLmxlbmd0aDsgaCsrICl7XG4gICAgICAgICAgdmFyIGV2dCA9IGV2dHNbIGggXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoIGV2dCApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5vcHRpb25hbFR5cGVSZWdleCApOyAvLyBbdHlwZV1bLm5hbWVzcGFjZV1cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApeyAvL1xuICAgICAgICAgICAgICB2YXIgX3AgPSBhbGxbIGkgXS5fcHJpdmF0ZSA9IGFsbFsgaSBdLl9wcml2YXRlIHx8IHt9O1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gX3AubGlzdGVuZXJzID0gX3AubGlzdGVuZXJzIHx8IFtdO1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGlzdGVuZXJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzWyBqIF07XG4gICAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gIXR5cGUgfHwgbGlzdGVuZXIudHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIGNiTWF0Y2hlcztcblxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBsaXN0ZW5lciBpZiBpdCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZSggaiwgMSApO1xuICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBmb3IgbGlzdGVuZXJzXG4gICAgICAgICAgICB9IC8vIGZvciBhbGxcbiAgICAgICAgICB9IC8vIGlmIG1hdGNoXG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuXG4gICAgICB9IC8vIGZvciBldmVudHMgbWFwXG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIG9mZlxuXG4gIHRyaWdnZXI6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB0cmlnZ2VySW1wbCggZXZlbnRzLCBleHRyYVBhcmFtcywgZm5Ub1RyaWdnZXIgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSBpcy5zdHJpbmcoIGV2ZW50cyApO1xuICAgICAgdmFyIGV2ZW50c0lzT2JqZWN0ID0gaXMucGxhaW5PYmplY3QoIGV2ZW50cyApO1xuICAgICAgdmFyIGV2ZW50c0lzRXZlbnQgPSBpcy5ldmVudCggZXZlbnRzICk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gdGhpcy5fcHJpdmF0ZSB8fCB7fTtcbiAgICAgIHZhciBjeSA9IF9wLmN5IHx8ICggaXMuY29yZSggdGhpcyApID8gdGhpcyA6IG51bGwgKTtcbiAgICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeSA/IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSA6IGZhbHNlO1xuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBtYWtlIGEgcGxhaW4gZXZlbnQgb2JqZWN0IGZvciBlYWNoIGV2ZW50IG5hbWVcbiAgICAgICAgdmFyIGV2dHMgPSBldmVudHMuc3BsaXQoIC9cXHMrLyApO1xuICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1sgaSBdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyggZXZ0ICkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggZGVmaW5lLmV2ZW50LnJlZ2V4ICk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cbiAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZXZlbnRzLnB1c2goIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCBldmVudHNJc09iamVjdCApeyAvLyBwdXQgaW4gbGVuZ3RoIDEgYXJyYXlcbiAgICAgICAgdmFyIGV2ZW50QXJnT2JqID0gZXZlbnRzO1xuXG4gICAgICAgIGV2ZW50cyA9IFsgZXZlbnRBcmdPYmogXTtcbiAgICAgIH1cblxuICAgICAgaWYoIGV4dHJhUGFyYW1zICl7XG4gICAgICAgIGlmKCAhaXMuYXJyYXkoIGV4dHJhUGFyYW1zICkgKXsgLy8gbWFrZSBzdXJlIGV4dHJhIHBhcmFtcyBhcmUgaW4gYW4gYXJyYXkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgd2UndmUgZ290IG5vdGhpbmdcbiAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKysgKXsgLy8gdHJpZ2dlciBlYWNoIGV2ZW50IGluIG9yZGVyXG4gICAgICAgIHZhciBldnRPYmogPSBldmVudHNbIGkgXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaFxuICAgICAgICAgIHZhciB0cmlnZ2VyZXIgPSBhbGxbIGogXTtcbiAgICAgICAgICB2YXIgX3AgPSB0cmlnZ2VyZXIuX3ByaXZhdGUgPSB0cmlnZ2VyZXIuX3ByaXZhdGUgfHwge307XG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVySXNFbGVtZW50ID0gaXMuZWxlbWVudCggdHJpZ2dlcmVyICk7XG4gICAgICAgICAgdmFyIGJ1YmJsZVVwID0gdHJpZ2dlcmVySXNFbGVtZW50IHx8IHBhcmFtcy5sYXlvdXQ7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIGV2ZW50IGZvciB0aGlzIGVsZW1lbnQgZnJvbSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgdmFyIGV2dDtcblxuICAgICAgICAgIGlmKCBldmVudHNJc0V2ZW50ICl7IC8vIHRoZW4ganVzdCBnZXQgdGhlIG9iamVjdFxuICAgICAgICAgICAgZXZ0ID0gZXZ0T2JqO1xuXG4gICAgICAgICAgICBldnQudGFyZ2V0ID0gZXZ0LnRhcmdldCB8fCB0cmlnZ2VyZXI7XG4gICAgICAgICAgICBldnQuY3kgPSBldnQuY3kgfHwgY3k7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHdlIGhhdmUgdG8gbWFrZSBvbmVcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFdmVudCggZXZ0T2JqLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogdHJpZ2dlcmVyLFxuICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogZXZ0T2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGEgbGF5b3V0IHdhcyBzcGVjaWZpZWQsIHRoZW4gcHV0IGl0IGluIHRoZSB0eXBlZCBldmVudFxuICAgICAgICAgIGlmKCBldnRPYmoubGF5b3V0ICl7XG4gICAgICAgICAgICBldnQubGF5b3V0ID0gZXZ0T2JqLmxheW91dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0cmlnZ2VyZWQgYnkgbGF5b3V0LCBwdXQgaW4gZXZlbnRcbiAgICAgICAgICBpZiggcGFyYW1zLmxheW91dCApe1xuICAgICAgICAgICAgZXZ0LmxheW91dCA9IHRyaWdnZXJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICAgICAgaWYoIGV2dC5wb3NpdGlvbiApe1xuICAgICAgICAgICAgdmFyIHBvcyA9IGV2dC5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgICBldnQucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBmblRvVHJpZ2dlciApeyAvLyB0aGVuIG92ZXJyaWRlIHRoZSBsaXN0ZW5lcnMgbGlzdCB3aXRoIGp1c3QgdGhlIG9uZSB3ZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IFsge1xuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFjazogZm5Ub1RyaWdnZXJcbiAgICAgICAgICAgIH0gXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGxpc3RlbmVycy5sZW5ndGg7IGsrKyApeyAvLyBjaGVjayBlYWNoIGxpc3RlbmVyXG4gICAgICAgICAgICB2YXIgbGlzID0gbGlzdGVuZXJzWyBrIF07XG4gICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIWxpcy5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZXZ0Lm5hbWVzcGFjZSB8fCBsaXMubmFtZXNwYWNlID09PSBkZWZpbmUuZXZlbnQudW5pdmVyc2FsTmFtZXNwYWNlO1xuICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gbGlzLnR5cGUgPT09IGV2dC50eXBlO1xuICAgICAgICAgICAgdmFyIHRhcmdldE1hdGNoZXMgPSBsaXMuZGVsZWdhdGVkID8gKCB0cmlnZ2VyZXIgIT09IGV2dC50YXJnZXQgJiYgaXMuZWxlbWVudCggZXZ0LnRhcmdldCApICYmIGxpcy5zZWxPYmoubWF0Y2hlcyggZXZ0LnRhcmdldCApICkgOiAodHJ1ZSk7IC8vIHdlJ3JlIG5vdCBnb2luZyB0byB2YWxpZGF0ZSB0aGUgaGllcmFyY2h5OyB0aGF0J3MgdG9vIGV4cGVuc2l2ZVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiB0YXJnZXRNYXRjaGVzO1xuXG4gICAgICAgICAgICBpZiggbGlzdGVuZXJNYXRjaGVzICl7IC8vIHRoZW4gdHJpZ2dlciBpdFxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZ0IF07XG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCggZXh0cmFQYXJhbXMgKTsgLy8gYWRkIGV4dHJhIHBhcmFtcyB0byBhcmdzIGxpc3RcblxuICAgICAgICAgICAgICBpZiggbGlzLmRhdGEgKXsgLy8gYWRkIG9uIGRhdGEgcGx1Z2dlZCBpbnRvIGJpbmRpbmdcbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGxpcy5kYXRhO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvciBjbGVhciBpdCBpbiBjYXNlIHRoZSBldmVudCBvYmogaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZFNlbGZPblRyaWdnZXIgfHwgbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKCBrLCAxICk7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIGxpcy51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyICl7IC8vIHRoZW4gZGVsZXRlIHRoZSBsaXN0ZW5lciBmb3IgYWxsIGJpbmRlcnNcbiAgICAgICAgICAgICAgICB2YXIgYmluZGVycyA9IGxpcy5iaW5kZXJzO1xuICAgICAgICAgICAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgYmluZGVycy5sZW5ndGg7IGwrKyApe1xuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlciA9IGJpbmRlcnNbIGwgXTtcbiAgICAgICAgICAgICAgICAgIGlmKCAhYmluZGVyIHx8IGJpbmRlciA9PT0gdHJpZ2dlcmVyICl7IGNvbnRpbnVlOyB9IC8vIGFscmVhZHkgaGFuZGxlZCB0cmlnZ2VyZXIgb3Igd2UgY2FuJ3QgaGFuZGxlIGl0XG5cbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJMaXN0ZW5lcnMgPSBiaW5kZXIuX3ByaXZhdGUubGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgbSA9IDA7IG0gPCBiaW5kZXJMaXN0ZW5lcnMubGVuZ3RoOyBtKysgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVyID0gYmluZGVyTGlzdGVuZXJzWyBtIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIGJpbmRlckxpc3RlbmVyID09PSBsaXMgKXsgLy8gZGVsZXRlIGxpc3RlbmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgIGJpbmRlckxpc3RlbmVycy5zcGxpY2UoIG0sIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICBtLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBydW4gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbGlzLmRlbGVnYXRlZCA/IGV2dC50YXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSB8fCBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApe1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgaWYoIGJ1YmJsZVVwICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApeyAvLyB0aGVuIGJ1YmJsZSB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlciggZXZ0ICk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGJ1YmJsZSB1cCB0byB0aGUgY29yZVxuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBldnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBmb3IgZWFjaCBvZiBhbGxcbiAgICAgIH0gLy8gZm9yIGVhY2ggZXZlbnRcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gdHJpZ2dlclxuXG4gIGFuaW1hdGVkOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBhbmltYXRlZFxuXG4gIGNsZWFyUXVldWU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgZm5QYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsWyBpIF07XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSwgLy8gY2xlYXJRdWV1ZVxuXG4gIGRlbGF5OiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0gKTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbigge1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSApO1xuICAgIH07XG4gIH0sIC8vIGRlbGF5XG5cbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgICBwcm9wZXJ0aWVzID0gdXRpbC5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMgKTtcblxuICAgICAgaWYoIHByb3BlcnRpZXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNDAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2goIHByb3BlcnRpZXMuZHVyYXRpb24gKXtcbiAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BlcnRpZXNFbXB0eSA9IE9iamVjdC5rZXlzKCBwcm9wZXJ0aWVzICkubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiggcHJvcGVydGllc0VtcHR5ICl7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCBhbGxbMF0sIHByb3BlcnRpZXMgKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICB9XG5cbiAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdCggcHJvcGVydGllcy5zdHlsZSB8fCBwcm9wZXJ0aWVzLmNzcyApO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY3NzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICYmIGlzRWxlcyApe1xuICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvIHpvb20sXG4gICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC8gem9vbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICBpZiggcHJvcGVydGllcy5wYW5CeSAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcbiAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcbiAgICAgIGlmKCBjZW50ZXIgJiYgaXNDb3JlICl7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oIGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20gKTtcblxuICAgICAgICBpZiggY2VudGVyUGFuICl7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG4gICAgICBpZiggcHJvcGVydGllcy5maXQgJiYgaXNDb3JlICl7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoIGZpdC5lbGVzIHx8IGZpdC5ib3VuZGluZ0JveCwgZml0LnBhZGRpbmcgKTtcblxuICAgICAgICBpZiggZml0VnAgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCBhbGxbMF0sIHByb3BlcnRpZXMgKTtcbiAgICB9O1xuICB9LCAvLyBhbmltYXRlXG5cbiAgYW5pbWF0ZTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgaWYoIHBhcmFtcyApe1xuICAgICAgICBwcm9wZXJ0aWVzID0gdXRpbC5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMgKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbIGkgXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcblxuICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbiggcHJvcGVydGllcywgKHF1ZXVlID8geyBxdWV1ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKSApO1xuXG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH07XG4gIH0sIC8vIGFuaW1hdGVcblxuICBzdG9wOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoIGNsZWFyUXVldWUsIGp1bXBUb0VuZCApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsWyBpIF07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgYW5pID0gYW5pc1sgaiBdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmKCBjbGVhclF1ZXVlICl7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoIHtcbiAgICAgICAgZWxlczogdGhpcyxcbiAgICAgICAgdHlwZTogJ2RyYXcnXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0gLy8gc3RvcFxuXG59OyAvLyBkZWZpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKXtcbiAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBFdmVudCkgKXtcbiAgICByZXR1cm4gbmV3IEV2ZW50KCBzcmMsIHByb3BzICk7XG4gIH1cblxuICAvLyBFdmVudCBvYmplY3RcbiAgaWYoIHNyYyAmJiBzcmMudHlwZSApe1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoIHNyYy5kZWZhdWx0UHJldmVudGVkICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cbiAgLy8gRXZlbnQgdHlwZVxuICB9IGVsc2Uge1xuICAgIHRoaXMudHlwZSA9IHNyYztcbiAgfVxuXG4gIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gIGlmKCBwcm9wcyApe1xuICAgIC8vIHV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPT0gdW5kZWZpbmVkID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgdGhpcy50YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBwcm9wcy5tZXNzYWdlO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKXtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCl7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICdldmVudCc7XG4gIH0sXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYoICFlICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiggZS5wcmV2ZW50RGVmYXVsdCApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiggIWUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiggZS5zdG9wUHJvcGFnYXRpb24gKXtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKXtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4vZGVmaW5lJyApO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCAnLi9jb2xsZWN0aW9uJyApO1xudmFyIENvcmUgPSByZXF1aXJlKCAnLi9jb3JlJyApO1xudmFyIGluY0V4dHMgPSByZXF1aXJlKCAnLi9leHRlbnNpb25zJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG5cbi8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxudmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuLy8gcmVnaXN0ZXJlZCBtb2R1bGVzIGZvciBleHRlbnNpb25zLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBtb2R1bGVzID0ge307XG5cbmZ1bmN0aW9uIHNldEV4dGVuc2lvbiggdHlwZSwgbmFtZSwgcmVnaXN0cmFudCApe1xuXG4gIHZhciBleHQgPSByZWdpc3RyYW50O1xuXG4gIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyApO1xuICB9O1xuXG4gIGlmKCB0eXBlID09PSAnY29yZScgKXtcbiAgICBpZiggQ29yZS5wcm90b3R5cGVbIG5hbWUgXSApe1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKCBuYW1lICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvcmUucHJvdG90eXBlWyBuYW1lIF0gPSByZWdpc3RyYW50O1xuICAgIH1cblxuICB9IGVsc2UgaWYoIHR5cGUgPT09ICdjb2xsZWN0aW9uJyApe1xuICAgIGlmKCBDb2xsZWN0aW9uLnByb3RvdHlwZVsgbmFtZSBdICl7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIoIG5hbWUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbIG5hbWUgXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiggdHlwZSA9PT0gJ2xheW91dCcgKXtcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG5cbiAgICB2YXIgTGF5b3V0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmKCAhaXMucGxhaW5PYmplY3QoIHRoaXMuX3ByaXZhdGUgKSApe1xuICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIHJlZ2lzdHJhbnQucHJvdG90eXBlICk7XG5cbiAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1sgaSBdO1xuXG4gICAgICBsYXlvdXRQcm90b1sgZm5OYW1lIF0gPSBsYXlvdXRQcm90b1sgZm5OYW1lIF0gfHwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG4gICAgfVxuXG4gICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgIGlmKCBsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICBsYXlvdXRQcm90by5ydW4gPSBmdW5jdGlvbigpeyB0aGlzLnN0YXJ0KCk7IHJldHVybiB0aGlzOyB9O1xuICAgIH0gZWxzZSBpZiggIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1biApe1xuICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbigpeyB0aGlzLnJ1bigpOyByZXR1cm4gdGhpczsgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVnU3RvcCA9IHJlZ2lzdHJhbnQucHJvdG90eXBlLnN0b3A7XG4gICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYoIG9wdHMgJiYgb3B0cy5hbmltYXRlICl7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgIGlmKCBhbmlzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbmlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBhbmlzWyBpIF0uc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggcmVnU3RvcCApe1xuICAgICAgICByZWdTdG9wLmNhbGwoIHRoaXMgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlciggJ2xheW91dHN0b3AnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBpZiggIWxheW91dFByb3RvLmRlc3Ryb3kgKXtcbiAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGF5b3V0UHJvdG8ub24gPSBkZWZpbmUub24oIHsgbGF5b3V0OiB0cnVlIH0gKTtcbiAgICBsYXlvdXRQcm90by5vbmUgPSBkZWZpbmUub24oIHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0gKTtcbiAgICBsYXlvdXRQcm90by5vbmNlID0gZGVmaW5lLm9uKCB7IGxheW91dDogdHJ1ZSwgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9ICk7XG4gICAgbGF5b3V0UHJvdG8ub2ZmID0gZGVmaW5lLm9mZiggeyBsYXlvdXQ6IHRydWUgfSApO1xuICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSBkZWZpbmUudHJpZ2dlciggeyBsYXlvdXQ6IHRydWUgfSApO1xuXG4gICAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBsYXlvdXRQcm90byApO1xuXG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG5cbiAgfSBlbHNlIGlmKCB0eXBlID09PSAncmVuZGVyZXInICYmIG5hbWUgIT09ICdudWxsJyAmJiBuYW1lICE9PSAnYmFzZScgKXtcbiAgICAvLyB1c2VyIHJlZ2lzdGVyZWQgcmVuZGVyZXJzIGluaGVyaXQgZnJvbSBiYXNlXG5cbiAgICB2YXIgQmFzZVJlbmRlcmVyID0gZ2V0RXh0ZW5zaW9uKCAncmVuZGVyZXInLCAnYmFzZScgKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbigpe1xuICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgIFJlZ2lzdHJhbnRSZW5kZXJlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIGZvciggdmFyIHBOYW1lIGluIGJQcm90byApe1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bIHBOYW1lIF07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvWyBwTmFtZSBdICE9IG51bGw7XG5cbiAgICAgIGlmKCBleGlzdHNJblIgKXtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKCBwTmFtZSApO1xuICAgICAgfVxuXG4gICAgICBwcm90b1sgcE5hbWUgXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG5cbiAgICBmb3IoIHZhciBwTmFtZSBpbiByUHJvdG8gKXtcbiAgICAgIHByb3RvWyBwTmFtZSBdID0gclByb3RvWyBwTmFtZSBdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiggbmFtZSApe1xuICAgICAgcHJvdG9bIG5hbWUgXSA9IHByb3RvWyBuYW1lIF0gfHwgZnVuY3Rpb24oKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnICk7XG4gICAgICB9O1xuICAgIH0gKTtcblxuICAgIGV4dCA9IFJlbmRlcmVyO1xuXG4gIH1cblxuICByZXR1cm4gdXRpbC5zZXRNYXAoIHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF0sXG4gICAgdmFsdWU6IGV4dFxuICB9ICk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbiggdHlwZSwgbmFtZSApe1xuICByZXR1cm4gdXRpbC5nZXRNYXAoIHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgfSApO1xufVxuXG5mdW5jdGlvbiBzZXRNb2R1bGUoIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQgKXtcbiAgcmV0dXJuIHV0aWwuc2V0TWFwKCB7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSBdLFxuICAgIHZhbHVlOiByZWdpc3RyYW50XG4gIH0gKTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlKCB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lICl7XG4gIHJldHVybiB1dGlsLmdldE1hcCgge1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXVxuICB9ICk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKXtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICl7XG4gICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gNCApe1xuICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDUgKXtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIHV0aWwuZXJyb3IoICdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4JyApO1xuICB9XG5cbn07XG5cbi8vIGFsbG93cyBhIGNvcmUgaW5zdGFuY2UgdG8gYWNjZXNzIGV4dGVuc2lvbnMgaW50ZXJuYWxseVxuQ29yZS5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuXG4vLyBpbmNsdWRlZCBleHRlbnNpb25zXG5pbmNFeHRzLmZvckVhY2goIGZ1bmN0aW9uKCBncm91cCApe1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBleHQgKXtcbiAgICBzZXRFeHRlbnNpb24oIGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCApO1xuICB9ICk7XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5zaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHR5cGU6ICdsYXlvdXQnLFxuICAgIGV4dGVuc2lvbnM6IHJlcXVpcmUoICcuL2xheW91dCcgKVxuICB9LFxuXG4gIHtcbiAgICB0eXBlOiAncmVuZGVyZXInLFxuICAgIGV4dGVuc2lvbnM6IHJlcXVpcmUoICcuL3JlbmRlcmVyJyApXG4gIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5CcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgcm9vdHM7XG4gIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBvcHRpb25zLnJvb3RzICkgKXtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiggaXMuYXJyYXkoIG9wdGlvbnMucm9vdHMgKSApe1xuICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbIGkgXTtcbiAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgIHJvb3RzQXJyYXkucHVzaCggZWxlICk7XG4gICAgfVxuXG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCByb290c0FycmF5ICk7XG4gIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3RzICkgKXtcbiAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICB9IGVsc2Uge1xuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICl7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgdmFyIGN1cnJDb21wID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIGVsZXMuYmZzKCB7XG4gICAgICAgICAgcm9vdHM6IHVuaGFuZGxlZE5vZGVzWzBdLFxuICAgICAgICAgIHZpc2l0OiBmdW5jdGlvbiggbm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoICl7XG4gICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0gKTtcblxuICAgICAgICB1bmhhbmRsZWROb2RlcyA9IHVuaGFuZGxlZE5vZGVzLm5vdCggY3VyckNvbXAgKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKCBjdXJyQ29tcCApO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbIGkgXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gZWxlLmRlZ3JlZSggZmFsc2UgKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9ICk7XG5cbiAgICAgICAgcm9vdHMgPSByb290cy5hZGQoIGNvbXBSb290cyApO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cblxuICB2YXIgZGVwdGhzID0gW107XG4gIHZhciBmb3VuZEJ5QmZzID0ge307XG4gIHZhciBpZDJkZXB0aCA9IHt9O1xuICB2YXIgcHJldk5vZGUgPSB7fTtcbiAgdmFyIHByZXZFZGdlID0ge307XG4gIHZhciBzdWNjZXNzb3JzID0ge307XG5cbiAgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuICBncmFwaC5iZnMoIHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uKCBub2RlLCBlZGdlLCBwTm9kZSwgaSwgZGVwdGggKXtcbiAgICAgIHZhciBlbGUgPSBub2RlWzBdO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgIGlmKCAhZGVwdGhzWyBkZXB0aCBdICl7XG4gICAgICAgIGRlcHRoc1sgZGVwdGggXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbIGRlcHRoIF0ucHVzaCggZWxlICk7XG4gICAgICBmb3VuZEJ5QmZzWyBpZCBdID0gdHJ1ZTtcbiAgICAgIGlkMmRlcHRoWyBpZCBdID0gZGVwdGg7XG4gICAgICBwcmV2Tm9kZVsgaWQgXSA9IHBOb2RlO1xuICAgICAgcHJldkVkZ2VbIGlkIF0gPSBlZGdlO1xuXG4gICAgICBpZiggcE5vZGUgKXtcbiAgICAgICAgdmFyIHByZXZJZCA9IHBOb2RlLmlkKCk7XG4gICAgICAgIHZhciBzdWNjID0gc3VjY2Vzc29yc1sgcHJldklkIF0gPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSB8fCBbXTtcblxuICAgICAgICBzdWNjLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gKTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1sgaSBdO1xuXG4gICAgaWYoIGZvdW5kQnlCZnNbIGVsZS5pZCgpIF0gKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBlbGUgKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIGEgZGVwdGggZnJvbSB0aGVpciBuZWlnaGJvcmhvb2RcbiAgdmFyIG1heENoZWNrcyA9IG9ycGhhbk5vZGVzLmxlbmd0aCAqIDM7XG4gIHZhciBjaGVja3MgPSAwO1xuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICYmIGNoZWNrcyA8IG1heENoZWNrcyApe1xuICAgIHZhciBub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICB2YXIgbmVpZ2hib3JzID0gbm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpO1xuICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIG5laWdoYm9yc1sgaSBdLmlkKCkgXTtcblxuICAgICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZGVwdGhzWyBkZXB0aCBdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhYXNzaWduZWREZXB0aCApe1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgIH1cblxuICAgIGNoZWNrcysrO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICl7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgIC8vICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiggIWFzc2lnbmVkRGVwdGggKXsgLy8gd29yc3QgY2FzZSBpZiB0aGUgZ3JhcGggcmVhbGx5IGlzbid0IHRyZWUgZnJpZW5kbHksIHRoZW4ganVzdCBkdW1wIGl0IGluIDBcbiAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIGRlcHRocy5wdXNoKCBbXSApO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbMF0ucHVzaCggbm9kZSApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcbiAgdmFyIGFzc2lnbkRlcHRoc1RvRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGVzID0gZGVwdGhzWyBpIF07XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaiBdO1xuXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBpbmRleDogalxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG5cblxuICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5kYXRhKCAndGFyZ2V0JyApID09PSBub2RlLmlkKCk7XG4gICAgfSApO1xuICAgIHZhciB0aGlzSW5mbyA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgdmFyIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSAwO1xuICAgIHZhciBoaWdoZXN0T3RoZXI7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1sgaSBdO1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgb3RoZXJJbmZvID0gb3RoZXJOb2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICBpZiggdGhpc0luZm8uZGVwdGggPD0gb3RoZXJJbmZvLmRlcHRoICYmIGhpZ2hlc3REZXB0aE9mT3RoZXIgPCBvdGhlckluZm8uZGVwdGggKXtcbiAgICAgICAgaGlnaGVzdERlcHRoT2ZPdGhlciA9IG90aGVySW5mby5kZXB0aDtcbiAgICAgICAgaGlnaGVzdE90aGVyID0gb3RoZXJOb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoaWdoZXN0T3RoZXI7XG4gIH07XG5cbiAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gIGZvciggdmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKyApe1xuXG4gICAgdmFyIG5EZXB0aHMgPSBkZXB0aHMubGVuZ3RoO1xuICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuRGVwdGhzOyBpKysgKXtcbiAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1sgaSBdO1xuXG4gICAgICB2YXIgbkRlcHRoID0gZGVwdGgubGVuZ3RoO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBuRGVwdGg7IGorKyApe1xuICAgICAgICB2YXIgZWxlID0gZGVwdGhbIGogXTtcbiAgICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICAgIHZhciBpbnRFbGUgPSBpbnRlcnNlY3RzRGVwdGgoIGVsZSApO1xuXG4gICAgICAgIGlmKCBpbnRFbGUgKXtcbiAgICAgICAgICBpbmZvLmludEVsZSA9IGludEVsZTtcbiAgICAgICAgICBlbGVzVG9Nb3ZlLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9Nb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvTW92ZVsgaSBdO1xuICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgaW50RWxlID0gaW5mby5pbnRFbGU7XG4gICAgICB2YXIgaW50SW5mbyA9IGludEVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgZGVwdGhzWyBpbmZvLmRlcHRoIF0uc3BsaWNlKCBpbmZvLmluZGV4LCAxICk7IC8vIHJlbW92ZSBmcm9tIG9sZCBkZXB0aCAmIGluZGV4XG5cbiAgICAgIC8vIGFkZCB0byBlbmQgb2YgbmV3IGRlcHRoXG4gICAgICB2YXIgbmV3RGVwdGggPSBpbnRJbmZvLmRlcHRoICsgMTtcbiAgICAgIHdoaWxlKCBuZXdEZXB0aCA+IGRlcHRocy5sZW5ndGggLSAxICl7XG4gICAgICAgIGRlcHRocy5wdXNoKCBbXSApO1xuICAgICAgfVxuICAgICAgZGVwdGhzWyBuZXdEZXB0aCBdLnB1c2goIGVsZSApO1xuXG4gICAgICBpbmZvLmRlcHRoID0gbmV3RGVwdGg7XG4gICAgICBpbmZvLmluZGV4ID0gZGVwdGhzWyBuZXdEZXB0aCBdLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG4gIH1cblxuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG4gPSBub2Rlc1sgaSBdO1xuICAgICAgdmFyIG5iYiA9IG4uYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICB2YXIgaCA9IG5iYi5oO1xuXG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KCBtaW5EaXN0YW5jZSwgdywgaCApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG4gIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgaWYoIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXSApe1xuICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXTtcbiAgICB9XG5cbiAgICB2YXIgZWxlRGVwdGggPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3QuZGVwdGg7XG4gICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLm5vdCggJzpwYXJlbnQnICkuaW50ZXJzZWN0aW9uKG5vZGVzKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1sgaSBdO1xuICAgICAgdmFyIGJmID0gbmVpZ2hib3IuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgIHZhciBkZXB0aCA9IGJmLmRlcHRoO1xuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1sgZGVwdGggXS5sZW5ndGg7XG5cbiAgICAgIGlmKCBlbGVEZXB0aCA+IGRlcHRoIHx8IGVsZURlcHRoID09PSAwICl7IC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgc2FtcGxlcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNhbXBsZXMgPSBNYXRoLm1heCggMSwgc2FtcGxlcyApO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgIGlmKCBzYW1wbGVzID09PSAwICl7IC8vIHNvIGxvbmUgbm9kZXMgaGF2ZSBhIFwiZG9uJ3QgY2FyZVwiIHN0YXRlIGluIHNvcnRpbmdcbiAgICAgIHBlcmNlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuXG4gIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiggYSwgYiApe1xuICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBhICk7XG4gICAgdmFyIGJwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoIGIgKTtcblxuICAgIHJldHVybiBhcGN0IC0gYnBjdDtcbiAgfTtcblxuICBmb3IoIHZhciB0aW1lcyA9IDA7IHRpbWVzIDwgMzsgdGltZXMrKyApeyAvLyBkbyBpdCBhIGZldyB0aW1lcyBiL2MgdGhlIGRlcHRocyBhcmUgZHluYW1pYyBhbmQgd2Ugd2FudCBhIG1vcmUgc3RhYmxlIHJlc3VsdFxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGRlcHRoc1sgaSBdID0gZGVwdGhzWyBpIF0uc29ydCggc29ydEZuICk7XG4gICAgfVxuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpOyAvLyBhbmQgdXBkYXRlXG5cbiAgfVxuXG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoIGRlcHRoc1sgaSBdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSApO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLngxICsgYmIuaCAvIDJcbiAgfTtcblxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiggZWxlLCBpc0JvdHRvbURlcHRoICl7XG4gICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgdmFyIGRlcHRoID0gaW5mby5kZXB0aDtcbiAgICB2YXIgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbIGRlcHRoIF0ubGVuZ3RoO1xuXG4gICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KCBiYi53IC8gKGRlcHRoU2l6ZSArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heCggYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgdmFyIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5taW4oIGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoICk7XG4gICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heCggcmFkaXVzU3RlcFNpemUsIG1pbkRpc3RhbmNlICk7XG5cbiAgICBpZiggIW9wdGlvbnMuY2lyY2xlICl7XG5cbiAgICAgIHZhciBlcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkgLyAyKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgIH07XG5cbiAgICAgIGlmKCBpc0JvdHRvbURlcHRoICl7XG4gICAgICAgIHJldHVybiBlcG9zO1xuICAgICAgfVxuXG4gICAgICAvLyB2YXIgc3VjY3MgPSBzdWNjZXNzb3JzWyBlbGUuaWQoKSBdO1xuICAgICAgLy8gaWYoIHN1Y2NzICl7XG4gICAgICAvLyAgIGVwb3MueCA9IDA7XG4gICAgICAvL1xuICAgICAgLy8gICBmb3IoIHZhciBpID0gMCA7IGkgPCBzdWNjcy5sZW5ndGg7IGkrKyApe1xuICAgICAgLy8gICAgIHZhciBzcG9zID0gcG9zWyBzdWNjc1tpXS5pZCgpIF07XG4gICAgICAvL1xuICAgICAgLy8gICAgIGVwb3MueCArPSBzcG9zLng7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vXG4gICAgICAvLyAgIGVwb3MueCAvPSBzdWNjcy5sZW5ndGg7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICAvL2RlYnVnZ2VyO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gZXBvcztcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggb3B0aW9ucy5jaXJjbGUgKXtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c1N0ZXBTaXplICogZGVwdGggKyByYWRpdXNTdGVwU2l6ZSAtIChkZXB0aHMubGVuZ3RoID4gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoIDw9IDMgPyByYWRpdXNTdGVwU2l6ZSAvIDIgOiAwKTtcbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbIGRlcHRoIF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgICAgaWYoIGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhIClcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkgLyAyKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8vIGdldCBwb3NpdGlvbnMgaW4gcmV2ZXJzZSBkZXB0aCBvcmRlclxuICB2YXIgcG9zID0ge307XG4gIGZvciggdmFyIGkgPSBkZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICB2YXIgZGVwdGggPSBkZXB0aHNbIGkgXTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZGVwdGgubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBub2RlID0gZGVwdGhbIGogXTtcblxuICAgICAgcG9zWyBub2RlLmlkKCkgXSA9IGdldFBvc2l0aW9uKCBub2RlLCBpID09PSBkZXB0aHMubGVuZ3RoIC0gMSApO1xuICAgIH1cbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZnVuY3Rpb24oIG5vZGUgKXtcbiAgICByZXR1cm4gcG9zWyBub2RlLmlkKCkgXTtcbiAgfSApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcmVhZHRoRmlyc3RMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHJhZGl1czogdW5kZWZpbmVkLCAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLCAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIENpcmNsZUxheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cbkNpcmNsZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG5cbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCggJzpwYXJlbnQnICk7XG5cbiAgaWYoIG9wdGlvbnMuc29ydCApe1xuICAgIG5vZGVzID0gbm9kZXMuc29ydCggb3B0aW9ucy5zb3J0ICk7XG4gIH1cblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcblxuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcblxuICB2YXIgZFRoZXRhID0gc3dlZXAgLyAoIE1hdGgubWF4KCAxLCBub2Rlcy5sZW5ndGggLSAxICkgKTtcbiAgdmFyIHI7XG5cbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBuID0gbm9kZXNbIGkgXTtcbiAgICB2YXIgbmJiID0gbi5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcblxuICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgoIG1pbkRpc3RhbmNlLCB3LCBoICk7XG4gIH1cblxuICBpZiggaXMubnVtYmVyKCBvcHRpb25zLnJhZGl1cyApICl7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYoIG5vZGVzLmxlbmd0aCA8PSAxICl7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKCBiYi5oLCBiYi53ICkgLyAyIC0gbWluRGlzdGFuY2U7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICBpZiggbm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICB2YXIgZGNvcyA9IE1hdGguY29zKCBkVGhldGEgKSAtIE1hdGguY29zKCAwICk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbiggZFRoZXRhICkgLSBNYXRoLnNpbiggMCApO1xuICAgIHZhciByTWluID0gTWF0aC5zcXJ0KCBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKCBkY29zICogZGNvcyArIGRzaW4gKiBkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICB9XG5cbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBlbGUsIGkgKXtcbiAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyBpICogZFRoZXRhICogKCBjbG9ja3dpc2UgPyAxIDogLTEgKTtcblxuICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyggdGhldGEgKTtcbiAgICB2YXIgcnkgPSByICogTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgfTtcblxuICAgIHJldHVybiBwb3M7XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSwgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLCAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIGhlaWdodDogdW5kZWZpbmVkLCAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLCAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cCAgXG4gIGNvbmNlbnRyaWM6IGZ1bmN0aW9uKCBub2RlICl7IC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gIH0sXG4gIGxldmVsV2lkdGg6IGZ1bmN0aW9uKCBub2RlcyApeyAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICB9LFxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBDb25jZW50cmljTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuQ29uY2VudHJpY0xheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcblxuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCggJzpwYXJlbnQnICk7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG5cbiAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG4gIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZTtcbiAgdmFyIG1heE5vZGVTaXplID0gMDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKCBub2RlICk7XG4gICAgbm9kZVZhbHVlcy5wdXNoKCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSApO1xuXG4gICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9XG5cbiAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgbm9kZXMudXBkYXRlU3R5bGUoKTtcblxuICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgIHZhciBuYmIgPSBub2RlLmJvdW5kaW5nQm94KCk7XG5cbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KCBtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oICk7XG4gIH1cblxuICAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG4gIG5vZGVWYWx1ZXMuc29ydCggZnVuY3Rpb24oIGEsIGIgKXtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0gKTtcblxuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aCggbm9kZXMgKTtcblxuICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICB2YXIgbGV2ZWxzID0gWyBbXSBdO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1sgaSBdO1xuXG4gICAgaWYoIGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwICl7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKCBjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUgKTtcblxuICAgICAgaWYoIGRpZmYgPj0gbGV2ZWxXaWR0aCApe1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goIGN1cnJlbnRMZXZlbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKCB2YWwgKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gIGlmKCAhb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gKCBNYXRoLm1pbiggYmIudywgYmIuaCApIC8gMiAtIG1pbkRpc3QgKTtcbiAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKCBsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwICk7XG5cbiAgICBtaW5EaXN0ID0gTWF0aC5taW4oIG1pbkRpc3QsIHJTdGVwICk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBtZXRyaWNzIGZvciBlYWNoIGxldmVsXG4gIHZhciByID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcbiAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbGV2ZWwubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhID0gc3dlZXAgLyAoIE1hdGgubWF4KCAxLCBsZXZlbC5sZW5ndGggLSAxICkgKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYoIGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyggZFRoZXRhICkgLSBNYXRoLmNvcyggMCApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbiggZFRoZXRhICkgLSBNYXRoLnNpbiggMCApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3QgKiBtaW5EaXN0IC8gKCBkY29zICogZGNvcyArIGRzaW4gKiBkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgICB9XG5cbiAgICBsZXZlbC5yID0gcjtcblxuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmKCBvcHRpb25zLmVxdWlkaXN0YW50ICl7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuICAgICAgdmFyIHJEZWx0YSA9IGxldmVsLnIgLSByO1xuXG4gICAgICByRGVsdGFNYXggPSBNYXRoLm1heCggckRlbHRhTWF4LCByRGVsdGEgKTtcbiAgICB9XG5cbiAgICByID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgIHIgPSBsZXZlbC5yO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC5yID0gcjtcblxuICAgICAgciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YTtcbiAgICB2YXIgciA9IGxldmVsLnI7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgdmFsID0gbGV2ZWxbIGogXTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogZFRoZXRhICogajtcblxuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgciAqIE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICB5OiBjZW50ZXIueSArIHIgKiBNYXRoLnNpbiggdGhldGEgKVxuICAgICAgfTtcblxuICAgICAgcG9zWyB2YWwubm9kZS5pZCgpIF0gPSBwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgIHJldHVybiBwb3NbIGlkIF07XG4gIH0gKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uY2VudHJpY0xheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcblRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5odHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZ2VyYXJkb2h1Y2svXG5cbkJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZTpcbmh0dHA6Ly9kbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xNDk4MDQ3XG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi4vLi4vcHJvbWlzZScpO1xuXG52YXIgREVCVUc7XG5cbi8qKlxuICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIGRlZmF1bHRzID0ge1xuICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICByZWFkeTogZnVuY3Rpb24oKXt9LFxuXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24oKXt9LFxuXG4gIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgYW5pbWF0ZTogdHJ1ZSxcblxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuICAvLyAocHJldmVudHMgZmxhc2hpbmcgb24gZmFzdCBydW5zKVxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDI1MCxcblxuICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlXG4gIC8vICgwIC0+IG9ubHkgdXBkYXRlZCBvbiB0aGUgZW5kKVxuICByZWZyZXNoOiAyMCxcblxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG5cbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMzAsXG5cbiAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG5cbiAgLy8gUmFuZG9taXplIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgKHRydWUpIG9yIHVzZSBleGlzdGluZyBwb3NpdGlvbnMgKGZhbHNlKVxuICByYW5kb21pemU6IGZhbHNlLFxuXG4gIC8vIEV4dHJhIHNwYWNpbmcgYmV0d2VlbiBjb21wb25lbnRzIGluIG5vbi1jb21wb3VuZCBncmFwaHNcbiAgY29tcG9uZW50U3BhY2luZzogMTAwLFxuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIDQwMDAwMDsgfSxcblxuICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZU92ZXJsYXA6IDEwLFxuXG4gIC8vIE5vZGUgb3ZlcmxhcCBpbmNyZWFzZSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwQXV0b0ZhY3RvcjogMixcblxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTA7IH0sXG5cbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTAwOyB9LFxuXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogNSxcblxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogODAsXG5cbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDEwMDAsXG5cbiAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgaW5pdGlhbFRlbXA6IDIwMCxcblxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk1LFxuXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjAsXG5cbiAgLy8gUGFzcyBhIHJlZmVyZW5jZSB0byB3ZWF2ZXIgdG8gdXNlIHRocmVhZHMgZm9yIGNhbGN1bGF0aW9uc1xuICB3ZWF2ZXI6IGZhbHNlXG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIENvc2VMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xuXG4gIHRoaXMub3B0aW9ucy5sYXlvdXQgPSB0aGlzO1xufVxuXG4vKipcbiAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ICAgICAgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ICA9IHRoaXM7XG4gIHZhciB0aHJlYWQgID0gdGhpcy50aHJlYWQ7XG4gIHZhciBUaHJlYWQgID0gb3B0aW9ucy53ZWF2ZXIgPyBvcHRpb25zLndlYXZlci5UaHJlYWQgOiBudWxsO1xuXG4gIHZhciBmYWxzZVRocmVhZCA9IHsgLy8gdXNlIGZhbHNlIHRocmVhZCBhcyBwb2x5ZmlsbFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgb246IGZ1bmN0aW9uKGUsIGNiKXtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goeyBldmVudDogZSwgY2FsbGJhY2s6IGNiIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGUpe1xuICAgICAgaWYoIGlzLnN0cmluZyhlKSApe1xuICAgICAgICBlID0geyB0eXBlOiBlIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVzRXZlbnQgPSBmdW5jdGlvbiggbCApeyByZXR1cm4gbC5ldmVudCA9PT0gZS50eXBlOyB9O1xuICAgICAgdmFyIHRyaWdnZXIgPSBmdW5jdGlvbiggbCApeyBsLmNhbGxiYWNrKGUpOyB9O1xuXG4gICAgICB0aGlzLmxpc3RlbmVycy5maWx0ZXIoIG1hdGNoZXNFdmVudCApLmZvckVhY2goIHRyaWdnZXIgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYXNzOiBmdW5jdGlvbiggZGF0YSApe1xuICAgICAgdGhpcy5wYXNzID0gZGF0YTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uKCBjYiApe1xuICAgICAgdmFyIHBhc3MgPSB0aGlzLnBhc3M7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZSApe1xuICAgICAgICByZXNvbHZlKCBjYiggcGFzcyApICk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYnJvYWRjYXN0KCBtZXNzYWdlICl7IC8vIGZvciBmYWxzZSB0aHJlYWRcbiAgICB2YXIgZSA9IHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtZXNzYWdlIH07XG5cbiAgICBmYWxzZVRocmVhZC50cmlnZ2VyKCBlICk7XG4gIH1cblxuICBpZiggIXRocmVhZCB8fCB0aHJlYWQuc3RvcHBlZCgpICl7XG4gICAgdGhyZWFkID0gdGhpcy50aHJlYWQgPSBUaHJlYWQgPyBuZXcgVGhyZWFkKCkgOiBmYWxzZVRocmVhZDtcbiAgfVxuXG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICBpZiggdHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1ZyApe1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oIGN5LCBsYXlvdXQsIG9wdGlvbnMgKTtcblxuICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gIGlmKCBERUJVRyApe1xuICAgIHByaW50TGF5b3V0SW5mbyggbGF5b3V0SW5mbyApO1xuICB9XG5cbiAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICByYW5kb21pemVQb3NpdGlvbnMoIGxheW91dEluZm8sIGN5ICk7XG4gIH1cblxuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiggck9wdHMgKXtcbiAgICByT3B0cyA9IHJPcHRzIHx8IHt9O1xuXG4gICAgaWYoIHJlZnJlc2hSZXF1ZXN0ZWQgJiYgIXJPcHRzLm5leHQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggIXJPcHRzLmZvcmNlICYmIERhdGUubm93KCkgLSBzdGFydFRpbWUgPCBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgdXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uKCl7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyApO1xuXG4gICAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYoIHRydWUgPT09IG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYoIHJPcHRzLm5leHQgKXsgck9wdHMubmV4dCgpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhyZWFkLm9uKCAnbWVzc2FnZScsIGZ1bmN0aW9uKCBlICl7XG4gICAgdmFyIGxheW91dE5vZGVzID0gZS5tZXNzYWdlO1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dE5vZGVzO1xuICAgIHJlZnJlc2goKTtcbiAgfSApO1xuXG4gIHRocmVhZC5wYXNzKCB7XG4gICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsXG4gICAgICByZWZyZXNoOiBvcHRpb25zLnJlZnJlc2gsXG4gICAgICBjb21wb25lbnRTcGFjaW5nOiBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmcsXG4gICAgICBub2RlT3ZlcmxhcDogb3B0aW9ucy5ub2RlT3ZlcmxhcCxcbiAgICAgIG5lc3RpbmdGYWN0b3I6IG9wdGlvbnMubmVzdGluZ0ZhY3RvcixcbiAgICAgIGdyYXZpdHk6IG9wdGlvbnMuZ3Jhdml0eSxcbiAgICAgIG51bUl0ZXI6IG9wdGlvbnMubnVtSXRlcixcbiAgICAgIGluaXRpYWxUZW1wOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgICAgY29vbGluZ0ZhY3Rvcjogb3B0aW9ucy5jb29saW5nRmFjdG9yLFxuICAgICAgbWluVGVtcDogb3B0aW9ucy5taW5UZW1wXG4gICAgfVxuICB9ICkucnVuKCBmdW5jdGlvbiggcGFzcyApe1xuICAgIHZhciBsYXlvdXRJbmZvID0gcGFzcy5sYXlvdXRJbmZvO1xuICAgIHZhciBvcHRpb25zID0gcGFzcy5vcHRpb25zO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRGb3JjZSA9IHt9O1xuICAgIHZhciB0ID0gMjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy9jb25zb2xlLmxvZyhsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldLmlkKTtcbiAgICAgIGN1cnJlbnRGb3JjZVtsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldLmlkXSA9IHt9O1xuICAgICAgZm9yKHZhciBqID0gaSArIDE7IGogPCBsYXlvdXRJbmZvLmxheW91dE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGN1cnJlbnRGb3JjZVtsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldLmlkXVtsYXlvdXRJbmZvLmxheW91dE5vZGVzW2pdLmlkXSA9IG9wdGlvbnMubm9kZU92ZXJsYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICAgICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zLCBzdGVwICl7XG4gICAgICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAgICAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgICAgIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICAgICAgY2FsY3VsYXRlTm9kZUZvcmNlcyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgICAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gICAgICBjYWxjdWxhdGVFZGdlRm9yY2VzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgICAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcbiAgICAgIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICAgIC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgICAgIHByb3BhZ2F0ZUZvcmNlcyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICAgICAgdXBkYXRlUG9zaXRpb25zKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggb2YgdGhlIGdyYXBocyBpbiBncmFwaFNldFxuICAgICAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gICAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKyApe1xuICAgICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0WyBpIF07XG4gICAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gTm93IGdldCBhbGwgdGhlIHBhaXJzIG9mIG5vZGVzXG4gICAgICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgICAgdmFyIG5vZGUxID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGdyYXBoWyBqIF0gXSBdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKyApe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGdyYXBoWyBrIF0gXSBdO1xuXG4gICAgICAgICAgICBub2RlUmVwdWxzaW9uKCBub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJhbmRvbURpc3RhbmNlID0gZnVuY3Rpb24oIG1heCApe1xuICAgICAgcmV0dXJuIC1tYXggKyAyICogbWF4ICogTWF0aC5yYW5kb20oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gICAgICovXG4gICAgdmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbiggbm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICAvLyB2YXIgcyA9IFwiTm9kZSByZXB1bHNpb24uIE5vZGUxOiBcIiArIG5vZGUxLmlkICsgXCIgTm9kZTI6IFwiICsgbm9kZTIuaWQ7XG5cbiAgICAgIHZhciBjbXB0SWQxID0gbm9kZTEuY21wdElkO1xuICAgICAgdmFyIGNtcHRJZDIgPSBub2RlMi5jbXB0SWQ7XG5cbiAgICAgIGlmKCBjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQgKXsgcmV0dXJuOyB9XG5cbiAgICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICAgICAgdmFyIG1heFJhbmREaXN0ID0gMTtcbiAgICAgIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICAgICAgaWYoIDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSApe1xuICAgICAgICBkaXJlY3Rpb25YID0gcmFuZG9tRGlzdGFuY2UoIG1heFJhbmREaXN0ICk7XG4gICAgICAgIGRpcmVjdGlvblkgPSByYW5kb21EaXN0YW5jZSggbWF4UmFuZERpc3QgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAoIG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSApO1xuXG4gICAgICBpZiggb3ZlcmxhcCA+IDAgKXtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICAgICAgdmFyIGZvcmNlICAgID0gY3VycmVudEZvcmNlW25vZGUxLmlkXVtub2RlMi5pZF0gLypvcHRpb25zLm5vZGVPdmVybGFwKi8gKiBvdmVybGFwO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSApO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVggICA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VZICAgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgICAgICAgY3VycmVudEZvcmNlW25vZGUxLmlkXVtub2RlMi5pZF0gKj0gb3B0aW9ucy5ub2RlT3ZlcmxhcEF1dG9GYWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Rm9yY2Vbbm9kZTEuaWRdW25vZGUyLmlkXSA9IG9wdGlvbnMubm9kZU92ZXJsYXA7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludCggbm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkgKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KCBub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkgKTtcblxuICAgICAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICAgICAgdmFyIGRpc3RhbmNlWCAgID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGRpc3RhbmNlWSAgID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgICB2YXIgZGlzdGFuY2UgICAgPSBNYXRoLnNxcnQoIGRpc3RhbmNlU3FyICk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgICB2YXIgZm9yY2UgID0gKCBub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbiApIC8gZGlzdGFuY2VTcXI7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBBcHBseSBmb3JjZVxuICAgICAgaWYoICFub2RlMS5pc0xvY2tlZCApe1xuICAgICAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbm9kZTIuaXNMb2NrZWQgKXtcbiAgICAgICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgICAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAgICAgKi9cbiAgICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24oIG5vZGUxLCBub2RlMiwgZFgsIGRZICl7XG5cbiAgICAgIGlmKCBkWCA+IDAgKXtcbiAgICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgICAgIH1cblxuICAgICAgaWYoIGRZID4gMCApe1xuICAgICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICAgICAgfVxuXG4gICAgICBpZiggb3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwICl7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAgICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gICAgICovXG4gICAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24oIG5vZGUsIGRYLCBkWSApe1xuXG4gICAgICAvLyBTaG9yY3V0c1xuICAgICAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gICAgICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgICAgIHZhciBkaXJTbG9wZSAgICAgPSBkWSAvIGRYO1xuICAgICAgdmFyIG5vZGVTbG9wZSAgICA9IEggLyBXO1xuXG4gICAgICAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgK1xuICAgICAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7XG4gICAgICAvL1xuICAgICAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcbiAgICAgIGlmKCAwID09PSBkWCAmJiAwIDwgZFkgKXtcbiAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcbiAgICAgIGlmKCAwID09PSBkWCAmJiAwID4gZFkgKXtcbiAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICBpZiggMCA8IGRYICYmXG4gICAgICAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJlxuICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlICl7XG4gICAgICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgKyAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcbiAgICAgIGlmKCAwID4gZFggJiZcbiAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmXG4gICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUgKXtcbiAgICAgICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSAtIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcbiAgICAgIGlmKCAwIDwgZFkgJiZcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkgKXtcbiAgICAgICAgcmVzLnggPSBYICsgKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgIGlmKCAwID4gZFkgJiZcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkgKXtcbiAgICAgICAgcmVzLnggPSBYIC0gKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKysgKXtcbiAgICAgICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgICAgICB2YXIgZWRnZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzWyBpIF07XG4gICAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4WyBlZGdlLnNvdXJjZUlkIF07XG4gICAgICAgIHZhciBzb3VyY2UgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIHNvdXJjZUl4IF07XG4gICAgICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4WyBlZGdlLnRhcmdldElkIF07XG4gICAgICAgIHZhciB0YXJnZXQgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIHRhcmdldEl4IF07XG5cbiAgICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTtcblxuICAgICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgICAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cbiAgICAgICAgaWYoIDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSApe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KCBzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkgKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KCB0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZICk7XG5cblxuICAgICAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgICB2YXIgbCAgPSBNYXRoLnNxcnQoIGx4ICogbHggKyBseSAqIGx5ICk7XG5cbiAgICAgICAgdmFyIGZvcmNlICA9IE1hdGgucG93KCBlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMiApIC8gZWRnZS5lbGFzdGljaXR5O1xuXG4gICAgICAgIGlmKCAwICE9PSBsICl7XG4gICAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG4gICAgICAgIGlmKCAhc291cmNlLmlzTG9ja2VkICl7XG4gICAgICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhdGFyZ2V0LmlzTG9ja2VkICl7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBzID0gJ0VkZ2UgZm9yY2UgYmV0d2VlbiBub2RlcyAnICsgc291cmNlLmlkICsgJyBhbmQgJyArIHRhcmdldC5pZDtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxO1xuXG4gICAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKyApe1xuICAgICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0WyBpIF07XG4gICAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcbiAgICAgICAgaWYoIDAgPT09IGkgKXtcbiAgICAgICAgICB2YXIgY2VudGVyWCAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICAgIHZhciBjZW50ZXJZICAgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoICAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgICAgICB2YXIgdGVtcCAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFswXSBdIF07XG4gICAgICAgICAgdmFyIHBhcmVudCAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcC5wYXJlbnRJZCBdIF07XG4gICAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFsgaiBdIF0gXTtcbiAgICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgICAgICBpZiggbm9kZS5pc0xvY2tlZCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgICB2YXIgZCAgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG4gICAgICAgICAgaWYoIGQgPiBkaXN0VGhyZXNob2xkICl7XG4gICAgICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7XG4gICAgICAgICAgICAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHMgKz0gXCI6IHNreXBwZWQgc2luY2UgaXQncyB0b28gY2xvc2UgdG8gY2VudGVyXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tXG4gICAgICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAgICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICAgICAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAgICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgICAqL1xuICAgIHZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gICAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG5cbiAgICAgIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWUucHVzaC5hcHBseSggcXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0gKTtcbiAgICAgIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDtcblxuICAgICAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgICAgIHdoaWxlKCBzdGFydCA8PSBlbmQgKXtcbiAgICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgICB2YXIgbm9kZUlkICAgID0gcXVldWVbIHN0YXJ0KysgXTtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4WyBub2RlSWQgXTtcbiAgICAgICAgdmFyIG5vZGUgICAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIG5vZGVJbmRleCBdO1xuICAgICAgICB2YXIgY2hpbGRyZW4gID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG4gICAgICAgIGlmKCAwIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmlzTG9ja2VkICl7XG4gICAgICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7XG5cbiAgICAgICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgK1xuICAgICAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBjaGlsZHJlblsgaSBdIF0gXTtcbiAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBvZmZzZXRcbiAgICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgICAgICAgIHF1ZXVlWyArK2VuZCBdID0gY2hpbGRyZW5bIGkgXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuICAgICAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gICAgICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBpIF07XG4gICAgICAgIGlmKCAwIDwgbi5jaGlsZHJlbi5sZW5ndGggKXtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuICAgICAgICBpZiggMCA8IG4uY2hpbGRyZW4ubGVuZ3RoIHx8IG4uaXNMb2NrZWQgKXtcbiAgICAgICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBvciBsb2NrZWQgbm9kZSBwb3NpdGlvblxuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArXG4gICAgICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG5cbiAgICAgICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG4gICAgICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKCBuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSApO1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgICAgIG4ubWluWCAgICA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICAgICAgbi5tYXhYICAgID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgICAgICBuLm1pblkgICAgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgICAgICBuLm1heFkgICAgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0O1xuICAgICAgICAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgICAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMoIG4sIGxheW91dEluZm8gKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuICAgICAgICBpZiggMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkICl7XG4gICAgICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICAgICAgbi53aWR0aCAgICAgPSBuLm1heFggLSBuLm1pblg7XG4gICAgICAgICAgbi5oZWlnaHQgICAgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAgICAgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gICAgICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiAgICAgOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24oIGZvcmNlWCwgZm9yY2VZLCBtYXggKXtcbiAgICAgIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICAgICAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KCBmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkgKTtcblxuICAgICAgaWYoIGZvcmNlID4gbWF4ICl7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgeDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgICB4OiBmb3JjZVgsXG4gICAgICAgICAgeTogZm9yY2VZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gICAgICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24oIG5vZGUsIGxheW91dEluZm8gKXtcbiAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgICAgIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgICBpZiggbnVsbCA9PSBwYXJlbnRJZCApe1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAgICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBQYXJlbnQgTm9kZVxuICAgICAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgcGFyZW50SWQgXSBdO1xuICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgICAgLy8gTWF4WFxuICAgICAgaWYoIG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFggKXtcbiAgICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICAgICAgfVxuXG4gICAgICAvLyBNaW5YXG4gICAgICBpZiggbnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YICl7XG4gICAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXhZXG4gICAgICBpZiggbnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkgKXtcbiAgICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgICAgIH1cblxuICAgICAgLy8gTWluWVxuICAgICAgaWYoIG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZICl7XG4gICAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gICAgICBpZiggZmxhZyApe1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyggcCwgbGF5b3V0SW5mbyApO1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIHZhciBzZXBhcmF0ZUNvbXBvbmVudHMgPSBmdW5jdGlvbiggbGF5dXRJbmZvLCBvcHRpb25zICl7XG4gICAgICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbIGNpZCBdID0gY29tcG9uZW50c1sgY2lkIF0gfHwgW107XG5cbiAgICAgICAgY29tcG9uZW50LnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsQSA9IDA7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbIGkgXTtcblxuICAgICAgICBpZiggIWMgKXsgY29udGludWU7IH1cblxuICAgICAgICBjLngxID0gSW5maW5pdHk7XG4gICAgICAgIGMueDIgPSAtSW5maW5pdHk7XG4gICAgICAgIGMueTEgPSBJbmZpbml0eTtcbiAgICAgICAgYy55MiA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgbiA9IGNbIGogXTtcblxuICAgICAgICAgIGMueDEgPSBNYXRoLm1pbiggYy54MSwgbi5wb3NpdGlvblggLSBuLndpZHRoIC8gMiApO1xuICAgICAgICAgIGMueDIgPSBNYXRoLm1heCggYy54Miwgbi5wb3NpdGlvblggKyBuLndpZHRoIC8gMiApO1xuICAgICAgICAgIGMueTEgPSBNYXRoLm1pbiggYy55MSwgbi5wb3NpdGlvblkgLSBuLmhlaWdodCAvIDIgKTtcbiAgICAgICAgICBjLnkyID0gTWF0aC5tYXgoIGMueTIsIG4ucG9zaXRpb25ZICsgbi5oZWlnaHQgLyAyICk7XG4gICAgICAgIH1cblxuICAgICAgICBjLncgPSBjLngyIC0gYy54MTtcbiAgICAgICAgYy5oID0gYy55MiAtIGMueTE7XG5cbiAgICAgICAgdG90YWxBICs9IGMudyAqIGMuaDtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cy5zb3J0KCBmdW5jdGlvbiggYzEsIGMyICl7XG4gICAgICAgIHJldHVybiBjMi53ICogYzIuaCAtIGMxLncgKiBjMS5oO1xuICAgICAgfSApO1xuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB2YXIgdXNlZFcgPSAwO1xuICAgICAgdmFyIHJvd0ggPSAwO1xuICAgICAgdmFyIG1heFJvd1cgPSBNYXRoLnNxcnQoIHRvdGFsQSApICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzWyBpIF07XG5cbiAgICAgICAgaWYoICFjICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIG4gPSBjWyBqIF07XG5cbiAgICAgICAgICBpZiggIW4uaXNMb2NrZWQgKXtcbiAgICAgICAgICAgIG4ucG9zaXRpb25YICs9IHg7XG4gICAgICAgICAgICBuLnBvc2l0aW9uWSArPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHggKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgIHJvd0ggPSBNYXRoLm1heCggcm93SCwgYy5oICk7XG5cbiAgICAgICAgaWYoIHVzZWRXID4gbWF4Um93VyApe1xuICAgICAgICAgIHkgKz0gcm93SCArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB1c2VkVyA9IDA7XG4gICAgICAgICAgcm93SCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24oIGkgKXtcbiAgICAgIGlmKCBzdG9wcGVkICl7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBvbmUgc3RlcCBpbiB0aGUgcGhpc2ljYWwgc2ltdWxhdGlvblxuICAgICAgc3RlcCggbGF5b3V0SW5mbywgb3B0aW9ucywgaSApO1xuXG4gICAgICAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcbiAgICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yO1xuICAgICAgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICAgIGlmKCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wICl7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxvb3BSZXQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgZiA9IDA7XG5cbiAgICAgIHdoaWxlKCBmIDwgb3B0aW9ucy5yZWZyZXNoICYmIGkgPCBvcHRpb25zLm51bUl0ZXIgKXtcbiAgICAgICAgdmFyIGxvb3BSZXQgPSBtYWluTG9vcCggaSApO1xuICAgICAgICBpZiggIWxvb3BSZXQgKXsgYnJlYWs7IH1cblxuICAgICAgICBmKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICBicm9hZGNhc3QoIGxheW91dEluZm8ubGF5b3V0Tm9kZXMgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgfVxuXG4gICAgfSB3aGlsZSggbG9vcFJldCAmJiBpICsgMSA8IG9wdGlvbnMubnVtSXRlciApO1xuXG4gICAgc2VwYXJhdGVDb21wb25lbnRzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG5cbiAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgfSApLnRoZW4oIGZ1bmN0aW9uKCBsYXlvdXRJbmZvVXBkYXRlZCApe1xuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMgPSBsYXlvdXRJbmZvVXBkYXRlZC5sYXlvdXROb2RlczsgLy8gZ2V0IHRoZSBwb3NpdGlvbnNcblxuICAgIHRocmVhZC5zdG9wKCk7XG4gICAgZG9uZSgpO1xuICB9ICk7XG5cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJlZnJlc2goe1xuICAgICAgZm9yY2U6IHRydWUsXG4gICAgICBuZXh0OiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gKi9cbkNvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gIGlmKCB0aGlzLnRocmVhZCApe1xuICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgfVxuXG4gIHRoaXMudHJpZ2dlciggJ2xheW91dHN0b3AnICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYoIHRoaXMudGhyZWFkICl7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICogICAgICAgICAgICAgIHVzZWQgaW4gdGhlIGxheW91dCBwcm9jZXNzXG4gKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gKi9cbnZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24oIGN5LCBsYXlvdXQsIG9wdGlvbnMgKXtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuXG4gIHZhciBsYXlvdXRJbmZvICAgPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGN5LndpZHRoKCksXG4gICAgY2xpZW50SGVpZ2h0OiBjeS53aWR0aCgpLFxuICAgIGJvdW5kaW5nQm94OiBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgICAgICAgICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICAgICAgICAgICAgICAgfSApXG4gIH07XG5cbiAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICB2YXIgaWQyY21wdElkID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbIGkgXTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFsgaiBdO1xuXG4gICAgICBpZDJjbXB0SWRbIG5vZGUuaWQoKSBdID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBjcmVhdGluZyBsYXlvdXQgbm9kZXNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICB2YXIgbiA9IG5vZGVzWyBpIF07XG4gICAgdmFyIG5iYiA9IG4uYm91bmRpbmdCb3goKTtcblxuICAgIHZhciB0ZW1wTm9kZSAgICAgICAgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCAgID0gbi5sb2NrZWQoKTtcbiAgICB0ZW1wTm9kZS5pZCAgICAgICAgID0gbi5kYXRhKCAnaWQnICk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgICA9IG4uZGF0YSggJ3BhcmVudCcgKTtcbiAgICB0ZW1wTm9kZS5jbXB0SWQgICAgID0gaWQyY21wdElkWyBuLmlkKCkgXTtcbiAgICB0ZW1wTm9kZS5jaGlsZHJlbiAgID0gW107XG4gICAgdGVtcE5vZGUucG9zaXRpb25YICA9IG4ucG9zaXRpb24oICd4JyApO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSAgPSBuLnBvc2l0aW9uKCAneScgKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYICAgID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZICAgID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgICAgID0gbmJiLnc7XG4gICAgdGVtcE5vZGUud2lkdGggICAgICA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgIHRlbXBOb2RlLm1pblggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgIHRlbXBOb2RlLm1heFkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLm1pblkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLnBhZExlZnQgICAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCAncGFkZGluZycgKSApO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ICAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCAncGFkZGluZycgKSApO1xuICAgIHRlbXBOb2RlLnBhZFRvcCAgICAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCAncGFkZGluZycgKSApO1xuICAgIHRlbXBOb2RlLnBhZEJvdHRvbSAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCAncGFkZGluZycgKSApO1xuXG4gICAgLy8gZm9yY2VzXG4gICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGlzLmZuKCBvcHRpb25zLm5vZGVSZXB1bHNpb24gKSA/IG9wdGlvbnMubm9kZVJlcHVsc2lvbihuKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcblxuICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCggdGVtcE5vZGUgKTtcbiAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBOb2RlLmlkIF0gPSBpO1xuICB9XG5cbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIHZhciB0ZW1wR3JhcGggPSBbXTtcblxuICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYoIG51bGwgIT0gcF9pZCApe1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHBfaWQgXSBdLmNoaWxkcmVuLnB1c2goIG4uaWQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsgKytlbmQgXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaCggbi5pZCApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG4gIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCggdGVtcEdyYXBoICk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUoIHN0YXJ0IDw9IGVuZCApe1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCAgPSBxdWV1ZVsgc3RhcnQrKyBdO1xuICAgIHZhciBub2RlX2l4ICA9IGxheW91dEluZm8uaWRUb0luZGV4WyBub2RlX2lkIF07XG4gICAgdmFyIG5vZGUgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbm9kZV9peCBdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYoIGNoaWxkcmVuLmxlbmd0aCA+IDAgKXtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCggY2hpbGRyZW4gKTtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBxdWV1ZVsgKytlbmQgXSA9IGNoaWxkcmVuWyBpIF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFsgaSBdO1xuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFsgaiBdIF07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgaW5kZXggXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrICl7XG4gICAgdmFyIGUgPSBlZGdlc1sgaSBdO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkICAgICAgID0gZS5kYXRhKCAnaWQnICk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoICdzb3VyY2UnICk7XG4gICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoICd0YXJnZXQnICk7XG5cbiAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgIHZhciBpZGVhbExlbmd0aCA9IGlzLmZuKCBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCApID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgoZSkgOiBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgICB2YXIgZWxhc3RpY2l0eSA9IGlzLmZuKCBvcHRpb25zLmVkZ2VFbGFzdGljaXR5ICkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5KGUpIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTtcblxuICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuICAgIHZhciBzb3VyY2VJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4WyB0ZW1wRWRnZS5zb3VyY2VJZCBdO1xuICAgIHZhciB0YXJnZXRJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4WyB0ZW1wRWRnZS50YXJnZXRJZCBdO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoWyBzb3VyY2VJeCBdO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoWyB0YXJnZXRJeCBdO1xuXG4gICAgaWYoIHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoICl7XG4gICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgIHZhciBsY2EgPSBmaW5kTENBKCB0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8gKTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFsgbGNhIF07XG4gICAgICB2YXIgZGVwdGggICAgPSAwO1xuXG4gICAgICAvLyBTb3VyY2UgZGVwdGhcbiAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIHNvdXJjZUl4IF07XG4gICAgICB3aGlsZSggLTEgPT09IGxjYUdyYXBoLmluZGV4T2YoIHRlbXBOb2RlLmlkICkgKXtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcE5vZGUucGFyZW50SWQgXSBdO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXJnZXQgZGVwdGhcbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgdGFyZ2V0SXggXTtcbiAgICAgIHdoaWxlKCAtMSA9PT0gbGNhR3JhcGguaW5kZXhPZiggdGVtcE5vZGUuaWQgKSApe1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyB0ZW1wTm9kZS5wYXJlbnRJZCBdIF07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcblxuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG4gICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICB9XG5cbiAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKCB0ZW1wRWRnZSApO1xuICB9XG5cbiAgLy8gRmluYWxseSwgcmV0dXJuIGxheW91dEluZm8gb2JqZWN0XG4gIHJldHVybiBsYXlvdXRJbmZvO1xufTtcblxuXG4vKipcbiAqIEBicmllZiA6IFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGluZGV4IG9mIHRoZSBsb3dlc3QgY29tbW9uXG4gKiAgICAgICAgICBncmFwaCBhbmNlc3RvciBiZXR3ZWVuIDIgbm9kZXMgaW4gdGhlIHN1YnRyZWVcbiAqICAgICAgICAgIChmcm9tIHRoZSBncmFwaCBoaWVyYXJjaHkgaW5kdWNlZCB0cmVlKSB3aG9zZVxuICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gKlxuICogQGFyZyBub2RlMTogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqL1xudmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiggbm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvICl7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBmaW5kTENBX2F1eCggbm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvICk7XG4gIGlmKCAyID4gcmVzLmNvdW50ICl7XG4gICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlcixcbiAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAqXG4gKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdGVycyAobWF4OiAyKSBmb3VuZCBpblxuICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAqL1xudmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24oIG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbyApe1xuICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0WyBncmFwaEl4IF07XG4gIC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG4gIGlmKCAtMSA8IGdyYXBoLmluZGV4T2YoIG5vZGUxICkgJiYgLTEgPCBncmFwaC5pbmRleE9mKCBub2RlMiApICl7XG4gICAgcmV0dXJuIHtjb3VudDogMiwgZ3JhcGg6IGdyYXBoSXh9O1xuICB9XG5cbiAgLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcbiAgdmFyIGMgPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG5vZGVJZCAgID0gZ3JhcGhbIGkgXTtcbiAgICB2YXIgbm9kZUl4ICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgbm9kZUlkIF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbm9kZUl4IF0uY2hpbGRyZW47XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcbiAgICBpZiggMCA9PT0gY2hpbGRyZW4ubGVuZ3RoICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbIGxheW91dEluZm8uaWRUb0luZGV4WyBjaGlsZHJlblswXSBdIF07XG4gICAgdmFyIHJlc3VsdCA9IGZpbmRMQ0FfYXV4KCBub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyApO1xuICAgIGlmKCAwID09PSByZXN1bHQuY291bnQgKXtcbiAgICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiggMSA9PT0gcmVzdWx0LmNvdW50ICl7XG4gICAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjKys7XG4gICAgICBpZiggMiA9PT0gYyApe1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge2NvdW50OiBjLCBncmFwaDogZ3JhcGhJeH07XG59O1xuXG5cbi8qKlxuICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZ1xuICovXG52YXIgcHJpbnRMYXlvdXRJbmZvID0gZnVuY3Rpb24oIGxheW91dEluZm8gKXtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICBpZiggIURFQlVHICl7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZGVidWcoICdsYXlvdXROb2RlczonICk7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBpIF07XG4gICAgdmFyIHMgPVxuICAgICdcXG5pbmRleDogJyAgICAgKyBpICtcbiAgICAnXFxuSWQ6ICcgICAgICAgICsgbi5pZCArXG4gICAgJ1xcbkNoaWxkcmVuOiAnICArIG4uY2hpbGRyZW4udG9TdHJpbmcoKSArXG4gICAgJ1xcbnBhcmVudElkOiAnICArIG4ucGFyZW50SWQgICtcbiAgICAnXFxucG9zaXRpb25YOiAnICsgbi5wb3NpdGlvblggK1xuICAgICdcXG5wb3NpdGlvblk6ICcgKyBuLnBvc2l0aW9uWSArXG4gICAgJ1xcbk9mZnNldFg6ICcgKyBuLm9mZnNldFggK1xuICAgICdcXG5PZmZzZXRZOiAnICsgbi5vZmZzZXRZICtcbiAgICAnXFxucGFkTGVmdDogJyArIG4ucGFkTGVmdCArXG4gICAgJ1xcbnBhZFJpZ2h0OiAnICsgbi5wYWRSaWdodCArXG4gICAgJ1xcbnBhZFRvcDogJyArIG4ucGFkVG9wICtcbiAgICAnXFxucGFkQm90dG9tOiAnICsgbi5wYWRCb3R0b207XG5cbiAgICBjb25zb2xlLmRlYnVnKCBzICk7XG4gIH1cblxuICBjb25zb2xlLmRlYnVnKCAnaWRUb0luZGV4JyApO1xuICBmb3IoIHZhciBpIGluIGxheW91dEluZm8uaWRUb0luZGV4ICl7XG4gICAgY29uc29sZS5kZWJ1ZyggJ0lkOiAnICsgaSArICdcXG5JbmRleDogJyArIGxheW91dEluZm8uaWRUb0luZGV4WyBpIF0gKTtcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoICdHcmFwaCBTZXQnICk7XG4gIHZhciBzZXQgPSBsYXlvdXRJbmZvLmdyYXBoU2V0O1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKysgKXtcbiAgICBjb25zb2xlLmRlYnVnKCAnU2V0IDogJyArIGkgKyAnOiAnICsgc2V0WyBpIF0udG9TdHJpbmcoKSApO1xuICB9XG5cbiAgdmFyIHMgPSAnSW5kZXhUb0dyYXBoJztcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaC5sZW5ndGg7IGkgKysgKXtcbiAgICBzICs9ICdcXG5JbmRleCA6ICcgKyBpICsgJyBHcmFwaDogJyArIGxheW91dEluZm8uaW5kZXhUb0dyYXBoWyBpIF07XG4gIH1cbiAgY29uc29sZS5kZWJ1ZyggcyApO1xuXG4gIHMgPSAnTGF5b3V0IEVkZ2VzJztcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGUgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzWyBpIF07XG4gICAgcyArPSAnXFxuRWRnZSBJbmRleDogJyArIGkgKyAnIElEOiAnICsgZS5pZCArXG4gICAgJyBTb3VjZUlEOiAnICsgZS5zb3VyY2VJZCArICcgVGFyZ2V0SWQ6ICcgKyBlLnRhcmdldElkICtcbiAgICAnIElkZWFsIExlbmd0aDogJyArIGUuaWRlYWxMZW5ndGg7XG4gIH1cbiAgY29uc29sZS5kZWJ1ZyggcyApO1xuXG4gIHMgPSAgJ25vZGVTaXplOiAnICsgbGF5b3V0SW5mby5ub2RlU2l6ZTtcbiAgcyArPSAnXFxuZWRnZVNpemU6ICcgKyBsYXlvdXRJbmZvLmVkZ2VTaXplO1xuICBzICs9ICdcXG50ZW1wZXJhdHVyZTogJyArIGxheW91dEluZm8udGVtcGVyYXR1cmU7XG4gIGNvbnNvbGUuZGVidWcoIHMgKTtcblxuICByZXR1cm47XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBSYW5kb21pemVzIHRoZSBwb3NpdGlvbiBvZiBhbGwgbm9kZXNcbiAqL1xudmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBjeSApe1xuICB2YXIgd2lkdGggICAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCAgICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBpIF07XG5cbiAgICAvLyBObyBuZWVkIHRvIHJhbmRvbWl6ZSBjb21wb3VuZCBub2RlcyBvciBsb2NrZWQgbm9kZXNcbiAgICBpZiggMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQgKXtcbiAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24oIGxheW91dEluZm8sIGN5LCBvcHRpb25zICl7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgdmFyIGNvc2VCQiA9IHsgeDE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MTogSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcblxuICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgIG5vZGVzLmZvckVhY2goIGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgbm9kZS5kYXRhKCAnaWQnICkgXSBdO1xuXG4gICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbiggY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblggKTtcbiAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KCBjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCApO1xuXG4gICAgICBjb3NlQkIueTEgPSBNYXRoLm1pbiggY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KCBjb3NlQkIueTIsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgIH0gKTtcblxuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG5cbiAgbm9kZXMucG9zaXRpb25zKCBmdW5jdGlvbiggZWxlLCBpICl7XG4gICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGVsZS5kYXRhKCAnaWQnICkgXSBdO1xuICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbG5vZGUuaWQgKyBcIi4gUmVmcmVzaGVkIHBvc2l0aW9uOiAoXCIgK1xuICAgIC8vIGxub2RlLnBvc2l0aW9uWCArIFwiLCBcIiArIGxub2RlLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7IC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfSApO1xuXG4gIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gIGlmKCB0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5ICl7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCAnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5ICk7XG4gICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiB0aGlzIH0gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICovXG4vLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgIGlmIChERUJVRykge1xuLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4vLyAgIH1cbi8vIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29zZUxheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uL21hdGgnICk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgYXZvaWRPdmVybGFwUGFkZGluZzogMTAsIC8vIGV4dHJhIHNwYWNpbmcgYXJvdW5kIG5vZGVzIHdoZW4gYXZvaWRPdmVybGFwOiB0cnVlXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCwgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgY29uZGVuc2U6IGZhbHNlLCAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gIHJvd3M6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgY29sczogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBwb3NpdGlvbjogZnVuY3Rpb24oIG5vZGUgKXt9LCAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIEdyaWRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5HcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKTtcblxuICBpZiggb3B0aW9ucy5zb3J0ICl7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KCBvcHRpb25zLnNvcnQgKTtcbiAgfVxuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICBpZiggYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwICl7XG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4geyB4OiBiYi54MSwgeTogYmIueTEgfTtcbiAgICB9ICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmggLyBiYi53ICk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKCBzcGxpdHMgKTtcbiAgICB2YXIgY29scyA9IE1hdGgucm91bmQoIGJiLncgLyBiYi5oICogc3BsaXRzICk7XG5cbiAgICB2YXIgc21hbGwgPSBmdW5jdGlvbiggdmFsICl7XG4gICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKCByb3dzLCBjb2xzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oIHJvd3MsIGNvbHMgKTtcbiAgICAgICAgaWYoIG1pbiA9PSByb3dzICl7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoIHJvd3MsIGNvbHMgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCggcm93cywgY29scyApO1xuICAgICAgICBpZiggbWF4ID09IHJvd3MgKXtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9Sb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgIHZhciBvQ29scyA9IG9wdGlvbnMuY29scyAhPSBudWxsID8gb3B0aW9ucy5jb2xzIDogb3B0aW9ucy5jb2x1bW5zO1xuXG4gICAgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcbiAgICBpZiggb1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsICl7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgfSBlbHNlIGlmKCBvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwgKXtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBNYXRoLmNlaWwoIGNlbGxzIC8gcm93cyApO1xuICAgIH0gZWxzZSBpZiggb1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsICl7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgICByb3dzID0gTWF0aC5jZWlsKCBjZWxscyAvIGNvbHMgKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcblxuICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgZWxzZSBpZiggY29scyAqIHJvd3MgPiBjZWxscyApe1xuICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgaWYoIChzbSAtIDEpICogbGcgPj0gY2VsbHMgKXtcbiAgICAgICAgc21hbGwoIHNtIC0gMSApO1xuICAgICAgfSBlbHNlIGlmKCAobGcgLSAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgIGxhcmdlKCBsZyAtIDEgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgd2hpbGUoIGNvbHMgKiByb3dzIDwgY2VsbHMgKXtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgICAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG4gICAgICAgIGlmKCAobGcgKyAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgICAgbGFyZ2UoIGxnICsgMSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYWxsKCBzbSArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYoIG9wdGlvbnMuY29uZGVuc2UgKXtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBpZiggcG9zLnggPT0gbnVsbCB8fCBwb3MueSA9PSBudWxsICl7IC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmJiID0gbm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcblxuICAgICAgICB2YXIgdyA9IG5iYi53ICsgcDtcbiAgICAgICAgdmFyIGggPSBuYmIuaCArIHA7XG5cbiAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoIGNlbGxXaWR0aCwgdyApO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoIGNlbGxIZWlnaHQsIGggKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24oIHJvdywgY29sICl7XG4gICAgICByZXR1cm4gY2VsbFVzZWRbICdjLScgKyByb3cgKyAnLScgKyBjb2wgXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uKCByb3csIGNvbCApe1xuICAgICAgY2VsbFVzZWRbICdjLScgKyByb3cgKyAnLScgKyBjb2wgXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIGNvbCA9IDA7XG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24oKXtcbiAgICAgIGNvbCsrO1xuICAgICAgaWYoIGNvbCA+PSBjb2xzICl7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICB2YXIgaWQybWFuUG9zID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICBpZiggcmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSApeyAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICBwb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKCBwb3Mucm93LCBwb3MuY29sICkgKXtcbiAgICAgICAgICAgIHBvcy5jb2wrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggcG9zLnJvdyA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgIHBvcy5yb3cgPSAwO1xuXG4gICAgICAgICAgd2hpbGUoIHVzZWQoIHBvcy5yb3csIHBvcy5jb2wgKSApe1xuICAgICAgICAgICAgcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlkMm1hblBvc1sgbm9kZS5pZCgpIF0gPSBwb3M7XG4gICAgICAgIHVzZSggcG9zLnJvdywgcG9zLmNvbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggZWxlbWVudCwgaSApe1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zWyBlbGVtZW50LmlkKCkgXTtcbiAgICAgIGlmKCByY1BvcyApe1xuICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuXG4gICAgICAgIHdoaWxlKCB1c2VkKCByb3csIGNvbCApICl7XG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgdXNlKCByb3csIGNvbCApO1xuXG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblxuICAgIH07XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZExheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgbmFtZTogJ2JyZWFkdGhmaXJzdCcsIGltcGw6IHJlcXVpcmUoICcuL2JyZWFkdGhmaXJzdCcgKSB9LFxuICB7IG5hbWU6ICdjaXJjbGUnLCBpbXBsOiByZXF1aXJlKCAnLi9jaXJjbGUnICkgfSxcbiAgeyBuYW1lOiAnY29uY2VudHJpYycsaW1wbDogcmVxdWlyZSggJy4vY29uY2VudHJpYycgKSB9LFxuICB7IG5hbWU6ICdjb3NlJywgaW1wbDogcmVxdWlyZSggJy4vY29zZScgKSB9LFxuICB7IG5hbWU6ICdncmlkJywgaW1wbDogcmVxdWlyZSggJy4vZ3JpZCcgKSB9LFxuICB7IG5hbWU6ICdudWxsJywgaW1wbDogcmVxdWlyZSggJy4vbnVsbCcgKSB9LFxuICB7IG5hbWU6ICdwcmVzZXQnLCBpbXBsOiByZXF1aXJlKCAnLi9wcmVzZXQnICkgfSxcbiAgeyBuYW1lOiAncmFuZG9tJywgaW1wbDogcmVxdWlyZSggJy4vcmFuZG9tJyApIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbi8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbnZhciBkZWZhdWx0cyA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3Bcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbmZ1bmN0aW9uIE51bGxMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG4vLyBydW5zIHRoZSBsYXlvdXRcbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gIGxheW91dC50cmlnZ2VyKCAnbGF5b3V0c3RhcnQnICk7XG5cbiAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSApO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICBsYXlvdXQudHJpZ2dlciggJ2xheW91dHJlYWR5JyApO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gIGxheW91dC5vbmUoICdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wICk7XG4gIGxheW91dC50cmlnZ2VyKCAnbGF5b3V0c3RvcCcgKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHBvc2l0aW9uczogdW5kZWZpbmVkLCAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICB6b29tOiB1bmRlZmluZWQsIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgcGFuOiB1bmRlZmluZWQsIC8vIHRoZSBwYW4gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gaXMuZm4oIG9wdGlvbnMucG9zaXRpb25zICk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oIG5vZGUgKXtcbiAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyggbm9kZSApO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uc1sgbm9kZS5fcHJpdmF0ZS5kYXRhLmlkIF07XG5cbiAgICBpZiggcG9zID09IG51bGwgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCBub2RlLCBpICl7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24oIG5vZGUgKTtcblxuICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0TGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gUmFuZG9tTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIG5vZGUsIGkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApXG4gICAgfTtcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21MYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5cbkJScC5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG5cbiAgICB2YXIgaW5zaWRlID0gKHgxIDw9IHggJiYgeCA8PSB4MikgJiYgKHkxIDw9IHkgJiYgeSA8PSB5Mik7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKCBhbmdsZSApIC0geSAqIE1hdGguc2luKCBhbmdsZSApO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbiggYW5nbGUgKSArIHkgKiBNYXRoLmNvcyggYW5nbGUgKTtcblxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uKCBwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICB2YXIgeCA9IHB0c1sgaSBdO1xuICAgICAgdmFyIHkgPSBwdHNbIGkgKyAxXTtcblxuICAgICAgcmV0UHRzLnB1c2goIHRyYW5zZm9ybSggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0UHRzO1xuICB9O1xuXG4gIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uKCBwdHMgKXtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHAgPSBwdHNbIGkgXTtcblxuICAgICAgcmV0LnB1c2goIHAueCwgcC55ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgc3RhbmRhcmRHYXAgPSBmdW5jdGlvbiggZWRnZSApIHtcbiAgICByZXR1cm4gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS5wZlZhbHVlICogMjtcbiAgfTtcblxuICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uKCBuYW1lLCBkZWZuICl7XG4gICAgaWYoIGlzLnN0cmluZyggZGVmbiApICl7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbIGRlZm4gXTtcbiAgICB9XG5cbiAgICBhcnJvd1NoYXBlc1sgbmFtZSBdID0gdXRpbC5leHRlbmQoIHtcbiAgICAgIG5hbWU6IG5hbWUsXG5cbiAgICAgIHBvaW50czogW1xuICAgICAgICAtMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgMC4zLFxuICAgICAgICAtMC4xNSwgMC4zXG4gICAgICBdLFxuXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHBvaW50cyApO1xuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuXG4gICAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoICdwb2x5Z29uJyApKCBjb250ZXh0LCBwb2ludHMgKTtcbiAgICAgIH0sXG5cbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcblxuICAgICAgZ2FwOiBzdGFuZGFyZEdhcFxuICAgIH0sIGRlZm4gKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnbm9uZScsIHtcbiAgICBjb2xsaWRlOiB1dGlsLmZhbHNpZnksXG5cbiAgICByb3VnaENvbGxpZGU6IHV0aWwuZmFsc2lmeSxcblxuICAgIGRyYXc6IHV0aWwubm9vcCxcblxuICAgIHNwYWNpbmc6IHV0aWwuemVyb2lmeSxcblxuICAgIGdhcDogdXRpbC56ZXJvaWZ5XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2Fycm93JywgJ3RyaWFuZ2xlJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sgJ3RyaWFuZ2xlJyBdLnBvaW50cyxcblxuICAgIGNvbnRyb2xQb2ludDogWyAwLCAtMC4xNSBdLFxuXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgIHZhciBjdHJsUHQgPSB0aGlzLmNvbnRyb2xQb2ludDtcbiAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybSggY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyApO1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC45ODU7XG4gICAgfVxuICB9ICk7XG5cblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcblxuICAgIHBvaW50c1RlZTogW1xuICAgICAgLTAuMTUsIC0wLjQsXG4gICAgICAtMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC40XG4gICAgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbiApICk7XG5cbiAgICAgIHZhciBpbnNpZGUgPSBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgdHJpUHRzICkgfHwgbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRlZVB0cyApO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMgKTtcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgY3Jvc3NMaW5lUG9pbnRzOiBbXG4gICAgICAtMC4yNDE3NSwgLTAuNCxcbiAgICAgIDAuMjQxNzUsIC0wLjQsXG4gICAgXSxcblxuICAgIGZvcmNlU3Ryb2tlOiB0cnVlLFxuXG4gICAgbWF0Y2hFZGdlV2lkdGg6IHRydWUsXG5cbiAgICBzY2FsZUNvb3JkOiBmdW5jdGlvbiAoIGNvbnN0YW50LCBzaXplLCBlZGdlV2lkdGggKXtcbiAgICAgcmV0dXJuIGNvbnN0YW50ICsgKCBlZGdlV2lkdGggKiAwLjAxMiApICsgKCBtYXRoLmxvZzIoIHNpemUgLSAyOC45NSApICogMC4wMDEgKTtcbiAgICB9LFxuXG4gICBzY2FsZUNyb3NzTGluZVhDb29yZDogZnVuY3Rpb24oIHNpemUsIGVkZ2VXaWR0aCApe1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVDb29yZCggMC40Miwgc2l6ZSwgZWRnZVdpZHRoICk7XG4gICAgfSxcblxuICAgIHNjYWxlQ3Jvc3NMaW5lWUNvb3JkOiBmdW5jdGlvbiggc2l6ZSwgZWRnZVdpZHRoICl7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZUNvb3JkKCAtMC4wMSwgc2l6ZSwgZWRnZVdpZHRoICk7XG4gICAgfSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMuY3Jvc3NMaW5lUG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbiApICk7XG5cbiAgICAgIHZhciBpbnNpZGUgPSBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgdHJpUHRzIClcbiAgICAgIHx8IG1hdGguaW5MaW5lVmljaW5pdHkoIHgsIHksXG4gICAgICAgIGNyb3NzTGluZVB0c1swXSwgY3Jvc3NMaW5lUHRzWzFdLCBjcm9zc0xpbmVQdHNbMl0sIGNyb3NzTGluZVB0c1szXSwgcGFkZGluZyApO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGggKXtcbiAgICAgIHZhciBzY2FsZWRDcm9zc0xpbmUgPSBbXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzBdICsgdGhpcy5zY2FsZUNyb3NzTGluZVhDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzFdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVlDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzJdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVhDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzNdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVlDb29yZCggc2l6ZSwgZWRnZVdpZHRoIClcbiAgICAgIF07XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKCBzY2FsZWRDcm9zc0xpbmUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3ZlZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAwLCAtMC4xNVxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjk4NTtcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gKCBNYXRoLnBvdyggdC54IC0geCwgMiApICsgTWF0aC5wb3coIHQueSAtIHksIDIgKSA8PSBNYXRoLnBvdyggKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMiApICk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplICk7XG4gICAgfSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aCggZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSggJ2Fycm93LXNjYWxlJyApLnZhbHVlIClcbiAgICAgICAgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndGVlJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIDAsXG4gICAgICAtMC4xNSwgLTAuMSxcbiAgICAgIDAuMTUsIC0wLjEsXG4gICAgICAwLjE1LCAwXG4gICAgXSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3NxdWFyZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdkaWFtb25kJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjE1LFxuICAgICAgMCwgLTAuMyxcbiAgICAgIDAuMTUsIC0wLjE1LFxuICAgICAgMCwgMFxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZTtcbiAgICB9XG4gIH0gKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIHpJbmRleFNvcnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vY29sbGVjdGlvbi96c29ydCcgKTtcbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vLi4vLi4vd2luZG93JyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24oIGVsZXMsIGUsIGRpcnR5U3R5bGVDYWNoZXMgKXtcbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoIGVsZXMgKTtcblxuICAgIGlmKCBkaXJ0eVN0eWxlQ2FjaGVzID09PSB0cnVlIHx8IGRpcnR5U3R5bGVDYWNoZXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHZhciBldnRzID0gcnN0eWxlLmRpcnR5RXZlbnRzID0gcnN0eWxlLmRpcnR5RXZlbnRzIHx8IHsgbGVuZ3RoOiAwIH07XG5cbiAgICAgICAgaWYoICFldnRzWyBlLnR5cGUgXSApe1xuICAgICAgICAgIGV2dHNbIGUudHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICBldnRzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHIuYmluZGVyKCBjeSApXG4gICAgLy8gbm9kZXNcblxuICAgIC5vbigncG9zaXRpb24uKiBzdHlsZS4qIGZyZWUuKiBib3VuZHMuKicsICdub2RlJywgZnVuY3Rpb24gb25EaXJ0eU1vZE5vZGUoIGUgKXtcbiAgICAgIHZhciBub2RlID0gZS50YXJnZXQ7XG5cbiAgICAgIGVucXVldWUoIG5vZGUsIGUgKTtcbiAgICAgIGVucXVldWUoIG5vZGUuY29ubmVjdGVkRWRnZXMoKSwgZSApO1xuICAgIH0pXG5cbiAgICAub24oJ2FkZC4qJywgJ25vZGUnLCBmdW5jdGlvbiBvbkRpcnR5QWRkTm9kZSggZSApe1xuICAgICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuXG4gICAgICBlbnF1ZXVlKCBlbGUsIGUgKTtcbiAgICB9KVxuXG4gICAgLm9uKCdiYWNrZ3JvdW5kLionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlCZ05vZGUoIGUgKXtcbiAgICAgIHZhciBlbGUgPSBlLnRhcmdldDtcblxuICAgICAgZW5xdWV1ZSggZWxlLCBlLCBmYWxzZSApO1xuICAgIH0pXG5cbiAgICAvLyBlZGdlc1xuXG4gICAgLm9uKCdhZGQuKiBzdHlsZS4qJywgJ2VkZ2UnLCBmdW5jdGlvbiBvbkRpcnR5RWRnZSggZSApe1xuICAgICAgdmFyIGVkZ2UgPSBlLnRhcmdldDtcblxuICAgICAgZW5xdWV1ZSggZWRnZSwgZSApO1xuICAgICAgZW5xdWV1ZSggZWRnZS5wYXJhbGxlbEVkZ2VzKCksIGUgKTtcbiAgICB9KVxuXG4gICAgLm9uKCdyZW1vdmUuKicsICdlZGdlJywgZnVuY3Rpb24gb25EaXJ0eVJlbW92ZUVkZ2UoIGUgKXtcbiAgICAgIHZhciBlZGdlID0gZS50YXJnZXQ7XG4gICAgICB2YXIgcEVkZ2VzID0gZWRnZS5wYXJhbGxlbEVkZ2VzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwRWRnZSA9IHBFZGdlc1tpXTtcblxuICAgICAgICBpZiggIXBFZGdlLnJlbW92ZWQoKSApe1xuICAgICAgICAgIGVucXVldWUoIHBFZGdlLCBlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gbWFudWFsIGRpcnR5aW5nXG5cbiAgICAub24oJ2RpcnR5LionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlFbGUoIGUgKXtcbiAgICAgIHZhciBlbGUgPSBlLmN5VGFyZ2V0O1xuXG4gICAgICBlbnF1ZXVlKCBlbGUsIGUgKTtcbiAgICB9KVxuICA7XG5cbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24oIHdpbGxEcmF3ICl7XG4gICAgaWYoIHdpbGxEcmF3ICl7XG4gICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zO1xuXG4gICAgICBpZiggZm5zICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmbiA9IGZuc1tpXTtcblxuICAgICAgICBmbiggd2lsbERyYXcsIGVsZXNUb1VwZGF0ZSApO1xuICAgICAgfSB9XG5cbiAgICAgIHIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCBlbGVzVG9VcGRhdGUsIGZhbHNlICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvVXBkYXRlLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVsZXNUb1VwZGF0ZVtpXS5fcHJpdmF0ZS5yc3R5bGUuZGlydHlFdmVudHMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIHIuYmVmb3JlUmVuZGVyKCB1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzICk7XG59O1xuXG5CUnAub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uKCBmbiApe1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuXG4gIGZucy5wdXNoKCBmbiApO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVzLCB1c2VDYWNoZSApe1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG4gIGlmKCB0aGlzLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuICBpZiggdXNlQ2FjaGUgPT09IHVuZGVmaW5lZCApeyB1c2VDYWNoZSA9IHRydWU7IH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG4gICAgaWYoICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4pIHx8IGVsZS5yZW1vdmVkKCkgKXsgY29udGludWU7IH1cblxuICAgIC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG4gICAgaWYoIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnICl7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSB7IC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICB9XG5cbiAgICByc3R5bGUuY2xlYW4gPSB0cnVlO1xuICAgIC8vIHJzdHlsZS5kaXJ0eUV2ZW50cyA9IG51bGw7XG4gIH1cblxuICAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiggZWxlICk7XG5cbiAgICByc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICByc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICByc3R5bGUubm9kZVcgPSBlbGUucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZTtcbiAgICByc3R5bGUubm9kZUggPSBlbGUucHN0eWxlKCAnaGVpZ2h0JyApLnBmVmFsdWU7XG4gIH1cblxuICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKCBlZGdlcyApO1xuXG4gIC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVkZ2VzWyBpIF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoIGVsZSApO1xuXG4gICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICByc3R5bGUuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHJzdHlsZS5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgcnN0eWxlLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgcnN0eWxlLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgcnN0eWxlLm1pZFggPSBycy5taWRYO1xuICAgIHJzdHlsZS5taWRZID0gcnMubWlkWTtcbiAgICByc3R5bGUubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgIHJzdHlsZS50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxuLy8gUHJvamVjdCBtb3VzZVxuQlJwLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiggY2xpZW50WCwgY2xpZW50WSApe1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gIHZhciB4ID0gKCBjbGllbnRYIC0gb2Zmc2V0TGVmdCAtIHBhbi54ICkgLyB6b29tO1xuICB2YXIgeSA9ICggY2xpZW50WSAtIG9mZnNldFRvcCAtIHBhbi55ICkgLyB6b29tO1xuXG4gIHJldHVybiBbIHgsIHkgXTtcbn07XG5cbkJScC5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24oKXtcbiAgaWYoIHRoaXMuY29udGFpbmVyQkIgKXtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQjtcbiAgfVxuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250YWluZXIgKTtcbiAgdmFyIHN0eWxlVmFsdWUgPSBmdW5jdGlvbiggbmFtZSApeyByZXR1cm4gcGFyc2VGbG9hdCggc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApICk7IH07XG4gIHZhciBleHRyYSA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJykgKyBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgfTtcblxuICByZXR1cm4gKCB0aGlzLmNvbnRhaW5lckJCID0gWyAvLyB4LCB5LCB3LCBoXG4gICAgcmVjdC5sZWZ0ICsgZXh0cmEubGVmdCxcbiAgICByZWN0LnRvcCArIGV4dHJhLnRvcCxcbiAgICByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IC0gZXh0cmEubGVmdCAtIGV4dHJhLnJpZ2h0LFxuICAgIHJlY3QuYm90dG9tIC0gcmVjdC50b3AgLSBleHRyYS50b3AgLSBleHRyYS5ib3R0b21cbiAgXSApO1xufTtcblxuQlJwLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xufTtcblxuQlJwLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uKCB4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCApe1xuICByZXR1cm4gdGhpcy5maW5kTmVhcmVzdEVsZW1lbnRzKCB4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCApWzBdO1xufTtcblxuQlJwLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiggeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2ggKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuXG4gIGlmKCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSApe1xuICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlKCBlbGUsIHNxRGlzdCApe1xuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGlmKCBuZWFyTm9kZSApe1xuICAgICAgICByZXR1cm47IC8vIGNhbid0IHJlcGxhY2Ugbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhck5vZGUgPSBlbGU7XG4gICAgICAgIG5lYXIucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSAmJiAoIHNxRGlzdCA9PSBudWxsIHx8IHNxRGlzdCA8IG1pblNxRGlzdCApICl7XG4gICAgICBpZiggbmVhckVkZ2UgKXsgLy8gdGhlbiByZXBsYWNlIGV4aXN0aW5nIGVkZ2VcbiAgICAgICAgLy8gY2FuIHJlcGxhY2Ugb25seSBpZiBzYW1lIHotaW5kZXhcbiAgICAgICAgaWYoIG5lYXJFZGdlLnBzdHlsZSggJ3otaW5kZXgnICkudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVhci5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgaWYoIG5lYXJbaV0uaXNFZGdlKCkgKXtcbiAgICAgICAgICAgICAgbmVhcltpXSA9IGVsZTtcbiAgICAgICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXIucHVzaCggZWxlICk7XG4gICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja05vZGUoIG5vZGUgKXtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuXG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuXG4gICAgaWYoXG4gICAgICBwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICAgJiZcbiAgICAgIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICl7XG4gICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbIHNlbGYuZ2V0Tm9kZVNoYXBlKCBub2RlICkgXTtcblxuICAgICAgaWYoXG4gICAgICAgIHNoYXBlLmNoZWNrUG9pbnQoIHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSApXG4gICAgICApe1xuICAgICAgICBhZGRFbGUoIG5vZGUsIDAgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2UgKXtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuXG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHN0eWxlV2lkdGggPSBlZGdlLnBzdHlsZSggJ3dpZHRoJyApLnBmVmFsdWU7XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZTtcbiAgICB2YXIgd2lkdGggPSBzdHlsZVdpZHRoIC8gMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgaW5FZGdlQkIgPSBmYWxzZTtcbiAgICB2YXIgc3FEaXN0O1xuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gbWF0aC5pbkxpbmVWaWNpbml0eSggeCwgeSwgcHRzWyBpIF0sIHB0c1sgaSArIDFdLCBwdHNbIGkgKyAyXSwgcHRzWyBpICsgM10sIHdpZHRoMiApKVxuICAgICAgICAgICAgJiZcbiAgICAgICAgICB3aWR0aFNxID4gKCBzcURpc3QgPSBtYXRoLnNxZGlzdFRvRmluaXRlTGluZSggeCwgeSwgcHRzWyBpIF0sIHB0c1sgaSArIDFdLCBwdHNbIGkgKyAyXSwgcHRzWyBpICsgM10gKSApXG4gICAgICAgICl7XG4gICAgICAgICAgYWRkRWxlKCBlZGdlLCBzcURpc3QgKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyApe1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCApe1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSBtYXRoLmluQmV6aWVyVmljaW5pdHkoIHgsIHksIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSwgcHRzWyBpICsgMl0sIHB0c1sgaSArIDNdLCBwdHNbIGkgKyA0XSwgcHRzWyBpICsgNV0sIHdpZHRoMiApKVxuICAgICAgICAgICAgJiZcbiAgICAgICAgICAod2lkdGhTcSA+IChzcURpc3QgPSBtYXRoLnNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKCB4LCB5LCBwdHNbIGkgXSwgcHRzWyBpICsgMV0sIHB0c1sgaSArIDJdLCBwdHNbIGkgKyAzXSwgcHRzWyBpICsgNF0sIHB0c1sgaSArIDVdICkpIClcbiAgICAgICAgKXtcbiAgICAgICAgICBhZGRFbGUoIGVkZ2UsIHNxRGlzdCApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG5cbiAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcblxuICAgIHZhciBhclNpemUgPSBzZWxmLmdldEFycm93V2lkdGgoIHN0eWxlV2lkdGgsIHNjYWxlICk7XG5cbiAgICB2YXIgYXJyb3dzID0gW1xuICAgICAgeyBuYW1lOiAnc291cmNlJywgeDogcnMuYXJyb3dTdGFydFgsIHk6IHJzLmFycm93U3RhcnRZLCBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZSB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0JywgeDogcnMuYXJyb3dFbmRYLCB5OiBycy5hcnJvd0VuZFksIGFuZ2xlOiBycy50Z3RBcnJvd0FuZ2xlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlJywgeDogcnMubWlkWCwgeTogcnMubWlkWSwgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGUgfSxcbiAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQnLCB4OiBycy5taWRYLCB5OiBycy5taWRZLCBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZSB9XG4gICAgXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYXJyb3dzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYXIgPSBhcnJvd3NbIGkgXTtcbiAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbIGVkZ2UucHN0eWxlKCBhci5uYW1lICsgJy1hcnJvdy1zaGFwZScgKS52YWx1ZSBdO1xuXG4gICAgICBpZihcbiAgICAgICAgc2hhcGUucm91Z2hDb2xsaWRlKCB4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7IHg6IGFyLngsIHk6IGFyLnkgfSwgZWRnZVRocmVzaG9sZCApXG4gICAgICAgICAmJlxuICAgICAgICBzaGFwZS5jb2xsaWRlKCB4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7IHg6IGFyLngsIHk6IGFyLnkgfSwgZWRnZVRocmVzaG9sZCApXG4gICAgICApe1xuICAgICAgICBhZGRFbGUoIGVkZ2UgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgaWYoIGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDAgKXtcbiAgICAgIGNoZWNrTm9kZSggc3JjICk7XG4gICAgICBjaGVja05vZGUoIHRndCApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXByb3AoIG9iaiwgbmFtZSwgcHJlICl7XG4gICAgcmV0dXJuIHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggb2JqLCBuYW1lLCBwcmUgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTGFiZWwoIGVsZSwgcHJlZml4ICl7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciB0aCA9IGxhYmVsVGhyZXNob2xkO1xuXG4gICAgdmFyIHByZWZpeERhc2g7XG4gICAgaWYoIHByZWZpeCApe1xuICAgICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4RGFzaCA9ICcnO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZSggcHJlZml4RGFzaCArICdsYWJlbCcgKS52YWx1ZTtcbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IGVsZS5wc3R5bGUoICd0ZXh0LWV2ZW50cycgKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiggIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBidyA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgcHcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgdmFyIGx3ID0gcHJlcHJvcCggcnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCApICsgYncgKyAyKnRoICsgMipwdztcbiAgICB2YXIgbGggPSBwcmVwcm9wKCByc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCApICsgYncgKyAyKnRoICsgMipwdztcbiAgICB2YXIgbHggPSBwcmVwcm9wKCByc3R5bGUsICdsYWJlbFgnLCBwcmVmaXggKTtcbiAgICB2YXIgbHkgPSBwcmVwcm9wKCByc3R5bGUsICdsYWJlbFknLCBwcmVmaXggKTtcblxuICAgIHZhciB0aGV0YSA9IHByZXByb3AoIF9wLnJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCApO1xuXG4gICAgdmFyIGx4MSA9IGx4IC0gbHcgLyAyO1xuICAgIHZhciBseDIgPSBseCArIGx3IC8gMjtcbiAgICB2YXIgbHkxID0gbHkgLSBsaCAvIDI7XG4gICAgdmFyIGx5MiA9IGx5ICsgbGggLyAyO1xuXG4gICAgaWYoIHRoZXRhICl7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiggeCwgeSApe1xuICAgICAgICB4ID0geCAtIGx4O1xuICAgICAgICB5ID0geSAtIGx5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUoIGx4MSwgbHkxICk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUoIGx4MSwgbHkyICk7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUoIGx4MiwgbHkxICk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUoIGx4MiwgbHkyICk7XG5cbiAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgIHB4MXkxLngsIHB4MXkxLnksXG4gICAgICAgIHB4MnkxLngsIHB4MnkxLnksXG4gICAgICAgIHB4MnkyLngsIHB4MnkyLnksXG4gICAgICAgIHB4MXkyLngsIHB4MXkyLnlcbiAgICAgIF07XG5cbiAgICAgIGlmKCBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgcG9pbnRzICkgKXtcbiAgICAgICAgYWRkRWxlKCBlbGUgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gZG8gYSBjaGVhcGVyIGJiIGNoZWNrXG4gICAgICB2YXIgYmIgPSB7XG4gICAgICAgIHc6IGx3LFxuICAgICAgICBoOiBsaCxcbiAgICAgICAgeDE6IGx4MSxcbiAgICAgICAgeDI6IGx4MixcbiAgICAgICAgeTE6IGx5MSxcbiAgICAgICAgeTI6IGx5MlxuICAgICAgfTtcblxuICAgICAgaWYoIG1hdGguaW5Cb3VuZGluZ0JveCggYmIsIHgsIHkgKSApe1xuICAgICAgICBhZGRFbGUoIGVsZSApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGZvciggdmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7IC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgY2hlY2tOb2RlKCBlbGUgKSB8fCBjaGVja0xhYmVsKCBlbGUgKTtcblxuICAgIH0gZWxzZSB7IC8vIHRoZW4gZWRnZVxuICAgICAgY2hlY2tFZGdlKCBlbGUgKSB8fCBjaGVja0xhYmVsKCBlbGUgKSB8fCBjaGVja0xhYmVsKCBlbGUsICdzb3VyY2UnICkgfHwgY2hlY2tMYWJlbCggZWxlLCAndGFyZ2V0JyApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWFyO1xufTtcblxuLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuQlJwLmdldEFsbEluQm94ID0gZnVuY3Rpb24oIHgxLCB5MSwgeDIsIHkyICl7XG4gIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmludGVyYWN0aXZlO1xuICB2YXIgYm94ID0gW107XG5cbiAgdmFyIHgxYyA9IE1hdGgubWluKCB4MSwgeDIgKTtcbiAgdmFyIHgyYyA9IE1hdGgubWF4KCB4MSwgeDIgKTtcbiAgdmFyIHkxYyA9IE1hdGgubWluKCB5MSwgeTIgKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KCB5MSwgeTIgKTtcblxuICB4MSA9IHgxYztcbiAgeDIgPSB4MmM7XG4gIHkxID0geTFjO1xuICB5MiA9IHkyYztcblxuICB2YXIgYm94QmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCgge1xuICAgIHgxOiB4MSwgeTE6IHkxLFxuICAgIHgyOiB4MiwgeTI6IHkyXG4gIH0gKTtcblxuICBmb3IoIHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcblxuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goIHtcbiAgICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRWRnZXM6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlTGFiZWxzOiBmYWxzZVxuICAgICAgfSApO1xuXG4gICAgICBpZiggbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBib3hCYiwgbm9kZUJiICkgKXtcbiAgICAgICAgYm94LnB1c2goIG5vZGUgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgIGlmKCBycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KCBib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkgKSApeyBjb250aW51ZTsgfVxuICAgICAgaWYoIHJzLmVuZFggIT0gbnVsbCAmJiBycy5lbmRZICE9IG51bGwgJiYgIW1hdGguaW5Cb3VuZGluZ0JveCggYm94QmIsIHJzLmVuZFgsIHJzLmVuZFkgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcblxuICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgaWYoICFtYXRoLnBvaW50SW5Cb3VuZGluZ0JveCggYm94QmIsIHB0c1sgaSBdICkgKXtcbiAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFsbEluc2lkZSApe1xuICAgICAgICAgIGJveC5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyApe1xuICAgICAgICBib3gucHVzaCggZWRnZSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGdpdmVuIG5vZGVcbiAqIGlzIHNldCB0byBhdXRvLCB0aGUgbm9kZSBpcyBjb25zaWRlcmVkIHRvIGJlIGEgY29tcG91bmQuXG4gKlxuICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBzaGFwZSBvZiB0aGUgbm9kZVxuICovXG5CUnAuZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZSggJ3NoYXBlJyApLnZhbHVlO1xuXG4gIGlmKCBub2RlLmlzUGFyZW50KCkgKXtcbiAgICBpZiggc2hhcGUgPT09ICdyZWN0YW5nbGUnXG4gICAgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZSdcbiAgICB8fCBzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZSdcbiAgICB8fCBzaGFwZSA9PT0gJ2JhcnJlbCcgKXtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBzaGFwZSA9PT0gJ3BvbHlnb24nICl7XG4gICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCAnc2hhcGUtcG9seWdvbi1wb2ludHMnICkudmFsdWU7XG5cbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKCBwb2ludHMgKS5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuQlJwLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuXG4gIGlmKCAhZWxlcyApe1xuICAgIC8vIGp1c3QgbGV0IHRoaXMgYmUgcmVjYWxjdWxhdGVkIG9uIHRoZSBuZXh0IHogc29ydCB0aWNrXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlcy5kcmFnID0gW107XG4gIGVsZXMubm9uZHJhZyA9IFtdO1xuXG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmKCBlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgZ3JhYlRhcmdldHMucHVzaCggZWxlICk7XG4gICAgfSBlbHNlIGlmKCBycy5pbkRyYWdMYXllciApe1xuICAgICAgZWxlcy5kcmFnLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzLm5vbmRyYWcucHVzaCggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZ3JhYlRhcmdldHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZ3JhYlRhcmdldHNbaV07XG5cbiAgICBlbGVzLmRyYWcucHVzaCggZWxlICk7XG4gIH1cbn07XG5cbkJScC5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbn07XG5cbkJScC5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCBmb3JjZVJlY2FsYyApe1xuICBpZiggZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgKXtcbiAgICAvL2NvbnNvbGUudGltZSgnY2FjaGV6b3JkZXInKVxuXG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcblxuICAgIGVsZXMuc29ydCggekluZGV4U29ydCApO1xuXG4gICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuXG4gICAgdGhpcy51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9IGVsc2Uge1xuICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICB9XG5cbiAgcmV0dXJuIGVsZXM7XG59O1xuXG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKCByLCBlZGdlLCBwdHMgKXtcbiAgdmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uKCBwMSwgcDIsIHAzLCB0ICl7IHJldHVybiBtYXRoLnFiZXppZXJBdCggcDEsIHAyLCBwMywgdCApOyB9O1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuXG4gICAgYnB0cy5wdXNoKCB7XG4gICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIHAgKSxcbiAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcCApXG4gICAgfSApO1xuICB9XG59XG5cbkJScC5wcm9qZWN0TGluZXMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICBpZiggZXQgPT09ICdtdWx0aWJlemllcicgfHwgIGV0ID09PSAnYmV6aWVyJyB8fCAgZXQgPT09ICdzZWxmJyB8fCAgZXQgPT09ICdjb21wb3VuZCcgKXtcbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZSggaSwgaSArIDYgKSApO1xuICAgIH1cbiAgfSBlbHNlIGlmKCAgZXQgPT09ICdzZWdtZW50cycgKXtcbiAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDEgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgIGxwdHMucHVzaCgge1xuICAgICAgICB4OiBycy5hbGxwdHNbIGkgXSxcbiAgICAgICAgeTogcnMuYWxscHRzWyBpICsgMV1cbiAgICAgIH0gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggZXQgPT09ICdoYXlzdGFjaycgKXtcbiAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuXG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW1xuICAgICAgeyB4OiBocHRzWzBdLCB5OiBocHRzWzFdIH0sXG4gICAgICB7IHg6IGhwdHNbMl0sIHk6IGhwdHNbM10gfVxuICAgIF07XG4gIH1cblxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZSApXG4gICAgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5cbkJScC5wcm9qZWN0QmV6aWVyID0gQlJwLnByb2plY3RMaW5lcztcblxuQlJwLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBub2RlICl7XG4gIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoICdsYWJlbCcgKS5zdHJWYWx1ZTtcblxuICBpZiggaXMuZW1wdHlTdHJpbmcoY29udGVudCkgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICB2YXIgbm9kZVBvcyA9IF9wLnBvc2l0aW9uO1xuICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUucHN0eWxlKCAndGV4dC1oYWxpZ24nICkuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gIH1cblxuICBzd2l0Y2goIHRleHRWYWxpZ24gKXtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgLSBub2RlSGVpZ2h0IC8gMiAtIHBhZGRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBub2RlICk7XG59O1xuXG5CUnAucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gIHZhciBwO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gIH07XG5cbiAgaWYoIGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0ICl7XG4gICAgLy8gdGhlbiB3ZSBoYXZlIHRvIGNhbGN1bGF0ZS4uLlxuICB9IGVsc2Uge1xuICAgIHJldHVybjsgLy8gbm8gbGFiZWxzID0+IG5vIGNhbGNzXG4gIH1cblxuICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAvL1xuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuXG4gIHZhciBzZXRScyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSApe1xuICAgIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICk7XG4gICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc3R5bGUsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICk7XG4gIH07XG5cbiAgc2V0UnMoICdsYWJlbFgnLCBudWxsLCBwLnggKTtcbiAgc2V0UnMoICdsYWJlbFknLCBudWxsLCBwLnkgKTtcblxuICB2YXIgY3JlYXRlQ29udHJvbFBvaW50SW5mbyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUgKXsgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7IH0gLy8gdXNlIGNhY2hlIHNvIG9ubHkgMXggcGVyIGVkZ2VcblxuICAgIHZhciBjdHJscHRzID0gW107XG5cbiAgICAvLyBzdG9yZSBlYWNoIGN0cmxwdCBpbmZvIGluaXRcbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgIHZhciBwMCA9IHsgeDogcnMuYWxscHRzW2ldLCB5OiBycy5hbGxwdHNbaSsxXSB9O1xuICAgICAgdmFyIHAxID0geyB4OiBycy5hbGxwdHNbaSsyXSwgeTogcnMuYWxscHRzW2krM10gfTsgLy8gY3RybHB0XG4gICAgICB2YXIgcDIgPSB7IHg6IHJzLmFsbHB0c1tpKzRdLCB5OiBycy5hbGxwdHNbaSs1XSB9O1xuXG4gICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgcDI6IHAyLFxuICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudCggY3AsIHAwLCBwMSwgdDAsIHQxICl7XG4gICAgICB2YXIgbGVuZ3RoID0gbWF0aC5kaXN0KCBwMCwgcDEgKTtcbiAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzWyBjcC5zZWdtZW50cy5sZW5ndGggLSAxIF07XG4gICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDEsXG4gICAgICAgIHQwOiB0MCxcbiAgICAgICAgdDE6IHQxLFxuICAgICAgICBzdGFydERpc3Q6IHByZXZTZWdtZW50ID8gcHJldlNlZ21lbnQuc3RhcnREaXN0ICsgcHJldlNlZ21lbnQubGVuZ3RoIDogMCxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgIH07XG5cbiAgICAgIGNwLnNlZ21lbnRzLnB1c2goIHNlZ21lbnQgKTtcblxuICAgICAgY3AubGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZWFjaCBjdHJscHQgd2l0aCBzZWdtZW50IGluZm9cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGN0cmxwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjcCA9IGN0cmxwdHNbaV07XG4gICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tpIC0gMV07XG5cbiAgICAgIGlmKCBwcmV2Q3AgKXtcbiAgICAgICAgY3Auc3RhcnREaXN0ID0gcHJldkNwLnN0YXJ0RGlzdCArIHByZXZDcC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGFkZFNlZ21lbnQoXG4gICAgICAgIGNwLFxuICAgICAgICBjcC5wMCwgICBicHRzWyBpICogblByb2pzIF0sXG4gICAgICAgIDAsICAgICAgIHIuYmV6aWVyUHJvalBjdHNbIDAgXVxuICAgICAgKTsgLy8gZmlyc3RcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBuUHJvanMgLSAxOyBqKysgKXtcbiAgICAgICAgYWRkU2VnbWVudChcbiAgICAgICAgICBjcCxcbiAgICAgICAgICBicHRzWyBpICogblByb2pzICsgaiBdLCAgIGJwdHNbIGkgKiBuUHJvanMgKyBqICsgMSBdLFxuICAgICAgICAgIHIuYmV6aWVyUHJvalBjdHNbIGogXSwgICAgci5iZXppZXJQcm9qUGN0c1sgaiArIDEgXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KFxuICAgICAgICBjcCxcbiAgICAgICAgYnB0c1sgaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDEgXSwgICBjcC5wMixcbiAgICAgICAgci5iZXppZXJQcm9qUGN0c1sgblByb2pzIC0gMSBdLCAgICAxXG4gICAgICApOyAvLyBsYXN0XG4gICAgfVxuXG4gICAgcmV0dXJuICggY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHMgKTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICB2YXIgYW5nbGU7XG4gICAgdmFyIGlzU3JjID0gcHJlZml4ID09PSAnc291cmNlJztcblxuICAgIGlmKCAhY29udGVudFsgcHJlZml4IF0gKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4KyctdGV4dC1vZmZzZXQnKS5wZlZhbHVlO1xuXG4gICAgdmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uKCBwMCwgcDEgKXtcbiAgICAgIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICAgICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG5cbiAgICAgIHJldHVybiBNYXRoLmF0YW4oIGR5IC8gZHggKTtcbiAgICB9O1xuXG4gICAgdmFyIGJlemllckFuZ2xlID0gZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHQgKXtcbiAgICAgIHZhciB0MCA9IG1hdGguYm91bmQoIDAsIHQgLSAwLjAwMSwgMSApO1xuICAgICAgdmFyIHQxID0gbWF0aC5ib3VuZCggMCwgdCArIDAuMDAxLCAxICk7XG5cbiAgICAgIHZhciBscDAgPSBtYXRoLnFiZXppZXJQdEF0KCBwMCwgcDEsIHAyLCB0MCApO1xuICAgICAgdmFyIGxwMSA9IG1hdGgucWJlemllclB0QXQoIHAwLCBwMSwgcDIsIHQxICk7XG5cbiAgICAgIHJldHVybiBsaW5lQW5nbGUoIGxwMCwgbHAxICk7XG4gICAgfTtcblxuICAgIHN3aXRjaCggcnMuZWRnZVR5cGUgKXtcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgdmFyIGNwcyA9IGNyZWF0ZUNvbnRyb2xQb2ludEluZm8oKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICB2YXIgc3RhcnREaXN0ID0gMDtcbiAgICAgICAgdmFyIHRvdGFsRGlzdCA9IDA7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgc2VnbWVudCB3ZSdyZSBvblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNwcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBjcCA9IGNwc1sgaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpIF07XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNwLnNlZ21lbnRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgc2VnID0gY3Auc2VnbWVudHNbIGlzU3JjID8gaiA6IGNwLnNlZ21lbnRzLmxlbmd0aCAtIDEgLSBqIF07XG4gICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IGNwLnNlZ21lbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIHN0YXJ0RGlzdCA9IHRvdGFsRGlzdDtcbiAgICAgICAgICAgIHRvdGFsRGlzdCArPSBzZWcubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiggdG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnICl7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0geyBjcDogY3AsIHNlZ21lbnQ6IHNlZyB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggc2VsZWN0ZWQgKXsgYnJlYWs7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgdmFyIHRTZWdtZW50ID0gKCBvZmZzZXQgLSBzdGFydERpc3QgKSAvICggc2VnLmxlbmd0aCApO1xuICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcblxuICAgICAgICB0ID0gbWF0aC5ib3VuZCggMCwgdCwgMSApO1xuICAgICAgICBwID0gbWF0aC5xYmV6aWVyUHRBdCggY3AucDAsIGNwLnAxLCBjcC5wMiwgdCApO1xuICAgICAgICBhbmdsZSA9IGJlemllckFuZ2xlKCBjcC5wMCwgY3AucDEsIGNwLnAyLCB0LCBwICk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgdmFyIGQgPSAwLCBkaSwgZDA7XG4gICAgICAgIHZhciBwMCwgcDE7XG4gICAgICAgIHZhciBsID0gcnMuYWxscHRzLmxlbmd0aDtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSArIDMgPCBsOyBpICs9IDIgKXtcbiAgICAgICAgICBpZiggaXNTcmMgKXtcbiAgICAgICAgICAgIHAwID0geyB4OiBycy5hbGxwdHNbaV0sICAgICB5OiBycy5hbGxwdHNbaSsxXSB9O1xuICAgICAgICAgICAgcDEgPSB7IHg6IHJzLmFsbHB0c1tpKzJdLCAgIHk6IHJzLmFsbHB0c1tpKzNdIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAwID0geyB4OiBycy5hbGxwdHNbbC0yLWldLCB5OiBycy5hbGxwdHNbbC0xLWldIH07XG4gICAgICAgICAgICBwMSA9IHsgeDogcnMuYWxscHRzW2wtNC1pXSwgeTogcnMuYWxscHRzW2wtMy1pXSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpID0gbWF0aC5kaXN0KCBwMCwgcDEgKTtcbiAgICAgICAgICBkMCA9IGQ7XG4gICAgICAgICAgZCArPSBkaTtcblxuICAgICAgICAgIGlmKCBkID49IG9mZnNldCApeyBicmVhazsgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBEID0gb2Zmc2V0IC0gZDA7XG4gICAgICAgIHZhciB0ID0gcEQgLyBkaTtcblxuICAgICAgICB0ICA9IG1hdGguYm91bmQoIDAsIHQsIDEgKTtcbiAgICAgICAgcCA9IG1hdGgubGluZUF0KCBwMCwgcDEsIHQgKTtcbiAgICAgICAgYW5nbGUgPSBsaW5lQW5nbGUoIHAwLCBwMSApO1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHNldFJzKCAnbGFiZWxYJywgcHJlZml4LCBwLnggKTtcbiAgICBzZXRScyggJ2xhYmVsWScsIHByZWZpeCwgcC55ICk7XG4gICAgc2V0UnMoICdsYWJlbEF1dG9BbmdsZScsIHByZWZpeCwgYW5nbGUgKTtcbiAgfTtcblxuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCAnc291cmNlJyApO1xuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCAndGFyZ2V0JyApO1xuXG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIGVkZ2UgKTtcbn07XG5cbkJScC5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKCBlbGUgKTtcblxuICBpZiggZWxlLmlzRWRnZSgpICl7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKCBlbGUsICdzb3VyY2UnICk7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKCBlbGUsICd0YXJnZXQnICk7XG4gIH1cbn07XG5cbkJScC5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSwgcHJlZml4ICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGUsIHByZWZpeCApO1xuICB2YXIgbGFiZWxEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgdGV4dCApO1xuXG4gIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnN0eWxlLCAgICdsYWJlbFdpZHRoJywgcHJlZml4LCBsYWJlbERpbXMud2lkdGggKTtcbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIGxhYmVsRGltcy53aWR0aCApO1xuXG4gIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnN0eWxlLCAgICdsYWJlbEhlaWdodCcsIHByZWZpeCwgbGFiZWxEaW1zLmhlaWdodCApO1xuICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGxhYmVsRGltcy5oZWlnaHQgKTtcbn07XG5cbkJScC5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiggZWxlLCBwcmVmaXggKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGZkID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciB0ZXh0ID0gZWxlLnBzdHlsZSggcGZkICsgJ2xhYmVsJyApLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoICd0ZXh0LXRyYW5zZm9ybScgKS52YWx1ZTtcbiAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24oIHByb3BOYW1lLCB2YWx1ZSApe1xuICAgIGlmKCB2YWx1ZSApe1xuICAgICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUgKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXggKTtcbiAgICB9XG4gIH07XG5cbiAgaWYoIHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnICl7XG4gICAgLy8gcGFzc3Rocm91Z2hcbiAgfSBlbHNlIGlmKCB0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnICl7XG4gICAgdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmKCB0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnICl7XG4gICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHZhciB3cmFwU3R5bGUgPSBlbGUucHN0eWxlKCAndGV4dC13cmFwJyApLnZhbHVlO1xuXG4gIGlmKCB3cmFwU3R5bGUgPT09ICd3cmFwJyApe1xuICAgIC8vY29uc29sZS5sb2coJ3dyYXAnKTtcblxuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCAnbGFiZWxLZXknICk7XG5cbiAgICAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgaWYoIGxhYmVsS2V5ICYmIHJzY3JhdGNoKCAnbGFiZWxXcmFwS2V5JyApID09PSBsYWJlbEtleSApe1xuICAgICAgLy8gY29uc29sZS5sb2coJ3dyYXAgY2FjaGUgaGl0Jyk7XG4gICAgICByZXR1cm4gcnNjcmF0Y2goICdsYWJlbFdyYXBDYWNoZWRUZXh0JyApO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBtaXNzJyk7XG5cbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSggJ3RleHQtbWF4LXdpZHRoJyApLnBmVmFsdWU7XG4gICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1sgbCBdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgbGluZSwgJ2xpbmU9JyArIGxpbmUgKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICBpZiggbGluZVcgPiBtYXhXICl7IC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCggL1xccysvICk7IC8vIE5COiBhc3N1bWUgY29sbGFwc2VkIHdoaXRlc3BhY2UgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcblxuICAgICAgICBmb3IoIHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrICl7XG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1sgdyBdO1xuICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyAnICcgKyB3b3JkO1xuICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRlc3RMaW5lLCAndGVzdExpbmU9JyArIHRlc3RMaW5lICk7XG4gICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICBpZiggdGVzdFcgPD0gbWF4VyApeyAvLyB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXG4gICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgICAgICBzdWJsaW5lID0gd29yZCArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcbiAgICAgICAgaWYoICFzdWJsaW5lLm1hdGNoKCAvXlxccyskLyApICl7XG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggbGluZSApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cbiAgICByc2NyYXRjaCggJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgd3JhcHBlZExpbmVzICk7XG4gICAgdGV4dCA9IHJzY3JhdGNoKCAnbGFiZWxXcmFwQ2FjaGVkVGV4dCcsIHdyYXBwZWRMaW5lcy5qb2luKCAnXFxuJyApICk7XG4gICAgcnNjcmF0Y2goICdsYWJlbFdyYXBLZXknLCBsYWJlbEtleSApO1xuXG4gICAgLy8gY29uc29sZS5sb2codGV4dClcbiAgfSBlbHNlIGlmKCB3cmFwU3R5bGUgPT09ICdlbGxpcHNpcycgKXtcbiAgICB2YXIgbWF4VyA9IGVsZS5wc3R5bGUoICd0ZXh0LW1heC13aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciBlbGxpcHNpemVkID0gJyc7XG4gICAgdmFyIGVsbGlwc2lzID0gJ1xcdTIwMjYnO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIGVsbGlwc2l6ZWQgKyB0ZXh0W2ldICsgZWxsaXBzaXMgKS53aWR0aDtcblxuICAgICAgaWYoIHdpZHRoV2l0aE5leHRDaCA+IG1heFcgKXsgYnJlYWs7IH1cblxuICAgICAgZWxsaXBzaXplZCArPSB0ZXh0W2ldO1xuXG4gICAgICBpZiggaSA9PT0gdGV4dC5sZW5ndGggLSAxICl7IGluY0xhc3RDaCA9IHRydWU7IH1cbiAgICB9XG5cbiAgICBpZiggIWluY0xhc3RDaCApe1xuICAgICAgZWxsaXBzaXplZCArPSBlbGxpcHNpcztcbiAgICB9XG5cbiAgICByZXR1cm4gZWxsaXBzaXplZDtcbiAgfSAvLyBpZiBlbGxpcHNpemVcblxuICByZXR1cm4gdGV4dDtcbn07XG5cbkJScC5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlLCB0ZXh0LCBleHRyYUtleSApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGNhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmxhYmVsU3R5bGVLZXkgKyAnJEAkJyArIHRleHQ7XG5cbiAgaWYoIGV4dHJhS2V5ICl7XG4gICAgY2FjaGVLZXkgKz0gJyRAJCcgKyBleHRyYUtleTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0ge30pO1xuXG4gIGlmKCBjYWNoZVsgY2FjaGVLZXkgXSApe1xuICAgIHJldHVybiBjYWNoZVsgY2FjaGVLZXkgXTtcbiAgfVxuXG4gIHZhciBzaXplTXVsdCA9IDE7IC8vIGluY3JlYXNlIHRoZSBzY2FsZSB0byBpbmNyZWFzZSBhY2N1cmFjeSB3LnIudC4gem9vbWVkIHRleHRcbiAgdmFyIGZTdHlsZSA9IGVsZS5wc3R5bGUoICdmb250LXN0eWxlJyApLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9ICggc2l6ZU11bHQgKiBlbGUucHN0eWxlKCAnZm9udC1zaXplJyApLnBmVmFsdWUgKSArICdweCc7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCAnZm9udC1mYW1pbHknICkuc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCAnZm9udC13ZWlnaHQnICkuc3RyVmFsdWU7XG5cbiAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gIGlmKCAhZGl2ICl7XG4gICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuXG4gIHZhciBkcyA9IGRpdi5zdHlsZTtcblxuICAvLyBmcm9tIGVsZSBzdHlsZVxuICBkcy5mb250RmFtaWx5ID0gZmFtaWx5O1xuICBkcy5mb250U3R5bGUgPSBmU3R5bGU7XG4gIGRzLmZvbnRTaXplID0gc2l6ZTtcbiAgZHMuZm9udFdlaWdodCA9IHdlaWdodDtcblxuICAvLyBmb3JjZWQgc3R5bGVcbiAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICBkcy50b3AgPSAnLTk5OTlweCc7XG4gIGRzLnpJbmRleCA9ICctMSc7XG4gIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgZHMucGFkZGluZyA9ICcwJztcbiAgZHMubGluZUhlaWdodCA9ICcxJztcblxuICBpZiggZWxlLnBzdHlsZSggJ3RleHQtd3JhcCcgKS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgZHMud2hpdGVTcGFjZSA9ICdwcmUnOyAvLyBzbyBuZXdsaW5lcyBhcmUgdGFrZW4gaW50byBhY2NvdW50XG4gIH0gZWxzZSB7XG4gICAgZHMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuICB9XG5cbiAgLy8gcHV0IGxhYmVsIGNvbnRlbnQgaW4gZGl2XG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG5cbiAgY2FjaGVbIGNhY2hlS2V5IF0gPSB7XG4gICAgd2lkdGg6IE1hdGguY2VpbCggZGl2LmNsaWVudFdpZHRoIC8gc2l6ZU11bHQgKSxcbiAgICBoZWlnaHQ6IE1hdGguY2VpbCggZGl2LmNsaWVudEhlaWdodCAvIHNpemVNdWx0IClcbiAgfTtcblxuICByZXR1cm4gY2FjaGVbIGNhY2hlS2V5IF07XG59O1xuXG5CUnAucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggZWRnZXMgKXtcbiAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoIGVkZ2VzICk7XG59O1xuXG5cbi8vIEZpbmQgZWRnZSBjb250cm9sIHBvaW50c1xuQlJwLmZpbmRFZGdlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKCBlZGdlcyApe1xuICBpZiggIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTtcblxuICAvLyBjcmVhdGUgYSB0YWJsZSBvZiBlZGdlIChzcmMsIHRndCkgPT4gbGlzdCBvZiBlZGdlcyBiZXR3ZWVuIHRoZW1cbiAgdmFyIHBhaXJJZDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlZGdlID0gZWRnZXNbIGkgXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBkYXRhID0gX3AuZGF0YTtcbiAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCAnY3VydmUtc3R5bGUnICkudmFsdWU7XG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnO1xuXG4gICAgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcbiAgICBpZiggZWRnZS5wc3R5bGUoICdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJyApe1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYoIGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHNyY0lkID0gZGF0YS5zb3VyY2U7XG4gICAgdmFyIHRndElkID0gZGF0YS50YXJnZXQ7XG5cbiAgICBwYWlySWQgPSBzcmNJZCA+IHRndElkID9cbiAgICAgIHRndElkICsgJyQtJCcgKyBzcmNJZCA6XG4gICAgICBzcmNJZCArICckLSQnICsgdGd0SWQgO1xuXG4gICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgcGFpcklkID0gJ3VuYnVuZGxlZCcgKyAnJC0kJyArIGRhdGEuaWQ7XG4gICAgfVxuXG4gICAgaWYoIGhhc2hUYWJsZVsgcGFpcklkIF0gPT0gbnVsbCApe1xuICAgICAgaGFzaFRhYmxlWyBwYWlySWQgXSA9IFtdO1xuICAgICAgcGFpcklkcy5wdXNoKCBwYWlySWQgKTtcbiAgICB9XG5cbiAgICBoYXNoVGFibGVbIHBhaXJJZCBdLnB1c2goIGVkZ2UgKTtcblxuICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgIGhhc2hUYWJsZVsgcGFpcklkIF0uaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3JjLCB0Z3QsIHNyY19wLCB0Z3RfcCwgc3JjUG9zLCB0Z3RQb3MsIHNyY1csIHNyY0gsIHRndFcsIHRndEgsIHNyY1NoYXBlLCB0Z3RTaGFwZTtcbiAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgYmFkQmV6aWVyO1xuXG4gIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG4gIGZvciggdmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKyApe1xuICAgIHBhaXJJZCA9IHBhaXJJZHNbIHAgXTtcbiAgICB2YXIgcGFpckVkZ2VzID0gaGFzaFRhYmxlWyBwYWlySWQgXTtcblxuICAgIC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG4gICAgcGFpckVkZ2VzLnNvcnQoIGZ1bmN0aW9uKCBlZGdlMSwgZWRnZTIgKXtcbiAgICAgIHJldHVybiBlZGdlMS5wb29sSW5kZXgoKSAtIGVkZ2UyLnBvb2xJbmRleCgpO1xuICAgIH0gKTtcblxuICAgIHNyYyA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgdGd0ID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnRhcmdldDtcblxuICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgZm9yIGJ1bmRsZWQgZWRnZXNcbiAgICBpZiggIXBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQgJiYgc3JjLmlkKCkgPiB0Z3QuaWQoKSApe1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cblxuICAgIHNyY19wID0gc3JjLl9wcml2YXRlO1xuICAgIHRndF9wID0gdGd0Ll9wcml2YXRlO1xuXG4gICAgc3JjUG9zID0gc3JjX3AucG9zaXRpb247XG4gICAgdGd0UG9zID0gdGd0X3AucG9zaXRpb247XG5cbiAgICBzcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICBzcmNIID0gc3JjLm91dGVySGVpZ2h0KCk7XG5cbiAgICB0Z3RXID0gdGd0Lm91dGVyV2lkdGgoKTtcbiAgICB0Z3RIID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICBzcmNTaGFwZSA9IHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIHNyYyApIF07XG4gICAgdGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCB0Z3QgKSBdO1xuXG4gICAgYmFkQmV6aWVyID0gZmFsc2U7XG5cbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgZWRnZV9wO1xuICAgIHZhciBycztcblxuICAgIHZhciBkaXJDb3VudHMgPSB7XG4gICAgICAnbm9ydGgnOiAwLFxuICAgICAgJ3dlc3QnOiAwLFxuICAgICAgJ3NvdXRoJzogMCxcbiAgICAgICdlYXN0JzogMCxcbiAgICAgICdub3J0aHdlc3QnOiAwLFxuICAgICAgJ3NvdXRod2VzdCc6IDAsXG4gICAgICAnbm9ydGhlYXN0JzogMCxcbiAgICAgICdzb3V0aGVhc3QnOiAwXG4gICAgfTtcblxuICAgIHZhciBzcmNYMiA9IHNyY1Bvcy54O1xuICAgIHZhciBzcmNZMiA9IHNyY1Bvcy55O1xuICAgIHZhciBzcmNXMiA9IHNyY1c7XG4gICAgdmFyIHNyY0gyID0gc3JjSDtcblxuICAgIHZhciB0Z3RYMiA9IHRndFBvcy54O1xuICAgIHZhciB0Z3RZMiA9IHRndFBvcy55O1xuICAgIHZhciB0Z3RXMiA9IHRndFc7XG4gICAgdmFyIHRndEgyID0gdGd0SDtcblxuICAgIHZhciBudW1FZGdlczIgPSBwYWlyRWRnZXMubGVuZ3RoO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYWlyRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVkZ2UgPSBwYWlyRWRnZXNbIGkgXTtcbiAgICAgIGVkZ2VfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICBycyA9IGVkZ2VfcC5yc2NyYXRjaDtcblxuICAgICAgdmFyIGVkZ2VJbmRleDEgPSBycy5sYXN0RWRnZUluZGV4O1xuICAgICAgdmFyIGVkZ2VJbmRleDIgPSBpO1xuXG4gICAgICB2YXIgbnVtRWRnZXMxID0gcnMubGFzdE51bUVkZ2VzO1xuXG4gICAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCAnY3VydmUtc3R5bGUnICkudmFsdWU7XG5cbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJztcblxuICAgICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycgKTtcbiAgICAgIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgICAgIHZhciBsb29wU3dwID0gZWRnZS5wc3R5bGUoJ2xvb3Atc3dlZXAnKS5wZlZhbHVlO1xuICAgICAgdmFyIGN0cmxwdFdzID0gZWRnZS5wc3R5bGUoICdjb250cm9sLXBvaW50LXdlaWdodHMnICk7XG4gICAgICB2YXIgYmV6aWVyTiA9IGN0cmxwdERpc3RzICYmIGN0cmxwdFdzID8gTWF0aC5taW4oIGN0cmxwdERpc3RzLnZhbHVlLmxlbmd0aCwgY3RybHB0V3MudmFsdWUubGVuZ3RoICkgOiAxO1xuICAgICAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScgKS5wZlZhbHVlO1xuICAgICAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07XG4gICAgICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICAgICAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCAnc2VnbWVudC13ZWlnaHRzJyApO1xuICAgICAgdmFyIHNlZ21lbnREcyA9IGVkZ2UucHN0eWxlKCAnc2VnbWVudC1kaXN0YW5jZXMnICk7XG4gICAgICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oIHNlZ21lbnRXcy5wZlZhbHVlLmxlbmd0aCwgc2VnbWVudERzLnBmVmFsdWUubGVuZ3RoICk7XG5cbiAgICAgIHZhciBzcmNYMSA9IHJzLmxhc3RTcmNDdGxQdFg7XG4gICAgICB2YXIgc3JjWTEgPSBycy5sYXN0U3JjQ3RsUHRZO1xuICAgICAgdmFyIHNyY1cxID0gcnMubGFzdFNyY0N0bFB0VztcbiAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG5cbiAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICB2YXIgdGd0WTEgPSBycy5sYXN0VGd0Q3RsUHRZO1xuICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgIHZhciB0Z3RIMSA9IHJzLmxhc3RUZ3RDdGxQdEg7XG5cbiAgICAgIHZhciBjdXJ2ZVN0eWxlMSA9IHJzLmxhc3RDdXJ2ZVN0eWxlO1xuICAgICAgdmFyIGN1cnZlU3R5bGUyID0gY3VydmVTdHlsZTtcblxuICAgICAgdmFyIGN0cmxwdERpc3RzMSA9IHJzLmxhc3RDdHJscHREaXN0cztcbiAgICAgIHZhciBjdHJscHREaXN0czIgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnN0clZhbHVlIDogbnVsbDtcblxuICAgICAgdmFyIGN0cmxwdFdzMSA9IHJzLmxhc3RDdHJscHRXcztcbiAgICAgIHZhciBjdHJscHRXczIgPSBjdHJscHRXcy5zdHJWYWx1ZTtcblxuICAgICAgdmFyIHNlZ21lbnRXczEgPSBycy5sYXN0U2VnbWVudFdzO1xuICAgICAgdmFyIHNlZ21lbnRXczIgPSBzZWdtZW50V3Muc3RyVmFsdWU7XG5cbiAgICAgIHZhciBzZWdtZW50RHMxID0gcnMubGFzdFNlZ21lbnREcztcbiAgICAgIHZhciBzZWdtZW50RHMyID0gc2VnbWVudERzLnN0clZhbHVlO1xuXG4gICAgICB2YXIgc3RlcFNpemUxID0gcnMubGFzdFN0ZXBTaXplO1xuICAgICAgdmFyIHN0ZXBTaXplMiA9IHN0ZXBTaXplO1xuXG4gICAgICB2YXIgbG9vcERpcjEgPSBycy5sYXN0TG9vcERpcjtcbiAgICAgIHZhciBsb29wRGlyMiA9IGxvb3BEaXI7XG5cbiAgICAgIHZhciBsb29wU3dwMSA9IHJzLmxhc3RMb29wU3dwO1xuICAgICAgdmFyIGxvb3BTd3AyID0gbG9vcFN3cDtcblxuICAgICAgdmFyIGVkZ2VEaXN0YW5jZXMxID0gcnMubGFzdEVkZ2VEaXN0YW5jZXM7XG4gICAgICB2YXIgZWRnZURpc3RhbmNlczIgPSBlZGdlRGlzdGFuY2VzO1xuXG4gICAgICBpZiggYmFkQmV6aWVyICl7XG4gICAgICAgIHJzLmJhZEJlemllciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHNyY1gxID09PSBzcmNYMiAmJiBzcmNZMSA9PT0gc3JjWTIgJiYgc3JjVzEgPT09IHNyY1cyICYmIHNyY0gxID09PSBzcmNIMlxuICAgICAgJiYgIHRndFgxID09PSB0Z3RYMiAmJiB0Z3RZMSA9PT0gdGd0WTIgJiYgdGd0VzEgPT09IHRndFcyICYmIHRndEgxID09PSB0Z3RIMlxuICAgICAgJiYgIGN1cnZlU3R5bGUxID09PSBjdXJ2ZVN0eWxlMlxuICAgICAgJiYgIGN0cmxwdERpc3RzMSA9PT0gY3RybHB0RGlzdHMyXG4gICAgICAmJiAgY3RybHB0V3MxID09PSBjdHJscHRXczJcbiAgICAgICYmICBzZWdtZW50V3MxID09PSBzZWdtZW50V3MyXG4gICAgICAmJiAgc2VnbWVudERzMSA9PT0gc2VnbWVudERzMlxuICAgICAgJiYgIHN0ZXBTaXplMSA9PT0gc3RlcFNpemUyXG4gICAgICAmJiAgbG9vcERpcjEgPT09IGxvb3BEaXIyXG4gICAgICAmJiAgbG9vcFN3cDEgPT09IGxvb3BTd3AyXG4gICAgICAmJiAgZWRnZURpc3RhbmNlczEgPT09IGVkZ2VEaXN0YW5jZXMyXG4gICAgICAmJiAgKChlZGdlSW5kZXgxID09PSBlZGdlSW5kZXgyICYmIG51bUVkZ2VzMSA9PT0gbnVtRWRnZXMyKSB8fCBlZGdlSXNVbmJ1bmRsZWQpICl7XG4gICAgICAgIGNvbnRpbnVlOyAvLyB0aGVuIHRoZSBjb250cm9sIHBvaW50cyBoYXZlbid0IGNoYW5nZWQgYW5kIHdlIGNhbiBza2lwIGNhbGN1bGF0aW5nIHRoZW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFggPSBzcmNYMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0WSA9IHNyY1kyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRXID0gc3JjVzI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdEggPSBzcmNIMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0WCA9IHRndFgyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRZID0gdGd0WTI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFcgPSB0Z3RXMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0SCA9IHRndEgyO1xuICAgICAgICBycy5sYXN0RWRnZUluZGV4ID0gZWRnZUluZGV4MjtcbiAgICAgICAgcnMubGFzdE51bUVkZ2VzID0gbnVtRWRnZXMyO1xuICAgICAgICBycy5sYXN0Q3VydmVTdHlsZSA9IGN1cnZlU3R5bGUyO1xuICAgICAgICBycy5sYXN0Q3RybHB0RGlzdHMgPSBjdHJscHREaXN0czI7XG4gICAgICAgIHJzLmxhc3RDdHJscHRXcyA9IGN0cmxwdFdzMjtcbiAgICAgICAgcnMubGFzdFNlZ21lbnREcyA9IHNlZ21lbnREczI7XG4gICAgICAgIHJzLmxhc3RTZWdtZW50V3MgPSBzZWdtZW50V3MyO1xuICAgICAgICBycy5sYXN0U3RlcFNpemUgPSBzdGVwU2l6ZTI7XG4gICAgICAgIHJzLmxhc3RMb29wRGlyID0gbG9vcERpcjI7XG4gICAgICAgIHJzLmxhc3RMb29wU3dwID0gbG9vcFN3cDI7XG4gICAgICAgIHJzLmxhc3RFZGdlRGlzdGFuY2VzID0gZWRnZURpc3RhbmNlczI7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhcGFpckVkZ2VzLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgKCAocGFpckVkZ2VzLmxlbmd0aCA+IDEgJiYgc3JjICE9PSB0Z3QpIHx8IHBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQgKSApe1xuXG4gICAgICAgIHBhaXJFZGdlcy5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgIHNyY1csXG4gICAgICAgICAgc3JjSCxcbiAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICB0Z3RXLFxuICAgICAgICAgIHRndEgsXG4gICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgMFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBtaWRwdFNyY1B0cyA9IHtcbiAgICAgICAgICB4MTogc3JjT3V0c2lkZVswXSxcbiAgICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgICB5MjogdGd0T3V0c2lkZVsxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwb3NQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGR5ID0gKCB0Z3RPdXRzaWRlWzFdIC0gc3JjT3V0c2lkZVsxXSApO1xuICAgICAgICB2YXIgZHggPSAoIHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdICk7XG4gICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgIH07XG4gICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgICAgaWYoXG4gICAgICAgICAgdGd0U2hhcGUuY2hlY2tQb2ludCggc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55ICkgICYmXG4gICAgICAgICAgc3JjU2hhcGUuY2hlY2tQb2ludCggdGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55IClcbiAgICAgICAgKXtcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHt9O1xuICAgICAgICAgIGJhZEJlemllciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBycy5zcmNJbnRuID0gc3JjT3V0c2lkZTtcbiAgICAgIHJzLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuXG4gICAgICBpZiggc3JjID09PSB0Z3QgKXtcbiAgICAgICAgLy8gU2VsZi1lZGdlXG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG5cbiAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dEFuZ2xlID0gIGxvb3BEaXIgLSBsb29wU3dwIC8gMjtcbiAgICAgICAgdmFyIGluQW5nbGUgID0gIGxvb3BEaXIgKyBsb29wU3dwIC8gMjtcblxuICAgICAgICAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuICAgICAgICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICAgICAgICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG5cbiAgICAgICAgcnMuY3RybHB0cyA9IFtcbiAgICAgICAgICBzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksXG4gICAgICAgICAgc3JjUG9zLnkgKyBNYXRoLnNpbihvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXG4gICAgICAgIF07XG5cbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgaGFzQ29tcG91bmRzICYmXG4gICAgICAgICggc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpICkgJiZcbiAgICAgICAgKCBzcmMucGFyZW50cygpLmFueVNhbWUoIHRndCApIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZSggc3JjICkgKVxuICAgICAgKXtcbiAgICAgICAgLy8gQ29tcG91bmQgZWRnZVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBsaW5lIGFwcHJveGltYXRpb24gZG9lc24ndCBhcHBseSBmb3IgY29tcG91bmQgYmV6aWVyc1xuICAgICAgICAvLyAobG9vcC9zZWxmIGVkZ2VzIGFyZSBhbHJlYWR5IGVsaWRlZCBiL2Mgb2YgY2hlYXAgc3JjPT10Z3QgY2hlY2spXG4gICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgIGogPSAwO1xuICAgICAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb29wVyA9IDUwO1xuXG4gICAgICAgIHZhciBsb29wYVBvcyA9IHtcbiAgICAgICAgICB4OiBzcmNQb3MueCAtIHNyY1cgLyAyLFxuICAgICAgICAgIHk6IHNyY1Bvcy55IC0gc3JjSCAvIDJcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgICAgICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICAgICAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3BQb3MgPSB7XG4gICAgICAgICAgeDogTWF0aC5taW4oIGxvb3BhUG9zLngsIGxvb3BiUG9zLnggKSxcbiAgICAgICAgICB5OiBNYXRoLm1pbiggbG9vcGFQb3MueSwgbG9vcGJQb3MueSApXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gICAgICAgIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coIHNyY1cgKiAwLjAxICkgKTtcbiAgICAgICAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyggdGd0VyAqIDAuMDEgKSApO1xuXG4gICAgICAgIHJzLmN0cmxwdHMgPSBbXG4gICAgICAgICAgbG9vcFBvcy54LFxuICAgICAgICAgIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3coIGxvb3BXLCAxLjEyICkgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsXG5cbiAgICAgICAgICBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KCBsb29wVywgMS4xMiApIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLFxuICAgICAgICAgIGxvb3BQb3MueVxuICAgICAgICBdO1xuXG4gICAgICB9IGVsc2UgaWYoIGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgKXtcbiAgICAgICAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgICAgICAgcnMuc2VncHRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKyApe1xuICAgICAgICAgIHZhciB3ID0gc2VnbWVudFdzLnBmVmFsdWVbIHMgXTtcbiAgICAgICAgICB2YXIgZCA9IHNlZ21lbnREcy5wZlZhbHVlWyBzIF07XG5cbiAgICAgICAgICB2YXIgdzEgPSAxIC0gdztcbiAgICAgICAgICB2YXIgdzIgPSB3O1xuXG4gICAgICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogbWlkcHRTcmNQdHM7XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuc2VncHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCxcbiAgICAgICAgICAgIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBTdHJhaWdodCBlZGdlXG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIHBhaXJFZGdlcy5sZW5ndGggJSAyID09PSAxXG4gICAgICAgICYmIGkgPT09IE1hdGguZmxvb3IoIHBhaXJFZGdlcy5sZW5ndGggLyAyIClcbiAgICAgICAgJiYgIWVkZ2VJc1VuYnVuZGxlZFxuICAgICAgKXtcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIChNdWx0aSliZXppZXJcblxuICAgICAgICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSBtdWx0aSA/ICdtdWx0aWJlemllcicgOiAnYmV6aWVyJztcbiAgICAgICAgcnMuY3RybHB0cyA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrICl7XG4gICAgICAgICAgdmFyIG5vcm1jdHJscHREaXN0ID0gKDAuNSAtIHBhaXJFZGdlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZTtcbiAgICAgICAgICB2YXIgbWFuY3RybHB0RGlzdDtcbiAgICAgICAgICB2YXIgc2lnbiA9IG1hdGguc2lnbnVtKCBub3JtY3RybHB0RGlzdCApO1xuXG4gICAgICAgICAgaWYoIG11bHRpICl7XG4gICAgICAgICAgICBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWyBiIF0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuICAgICAgICAgICAgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbIGIgXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7IC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuXG4gICAgICAgICAgdmFyIHcxID0gMSAtIGN0cmxwdFdlaWdodDtcbiAgICAgICAgICB2YXIgdzIgPSBjdHJscHRXZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBtaWRwdFNyY1B0cztcblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5jdHJscHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuXG4gICAgICB2YXIgYmFkU3RhcnQgPSAhaXMubnVtYmVyKCBycy5zdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5zdGFydFkgKTtcbiAgICAgIHZhciBiYWRBU3RhcnQgPSAhaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WCApIHx8ICFpcy5udW1iZXIoIHJzLmFycm93U3RhcnRZICk7XG4gICAgICB2YXIgYmFkRW5kID0gIWlzLm51bWJlciggcnMuZW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmVuZFkgKTtcbiAgICAgIHZhciBiYWRBRW5kID0gIWlzLm51bWJlciggcnMuYXJyb3dFbmRYICkgfHwgIWlzLm51bWJlciggcnMuYXJyb3dFbmRZICk7XG5cbiAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSwgZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZSApXG4gICAgICAgICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgdmFyIHN0YXJ0QUNwRGlzdCA9IG1hdGguZGlzdCggeyB4OiBycy5jdHJscHRzWzBdLCB5OiBycy5jdHJscHRzWzFdIH0sIHsgeDogcnMuc3RhcnRYLCB5OiBycy5zdGFydFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICAgIHZhciBlbmRBQ3BEaXN0ID0gbWF0aC5kaXN0KCB7IHg6IHJzLmN0cmxwdHNbMF0sIHk6IHJzLmN0cmxwdHNbMV0gfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG5cbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heCggc3JjVywgc3JjSCApO1xuICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgICBzcmNXLFxuICAgICAgICAgICAgc3JjSCxcbiAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmKCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KCBzcmNXLCBzcmNIICk7XG4gICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICAgIHRndFcsXG4gICAgICAgICAgICB0Z3RILFxuICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYoIGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG92ZXJsYXBwaW5nICl7XG4gICAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICAgIHJzLmFsbHB0cyA9IFtdO1xuXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5zdGFydFgsIHJzLnN0YXJ0WSApO1xuXG4gICAgICAgIGZvciggdmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIgKXtcbiAgICAgICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5jdHJscHRzWyBiIF0sIHJzLmN0cmxwdHNbIGIgKyAxXSApO1xuXG4gICAgICAgICAgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG4gICAgICAgICAgaWYoIGIgKyAzIDwgcnMuY3RybHB0cy5sZW5ndGggKXtcbiAgICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKCAocnMuY3RybHB0c1sgYiBdICsgcnMuY3RybHB0c1sgYiArIDJdKSAvIDIsIChycy5jdHJscHRzWyBiICsgMV0gKyBycy5jdHJscHRzWyBiICsgM10pIC8gMiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5lbmRYLCBycy5lbmRZICk7XG5cbiAgICAgICAgdmFyIG0sIG10O1xuICAgICAgICBpZiggcnMuY3RybHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICAgICAgICBycy5taWRYID0gcnMuYWxscHRzWyBtIF07XG4gICAgICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1sgbSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICAgICAgbXQgPSAwLjU7XG5cbiAgICAgICAgICBycy5taWRYID0gbWF0aC5xYmV6aWVyQXQoIHJzLmFsbHB0c1sgbSBdLCBycy5hbGxwdHNbIG0gKyAyXSwgcnMuYWxscHRzWyBtICsgNF0sIG10ICk7XG4gICAgICAgICAgcnMubWlkWSA9IG1hdGgucWJlemllckF0KCBycy5hbGxwdHNbIG0gKyAxXSwgcnMuYWxscHRzWyBtICsgM10sIHJzLmFsbHB0c1sgbSArIDVdLCBtdCApO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgKXtcbiAgICAgICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgICAgICBycy5hbGxwdHMgPSBbIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZIF07XG5cbiAgICAgICAgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuICAgICAgICBycy5taWRYID0gKCBycy5zdGFydFggKyBycy5lbmRYICsgcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFggKSAvIDQ7XG4gICAgICAgIHJzLm1pZFkgPSAoIHJzLnN0YXJ0WSArIHJzLmVuZFkgKyBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSApIC8gNDtcblxuICAgICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyApe1xuICAgICAgICBycy5hbGxwdHMgPSBbXTtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLnN0YXJ0WCwgcnMuc3RhcnRZICk7XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoLmFwcGx5KCBycy5hbGxwdHMsIHJzLnNlZ3B0cyApO1xuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuZW5kWCwgcnMuZW5kWSApO1xuXG4gICAgICAgIGlmKCBycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCApe1xuICAgICAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgICAgIHJzLm1pZFggPSAoIHJzLnNlZ3B0c1sgaTEgXSArIHJzLnNlZ3B0c1sgaTIgXSApIC8gMjtcbiAgICAgICAgICBycy5taWRZID0gKCBycy5zZWdwdHNbIGkxICsgMV0gKyBycy5zZWdwdHNbIGkyICsgMV0gKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGkxID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1sgaTEgXTtcbiAgICAgICAgICBycy5taWRZID0gcnMuc2VncHRzWyBpMSArIDFdO1xuICAgICAgICB9XG5cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2plY3RMaW5lcyggZWRnZSApO1xuICAgICAgdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyggZWRnZSApO1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKCBlZGdlICk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKCBlZGdlICk7XG5cbiAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG4gIH0gLy8gZm9yIHBhaXIgaWRzXG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoYXlzdGFja0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVkZ2UgPSBoYXlzdGFja0VkZ2VzWyBpIF07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcnMgPSByc2NyYXRjaDtcblxuICAgIGlmKCAhcnNjcmF0Y2guaGF5c3RhY2sgKXtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2guc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyggYW5nbGUgKSxcbiAgICAgICAgeTogTWF0aC5zaW4oIGFuZ2xlIClcbiAgICAgIH07XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2gudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyggYW5nbGUgKSxcbiAgICAgICAgeTogTWF0aC5zaW4oIGFuZ2xlIClcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoICdoYXlzdGFjay1yYWRpdXMnICkudmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbXG4gICAgICBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsXG4gICAgICBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksXG4gICAgICBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsXG4gICAgICBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnlcbiAgICBdO1xuXG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyO1xuXG4gICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICByc2NyYXRjaC5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgcnNjcmF0Y2guaGF5c3RhY2sgPSB0cnVlO1xuXG4gICAgdGhpcy5wcm9qZWN0TGluZXMoIGVkZ2UgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKCBlZGdlICk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKCBlZGdlICk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyggZWRnZSApO1xuICB9XG59O1xuXG52YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uKCBkaXNwWCwgZGlzcFkgKXtcbiAgcmV0dXJuIE1hdGguYXRhbjIoIGRpc3BZLCBkaXNwWCApIC0gTWF0aC5QSSAvIDI7XG59O1xuXG5CUnAuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnO1xuXG4gIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG5cbiAgdmFyIHNyY1BvcyA9IGVkZ2UuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICB2YXIgdGd0UG9zID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgfVxuXG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTtcblxuICAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiggaXNTZWdtZW50cyApe1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYoIGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IG1hdGgucWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEgKTtcbiAgICB2YXIgYlkgPSBtYXRoLnFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xICk7XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgfVxuXG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyBtaWQgdGFyZ2V0XG4gIC8vXG5cbiAgdmFyIG1pZFggPSBycy5taWRYO1xuICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICBtaWRYID0gKCBzdGFydFggKyBlbmRYICkgLyAyO1xuICAgIG1pZFkgPSAoIHN0YXJ0WSArIGVuZFkgKSAvIDI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiggaXNTZWxmICl7XG4gICAgZGlzcFggPSAtMTtcbiAgICBkaXNwWSA9IDE7XG4gIH0gZWxzZSBpZiggaXNTZWdtZW50cyApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiggcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwICl7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgZGlzcFggPSAoIHB0c1sgaTIgXSAtIHB0c1sgaTEgXSApO1xuICAgICAgZGlzcFkgPSAoIHB0c1sgaTIgKyAxXSAtIHB0c1sgaTEgKyAxXSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gKCBwdHNbIGkyIF0gLSBwdHNbIGkxIF0gKTtcbiAgICAgIGRpc3BZID0gKCBwdHNbIGkyICsgMV0gLSBwdHNbIGkxICsgMV0gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiggY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC4wICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuMCApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgXSwgcHRzWyBpYyBdLCBwdHNbIHAxIF0sIDAuMDAwMSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwICsgMV0sIHB0c1sgaWMgKyAxXSwgcHRzWyBwMSArIDFdLCAwLjAwMDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuICAgICAgdmFyIHAwID0gaWMgLSAyOyAvLyBzdGFydHB0XG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC40OTk5ICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuNDk5OSApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgXSwgcHRzWyBpYyBdLCBwdHNbIHAxIF0sIDAuNSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwICsgMV0sIHB0c1sgaWMgKyAxXSwgcHRzWyBwMSArIDFdLCAwLjUgKTtcbiAgICB9XG5cbiAgICBkaXNwWCA9ICggYnAxeCAtIGJwMHggKTtcbiAgICBkaXNwWSA9ICggYnAxeSAtIGJwMHkgKTtcbiAgfVxuXG4gIHJzLm1pZHRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG5cbiAgaWYoIGlzU2VnbWVudHMgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYoIHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgLy8gYWxyZWFkeSBva1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gLSggcHRzWyBpMyBdIC0gcHRzWyBpMiBdICk7XG4gICAgICBkaXNwWSA9IC0oIHB0c1sgaTMgKyAxXSAtIHB0c1sgaTIgKyAxXSApO1xuICAgIH1cbiAgfVxuXG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyB0YXJnZXRcbiAgLy9cblxuICBpZiggaXNTZWdtZW50cyApe1xuICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1sgcnMuc2VncHRzLmxlbmd0aCAtIDIgXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbIHJzLnNlZ3B0cy5sZW5ndGggLSAxIF07XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0JlemllciApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGwgPSBwdHMubGVuZ3RoO1xuICAgIHZhciBiWCA9IG1hdGgucWJlemllckF0KCBwdHNbbC02XSwgcHRzW2wtNF0sIHB0c1tsLTJdLCAwLjkgKTtcbiAgICB2YXIgYlkgPSBtYXRoLnFiZXppZXJBdCggcHRzW2wtNV0sIHB0c1tsLTNdLCBwdHNbbC0xXSwgMC45ICk7XG5cbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cblxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcCggZGlzcFgsIGRpc3BZICk7XG59O1xuXG5CUnAuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciByb3QgPSBlbGUucHN0eWxlKCAndGV4dC1yb3RhdGlvbicgKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcblxuICBpZiggcm90U3RyID09PSAnbm9uZScgKXtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGUgPSAwO1xuICB9IGVsc2UgaWYoIGlzRWRnZSAmJiByb3RTdHIgPT09ICdhdXRvcm90YXRlJyApe1xuICAgIHJzLmxhYmVsQW5nbGUgPSBNYXRoLmF0YW4oIHJzLm1pZERpc3BZIC8gcnMubWlkRGlzcFggKTtcbiAgICBycy5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBdXRvQW5nbGU7XG4gICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYoIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnICl7XG4gICAgcnMubGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlID0gMDtcbiAgfSBlbHNlIHtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGUgPSByb3QucGZWYWx1ZTtcbiAgfVxufTtcblxuQlJwLm1hbnVhbEVuZHB0VG9QeCA9IGZ1bmN0aW9uKCBub2RlLCBwcm9wICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5wb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuXG4gIGlmKCBwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMiApe1xuICAgIHZhciBwID0gW1xuICAgICAgcHJvcC5wZlZhbHVlWzBdLFxuICAgICAgcHJvcC5wZlZhbHVlWzFdXG4gICAgXTtcblxuICAgIGlmKCBwcm9wLnVuaXRzWzBdID09PSAnJScgKXtcbiAgICAgIHBbMF0gPSBwWzBdICogdztcbiAgICB9XG5cbiAgICBpZiggcHJvcC51bml0c1sxXSA9PT0gJyUnICl7XG4gICAgICBwWzFdID0gcFsxXSAqIGg7XG4gICAgfVxuXG4gICAgcFswXSArPSBucG9zLng7XG4gICAgcFsxXSArPSBucG9zLnk7XG5cbiAgICByZXR1cm4gcDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5nbGUgPSBwcm9wLnBmVmFsdWVbMF07XG5cbiAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCggdywgaCApO1xuXG4gICAgdmFyIHAgPSBbXG4gICAgICBucG9zLnggKyBNYXRoLmNvcyggYW5nbGUgKSAqIGwsXG4gICAgICBucG9zLnkgKyBNYXRoLnNpbiggYW5nbGUgKSAqIGxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIG5vZGUgKSBdLmludGVyc2VjdExpbmUoXG4gICAgICBucG9zLngsIG5wb3MueSxcbiAgICAgIHcsIGgsXG4gICAgICBwWzBdLCBwWzFdLFxuICAgICAgMFxuICAgICk7XG4gIH1cbn07XG5cbkJScC5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW50ZXJzZWN0O1xuXG4gIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICB2YXIgc3JjX3AgPSBzb3VyY2UuX3ByaXZhdGU7XG4gIHZhciB0Z3RfcCA9IHRhcmdldC5fcHJpdmF0ZTtcblxuICB2YXIgc3JjUG9zID0gc3JjX3AucG9zaXRpb247XG4gIHZhciB0Z3RQb3MgPSB0Z3RfcC5wb3NpdGlvbjtcblxuICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UucHN0eWxlKCAndGFyZ2V0LWFycm93LXNoYXBlJyApLnZhbHVlO1xuICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UucHN0eWxlKCAnc291cmNlLWFycm93LXNoYXBlJyApLnZhbHVlO1xuXG4gIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyApLnBmVmFsdWU7XG4gIHZhciBzcmNEaXN0ID0gZWRnZS5wc3R5bGUoICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJyApLnBmVmFsdWU7XG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcblxuICBycy5zcmNNYW5FbmRwdCA9IHNyY01hbkVuZHB0O1xuICBycy50Z3RNYW5FbmRwdCA9IHRndE1hbkVuZHB0O1xuXG4gIHZhciBwMTsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHRhcmdldCBzaWRlXG4gIHZhciBwMjsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHNvdXJjZSBzaWRlXG5cbiAgdmFyIHAxX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHRhcmdldCBzaGFwZVxuICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgaWYoIGJlemllciApe1xuICAgIHZhciBjcFN0YXJ0ID0gWyBycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdIF07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbIHJzLmN0cmxwdHNbIHJzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbIHJzLmN0cmxwdHMubGVuZ3RoIC0gMV0gXSA6IGNwU3RhcnQ7XG5cbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmKCBsaW5lcyApe1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFsgdGd0UG9zLngsIHRndFBvcy55IF0gOiBycy5zZWdwdHMuc2xpY2UoIDAsIDIgKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbIHNyY1Bvcy54LCBzcmNQb3MueSBdIDogcnMuc2VncHRzLnNsaWNlKCBycy5zZWdwdHMubGVuZ3RoIC0gMiApO1xuXG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG5cbiAgaWYoIHRndE1hbkVuZHB0LnZhbHVlID09PSAnaW5zaWRlLXRvLW5vZGUnICl7XG4gICAgaW50ZXJzZWN0ID0gWyB0Z3RQb3MueCwgdGd0UG9zLnkgXTtcbiAgfSBlbHNlIGlmKCB0Z3RNYW5FbmRwdC51bml0cyApe1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KCB0YXJnZXQsIHRndE1hbkVuZHB0ICk7XG4gIH0gZWxzZSBpZiggdGd0TWFuRW5kcHQudmFsdWUgPT09ICdvdXRzaWRlLXRvLWxpbmUnICl7XG4gICAgaW50ZXJzZWN0ID0gcnMudGd0SW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYoIHRndE1hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1ub2RlJyApe1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiggdGd0TWFuRW5kcHQudmFsdWUgPT09ICdvdXRzaWRlLXRvLWxpbmUnICl7XG4gICAgICBwMV9pID0gWyBzcmNQb3MueCwgc3JjUG9zLnkgXTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCB0YXJnZXQgKSBdLmludGVyc2VjdExpbmUoXG4gICAgICB0Z3RQb3MueCxcbiAgICAgIHRndFBvcy55LFxuICAgICAgdGFyZ2V0Lm91dGVyV2lkdGgoKSxcbiAgICAgIHRhcmdldC5vdXRlckhlaWdodCgpLFxuICAgICAgcDFfaVswXSxcbiAgICAgIHAxX2lbMV0sXG4gICAgICAwXG4gICAgKTtcbiAgfVxuXG4gIHZhciBhcnJvd0VuZCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDEsXG4gICAgci5hcnJvd1NoYXBlc1sgdGd0QXJTaGFwZSBdLnNwYWNpbmcoIGVkZ2UgKSArIHRndERpc3RcbiAgKTtcbiAgdmFyIGVkZ2VFbmQgPSBtYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgaW50ZXJzZWN0LFxuICAgIHAxLFxuICAgIHIuYXJyb3dTaGFwZXNbIHRndEFyU2hhcGUgXS5nYXAoIGVkZ2UgKSArIHRndERpc3RcbiAgKTtcblxuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG5cbiAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuXG4gIGlmKCBzcmNNYW5FbmRwdC52YWx1ZSA9PT0gJ2luc2lkZS10by1ub2RlJyApe1xuICAgIGludGVyc2VjdCA9IFsgc3JjUG9zLngsIHNyY1Bvcy55IF07XG4gIH0gZWxzZSBpZiggc3JjTWFuRW5kcHQudW5pdHMgKXtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCggc291cmNlLCBzcmNNYW5FbmRwdCApO1xuICB9IGVsc2UgaWYoIHNyY01hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1saW5lJyApe1xuICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmKCBzcmNNYW5FbmRwdC52YWx1ZSA9PT0gJ291dHNpZGUtdG8tbm9kZScgKXtcbiAgICAgIHAyX2kgPSBwMjtcbiAgICB9IGVsc2UgaWYoIHNyY01hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1saW5lJyApe1xuICAgICAgcDJfaSA9IFsgdGd0UG9zLngsIHRndFBvcy55IF07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggc291cmNlICkgXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgc3JjUG9zLngsXG4gICAgICBzcmNQb3MueSxcbiAgICAgIHNvdXJjZS5vdXRlcldpZHRoKCksXG4gICAgICBzb3VyY2Uub3V0ZXJIZWlnaHQoKSxcbiAgICAgIHAyX2lbMF0sXG4gICAgICBwMl9pWzFdLFxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICB2YXIgYXJyb3dTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDIsXG4gICAgci5hcnJvd1NoYXBlc1sgc3JjQXJTaGFwZSBdLnNwYWNpbmcoIGVkZ2UgKSArIHNyY0Rpc3RcbiAgKTtcbiAgdmFyIGVkZ2VTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDIsXG4gICAgci5hcnJvd1NoYXBlc1sgc3JjQXJTaGFwZSBdLmdhcCggZWRnZSApICsgc3JjRGlzdFxuICApO1xuXG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuXG4gIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuXG4gIGlmKCBoYXNFbmRwdHMgKXtcbiAgICBpZiggIWlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgIWlzLm51bWJlciggcnMuc3RhcnRZICkgfHwgIWlzLm51bWJlciggcnMuZW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmVuZFkgKSApe1xuICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJScC5nZXRBcnJvd1dpZHRoID0gQlJwLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24oIGVkZ2VXaWR0aCwgc2NhbGUgKXtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcblxuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbIGVkZ2VXaWR0aCArICcsICcgKyBzY2FsZSBdO1xuICBpZiggY2FjaGVkVmFsICl7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIGNhY2hlZFZhbCA9ICBNYXRoLm1heCggTWF0aC5wb3coIGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkgKSwgMjkgKSAqIHNjYWxlO1xuICBjYWNoZVsgZWRnZVdpZHRoICsgJywgJyArIHNjYWxlIF0gPSBjYWNoZWRWYWw7XG5cbiAgcmV0dXJuIGNhY2hlZFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uKCB1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVsgdXJsIF07XG5cbiAgaWYoIGNhY2hlICl7XG4gICAgaWYoICFjYWNoZS5pbWFnZS5jb21wbGV0ZSApe1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlID0gaW1hZ2VDYWNoZVsgdXJsIF0gPSBpbWFnZUNhY2hlWyB1cmwgXSB8fCB7fTtcblxuICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcblxuICAgIC8vICMxNTgyIHNhZmFyaSBkb2Vzbid0IGxvYWQgZGF0YSB1cmlzIHdpdGggY3Jvc3NPcmlnaW4gcHJvcGVybHlcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzOTc4XG4gICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKCAwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCApLnRvTG93ZXJDYXNlKCkgPT09IGRhdGFVcmlQcmVmaXg7XG4gICAgaWYoICFpc0RhdGFVcmkgKXtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47IC8vIHByZXZlbnQgdGFpbnRlZCBjYW52YXNcbiAgICB9XG5cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKXsgdGhpcy5pbml0KCBvcHRpb25zICk7IH07XG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuXG5CUnAuY2xpZW50RnVuY3Rpb25zID0gWyAncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnIF07XG5cbkJScC5pbml0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgci5jeSA9IG9wdGlvbnMuY3k7XG5cbiAgci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuXG4gIHIuc2VsZWN0aW9uID0gWyB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdOyAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWdcblxuICByLmJlemllclByb2pQY3RzID0gWyAwLjA1LCAwLjIyNSwgMC40LCAwLjUsIDAuNiwgMC43NzUsIDAuOTUgXTtcblxuICAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcbiAgci5ob3ZlckRhdGEgPSB7ZG93bjogbnVsbCwgbGFzdDogbnVsbCxcbiAgICAgIGRvd25UaW1lOiBudWxsLCB0cmlnZ2VyTW9kZTogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGluaXRpYWxQYW46IFsgbnVsbCwgbnVsbCBdLCBjYXB0dXJlOiBmYWxzZX07XG5cbiAgci5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuXG4gIHIudG91Y2hEYXRhID0ge1xuICAgIHN0YXJ0OiBudWxsLCBjYXB0dXJlOiBmYWxzZSxcblxuICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgIHN0YXJ0UG9zaXRpb246IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG5cbiAgICBub3c6IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdLFxuICAgIGVhcmxpZXI6IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdXG4gIH07XG5cbiAgci5yZWRyYXdzID0gMDtcbiAgci5zaG93RnBzID0gb3B0aW9ucy5zaG93RnBzO1xuICByLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gIHIuaGlkZUxhYmVsc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0O1xuICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICByLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ID0gMSAtIHIubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICByLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG4gIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMgPSB7IC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgYW5pbWF0aW9uczogICA0MDAsXG4gICAgZWxlQ2FsY3M6ICAgICAzMDAsXG4gICAgZWxlVHhyRGVxOiAgICAyMDAsXG4gICAgbHlyVHhyRGVxOiAgICAxMDBcbiAgfTtcblxuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG4gIHIubG9hZCgpO1xufTtcblxuQlJwLm5vdGlmeSA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgdmFyIHR5cGVzO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gIGlmKCB0aGlzLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICBpZiggaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICB0eXBlcyA9IHBhcmFtcy50eXBlO1xuXG4gIH0gZWxzZSB7XG4gICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gIH1cblxuICB2YXIgaGFzID0ge307XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdHlwZSA9IHR5cGVzWyBpIF07XG5cbiAgICBoYXNbIHR5cGUgXSA9IHRydWU7XG4gIH0gLy8gZm9yXG5cbiAgaWYoIGhhc1snZGVzdHJveSddICl7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYoIGhhc1snYWRkJ10gfHwgaGFzWydyZW1vdmUnXSB8fCBoYXNbJ2xvYWQnXSB8fCBoYXNbJ3pvcmRlciddICl7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgfVxuXG4gIGlmKCBoYXNbJ3ZpZXdwb3J0J10gKXtcbiAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gIH1cblxuICBpZiggaGFzWydsb2FkJ10gfHwgaGFzWydyZXNpemUnXSApe1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgci5tYXRjaENhbnZhc1NpemUoIHIuY29udGFpbmVyICk7XG4gIH1cblxuICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG5cbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScC5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIuZGVzdHJveWVkID0gdHJ1ZTtcblxuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzWyBpIF07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcblxuICAgICggdGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lciApLmFwcGx5KCB0Z3QsIGIuYXJncyApO1xuICB9XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcblxuICBpZiggci5yZW1vdmVPYnNlcnZlciApe1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYoIHIuc3R5bGVPYnNlcnZlciApe1xuICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiggci5sYWJlbENhbGNEaXYgKXtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggci5sYWJlbENhbGNEaXYgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2goIGUgKXtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbltcbiAgcmVxdWlyZSggJy4vYXJyb3ctc2hhcGVzJyApLFxuICByZXF1aXJlKCAnLi9jb29yZC1lbGUtbWF0aCcgKSxcbiAgcmVxdWlyZSggJy4vaW1hZ2VzJyApLFxuICByZXF1aXJlKCAnLi9sb2FkLWxpc3RlbmVycycgKSxcbiAgcmVxdWlyZSggJy4vbm9kZS1zaGFwZXMnICksXG4gIHJlcXVpcmUoICcuL3JlZHJhdycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIEJScCwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vZXZlbnQnICk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uKCB0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlICl7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KCBhcmd1bWVudHMsIFsxXSApOyAvLyBjb3B5XG4gIHZhciBiID0gdGhpcy5iaW5kZXIoIHRhcmdldCApO1xuXG4gIHJldHVybiBiLm9uLmFwcGx5KCBiLCBhcmdzICk7XG59O1xuXG5CUnAuYmluZGVyID0gZnVuY3Rpb24oIHRndCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHRndElzRG9tID0gdGd0ID09PSB3aW5kb3cgfHwgdGd0ID09PSBkb2N1bWVudCB8fCB0Z3QgPT09IGRvY3VtZW50LmJvZHkgfHwgaXMuZG9tRWxlbWVudCggdGd0ICk7XG5cbiAgaWYoIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwgKXtcblxuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9ICk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndGVzdCcsIG51bGwsIG9wdHMgKTtcbiAgICB9IGNhdGNoKCBlcnIgKXt9XG5cbiAgICByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZTtcbiAgfVxuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSApe1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gICAgaWYoIHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzICl7IC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGd0LFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuXG4gICAgKCB0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24gKS5hcHBseSggdGd0LCBhcmdzICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBvbixcbiAgICBhZGRFdmVudExpc3RlbmVyOiBvbixcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgYmluZDogb25cbiAgfTtcbn07XG5cbkJScC5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiggbm9kZSApe1xuICByZXR1cm4gKFxuICAgIG5vZGVcbiAgICAmJiBub2RlLmlzTm9kZSgpXG4gICAgJiYgIW5vZGUubG9ja2VkKClcbiAgICAmJiBub2RlLmdyYWJiYWJsZSgpXG4gICk7XG59O1xuXG5CUnAubm9kZUlzR3JhYmJhYmxlID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgcmV0dXJuIChcbiAgICB0aGlzLm5vZGVJc0RyYWdnYWJsZSggbm9kZSApXG4gICAgJiYgbm9kZS5pbnRlcmFjdGl2ZSgpXG4gICk7XG59O1xuXG5CUnAubG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKCB0YXJnZXQsIG5hbWVzLCBlLCBwcm9wcyApe1xuICAgIGlmKCB0YXJnZXQgPT0gbnVsbCApe1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzWyBpIF07XG5cbiAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCggZSwgdXRpbC5leHRlbmQoIHsgdHlwZTogbmFtZSB9LCBwcm9wcyApICk7XG4gICAgICB0YXJnZXQudHJpZ2dlciggZXZlbnQgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiggZSApe1xuICAgIHJldHVybiBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7IC8vIG1heWJlIGUuYWx0S2V5XG4gIH07XG5cbiAgdmFyIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoID0gZnVuY3Rpb24oIGRvd24sIGRvd25zICl7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgaWYoIHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5pc0VkZ2UoKSApe1xuICAgICAgLy8gYSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlZGdlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciggdmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICBpZiggZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG5cbiAgdmFyIGdldERyYWdMaXN0SWRzID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICB2YXIgbGlzdEhhc0lkO1xuXG4gICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmIHIuY3kuaGFzQ29tcG91bmROb2RlcygpICl7IC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgIGlmKCAhb3B0cy5hZGRUb0xpc3QuaGFzSWQgKXsgLy8gYnVpbGQgaWRzIGxvb2t1cCBpZiBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IG9wdHMuYWRkVG9MaXN0WyBpIF07XG5cbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZFsgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdEhhc0lkID0gb3B0cy5hZGRUb0xpc3QuaGFzSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RIYXNJZCB8fCB7fTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEluRHJhZ0xheWVyID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlR3JhYlRhcmdldCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiggZWxlLCBvcHRzICl7XG4gICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICBpZiggIWxpc3RIYXNJZFsgZWxlLmlkKCkgXSApe1xuICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggZWxlICk7XG4gICAgICBsaXN0SGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICBzZXRHcmFiYmVkKCBlbGUgKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24oIG5vZGUsIG9wdHMgKXtcbiAgICBpZiggIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCApe1xuICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgYWRkVG9EcmFnTGlzdCggZWxlLCBvcHRzICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG4gIHZhciBhZGROb2Rlc1RvRHJhZyA9IGZ1bmN0aW9uKCBub2Rlcywgb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBub2Rlcy5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICBub2Rlcy5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuXG4gICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgKXtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICBhZGRUb0RyYWdMaXN0KCBlbGUsIG9wdHMgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKCBub2Rlcywgb3B0cyApOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoIG5vZGVzLCB7XG4gICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgIH0gKTtcblxuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuXG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGdyYWJiZWRFbGVzICl7XG4gICAgaWYoICFncmFiYmVkRWxlcyApeyByZXR1cm47IH1cblxuICAgIGdyYWJiZWRFbGVzLmhhc0lkID0ge307IC8vIGNsZWFyIHRoZSBpZCBsaXN0XG5cbiAgICAvLyBqdXN0IGdvIG92ZXIgYWxsIGVsZW1lbnRzIHJhdGhlciB0aGFuIGRvaW5nIGEgYnVuY2ggb2YgKHBvc3NpYmx5IGV4cGVuc2l2ZSkgdHJhdmVyc2Fsc1xuICAgIHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHNldEZyZWVkKCBlbGUgKTtcbiAgICAgIHNldE91dERyYWdMYXllciggZWxlICk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KCBlbGUgKTtcbiAgICB9KTtcblxuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG4gIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uKCBub2RlLCBvcHRzICl7XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIGlmKCAhbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTtcblxuICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICBpZiggcGFyZW50LnNhbWUoIG5vZGUgKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpXG4gICAgICAubWVyZ2UoIHBhcmVudCApXG4gICAgICAudW5tZXJnZSggbm9kZSApXG4gICAgICAudW5tZXJnZSggbm9kZS5kZXNjZW5kYW50cygpIClcbiAgICA7XG5cbiAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIGVkZ2VzLmZvckVhY2goIHNldEluRHJhZ0xheWVyICk7XG4gICAgICBub2Rlcy5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCApe1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoIGVsZSwgb3B0cyApO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYXZlTXV0YXRpb25zQXBpID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIHdhdGNoIGZvciB3aGVuIHRoZSBjeSBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgaWYoIGhhdmVNdXRhdGlvbnNBcGkgKXtcbiAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIGZ1bmN0aW9uKCBtdXRucyApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBtdXRuID0gbXV0bnNbIGkgXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgIGlmKCByTm9kZXMgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbIGogXTtcblxuICAgICAgICAgIGlmKCByTm9kZSA9PT0gci5jb250YWluZXIgKXtcbiAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBpZiggci5jb250YWluZXIucGFyZW50Tm9kZSApe1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKCByLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0gKTtcbiAgfVxuXG4gIHZhciBvblJlc2l6ZSA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gICAgci5jeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG5cbiAgICByLm1hdGNoQ2FudmFzU2l6ZSggci5jb250YWluZXIgKTtcbiAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gICAgci5yZWRyYXcoKTtcbiAgfSwgMTAwICk7XG5cbiAgaWYoIGhhdmVNdXRhdGlvbnNBcGkgKXtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlciggb25SZXNpemUgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5zdHlsZU9ic2VydmVyLm9ic2VydmUoIHIuY29udGFpbmVyLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSApO1xuICB9XG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICB2YXIgaW52YWxDdG5yQkJPblNjcm9sbCA9IGZ1bmN0aW9uKCBkb21FbGUgKXtcbiAgICByLnJlZ2lzdGVyQmluZGluZyggZG9tRWxlLCAnc2Nyb2xsJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgfSApO1xuICB9O1xuXG4gIHZhciBiYkN0bnIgPSByLmN5LmNvbnRhaW5lcigpO1xuXG4gIGZvciggOzsgKXtcblxuICAgIGludmFsQ3RuckJCT25TY3JvbGwoIGJiQ3RuciApO1xuXG4gICAgaWYoIGJiQ3Ruci5wYXJlbnROb2RlICl7XG4gICAgICBiYkN0bnIgPSBiYkN0bnIucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiggZSApe1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSApO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICB9O1xuXG4gIHZhciBldmVudEluQ29udGFpbmVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG5cbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogWyBlIF07XG4gICAgdmFyIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcblxuICAgICAgaWYoIHggPD0gcC5jbGllbnRYICYmIHAuY2xpZW50WCA8PSB4ICsgd2lkdGhcbiAgICAgICAgJiYgeSA8PSBwLmNsaWVudFkgJiYgcC5jbGllbnRZIDw9IHkgKyBoZWlnaHRcbiAgICAgICl7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIWF0TGVhc3RPbmVQb3NJbnNpZGUgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSggdFBhcmVudCApe1xuICAgICAgaWYoIHRQYXJlbnQgPT09IGNvbnRhaW5lciApe1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmKCAhY29udGFpbmVySXNUYXJnZXQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFByaW1hcnkga2V5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoIGUgKXtcbiAgICBpZiggIWV2ZW50SW5Db250YWluZXIoZSkgKXsgcmV0dXJuOyB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgZ3BvcyA9IFsgZS5jbGllbnRYLCBlLmNsaWVudFkgXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBncG9zWzBdLCBncG9zWzFdICk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyggcG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlICk7XG4gICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24oKXtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KCByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCApO1xuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYoIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICBlbGUudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbiApO1xuICAgIH07XG5cbiAgICAvLyBSaWdodCBjbGljayBidXR0b25cbiAgICBpZiggZS53aGljaCA9PSAzICl7XG5cbiAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICBuZWFyLnRyaWdnZXIoIGN4dEV2dCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgfSBlbHNlIGlmKCBlLndoaWNoID09IDEgKXtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiggbmVhciAhPSBudWxsICl7XG5cbiAgICAgICAgICBpZiggci5ub2RlSXNHcmFiYmFibGUoIG5lYXIgKSApe1xuXG4gICAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24oIHR5cGUgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgICAgIGVsZS50cmlnZ2VyKCBtYWtlRXZlbnQoJ2dyYWInKSApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0R3JhYlRhcmdldCggbmVhciApO1xuXG4gICAgICAgICAgICBpZiggIW5lYXIuc2VsZWN0ZWQoKSApe1xuXG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBtYWtlRXZlbnQoJ2dyYWJvbicpICkudHJpZ2dlciggbWFrZUV2ZW50KCdncmFiJykgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFsgIF07XG5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKCBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoIGVsZSApOyB9ICk7XG5cbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIHNlbGVjdGVkTm9kZXMsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbWFrZUV2ZW50KCdncmFib24nKSApO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCggdHJpZ2dlckdyYWIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3ducyA9IG5lYXJzO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJyBdLCBlLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgPT0gbnVsbCApe1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IGVsc2UgaWYoIG5lYXIuaXNFZGdlKCkgKXtcbiAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgIH1cblxuICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG5cbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcbiAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIG1vdXNlbW92ZUhhbmRsZXIoIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmKCAhY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSApeyByZXR1cm47IH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbIGUuY2xpZW50WCwgZS5jbGllbnRZIF07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZ3Bvc1swXSwgZ3Bvc1sxXSApO1xuICAgIHZhciBtZG93blBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgIHZhciBtZG93bkdQb3MgPSByLmhvdmVyRGF0YS5tZG93bkdQb3M7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgdmFyIG5lYXIgPSBudWxsO1xuICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSApO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgdmFyIGRpc3AgPSBbIHBvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdIF07XG5cbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYoIG1kb3duR1BvcyApe1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuXG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMjtcbiAgICB9XG5cbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKCBlICk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnIF0sIGUsIHtcbiAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICB9ICk7XG5cbiAgICB2YXIgZ29JbnRvQm94TW9kZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgIGN5LnRyaWdnZXIoJ2JveHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH07XG5cbiAgICAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgLy8gYnV0IG9ubHkgaWYgb3ZlciB0aHJlc2hvbGRcbiAgICAgIGlmKCBpc092ZXJUaHJlc2hvbGREcmFnICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICB9IGVsc2UgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7XG4gICAgICAgIHZhciBkZWx0YVA7XG5cbiAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuICl7XG4gICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG5cbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAoIHBvc1swXSAtIG1kUG9zWzBdICkgKiB6b29tLFxuICAgICAgICAgICAgeTogKCBwb3NbMV0gLSBtZFBvc1sxXSApICogem9vbVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnBhbkJ5KCBkZWx0YVAgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcbiAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS5jbGllbnRYLCBlLmNsaWVudFkgKTtcblxuICAgIC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgIH0gZWxzZSBpZihcbiAgICAgICAgc2VsZWN0WzRdID09IDEgJiYgKGRvd24gPT0gbnVsbCB8fCBkb3duLmlzRWRnZSgpKVxuICAgICl7XG5cbiAgICAgIGlmKCBpc092ZXJUaHJlc2hvbGREcmFnICl7XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgKCBtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKSApe1xuICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcblxuICAgICAgICB9IGVsc2UgaWYoICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApe1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goIGRvd24sIHIuaG92ZXJEYXRhLmRvd25zICk7XG5cbiAgICAgICAgICBpZiggYWxsb3dQYXNzdGhyb3VnaCApe1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gbWF0aC5hcnJheTJwb2ludCggbWRvd25Qb3MgKTtcblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZG93biAmJiBkb3duLmlzRWRnZSgpICYmIGRvd24uYWN0aXZlKCkgKXsgZG93bi51bmFjdGl2YXRlKCk7IH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBkb3duICYmIGRvd24uaXNFZGdlKCkgJiYgZG93bi5hY3RpdmUoKSApeyBkb3duLnVuYWN0aXZhdGUoKTsgfVxuXG4gICAgICBpZiggKCAhZG93biB8fCAhZG93bi5ncmFiYmVkKCkgKSAmJiBuZWFyICE9IGxhc3QgKXtcblxuICAgICAgICBpZiggbGFzdCApe1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIGxhc3QsIFsgJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnIF0sIGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlcicgXSwgZSwge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICBpZiggZG93biAmJiByLm5vZGVJc0RyYWdnYWJsZSggZG93biApICl7XG5cbiAgICAgICAgaWYoIGlzT3ZlclRocmVzaG9sZERyYWcgKXsgLy8gdGhlbiB3ZSBjYW4gdGFrZSBhY3Rpb25cblxuICAgICAgICAgIGlmKCBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24gKXsgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiggZG93biAmJiBkb3duLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlbWVudHMgKTtcblxuICAgICAgICAgICAgICBkb3duLnRyaWdnZXIoJ2ZyZWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuXG4gICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGRyYWdcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IFtdO1xuXG4gICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIGN5LmNvbGxlY3Rpb24oIGRyYWdnZWRFbGVtZW50cyApLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRFbGUgPSBkcmFnZ2VkRWxlbWVudHNbIGkgXTtcblxuICAgICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIGRFbGUgKSAmJiBkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKCBkRWxlICk7XG5cbiAgICAgICAgICAgICAgICBpZiggaXMubnVtYmVyKCBkaXNwWzBdICkgJiYgaXMubnVtYmVyKCBkaXNwWzFdICkgKXtcbiAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVQb3MgPSAhZEVsZS5pc1BhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiggdXBkYXRlUG9zICl7XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgZHJhZ0RlbHRhICYmIGlzLm51bWJlciggZHJhZ0RlbHRhWzBdICkgJiYgaXMubnVtYmVyKCBkcmFnRGVsdGFbMV0gKSApe1xuICAgICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciB0Y29sID0gY3kuY29sbGVjdGlvbiggdG9UcmlnZ2VyICk7XG5cbiAgICAgICAgICAgIHRjb2wuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICAgICAgICB0Y29sLnRyaWdnZXIoICdwb3NpdGlvbiBkcmFnJyApO1xuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZWxlY3RbMl0gPSBwb3NbMF07IHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgIGlmKCBwcmV2ZW50RGVmYXVsdCApe1xuICAgICAgaWYoIGUuc3RvcFByb3BhZ2F0aW9uICkgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmKCBlLnByZXZlbnREZWZhdWx0ICkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgZmFsc2UgKTtcblxuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uIG1vdXNldXBIYW5kbGVyKCBlICl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgaWYoICFjYXB0dXJlICl7IHJldHVybjsgfVxuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgIHZhciBjeSA9IHIuY3k7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7IHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UgKTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50czsgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oIGUgKTtcblxuICAgIGlmKCByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG5cbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG5cbiAgICBpZiggZG93biApe1xuICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKCBkb3duICl7XG4gICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgIHZhciBjeHRUYXAgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuXG4gICAgfSBlbHNlIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMSApe1xuXG4gICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgaWYoIChkb3duID09IG51bGwpIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgJiYgIWlzTXVsdFNlbEtleURvd24oIGUgKVxuICAgICAgKXtcblxuICAgICAgICBjeS4kKCBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuc2VsZWN0ZWQoKTsgfSApLnVuc2VsZWN0KCk7XG5cbiAgICAgICAgaWYoIGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnIF0sIGUsIHtcbiAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZihcbiAgICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgKXtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyggZG93biwgWydjbGljaycsICd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgaWYoIG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgaWYoIG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgICAgLy8gaWYgcGFubmluZywgZG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgIH0gZWxzZSBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duICl7XG4gICAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCAhbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgICAgY3kuJCggJzpzZWxlY3RlZCcgKS51bm1lcmdlKCBuZWFyICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oIHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApICk7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICAgIGlmKCBib3gubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS50cmlnZ2VyKCdib3hlbmQnKTtcblxuICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7IH07XG5cbiAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyApe1xuICAgICAgICAgIGJveFxuICAgICAgICAgICAgLnRyaWdnZXIoJ2JveCcpXG4gICAgICAgICAgICAuc3RkRmlsdGVyKCBlbGVXb3VsZEJlU2VsZWN0ZWQgKVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ2JveHNlbGVjdCcpXG4gICAgICAgICAgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCAhbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgIGN5LiQoICc6c2VsZWN0ZWQnICkudW5tZXJnZSggYm94ICkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3hcbiAgICAgICAgICAgIC50cmlnZ2VyKCdib3gnKVxuICAgICAgICAgICAgLnN0ZEZpbHRlciggZWxlV291bGRCZVNlbGVjdGVkIClcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKCdib3hzZWxlY3QnKVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFzZWxlY3RbNF0gKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICB2YXIgZG93bldhc0dyYWJiZWQgPSBkb3duICYmIGRvd24uZ3JhYmJlZCgpO1xuXG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVtZW50cyApO1xuXG4gICAgICAgIGlmKCBkb3duV2FzR3JhYmJlZCApeyBkb3duLnRyaWdnZXIoJ2ZyZWUnKTsgfVxuICAgICAgfVxuXG4gICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgc2VsZWN0WzRdID0gMDsgci5ob3ZlckRhdGEuZG93biA9IG51bGw7XG5cbiAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBudWxsO1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uKCBlICl7XG5cblxuICAgIGlmKCByLnNjcm9sbGluZ1BhZ2UgKXsgcmV0dXJuOyB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS5jbGllbnRYLCBlLmNsaWVudFkgKTtcbiAgICB2YXIgcnBvcyA9IFsgcG9zWzBdICogY3kuem9vbSgpICsgY3kucGFuKCkueCxcbiAgICAgICAgICAgICAgICAgIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnkgXTtcblxuICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpICl7IC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KCByLmRhdGEud2hlZWxUaW1lb3V0ICk7XG4gICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTAgKTtcblxuICAgICAgdmFyIGRpZmY7XG5cbiAgICAgIGlmKCBlLmRlbHRhWSAhPSBudWxsICl7XG4gICAgICAgIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTA7XG4gICAgICB9IGVsc2UgaWYoIGUud2hlZWxEZWx0YVkgIT0gbnVsbCApe1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhWSAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG5cbiAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG4gICAgICBpZiggbmVlZHNXaGVlbEZpeCApeyAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgfVxuXG4gICAgICBjeS56b29tKCB7XG4gICAgICAgIGxldmVsOiBjeS56b29tKCkgKiBNYXRoLnBvdyggMTAsIGRpZmYgKSxcbiAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjogeyB4OiBycG9zWzBdLCB5OiBycG9zWzFdIH1cbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAvLyAtLVxuICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSApO1xuXG4gIC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTW91c2VTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG5cbiAgICBjbGVhclRpbWVvdXQoIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgKTtcbiAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IGZhbHNlO1xuICAgIH0sIDI1MCApO1xuICB9LCB0cnVlICk7XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbiBtb3VzZU91dEhhbmRsZXIoIGUgKXtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLmNsaWVudFgsIGUuY2xpZW50WSApO1xuXG4gICAgci5jeS50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApICk7XG4gIH0sIGZhbHNlICk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlciggZSApe1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7XG5cbiAgICByLmN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApICk7XG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiggeDEsIHkxLCB4MiwgeTIgKXtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkgKTtcbiAgfTtcblxuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICAgIHJldHVybiAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gIH07XG5cbiAgdmFyIHRvdWNoc3RhcnRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbiggZSApe1xuICAgIGlmKCAhZXZlbnRJbkNvbnRhaW5lcihlKSApeyByZXR1cm47IH1cblxuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiggZS50b3VjaGVzWzBdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSApOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmKCBlLnRvdWNoZXNbMV0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZICk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1syXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkgKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICBpZiggZS50b3VjaGVzWzFdICl7XG5cbiAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyApO1xuXG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcblxuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID1cbiAgICAgICAgICAgMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgO1xuXG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgY2VudGVyMSA9IFsgKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyIF07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbXG4gICAgICAgIChjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXG4gICAgICBdO1xuXG4gICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG4gICAgICBpZiggZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSApe1xuXG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSApO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggbm93WzJdLCBub3dbM10sIHRydWUsIHRydWUgKTtcblxuICAgICAgICBpZiggbmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkgKXtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuXG4gICAgICAgIH0gZWxzZSBpZiggbmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkgKXtcbiAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKCBlLnRvdWNoZXNbMl0gKXtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzFdICl7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9IGVsc2UgaWYoIGUudG91Y2hlc1swXSApe1xuICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSApO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcblxuICAgICAgaWYoIG5lYXIgIT0gbnVsbCApe1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICBpZiggci5ub2RlSXNHcmFiYmFibGUoIG5lYXIgKSApe1xuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gW107XG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjeS4kKCBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZSggZWxlICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKCBzZWxlY3RlZE5vZGVzLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEdyYWJUYXJnZXQoIG5lYXIgKTtcblxuICAgICAgICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiggdHlwZSApe1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5lYXIudHJpZ2dlciggbWFrZUV2ZW50KCdncmFib24nKSApXG5cbiAgICAgICAgICBpZiggc2VsZWN0ZWROb2RlcyApe1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBuICl7IG4udHJpZ2dlciggbWFrZUV2ZW50KCdncmFiJykgKTsgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbWFrZUV2ZW50KCdncmFiJykgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJyBdLCBlLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgPT0gbnVsbCApe1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBUYXAsIHRhcGhvbGRcbiAgICAgIC8vIC0tLS0tXG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgKTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZVxuICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICl7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyggci50b3VjaERhdGEuc3RhcnQsIFsgJ3RhcGhvbGQnIF0sIGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICBpZiggIXIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgICBjeS4kKCAnOnNlbGVjdGVkJyApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uICk7XG4gICAgfVxuXG4gICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPj0gMSApe1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuXG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFsgdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZIF07XG4gICAgfVxuXG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiggIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzBdICYmIHN0YXJ0R1BvcyApe1xuICAgICAgdmFyIGRpc3AgPSBbXTsgZm9yICh2YXIgaj0wO2o8bm93Lmxlbmd0aDtqKyspIHsgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07IH1cbiAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuXG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG4gICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuXG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgIGlmKCBmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EgKXtcbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG5cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnRcbiAgICAgICAgICAgIC51bmFjdGl2YXRlKClcbiAgICAgICAgICAgIC50cmlnZ2VyKCBjeHRFdnQgKVxuICAgICAgICAgIDtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZVxuICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgdmFyIGN4dEV2dCA9IG5ldyBFdmVudCggZSwge1xuICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSApO1xuXG4gICAgICBpZiggIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAvLyBib3ggc2VsZWN0aW9uXG4gICAgfSBlbHNlIGlmKCBjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGlmKCAhci50b3VjaERhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgIGN5LnRyaWdnZXIoJ2JveHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgaWYoICFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzICsgMTtcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXcoKTtcblxuICAgIC8vIHBpbmNoIHRvIHpvb21cbiAgICB9IGVsc2UgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApeyAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgaWYoIGRyYWdnZWRFbGVzICl7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG5cbiAgICAgICAgICBkZV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBkZV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cblxuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgaWYoIHR3b0ZpbmdlcnNTdGFydEluc2lkZSApe1xuICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7XG5cbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyIDJcbiAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTtcblxuICAgICAgICAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG4gICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkgLyAyO1xuICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpIC8gMjtcblxuICAgICAgICAvLyBhZGp1c3QgZmFjdG9yIGJ5IHRoZSBzcGVlZCBtdWx0aXBsaWVyXG4gICAgICAgIC8vIHZhciBzcGVlZCA9IDEuNTtcbiAgICAgICAgLy8gaWYoIGZhY3RvciA+IDEgKXtcbiAgICAgICAgLy8gICBmYWN0b3IgPSAoZmFjdG9yIC0gMSkgKiBzcGVlZCArIDE7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgZmFjdG9yID0gMSAtICgxIC0gZmFjdG9yKSAqIHNwZWVkO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgIC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuXG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgJiYgci50b3VjaERhdGEuc3RhcnQuYWN0aXZlKCkgKXtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlcyApO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnRcbiAgICAgICAgICAgIC51bmFjdGl2YXRlKClcbiAgICAgICAgICAgIC50cmlnZ2VyKCAnZnJlZScgKVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnZpZXdwb3J0KCB7XG4gICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICBmMnkxID0gZjJ5MjtcblxuICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgaWYoIGUudG91Y2hlc1swXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkgKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgIGlmKCBlLnRvdWNoZXNbMV0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZICk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgfSBlbHNlIGlmKCBlLnRvdWNoZXNbMF0gKXtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgdmFyIG5lYXI7XG5cbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyApe1xuICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnZ2luZyBub2Rlc1xuICAgICAgaWYoIGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCAmJiByLm5vZGVJc0RyYWdnYWJsZSggc3RhcnQgKSApe1xuXG4gICAgICAgIGlmKCBpc092ZXJUaHJlc2hvbGREcmFnICl7IC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKCBjeS5jb2xsZWN0aW9uKCBkcmFnZ2VkRWxlcyApLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZSA9IGRyYWdnZWRFbGVzWyBrIF07XG5cbiAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZSggZHJhZ2dlZEVsZSApICYmIGRyYWdnZWRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBkUG9zID0gZHJhZ2dlZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBvcyA9ICFkcmFnZ2VkRWxlLmlzUGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBpcy5udW1iZXIoIGRpc3BbMF0gKSAmJiBpcy5udW1iZXIoIGRpc3BbMV0gKSApe1xuICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBkcmFnRGVsdGEgJiYgaXMubnVtYmVyKCBkcmFnRGVsdGFbMF0gKSAmJiBpcy5udW1iZXIoIGRyYWdEZWx0YVsxXSApICl7XG4gICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0Y29sID0gY3kuY29sbGVjdGlvbiggZHJhZ2dlZEVsZXMgKTtcblxuICAgICAgICAgIHRjb2wuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICAgICAgdGNvbC50cmlnZ2VyKCAncG9zaXRpb24gZHJhZycgKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF1cbiAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXVxuICAgICAgICAgICl7XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRvdWNobW92ZVxuICAgICAge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKCAoc3RhcnQgfHwgbmVhciksIFsgJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnIF0sIGUsIHtcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggKCAhc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSApICYmIG5lYXIgIT0gbGFzdCApe1xuICAgICAgICAgIGlmKCBsYXN0ICl7IGxhc3QudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7IHR5cGU6ICd0YXBkcmFnb3V0JywgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9ICkgKTsgfVxuICAgICAgICAgIGlmKCBuZWFyICl7IG5lYXIudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7IHR5cGU6ICd0YXBkcmFnb3ZlcicsIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSApICk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuICAgICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBpZiggbm93WyBpIF1cbiAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bIGkgXVxuICAgICAgICAgICAgJiYgaXNPdmVyVGhyZXNob2xkRHJhZyApe1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFubmluZ1xuICAgICAgaWYoXG4gICAgICAgICAgY2FwdHVyZVxuICAgICAgICAgICYmICggc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5pc0VkZ2UoKSApXG4gICAgICAgICAgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKVxuICAgICAgKXtcblxuICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKCBzdGFydCwgci50b3VjaERhdGEuc3RhcnRzICk7XG5cbiAgICAgICAgaWYoIGFsbG93UGFzc3Rocm91Z2ggKXtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiggci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgICAgIGN5LnBhbkJ5KCB7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgfSBlbHNlIGlmKCBpc092ZXJUaHJlc2hvbGREcmFnICl7XG4gICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGN5LnBhbkJ5KCB7XG4gICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYoICFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBtYXRoLmFycmF5MnBvaW50KCByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkgKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKysgKXsgZWFybGllclsgaiBdID0gbm93WyBqIF07IH1cbiAgICAvL3IucmVkcmF3KCk7XG5cbiAgfSwgZmFsc2UgKTtcblxuICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiggc3RhcnQgKXtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH0gKTtcblxuICB2YXIgdG91Y2hlbmRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiggY2FwdHVyZSApe1xuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgaWYoIHN0YXJ0ICl7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eFRhcGVuZDtcbiAgICBpZiggci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBjdHhUYXBlbmQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcGVuZCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICB2YXIgY3R4VGFwID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcblxuICAgICAgci5yZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG4gICAgaWYoICFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZyApe1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG5cbiAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKCByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKSApO1xuXG4gICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgIGN5LnRyaWdnZXIoJ2JveGVuZCcpO1xuXG4gICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7IH07XG5cbiAgICAgIGJveFxuICAgICAgICAudHJpZ2dlcignYm94JylcbiAgICAgICAgLnN0ZEZpbHRlciggZWxlV291bGRCZVNlbGVjdGVkIClcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAudHJpZ2dlcignYm94c2VsZWN0JylcbiAgICAgIDtcblxuICAgICAgaWYoIGJveC5ub25lbXB0eSgpICl7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiggZS50b3VjaGVzWzJdICl7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgfSBlbHNlIGlmKCBlLnRvdWNoZXNbMV0gKXtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzBdICl7XG4gICAgICAvLyBpZ25vcmVcblxuICAgIC8vIExhc3QgdG91Y2ggcmVsZWFzZWRcbiAgICB9IGVsc2UgaWYoICFlLnRvdWNoZXNbMF0gKXtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgIGlmKCBzdGFydCAhPSBudWxsICl7XG5cbiAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG5cbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZXMgKTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuXG4gICAgICAgIGlmKCBzdGFydFdhc0dyYWJiZWQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCAnZnJlZScgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFdmVudHMoIHN0YXJ0LCBbICd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCcgXSwgZSwge1xuICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlICk7XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnIF0sIGUsIHtcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGxcbiAgICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBkcmFnIG5vZGVzIGFyb3VuZFxuICAgICAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGVcbiAgICAgICAgICAmJiByZGlzdDIgPCByLnRvdWNoVGFwVGhyZXNob2xkMlxuICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICApe1xuXG4gICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgY3kuJCggJzpzZWxlY3RlZCcgKS51bm1lcmdlKCBzdGFydCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIHN0YXJ0LnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkICl7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoIHN0YXJ0LCBbICd0YXAnLCAndmNsaWNrJyBdLCBlLCB7XG4gICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrICl7IGVhcmxpZXJbIGogXSA9IG5vd1sgaiBdOyB9XG5cbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgbW91c2Vkb3duXG5cbiAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA8IDIgKXtcbiAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8vci5yZWRyYXcoKTtcblxuICB9LCBmYWxzZSApO1xuXG4gIC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG4gIGlmKCB0eXBlb2YgVG91Y2hFdmVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcblxuICAgIHZhciBwb2ludGVycyA9IFtdO1xuXG4gICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgIHJhZGl1c1g6IGUud2lkdGggLyAyLFxuICAgICAgICByYWRpdXNZOiBlLmhlaWdodCAvIDIsXG4gICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbWFrZVBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIHRvdWNoOiBtYWtlVG91Y2goIGUgKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgcG9pbnRlcnMucHVzaCggbWFrZVBvaW50ZXIoIGUgKSApO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnNbIGkgXTtcblxuICAgICAgICBpZiggcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkICl7XG4gICAgICAgICAgcG9pbnRlcnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHZhciBwID0gcG9pbnRlcnMuZmlsdGVyKCBmdW5jdGlvbiggcCApe1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSApWzBdO1xuXG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goIGUgKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRvdWNoZXNUb0V2ZW50ID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcCggZnVuY3Rpb24oIHAgKXtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9ICk7XG4gICAgfTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIGlmKCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBhZGRQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaHN0YXJ0SGFuZGxlciggZSApO1xuICAgIH0gKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBpZiggZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNoZW5kSGFuZGxlciggZSApO1xuICAgIH0gKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBmdW5jdGlvbiggZSApe1xuICAgICAgaWYoIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaGNhbmNlbEhhbmRsZXIoIGUgKTtcbiAgICB9ICk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdwb2ludGVybW92ZScsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBpZiggZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdXBkYXRlUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2htb3ZlSGFuZGxlciggZSApO1xuICAgIH0gKTtcblxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAuZ2VuZXJhdGVQb2x5Z29uID0gZnVuY3Rpb24oIG5hbWUsIHBvaW50cyApe1xuICByZXR1cm4gKCB0aGlzLm5vZGVTaGFwZXNbIG5hbWUgXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcblxuICAgIG5hbWU6IG5hbWUsXG5cbiAgICBwb2ludHM6IHBvaW50cyxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoICdwb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgcmV0dXJuIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgICAgeCwgeSxcbiAgICAgICAgICB0aGlzLnBvaW50cyxcbiAgICAgICAgICBub2RlWCxcbiAgICAgICAgICBub2RlWSxcbiAgICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgICAgcGFkZGluZyApXG4gICAgICAgIDtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcbiAgICAgIHJldHVybiBtYXRoLnBvaW50SW5zaWRlUG9seWdvbiggeCwgeSwgdGhpcy5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcgKVxuICAgICAgO1xuICAgIH1cbiAgfSApO1xufTtcblxuQlJwLmdlbmVyYXRlRWxsaXBzZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAoIHRoaXMubm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ2VsbGlwc2UnLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCggdGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcgKXtcbiAgICAgIHJldHVybiBtYXRoLmludGVyc2VjdExpbmVFbGxpcHNlKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiArIHBhZGRpbmcsXG4gICAgICAgIGhlaWdodCAvIDIgKyBwYWRkaW5nIClcbiAgICAgIDtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcbiAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgIHkgLT0gY2VudGVyWTtcblxuICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG5cbiAgICAgIHJldHVybiB4ICogeCArIHkgKiB5IDw9IDE7XG4gICAgfVxuICB9ICk7XG59O1xuXG5CUnAuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAoIHRoaXMubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcblxuICAgIG5hbWU6ICdyb3VuZHJlY3RhbmdsZScsXG5cbiAgICBwb2ludHM6IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA0LCAwICksXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgcmV0dXJuIG1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIHBhZGRpbmcgKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICAvLyBMb29rcyBsaWtlIHRoZSB3aWR0aCBwYXNzZWQgaW50byB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IHRoZSB0b3RhbCB3aWR0aCAvIDJcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcblxuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBjb3JuZXJSYWRpdXMsIFswLCAtMV0sIHBhZGRpbmcgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY29ybmVyUmFkaXVzLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24oIHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKXtcbiAgICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgICB5IC09IGNlbnRlclk7XG5cbiAgICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcblxuICAgICAgICByZXR1cm4gKHggKiB4ICsgeSAqIHkgPD0gMSk7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmKCBjaGVja0luRWxsaXBzZSggeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcgKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9ICk7XG59O1xuXG5CUnAuZ2VuZXJhdGVDdXRSZWN0YW5nbGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKCB0aGlzLm5vZGVTaGFwZXNbJ2N1dHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ2N1dHJlY3RhbmdsZScsXG5cbiAgICBjb3JuZXJMZW5ndGg6IG1hdGguZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCksXG5cbiAgICBwb2ludHM6IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA0LCAwICksXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVDdXRUcmlhbmdsZVB0czogZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcbiAgICAgIHZhciBjbCA9IHRoaXMuY29ybmVyTGVuZ3RoO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcblxuICAgICAgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIHRyaWFuZ2xlIHB0IG9uIFs0LCA1XVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogWyB4QmVnaW4sIHlCZWdpbiArIGNsLCB4QmVnaW4gKyBjbCwgeUJlZ2luLCB4QmVnaW4gKyBjbCwgeUJlZ2luICsgY2wgXSxcbiAgICAgICAgdG9wUmlnaHQ6IFsgeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsIF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbIHhFbmQsIHlFbmQgLSBjbCwgeEVuZCAtIGNsLCB5RW5kLCB4RW5kIC0gY2wsIHlFbmQgLSBjbCBdLFxuICAgICAgICBib3R0b21MZWZ0OiBbIHhCZWdpbiArIGNsLCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBjbCwgeEJlZ2luICsgY2wsIHlFbmQgLSBjbCBdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICB2YXIgY1B0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyggd2lkdGggKyAyKnBhZGRpbmcsIGhlaWdodCsyKnBhZGRpbmcsIG5vZGVYLCBub2RlWSApO1xuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdC5hcHBseShbXSxcbiAgICAgICBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksXG4gICAgICAgICBjUHRzLmJvdHRvbVJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21MZWZ0LnNwbGljZSgwLCA0KVxuICAgICAgIF0pO1xuXG4gICAgICByZXR1cm4gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkgKTtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmKCBtYXRoLnBvaW50SW5zaWRlUG9seWdvbiggeCwgeSwgdGhpcy5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIFswLCAtMV0sIHBhZGRpbmcgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyApICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGN1dFRyaWFuZ2xlUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgcmV0dXJuIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BMZWZ0KVxuICAgICAgIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BSaWdodCApXG4gICAgICAgfHwgbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbVJpZ2h0IClcbiAgICAgICB8fCBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCApO1xuICAgIH1cblxuICB9ICk7XG59O1xuXG5CUnAuZ2VuZXJhdGVCYXJyZWwgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKCB0aGlzLm5vZGVTaGFwZXNbJ2JhcnJlbCddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ2JhcnJlbCcsXG5cbiAgICBwb2ludHM6IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA0LCAwICksXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgcmV0dXJuIG1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIHBhZGRpbmcgKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICAvLyBMb29rcyBsaWtlIHRoZSB3aWR0aCBwYXNzZWQgaW50byB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IHRoZSB0b3RhbCB3aWR0aCAvIDJcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcblxuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBjb3JuZXJSYWRpdXMsIFswLCAtMV0sIHBhZGRpbmcgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY29ybmVyUmFkaXVzLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24oIHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKXtcbiAgICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgICB5IC09IGNlbnRlclk7XG5cbiAgICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcblxuICAgICAgICByZXR1cm4gKHggKiB4ICsgeSAqIHkgPD0gMSk7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmKCBjaGVja0luRWxsaXBzZSggeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcgKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9ICk7XG59O1xuXG5cbkJScC5yZWdpc3Rlck5vZGVTaGFwZXMgPSBmdW5jdGlvbigpe1xuICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIHRoaXMuZ2VuZXJhdGVFbGxpcHNlKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICd0cmlhbmdsZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCAzLCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3JlY3RhbmdsZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA0LCAwICkgKTtcbiAgbm9kZVNoYXBlc1sgJ3NxdWFyZScgXSA9IG5vZGVTaGFwZXNbICdyZWN0YW5nbGUnIF07XG5cbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZUN1dFJlY3RhbmdsZSgpO1xuXG4gIHRoaXMuZ2VuZXJhdGVCYXJyZWwoKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ2RpYW1vbmQnLCBbXG4gICAgMCwgMSxcbiAgICAxLCAwLFxuICAgIDAsIC0xLFxuICAgIC0xLCAwXG4gIF0gKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3BlbnRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDUsIDAgKSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAnaGV4YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA2LCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ2hlcHRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDcsIDAgKSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAnb2N0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA4LCAwICkgKTtcblxuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoIDIwICk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIDUsIDAgKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIDUsIE1hdGguUEkgLyA1ICk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KCA1ICkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG5cbiAgICBmb3IoIHZhciBpID0gMDtpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjtpKysgKXtcbiAgICAgIGlubmVyUG9pbnRzWyBpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1sgaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDtpIDwgMjAgLyA0O2krKyApe1xuICAgICAgc3RhcjVQb2ludHNbIGkgKiA0XSA9IG91dGVyUG9pbnRzWyBpICogMl07XG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzWyBpICogMiArIDFdO1xuXG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAyXSA9IGlubmVyUG9pbnRzWyBpICogMl07XG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAzXSA9IGlubmVyUG9pbnRzWyBpICogMiArIDFdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXI1UG9pbnRzID0gbWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHN0YXI1UG9pbnRzICk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICdzdGFyJywgc3RhcjVQb2ludHMgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3ZlZScsIFtcbiAgICAtMSwgLTEsXG4gICAgMCwgLTAuMzMzLFxuICAgIDEsIC0xLFxuICAgIDAsIDFcbiAgXSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAncmhvbWJvaWQnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAuMzMzLCAtMSxcbiAgICAxLCAxLFxuICAgIC0wLjMzMywgMVxuICBdICk7XG5cbiAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcblxuICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuXG4gICAgdmFyIGtleSA9IHBvaW50cy5qb2luKCAnJCcgKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgaWYoIChzaGFwZSA9IHRoaXNbIG5hbWUgXSkgKXsgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbiggbmFtZSwgcG9pbnRzICk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcblxuQlJwLnJlZHJhdyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYoIHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDsgfVxuICBpZiggci5sYXN0UmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHIubGFzdFJlZHJhd1RpbWUgPSAwOyB9XG4gIGlmKCByLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHIubGFzdERyYXdUaW1lID0gMDsgfVxuXG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuQlJwLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uKCBmbiwgcHJpb3JpdHkgKXtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiggdGhpcy5kZXN0cm95ZWQgKXsgcmV0dXJuOyB9XG5cbiAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXG4gIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcblxuICBjYnMucHVzaCh7IGZuOiBmbiwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuXG4gIC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcbiAgY2JzLnNvcnQoZnVuY3Rpb24oIGEsIGIgKXsgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5OyB9KTtcbn07XG5cbnZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiggciwgd2lsbERyYXcsIHN0YXJ0VGltZSApe1xuICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKysgKXtcbiAgICBjYnNbaV0uZm4oIHdpbGxEcmF3LCBzdGFydFRpbWUgKTtcbiAgfVxufTtcblxuQlJwLnN0YXJ0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcztcblxuICBpZiggci5yZW5kZXJMb29wU3RhcnRlZCApe1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uKCByZXF1ZXN0VGltZSApe1xuICAgIGlmKCByLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICAgIGlmKCByLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSApe1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKCByLCB0cnVlLCByZXF1ZXN0VGltZSApO1xuXG4gICAgICB2YXIgc3RhcnRUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICByLnJlbmRlciggci5yZW5kZXJPcHRpb25zICk7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gci5sYXN0RHJhd1RpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgaWYoIHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuXG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyggciwgZmFsc2UsIHJlcXVlc3RUaW1lICk7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuICB9O1xuXG4gIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24oIG5hbWUgKXtcbiAgcmV0dXJuICggaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAncG9seWdvbic6IGZ1bmN0aW9uKCBjb250ZXh0LCBwb2ludHMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1sgaSBdO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICd0cmlhbmdsZS1iYWNrY3VydmUnOiBmdW5jdGlvbiggY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQgKXtcbiAgICAgIHZhciBmaXJzdFB0O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbIGkgXTtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSApO1xuICAgIH0sXG5cbiAgICAndHJpYW5nbGUtdGVlJzogZnVuY3Rpb24oIGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMgKXtcbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRyaVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiggY29udGV4dC5jbG9zZVBhdGggKXsgY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gICAgICAgIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRlZVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLWNyb3NzJzogZnVuY3Rpb24oIGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCBjcm9zc0xpbmVQb2ludHMgKXtcbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRyaVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiggY29udGV4dC5jbG9zZVBhdGggKXsgY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXG5cbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSBjcm9zc0xpbmVQb2ludHM7XG4gICAgICB2YXIgZmlyc3RUZWVQdCA9IGNyb3NzTGluZVBvaW50c1swXTtcbiAgICAgIGNvbnRleHQubW92ZVRvKCBmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNyb3NzTGluZVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBjcm9zc0xpbmVQdHNbIGkgXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cbiAgICB9LFxuXG4gICAgJ2NpcmNsZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCByeCwgcnksIHIgKXtcbiAgICAgIGNvbnRleHQuYXJjKCByeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSApO1xuICAgIH1cbiAgfSkgKVsgbmFtZSBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmRyYXdFZGdlID0gZnVuY3Rpb24oIGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGRyYXdMYWJlbCwgZHJhd092ZXJsYXlJbnN0ZWFkICl7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuICBpZiggcnMuYmFkTGluZSB8fCBpc05hTihycy5hbGxwdHNbMF0pICl7IC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCAhZWRnZS52aXNpYmxlKCkgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIGJiO1xuICBpZiggc2hpZnRUb09yaWdpbldpdGhCYiApe1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKCAtYmIueDEsIC1iYi55MSApO1xuICB9XG5cbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gZWRnZS5wc3R5bGUoICdvdmVybGF5LXBhZGRpbmcnICkucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gZWRnZS5wc3R5bGUoICdvdmVybGF5LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBlZGdlLnBzdHlsZSggJ292ZXJsYXktY29sb3InICkudmFsdWU7XG5cbiAgLy8gRWRnZSBjb2xvciAmIG9wYWNpdHlcbiAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApe1xuXG4gICAgaWYoIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgbm8gb3ZlcmxheVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5ICk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PSAnc2VsZicgJiYgIXVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVkZ2UucHN0eWxlKCAnbGluZS1jb2xvcicgKS52YWx1ZTtcblxuICAgIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIGVkZ2UucHN0eWxlKCAnb3BhY2l0eScgKS52YWx1ZSApO1xuXG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9XG5cbiAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSArIChkcmF3T3ZlcmxheUluc3RlYWQgPyAyICogb3ZlcmxheVBhZGRpbmcgOiAwKTtcbiAgdmFyIGxpbmVTdHlsZSA9IGRyYXdPdmVybGF5SW5zdGVhZCA/ICdzb2xpZCcgOiBlZGdlLnBzdHlsZSggJ2xpbmUtc3R5bGUnICkudmFsdWU7XG4gIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoO1xuXG4gIHRoaXMuZHJhd0VkZ2VQYXRoKFxuICAgIGVkZ2UsXG4gICAgY29udGV4dCxcbiAgICBycy5hbGxwdHMsXG4gICAgbGluZVN0eWxlLFxuICAgIGVkZ2VXaWR0aFxuICApO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZHMoIGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCApO1xuXG4gIGlmKCAhZHJhd092ZXJsYXlJbnN0ZWFkICl7XG4gICAgdGhpcy5kcmF3RWRnZSggY29udGV4dCwgZWRnZSwgZmFsc2UsIGRyYXdMYWJlbCwgdHJ1ZSApO1xuICB9XG5cbiAgdGhpcy5kcmF3RWxlbWVudFRleHQoIGNvbnRleHQsIGVkZ2UsIGRyYXdMYWJlbCApO1xuXG4gIGlmKCBzaGlmdFRvT3JpZ2luV2l0aEJiICl7XG4gICAgY29udGV4dC50cmFuc2xhdGUoIGJiLngxLCBiYi55MSApO1xuICB9XG59O1xuXG5cbkNScC5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiggZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlLCB3aWR0aCApe1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbiggJyQnICk7XG4gICAgdmFyIGtleU1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXk7XG5cbiAgICBpZigga2V5TWF0Y2hlcyApe1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY2FudmFzQ3h0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKCBbIDEsIDEgXSApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKCBbIDYsIDMgXSApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goIFsgXSApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSApe1xuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgY29udGV4dC5tb3ZlVG8oIHB0c1swXSwgcHRzWzFdICk7XG5cbiAgICBzd2l0Y2goIHJzLmVkZ2VUeXBlICl7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGZvciggdmFyIGkgPSAyOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gNCApe1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggcHRzWyBpIF0sIHB0c1sgaSArIDFdLCBwdHNbIGkgKyAyXSwgcHRzWyBpICsgM10gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBmb3IoIHZhciBpID0gMjsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyggcHRzWyBpIF0sIHB0c1sgaSArIDFdICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0N4dDtcbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG4gIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgXSApO1xuICB9XG5cbn07XG5cbkNScC5kcmF3QXJyb3doZWFkcyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQgKXtcbiAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApeyByZXR1cm47IH0gLy8gZG9uJ3QgZG8gYW55dGhpbmcgZm9yIG92ZXJsYXlzXG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcblxuICBpZiggIWlzSGF5c3RhY2sgKXtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICdzb3VyY2UnLCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHJzLnNyY0Fycm93QW5nbGUgKTtcbiAgfVxuXG4gIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ21pZC10YXJnZXQnLCBycy5taWRYLCBycy5taWRZLCBycy5taWR0Z3RBcnJvd0FuZ2xlICk7XG5cbiAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUgKTtcblxuICBpZiggIWlzSGF5c3RhY2sgKXtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICd0YXJnZXQnLCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgcnMudGd0QXJyb3dBbmdsZSApO1xuICB9XG59O1xuXG5DUnAuZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlICl7XG4gIGlmKCBpc05hTiggeCApIHx8IHggPT0gbnVsbCB8fCBpc05hTiggeSApIHx8IHkgPT0gbnVsbCB8fCBpc05hTiggYW5nbGUgKSB8fCBhbmdsZSA9PSBudWxsICl7IHJldHVybjsgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFycm93U2hhcGUgPSBlZGdlLnBzdHlsZSggcHJlZml4ICsgJy1hcnJvdy1zaGFwZScgKS52YWx1ZTtcbiAgaWYoIGFycm93U2hhcGUgPT09ICdub25lJyApIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctZmlsbCcgKS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgdmFyIGFycm93RmlsbCA9IGVkZ2UucHN0eWxlKCBwcmVmaXggKyAnLWFycm93LWZpbGwnICkudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSggJ3dpZHRoJyApLnBmVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gZWRnZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlO1xuXG4gIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICB2YXIgc2hhcGVJbXBsID0gc2VsZi5hcnJvd1NoYXBlc1sgYXJyb3dTaGFwZSBdO1xuXG4gIC8vIGNoZWNrIGlmIHRoZSBzaGFwZSBuZWVkcyBib3RoIGZpbGwgYW5kIHN0cm9rZSBvcGVyYXRpb25zIHRvIGJlIGRyYXduXG4gIGlmKCBzaGFwZUltcGwuZm9yY2VTdHJva2UgJiYgYXJyb3dGaWxsID09PSAnZmlsbGVkJyApe1xuICAgIGFycm93RmlsbCA9ICdib3RoJztcbiAgfVxuXG4gIGlmKCBvcGFjaXR5ICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycgKXsgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgc2VsZi5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEgKTtcbiAgICBzZWxmLnN0cm9rZVN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxICk7XG5cbiAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsXG4gICAgICBhcnJvd0NsZWFyRmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZVxuICAgICk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cbiAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctY29sb3InICkudmFsdWU7XG4gIHNlbGYuZmlsbFN0eWxlKCBjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5ICk7XG4gIHNlbGYuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkgKTtcblxuICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsXG4gICAgYXJyb3dGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIHgsIHksIGFuZ2xlXG4gICk7XG59O1xuXG5DUnAuZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbiggZWRnZSwgYXJyb3dUeXBlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7IHg6IHgsIHk6IHkgfTtcbiAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZTtcbiAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2VXaWR0aCwgc2NhbGUgKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbIHNoYXBlIF07XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHNpemUgKyAnJCcgKyBzaGFwZSArICckJyArIGFuZ2xlICsgJyQnICsgeCArICckJyArIHk7XG4gICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXkgPSBycy5hcnJvd1BhdGhDYWNoZUtleSB8fCB7fTtcbiAgICBycy5hcnJvd1BhdGhDYWNoZSA9IHJzLmFycm93UGF0aENhY2hlIHx8IHt9O1xuXG4gICAgdmFyIGFscmVhZHlDYWNoZWQgPSBycy5hcnJvd1BhdGhDYWNoZUtleVsgYXJyb3dUeXBlIF0gPT09IHBhdGhDYWNoZUtleTtcbiAgICBpZiggYWxyZWFkeUNhY2hlZCApe1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5hcnJvd1BhdGhDYWNoZVsgYXJyb3dUeXBlIF07XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXlbIGFycm93VHlwZSBdID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVbIGFycm93VHlwZSBdID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgc2hhcGVJbXBsLmRyYXcoIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoICk7XG4gIH1cblxuICBpZiggIXNoYXBlSW1wbC5sZWF2ZVBhdGhPcGVuICYmIGNvbnRleHQuY2xvc2VQYXRoICl7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gIGlmKCBmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH1cblxuICBpZiggZmlsbCA9PT0gJ2hvbGxvdycgfHwgZmlsbCA9PT0gJ2JvdGgnICl7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAoIHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEgKTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3RWxlbWVudCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgIHIuZHJhd05vZGUoIGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsICk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZSggY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdDYWNoZWRFbGVtZW50ID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50ICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG5cbiAgaWYoIGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCApeyByZXR1cm47IH1cblxuICBpZiggIWV4dGVudCB8fCBtYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGJiLCBleHRlbnQgKSApe1xuICAgIHZhciBjYWNoZSA9IHIuZGF0YS5lbGVUeHJDYWNoZS5nZXRFbGVtZW50KCBlbGUsIGJiLCBweFJhdGlvICk7XG5cbiAgICBpZiggY2FjaGUgKXtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBjYWNoZS50ZXh0dXJlLmNhbnZhcywgY2FjaGUueCwgMCwgY2FjaGUud2lkdGgsIGNhY2hlLmhlaWdodCwgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oICk7XG4gICAgfSBlbHNlIHsgLy8gaWYgdGhlIGVsZW1lbnQgaXMgbm90IGNhY2hlYWJsZSwgdGhlbiBkcmF3IGRpcmVjdGx5XG4gICAgICByLmRyYXdFbGVtZW50KCBjb250ZXh0LCBlbGUgKTtcbiAgICB9XG4gIH1cbn07XG5cbkNScC5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlcyApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgIHIuZHJhd0VsZW1lbnQoIGNvbnRleHQsIGVsZSApO1xuICB9XG59O1xuXG5DUnAuZHJhd0NhY2hlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoIGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50ICk7XG4gIH1cbn07XG5cbkNScC5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50ICl7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoIGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50ICk7XG4gIH1cbn07XG5cbkNScC5kcmF3TGF5ZXJlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoIGVsZXMsIHB4UmF0aW8gKTtcblxuICBpZiggbGF5ZXJzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBiYiA9IGxheWVyLmJiO1xuXG4gICAgICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBsYXllci5jYW52YXMsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCApO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gZmFsbCBiYWNrIG9uIHBsYWluIGNhY2hpbmcgaWYgbm8gbGF5ZXJzXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoIGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCApO1xuICB9XG59O1xuXG5DUnAuZHJhd0RlYnVnUG9pbnRzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZXMgKXtcbiAgdmFyIGRyYXcgPSBmdW5jdGlvbiggeCwgeSwgY29sb3IgKXtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoIHggLSAxLCB5IC0gMSwgMywgMyApO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgdmFyIHAgPSBlbGUucG9zaXRpb24oKTtcblxuICAgICAgZHJhdyggcC54LCBwLnksICdtYWdlbnRhJyApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiArIDEgPCBwdHMubGVuZ3RoOyBqICs9IDIgKXtcbiAgICAgICAgdmFyIHggPSBwdHNbIGogXTtcbiAgICAgICAgdmFyIHkgPSBwdHNbIGogKyAxIF07XG5cbiAgICAgICAgZHJhdyggeCwgeSwgJ2N5YW4nICk7XG4gICAgICB9XG5cbiAgICAgIGRyYXcoIHJzLm1pZFgsIHJzLm1pZFksICd5ZWxsb3cnICk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBnZXRJbmRleGVkU3R5bGUgPSB1dGlsLmdldEluZGV4ZWRTdHlsZS5iaW5kKCB1dGlsICk7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiggY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiggaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDAgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZSggaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApO1xufTtcblxuQ1JwLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4ICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVYID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICB2YXIgbm9kZVkgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLWZpdCcsICd2YWx1ZScsIGluZGV4ICk7XG4gIHZhciByZXBlYXQgPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4ICk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNsaXAgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtY2xpcCcgKS52YWx1ZTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKCBub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXggKTtcblxuICB2YXIgaW1nVyA9IGltZy53aWR0aCB8fCBpbWcuY2FjaGVkVztcbiAgdmFyIGltZ0ggPSBpbWcuaGVpZ2h0IHx8IGltZy5jYWNoZWRIO1xuXG4gIC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG4gIGlmKCBudWxsID09IGltZ1cgfHwgbnVsbCA9PSBpbWdIICl7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggaW1nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggaW1nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuXG4gIHZhciB3ID0gaW1nVztcbiAgdmFyIGggPSBpbWdIO1xuXG4gIGlmKCBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3ZhbHVlJywgaW5kZXggKSAhPT0gJ2F1dG8nICl7XG4gICAgaWYoIGdldEluZGV4ZWRTdHlsZSggbm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndW5pdHMnLCBpbmRleCApID09PSAnJScgKXtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCApICogbm9kZVc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCApO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4ICkgIT09ICdhdXRvJyApe1xuICAgIGlmKCBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd1bml0cycsIGluZGV4ICkgPT09ICclJyApe1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZSggbm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3BmVmFsdWUnLCBpbmRleCApICogbm9kZUg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXggKTtcbiAgICB9XG4gIH1cblxuICBpZiggdyA9PT0gMCB8fCBoID09PSAwICl7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiggZml0ID09PSAnY29udGFpbicgKXtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbiggbm9kZVcgLyB3LCBub2RlSCAvIGggKTtcblxuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcblxuICB9IGVsc2UgaWYoIGZpdCA9PT0gJ2NvdmVyJyApe1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KCBub2RlVyAvIHcsIG5vZGVIIC8gaCApO1xuXG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIHggPSAobm9kZVggLSBub2RlVyAvIDIpOyAvLyBsZWZ0XG4gIGlmKCBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCApID09PSAnJScgKXtcbiAgICB4ICs9IChub2RlVyAtIHcpICogZ2V0SW5kZXhlZFN0eWxlKCBub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCApO1xuICB9IGVsc2Uge1xuICAgIHggKz0gZ2V0SW5kZXhlZFN0eWxlKCBub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCApO1xuICB9XG5cbiAgdmFyIHkgPSAobm9kZVkgLSBub2RlSCAvIDIpOyAvLyB0b3BcbiAgaWYoIGdldEluZGV4ZWRTdHlsZSggbm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4ICkgPT09ICclJyApe1xuICAgIHkgKz0gKG5vZGVIIC0gaCkgKiBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAncGZWYWx1ZScsIGluZGV4ICk7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBnZXRJbmRleGVkU3R5bGUoIG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAncGZWYWx1ZScsIGluZGV4ICk7XG4gIH1cblxuICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuXG4gICAgbm9kZVggPSAwO1xuICAgIG5vZGVZID0gMDtcbiAgfVxuXG4gIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuXG4gIGlmKCByZXBlYXQgPT09ICduby1yZXBlYXQnICl7XG5cbiAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgICAgY29udGV4dC5jbGlwKCBycy5wYXRoQ2FjaGUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIubm9kZVNoYXBlc1sgci5nZXROb2RlU2hhcGUoIG5vZGUgKSBdLmRyYXcoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBub2RlWCwgbm9kZVksXG4gICAgICAgICAgbm9kZVcsIG5vZGVIICk7XG5cbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgci5zYWZlRHJhd0ltYWdlKCBjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGggKTtcblxuICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oIGltZywgcmVwZWF0ICk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuXG4gICAgci5ub2RlU2hhcGVzWyByLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbm9kZVgsIG5vZGVZLFxuICAgICAgICBub2RlVywgbm9kZUggKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKCB4LCB5ICk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoIC14LCAteSApO1xuICB9XG5cbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uKCBlbGUsIHNjYWxlICl7XG4gIGlmKCAhc2NhbGUgKXtcbiAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBsdmwgPSBNYXRoLmNlaWwoIG1hdGgubG9nMiggem9vbSAqIHB4UmF0aW8gKSApOyAvLyB0aGUgZWZmZWN0aXZlIHRleHR1cmUgbGV2ZWxcblxuICAgIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoICdmb250LXNpemUnICkucGZWYWx1ZSAqIHNjYWxlO1xuICB2YXIgbWluU2l6ZSA9IGVsZS5wc3R5bGUoICdtaW4tem9vbWVkLWZvbnQtc2l6ZScgKS5wZlZhbHVlO1xuXG4gIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DUnAuZHJhd0VsZW1lbnRUZXh0ID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZSwgZm9yY2UgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmKCBmb3JjZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgaWYoICFyLmVsZVRleHRCaWdnZXJUaGFuTWluKCBlbGUgKSApeyByZXR1cm47IH1cbiAgfSBlbHNlIHtcbiAgICBpZiggIWZvcmNlICl7IHJldHVybjsgfVxuICB9XG5cbiAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoICdsYWJlbCcgKTtcblxuICAgIGlmKCAhbGFiZWwgfHwgIWxhYmVsLnZhbHVlICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC1oYWxpZ24nICkuc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC12YWxpZ24nICkuc3RyVmFsdWU7XG5cbiAgICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoICdsYWJlbCcgKTtcbiAgICB2YXIgc3JjTGFiZWwgPSBlbGUucHN0eWxlKCAnc291cmNlLWxhYmVsJyApO1xuICAgIHZhciB0Z3RMYWJlbCA9IGVsZS5wc3R5bGUoICd0YXJnZXQtbGFiZWwnICk7XG5cbiAgICBpZihcbiAgICAgICggIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSApXG4gICAgICAmJiAoICFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUgKVxuICAgICAgJiYgKCAhdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlIClcbiAgICApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfVxuXG5cbiAgci5kcmF3VGV4dCggY29udGV4dCwgZWxlICk7XG5cbiAgaWYoIGVsZS5pc0VkZ2UoKSApe1xuICAgIHIuZHJhd1RleHQoIGNvbnRleHQsIGVsZSwgJ3NvdXJjZScgKTtcblxuICAgIHIuZHJhd1RleHQoIGNvbnRleHQsIGVsZSwgJ3RhcmdldCcgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdOb2RlVGV4dCA9IENScC5kcmF3RWRnZVRleHQgPSBDUnAuZHJhd0VsZW1lbnRUZXh0O1xuXG5DUnAuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24oIGNvbnRleHQgKXtcbiAgdmFyIGNhY2hlO1xuXG4gIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgIGNhY2hlID0gdGhpcy5mb250Q2FjaGVzWyBpIF07XG5cbiAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goIGNhY2hlICk7XG5cbiAgcmV0dXJuIGNhY2hlO1xufTtcblxuLy8gc2V0IHVwIGNhbnZhcyBjb250ZXh0IHdpdGggZm9udFxuLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuQ1JwLnNldHVwVGV4dFN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZSApe1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgdmFyIGxhYmVsU3R5bGUgPSBlbGUucHN0eWxlKCAnZm9udC1zdHlsZScgKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsU2l6ZSA9IGVsZS5wc3R5bGUoICdmb250LXNpemUnICkucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoICdmb250LWZhbWlseScgKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsV2VpZ2h0ID0gZWxlLnBzdHlsZSggJ2ZvbnQtd2VpZ2h0JyApLnN0clZhbHVlO1xuICB2YXIgb3BhY2l0eSA9IGVsZS5wc3R5bGUoICd0ZXh0LW9wYWNpdHknICkudmFsdWUgKiBlbGUucHN0eWxlKCAnb3BhY2l0eScgKS52YWx1ZSAqIHBhcmVudE9wYWNpdHk7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtb3BhY2l0eScgKS52YWx1ZSAqIG9wYWNpdHk7XG4gIHZhciBjb2xvciA9IGVsZS5wc3R5bGUoICdjb2xvcicgKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtY29sb3InICkudmFsdWU7XG5cbiAgdmFyIGZvbnRDYWNoZUtleSA9IGVsZS5fcHJpdmF0ZS5mb250S2V5O1xuICB2YXIgY2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZSggY29udGV4dCApO1xuXG4gIGlmKCBjYWNoZS5rZXkgIT09IGZvbnRDYWNoZUtleSApe1xuICAgIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuXG4gICAgY2FjaGUua2V5ID0gZm9udENhY2hlS2V5O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvbiBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudFxuXG4gIC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcblxuICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgY29sb3JbIDAgXSwgY29sb3JbIDEgXSwgY29sb3JbIDIgXSwgb3BhY2l0eSApO1xuXG4gIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIG91dGxpbmVDb2xvclsgMCBdLCBvdXRsaW5lQ29sb3JbIDEgXSwgb3V0bGluZUNvbG9yWyAyIF0sIG91dGxpbmVPcGFjaXR5ICk7XG59O1xuXG5mdW5jdGlvbiByb3VuZFJlY3QoIGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzICl7XG4gIHZhciByYWRpdXMgPSByYWRpdXMgfHwgNTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKCB4ICsgcmFkaXVzLCB5ICk7XG4gIGN0eC5saW5lVG8oIHggKyB3aWR0aCAtIHJhZGl1cywgeSApO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyggeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMgKTtcbiAgY3R4LmxpbmVUbyggeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzICk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCApO1xuICBjdHgubGluZVRvKCB4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0ICk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKCB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzICk7XG4gIGN0eC5saW5lVG8oIHgsIHkgKyByYWRpdXMgKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oIHgsIHksIHggKyByYWRpdXMsIHkgKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufVxuXG4vLyBEcmF3IHRleHRcbkNScC5kcmF3VGV4dCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGUsIHByZWZpeCApe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoICd0ZXh0LW9wYWNpdHknICkudmFsdWUgPT09IDAgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGV4dFggPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4ICk7XG4gIHZhciB0ZXh0WSA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXggKTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlLCBwcmVmaXggKTtcblxuICBpZiggdGV4dCAhPSBudWxsICYmIHRleHQgIT09ICcnICYmICFpc05hTiggdGV4dFggKSAmJiAhaXNOYU4oIHRleHRZICkgKXtcbiAgICB0aGlzLnNldHVwVGV4dFN0eWxlKCBjb250ZXh0LCBlbGUgKTtcblxuICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciB0ZXh0VyA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4ICk7XG4gICAgdmFyIHRleHRIID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4ICk7XG4gICAgdmFyIHRleHRBbmdsZSA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4ICk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKCBwZGFzaCArICd0ZXh0LW1hcmdpbi14JyApLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKCBwZGFzaCArICd0ZXh0LW1hcmdpbi15JyApLnBmVmFsdWU7XG5cbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG5cbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtaGFsaWduJyApLnZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC12YWxpZ24nICkudmFsdWU7XG5cbiAgICBpZiggaXNFZGdlICl7XG4gICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIHRleHRYICs9IG1hcmdpblg7XG4gICAgdGV4dFkgKz0gbWFyZ2luWTtcblxuICAgIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXJvdGF0aW9uJyApO1xuICAgIHZhciB0aGV0YTtcblxuICAgIGlmKCByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnICl7XG4gICAgICB0aGV0YSA9IGlzRWRnZSA/IHRleHRBbmdsZSA6IDA7XG4gICAgfSBlbHNlIGlmKCByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZXRhID0gcm90YXRpb24ucGZWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiggdGhldGEgIT09IDAgKXtcbiAgICAgIHZhciBvcmdUZXh0WCA9IHRleHRYO1xuICAgICAgdmFyIG9yZ1RleHRZID0gdGV4dFk7XG5cbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKCBvcmdUZXh0WCwgb3JnVGV4dFkgKTtcbiAgICAgIGNvbnRleHQucm90YXRlKCB0aGV0YSApO1xuXG4gICAgICB0ZXh0WCA9IDA7XG4gICAgICB0ZXh0WSA9IDA7XG4gICAgfVxuXG4gICAgc3dpdGNoKCB2YWxpZ24gKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZICs9IHRleHRIO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknICkudmFsdWU7XG4gICAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItb3BhY2l0eScgKS52YWx1ZTtcbiAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSggJ3RleHQtYm9yZGVyLXdpZHRoJyApLnBmVmFsdWU7XG4gICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyApLnBmVmFsdWU7XG5cbiAgICBpZiggYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8ICggdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCApICl7XG4gICAgICB2YXIgYmdYID0gdGV4dFggLSBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgc3dpdGNoKCBoYWxpZ24gKXtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VyAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGJnWSA9IHRleHRZIC0gdGV4dEggLSBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ1cgPSB0ZXh0VyArIDIqYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdIID0gdGV4dEggKyAyKmJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICBpZiggYmFja2dyb3VuZE9wYWNpdHkgPiAwICl7XG4gICAgICAgIHZhciB0ZXh0RmlsbCA9IGNvbnRleHQuZmlsbFN0eWxlO1xuICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoICd0ZXh0LWJhY2tncm91bmQtY29sb3InICkudmFsdWU7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclsgMCBdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsgMSBdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsgMiBdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IGVsZS5wc3R5bGUoICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnICkuc3RyVmFsdWU7XG4gICAgICAgIGlmKCBzdHlsZVNoYXBlID09ICdyb3VuZHJlY3RhbmdsZScgKXtcbiAgICAgICAgICByb3VuZFJlY3QoIGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgMiApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoIGJnWCwgYmdZLCBiZ1csIGJnSCApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICB9XG5cbiAgICAgIGlmKCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwICl7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoICd0ZXh0LWJvcmRlci1jb2xvcicgKS52YWx1ZTtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IGVsZS5wc3R5bGUoICd0ZXh0LWJvcmRlci1zdHlsZScgKS52YWx1ZTtcblxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclsgMCBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWyAxIF0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbIDIgXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcblxuICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBzd2l0Y2goIHRleHRCb3JkZXJTdHlsZSApe1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyAxLCAxIF0gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIDQsIDIgXSApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbXSApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggW10gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KCBiZ1gsIGJnWSwgYmdXLCBiZ0ggKTtcblxuICAgICAgICBpZiggdGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJyApe1xuICAgICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gMjtcblxuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCggYmdYICsgd2hpdGVXaWR0aCwgYmdZICsgd2hpdGVXaWR0aCwgYmdXIC0gd2hpdGVXaWR0aCAqIDIsIGJnSCAtIHdoaXRlV2lkdGggKiAyICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbXSApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gMiAqIGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtd2lkdGgnICkucGZWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgfVxuXG4gICAgaWYoIGVsZS5wc3R5bGUoICd0ZXh0LXdyYXAnICkudmFsdWUgPT09ICd3cmFwJyApe1xuICAgICAgdmFyIGxpbmVzID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4ICk7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRleHRIIC8gbGluZXMubGVuZ3RoO1xuXG4gICAgICBzd2l0Y2goIHZhbGlnbiApe1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHRleHRZIC09ICggbGluZXMubGVuZ3RoIC0gMSApICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0ZXh0WSAtPSAoIGxpbmVzLmxlbmd0aCAtIDEgKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoIGxpbmVzWyBsIF0sIHRleHRYLCB0ZXh0WSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dCggbGluZXNbIGwgXSwgdGV4dFgsIHRleHRZICk7XG5cbiAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoIHRleHQsIHRleHRYLCB0ZXh0WSApO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICB9XG5cbiAgICBpZiggdGhldGEgIT09IDAgKXtcbiAgICAgIGNvbnRleHQucm90YXRlKCAtdGhldGEgKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKCAtb3JnVGV4dFgsIC1vcmdUZXh0WSApO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi8uLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG52YXIgZ2V0SW5kZXhlZFN0eWxlID0gdXRpbC5nZXRJbmRleGVkU3R5bGUuYmluZCggdXRpbCApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3Tm9kZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBkcmF3TGFiZWwgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcG9zID0gcG9zIHx8IF9wLnBvc2l0aW9uO1xuXG4gIGlmKCAhaXMubnVtYmVyKCBwb3MueCApIHx8ICFpcy5udW1iZXIoIHBvcy55ICkgKXtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG5cbiAgaWYoICFub2RlLnZpc2libGUoKSApeyByZXR1cm47IH1cblxuICB2YXIgcGFyZW50T3BhY2l0eSA9IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcblxuICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuXG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nO1xuXG4gIGNvbnRleHQubGluZVdpZHRoID0gbm9kZS5wc3R5bGUoICdib3JkZXItd2lkdGgnICkucGZWYWx1ZTtcblxuICAvL1xuICAvLyBzZXR1cCBzaGlmdFxuXG4gIHZhciBiYjtcbiAgaWYoIHNoaWZ0VG9PcmlnaW5XaXRoQmIgKXtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggLWJiLngxLCAtYmIueTEgKTtcbiAgfVxuXG4gIC8vXG4gIC8vIGxvYWQgYmcgaW1hZ2VcblxuICB2YXIgYmdJbWdQcm9wID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLWltYWdlJyApO1xuICB2YXIgdXJscyA9IGJnSW1nUHJvcC52YWx1ZTtcbiAgdmFyIHVybDtcbiAgdmFyIHVybERlZmluZWQgPSBbXTtcbiAgdmFyIGltYWdlID0gW107XG4gIHZhciBudW1JbWFnZXMgPSB1cmxzLmxlbmd0aDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1JbWFnZXM7IGkrKyApe1xuICAgIHVybCA9IHVybHNbaV07XG4gICAgdXJsRGVmaW5lZFtpXSA9IHVybCAhPSBudWxsICYmIHVybCAhPT0gJ25vbmUnO1xuICAgIGlmKCB1cmxEZWZpbmVkW2ldICl7XG4gICAgICB2YXIgYmdJbWdDcm9zc09yaWdpbiA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsICd2YWx1ZScsIGkpO1xuXG4gICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgaW1hZ2VbaV0gPSB0aGlzLmdldENhY2hlZEltYWdlKCB1cmwsIGJnSW1nQ3Jvc3NPcmlnaW4sIGZ1bmN0aW9uKCl7XG4gICAgICAgIG5vZGUucnRyaWdnZXIoJ2JhY2tncm91bmQnKTtcbiAgICAgIH0gKTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuICB2YXIgYmdDb2xvciA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoICdib3JkZXItY29sb3InICkudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCAnYm9yZGVyLXN0eWxlJyApLnZhbHVlO1xuXG4gIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCBiZ0NvbG9yWzBdLCBiZ0NvbG9yWzFdLCBiZ0NvbG9yWzJdLCBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtb3BhY2l0eScgKS52YWx1ZSAqIHBhcmVudE9wYWNpdHkgKTtcblxuICB0aGlzLnN0cm9rZVN0eWxlKCBjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBub2RlLnBzdHlsZSggJ2JvcmRlci1vcGFjaXR5JyApLnZhbHVlICogcGFyZW50T3BhY2l0eSApO1xuXG4gIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgMSwgMSBdICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIDQsIDIgXSApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyBdICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG5cbiAgLy9cbiAgLy8gZHJhdyBzaGFwZVxuXG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHN0eWxlU2hhcGUgKyAnJCcgKyBub2RlV2lkdGggKyAnJCcgKyBub2RlSGVpZ2h0ICsgKCBzdHlsZVNoYXBlID09PSAncG9seWdvbicgPyAnJCcgKyBzaGFwZVB0cy5qb2luKCckJykgOiAnJyApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgaWYoIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5ICl7XG4gICAgICBwYXRoID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCApe1xuXG4gICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIG5wb3MgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgICAoIHBhdGggfHwgY29udGV4dCApLFxuICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICBucG9zLnksXG4gICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgIG5vZGVIZWlnaHQgKTtcbiAgfVxuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgLy9cbiAgLy8gYmcgaW1hZ2VcblxuICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IG51bUltYWdlczsgaSsrICl7XG4gICAgaWYoICggdXJsRGVmaW5lZFtpXSApICYmIGltYWdlW2ldLmNvbXBsZXRlICl7XG4gICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgdGhpcy5kcmF3SW5zY3JpYmVkSW1hZ2UoIGNvbnRleHQsIGltYWdlW2ldLCBub2RlLCBpICk7XG4gICAgfVxuICB9XG5cbiAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG4gIGlmKCBwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcgKXsgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgbm9kZS51cGRhdGVTdHlsZSggZmFsc2UgKTtcbiAgfVxuXG4gIC8vXG4gIC8vIHBpZVxuXG4gIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1ibGFja2VuJyApLnZhbHVlO1xuICB2YXIgYm9yZGVyV2lkdGggPSBub2RlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlO1xuXG4gIGlmKCB0aGlzLmhhc1BpZSggbm9kZSApICl7XG4gICAgdGhpcy5kcmF3UGllKCBjb250ZXh0LCBub2RlLCBwYXJlbnRPcGFjaXR5ICk7XG5cbiAgICAvLyByZWRyYXcgcGF0aCBmb3IgYmxhY2tlbiBhbmQgYm9yZGVyXG4gICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgIGlmKCAhdXNlUGF0aHMgKXtcbiAgICAgICAgci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBwb3MueCxcbiAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgbm9kZUhlaWdodCApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIGRhcmtlbi9saWdodGVuXG5cbiAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCAwLCAwLCAwLCBkYXJrbmVzcyApO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgdGhpcy5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIC1kYXJrbmVzcyApO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gYm9yZGVyXG5cbiAgaWYoIGJvcmRlcldpZHRoID4gMCApe1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbm9kZS5wc3R5bGUoICdib3JkZXItd2lkdGgnICkucGZWYWx1ZSAvIDM7XG5cbiAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgfVxuXG4gIH1cblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXBvcy54LCAtcG9zLnkgKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgXSApO1xuICB9XG5cbiAgLy9cbiAgLy8gbGFiZWxcblxuICByLmRyYXdFbGVtZW50VGV4dCggY29udGV4dCwgbm9kZSwgZHJhd0xhYmVsICk7XG5cbiAgLy9cbiAgLy8gb3ZlcmxheVxuXG4gIHZhciBvdmVybGF5UGFkZGluZyA9IG5vZGUucHN0eWxlKCAnb3ZlcmxheS1wYWRkaW5nJyApLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IG5vZGUucHN0eWxlKCAnb3ZlcmxheS1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gbm9kZS5wc3R5bGUoICdvdmVybGF5LWNvbG9yJyApLnZhbHVlO1xuXG4gIGlmKCBvdmVybGF5T3BhY2l0eSA+IDAgKXtcbiAgICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkgKTtcblxuICAgIHIubm9kZVNoYXBlc1sgJ3JvdW5kcmVjdGFuZ2xlJyBdLmRyYXcoXG4gICAgICBjb250ZXh0LFxuICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLFxuICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICk7XG5cbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYoIHNoaWZ0VG9PcmlnaW5XaXRoQmIgKXtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggYmIueDEsIGJiLnkxICk7XG4gIH1cblxufTtcblxuLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5DUnAuaGFzUGllID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcblxuQ1JwLmRyYXdQaWUgPSBmdW5jdGlvbiggY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHksIHBvcyApe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgcGllU2l6ZSA9IG5vZGUucHN0eWxlKCAncGllLXNpemUnICk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBvcyA9IHBvcyB8fCBfcC5wb3NpdGlvbjtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYoIHBpZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgcmFkaXVzID0gcGllU2l6ZS5wZlZhbHVlIC8gMjtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSggJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJyApLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJyApLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScgKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG5cbiAgICAvLyBwZXJjZW50IGNhbid0IHB1c2ggYmV5b25kIDFcbiAgICBpZiggcGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSApe1xuICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTtcblxuICAgIC8vIGlnbm9yZSBpZlxuICAgIC8vIC0gemVybyBzaXplXG4gICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgaWYoIHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKCB4LCB5ICk7XG4gICAgY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQgKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgdGhpcy5maWxsU3R5bGUoIGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkgKTtcblxuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG5cbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gIGlmKCB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCApe1xuICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gIH1cblxuICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufTtcblxuQ1JwLnBhaW50Q2FjaGUgPSBmdW5jdGlvbiggY29udGV4dCApe1xuICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gIHZhciBjYWNoZTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgIGNhY2hlID0gY2FjaGVzWyBpIF07XG5cbiAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBuZWVkVG9DcmVhdGVDYWNoZSApe1xuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgY2FjaGVzLnB1c2goIGNhY2hlICk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAuZmlsbFN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIHIsIGcsIGIsIGEgKXtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIHIsIGcsIGIsIGEgKXtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG4vLyBSZXNpemUgY2FudmFzXG5DUnAubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24oIGNvbnRhaW5lciApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgYmIgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gYmJbMl07XG4gIHZhciBoZWlnaHQgPSBiYlszXTtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG5cbiAgaWYoXG4gICAgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdIHx8XG4gICAgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdXG4gICl7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuXG4gIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXM7XG5cbiAgaWYoIGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQgKXtcbiAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgfVxuXG4gIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKyApe1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbIGkgXTtcblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKysgKXtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyBpIF07XG5cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG4gIGlmKCBwaXhlbFJhdGlvIDw9IDEgKXtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gIH1cblxuICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG59O1xuXG5DUnAucmVuZGVyVG8gPSBmdW5jdGlvbiggY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgdGhpcy5yZW5kZXIoIHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSApO1xufTtcblxuQ1JwLnJlbmRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5OyB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgIGlmKCByLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvICl7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoIHIuY29udGFpbmVyICk7XG5cbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgci5wcmV2UHhSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cblxuICBpZiggIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCApe1xuICAgIGNsZWFyVGltZW91dCggci5tb3Rpb25CbHVyVGltZW91dCApO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICBpZiggci5tYkZyYW1lcyA9PSBudWxsICl7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICByLm1iRnJhbWVzKys7XG5cbiAgICBpZiggci5tYkZyYW1lcyA8IDMgKXsgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG4gICAgaWYoIHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcyApe1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgIH1cbiAgfVxuXG4gIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuICBpZiggci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcgKXtcbiAgICBuZWVkRHJhd1sgci5OT0RFIF0gPSB0cnVlO1xuICAgIG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSA9IHRydWU7XG4gIH1cblxuICB2YXIgY29yZVN0eWxlID0gY3kuc3R5bGUoKS5fcHJpdmF0ZS5jb3JlU3R5bGU7XG5cbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICB4OiBwYW4ueCxcbiAgICB5OiBwYW4ueVxuICB9O1xuXG4gIHZhciB2cCA9IHtcbiAgICB6b29tOiB6b29tLFxuICAgIHBhbjoge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH1cbiAgfTtcbiAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7XG5cbiAgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcbiAgaWYoICF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgaWYoIGZvcmNlZFBhbiApe1xuICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgfVxuXG4gIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuXG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gIGZ1bmN0aW9uIG1iY2xlYXIoIGNvbnRleHQsIHgsIHksIHcsIGggKXtcbiAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgKTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KCB4LCB5LCB3LCBoICk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIGNsZWFyICl7XG4gICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgaWYoICFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF0pICl7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG5cbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cbiAgICBpZiggY2xlYXIgPT09ICdtb3Rpb25CbHVyJyApe1xuICAgICAgbWJjbGVhciggY29udGV4dCwgMCwgMCwgdywgaCApO1xuICAgIH0gZWxzZSBpZiggIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpICl7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCggMCwgMCwgdywgaCApO1xuICAgIH1cblxuICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGVQYW4ueCwgZVBhbi55ICk7XG4gICAgICBjb250ZXh0LnNjYWxlKCBlWm9vbSwgZVpvb20gKTtcbiAgICB9XG4gICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSApO1xuICAgIH1cbiAgICBpZiggZm9yY2VkWm9vbSApe1xuICAgICAgY29udGV4dC5zY2FsZSggZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSApO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gIH1cblxuICBpZiggdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcblxuICAgIHZhciBiYjtcblxuICAgIGlmKCAhci50ZXh0dXJlQ2FjaGUgKXtcbiAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG5cbiAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgY3h0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuICAgICAgY3h0LmNsZWFyUmVjdCggMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCApO1xuXG4gICAgICByLnJlbmRlcigge1xuICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgfSApO1xuXG4gICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgfTtcblxuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbIHIuRFJBRyBdID0gZmFsc2U7XG4gICAgbmVlZERyYXdbIHIuTk9ERSBdID0gZmFsc2U7XG5cbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdO1xuXG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuXG4gICAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICAgIG1iY2xlYXIoIGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InIF0udmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBjb3JlU3R5bGVbICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScgXS52YWx1ZTtcbiAgICByLmZpbGxTdHlsZSggY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcblxuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgZmFsc2UgKTtcblxuICAgIGNvbnRleHQuY2xlYXJSZWN0KCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8gKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggdGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvICk7XG5cbiAgfSBlbHNlIGlmKCByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICl7IC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKTtcbiAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuXG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuXG4gIG5lZWRNYkNsZWFyWyByLk5PREUgXSA9ICFuZWVkRHJhd1sgci5OT0RFIF0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5OT0RFIF0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmKCBuZWVkTWJDbGVhclsgci5OT0RFIF0gKXsgci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5OT0RFIF0gPSB0cnVlOyB9XG5cbiAgbmVlZE1iQ2xlYXJbIHIuRFJBRyBdID0gIW5lZWREcmF3WyByLkRSQUcgXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLkRSQUcgXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYoIG5lZWRNYkNsZWFyWyByLkRSQUcgXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLkRSQUcgXSA9IHRydWU7IH1cblxuICBpZiggbmVlZERyYXdbIHIuTk9ERSBdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIgfHwgbmVlZE1iQ2xlYXJbIHIuTk9ERSBdICl7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyWyByLk5PREUgXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSA6IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdICk7XG4gICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgY2xlYXIgKTtcblxuICAgIGlmKCBoaWRlRWRnZXMgKXtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKCBjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoIGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfVxuXG4gICAgaWYoIHIuZGVidWcgKXtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKCBjb250ZXh0LCBlbGVzLm5vbmRyYWcgKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgIG5lZWREcmF3WyByLk5PREUgXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3WyByLkRSQUcgXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyWyByLkRSQUcgXSkgKXtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbIHIuRFJBRyBdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdIDogZGF0YS5jb250ZXh0c1sgci5EUkFHIF0gKTtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCApO1xuXG4gICAgaWYoIGhpZGVFZGdlcyApe1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoIGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKCBjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuICAgIH1cblxuICAgIGlmKCByLmRlYnVnICl7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyggY29udGV4dCwgZWxlcy5kcmFnICk7XG4gICAgfVxuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyICl7XG4gICAgICBuZWVkRHJhd1sgci5EUkFHIF0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiggci5zaG93RnBzIHx8ICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSAmJiAhZHJhd0FsbExheWVycykpICl7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbIHIuU0VMRUNUX0JPWCBdO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCApO1xuXG4gICAgaWYoIHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nICkgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcgXS52YWx1ZSAvIHpvb207XG5cbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWNvbG9yJyBdLnZhbHVlWzBdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1jb2xvcicgXS52YWx1ZVsxXSArICcsJ1xuICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtY29sb3InIF0udmFsdWVbMl0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICByLnNlbGVjdGlvblsxXSxcbiAgICAgICAgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSxcbiAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSApO1xuXG4gICAgICBpZiggYm9yZGVyV2lkdGggPiAwICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnXG4gICAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicgXS52YWx1ZVswXSArICcsJ1xuICAgICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InIF0udmFsdWVbMV0gKyAnLCdcbiAgICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyBdLnZhbHVlWzJdICsgJywnXG4gICAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzFdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sXG4gICAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzBdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzFdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzJdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyggcG9zLngsIHBvcy55LCBjb3JlU3R5bGVbICdhY3RpdmUtYmctc2l6ZScgXS5wZlZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkgKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmKCByLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyICl7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKCB0aW1lVG9SZW5kZXIgKTtcbiAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKCAxMDAwIC8gdGltZVRvUmVuZGVyICk7XG5cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjAgKTtcblxuICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KCAwLCAzMCwgMjUwLCAyMCApO1xuICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMzAsIDI1MCAqIE1hdGgubWluKCBmcHMgLyBtYXhGcHMsIDEgKSwgMjAgKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgIG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuICBpZiggbW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEgKXtcbiAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdO1xuICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXTtcblxuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1sgci5EUkFHIF07XG4gICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24oIGN4dCwgdHh0LCBuZWVkQ2xlYXIgKXtcbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuICAgICAgaWYoIG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QgKXtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCggMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1iY2xlYXIoIGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHB4ciA9IG1iUHhSYXRpbztcblxuICAgICAgY3h0LmRyYXdJbWFnZShcbiAgICAgICAgdHh0LCAvLyBpbWdcbiAgICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgICAgMCwgMCwgLy8geCwgeVxuICAgICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiggbmVlZERyYXdbIHIuTk9ERSBdIHx8IG5lZWRNYkNsZWFyWyByLk5PREUgXSApe1xuICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyWyByLk5PREUgXSApO1xuICAgICAgbmVlZERyYXdbIHIuTk9ERSBdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIG5lZWREcmF3WyByLkRSQUcgXSB8fCBuZWVkTWJDbGVhclsgci5EUkFHIF0gKXtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKCBjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhclsgci5EUkFHIF0gKTtcbiAgICAgIG5lZWREcmF3WyByLkRSQUcgXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuXG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLk5PREUgXSA9IGZhbHNlO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5EUkFHIF0gPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICByLm1iRnJhbWVzID0gMDtcblxuICAgICAgbmVlZERyYXdbIHIuTk9ERSBdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3WyByLkRSQUcgXSA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5ICk7XG4gIH1cblxuICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICBjeS50cmlnZ2VyKCdyZW5kZXInKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcblxudmFyIENScCA9IHt9O1xuXG4vLyBATyBQb2x5Z29uIGRyYXdpbmdcbkNScC5kcmF3UG9seWdvblBhdGggPSBmdW5jdGlvbihcbiAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzICl7XG5cbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgZm9yKCB2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG4gICAgY29udGV4dC5saW5lVG8oIHggKyBoYWxmVyAqIHBvaW50c1sgaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbIGkgKiAyICsgMV0gKTtcbiAgfVxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCApe1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oIHgsIHkgLSBoYWxmSGVpZ2h0ICk7XG4gIC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuICBjb250ZXh0LmFyY1RvKCB4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gIGNvbnRleHQuYXJjVG8oIHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgY29udGV4dC5hcmNUbyggeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyApO1xuICAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG4gIGNvbnRleHQuYXJjVG8oIHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEpvaW4gbGluZVxuICBjb250ZXh0LmxpbmVUbyggeCwgeSAtIGhhbGZIZWlnaHQgKTtcblxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCApe1xuXG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lckxlbmd0aCA9IG1hdGguZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCk7XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oIHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0ICk7XG5cbiAgICBjb250ZXh0LmxpbmVUbyggeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQgKTtcbiAgICBjb250ZXh0LmxpbmVUbyggeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGggKTtcbiAgICBjb250ZXh0LmxpbmVUbyggeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGggKTtcbiAgICBjb250ZXh0LmxpbmVUbyggeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQgKTtcbiAgICBjb250ZXh0LmxpbmVUbyggeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgIHkgKyBoYWxmSGVpZ2h0ICk7XG4gICAgY29udGV4dC5saW5lVG8oIHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyTGVuZ3RoICk7XG4gICAgY29udGV4dC5saW5lVG8oIHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoICk7XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwLmRyYXdCYXJyZWxQYXRoID0gZnVuY3Rpb24oXG4gIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKXtcblxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIHZhciB4QmVnaW4gPSB4IC0gaGFsZldpZHRoO1xuICAgIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgICB2YXIgeUJlZ2luID0geSAtIGhhbGZIZWlnaHQ7XG4gICAgdmFyIHlFbmQgPSB5ICsgaGFsZkhlaWdodDtcbiAgICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIC4wNSAqIGhlaWdodCk7XG5cbiAgICBjb250ZXh0LmxpbmVUbyh4QmVnaW4sIHlCZWdpbiArIC45NSAqIGhlaWdodCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiwgeUVuZCwgeEJlZ2luICsgMC4yNSAqIHdpZHRoLCB5RW5kKTtcblxuICAgIGNvbnRleHQubGluZVRvKHhCZWdpbiArIDAuNzUgKiB3aWR0aCwgeUVuZCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQsIHlFbmQsIHhFbmQsIHlCZWdpbiArIDAuOTUgKiBoZWlnaHQpXG5cbiAgICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyAwLjA1ICogaGVpZ2h0KTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCwgeUJlZ2luLCB4QmVnaW4gKyAwLjc1ICogd2lkdGgsIHlCZWdpbik7XG5cbiAgICBjb250ZXh0LmxpbmVUbyh4QmVnaW4gKyAuMjUgKiB3aWR0aCwgeUJlZ2luKTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luLCB5QmVnaW4sIHhCZWdpbiwgeUJlZ2luICsgMC4wNSAqIGhlaWdodCk7XG5cblxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cblxudmFyIHNpbjAgPSBNYXRoLnNpbiggMCApO1xudmFyIGNvczAgPSBNYXRoLmNvcyggMCApO1xuXG52YXIgc2luID0ge307XG52YXIgY29zID0ge307XG5cbnZhciBlbGxpcHNlU3RlcFNpemUgPSBNYXRoLlBJIC8gNDA7XG5cbmZvciggdmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApe1xuICBzaW5bIGkgXSA9IE1hdGguc2luKCBpICk7XG4gIGNvc1sgaSBdID0gTWF0aC5jb3MoIGkgKTtcbn1cblxuQ1JwLmRyYXdFbGxpcHNlUGF0aCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIGlmKCBjb250ZXh0LmVsbGlwc2UgKXtcbiAgICAgIGNvbnRleHQuZWxsaXBzZSggY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeFBvcywgeVBvcztcbiAgICAgIHZhciBydyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG4gICAgICBmb3IoIHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUgKXtcbiAgICAgICAgeFBvcyA9IGNlbnRlclggLSAocncgKiBzaW5bIGkgXSkgKiBzaW4wICsgKHJ3ICogY29zWyBpIF0pICogY29zMDtcbiAgICAgICAgeVBvcyA9IGNlbnRlclkgKyAocmggKiBjb3NbIGkgXSkgKiBzaW4wICsgKHJoICogc2luWyBpIF0pICogY29zMDtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKCB4UG9zLCB5UG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHhQb3MsIHlQb3MgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBIZWFwID0gcmVxdWlyZSggJy4uLy4uLy4uL2hlYXAnICk7XG52YXIgZGVmcyA9IHJlcXVpcmUoICcuL3RleHR1cmUtY2FjaGUtZGVmcycgKTtcblxudmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG52YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG52YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcbnZhciBtYXhUeHJIID0gMTAyNDsgIC8vIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHRleHR1cmVcbnZhciBtaW5VdGlsaXR5ID0gMC41OyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG52YXIgbWF4RnVsbG5lc3MgPSAwLjg7IC8vIGZ1bGxuZXNzIG9mIHRleHR1cmUgYWZ0ZXIgd2hpY2ggcXVldWUgcmVtb3ZhbCBpcyBjaGVja2VkXG52YXIgbWF4RnVsbG5lc3NDaGVja3MgPSAxMDsgLy8gZGVxdWV1ZWQgYWZ0ZXIgdGhpcyBtYW55IGNoZWNrc1xudmFyIGFsbG93RWRnZVR4ckNhY2hpbmcgPSBmYWxzZTsgLy8gd2hldGhlciBlZGdlcyBjYW4gYmUgY2FjaGVkIGFzIHRleHR1cmVzIChUT0RPIG1heWJlIGJldHRlciBvbiBpZiB3ZWJnbCBzdXBwb3J0ZWQ/KVxudmFyIGFsbG93UGFyZW50VHhyQ2FjaGluZyA9IGZhbHNlOyAvLyB3aGV0aGVyIHBhcmVudCBub2RlcyBjYW4gYmUgY2FjaGVkIGFzIHRleHR1cmVzIChUT0RPIG1heWJlIGJldHRlciBvbiBpZiB3ZWJnbCBzdXBwb3J0ZWQ/KVxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gMTAwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgZ2V0VHhyUmVhc29ucyA9IHtcbiAgZGVxdWV1ZTogJ2RlcXVldWUnLFxuICBkb3duc2NhbGU6ICdkb3duc2NhbGUnLFxuICBoaWdoUXVhbGl0eTogJ2hpZ2hRdWFsaXR5J1xufTtcblxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiggcmVuZGVyZXIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgc2VsZi5vbkRlcXVldWVzID0gW107XG5cbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5cbkVUQ3AucmVhc29ucyA9IGdldFR4clJlYXNvbnM7XG5cbi8vIHRoZSBsaXN0IG9mIHRleHR1cmVzIGluIHdoaWNoIG5ldyBzdWJ0ZXh0dXJlcyBmb3IgZWxlbWVudHMgY2FuIGJlIHBsYWNlZFxuRVRDcC5nZXRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiggdHhySCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWxlSW1nQ2FjaGVzID0gc2VsZi5lbGVJbWdDYWNoZXMgfHwge307XG5cbiAgcmV0dXJuICggc2VsZi5lbGVJbWdDYWNoZXNbIHR4ckggXSA9IHNlbGYuZWxlSW1nQ2FjaGVzWyB0eHJIIF0gfHwgW10gKTtcbn07XG5cbi8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24oIHR4ckggKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBydHh0clFzID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgfHwge307XG4gIHZhciBydHh0clEgPSBydHh0clFzWyB0eHJIIF0gPSBydHh0clFzWyB0eHJIIF0gfHwgW107XG5cbiAgcmV0dXJuIHJ0eHRyUTtcbn07XG5cbi8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcChmdW5jdGlvbiggYSwgYiApe1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH0pO1xuXG4gIHJldHVybiBxO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHMgKGVsZW1lbnQgaWQgbG9va3VwKVxuRVRDcC5nZXRFbGVtZW50SWRUb1F1ZXVlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBpZDJxID0gc2VsZi5lbGVJZFRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlSWRUb0NhY2hlUXVldWUgfHwge307XG5cbiAgcmV0dXJuIGlkMnE7XG59O1xuXG5FVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiggZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24gKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcblxuICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IHJldHVybiBudWxsOyB9XG5cbiAgaWYoIGx2bCA9PSBudWxsICl7XG4gICAgbHZsID0gTWF0aC5jZWlsKCBtYXRoLmxvZzIoIHpvb20gKiBweFJhdGlvICkgKTtcbiAgfVxuXG4gIGlmKCBsdmwgPCBtaW5MdmwgKXtcbiAgICBsdmwgPSBtaW5Mdmw7XG4gIH0gZWxzZSBpZiggem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCApe1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gIHZhciBjYWNoZXMgPSBycy5pbWdDYWNoZXMgPSBycy5pbWdDYWNoZXMgfHwge307XG4gIHZhciBlbGVDYWNoZSA9IGNhY2hlc1tsdmxdO1xuXG4gIGlmKCBlbGVDYWNoZSApe1xuICAgIHJldHVybiBlbGVDYWNoZTtcbiAgfVxuXG4gIHZhciB0eHJIOyAvLyB3aGljaCB0ZXh0dXJlIGhlaWdodCB0aGlzIGVsZSBiZWxvbmdzIHRvXG5cbiAgaWYoIGVsZVNjYWxlZEggPD0gbWluVHhySCApe1xuICAgIHR4ckggPSBtaW5UeHJIO1xuICB9IGVsc2UgaWYoIGVsZVNjYWxlZEggPD0gdHhyU3RlcEggKXtcbiAgICB0eHJIID0gdHhyU3RlcEg7XG4gIH0gZWxzZSB7XG4gICAgdHhySCA9IE1hdGguY2VpbCggZWxlU2NhbGVkSCAvIHR4clN0ZXBIICkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmKFxuICAgIGVsZVNjYWxlZEggPiBtYXhUeHJIXG4gICAgfHwgZWxlU2NhbGVkVyA+IG1heFR4cldcbiAgICB8fCAoICFhbGxvd0VkZ2VUeHJDYWNoaW5nICYmIGVsZS5pc0VkZ2UoKSApXG4gICAgfHwgKCAhYWxsb3dQYXJlbnRUeHJDYWNoaW5nICYmIGVsZS5pc1BhcmVudCgpIClcbiAgKXtcbiAgICByZXR1cm4gbnVsbDsgLy8gY2FjaGluZyBsYXJnZSBlbGVtZW50cyBpcyBub3QgZWZmaWNpZW50XG4gIH1cblxuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuICB2YXIgdHhyID0gdHhyUVsgdHhyUS5sZW5ndGggLSAyIF07XG5cbiAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUoIHR4ckgsIGVsZVNjYWxlZFcgKSB8fCBzZWxmLmFkZFRleHR1cmUoIHR4ckgsIGVsZVNjYWxlZFcgKTtcbiAgfTtcblxuICAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuICBpZiggIXR4ciApe1xuICAgIHR4ciA9IHR4clFbIHR4clEubGVuZ3RoIC0gMSBdO1xuICB9XG5cbiAgLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcbiAgaWYoICF0eHIgKXtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUgY3VycmVudCB0ZXh0dXJlLCB3ZSBuZWVkIGEgbmV3IG9uZVxuICBpZiggdHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcgKXtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbiggZWxlLCBzY2FsZSApO1xuICB2YXIgc2NhbGFibGVGcm9tID0gZnVuY3Rpb24oIG90aGVyQ2FjaGUgKXtcbiAgICByZXR1cm4gb3RoZXJDYWNoZSAmJiBvdGhlckNhY2hlLnNjYWxlZExhYmVsU2hvd24gPT09IHNjYWxlZExhYmVsU2hvd247XG4gIH07XG5cbiAgdmFyIGRlcWluZyA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZGVxdWV1ZTtcbiAgdmFyIGhpZ2hRdWFsaXR5UmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5oaWdoUXVhbGl0eTtcbiAgdmFyIGRvd25zY2FsZVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZG93bnNjYWxlO1xuXG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuICBmb3IoIHZhciBsID0gbHZsICsgMTsgbCA8PSBtYXhMdmw7IGwrKyApe1xuICAgIHZhciBjID0gY2FjaGVzW2xdO1xuXG4gICAgaWYoIGMgKXsgaGlnaGVyQ2FjaGUgPSBjOyBicmVhazsgfVxuICB9XG5cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24oKXtcbiAgICB0eHIuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLFxuICAgICAgb25lVXBDYWNoZS54LCAwLFxuICAgICAgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsXG4gICAgICB0eHIudXNlZFdpZHRoLCAwLFxuICAgICAgZWxlU2NhbGVkVywgZWxlU2NhbGVkSFxuICAgICk7XG4gIH07XG5cbiAgaWYoIHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSApe1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcblxuICB9IGVsc2UgaWYoIHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkgKXtcbiAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcblxuICAgIGlmKCBoaWdoUXVhbGl0eVJlcSApe1xuICAgICAgZm9yKCB2YXIgbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBsID4gbHZsOyBsLS0gKXtcbiAgICAgICAgb25lVXBDYWNoZSA9IHNlbGYuZ2V0RWxlbWVudCggZWxlLCBiYiwgcHhSYXRpbywgbCwgZ2V0VHhyUmVhc29ucy5kb3duc2NhbGUgKTtcbiAgICAgIH1cblxuICAgICAgZG93bnNjYWxlKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoIGVsZSwgYmIsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSApO1xuXG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuICAgIGlmKCAhZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxICl7XG4gICAgICBmb3IoIHZhciBsID0gbHZsIC0gMTsgbCA+PSBtaW5Mdmw7IGwtLSApe1xuICAgICAgICB2YXIgYyA9IGNhY2hlc1tsXTtcblxuICAgICAgICBpZiggYyApeyBsb3dlckNhY2hlID0gYzsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpICl7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcblxuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoIGVsZSwgYmIsIGx2bCApO1xuXG4gICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICB9XG5cbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoIHR4ci51c2VkV2lkdGgsIDAgKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZSggc2NhbGUsIHNjYWxlICk7XG5cbiAgICByLmRyYXdFbGVtZW50KCB0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biApO1xuXG4gICAgdHhyLmNvbnRleHQuc2NhbGUoIDEvc2NhbGUsIDEvc2NhbGUgKTtcbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoIC10eHIudXNlZFdpZHRoLCAwICk7XG4gIH1cblxuICBlbGVDYWNoZSA9IGNhY2hlc1tsdmxdID0ge1xuICAgIGVsZTogZWxlLFxuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG5cbiAgdHhyLnVzZWRXaWR0aCArPSBNYXRoLmNlaWwoIGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nICk7XG5cbiAgdHhyLmVsZUNhY2hlcy5wdXNoKCBlbGVDYWNoZSApO1xuXG4gIHNlbGYuY2hlY2tUZXh0dXJlRnVsbG5lc3MoIHR4ciApO1xuXG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5cbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlcyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdDYWNoZXM7XG5cbiAgaWYoIGNhY2hlcyApe1xuICAgIGZvciggdmFyIGx2bCA9IG1pbkx2bDsgbHZsIDw9IG1heEx2bDsgbHZsKysgKXtcbiAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1sgbHZsIF07XG5cbiAgICAgIGlmKCBjYWNoZSApe1xuICAgICAgICB2YXIgdHhyID0gY2FjaGUudGV4dHVyZTtcblxuICAgICAgICAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG4gICAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoICs9IGNhY2hlLndpZHRoO1xuXG4gICAgICAgIC8vIHJlbW92ZSByZWZzIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgY2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgICAgIHV0aWwucmVtb3ZlRnJvbUFycmF5KCB0eHIuZWxlQ2FjaGVzLCBjYWNoZSApO1xuXG4gICAgICAgIC8vIG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoZSBlbnRpcmUgdGV4dHVyZSBpZiBpdCdzIG5vdCBlZmZpY2llbnRseSB1c2luZyBpdHMgc3BhY2VcbiAgICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KCB0eHIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uKCB0eHIgKXtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYoIHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGggKXtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUoIHR4ciApO1xuICB9XG59O1xuXG5FVENwLmNoZWNrVGV4dHVyZUZ1bGxuZXNzID0gZnVuY3Rpb24oIHR4ciApe1xuICAvLyBpZiB0ZXh0dXJlIGhhcyBiZWVuIG1vc3RseSBmaWxsZWQgYW5kIHBhc3NlZCBvdmVyIHNldmVyYWwgdGltZXMsIHJlbW92ZVxuICAvLyBpdCBmcm9tIHRoZSBxdWV1ZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlIHRpbWUgbG9va2luZyBhdCBpdCB0byBwdXQgbmV3IHRoaW5nc1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSggdHhyLmhlaWdodCApO1xuXG4gIGlmKCB0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzICl7XG4gICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHR4clEsIHR4ciApO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuXG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiggdHhyICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHR4clEsIHR4ciApO1xuXG4gIHR4ci5yZXRpcmVkID0gdHJ1ZTtcblxuICAvLyByZW1vdmUgdGhlIHJlZnMgZnJvbSB0aGUgZWxlcyB0byB0aGUgY2FjaGVzOlxuXG4gIHZhciBlbGVDYWNoZXMgPSB0eHIuZWxlQ2FjaGVzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlQ2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZUNhY2hlID0gZWxlQ2FjaGVzW2ldO1xuICAgIHZhciBlbGUgPSBlbGVDYWNoZS5lbGU7XG4gICAgdmFyIGx2bCA9IGVsZUNhY2hlLmxldmVsO1xuICAgIHZhciBpbWdDYWNoZXMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2guaW1nQ2FjaGVzO1xuXG4gICAgaWYoIGltZ0NhY2hlcyApe1xuICAgICAgaW1nQ2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdXRpbC5jbGVhckFycmF5KCBlbGVDYWNoZXMgKTtcblxuICAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSggdHhySCApO1xuXG4gIHJ0eHRyUS5wdXNoKCB0eHIgKTtcbn07XG5cbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uKCB0eHJILCBtaW5XICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSggdHhySCApO1xuICB2YXIgdHhyID0ge307XG5cbiAgdHhyUS5wdXNoKCB0eHIgKTtcblxuICB0eHIuZWxlQ2FjaGVzID0gW107XG5cbiAgdHhyLmhlaWdodCA9IHR4ckg7XG4gIHR4ci53aWR0aCA9IE1hdGgubWF4KCBkZWZUeHJXaWR0aCwgbWluVyApO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuXG4gIHR4ci5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB0eHIuY2FudmFzLndpZHRoID0gdHhyLndpZHRoO1xuICB0eHIuY2FudmFzLmhlaWdodCA9IHR4ci5oZWlnaHQ7XG5cbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgcmV0dXJuIHR4cjtcbn07XG5cbkVUQ3AucmVjeWNsZVRleHR1cmUgPSBmdW5jdGlvbiggdHhySCwgbWluVyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUoIHR4ckggKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSggdHhySCApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcblxuICAgIGlmKCB0eHIud2lkdGggPj0gbWluVyApe1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcblxuICAgICAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuXG4gICAgICB1dGlsLmNsZWFyQXJyYXkoIHR4ci5lbGVDYWNoZXMgKTtcblxuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB0eHIud2lkdGgsIHR4ci5oZWlnaHQgKTtcblxuICAgICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHJ0eHRyUSwgdHhyICk7XG4gICAgICB0eHJRLnB1c2goIHR4ciApO1xuXG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlLCBiYiwgbHZsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgaWQycSA9IHNlbGYuZ2V0RWxlbWVudElkVG9RdWV1ZSgpO1xuICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgdmFyIGV4aXN0aW5nUmVxID0gaWQycVsgaWQgXTtcblxuICBpZiggZXhpc3RpbmdSZXEgKXsgLy8gdXNlIHRoZSBtYXggbHZsIGIvYyBpbiBiZXR3ZWVuIGx2bHMgYXJlIGNoZWFwIHRvIG1ha2VcbiAgICBleGlzdGluZ1JlcS5sZXZlbCA9IE1hdGgubWF4KCBleGlzdGluZ1JlcS5sZXZlbCwgbHZsICk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKCBleGlzdGluZ1JlcSApO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSB7XG4gICAgICBlbGU6IGVsZSxcbiAgICAgIGJiOiBiYixcbiAgICAgIHBvc2l0aW9uOiBtYXRoLmNvcHlQb3NpdGlvbiggZWxlLnBvc2l0aW9uKCkgKSxcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICByZXFzOiAxXG4gICAgfTtcblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICAgIHJlcS5wb3NpdGlvbnMgPSB7XG4gICAgICAgIHNvdXJjZTogbWF0aC5jb3B5UG9zaXRpb24oIGVsZS5zb3VyY2UoKS5wb3NpdGlvbigpICksXG4gICAgICAgIHRhcmdldDogbWF0aC5jb3B5UG9zaXRpb24oIGVsZS50YXJnZXQoKS5wb3NpdGlvbigpIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcS5wdXNoKCByZXEgKTtcblxuICAgIGlkMnFbIGlkIF0gPSByZXE7XG4gIH1cbn07XG5cbkVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uKCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBpZDJxID0gc2VsZi5nZXRFbGVtZW50SWRUb1F1ZXVlKCk7XG4gIHZhciBkZXF1ZXVlZCA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZTsgaSsrICl7XG4gICAgaWYoIHEuc2l6ZSgpID4gMCApe1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG5cbiAgICAgIGlkMnFbIHJlcS5lbGUuaWQoKSBdID0gbnVsbDtcblxuICAgICAgZGVxdWV1ZWQucHVzaCggcmVxICk7XG5cbiAgICAgIHZhciBlbGUgPSByZXEuZWxlO1xuICAgICAgdmFyIGJiO1xuXG4gICAgICBpZihcbiAgICAgICAgKCBlbGUuaXNFZGdlKClcbiAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAhbWF0aC5hcmVQb3NpdGlvbnNTYW1lKCBlbGUuc291cmNlKCkucG9zaXRpb24oKSwgcmVxLnBvc2l0aW9ucy5zb3VyY2UgKVxuICAgICAgICAgICAgfHwgIW1hdGguYXJlUG9zaXRpb25zU2FtZSggZWxlLnRhcmdldCgpLnBvc2l0aW9uKCksIHJlcS5wb3NpdGlvbnMudGFyZ2V0IClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgfHwgKCAhbWF0aC5hcmVQb3NpdGlvbnNTYW1lKCBlbGUucG9zaXRpb24oKSwgcmVxLnBvc2l0aW9uICkgKVxuICAgICAgKXtcbiAgICAgICAgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJiID0gcmVxLmJiO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmdldEVsZW1lbnQoIHJlcS5lbGUsIGJiLCBweFJhdGlvLCByZXEubGV2ZWwsIGdldFR4clJlYXNvbnMuZGVxdWV1ZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxdWV1ZWQ7XG59O1xuXG5FVENwLm9uRGVxdWV1ZSA9IGZ1bmN0aW9uKCBmbiApeyB0aGlzLm9uRGVxdWV1ZXMucHVzaCggZm4gKTsgfTtcbkVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uKCBmbiApeyB1dGlsLnJlbW92ZUZyb21BcnJheSggdGhpcy5vbkRlcXVldWVzLCBmbiApOyB9O1xuXG5FVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQsXG4gIGRlcUNvc3Q6IGRlcUNvc3QsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCxcbiAgZGVxOiBmdW5jdGlvbiggc2VsZiwgcHhSYXRpbywgZXh0ZW50ICl7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZSggcHhSYXRpbywgZXh0ZW50ICk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24oIHNlbGYsIGRlcWQgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuXG4gICAgICBmbiggZGVxZCApO1xuICAgIH1cbiAgfSxcbiAgc2hvdWxkUmVkcmF3OiBmdW5jdGlvbiggc2VsZiwgZGVxZCwgcHhSYXRpbywgZXh0ZW50ICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXFkLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYmIgPSBkZXFkW2ldLmJiO1xuXG4gICAgICBpZiggbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBiYiwgZXh0ZW50ICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmlvcml0eTogZnVuY3Rpb24oIHNlbGYgKXtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZVR4ckRlcTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudFRleHR1cmVDYWNoZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiggdywgaCApe1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICBidWZmZXIud2lkdGggPSB3O1xuICBidWZmZXIuaGVpZ2h0ID0gaDtcblxuICByZXR1cm4gWyBidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCAnMmQnICkgXTtcbn07XG5cbkNScC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKCBiYi53ICkgOiBjdHJSZWN0WzJdO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKCBiYi5oICkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gaXMubnVtYmVyKCBvcHRpb25zLm1heFdpZHRoICkgfHwgaXMubnVtYmVyKCBvcHRpb25zLm1heEhlaWdodCApO1xuICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgc2NhbGUgPSAxO1xuXG4gIGlmKCBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgKXtcbiAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICB9IGVsc2UgaWYoIHNwZWNkTWF4RGltcyApe1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1heFdpZHRoICkgKXtcbiAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgIH1cblxuICAgIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWF4SGVpZ2h0ICkgKXtcbiAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBNYXRoLm1pbiggbWF4U2NhbGVXLCBtYXhTY2FsZUggKTtcblxuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuXG4gIGlmKCAhc3BlY2RNYXhEaW1zICl7XG4gICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICBzY2FsZSAqPSBweFJhdGlvO1xuICB9XG5cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgaWYoIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwICl7XG5cbiAgICBidWZmQ3h0LmNsZWFyUmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgaWYoIG9wdGlvbnMuYmcgKXtcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgaWYoIG9wdGlvbnMuZnVsbCApeyAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKCAtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUgKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoIHNjYWxlLCBzY2FsZSApO1xuXG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyggYnVmZkN4dCwgenNvcnRlZEVsZXMgKTtcbiAgICB9IGVsc2UgeyAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiBwYW4ueCAqIHNjYWxlLFxuICAgICAgICB5OiBwYW4ueSAqIHNjYWxlXG4gICAgICB9O1xuXG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG5cbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55ICk7XG4gICAgICBidWZmQ3h0LnNjYWxlKCBzY2FsZSwgc2NhbGUgKTtcblxuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoIGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZDYW52YXM7XG59O1xuXG5mdW5jdGlvbiBiNjRUb0Jsb2IoIGI2NCwgbWltZVR5cGUgKXtcbiAgdmFyIGJ5dGVzID0gYXRvYiggYjY0ICk7XG4gIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKCBieXRlcy5sZW5ndGggKTtcbiAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KCBidWZmICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKyApe1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoIFtidWZmXSwgeyB0eXBlOiBtaW1lVHlwZSB9ICk7XG59XG5cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KCBiNjR1cmkgKXtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuXG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKCBpICsgMSApO1xufTtcblxuZnVuY3Rpb24gb3V0cHV0KCBvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlICl7XG4gIHZhciBiNjRVcmkgPSBjYW52YXMudG9EYXRhVVJMKCBtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5ICk7XG5cbiAgc3dpdGNoKCBvcHRpb25zLm91dHB1dCApe1xuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYiggYjY0VXJpVG9CNjQoIGI2NFVyaSApLCBtaW1lVHlwZSApO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiNjRVcmlUb0I2NCggYjY0VXJpICk7XG5cbiAgICBjYXNlICdiYXNlNjR1cmknOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYjY0VXJpO1xuICB9XG59XG5cbkNScC5wbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICByZXR1cm4gb3V0cHV0KCBvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICksICdpbWFnZS9wbmcnICk7XG59O1xuXG5DUnAuanBnID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgcmV0dXJuIG91dHB1dCggb3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLCAnaW1hZ2UvanBlZycgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiLypcblRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IHJlcXVpcmUoJy4vZWxlLXRleHR1cmUtY2FjaGUnKTtcbnZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gcmVxdWlyZSgnLi9sYXllcmVkLXRleHR1cmUtY2FjaGUnKTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuXG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlciggb3B0aW9ucyApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5kYXRhID0ge1xuICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoIENScC5DQU5WQVNfTEFZRVJTICksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheSggQ1JwLkNBTlZBU19MQVlFUlMgKSxcbiAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KCBDUnAuQ0FOVkFTX0xBWUVSUyApLFxuXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheSggQ1JwLkJVRkZFUl9DT1VOVCApLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoIENScC5DQU5WQVNfTEFZRVJTICksXG4gIH07XG5cbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7JyApO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKCByLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG4gIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICggY29udGFpbmVyLmdldEF0dHJpYnV0ZSggJ3N0eWxlJyApIHx8ICcnICkgKyAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKysgKXtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzWyBpIF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuZGF0YS5jb250ZXh0c1sgaSBdID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCAnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOyBvdXRsaW5lLXN0eWxlOiBub25lOycgKyAoIGlzLm1zKCkgPyAnIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7IHRvdWNoLWFjdGlvbjogbm9uZTsgJyA6ICcnICkgKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoICdkYXRhLWlkJywgJ2xheWVyJyArIGkgKTtcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gU3RyaW5nKCBDUnAuQ0FOVkFTX0xBWUVSUyAtIGkgKTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKCBjYW52YXMgKTtcblxuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgaSBdID0gZmFsc2U7XG4gIH1cbiAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcblxuICByLmRhdGEuY2FudmFzZXNbIENScC5OT0RFIF0uc2V0QXR0cmlidXRlKCAnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuTk9ERSArICctbm9kZScgKTtcbiAgci5kYXRhLmNhbnZhc2VzWyBDUnAuU0VMRUNUX0JPWCBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcgKTtcbiAgci5kYXRhLmNhbnZhc2VzWyBDUnAuRFJBRyBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBDUnAuQlVGRkVSX0NPVU5UOyBpKysgKXtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzWyBpIF0gPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXS5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBpIF0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkgKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoIC1pIC0gMSApO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcblxuICByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZSggciApO1xuICByLmRhdGEubHlyVHhyQ2FjaGUgPSBuZXcgTGF5ZXJlZFRleHR1cmVDYWNoZSggciwgci5kYXRhLmVsZVR4ckNhY2hlICk7XG5cbiAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uIGludmFsaWRhdGVUZXh0dXJlQ2FjaGVzKCB3aWxsRHJhdywgZWxlcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuICAgICAgdmFyIGRlID0gcnMuZGlydHlFdmVudHM7XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgJiYgZGUgJiYgZGUubGVuZ3RoID09PSAxICYmIGRlWydwb3NpdGlvbiddICl7XG4gICAgICAgIC8vIHRoZW4ga2VlcCBjYWNoZWQgZWxlIHRleHR1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIuZGF0YS5lbGVUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgci5kYXRhLmx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyggZWxlcyApO1xuICAgIH1cbiAgfSk7XG59XG5cbkNScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24oIGdyb3VwLCBib29sICl7XG4gIHZhciByID0gdGhpcztcblxuICBzd2l0Y2goIGdyb3VwICl7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbIENScC5OT0RFIF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbIENScC5EUkFHIF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLlNFTEVDVF9CT1ggXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24oIG9uICl7XG4gIGlmKCBvbiA9PT0gdW5kZWZpbmVkICl7XG4gICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICB9XG5cbiAgdGhpcy5wYXRoc0VuYWJsZWQgPSBvbiA/IHRydWUgOiBmYWxzZTtcbn07XG5cbkNScC51c2VQYXRocyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xufTtcblxuW1xuICByZXF1aXJlKCAnLi9hcnJvdy1zaGFwZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctZWxlbWVudHMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctZWRnZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctaW1hZ2VzJyApLFxuICByZXF1aXJlKCAnLi9kcmF3aW5nLWxhYmVsLXRleHQnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctbm9kZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctcmVkcmF3JyApLFxuICByZXF1aXJlKCAnLi9kcmF3aW5nLXNoYXBlcycgKSxcbiAgcmVxdWlyZSggJy4vZXhwb3J0LWltYWdlJyApLFxuICByZXF1aXJlKCAnLi9ub2RlLXNoYXBlcycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIENScCwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgSGVhcCA9IHJlcXVpcmUoICcuLi8uLi8uLi9oZWFwJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIGRlZnMgPSByZXF1aXJlKCAnLi90ZXh0dXJlLWNhY2hlLWRlZnMnICk7XG5cbnZhciBkZWZOdW1MYXllcnMgPSAxOyAvLyBkZWZhdWx0IG51bWJlciBvZiBsYXllcnMgdG8gdXNlXG52YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSA1MDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcbnZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcbnZhciBkaXNhYmxlRWxlSW1nU21vb3RoaW5nID0gdHJ1ZTsgLy8gd2hlbiBkcmF3aW5nIGVsZXMgb24gbGF5ZXJzIGZyb20gYW4gZWxlIGNhY2hlIDsgY3Jpc3BlciBhbmQgbW9yZSBwZXJmb3JtYW50IHdoZW4gdHJ1ZVxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgbWF4RGVxU2l6ZSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG52YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xudmFyIG1heExheWVyQXJlYSA9IDQwMDAgKiA0MDAwOyAvLyBsYXllcnMgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhpc1xudmFyIGFsd2F5c1F1ZXVlID0gdHJ1ZTsgLy8gbmV2ZXIgZHJhdyBhbGwgdGhlIGxheWVycyBpbiBhIGxldmVsIG9uIGEgZnJhbWU7IGRyYXcgZGlyZWN0bHkgdW50aWwgYWxsIGRlcXVldWVkXG52YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuXG52YXIgdXNlRWxlVHhyQ2FjaGluZyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGluZGl2aWR1YWwgZWxlIHRleHR1cmUgY2FjaGluZyB1bmRlcm5lYXRoIHRoaXMgY2FjaGVcblxuLy8gdmFyIGxvZyA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTsgfTtcblxudmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiggcmVuZGVyZXIsIGVsZVR4ckNhY2hlICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICBzZWxmLmxheWVyc0J5TGV2ZWwgPSB7fTsgLy8gZS5nLiAyID0+IFsgbGF5ZXIxLCBsYXllcjIsIC4uLiwgbGF5ZXJOIF1cblxuICBzZWxmLmZpcnN0R2V0ID0gdHJ1ZTtcblxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpIC0gMippbnZhbGlkVGhyZXNob2xkO1xuXG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcblxuICByLmJlZm9yZVJlbmRlcihmdW5jdGlvbiggd2lsbERyYXcsIG5vdyApe1xuICAgIGlmKCBub3cgLSBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lIDw9IGludmFsaWRUaHJlc2hvbGQgKXtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcVNvcnQgPSBmdW5jdGlvbihhLCBiKXtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9O1xuXG4gIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgSGVhcCggcVNvcnQgKTtcblxuICBzZWxmLmVsZVR4ckNhY2hlID0gZWxlVHhyQ2FjaGU7XG5cbiAgc2VsZi5zZXR1cEVsZUNhY2hlSW52YWxpZGF0aW9uKCk7XG5cbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5cbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbkxUQ3AubWFrZUxheWVyID0gZnVuY3Rpb24oIGJiLCBsdmwgKXtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuXG4gIHZhciB3ID0gTWF0aC5jZWlsKCBiYi53ICogc2NhbGUgKTtcbiAgdmFyIGggPSBNYXRoLmNlaWwoIGJiLmggKiBzY2FsZSApO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuXG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogKGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQgKSxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07XG5cbiAgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7XG5cbiAgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG4gIGN4dC5zY2FsZSggc2NhbGUsIHNjYWxlICk7XG4gIGN4dC50cmFuc2xhdGUoIGR4LCBkeSApO1xuXG4gIHJldHVybiBsYXllcjtcbn07XG5cbkxUQ3AuZ2V0TGF5ZXJzID0gZnVuY3Rpb24oIGVsZXMsIHB4UmF0aW8sIGx2bCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBmaXJzdEdldCA9IHNlbGYuZmlyc3RHZXQ7XG5cbiAgc2VsZi5maXJzdEdldCA9IGZhbHNlO1xuXG4gIC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYoIGx2bCA9PSBudWxsICl7XG4gICAgbHZsID0gTWF0aC5jZWlsKCBtYXRoLmxvZzIoIHpvb20gKiBweFJhdGlvICkgKTtcblxuICAgIGlmKCBsdmwgPCBtaW5MdmwgKXtcbiAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICB9IGVsc2UgaWYoIHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcoIGx2bCwgZWxlcyApO1xuXG4gIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbIGx2bCBdID0gbGF5ZXJzQnlMdmxbIGx2bCBdIHx8IFtdO1xuICB2YXIgYmI7XG5cbiAgdmFyIGx2bENvbXBsZXRlID0gc2VsZi5sZXZlbElzQ29tcGxldGUoIGx2bCwgZWxlcyApO1xuICB2YXIgdG1wTGF5ZXJzO1xuXG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjYW5Vc2VBc1RtcEx2bCA9IGZ1bmN0aW9uKCBsICl7XG4gICAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKCBsLCBlbGVzICk7XG5cbiAgICAgIGlmKCBzZWxmLmxldmVsSXNDb21wbGV0ZSggbCwgZWxlcyApICl7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uKCBkaXIgKXtcbiAgICAgIGlmKCB0bXBMYXllcnMgKXsgcmV0dXJuOyB9XG5cbiAgICAgIGZvciggdmFyIGwgPSBsdmwgKyBkaXI7IG1pbkx2bCA8PSBsICYmIGwgPD0gbWF4THZsOyBsICs9IGRpciApe1xuICAgICAgICBpZiggY2FuVXNlQXNUbXBMdmwobCkgKXsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tMdmxzKCArMSApO1xuICAgIGNoZWNrTHZscyggLTEgKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgaW52YWxpZCBsYXllcnM7IHRoZXkgd2lsbCBiZSByZXBsYWNlZCBhcyBuZWVkZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvblxuICAgIGZvciggdmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgaWYoIGxheWVyLmludmFsaWQgKXtcbiAgICAgICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIGxheWVycywgbGF5ZXIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYoICFsdmxDb21wbGV0ZSApe1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuXG4gICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBsb2coJ2xldmVsIGNvbXBsZXRlLCB1c2luZyBleGlzdGluZyBsYXllcnNcXG4tLScpO1xuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICB2YXIgZ2V0QmIgPSBmdW5jdGlvbigpe1xuICAgIGlmKCAhYmIgKXtcbiAgICAgIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIG1hdGgudXBkYXRlQm91bmRpbmdCb3goIGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuXG4gICAgZ2V0QmIoKTtcblxuICAgIHZhciBhcmVhID0gKCBiYi53ICogc2NhbGUgKSAqICggYmIuaCAqIHNjYWxlICk7XG5cbiAgICBpZiggYXJlYSA+IG1heExheWVyQXJlYSApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoIGJiLCBsdmwgKTtcblxuICAgIGlmKCBhZnRlciAhPSBudWxsICl7XG4gICAgICB2YXIgaW5kZXggPSBsYXllcnMuaW5kZXhPZiggYWZ0ZXIgKSArIDE7XG5cbiAgICAgIGxheWVycy5zcGxpY2UoIGluZGV4LCAwLCBsYXllciApO1xuICAgIH0gZWxzZSBpZiggb3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCApe1xuICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICBsYXllcnMudW5zaGlmdCggbGF5ZXIgKTtcbiAgICB9XG5cbiAgICAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgICAvL3NlbGYucXVldWVMYXllciggbGF5ZXIgKTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH07XG5cbiAgaWYoIHNlbGYuc2tpcHBpbmcgJiYgIWZpcnN0R2V0ICl7XG4gICAgLy8gbG9nKCdza2lwIGxheWVycycpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbG9nKCdkbyBsYXllcnMnKTtcblxuICB2YXIgbGF5ZXIgPSBudWxsO1xuICB2YXIgbWF4RWxlc1BlckxheWVyID0gZWxlcy5sZW5ndGggLyBkZWZOdW1MYXllcnM7XG4gIHZhciBhbGxvd0xhenlRdWV1ZWluZyA9IGFsd2F5c1F1ZXVlICYmICFmaXJzdEdldDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbIGx2bCBdO1xuXG4gICAgaWYoIGV4aXN0aW5nTGF5ZXIgKXtcbiAgICAgIC8vIHJldXNlIGxheWVyIGZvciBsYXRlciBlbGVzXG4gICAgICAvLyBsb2coJ3JldXNlIGxheWVyIGZvcicsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gZXhpc3RpbmdMYXllcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKFxuICAgICAgIWxheWVyXG4gICAgICB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXJcbiAgICAgIHx8ICFtYXRoLmJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCggbGF5ZXIuYmIsIGVsZS5ib3VuZGluZ0JveCgpIClcbiAgICApe1xuICAgICAgLy8gbG9nKCdtYWtlIG5ldyBsYXllciBmb3IgZWxlICVzJywgZWxlLmlkKCkpO1xuXG4gICAgICBsYXllciA9IG1ha2VMYXllcih7IGluc2VydDogdHJ1ZSwgYWZ0ZXI6IGxheWVyIH0pO1xuXG4gICAgICAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG4gICAgICBpZiggIWxheWVyICl7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG4gICAgfVxuXG4gICAgaWYoIHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZyApe1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKCBsYXllciwgZWxlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllciggbGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvICk7XG4gICAgfVxuXG4gICAgbGF5ZXIuZWxlcy5wdXNoKCBlbGUgKTtcblxuICAgIGNhY2hlc1sgbHZsIF0gPSBsYXllcjtcbiAgfVxuXG4gIC8vIGxvZygnLS0nKTtcblxuICBpZiggdG1wTGF5ZXJzICl7IC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuXG4gIGlmKCBhbGxvd0xhenlRdWV1ZWluZyApe1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufTtcblxuLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiggbHZsLCBweFJhdGlvICl7XG4gIHJldHVybiBsdmw7XG59O1xuXG5mdW5jdGlvbiBpbWdTbW9vdGhpbmcoIGNvbnRleHQsIGJvb2wgKXtcbiAgaWYoIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwgKXtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufVxuXG5MVENwLmRyYXdFbGVJbkxheWVyID0gZnVuY3Rpb24oIGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIGNvbnRleHQgPSBsYXllci5jb250ZXh0O1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IHJldHVybjsgfVxuXG4gIHZhciBlbGVDYWNoZSA9IHNlbGYuZWxlVHhyQ2FjaGU7XG4gIHZhciByZWFzb24gPSB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPyBlbGVDYWNoZS5yZWFzb25zLmhpZ2hRdWFsaXR5IDogdW5kZWZpbmVkO1xuXG4gIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKCBsdmwsIHB4UmF0aW8gKTtcblxuICB2YXIgY2FjaGUgPSB1c2VFbGVUeHJDYWNoaW5nID8gZWxlQ2FjaGUuZ2V0RWxlbWVudCggZWxlLCBiYiwgbnVsbCwgbHZsLCByZWFzb24gKSA6IG51bGw7XG5cbiAgaWYoIGNhY2hlICl7XG4gICAgaWYoIGRpc2FibGVFbGVJbWdTbW9vdGhpbmcgKXsgaW1nU21vb3RoaW5nKCBjb250ZXh0LCBmYWxzZSApOyB9XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSggY2FjaGUudGV4dHVyZS5jYW52YXMsIGNhY2hlLngsIDAsIGNhY2hlLndpZHRoLCBjYWNoZS5oZWlnaHQsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCApO1xuXG4gICAgaWYoIGRpc2FibGVFbGVJbWdTbW9vdGhpbmcgKXsgaW1nU21vb3RoaW5nKCBjb250ZXh0LCB0cnVlICk7IH1cbiAgfSBlbHNlIHsgLy8gaWYgdGhlIGVsZW1lbnQgaXMgbm90IGNhY2hlYWJsZSwgdGhlbiBkcmF3IGRpcmVjdGx5XG4gICAgci5kcmF3RWxlbWVudCggY29udGV4dCwgZWxlICk7XG4gIH1cbn07XG5cbkxUQ3AubGV2ZWxJc0NvbXBsZXRlID0gZnVuY3Rpb24oIGx2bCwgZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbIGx2bCBdO1xuXG4gIGlmKCAhbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmKCBsYXllci5yZXFzID4gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBpcyBpbnZhbGlkLCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYoIGxheWVyLmludmFsaWQgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcbiAgaWYoIG51bUVsZXNJbkxheWVycyAhPT0gZWxlcy5sZW5ndGggKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24oIGx2bCwgZWxlcyApe1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsWyBsdmwgXTtcblxuICBpZiggIWxheWVycyApeyByZXR1cm47IH1cblxuICAvLyBpZiBpbiBhIGxheWVyIHRoZSBlbGVzIGFyZSBub3QgaW4gdGhlIHNhbWUgb3JkZXIsIHRoZW4gdGhlIGxheWVyIGlzIGludmFsaWRcbiAgLy8gKGkuZS4gdGhlcmUgaXMgYW4gZWxlIGluIGJldHdlZW4gdGhlIGVsZXMgaW4gdGhlIGxheWVyKVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcblxuICAgIC8vIGZpbmQgdGhlIG9mZnNldFxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgaWYoIGxheWVyLmVsZXNbMF0gPT09IGVsZXNbal0gKXtcbiAgICAgICAgb2Zmc2V0ID0gajtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIG9mZnNldCA8IDAgKXtcbiAgICAgIC8vIHRoZW4gdGhlIGxheWVyIGhhcyBub25leGlzdGFudCBlbGVtZW50cyBhbmQgaXMgaW52YWxpZFxuICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgaWYoIGxheWVyLmVsZXNbal0gIT09IGVsZXNbbytqXSApe1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTFRDcC51cGRhdGVFbGVtZW50c0luTGF5ZXJzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpc0VsZXMgPSBpcy5lbGVtZW50KCBlbGVzWzBdICk7XG5cbiAgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBmb3IoIHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrICl7XG4gICAgICB2YXIgbGF5ZXIgPSBjYWNoZXNbbF07XG5cbiAgICAgIGlmKCAhbGF5ZXIgKXsgY29udGludWU7IH1cblxuICAgICAgLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgIGlmKCByZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwoIGxheWVyLmxldmVsICkgIT09IHJlcS5sZXZlbCApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCBsYXllciwgZWxlLCByZXEgKTtcbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AuaGF2ZUxheWVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcblxuICBmb3IoIHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrICl7XG4gICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsXTtcblxuICAgIGlmKCBsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCA+IDAgKXtcbiAgICAgIGhhdmVMYXllcnMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhdmVMYXllcnM7XG59O1xuXG5MVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICBpZiggZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpICl7IHJldHVybjsgfVxuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyggZWxlcywgZnVuY3Rpb24gaW52YWxBc3NvY0xheWVycyggbGF5ZXIsIGVsZSwgcmVxICl7XG4gICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gIH0gKTtcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24oIGxheWVyICl7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuXG4gIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYoIGxheWVyLmludmFsaWQgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzXG5cbiAgdmFyIGx2bCA9IGxheWVyLmxldmVsO1xuICB2YXIgZWxlcyA9IGxheWVyLmVsZXM7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbIGx2bCBdO1xuXG4gICAvLyBsb2coJ2ludmFsaWRhdGUgbGF5ZXInLCBsYXllci5pZCApO1xuXG4gIHV0aWwucmVtb3ZlRnJvbUFycmF5KCBsYXllcnMsIGxheWVyICk7XG4gIC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcblxuICBsYXllci5pbnZhbGlkID0gdHJ1ZTtcblxuICBpZiggbGF5ZXIucmVwbGFjZW1lbnQgKXtcbiAgICBsYXllci5yZXBsYWNlbWVudC5pbnZhbGlkID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuXG4gICAgaWYoIGNhY2hlcyApe1xuICAgICAgY2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoIGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUoIGxheWVyLCBlbGUsIHJlcSApe1xuICAgIHZhciByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQ7XG5cbiAgICBpZiggIXJMeXIgKXtcbiAgICAgIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudCA9IHNlbGYubWFrZUxheWVyKCBsYXllci5iYiwgbGF5ZXIubGV2ZWwgKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7XG5cbiAgICAgICAvLyBsb2coJ21ha2UgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgZm9yICVzIHdpdGggbGV2ZWwgJXMnLCByTHlyLmlkLCBsYXllci5pZCwgckx5ci5sZXZlbCk7XG4gICAgfVxuXG4gICAgaWYoICFyTHlyLnJlcXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgckx5ci5lbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHNlbGYucXVldWVMYXllciggckx5ciwgckx5ci5lbGVzW2ldICk7XG4gICAgICB9XG5cbiAgICAgICAvLyBsb2coJ3F1ZXVlIHJlcGxhY2VtZW50IGxheWVyIHJlZmluZW1lbnQnLCByTHlyLmlkKTtcbiAgICB9XG4gIH0gKTtcbn07XG5cbkxUQ3Auc2V0dXBFbGVDYWNoZUludmFsaWRhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZURlcXMgPSBbXTtcblxuICBpZiggIXVzZUVsZVR4ckNhY2hpbmcgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHVwZGF0ZWRFbGVzSW5MYXllcnMgPSB1dGlsLmRlYm91bmNlKCBmdW5jdGlvbigpe1xuICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKCBlbGVEZXFzICk7XG5cbiAgICBlbGVEZXFzID0gW107XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSApO1xuXG4gIHNlbGYuZWxlVHhyQ2FjaGUub25EZXF1ZXVlKGZ1bmN0aW9uKCByZXFzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrICl7XG4gICAgICBlbGVEZXFzLnB1c2goIHJlcXNbaV0gKTtcbiAgICB9XG5cbiAgICB1cGRhdGVkRWxlc0luTGF5ZXJzKCk7XG4gIH0pO1xufTtcblxuTFRDcC5xdWV1ZUxheWVyID0gZnVuY3Rpb24oIGxheWVyLCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBlbGVzUSA9IGxheWVyLmVsZXNRdWV1ZTtcbiAgdmFyIGhhc0lkID0gZWxlc1EuaGFzSWQgPSBlbGVzUS5oYXNJZCB8fCB7fTtcblxuICAvLyBpZiBhIGxheWVyIGlzIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBxdWV1aW5nIGlzIGEgd2FzdGUgb2YgdGltZVxuICBpZiggbGF5ZXIucmVwbGFjZW1lbnQgKXsgcmV0dXJuOyB9XG5cbiAgaWYoIGVsZSApe1xuICAgIGlmKCBoYXNJZFsgZWxlLmlkKCkgXSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZXNRLnB1c2goIGVsZSApO1xuICAgIGhhc0lkWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmKCBsYXllci5yZXFzICl7XG4gICAgbGF5ZXIucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKCBsYXllciApO1xuICB9IGVsc2Uge1xuICAgIGxheWVyLnJlcXMgPSAxO1xuXG4gICAgcS5wdXNoKCBsYXllciApO1xuICB9XG59O1xuXG5MVENwLmRlcXVldWUgPSBmdW5jdGlvbiggcHhSYXRpbyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGRlcWQgPSBbXTtcbiAgdmFyIGVsZURlcXMgPSAwO1xuXG4gIHdoaWxlKCBlbGVEZXFzIDwgbWF4RGVxU2l6ZSApe1xuICAgIGlmKCBxLnNpemUoKSA9PT0gMCApeyBicmVhazsgfVxuXG4gICAgdmFyIGxheWVyID0gcS5wZWVrKCk7XG5cbiAgICAvLyBpZiBhIGxheWVyIGhhcyBiZWVuIG9yIHdpbGwgYmUgcmVwbGFjZWQsIHRoZW4gZG9uJ3Qgd2FzdGUgdGltZSB3aXRoIGl0XG4gICAgaWYoIGxheWVyLnJlcGxhY2VtZW50ICl7XG4gICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG4gICAgaWYoIGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCApe1xuICAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKCBsYXllci5pbnZhbGlkICl7XG4gICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciAlcyBpcyBpbnZhbGlkOyBkZXF1ZXVlZCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKCBsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyApO1xuXG4gICAgICBlbGVEZXFzKys7XG4gICAgfVxuXG4gICAgaWYoIGRlcWQubGVuZ3RoID09PSAwICl7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKCB0cnVlICk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcbiAgICBpZiggbGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCApe1xuICAgICAgcS5wb3AoKTtcblxuICAgICAgbGF5ZXIucmVxcyA9IDA7XG5cbiAgICAgICAvLyBsb2coJ2RlcXVldWUgb2YgbGF5ZXIgJXMgY29tcGxldGUnLCBsYXllci5pZCk7XG5cbiAgICAgIC8vIHdoZW4gYSByZXBsYWNlbWVudCBsYXllciBpcyBkZXF1ZXVlZCwgaXQgcmVwbGFjZXMgdGhlIG9sZCBsYXllciBpbiB0aGUgbGV2ZWxcbiAgICAgIGlmKCBsYXllci5yZXBsYWNlcyApe1xuICAgICAgICBzZWxmLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCggbGF5ZXIgKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcWQ7XG59O1xuXG5MVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uKCBsYXllciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsWyBsYXllci5sZXZlbCBdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKCByZXBsYWNlZCApO1xuXG4gIC8vIGlmIHRoZSByZXBsYWNlZCBsYXllciBpcyBub3QgaW4gdGhlIGFjdGl2ZSBsaXN0IGZvciB0aGUgbGV2ZWwsIHRoZW4gcmVwbGFjaW5nXG4gIC8vIHJlZnMgd291bGQgYmUgYSBtaXN0YWtlIChpLmUuIG92ZXJ3cml0aW5nIHRoZSB0cnVlIGFjdGl2ZSBsYXllcilcbiAgaWYoIGluZGV4IDwgMCB8fCByZXBsYWNlZC5pbnZhbGlkICl7XG4gICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGF5ZXJzSW5MZXZlbFsgaW5kZXggXSA9IGxheWVyOyAvLyByZXBsYWNlIGxldmVsIHJlZlxuXG4gIC8vIHJlcGxhY2UgcmVmcyBpbiBlbGVzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBfcCA9IGxheWVyLmVsZXNbaV0uX3ByaXZhdGU7XG4gICAgdmFyIGNhY2hlID0gX3AuaW1nTGF5ZXJDYWNoZXMgPSBfcC5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGlmKCBjYWNoZSApe1xuICAgICAgY2FjaGVbIGxheWVyLmxldmVsIF0gPSBsYXllcjtcbiAgICB9XG4gIH1cblxuICAgLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbn07XG5cbkxUQ3AucmVxdWVzdFJlZHJhdyA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcblxuICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICByLnJlZHJhdygpO1xufSwgMTAwICk7XG5cbkxUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uKCBzZWxmLCBweFJhdGlvICl7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZSggcHhSYXRpbyApO1xuICB9LFxuICBvbkRlcWQ6IHV0aWwubm9vcCxcbiAgc2hvdWxkUmVkcmF3OiB1dGlsLnRydWVpZnksXG4gIHByaW9yaXR5OiBmdW5jdGlvbiggc2VsZiApe1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXllcmVkVGV4dHVyZUNhY2hlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24oIG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyApe1xuICBzd2l0Y2goIG5hbWUgKXtcbiAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKTtcbiAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgY2FzZSAnY3V0cmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdDdXRSZWN0YW5nbGVQYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgY2FzZSAnYmFycmVsJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgZnVsbEZwc1RpbWUgPSAxMDAwLzYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24oIG9wdHMgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICBpZiggc2VsZi5kZXF1ZXVlaW5nU2V0dXAgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5kZXF1ZXVlaW5nU2V0dXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVldWVSZWRyYXcgPSB1dGlsLmRlYm91bmNlKCBmdW5jdGlvbigpe1xuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCApO1xuXG4gICAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uKCB3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUgKXtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIHdoaWxlKCB0cnVlICl7XG4gICAgICAgICAgdmFyIG5vdyA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBub3cgLSBmcmFtZVN0YXJ0VGltZTtcblxuICAgICAgICAgIGlmKCByZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUgKXtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG5cbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAoIHdpbGxEcmF3ID8gYXZnUmVuZGVyVGltZSA6IDAgKTtcblxuICAgICAgICAgICAgaWYoIGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUgKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCB3aWxsRHJhdyApe1xuICAgICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA+PSBvcHRzLmRlcUNvc3QgKiByZW5kZXJUaW1lXG4gICAgICAgICAgICAgICAgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZVxuICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUgKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoIHNlbGYsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuXG4gICAgICAgICAgaWYoIHRoaXNEZXFkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgZGVxZC5wdXNoKCB0aGlzRGVxZFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuICAgICAgICBpZiggZGVxZC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgb3B0cy5vbkRlcWQoIHNlbGYsIGRlcWQgKTtcblxuICAgICAgICAgIGlmKCAhd2lsbERyYXcgJiYgb3B0cy5zaG91bGRSZWRyYXcoIHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCApICl7XG4gICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCB1dGlsLm5vb3A7XG5cbiAgICAgIHIuYmVmb3JlUmVuZGVyKCBkZXF1ZXVlLCBwcmlvcml0eSggc2VsZiApICk7XG4gICAgfTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgbmFtZTogJ251bGwnLCBpbXBsOiByZXF1aXJlKCAnLi9udWxsJyApIH0sXG4gIHsgbmFtZTogJ2Jhc2UnLCBpbXBsOiByZXF1aXJlKCAnLi9iYXNlJyApIH0sXG4gIHsgbmFtZTogJ2NhbnZhcycsIGltcGw6IHJlcXVpcmUoICcuL2NhbnZhcycgKSB9XG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBOdWxsUmVuZGVyZXIoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbigpe307XG5cbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgbm90aWZ5OiBmdW5jdGlvbigpeyB0aGlzLm5vdGlmaWNhdGlvbnMrKzsgfSxcbiAgaW5pdDogbm9vcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsUmVuZGVyZXI7XG4iLCIvKiFcblBvcnRlZCBieSBYdWVxaWFvIFh1IDx4dWVxaWFveHVAZ21haWwuY29tPjtcblxuUFNGIExJQ0VOU0UgQUdSRUVNRU5UIEZPUiBQWVRIT04gMi43LjJcblxuMS4gVGhpcyBMSUNFTlNFIEFHUkVFTUVOVCBpcyBiZXR3ZWVuIHRoZSBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbiAo4oCcUFNG4oCdKSwgYW5kIHRoZSBJbmRpdmlkdWFsIG9yIE9yZ2FuaXphdGlvbiAo4oCcTGljZW5zZWXigJ0pIGFjY2Vzc2luZyBhbmQgb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiBzb2Z0d2FyZSBpbiBzb3VyY2Ugb3IgYmluYXJ5IGZvcm0gYW5kIGl0cyBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24uXG4yLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LCBQU0YgaGVyZWJ5IGdyYW50cyBMaWNlbnNlZSBhIG5vbmV4Y2x1c2l2ZSwgcm95YWx0eS1mcmVlLCB3b3JsZC13aWRlIGxpY2Vuc2UgdG8gcmVwcm9kdWNlLCBhbmFseXplLCB0ZXN0LCBwZXJmb3JtIGFuZC9vciBkaXNwbGF5IHB1YmxpY2x5LCBwcmVwYXJlIGRlcml2YXRpdmUgd29ya3MsIGRpc3RyaWJ1dGUsIGFuZCBvdGhlcndpc2UgdXNlIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uLCBwcm92aWRlZCwgaG93ZXZlciwgdGhhdCBQU0bigJlzIExpY2Vuc2UgQWdyZWVtZW50IGFuZCBQU0bigJlzIG5vdGljZSBvZiBjb3B5cmlnaHQsIGkuZS4sIOKAnENvcHlyaWdodCDCqSAyMDAxLTIwMTIgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWTigJ0gYXJlIHJldGFpbmVkIGluIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uIHByZXBhcmVkIGJ5IExpY2Vuc2VlLlxuMy4gSW4gdGhlIGV2ZW50IExpY2Vuc2VlIHByZXBhcmVzIGEgZGVyaXZhdGl2ZSB3b3JrIHRoYXQgaXMgYmFzZWQgb24gb3IgaW5jb3Jwb3JhdGVzIFB5dGhvbiAyLjcuMiBvciBhbnkgcGFydCB0aGVyZW9mLCBhbmQgd2FudHMgdG8gbWFrZSB0aGUgZGVyaXZhdGl2ZSB3b3JrIGF2YWlsYWJsZSB0byBvdGhlcnMgYXMgcHJvdmlkZWQgaGVyZWluLCB0aGVuIExpY2Vuc2VlIGhlcmVieSBhZ3JlZXMgdG8gaW5jbHVkZSBpbiBhbnkgc3VjaCB3b3JrIGEgYnJpZWYgc3VtbWFyeSBvZiB0aGUgY2hhbmdlcyBtYWRlIHRvIFB5dGhvbiAyLjcuMi5cbjQuIFBTRiBpcyBtYWtpbmcgUHl0aG9uIDIuNy4yIGF2YWlsYWJsZSB0byBMaWNlbnNlZSBvbiBhbiDigJxBUyBJU+KAnSBiYXNpcy4gUFNGIE1BS0VTIE5PIFJFUFJFU0VOVEFUSU9OUyBPUiBXQVJSQU5USUVTLCBFWFBSRVNTIE9SIElNUExJRUQuIEJZIFdBWSBPRiBFWEFNUExFLCBCVVQgTk9UIExJTUlUQVRJT04sIFBTRiBNQUtFUyBOTyBBTkQgRElTQ0xBSU1TIEFOWSBSRVBSRVNFTlRBVElPTiBPUiBXQVJSQU5UWSBPRiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQU5ZIFBBUlRJQ1VMQVIgUFVSUE9TRSBPUiBUSEFUIFRIRSBVU0UgT0YgUFlUSE9OIDIuNy4yIFdJTEwgTk9UIElORlJJTkdFIEFOWSBUSElSRCBQQVJUWSBSSUdIVFMuXG41LiBQU0YgU0hBTEwgTk9UIEJFIExJQUJMRSBUTyBMSUNFTlNFRSBPUiBBTlkgT1RIRVIgVVNFUlMgT0YgUFlUSE9OIDIuNy4yIEZPUiBBTlkgSU5DSURFTlRBTCwgU1BFQ0lBTCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIExPU1MgQVMgQSBSRVNVTFQgT0YgTU9ESUZZSU5HLCBESVNUUklCVVRJTkcsIE9SIE9USEVSV0lTRSBVU0lORyBQWVRIT04gMi43LjIsIE9SIEFOWSBERVJJVkFUSVZFIFRIRVJFT0YsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgVEhFUkVPRi5cbjYuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZSB1cG9uIGEgbWF0ZXJpYWwgYnJlYWNoIG9mIGl0cyB0ZXJtcyBhbmQgY29uZGl0aW9ucy5cbjcuIE5vdGhpbmcgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBzaGFsbCBiZSBkZWVtZWQgdG8gY3JlYXRlIGFueSByZWxhdGlvbnNoaXAgb2YgYWdlbmN5LCBwYXJ0bmVyc2hpcCwgb3Igam9pbnQgdmVudHVyZSBiZXR3ZWVuIFBTRiBhbmQgTGljZW5zZWUuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgUFNGIHRyYWRlbWFya3Mgb3IgdHJhZGUgbmFtZSBpbiBhIHRyYWRlbWFyayBzZW5zZSB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgb3Igc2VydmljZXMgb2YgTGljZW5zZWUsIG9yIGFueSB0aGlyZCBwYXJ0eS5cbjguIEJ5IGNvcHlpbmcsIGluc3RhbGxpbmcgb3Igb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiwgTGljZW5zZWUgYWdyZWVzIHRvIGJlIGJvdW5kIGJ5IHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuXG52YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbmZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuLypcbkRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gKi9cblxuZGVmYXVsdENtcCA9IGZ1bmN0aW9uKCB4LCB5ICl7XG4gIGlmKCB4IDwgeSApe1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiggeCA+IHkgKXtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuLypcbkluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG5cbklmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cblxuT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxub2YgYSB0byBiZSBzZWFyY2hlZC5cbiAqL1xuXG5pbnNvcnQgPSBmdW5jdGlvbiggYSwgeCwgbG8sIGhpLCBjbXAgKXtcbiAgdmFyIG1pZDtcbiAgaWYoIGxvID09IG51bGwgKXtcbiAgICBsbyA9IDA7XG4gIH1cbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBpZiggbG8gPCAwICl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCAnbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnICk7XG4gIH1cbiAgaWYoIGhpID09IG51bGwgKXtcbiAgICBoaSA9IGEubGVuZ3RoO1xuICB9XG4gIHdoaWxlKCBsbyA8IGhpICl7XG4gICAgbWlkID0gZmxvb3IoIChsbyArIGhpKSAvIDIgKTtcbiAgICBpZiggY21wKCB4LCBhWyBtaWQgXSApIDwgMCApe1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoIGEsIFsgbG8sIGxvIC0gbG8gXS5jb25jYXQoIHggKSApLCB4KTtcbn07XG5cblxuLypcblB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAqL1xuXG5oZWFwcHVzaCA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgYXJyYXkucHVzaCggaXRlbSApO1xuICByZXR1cm4gX3NpZnRkb3duKCBhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wICk7XG59O1xuXG5cbi8qXG5Qb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gKi9cblxuaGVhcHBvcCA9IGZ1bmN0aW9uKCBhcnJheSwgY21wICl7XG4gIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgaWYoIGFycmF5Lmxlbmd0aCApe1xuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgX3NpZnR1cCggYXJyYXksIDAsIGNtcCApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICB9XG4gIHJldHVybiByZXR1cm5pdGVtO1xufTtcblxuXG4vKlxuUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuXG5UaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbm1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxucmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxudGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAqL1xuXG5oZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIHZhciByZXR1cm5pdGVtO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgYXJyYXlbMF0gPSBpdGVtO1xuICBfc2lmdHVwKCBhcnJheSwgMCwgY21wICk7XG4gIHJldHVybiByZXR1cm5pdGVtO1xufTtcblxuXG4vKlxuRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICovXG5cbmhlYXBwdXNocG9wID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtLCBjbXAgKXtcbiAgdmFyIF9yZWY7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgaWYoIGFycmF5Lmxlbmd0aCAmJiBjbXAoIGFycmF5WzBdLCBpdGVtICkgPCAwICl7XG4gICAgX3JlZiA9IFsgYXJyYXlbMF0sIGl0ZW0gXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICBfc2lmdHVwKCBhcnJheSwgMCwgY21wICk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbi8qXG5UcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICovXG5cbmhlYXBpZnkgPSBmdW5jdGlvbiggYXJyYXksIGNtcCApe1xuICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBfcmVmMSA9IChmdW5jdGlvbigpe1xuICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgIGZvciggdmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKCBhcnJheS5sZW5ndGggLyAyICk7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0gKXsgX3Jlc3VsdHMxLnB1c2goIF9qICk7IH1cbiAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICB9KS5hcHBseSggdGhpcyApLnJldmVyc2UoKTtcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yKCBfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKyApe1xuICAgIGkgPSBfcmVmMVsgX2kgXTtcbiAgICBfcmVzdWx0cy5wdXNoKCBfc2lmdHVwKCBhcnJheSwgaSwgY21wICkgKTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5cbi8qXG5VcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gKi9cblxudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIHZhciBwb3M7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgcG9zID0gYXJyYXkuaW5kZXhPZiggaXRlbSApO1xuICBpZiggcG9zID09PSAtMSApe1xuICAgIHJldHVybjtcbiAgfVxuICBfc2lmdGRvd24oIGFycmF5LCAwLCBwb3MsIGNtcCApO1xuICByZXR1cm4gX3NpZnR1cCggYXJyYXksIHBvcywgY21wICk7XG59O1xuXG5cbi8qXG5GaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICovXG5cbm5sYXJnZXN0ID0gZnVuY3Rpb24oIGFycmF5LCBuLCBjbXAgKXtcbiAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoIDAsIG4gKTtcbiAgaWYoICFyZXN1bHQubGVuZ3RoICl7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoZWFwaWZ5KCByZXN1bHQsIGNtcCApO1xuICBfcmVmID0gYXJyYXkuc2xpY2UoIG4gKTtcbiAgZm9yKCBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrICl7XG4gICAgZWxlbSA9IF9yZWZbIF9pIF07XG4gICAgaGVhcHB1c2hwb3AoIHJlc3VsdCwgZWxlbSwgY21wICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5zb3J0KCBjbXAgKS5yZXZlcnNlKCk7XG59O1xuXG5cbi8qXG5GaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAqL1xuXG5uc21hbGxlc3QgPSBmdW5jdGlvbiggYXJyYXksIG4sIGNtcCApe1xuICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGlmKCBuICogMTAgPD0gYXJyYXkubGVuZ3RoICl7XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoIDAsIG4gKS5zb3J0KCBjbXAgKTtcbiAgICBpZiggIXJlc3VsdC5sZW5ndGggKXtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxvcyA9IHJlc3VsdFsgcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZSggbiApO1xuICAgIGZvciggX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKyApe1xuICAgICAgZWxlbSA9IF9yZWZbIF9pIF07XG4gICAgICBpZiggY21wKCBlbGVtLCBsb3MgKSA8IDAgKXtcbiAgICAgICAgaW5zb3J0KCByZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCApO1xuICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgIGxvcyA9IHJlc3VsdFsgcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhlYXBpZnkoIGFycmF5LCBjbXAgKTtcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yKCBpID0gX2ogPSAwLCBfcmVmMSA9IG1pbiggbiwgYXJyYXkubGVuZ3RoICk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faiApe1xuICAgIF9yZXN1bHRzLnB1c2goIGhlYXBwb3AoIGFycmF5LCBjbXAgKSApO1xuICB9XG4gIHJldHVybiBfcmVzdWx0cztcbn07XG5cbl9zaWZ0ZG93biA9IGZ1bmN0aW9uKCBhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wICl7XG4gIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBuZXdpdGVtID0gYXJyYXlbIHBvcyBdO1xuICB3aGlsZSggcG9zID4gc3RhcnRwb3MgKXtcbiAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICBwYXJlbnQgPSBhcnJheVsgcGFyZW50cG9zIF07XG4gICAgaWYoIGNtcCggbmV3aXRlbSwgcGFyZW50ICkgPCAwICl7XG4gICAgICBhcnJheVsgcG9zIF0gPSBwYXJlbnQ7XG4gICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGFycmF5WyBwb3MgXSA9IG5ld2l0ZW07XG59O1xuXG5fc2lmdHVwID0gZnVuY3Rpb24oIGFycmF5LCBwb3MsIGNtcCApe1xuICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgc3RhcnRwb3MgPSBwb3M7XG4gIG5ld2l0ZW0gPSBhcnJheVsgcG9zIF07XG4gIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gIHdoaWxlKCBjaGlsZHBvcyA8IGVuZHBvcyApe1xuICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgIGlmKCByaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcCggYXJyYXlbIGNoaWxkcG9zIF0sIGFycmF5WyByaWdodHBvcyBdICkgPCAwKSApe1xuICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICB9XG4gICAgYXJyYXlbIHBvcyBdID0gYXJyYXlbIGNoaWxkcG9zIF07XG4gICAgcG9zID0gY2hpbGRwb3M7XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgfVxuICBhcnJheVsgcG9zIF0gPSBuZXdpdGVtO1xuICByZXR1cm4gX3NpZnRkb3duKCBhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wICk7XG59O1xuXG5IZWFwID0gKGZ1bmN0aW9uKCl7XG4gIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gIGZ1bmN0aW9uIEhlYXAoIGNtcCApe1xuICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuXG4gIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiggeCApe1xuICAgIHJldHVybiBoZWFwcHVzaCggdGhpcy5ub2RlcywgeCwgdGhpcy5jbXAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBoZWFwcG9wKCB0aGlzLm5vZGVzLCB0aGlzLmNtcCApO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKCB4ICkgIT09IC0xO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiggeCApe1xuICAgIHJldHVybiBoZWFwcmVwbGFjZSggdGhpcy5ub2RlcywgeCwgdGhpcy5jbXAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gaGVhcHB1c2hwb3AoIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGhlYXBpZnkoIHRoaXMubm9kZXMsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKCB4ICl7XG4gICAgcmV0dXJuIHVwZGF0ZUl0ZW0oIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBoZWFwO1xuICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKCAwICk7XG4gICAgcmV0dXJuIGhlYXA7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoIDAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICByZXR1cm4gSGVhcDtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLy1wcmVhbWJsZScpO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4vd2luZG93JyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgQ29yZSA9IHJlcXVpcmUoICcuL2NvcmUnICk7XG52YXIgZXh0ZW5zaW9uID0gcmVxdWlyZSggJy4vZXh0ZW5zaW9uJyApO1xudmFyIFN0eWxlc2hlZXQgPSByZXF1aXJlKCAnLi9zdHlsZXNoZWV0JyApO1xuXG52YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICl7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gY3JlYXRlIGluc3RhbmNlXG4gIGlmKCBpcy5wbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgcmV0dXJuIG5ldyBDb3JlKCBvcHRpb25zICk7XG4gIH1cblxuICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgZWxzZSBpZiggaXMuc3RyaW5nKCBvcHRpb25zICkgKXtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KCBleHRlbnNpb24sIGFyZ3VtZW50cyApO1xuICB9XG59O1xuXG4vLyBlLmcuIGN5dG9zY2FwZS51c2UoIHJlcXVpcmUoJ2N5dG9zY2FwZS1mb28nKSwgYmFyIClcbmN5dG9zY2FwZS51c2UgPSBmdW5jdGlvbiggZXh0ICl7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KCBjeXRvc2NhcGUgKTsgLy8gY3l0b3NjYXBlIGlzIGZpcnN0IGFyZyB0byBleHRcblxuICBleHQuYXBwbHkoIG51bGwsIGFyZ3MgKTtcbn07XG5cbi8vIHJlcGxhY2VkIGJ5IGJ1aWxkIHN5c3RlbVxuY3l0b3NjYXBlLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZ2xvYmFsIEhUTUxFbGVtZW50IERvY3VtZW50VG91Y2ggKi9cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoICcuL3dpbmRvdycgKTtcbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgPyB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbnZhciBkb2N1bWVudCA9IHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IG51bGw7XG5cbnZhciB0eXBlb2ZzdHIgPSB0eXBlb2YgJyc7XG52YXIgdHlwZW9mb2JqID0gdHlwZW9mIHt9O1xudmFyIHR5cGVvZmZuID0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50O1xuXG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiggb2JqICl7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGlzLmZuKCBvYmouaW5zdGFuY2VTdHJpbmcgKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBpcyA9IHtcbiAgZGVmaW5lZDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbDsgLy8gbm90IHVuZGVmaW5lZCBvciBudWxsXG4gIH0sXG5cbiAgc3RyaW5nOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mc3RyO1xuICB9LFxuXG4gIGZuOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZmZuO1xuICB9LFxuXG4gIGFycmF5OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KCBvYmogKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICB9LFxuXG4gIHBsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZm9iaiAmJiAhaXMuYXJyYXkoIG9iaiApICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9LFxuXG4gIG9iamVjdDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmo7XG4gIH0sXG5cbiAgbnVtYmVyOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAxICYmICFpc05hTiggb2JqICk7XG4gIH0sXG5cbiAgaW50ZWdlcjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5udW1iZXIoIG9iaiApICYmIE1hdGguZmxvb3IoIG9iaiApID09PSBvYmo7XG4gIH0sXG5cbiAgYm9vbDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgdHJ1ZTtcbiAgfSxcblxuICBodG1sRWxlbWVudDogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSApe1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBlbGVtZW50T3JDb2xsZWN0aW9uOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGlzLmVsZW1lbnQoIG9iaiApIHx8IGlzLmNvbGxlY3Rpb24oIG9iaiApO1xuICB9LFxuXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnY29sbGVjdGlvbicgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfSxcblxuICBjb2xsZWN0aW9uOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9LFxuXG4gIGNvcmU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnY29yZSc7XG4gIH0sXG5cbiAgc3R5bGU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnc3R5bGUnO1xuICB9LFxuXG4gIHN0eWxlc2hlZXQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnc3R5bGVzaGVldCc7XG4gIH0sXG5cbiAgZXZlbnQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnZXZlbnQnO1xuICB9LFxuXG4gIHRocmVhZDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpbnN0YW5jZVN0ciggb2JqICkgPT09ICd0aHJlYWQnO1xuICB9LFxuXG4gIGZhYnJpYzogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpbnN0YW5jZVN0ciggb2JqICkgPT09ICdmYWJyaWMnO1xuICB9LFxuXG4gIGVtcHR5U3RyaW5nOiBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCApeyAvLyBudWxsIGlzIGVtcHR5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYoIG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKCAvXlxccyskLyApICl7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3RcbiAgfSxcblxuICBub25lbXB0eVN0cmluZzogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCBvYmogJiYgaXMuc3RyaW5nKCBvYmogKSAmJiBvYmogIT09ICcnICYmICFvYmoubWF0Y2goIC9eXFxzKyQvICkgKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBkb21FbGVtZW50OiBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9LFxuXG4gIGJvdW5kaW5nQm94OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGlzLnBsYWluT2JqZWN0KCBvYmogKSAmJlxuICAgICAgaXMubnVtYmVyKCBvYmoueDEgKSAmJiBpcy5udW1iZXIoIG9iai54MiApICYmXG4gICAgICBpcy5udW1iZXIoIG9iai55MSApICYmIGlzLm51bWJlciggb2JqLnkyIClcbiAgICA7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5vYmplY3QoIG9iaiApICYmIGlzLmZuKCBvYmoudGhlbiApO1xuICB9LFxuXG4gIHRvdWNoOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgfSxcblxuICBnZWNrbzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93ICYmICggdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgKTtcbiAgfSxcblxuICB3ZWJraXQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiAoIHR5cGVvZiB3ZWJraXRVUkwgIT09ICd1bmRlZmluZWQnIHx8ICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSApO1xuICB9LFxuXG4gIGNocm9taXVtOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCB0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyApO1xuICB9LFxuXG4gIGtodG1sOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnZlbmRvci5tYXRjaCggL2tkZS9pICk7IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICB9LFxuXG4gIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBpcy5raHRtbCgpIHx8IGlzLndlYmtpdCgpIHx8IGlzLmNocm9taXVtKCk7XG4gIH0sXG5cbiAgbXM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCAvbXNpZXx0cmlkZW50fGVkZ2UvaSApOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goIC9XaW4vaSApO1xuICB9LFxuXG4gIG1hYzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKCAvTWFjL2kgKTtcbiAgfSxcblxuICBsaW51eDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKCAvTGludXgvaSApO1xuICB9LFxuXG4gIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCggL1gxMS9pICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXM7XG4iLCJmdW5jdGlvbiBPYmplY3RNYXAoKXtcbiAgdGhpcy5fb2JqID0ge307XG59XG5cbnZhciBwID0gT2JqZWN0TWFwLnByb3RvdHlwZTtcblxucC5zZXQgPSBmdW5jdGlvbigga2V5LCB2YWwgKXtcbiAgdGhpcy5fb2JqWyBrZXkgXSA9IHZhbDtcbn07XG5cbnAuZGVsZXRlID0gZnVuY3Rpb24oIGtleSApe1xuICB0aGlzLl9vYmpbIGtleSBdID0gbnVsbDtcbn07XG5cbnAuaGFzID0gZnVuY3Rpb24oIGtleSApe1xuICByZXR1cm4gdGhpcy5fb2JqWyBrZXkgXSAhPSBudWxsO1xufTtcblxucC5nZXQgPSBmdW5jdGlvbigga2V5ICl7XG4gIHJldHVybiB0aGlzLl9vYmpbIGtleSBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyA/IE1hcCA6IE9iamVjdE1hcDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSB7fTtcblxubWF0aC5hcmVQb3NpdGlvbnNTYW1lID0gZnVuY3Rpb24oIHAxLCBwMiApe1xuICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufTtcblxubWF0aC5jb3B5UG9zaXRpb24gPSBmdW5jdGlvbiggcCApe1xuICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xufTtcblxubWF0aC5hcnJheTJwb2ludCA9IGZ1bmN0aW9uKCBhcnIgKXtcbiAgcmV0dXJuIHtcbiAgICB4OiBhcnJbMF0sXG4gICAgeTogYXJyWzFdXG4gIH07XG59O1xuXG5tYXRoLmRlZzJyYWQgPSBmdW5jdGlvbiggZGVnICl7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcblxubWF0aC5sb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uKCBuICl7XG4gIHJldHVybiBNYXRoLmxvZyggbiApIC8gTWF0aC5sb2coIDIgKTtcbn07XG5cbm1hdGguc2lnbnVtID0gZnVuY3Rpb24oIHggKXtcbiAgaWYoIHggPiAwICl7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiggeCA8IDAgKXtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbm1hdGguZGlzdCA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgcmV0dXJuIE1hdGguc3FydCggbWF0aC5zcWRpc3QoIHAxLCBwMiApICk7XG59O1xuXG5tYXRoLnNxZGlzdCA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuXG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG5cbi8vIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlI1F1YWRyYXRpY19jdXJ2ZXNcbm1hdGgucWJlemllckF0ID0gZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHQgKXtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogcDAgKyAyICogKDEgLSB0KSAqIHQgKiBwMSArIHQgKiB0ICogcDI7XG59O1xuXG5tYXRoLnFiZXppZXJQdEF0ID0gZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHQgKXtcbiAgcmV0dXJuIHtcbiAgICB4OiBtYXRoLnFiZXppZXJBdCggcDAueCwgcDEueCwgcDIueCwgdCApLFxuICAgIHk6IG1hdGgucWJlemllckF0KCBwMC55LCBwMS55LCBwMi55LCB0IClcbiAgfTtcbn07XG5cbm1hdGgubGluZUF0ID0gZnVuY3Rpb24oIHAwLCBwMSwgdCwgZCApe1xuICB2YXIgdmVjID0ge1xuICAgIHg6IHAxLnggLSBwMC54LFxuICAgIHk6IHAxLnkgLSBwMC55XG4gIH07XG5cbiAgdmFyIHZlY0Rpc3QgPSBtYXRoLmRpc3QoIHAwLCBwMSApO1xuXG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcblxuICB0ID0gdCA9PSBudWxsID8gMCA6IHQ7XG5cbiAgdmFyIGQgPSBkICE9IG51bGwgPyBkIDogdCAqIHZlY0Rpc3Q7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBwMC54ICsgbm9ybVZlYy54ICogZCxcbiAgICB5OiBwMC55ICsgbm9ybVZlYy55ICogZFxuICB9O1xufTtcblxubWF0aC5saW5lQXREaXN0ID0gZnVuY3Rpb24oIHAwLCBwMSwgZCApe1xuICByZXR1cm4gbWF0aC5saW5lQXQoIHAwLCBwMSwgdW5kZWZpbmVkLCBkICk7XG59O1xuXG4vLyBnZXQgYW5nbGUgYXQgQSB2aWEgY29zaW5lIGxhd1xubWF0aC50cmlhbmdsZUFuZ2xlID0gZnVuY3Rpb24oIEEsIEIsIEMgKXtcbiAgdmFyIGEgPSBtYXRoLmRpc3QoIEIsIEMgKTtcbiAgdmFyIGIgPSBtYXRoLmRpc3QoIEEsIEMgKTtcbiAgdmFyIGMgPSBtYXRoLmRpc3QoIEEsIEIgKTtcblxuICByZXR1cm4gTWF0aC5hY29zKCAoYSphICsgYipiIC0gYypjKS8oMiphKmIpICk7XG59O1xuXG5tYXRoLmJvdW5kID0gZnVuY3Rpb24oIG1pbiwgdmFsLCBtYXggKXtcbiAgcmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbCApICk7XG59O1xuXG4vLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xubWF0aC5tYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIgKXtcbiAgaWYoIGJiID09IG51bGwgKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICB3OiAwLFxuICAgICAgaDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiggYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsICl7XG4gICAgaWYoIGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiggYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgdzogYmIudyxcbiAgICAgICAgaDogYmIuaFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbm1hdGgudXBkYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgLy8gdXBkYXRlIGJiMSB3aXRoIGJiMiBib3VuZHNcblxuICBiYjEueDEgPSBNYXRoLm1pbiggYmIxLngxLCBiYjIueDEgKTtcbiAgYmIxLngyID0gTWF0aC5tYXgoIGJiMS54MiwgYmIyLngyICk7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuXG4gIGJiMS55MSA9IE1hdGgubWluKCBiYjEueTEsIGJiMi55MSApO1xuICBiYjEueTIgPSBNYXRoLm1heCggYmIxLnkyLCBiYjIueTIgKTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xuXG5tYXRoLmV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCA9IGZ1bmN0aW9uKCBiYiwgeCwgeSApe1xuICBiYi54MSA9IE1hdGgubWluKCBiYi54MSwgeCApO1xuICBiYi54MiA9IE1hdGgubWF4KCBiYi54MiwgeCApO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcblxuICBiYi55MSA9IE1hdGgubWluKCBiYi55MSwgeSApO1xuICBiYi55MiA9IE1hdGgubWF4KCBiYi55MiwgeSApO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbn07XG5cbm1hdGguZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHBhZGRpbmcgKXtcbiAgYmIueDEgLT0gcGFkZGluZztcbiAgYmIueDIgKz0gcGFkZGluZztcbiAgYmIueTEgLT0gcGFkZGluZztcbiAgYmIueTIgKz0gcGFkZGluZztcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gIHJldHVybiBiYjtcbn07XG5cbm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYoIGJiMS54MSA+IGJiMi54MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYoIGJiMi54MSA+IGJiMS54MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICBpZiggYmIxLngyIDwgYmIyLngxICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLngyIDwgYmIxLngxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuICBpZiggYmIxLnkyIDwgYmIyLnkxICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLnkyIDwgYmIxLnkxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICBpZiggYmIxLnkxID4gYmIyLnkyICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLnkxID4gYmIxLnkyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1hdGguaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgeCwgeSApe1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG5cbm1hdGgucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCBwdCApe1xuICByZXR1cm4gdGhpcy5pbkJvdW5kaW5nQm94KCBiYiwgcHQueCwgcHQueSApO1xufTtcblxubWF0aC5ib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgcmV0dXJuIChcbiAgICAgICBtYXRoLmluQm91bmRpbmdCb3goIGJiMSwgYmIyLngxLCBiYjIueTEgKVxuICAgICYmIG1hdGguaW5Cb3VuZGluZ0JveCggYmIxLCBiYjIueDIsIGJiMi55MiApXG4gICk7XG59O1xuXG5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKXtcblxuICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyggd2lkdGgsIGhlaWdodCApO1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UgKTtcblxuICAgIGlmKCBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgKXtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICB2YXIgcmlnaHRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSApO1xuXG4gICAgaWYoIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAge1xuICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlICk7XG5cbiAgICBpZiggc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICl7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSApO1xuXG4gICAgaWYoIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3AgTGVmdFxuICB7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcgKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmKCBhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkgKXtcbiAgICAgIHJldHVybiBbIGFyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV0gXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZICl7XG4gICAgICByZXR1cm4gWyBhcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdIF07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIFJpZ2h0XG4gIHtcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLFxuICAgICAgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcgKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmKCBhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSApe1xuICAgICAgcmV0dXJuIFsgYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXSBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBMZWZ0XG4gIHtcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSApe1xuICAgICAgcmV0dXJuIFsgYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcblxubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uKCB4LCB5LCBseDEsIGx5MSwgbHgyLCBseTIsIHRvbGVyYW5jZSApe1xuICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICB2YXIgeDEgPSBNYXRoLm1pbiggbHgxLCBseDIgKTtcbiAgdmFyIHgyID0gTWF0aC5tYXgoIGx4MSwgbHgyICk7XG4gIHZhciB5MSA9IE1hdGgubWluKCBseTEsIGx5MiApO1xuICB2YXIgeTIgPSBNYXRoLm1heCggbHkxLCBseTIgKTtcblxuICByZXR1cm4geDEgLSB0IDw9IHggJiYgeCA8PSB4MiArIHRcbiAgICAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG5cbm1hdGguaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uKFxuICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UgKXtcblxuICB2YXIgYmIgPSB7XG4gICAgeDE6IE1hdGgubWluKCB4MSwgeDMsIHgyICkgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KCB4MSwgeDMsIHgyICkgKyB0b2xlcmFuY2UsXG4gICAgeTE6IE1hdGgubWluKCB5MSwgeTMsIHkyICkgLSB0b2xlcmFuY2UsXG4gICAgeTI6IE1hdGgubWF4KCB5MSwgeTMsIHkyICkgKyB0b2xlcmFuY2VcbiAgfTtcblxuICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgaWYoIHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55MiApe1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxubWF0aC5zb2x2ZUN1YmljID0gZnVuY3Rpb24oIGEsIGIsIGMsIGQsIHJlc3VsdCApe1xuXG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG5cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcblxuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuXG4gIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgciAvPSA1NC4wO1xuXG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IChiIC8gMy4wKTtcblxuICBpZiggZGlzY3JpbWluYW50ID4gMCApe1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKTtcbiAgICBzID0gKChzIDwgMCkgPyAtTWF0aC5wb3coIC1zLCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHMsICgxLjAgLyAzLjApICkpO1xuICAgIHQgPSByIC0gTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKTtcbiAgICB0ID0gKCh0IDwgMCkgPyAtTWF0aC5wb3coIC10LCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHQsICgxLjAgLyAzLjApICkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KCAzLjAgKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcblxuICBpZiggZGlzY3JpbWluYW50ID09PSAwICl7XG4gICAgcjEzID0gKChyIDwgMCkgPyAtTWF0aC5wb3coIC1yLCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHIsICgxLjAgLyAzLjApICkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MoIHIgLyBNYXRoLnNxcnQoIGR1bTEgKSApO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQoIHEgKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIGR1bTEgLyAzLjAgKTtcbiAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjAgKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIChkdW0xICsgNC4wICogTWF0aC5QSSkgLyAzLjAgKTtcblxuICByZXR1cm47XG59O1xuXG5tYXRoLnNxZGlzdFRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24oXG4gIHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMgKXtcblxuICAvLyBGaW5kIG1pbmltdW0gZGlzdGFuY2UgYnkgdXNpbmcgdGhlIG1pbmltdW0gb2YgdGhlIGRpc3RhbmNlXG4gIC8vIGZ1bmN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50IGFuZCB0aGUgY3VydmVcblxuICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG5cbiAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzXG4gICAgKyB5MSAqIHkxIC0gNCAqIHkxICogeTIgKyAyICogeTEgKiB5MyArIDQgKiB5MiAqIHkyIC0gNCAqIHkyICogeTMgKyB5MyAqIHkzO1xuXG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4M1xuICAgICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcblxuICB2YXIgYyA9IDEuMCAqIDMgKiB4MSAqIHgxIC0gNiAqIHgxICogeDIgKyB4MSAqIHgzIC0geDEgKiB4ICsgMiAqIHgyICogeDIgKyAyICogeDIgKiB4IC0geDMgKiB4XG4gICAgKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcblxuICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4XG4gICAgKyB5MSAqIHkyIC0geTEgKiB5MSArIHkxICogeSAtIHkyICogeTtcblxuICAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107XG5cbiAgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuICB0aGlzLnNvbHZlQ3ViaWMoIGEsIGIsIGMsIGQsIHJvb3RzICk7XG5cbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG5cbiAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gIGZvciggdmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyICl7XG4gICAgaWYoIE1hdGguYWJzKCByb290c1sgaW5kZXggKyAxXSApIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAmJiByb290c1sgaW5kZXggXSA+PSAwXG4gICAgICAgICYmIHJvb3RzWyBpbmRleCBdIDw9IDEuMCApe1xuICAgICAgcGFyYW1zLnB1c2goIHJvb3RzWyBpbmRleCBdICk7XG4gICAgfVxuICB9XG5cbiAgcGFyYW1zLnB1c2goIDEuMCApO1xuICBwYXJhbXMucHVzaCggMC4wICk7XG5cbiAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICB2YXIgY2xvc2VzdFBhcmFtO1xuXG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKysgKXtcbiAgICBjdXJYID0gTWF0aC5wb3coIDEuMCAtIHBhcmFtc1sgaSBdLCAyLjAgKSAqIHgxXG4gICAgICArIDIuMCAqICgxIC0gcGFyYW1zWyBpIF0pICogcGFyYW1zWyBpIF0gKiB4MlxuICAgICAgKyBwYXJhbXNbIGkgXSAqIHBhcmFtc1sgaSBdICogeDM7XG5cbiAgICBjdXJZID0gTWF0aC5wb3coIDEgLSBwYXJhbXNbIGkgXSwgMi4wICkgKiB5MVxuICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1sgaSBdKSAqIHBhcmFtc1sgaSBdICogeTJcbiAgICAgICsgcGFyYW1zWyBpIF0gKiBwYXJhbXNbIGkgXSAqIHkzO1xuXG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyggY3VyWCAtIHgsIDIgKSArIE1hdGgucG93KCBjdXJZIC0geSwgMiApO1xuICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgIGlmKCBtaW5EaXN0YW5jZVNxdWFyZWQgPj0gMCApe1xuICAgICAgaWYoIGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkICl7XG4gICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbIGkgXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbIGkgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xufTtcblxubWF0aC5zcWRpc3RUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbiggeCwgeSwgeDEsIHkxLCB4MiwgeTIgKXtcbiAgdmFyIG9mZnNldCA9IFsgeCAtIHgxLCB5IC0geTEgXTtcbiAgdmFyIGxpbmUgPSBbIHgyIC0geDEsIHkyIC0geTEgXTtcblxuICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuXG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmKCBkb3RQcm9kdWN0IDwgMCApe1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmKCBhZGpTcSA+IGxpbmVTcSApe1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiggeCwgeSwgcG9pbnRzICl7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzO1xuXG4gIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgdmFyIHVwID0gMDtcbiAgdmFyIGRvd24gPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcblxuICAgIHgxID0gcG9pbnRzWyBpICogMl07XG4gICAgeTEgPSBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMiApe1xuICAgICAgeDIgPSBwb2ludHNbIChpICsgMSkgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHBvaW50c1sgKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1sgKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgIH1cblxuICAgIGlmKCB4MSA9PSB4ICYmIHgyID09IHggKXtcbiAgICAgIC8vIHRoZW4gaWdub3JlXG4gICAgfSBlbHNlIGlmKCAoeDEgPj0geCAmJiB4ID49IHgyKVxuICAgICAgfHwgKHgxIDw9IHggJiYgeCA8PSB4MikgKXtcblxuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICBpZiggeTMgPiB5ICl7XG4gICAgICAgIHVwKys7XG4gICAgICB9XG5cbiAgICAgIGlmKCB5MyA8IHkgKXtcbiAgICAgICAgZG93bisrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICB9XG5cbiAgaWYoIHVwICUgMiA9PT0gMCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nICl7XG5cbiAgLy92YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzWzZdO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoIGJhc2VQb2ludHMubGVuZ3RoICk7XG5cbiAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgdmFyIGFuZ2xlO1xuXG4gIGlmKCBkaXJlY3Rpb25bMF0gIT0gbnVsbCApe1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKCBkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0gKTtcblxuICAgIGlmKCBkaXJlY3Rpb25bMF0gPCAwICl7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgdmFyIGNvcyA9IE1hdGguY29zKCAtYW5nbGUgKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKCAtYW5nbGUgKTtcblxuICAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSA9XG4gICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1sgaSAqIDJdICogY29zXG4gICAgICAgIC0gYmFzZVBvaW50c1sgaSAqIDIgKyAxXSAqIHNpbik7XG5cbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDIgKyAxXSA9XG4gICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbIGkgKiAyICsgMV0gKiBjb3NcbiAgICAgICAgKyBiYXNlUG9pbnRzWyBpICogMl0gKiBzaW4pO1xuXG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzWyBpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmKCBwYWRkaW5nID4gMCApe1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSB0aGlzLmV4cGFuZFBvbHlnb24oXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgIC1wYWRkaW5nICk7XG5cbiAgICBwb2ludHMgPSB0aGlzLmpvaW5MaW5lcyggZXhwYW5kZWRMaW5lU2V0ICk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cblxuICByZXR1cm4gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHBvaW50cyApO1xufTtcblxubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbiggbGluZVNldCApe1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheSggbGluZVNldC5sZW5ndGggLyAyICk7XG5cbiAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKysgKXtcbiAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbIGkgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbIGkgKiA0ICsgMV07XG4gICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFsgaSAqIDQgKyAyXTtcbiAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0WyBpICogNCArIDNdO1xuXG4gICAgaWYoIGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxICl7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbIChpICsgMSkgKiA0XTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsgKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbIChpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyAoaSArIDEpICogNCArIDNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbMF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFszXTtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSxcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLFxuICAgICAgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksXG4gICAgICB0cnVlICk7XG5cbiAgICB2ZXJ0aWNlc1sgaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgIHZlcnRpY2VzWyBpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcblxubWF0aC5leHBhbmRQb2x5Z29uID0gZnVuY3Rpb24oIHBvaW50cywgcGFkICl7XG5cbiAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheSggcG9pbnRzLmxlbmd0aCAqIDIgKTtcblxuICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcbiAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzWyBpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1sgaSAqIDIgKyAxXTtcblxuICAgIGlmKCBpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxICl7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyAoaSArIDEpICogMl07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cblxuICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cbiAgICB2YXIgb2Zmc2V0WCA9IChuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WSk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQoIG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkgKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG5cbiAgICBleHBhbmRlZExpbmVTZXRbIGkgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbIGkgKiA0ICsgMV0gPSBjdXJyZW50UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0WyBpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFsgaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xuXG5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24oXG4gIHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cyApe1xuXG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcblxuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG5cbiAgdmFyIGxlbiA9IE1hdGguc3FydCggZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkgKTtcblxuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICBpZiggbmV3TGVuZ3RoIDwgMCApe1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuXG4gIHJldHVybiBbIChjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5IF07XG59O1xuXG4vLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxubWF0aC5pbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24oXG4gIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgKXtcblxuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gWyB4MiAtIHgxLCB5MiAtIHkxIF07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgYyA9IFsgY2VudGVyWCwgY2VudGVyWSBdOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gIHZhciBmID0gWyB4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWSBdO1xuXG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IChmWzBdICogZlswXSArIGZbMV0gKiBmWzFdKSAtIHJhZGl1cyAqIHJhZGl1cyA7XG5cbiAgdmFyIGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gIGlmKCBkaXNjcmltaW5hbnQgPCAwICl7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoIGRpc2NyaW1pbmFudCApKSAvICgyICogYSk7XG5cbiAgdmFyIHRNaW4gPSBNYXRoLm1pbiggdDEsIHQyICk7XG4gIHZhciB0TWF4ID0gTWF0aC5tYXgoIHQxLCB0MiApO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmKCB0TWluID49IDAgJiYgdE1pbiA8PSAxICl7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKCB0TWluICk7XG4gIH1cblxuICBpZiggdE1heCA+PSAwICYmIHRNYXggPD0gMSApe1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCggdE1heCApO1xuICB9XG5cbiAgaWYoIGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwICl7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcblxuICBpZiggaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxICl7XG5cbiAgICBpZiggaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdICl7XG4gICAgICByZXR1cm4gWyBuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblkgXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG5cbiAgICAgIHJldHVybiBbIG5lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWSBdO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbIG5lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSBdO1xuICB9XG5cbn07XG5cbm1hdGguZmluZENpcmNsZU5lYXJQb2ludCA9IGZ1bmN0aW9uKCBjZW50ZXJYLCBjZW50ZXJZLFxuICByYWRpdXMsIGZhclgsIGZhclkgKXtcblxuICB2YXIgZGlzcGxhY2VtZW50WCA9IGZhclggLSBjZW50ZXJYO1xuICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGRpc3BsYWNlbWVudFggKiBkaXNwbGFjZW1lbnRYXG4gICAgKyBkaXNwbGFjZW1lbnRZICogZGlzcGxhY2VtZW50WSApO1xuXG4gIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgdmFyIHVuaXREaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50WSAvIGRpc3RhbmNlO1xuXG4gIHJldHVybiBbIGNlbnRlclggKyB1bml0RGlzcGxhY2VtZW50WCAqIHJhZGl1cyxcbiAgICBjZW50ZXJZICsgdW5pdERpc3BsYWNlbWVudFkgKiByYWRpdXMgXTtcbn07XG5cbm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcbiAgdmFyIG1heFNxRGlzdGFuY2UgPSAwLjAwMDAwMTtcbiAgdmFyIHNxRGlzdGFuY2U7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG5cbiAgICBzcURpc3RhbmNlID0gcG9pbnRzWyBpICogMl0gKiBwb2ludHNbIGkgKiAyXVxuICAgICAgKyBwb2ludHNbIGkgKiAyICsgMV0gKiBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UgKXtcbiAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhTcURpc3RhbmNlO1xufTtcblxubWF0aC5taWRPZlRocmVlID0gZnVuY3Rpb24oIGEsIGIsIGMgKXtcbiAgaWYoIChiIDw9IGEgJiYgYSA8PSBjKSB8fCAoYyA8PSBhICYmIGEgPD0gYikgKXtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmKCAoYSA8PSBiICYmIGIgPD0gYykgfHwgKGMgPD0gYiAmJiBiIDw9IGEpICl7XG4gICAgcmV0dXJuIGI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn07XG5cbi8vICh4MSx5MSk9Pih4Mix5MikgaW50ZXJzZWN0IHdpdGggKHgzLHkzKT0+KHg0LHk0KVxubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKFxuICB4MSwgeTEsIHgyLCB5MixcbiAgeDMsIHkzLCB4NCwgeTQsXG4gIGluZmluaXRlTGluZXNcbil7XG5cbiAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gIHZhciBkeDQzID0geDQgLSB4MztcblxuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuXG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iICA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG5cbiAgaWYoIHVfYiAhPT0gMCApe1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcblxuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG4gICAgdmFyIG1pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuICAgIHZhciBtYXggPSAxICsgZmxwdFRocmVzaG9sZDtcblxuICAgIGlmKCBtaW4gPD0gdWEgJiYgdWEgPD0gbWF4ICYmIG1pbiA8PSB1YiAmJiB1YiA8PSBtYXggKXtcbiAgICAgIHJldHVybiBbIHgxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMSBdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCAhaW5maW5pdGVMaW5lcyApe1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWyB4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjEgXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYoIHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCApe1xuXG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYoIHRoaXMubWlkT2ZUaHJlZSggeDEsIHgyLCB4NCApID09PSB4NCApe1xuICAgICAgICByZXR1cm4gWyB4NCwgeTQgXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmKCB0aGlzLm1pZE9mVGhyZWUoIHgxLCB4MiwgeDMgKSA9PT0geDMgKXtcbiAgICAgICAgcmV0dXJuIFsgeDMsIHkzIF07XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICAgIGlmKCB0aGlzLm1pZE9mVGhyZWUoIHgzLCB4NCwgeDIgKSA9PT0geDIgKXtcbiAgICAgICAgcmV0dXJuIFsgeDIsIHkyIF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKVxuLy8gaW50ZXJzZWN0IGEgbm9kZSBwb2x5Z29uIChwdHMgdHJhbnNmb3JtZWQpXG4vL1xuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSApXG4vLyBpbnRlcnNlY3QgdGhlIHBvaW50cyAobm8gdHJhbnNmb3JtKVxubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nICl7XG5cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcblxuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoIGJhc2VQb2ludHMubGVuZ3RoICk7XG5cbiAgdmFyIGRvVHJhbnNmb3JtID0gdHJ1ZTtcbiAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDUgKXtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiggZG9UcmFuc2Zvcm0gKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKyApe1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSA9IGJhc2VQb2ludHNbIGkgKiAyXSAqIHdpZHRoICsgY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzWyBpICogMiArIDFdID0gYmFzZVBvaW50c1sgaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuXG4gICAgaWYoIHBhZGRpbmcgPiAwICl7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbWF0aC5leHBhbmRQb2x5Z29uKFxuICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgICAgLXBhZGRpbmcgKTtcblxuICAgICAgcG9pbnRzID0gbWF0aC5qb2luTGluZXMoIGV4cGFuZGVkTGluZVNldCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gYmFzZVBvaW50cztcbiAgfVxuXG4gIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcblxuICAgIGN1cnJlbnRYID0gcG9pbnRzWyBpICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSApe1xuICAgICAgbmV4dFggPSBwb2ludHNbIChpICsgMSkgKiAyXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgY3VycmVudFgsIGN1cnJlbnRZLFxuICAgICAgbmV4dFgsIG5leHRZICk7XG5cbiAgICBpZiggaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCApe1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcblxubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oXG4gIGludGVyc2VjdGlvbiwgb2Zmc2V0LCBhbW91bnQgKXtcblxuICB2YXIgZGlzcCA9IFsgaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV0gXTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KCBkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdICk7XG5cbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgaWYoIGxlblJhdGlvIDwgMCApe1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuXG4gIHJldHVybiBbIG9mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdIF07XG59O1xuXG5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uKCBzaWRlcywgcm90YXRpb25SYWRpYW5zICl7XG4gIHZhciBwb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIHNpZGVzLCByb3RhdGlvblJhZGlhbnMgKTtcbiAgcG9pbnRzID0gbWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHBvaW50cyApO1xuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrICl7XG4gICAgeCA9IHBvaW50c1syICogaSBdO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcblxuICAgIG1pblggPSBNYXRoLm1pbiggbWluWCwgeCApO1xuICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgIG1heFkgPSBNYXRoLm1heCggbWF4WSwgeSApO1xuICB9XG5cbiAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICB4ID0gcG9pbnRzWzIgKiBpIF0gPSBwb2ludHNbMiAqIGkgXSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IHBvaW50c1syICogaSArIDFdICogc3k7XG5cbiAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICBtaW5ZID0gTWF0aC5taW4oIG1pblksIHkgKTtcbiAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgfVxuXG4gIGlmKCBtaW5ZIDwgLTEgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IHBvaW50c1syICogaSArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uKCBzaWRlcywgcm90YXRpb25SYWRpYW5zICl7XG5cbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID9cbiAgICBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgLy8gICAgY29uc29sZS5sb2cobm9kZVNoYXBlc1snc3F1YXJlJ10pO1xuICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcblxuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KCBzaWRlcyAqIDIgKTtcblxuICB2YXIgY3VycmVudEFuZ2xlLCB4LCB5O1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcblxuICAgIHggPSBwb2ludHNbMiAqIGkgXSA9IE1hdGguY29zKCBjdXJyZW50QW5nbGUgKTsvLyAqICgxICsgaS8yKTtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbiggLWN1cnJlbnRBbmdsZSApOy8vICAqICgxICsgaS8yKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQgKXtcblxuICAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcbiAgcmV0dXJuIE1hdGgubWluKCB3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDggKTtcbn07XG5cbm1hdGguZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIDg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGg7XG4iLCIvKiFcbkVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG5MaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HICAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xudmFyIFNUQVRFX1JFSkVDVEVEICA9IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xudmFyIGFwaSA9IGZ1bmN0aW9uKCBleGVjdXRvciApe1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgYXBpKSApXG4gICAgcmV0dXJuIG5ldyBhcGkoIGV4ZWN1dG9yICk7XG5cbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICB0aGlzLmlkICAgICAgICAgICA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gIHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgdmFsdWUgICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgcmVhc29uICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG4gIHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gIHRoaXMub25SZWplY3RlZCAgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKCB0aGlzIClcbiAgfTtcblxuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cbiAgaWYoIHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgZXhlY3V0b3IuY2FsbCggdGhpcywgdGhpcy5mdWxmaWxsLmJpbmQoIHRoaXMgKSwgdGhpcy5yZWplY3QuYmluZCggdGhpcyApICk7XG59O1xuXG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cbmFwaS5wcm90b3R5cGUgPSB7XG4gIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICBmdWxmaWxsOiBmdW5jdGlvbiggdmFsdWUgKXsgcmV0dXJuIGRlbGl2ZXIoIHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlICk7IH0sXG4gIHJlamVjdDogIGZ1bmN0aW9uKCB2YWx1ZSApeyByZXR1cm4gZGVsaXZlciggdGhpcywgU1RBVEVfUkVKRUNURUQsICAncmVqZWN0UmVhc29uJywgdmFsdWUgKTsgfSxcblxuICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gIHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApe1xuICAgIHZhciBjdXJyID0gdGhpcztcbiAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2goXG4gICAgICByZXNvbHZlciggb25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJyApICk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuICAgIGN1cnIub25SZWplY3RlZC5wdXNoKFxuICAgICAgcmVzb2x2ZXIoIG9uUmVqZWN0ZWQsICBuZXh0LCAncmVqZWN0JyApICk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgIGV4ZWN1dGUoIGN1cnIgKTtcbiAgICByZXR1cm4gbmV4dC5wcm94eTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICB9XG59O1xuXG4vKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG52YXIgZGVsaXZlciA9IGZ1bmN0aW9uKCBjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUgKXtcbiAgaWYoIGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcgKXtcbiAgICBjdXJyLnN0YXRlID0gc3RhdGU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuICAgIGN1cnJbIG5hbWUgXSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICBleGVjdXRlKCBjdXJyICk7XG4gIH1cbiAgcmV0dXJuIGN1cnI7XG59O1xuXG4vKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKCBjdXJyICl7XG4gIGlmKCBjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQgKVxuICAgIGV4ZWN1dGVfaGFuZGxlcnMoIGN1cnIsICdvbkZ1bGZpbGxlZCcsIGN1cnIuZnVsZmlsbFZhbHVlICk7XG4gIGVsc2UgaWYoIGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEIClcbiAgICBleGVjdXRlX2hhbmRsZXJzKCBjdXJyLCAnb25SZWplY3RlZCcsICBjdXJyLnJlamVjdFJlYXNvbiApO1xufTtcblxuLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uKCBjdXJyLCBuYW1lLCB2YWx1ZSApe1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgaWYoIGN1cnJbIG5hbWUgXS5sZW5ndGggPT09IDAgKVxuICAgIHJldHVybjtcblxuICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuICB2YXIgaGFuZGxlcnMgPSBjdXJyWyBuYW1lIF07XG4gIGN1cnJbIG5hbWUgXSA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG4gIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrIClcbiAgICAgIGhhbmRsZXJzWyBpIF0oIHZhbHVlICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICBpZiggdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgc2V0SW1tZWRpYXRlKCBmdW5jICk7XG4gIGVsc2VcbiAgICBzZXRUaW1lb3V0KCBmdW5jLCAwICk7XG59O1xuXG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uKCBjYiwgbmV4dCwgbWV0aG9kICl7XG4gIHJldHVybiBmdW5jdGlvbiggdmFsdWUgKXtcbiAgICBpZiggdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0WyBtZXRob2QgXS5jYWxsKCBuZXh0LCB2YWx1ZSApOyAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHRyeSB7IHJlc3VsdCA9IGNiKCB2YWx1ZSApOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgY2F0Y2goIGUgKXtcbiAgICAgICAgbmV4dC5yZWplY3QoIGUgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSggbmV4dCwgcmVzdWx0ICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgfVxuICB9O1xufTtcblxuLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbnZhciByZXNvbHZlID0gZnVuY3Rpb24oIHByb21pc2UsIHggKXtcbiAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiggcHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4ICl7XG4gICAgcHJvbWlzZS5yZWplY3QoIG5ldyBUeXBlRXJyb3IoICdjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJyApICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cbiAgdmFyIHRoZW47XG4gIGlmKCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICl7XG4gICAgdHJ5IHsgdGhlbiA9IHgudGhlbjsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgIGNhdGNoKCBlICl7XG4gICAgICBwcm9taXNlLnJlamVjdCggZSApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgaWYoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICl7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKCB4LFxuICAgICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgICBmdW5jdGlvbiggeSApe1xuICAgICAgICAgIGlmKCByZXNvbHZlZCApIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgaWYoIHkgPT09IHggKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KCBuZXcgVHlwZUVycm9yKCAnY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nICkgKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXNvbHZlKCBwcm9taXNlLCB5ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogIHJlamVjdFByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4yXSAgKi9cbiAgICAgICAgZnVuY3Rpb24oIHIgKXtcbiAgICAgICAgICBpZiggcmVzb2x2ZWQgKSByZXR1cm47IHJlc29sdmVkID0gdHJ1ZTsgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KCByICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoKCBlICl7XG4gICAgICBpZiggIXJlc29sdmVkICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KCBlICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG4gIHByb21pc2UuZnVsZmlsbCggeCApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTtcblxuLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuYXBpLmFsbCA9IGZ1bmN0aW9uKCBwcyApe1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiggcmVzb2x2ZUFsbCwgcmVqZWN0QWxsICl7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkoIHBzLmxlbmd0aCApO1xuICAgIHZhciBkb25lQ291bnQgPSAwO1xuXG4gICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiggaSwgdmFsICl7XG4gICAgICB2YWxzWyBpIF0gPSB2YWw7XG4gICAgICBkb25lQ291bnQrKztcblxuICAgICAgaWYoIGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoICl7XG4gICAgICAgIHJlc29sdmVBbGwoIHZhbHMgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKyApe1xuICAgICAgKGZ1bmN0aW9uKCBpICl7XG4gICAgICAgIHZhciBwID0gcHNbaV07XG4gICAgICAgIHZhciBpc1Byb21pc2UgPSBwICE9IG51bGwgJiYgcC50aGVuICE9IG51bGw7XG5cbiAgICAgICAgaWYoIGlzUHJvbWlzZSApe1xuICAgICAgICAgIHAudGhlbiggZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oIGVyciApe1xuICAgICAgICAgICAgcmVqZWN0QWxsKCBlcnIgKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHA7XG4gICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgIH1cbiAgICAgIH0pKCBpICk7XG4gICAgfVxuXG4gIH0gKTtcbn07XG5cbmFwaS5yZXNvbHZlID0gZnVuY3Rpb24oIHZhbCApe1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7IHJlc29sdmUoIHZhbCApOyB9KTtcbn07XG5cbmFwaS5yZWplY3QgPSBmdW5jdGlvbiggdmFsICl7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXsgcmVqZWN0KCB2YWwgKTsgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFtcbiAge1xuICAgIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuc2VsZWN0ZWQoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gIWVsZS5zZWxlY3RlZCgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuc2VsZWN0YWJsZSgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuICFlbGUuc2VsZWN0YWJsZSgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5sb2NrZWQoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuICFlbGUubG9ja2VkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS52aXNpYmxlKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gIWVsZS52aXNpYmxlKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUudHJhbnNwYXJlbnQoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLmdyYWJiZWQoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gIWVsZS5ncmFiYmVkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5yZW1vdmVkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gIWVsZS5yZW1vdmVkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLmdyYWJiYWJsZSgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gIWVsZS5ncmFiYmFibGUoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5hbmltYXRlZCgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiAhZWxlLmFuaW1hdGVkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLmlzUGFyZW50KCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLmlzQ2hpbGRsZXNzKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuaXNDaGlsZCgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5pc09ycGhhbigpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5pc0NoaWxkKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmxvb3AnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5pc0xvb3AoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6c2ltcGxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuaXNTaW1wbGUoKTsgfVxuICB9LFxuICB7XG4gICAgc2VsZWN0b3I6ICc6YWN0aXZlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuYWN0aXZlKCk7IH1cbiAgfSxcbiAge1xuICAgIHNlbGVjdG9yOiAnOmluYWN0aXZlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiAhZWxlLmFjdGl2ZSgpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpiYWNrZ3JvdW5kaW5nJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpOyB9XG4gIH0sXG4gIHtcbiAgICBzZWxlY3RvcjogJzpub25iYWNrZ3JvdW5kaW5nJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiggZWxlICl7IHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTsgfVxuICB9XG5dLnNvcnQoZnVuY3Rpb24oIGEsIGIgKXsgLy8gbi5iLiBzZWxlY3RvcnMgdGhhdCBhcmUgc3RhcnRpbmcgc3Vic3RyaW5ncyBvZiBvdGhlcnMgbXVzdCBoYXZlIHRoZSBsb25nZXIgb25lcyBmaXJzdFxuICByZXR1cm4gdXRpbC5zb3J0LmRlc2NlbmRpbmcoIGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IgKTtcbn0pO1xuXG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiggc2VsLCBlbGUgKXtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlU2VsZWN0b3JNYXRjaGVzLmxvb2t1cCA9IHN0YXRlU2VsZWN0b3JNYXRjaGVzLmxvb2t1cCB8fCAoZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsVG9GbiA9IHt9O1xuICAgIHZhciBzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzdGF0ZVNlbGVjdG9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgcyA9IHN0YXRlU2VsZWN0b3JzW2ldO1xuXG4gICAgICBzZWxUb0ZuWyBzLnNlbGVjdG9yIF0gPSBzLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbFRvRm47XG4gIH0pKCk7XG5cbiAgcmV0dXJuIGxvb2t1cFsgc2VsIF0oIGVsZSApO1xufTtcblxudmFyIHN0YXRlU2VsZWN0b3JSZWdleCA9ICcoJyArIHN0YXRlU2VsZWN0b3JzLm1hcChmdW5jdGlvbiggcyApeyByZXR1cm4gcy5zZWxlY3RvcjsgfSkuam9pbignfCcpICsgJyknO1xuXG52YXIgU2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuX3ByaXZhdGUgPSB7XG4gICAgc2VsZWN0b3JUZXh0OiBudWxsLFxuICAgIGludmFsaWQ6IHRydWVcbiAgfTtcblxuICAvLyBzdG9yYWdlIGZvciBwYXJzZWQgcXVlcmllc1xuICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDAsIC8vIGhvdyBtYW55IGV4cHJlc3Npb25zIHBlciBxdWVyeVxuXG4gICAgICBjbGFzc2VzOiBbXSxcbiAgICAgIGNvbG9uU2VsZWN0b3JzOiBbXSxcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICBpZHM6IFtdLFxuICAgICAgbWV0YTogW10sXG5cbiAgICAgIC8vIGZha2Ugc2VsZWN0b3JzXG4gICAgICBjb2xsZWN0aW9uOiBudWxsLCAvLyBhIGNvbGxlY3Rpb24gdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgZmlsdGVyOiBudWxsLCAvLyBmaWx0ZXIgZnVuY3Rpb25cblxuICAgICAgLy8gdGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIHVwd2FyZCBkaXJlY3Rpb24gcmF0aGVyIHRoYW4gZG93biAoZS5nLiBjaGlsZClcbiAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyB1cCBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcXVlcnkgb2JqXG4gICAgICBhbmNlc3RvcjogbnVsbCwgLy8gYW5jZXN0b3IgcXVlcnkgb2JqXG4gICAgICBzdWJqZWN0OiBudWxsLCAvLyBkZWZpbmVzIHN1YmplY3QgaW4gY29tcG91bmQgcXVlcnkgKHN1YmplY3QgcXVlcnkgb2JqOyBwb2ludHMgdG8gc2VsZiBpZiBzdWJqZWN0KVxuXG4gICAgICAvLyB1c2UgdGhlc2Ugb25seSB3aGVuIHN1YmplY3QgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAgY2hpbGQ6IG51bGwsXG4gICAgICBkZXNjZW5kYW50OiBudWxsXG4gICAgfTtcbiAgfTtcblxuICBpZiggIXNlbGVjdG9yIHx8ICggaXMuc3RyaW5nKCBzZWxlY3RvciApICYmIHNlbGVjdG9yLm1hdGNoKCAvXlxccyokLyApICkgKXtcblxuICAgIHNlbGYubGVuZ3RoID0gMDtcblxuICB9IGVsc2UgaWYoIHNlbGVjdG9yID09PSAnKicgfHwgc2VsZWN0b3IgPT09ICdlZGdlJyB8fCBzZWxlY3RvciA9PT0gJ25vZGUnICl7XG5cbiAgICAvLyBtYWtlIHNpbmdsZSwgZ3JvdXAtb25seSBzZWxlY3RvcnMgY2hlYXAgdG8gbWFrZSBhbmQgY2hlYXAgdG8gZmlsdGVyXG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmdyb3VwID0gc2VsZWN0b3IgPT09ICcqJyA/IHNlbGVjdG9yIDogc2VsZWN0b3IgKyAncyc7XG4gICAgc2VsZlswXS5ncm91cE9ubHkgPSB0cnVlO1xuICAgIHNlbGZbMF0ubGVuZ3RoID0gMTtcbiAgICBzZWxmLl9wcml2YXRlLmludmFsaWQgPSBmYWxzZTtcbiAgICBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcblxuICB9IGVsc2UgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIHNlbGVjdG9yICkgKXtcblxuICAgIHZhciBjb2xsZWN0aW9uID0gc2VsZWN0b3IuY29sbGVjdGlvbigpO1xuXG4gICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgc2VsZlswXS5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICBzZWxmWzBdLmxlbmd0aCA9IDE7XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIH0gZWxzZSBpZiggaXMuZm4oIHNlbGVjdG9yICkgKXtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uZmlsdGVyID0gc2VsZWN0b3I7XG4gICAgc2VsZlswXS5sZW5ndGggPSAxO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcblxuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggc2VsZWN0b3IgKSApe1xuXG4gICAgLy8gdGhlIGN1cnJlbnQgc3ViamVjdCBpbiB0aGUgcXVlcnlcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBudWxsO1xuXG4gICAgLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxuICAgIHZhciB0b2tlbnMgPSB7XG4gICAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIHZhciBuYW1lcywgZXRjXG4gICAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJywgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkqXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKidcIiwgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICAgIG51bWJlcjogdXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgICAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLCAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICAgICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICAgIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gICAgICBzdWJqZWN0OiAnXFxcXCQnXG4gICAgfTtcbiAgICB0b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuICAgIHRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcbiAgICB0b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG4gICAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gICAgLy8gd2hlbiBhIHRva2VuIGxpa2UgYSB2YXJpYWJsZSBoYXMgZXNjYXBlZCBtZXRhIGNoYXJhY3RlcnMsIHdlIG5lZWQgdG8gY2xlYW4gdGhlIGJhY2tzbGFzaGVzIG91dFxuICAgIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSggbmV3IFJlZ0V4cCggJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyApLCBmdW5jdGlvbiggbWF0Y2gsICQxLCBvZmZzZXQsIG9yaWdpbmFsICl7XG4gICAgICAgIHJldHVybiAkMTtcbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoICd8JyApO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgb3AgPSBvcHNbIGkgXTtcbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgIH1cblxuICAgIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCAnfCcgKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG9wID0gb3BzWyBpIF07XG5cbiAgICAgIGlmKCBvcC5pbmRleE9mKCAnIScgKSA+PSAwICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICAgIGlmKCBvcCA9PT0gJz0nICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4gICAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gICAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZltpXSAtLS0geW91IGNhbiB1c2UgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIHBvcHVsYXRlIGZ1bmN0aW9uO1xuICAgIC8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gU2VsZWN0b3IuZmlsdGVyKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuICAgIC8vIC0gd2hlbiB5b3UgYWRkIHNvbWV0aGluZyBoZXJlLCBhbHNvIGFkZCB0byBTZWxlY3Rvci50b1N0cmluZygpXG4gICAgdmFyIGV4cHJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnZ3JvdXAnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICcobm9kZXxlZGdlfFxcXFwqKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXAgPT09ICcqJyA/IGdyb3VwIDogZ3JvdXAgKyAncyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3N0YXRlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggc3RhdGUgKXtcbiAgICAgICAgICB0aGlzLmNvbG9uU2VsZWN0b3JzLnB1c2goIHN0YXRlICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICAgIHRoaXMuaWRzLnB1c2goIGNsZWFuTWV0YUNoYXJzKCBpZCApICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsYXNzTmFtZScsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFwuKCcgKyB0b2tlbnMuY2xhc3NOYW1lICsgJyknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xuICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCBjbGVhbk1ldGFDaGFycyggY2xhc3NOYW1lICkgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSApe1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKCB7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMoIHZhcmlhYmxlIClcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlLCBjb21wYXJhdG9yT3AsIHZhbHVlICl7XG4gICAgICAgICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCAnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnICkuZXhlYyggdmFsdWUgKSAhPSBudWxsO1xuXG4gICAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKCAxLCB2YWx1ZS5sZW5ndGggLSAxICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCgge1xuICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKCB2YXJpYWJsZSApLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUJvb2wnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLmJvb2xPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBib29sT3AsIHZhcmlhYmxlICl7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goIHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyggdmFyaWFibGUgKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21ldGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignICsgdG9rZW5zLm1ldGEgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMubnVtYmVyICsgJylcXFxccypcXFxcXVxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBtZXRhLCBjb21wYXJhdG9yT3AsIG51bWJlciApe1xuICAgICAgICAgIHRoaXMubWV0YS5wdXNoKCB7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMoIG1ldGEgKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCggbnVtYmVyIClcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ25leHRRdWVyeScsXG4gICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICAgICAgICBzZWxmWyArK2kgXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjaGlsZCcsXG4gICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgcGFyZW50IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICB2YXIgY2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgY2hpbGRRdWVyeS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgIGNoaWxkUXVlcnkuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuXG4gICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICBzZWxmWyBpIF0gPSBjaGlsZFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICB2YXIgZGVzY2VuZGFudFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgc2VsZlsgaSBdID0gZGVzY2VuZGFudFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzdWJqZWN0JyxcbiAgICAgICAgbW9kaWZpZXI6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoIGN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgdGhpcy5zdWJqZWN0ICE9IHRoaXMgKXtcbiAgICAgICAgICAgIHV0aWwuZXJyb3IoICdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AnICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFN1YmplY3QgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuc3ViamVjdCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIF07XG5cbiAgICBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIHZhciByZW1haW5pbmcgPSBzZWxlY3RvcjtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvLyBvZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHRcbiAgICB2YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiggZXhwZWN0YXRpb24gKXtcbiAgICAgIHZhciBleHByO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIG5hbWU7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGUgPSBleHByc1sgaiBdO1xuICAgICAgICB2YXIgbiA9IGUubmFtZTtcblxuICAgICAgICAvLyBpZ25vcmUgdGhpcyBleHByZXNzaW9uIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgZXhwZWN0YXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYoIGlzLmZuKCBleHBlY3RhdGlvbiApICYmICFleHBlY3RhdGlvbiggbiwgZSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goIG5ldyBSZWdFeHAoICdeJyArIGUucmVnZXggKSApO1xuXG4gICAgICAgIGlmKCBtICE9IG51bGwgKXtcbiAgICAgICAgICBtYXRjaCA9IG07XG4gICAgICAgICAgZXhwciA9IGU7XG4gICAgICAgICAgbmFtZSA9IG47XG5cbiAgICAgICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuXG4gICAgICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cHI6IGV4cHIsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gY29uc3VtZSBhbGwgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgdmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCggL15cXHMrLyApO1xuXG4gICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTsgLy8gZ2V0IHN0YXJ0ZWRcblxuICAgIGNvbnN1bWVXaGl0ZXNwYWNlKCk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgZm9yKCA7OyApe1xuICAgICAgdmFyIGNoZWNrID0gY29uc3VtZUV4cHIoKTtcblxuICAgICAgaWYoIGNoZWNrLmV4cHIgPT0gbnVsbCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYGlzIGludmFsaWQnICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciggdmFyIGogPSAxOyBqIDwgY2hlY2subWF0Y2gubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICBhcmdzLnB1c2goIGNoZWNrLm1hdGNoWyBqIF0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZbaV0ubGVuZ3RoKys7XG5cbiAgICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IChpLmUuIGluIHNlbGZbaV0pXG4gICAgICAgIHZhciByZXQgPSBjaGVjay5leHByLnBvcHVsYXRlLmFwcGx5KCBzZWxmWyBpIF0sIGFyZ3MgKTtcblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyByZXR1cm47IH0gLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubWF0Y2goIC9eXFxzKiQvICkgKXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5sZW5ndGggPSBpICsgMTtcblxuICAgIC8vIGFkanVzdCByZWZlcmVuY2VzIGZvciBzdWJqZWN0XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmWyBqIF07XG5cbiAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ICE9IG51bGwgKXtcbiAgICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgICAgZm9yKCA7OyApe1xuICAgICAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09IHF1ZXJ5ICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgc3ViamVjdCBpcyBzZWxmXG5cbiAgICAgICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXsgLy8gc3dhcCBwYXJlbnQvY2hpbGQgcmVmZXJlbmNlXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcXVlcnkucGFyZW50O1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gcXVlcnk7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGQgPSBjaGlsZDtcblxuICAgICAgICAgICAgcXVlcnkgPSBwYXJlbnQ7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgfSBlbHNlIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7IC8vIHN3YXAgYW5jZXN0b3IvZGVzY2VuZGFudFxuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gcXVlcnkuYW5jZXN0b3I7XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICBkZXNjZW5kYW50LmFuY2VzdG9yID0gbnVsbDtcbiAgICAgICAgICAgIGFuY2VzdG9yLmRlc2NlbmRhbnQgPSBkZXNjZW5kYW50O1xuXG4gICAgICAgICAgICBxdWVyeSA9IGFuY2VzdG9yOyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKCAnV2hlbiBhZGp1c3RpbmcgcmVmZXJlbmNlcyBmb3IgdGhlIHNlbGVjdG9yIGAnICsgcXVlcnkgKyAnYCwgbmVpdGhlciBwYXJlbnQgbm9yIGFuY2VzdG9yIHdhcyBmb3VuZCcgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3JcblxuICAgICAgICBzZWxmWyBqIF0gPSBxdWVyeS5zdWJqZWN0OyAvLyBzdWJqZWN0IHNob3VsZCBiZSB0aGUgcm9vdCBxdWVyeVxuICAgICAgfSAvLyBpZlxuICAgIH0gLy8gZm9yXG5cbiAgfSBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCAnQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyArIHNlbGVjdG9yICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi5fcHJpdmF0ZS5pbnZhbGlkID0gZmFsc2U7XG5cbn07XG5cbnZhciBzZWxmbiA9IFNlbGVjdG9yLnByb3RvdHlwZTtcblxuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbnNlbGZuLmVxID0gZnVuY3Rpb24oIGkgKXtcbiAgcmV0dXJuIHRoaXNbIGkgXTtcbn07XG5cbnZhciBxdWVyeU1hdGNoZXMgPSBmdW5jdGlvbiggcXVlcnksIGVsZSApe1xuICB2YXIgZWxlX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgLy8gbWFrZSBzaW5nbGUgZ3JvdXAtb25seSBzZWxlY3RvcnMgcmVhbGx5IGNoZWFwIHRvIGNoZWNrIHNpbmNlIHRoZXkncmUgdGhlIG1vc3QgY29tbW9uIG9uZXNcbiAgaWYoIHF1ZXJ5Lmdyb3VwT25seSApe1xuICAgIHJldHVybiBxdWVyeS5ncm91cCA9PT0gJyonIHx8IHF1ZXJ5Lmdyb3VwID09PSBlbGVfcC5ncm91cDtcbiAgfVxuXG4gIC8vIGNoZWNrIGdyb3VwXG4gIGlmKCBxdWVyeS5ncm91cCAhPSBudWxsICYmIHF1ZXJ5Lmdyb3VwICE9ICcqJyAmJiBxdWVyeS5ncm91cCAhPSBlbGVfcC5ncm91cCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjeSA9IGVsZS5jeSgpO1xuXG4gIC8vIGNoZWNrIGNvbG9uIHNlbGVjdG9yc1xuICB2YXIgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IHRydWU7XG4gIGZvciggdmFyIGsgPSAwOyBrIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBrKysgKXtcbiAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbIGsgXTtcblxuICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyggc2VsLCBlbGUgKTtcblxuICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIGJyZWFrO1xuICB9XG4gIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBjaGVjayBpZFxuICB2YXIgYWxsSWRzTWF0Y2ggPSB0cnVlO1xuICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyApe1xuICAgIHZhciBpZCA9IHF1ZXJ5Lmlkc1sgayBdO1xuICAgIHZhciBhY3R1YWxJZCA9IGVsZV9wLmRhdGEuaWQ7XG5cbiAgICBhbGxJZHNNYXRjaCA9IGFsbElkc01hdGNoICYmIChpZCA9PSBhY3R1YWxJZCk7XG5cbiAgICBpZiggIWFsbElkc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxJZHNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBjaGVjayBjbGFzc2VzXG4gIHZhciBhbGxDbGFzc2VzTWF0Y2ggPSB0cnVlO1xuICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBrKysgKXtcbiAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1sgayBdO1xuXG4gICAgYWxsQ2xhc3Nlc01hdGNoID0gYWxsQ2xhc3Nlc01hdGNoICYmIGVsZS5oYXNDbGFzcyggY2xzICk7XG5cbiAgICBpZiggIWFsbENsYXNzZXNNYXRjaCApIGJyZWFrO1xuICB9XG4gIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGdlbmVyaWMgY2hlY2tpbmcgZm9yIGRhdGEvbWV0YWRhdGFcbiAgdmFyIG9wZXJhbmRzTWF0Y2ggPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGFsbERhdGFNYXRjaGVzID0gdHJ1ZTtcbiAgICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5WyBwYXJhbXMubmFtZSBdLmxlbmd0aDsgaysrICl7XG4gICAgICB2YXIgZGF0YSA9IHF1ZXJ5WyBwYXJhbXMubmFtZSBdWyBrIF07XG4gICAgICB2YXIgb3BlcmF0b3IgPSBkYXRhLm9wZXJhdG9yO1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICB2YXIgbWF0Y2hlcztcblxuICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuXG4gICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKCBmaWVsZCApO1xuICAgICAgICB2YXIgZmllbGRTdHIgPSAhaXMuc3RyaW5nKCBmaWVsZFZhbCApICYmICFpcy5udW1iZXIoIGZpZWxkVmFsICkgPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICAgIHZhciB2YWxTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICAgIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoICdAJyApID49IDAgKXtcbiAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoICdAJywgJycgKTtcbiAgICAgICAgICBjYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoICchJyApID49IDAgKXtcbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoICchJywgJycgKTtcbiAgICAgICAgICBub3RFeHByID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICAgICAgICBpZiggY2FzZUluc2Vuc2l0aXZlICl7XG4gICAgICAgICAgdmFsdWUgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoKCBvcGVyYXRvciApe1xuICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YoIHZhbFN0ciApID49IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZiggdmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoICkgPj0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKCB2YWxTdHIgKSA9PT0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIG5vdCBvcCwgYnV0IG51bGwgdmFscyBmb3IgaW5lcXVhbGl0aWVzIHNob3VsZCBhbHdheXMgc3RheSBub24tbWF0Y2hpbmdcbiAgICAgICAgaWYoIG5vdEV4cHIgJiYgKCBmaWVsZFZhbCAhPSBudWxsIHx8ICFpc0luZXFDbXAgKSApe1xuICAgICAgICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCBvcGVyYXRvciAhPSBudWxsICl7XG4gICAgICAgIHN3aXRjaCggb3BlcmF0b3IgKXtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFRydXRoeSggZmllbGQgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRUcnV0aHkoIGZpZWxkICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIG1hdGNoZXMgPSBwYXJhbXMuZmllbGRVbmRlZmluZWQoIGZpZWxkICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVW5kZWZpbmVkKCBmaWVsZCApO1xuICAgICAgfVxuXG4gICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgYWxsRGF0YU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJldHVybiBhbGxEYXRhTWF0Y2hlcztcbiAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuXG4gIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKCB7XG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgcmV0dXJuIGVsZV9wLmRhdGFbIGZpZWxkIF07XG4gICAgfSxcbiAgICBmaWVsZFVuZGVmaW5lZDogZnVuY3Rpb24oIGZpZWxkICl7XG4gICAgICByZXR1cm4gZWxlX3AuZGF0YVsgZmllbGQgXSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgaWYoIGVsZV9wLmRhdGFbIGZpZWxkIF0gKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9ICk7XG5cbiAgaWYoICFhbGxEYXRhTWF0Y2hlcyApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgdmFyIGFsbE1ldGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCgge1xuICAgIG5hbWU6ICdtZXRhJyxcbiAgICBmaWVsZFZhbHVlOiBmdW5jdGlvbiggZmllbGQgKXtcbiAgICAgIHJldHVybiBlbGVbIGZpZWxkIF0oKTtcbiAgICB9LFxuICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbiggZmllbGQgKXtcbiAgICAgIHJldHVybiBlbGVbIGZpZWxkIF0oKSA9PSBudWxsO1xuICAgIH0sXG4gICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgaWYoIGVsZVsgZmllbGQgXSgpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSApO1xuXG4gIGlmKCAhYWxsTWV0YU1hdGNoZXMgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjaGVjayBjb2xsZWN0aW9uXG4gIGlmKCBxdWVyeS5jb2xsZWN0aW9uICE9IG51bGwgKXtcbiAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZCggZWxlLmlkKCkgKTtcblxuICAgIGlmKCAhbWF0Y2hlc0FueSApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGZpbHRlciBmdW5jdGlvblxuICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlLmNvbGxlY3Rpb24oKS5zb21lKCBxdWVyeS5maWx0ZXIgKSApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIHBhcmVudC9jaGlsZCByZWxhdGlvbnNcbiAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZXMgKXtcbiAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgaWYoICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcygpOyAvLyBzYXZlIGN5Y2xlcyBpZiBxdWVyeSA9PSBudWxsXG5cbiAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVzWyBpIF0gKSApe1xuICAgICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgaWYoICFjb25maXJtUmVsYXRpb25zKCBxdWVyeS5wYXJlbnQsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZS5wYXJlbnQoKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmKCAhY29uZmlybVJlbGF0aW9ucyggcXVlcnkuYW5jZXN0b3IsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZS5wYXJlbnRzKCk7XG4gIH0gKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiggIWNvbmZpcm1SZWxhdGlvbnMoIHF1ZXJ5LmNoaWxkLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmKCAhY29uZmlybVJlbGF0aW9ucyggcXVlcnkuZGVzY2VuZGFudCwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlLmRlc2NlbmRhbnRzKCk7XG4gIH0gKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQsIHNvIHdlJ3ZlIG1hdGNoZWQgZXZlcnl0aGluZyBmb3IgdGhpcyBxdWVyeVxuICByZXR1cm4gdHJ1ZTtcbn07IC8vIHF1ZXJ5TWF0Y2hlc1xuXG4vLyBmaWx0ZXIgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxuc2VsZm4uZmlsdGVyID0gZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBjb2xsZWN0aW9uLmN5KCk7XG5cbiAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG4gIGlmKCBzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmlkcy5sZW5ndGggPT09IDEgKXtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5nZXRFbGVtZW50QnlJZCggc2VsZlswXS5pZHNbMF0gKS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCBlbGVtZW50LCBpICl7XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmWyBqIF07XG5cbiAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50ICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9O1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uZmlsdGVyKCBzZWxlY3RvckZ1bmN0aW9uICk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkQ29sbGVjdGlvbjtcbn07IC8vIGZpbHRlclxuXG4vLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG5zZWxmbi5tYXRjaGVzID0gZnVuY3Rpb24oIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgIHZhciBxdWVyeSA9IHNlbGZbIGogXTtcblxuICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGUgKSApe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gZmlsdGVyXG5cbi8vIGl0aCBxdWVyeSB0byBzdHJpbmdcbnNlbGZuLnRvU3RyaW5nID0gc2VsZm4uc2VsZWN0b3IgPSBmdW5jdGlvbigpe1xuXG4gIHZhciBzdHIgPSAnJztcblxuICB2YXIgY2xlYW4gPSBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGVhblZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICBpZiggaXMuc3RyaW5nKCB2YWwgKSApe1xuICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xlYW4oIHZhbCApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3BhY2UgPSBmdW5jdGlvbiggdmFsICl7XG4gICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKCBxdWVyeSApe1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09PSBxdWVyeSApe1xuICAgICAgc3RyICs9ICckJztcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSBjbGVhbiggcXVlcnkuZ3JvdXAgKTtcbiAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKCAwLCBncm91cC5sZW5ndGggLSAxICk7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHF1ZXJ5LmRhdGEubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkuZGF0YVsgaiBdO1xuXG4gICAgICBpZiggZGF0YS52YWx1ZSApe1xuICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIHNwYWNlKCBjbGVhbiggZGF0YS5vcGVyYXRvciApICkgKyBjbGVhblZhbCggZGF0YS52YWx1ZSApICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9ICdbJyArIGNsZWFuKCBkYXRhLm9wZXJhdG9yICkgKyBkYXRhLmZpZWxkICsgJ10nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkubWV0YS5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG1ldGEgPSBxdWVyeS5tZXRhWyBqIF07XG4gICAgICBzdHIgKz0gJ1tbJyArIG1ldGEuZmllbGQgKyBzcGFjZSggY2xlYW4oIG1ldGEub3BlcmF0b3IgKSApICsgY2xlYW5WYWwoIG1ldGEudmFsdWUgKSArICddXSc7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzWyBpIF07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkuaWRzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgc2VsID0gJyMnICsgcXVlcnkuaWRzWyBpIF07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbIGogXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5hbmNlc3RvciApICsgJyAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5jaGlsZCApO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5kZXNjZW5kYW50ICE9IG51bGwgKXtcbiAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcXVlcnkgPSB0aGlzWyBpIF07XG5cbiAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcblxuICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSApe1xuICAgICAgc3RyICs9ICcsICc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3I7XG4iLCJmdW5jdGlvbiBPYmplY3RTZXQoKXtcbiAgdGhpcy5fb2JqID0ge307XG59XG5cbnZhciBwID0gT2JqZWN0U2V0LnByb3RvdHlwZTtcblxucC5hZGQgPSBmdW5jdGlvbiggdmFsICl7XG4gIHRoaXMuX29ialsgdmFsIF0gPSAxO1xufTtcblxucC5yZW1vdmUgPSBmdW5jdGlvbiggdmFsICl7XG4gIHRoaXMuX29ialsgdmFsIF0gPSAwO1xufTtcblxucC5oYXMgPSBmdW5jdGlvbiggdmFsICl7XG4gIHJldHVybiB0aGlzLl9vYmpbIHZhbCBdID09PSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyA/IFNldCA6IE9iamVjdFNldDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4vLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbi8vIC0gaXRzIGJ5cGFzc1xuLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiggZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgaWYoIF9wLm5ld1N0eWxlICl7IC8vIGNsZWFyIHN0eWxlIGNhY2hlc1xuICAgIF9wLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICBfcC5wcm9wRGlmZnMgPSB7fTtcblxuICAgIHNlbGYuY2xlYW5FbGVtZW50cyggZWxlcywgdHJ1ZSApO1xuICB9XG5cbiAgZm9yKCB2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGllIF07XG5cbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoIGVsZSApO1xuXG4gICAgaWYoIGN4dE1ldGEuZW1wdHkgKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZSggZWxlICk7XG4gICAgfVxuXG4gICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoIGN4dE1ldGEgKTtcbiAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZSggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApO1xuXG4gICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBhcHAuZGlmZlByb3BzICk7XG4gICAgc2VsZi51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcblxuICB9IC8vIGZvciBlbGVtZW50c1xuXG4gIF9wLm5ld1N0eWxlID0gZmFsc2U7XG5cbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcblxuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiggb2xkQ3h0S2V5LCBuZXdDeHRLZXkgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlWyBkdWFsQ3h0S2V5IF07XG5cbiAgaWYoIGNhY2hlZFZhbCApe1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICB2YXIgZGlmZlByb3BzID0gW107XG4gIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gc2VsZlsgaSBdO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbIGkgXSA9PT0gJ3QnO1xuICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbIGkgXSA9PT0gJ3QnO1xuICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgaWYoIGN4dEhhc0RpZmZlZCB8fCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgdmFyIHByb3BzO1xuXG4gICAgICBpZiggY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzRGlmZmVkICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgLy8gaXMgY2FjaGVkKVxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZbIGsgXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlbIGsgXSA9PT0gJ3QnO1xuXG4gICAgICAgICAgaWYoICFoYXNMYXRlckN4dCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggbGF0ZXJDeHRPdmVycmlkZXMgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFhZGRlZFByb3BbIG5hbWUgXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMgKXtcbiAgICAgICAgICBhZGRlZFByb3BbIG5hbWUgXSA9IHRydWU7XG4gICAgICAgICAgZGlmZlByb3BzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgcHJvcHNcbiAgICB9IC8vIGlmXG5cbiAgfSAvLyBmb3IgY29udGV4dHNcblxuICBjYWNoZVsgZHVhbEN4dEtleSBdID0gZGlmZlByb3BzO1xuICByZXR1cm4gZGlmZlByb3BzO1xufTtcblxuc3R5Zm4uZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApe1xuICAgIHByZXZLZXkgPSAnJzsgLy8gc2luY2Ugd2UgbmVlZCB0byBhcHBseSBhbGwgc3R5bGUgaWYgYSBmcmVzaCBzdHlsZXNoZWV0XG4gIH1cblxuICAvLyBnZXQgdGhlIGN4dCBrZXlcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBzZWxmWyBpIF07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmKCBjb250ZXh0U2VsZWN0b3JNYXRjaGVzICl7XG4gICAgICBjeHRLZXkgKz0gJ3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gJ2YnO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYoIHByZXZLZXksIGN4dEtleSApO1xuXG4gIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcblxuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICB9O1xufTtcblxuLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcbiAgaWYoIGN4dFN0eWxlc1sgY3h0S2V5IF0gKXsgcmV0dXJuIGN4dFN0eWxlc1sgY3h0S2V5IF07IH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgX3ByaXZhdGU6IHtcbiAgICAgIGtleTogY3h0S2V5XG4gICAgfVxuICB9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjeHQgPSBzZWxmWyBpIF07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVsgaSBdID09PSAndCc7XG5cbiAgICBpZiggIWhhc0N4dCApeyBjb250aW51ZTsgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1sgaiBdO1xuXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGN4dFN0eWxlc1sgY3h0S2V5IF0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbIGkgXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoIGRpZmZQcm9wTmFtZSApO1xuXG4gICAgaWYoICFjeHRQcm9wICl7IC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmKCAhZWxlUHJvcCApe1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmKCBlbGVQcm9wLmJ5cGFzcyApe1xuICAgICAgICBjeHRQcm9wID0geyBuYW1lOiBkaWZmUHJvcE5hbWUsIGRlbGV0ZUJ5cGFzc2VkOiB0cnVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeHRQcm9wID0geyBuYW1lOiBkaWZmUHJvcE5hbWUsIGRlbGV0ZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmKCBlbGVQcm9wID09PSBjeHRQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG5cbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoIGRpZmZQcm9wTmFtZSApO1xuXG4gICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgfTtcbn07XG5cbnN0eWZuLnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbihlbGUpe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiggZWxlLnJlbW92ZWQoKSApeyByZXR1cm47IH1cblxuICAvLyBzZXQgd2hldGhlciBoYXMgcGllIG9yIG5vdDsgZm9yIGdyZWF0ZXIgZWZmaWNpZW5jeVxuICB2YXIgaGFzUGllID0gZmFsc2U7XG4gIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IHNlbGYucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IGVsZS5wc3R5bGUoICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScgKS52YWx1ZTtcblxuICAgICAgaWYoIHNpemUgPiAwICl7XG4gICAgICAgIGhhc1BpZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wLmhhc1BpZSA9IGhhc1BpZTtcblxuICB2YXIgdHJhbnNmb3JtID0gZWxlLnBzdHlsZSggJ3RleHQtdHJhbnNmb3JtJyApLnN0clZhbHVlO1xuICB2YXIgY29udGVudCA9IGVsZS5wc3R5bGUoICdsYWJlbCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHNyY0NvbnRlbnQgPSBlbGUucHN0eWxlKCAnc291cmNlLWxhYmVsJyApLnN0clZhbHVlO1xuICB2YXIgdGd0Q29udGVudCA9IGVsZS5wc3R5bGUoICd0YXJnZXQtbGFiZWwnICkuc3RyVmFsdWU7XG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCAnZm9udC1zdHlsZScgKS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCAnZm9udC1zaXplJyApLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgZmFtaWx5ID0gZWxlLnBzdHlsZSggJ2ZvbnQtZmFtaWx5JyApLnN0clZhbHVlO1xuICAvLyB2YXIgdmFyaWFudCA9IHN0eWxlWydmb250LXZhcmlhbnQnXS5zdHJWYWx1ZTtcbiAgdmFyIHdlaWdodCA9IGVsZS5wc3R5bGUoICdmb250LXdlaWdodCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIG9XaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtd2lkdGgnICkucGZWYWx1ZTtcbiAgdmFyIHdyYXAgPSBlbGUucHN0eWxlKCAndGV4dC13cmFwJyApLnN0clZhbHVlO1xuICB2YXIgd3JhcFcgPSBlbGUucHN0eWxlKCAndGV4dC1tYXgtd2lkdGgnICkucGZWYWx1ZTtcbiAgdmFyIGxhYmVsU3R5bGVLZXkgPSBmU3R5bGUgKyAnJCcgKyBzaXplICsgJyQnICsgZmFtaWx5ICsgJyQnICsgd2VpZ2h0ICsgJyQnICsgdHJhbnNmb3JtICsgJyQnICsgdmFsaWduICsgJyQnICsgaGFsaWduICsgJyQnICsgb1dpZHRoICsgJyQnICsgd3JhcCArICckJyArIHdyYXBXO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gbGFiZWxTdHlsZUtleTtcbiAgX3Auc291cmNlTGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgc3JjQ29udGVudDtcbiAgX3AudGFyZ2V0TGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgdGd0Q29udGVudDtcbiAgX3AubGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgY29udGVudDtcbiAgX3AuZm9udEtleSA9IGZTdHlsZSArICckJyArIHdlaWdodCArICckJyArIHNpemUgKyAnJCcgKyBmYW1pbHk7XG5cbiAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpO1xufTtcblxuLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5zdHlmbi5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24oIGVsZSwgcGFyc2VkUHJvcCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG5cbiAgLy8gZWRnZXMgY29ubmVjdGVkIHRvIGNvbXBvdW5kIG5vZGVzIGNhbiBub3QgYmUgaGF5c3RhY2tzXG4gIGlmKFxuICAgIHBhcnNlZFByb3AubmFtZSA9PT0gJ2N1cnZlLXN0eWxlJ1xuICAgICYmIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaydcbiAgICAmJiBlbGUuaXNFZGdlKClcbiAgICAmJiAoIGVsZS5pc0xvb3AoKSB8fCBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSApXG4gICl7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBwYXJzZWRQcm9wLm5hbWUsICdiZXppZXInLCBwcm9wSXNCeXBhc3MgKTtcbiAgfVxuXG4gIGlmKCBwcm9wLmRlbGV0ZSApeyAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGFuZCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gZmFsc2V5IHZhbHVlXG4gICAgc3R5bGVbIHByb3AubmFtZSBdID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiggcHJvcC5kZWxldGVCeXBhc3NlZCApeyAvLyBkZWxldGUgdGhlIHByb3BlcnR5IHRoYXQgdGhlXG4gICAgaWYoICFvcmlnUHJvcCApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGNhbid0IGRlbGV0ZSBpZiBubyBwcm9wXG5cbiAgICB9IGVsc2UgaWYoIG9yaWdQcm9wLmJ5cGFzcyApeyAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gIGlmKCBwcm9wLmRlbGV0ZUJ5cGFzcyApeyAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgaWYoICFvcmlnUHJvcCApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcblxuICAgIH0gZWxzZSBpZiggb3JpZ1Byb3AuYnlwYXNzICl7IC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gb3JpZ1Byb3AuYnlwYXNzZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uKCl7XG4gICAgdXRpbC5lcnJvciggJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcgKTtcbiAgfTtcblxuICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gIHN3aXRjaCggcHJvcC5tYXBwZWQgKXsgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoICcuJyApO1xuICAgIHZhciBmaWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKyApe1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG4gICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50O1xuICAgIGlmKCAhaXMubnVtYmVyKCBmaWVsZFZhbCApICl7IC8vIHRoZW4ga2VlcCB0aGUgbWFwcGluZyBidXQgYXNzdW1lIDAlIGZvciBub3dcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyAocHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW4pO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG4gICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgdmFyIGNsciA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCggcjEgKyAocjIgLSByMSkgKiBwZXJjZW50ICksXG4gICAgICAgIE1hdGgucm91bmQoIGcxICsgKGcyIC0gZzEpICogcGVyY2VudCApLFxuICAgICAgICBNYXRoLnJvdW5kKCBiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQgKSxcbiAgICAgICAgTWF0aC5yb3VuZCggYTEgKyAoYTIgLSBhMSkgKiBwZXJjZW50IClcbiAgICAgIF07XG5cbiAgICAgIGZsYXRQcm9wID0geyAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgfVxuXG4gICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICAvLyBkaXJlY3QgbWFwcGluZ1xuICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCAnLicgKTtcbiAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgaWYoIGZpZWxkVmFsICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcbiAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgfSB9XG5cbiAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcblxuICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgdmFyIGZsYXRQcm9wVmFsID0gb3JpZ1Byb3AgPyBvcmlnUHJvcC5zdHJWYWx1ZSA6ICcnO1xuXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICBjYXNlIHR5cGVzLmZuOlxuICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgdmFyIGZuUmV0VmFsID0gZm4oIGVsZSApO1xuXG4gICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nICk7XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICBjYXNlIHVuZGVmaW5lZDpcbiAgICBicmVhazsgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfVxuXG4gIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICBpZiggcHJvcElzQnlwYXNzICl7XG4gICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7IC8vIHRoZW4gbGluayB0aGUgb3JpZyBwcm9wIHRvIHRoZSBuZXcgYnlwYXNzXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgfVxuXG4gICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYW5kIHNldFxuXG4gIH0gZWxzZSB7IC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2UgeyAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlciggZWxlLCBwcm9wLm5hbWUsIG9yaWdQcm9wID8gb3JpZ1Byb3AudmFsdWUgOiBudWxsLCBwcm9wLnZhbHVlICk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zdHlmbi5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZXMsIGtlZXBCeXBhc3NlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmKCAha2VlcEJ5cGFzc2VzICl7XG4gICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBlbGVQcm9wICl7XG4gICAgICAgICAgaWYoIGVsZVByb3AuYnlwYXNzICl7XG4gICAgICAgICAgICBlbGVQcm9wLmJ5cGFzc2VkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTtcblxuLy8ganVzdCB1cGRhdGUgdGhlIGZ1bmN0aW9uYWwgcHJvcGVydGllcyAoaS5lLiBtYXBwaW5ncykgaW4gdGhlIGVsZW1lbnRzJ1xuLy8gc3R5bGVzIChsZXNzIGV4cGVuc2l2ZSB0aGFuIHJlY2FsY3VsYXRpb24pXG5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciB1cGRhdGVkRWxlID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgaiBdO1xuICAgICAgdmFyIHByb3BJblN0eWxlID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICBpZiggcHJvcEluU3R5bGUgJiYgcHJvcEluU3R5bGUubWFwcGluZyApe1xuICAgICAgICB2YXIgbWFwcGluZyA9IHByb3BJblN0eWxlLm1hcHBpbmc7XG5cbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuXG4gICAgICAgIHVwZGF0ZWRFbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCB1cGRhdGVkRWxlICl7XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZSggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcblxuLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cbnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSggJ3RyYW5zaXRpb24tcHJvcGVydHknICkudmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoICd0cmFuc2l0aW9uLWR1cmF0aW9uJyApLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoICd0cmFuc2l0aW9uLWRlbGF5JyApLnBmVmFsdWU7XG5cbiAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICB2YXIgY3NzID0ge307XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBpIF07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUoIHByb3AgKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcCBdO1xuXG4gICAgICBpZiggIWRpZmZQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgIGlmKCBpcy5udW1iZXIoIGZyb21Qcm9wLnBmVmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC5wZlZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmKCBpcy5hcnJheSggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5hcnJheSggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF1cbiAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdXG4gICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXVxuICAgICAgICA7XG5cbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgIGlmKCBkaWZmICl7XG4gICAgICAgIGNzc1sgcHJvcCBdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBwcm9wLCBpbml0VmFsICk7IC8vIGZyb20gdmFsXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG5cbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICBpZiggIWFueVByZXYgKXsgcmV0dXJuOyB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIGVsZS5zdG9wKCk7XG5cbiAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICBlbGUuZGVsYXkoIGRlbGF5ICk7XG4gICAgfVxuXG4gICAgZWxlLmFuaW1hdGUoIHtcbiAgICAgIGNzczogY3NzXG4gICAgfSwge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nICkudmFsdWUsXG4gICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFpc0J5cGFzcyApe1xuICAgICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgfSBlbHNlIGlmKCBfcC50cmFuc2l0aW9uaW5nICl7XG4gICAgZWxlLnN0b3AoKTtcblxuICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24oIGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlICl7XG4gIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF07XG5cbiAgaWYoIHByb3AudHJpZ2dlcnNaT3JkZXIgJiYgKCBmcm9tVmFsdWUgPT0gbnVsbCB8fCBwcm9wLnRyaWdnZXJzWk9yZGVyKCBmcm9tVmFsdWUsIHRvVmFsdWUgKSApICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoe1xuICAgICAgdHlwZTogJ3pvcmRlcicsXG4gICAgICBlbGVzOiBlbGVcbiAgICB9KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbnN0eWZuLmFwcGx5QnlwYXNzID0gZnVuY3Rpb24oIGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgaWYoIG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionICl7IC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggbmFtZSApICl7IC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBuYW1lICkgKXsgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciB2YWx1ZSA9IHNwZWNpZmllZFByb3BzWyBuYW1lIF07XG5cbiAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIHV0aWwuZGFzaDJjYW1lbCggbmFtZSApIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHsgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICBpZiggcHJvcHMubGVuZ3RoID09PSAwICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaiBdO1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHByb3AgKSB8fCByZXQ7XG5cbiAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgICB9XG5cbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgaWYoIHJldCApe1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgICB9XG5cbiAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaCggbmFtZSApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbIG5hbWUgXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1sgbmFtZSBdLnR5cGU7XG4gICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuXG4gICAgaWYoICFwcm9wIHx8ICFwcm9wLmJ5cGFzcyApeyAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIG5hbWUsIHZhbHVlICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgb2xkVmFsdWUgPSBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiggcHJvcC5wZlZhbHVlICE9IG51bGwgKXtcbiAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmKCBpc0NvbG9yICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbiggJywnICkgKyAnKSc7XG4gICAgfSBlbHNlIGlmKCBpc011bHRpICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbiggJyAnICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3Auc3RyVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKCBlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSApO1xuICB9XG59O1xuXG5zdHlmbi5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyggZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xufTtcblxuc3R5Zm4ucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGogXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IHByb3BzWyBpIF07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1sgbmFtZSBdO1xuICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG5cbiAgICAgIGlmKCAhcHJldlByb3AgfHwgIXByZXZQcm9wLmJ5cGFzcyApe1xuICAgICAgICAvLyBpZiBhIGJ5cGFzcyBkb2Vzbid0IGV4aXN0IGZvciB0aGUgcHJvcCwgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBuYW1lLCB2YWx1ZSwgdHJ1ZSApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHBhcnNlZFByb3AgKTtcblxuICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vd2luZG93JyApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbnN0eWZuLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoICdmb250LXNpemUnICk7XG5cbiAgaWYoIHB4ICE9IG51bGwgKXtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCggcHggKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gIH1cbn07XG5cbi8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5zdHlmbi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRvbUVsZW1lbnQgKS5nZXRQcm9wZXJ0eVZhbHVlKCBwcm9wTmFtZSApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuLmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiggZWxlLCBwcm9wICl7XG4gIGlmKCBwcm9wICl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIHByb3AsIHRydWUgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYXdTdHlsZSggZWxlLCB0cnVlICk7XG4gIH1cbn07XG5cbi8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4uZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiggZWxlLCBpc1JlbmRlcmVkVmFsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmKCBlbGUgKXtcbiAgICB2YXIgcnN0eWxlID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIGkgXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwgKTtcblxuICAgICAgaWYoIHZhbCAhPSBudWxsICl7XG4gICAgICAgIHJzdHlsZVsgcHJvcC5uYW1lIF0gPSB2YWw7XG4gICAgICAgIHJzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKCBwcm9wLm5hbWUgKSBdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH1cbn07XG5cbnN0eWZuLmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKCBlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmKCBlbGUgKXtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXTtcblxuICAgIGlmKCBwcm9wLmFsaWFzICl7XG4gICAgICBwcm9wID0gcHJvcC5wb2ludHNUbztcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICB2YXIgdW5pdHMgPSBzdHlsZVByb3AudW5pdHMgPyB0eXBlLmltcGxpY2l0VW5pdHMgfHwgJ3B4JyA6IG51bGw7XG4gICAgICB2YXIgdmFsID0gdW5pdHMgPyBbXS5jb25jYXQoIHN0eWxlUHJvcC5wZlZhbHVlICkubWFwKCBmdW5jdGlvbiggcGZWYWx1ZSApe1xuICAgICAgICByZXR1cm4gKCBwZlZhbHVlICogKGlzUmVuZGVyZWRWYWwgPyB6b29tIDogMSkgKSArIHVuaXRzO1xuICAgICAgfSApLmpvaW4oICcgJyApIDogc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxuc3R5Zm4uZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIGFuaVByb3BzICl7XG4gIHZhciByc3R5bGUgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1sgaSBdO1xuICAgIHZhciBuYW1lID0gYW5pUHJvcC5uYW1lO1xuXG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUoIG5hbWUgKTtcblxuICAgIGlmKCBzdHlsZVByb3AgIT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIHN0eWxlUHJvcCApICl7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHN0eWxlUHJvcC5zdHJWYWx1ZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgc3R5bGVQcm9wICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgcnN0eWxlWyBuYW1lIF0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuLmdldFByb3BzTGlzdCA9IGZ1bmN0aW9uKCBwcm9wc09iaiApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByc3R5bGUgPSBbXTtcbiAgdmFyIHN0eWxlID0gcHJvcHNPYmo7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBpZiggc3R5bGUgKXtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyggc3R5bGUgKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgdmFsID0gc3R5bGVbIG5hbWUgXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIG5hbWUgXSB8fCBwcm9wc1sgdXRpbC5jYW1lbDJkYXNoKCBuYW1lICkgXTtcbiAgICAgIHZhciBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIHZhbCApO1xuXG4gICAgICByc3R5bGUucHVzaCggc3R5bGVQcm9wICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKCAnLi4vc2VsZWN0b3InICk7XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkgKXtcbiAgICByZXR1cm4gbmV3IFN0eWxlKCBjeSApO1xuICB9XG5cbiAgaWYoICFpcy5jb3JlKCBjeSApICl7XG4gICAgdXRpbC5lcnJvciggJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgY29yZVN0eWxlOiB7fVxuICB9O1xuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xuXG52YXIgc3R5Zm4gPSBTdHlsZS5wcm90b3R5cGU7XG5cbnN0eWZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdzdHlsZSc7XG59O1xuXG4vLyByZW1vdmUgYWxsIGNvbnRleHRzXG5zdHlmbi5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHRoaXNbIGkgXSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICBfcC5uZXdTdHlsZSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbi5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5zdHlmbi5jb3JlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xufTtcblxuLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3JTdHIgKXtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgdGhpc1sgaSBdID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG5zdHlmbi5jc3MgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgY2FzZSAxOlxuICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIG1hcFZhbCA9IG1hcFsgdXRpbC5kYXNoMmNhbWVsKCBwcm9wLm5hbWUgKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5jc3NSdWxlKCBwcm9wLm5hbWUsIG1hcFZhbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgMjpcbiAgICB0aGlzLmNzc1J1bGUoIGFyZ3NbMF0sIGFyZ3NbMV0gKTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIGJyZWFrOyAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzO1xuXG4vLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gIGlmKCBwcm9wZXJ0eSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHRoaXNbIGkgXS5wcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgdGhpc1sgaSBdLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiggcHJvcGVydHkubmFtZS5tYXRjaCggL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLyApICYmIHByb3BlcnR5LnZhbHVlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHByb3BlcnR5Lm1hcHBlZCApe1xuICAgICAgdGhpc1sgaSBdLm1hcHBlZFByb3BlcnRpZXMucHVzaCggcHJvcGVydHkgKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbIGkgXS5zZWxlY3RvcjtcbiAgICBpZiggY3VycmVudFNlbGVjdG9ySXNDb3JlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVsgcHJvcGVydHkubmFtZSBdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBzdGF0aWMgZnVuY3Rpb25cblN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZSggY3kgKTtcblxuICBzdHlsZS5mcm9tSnNvbigganNvbiApO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICByZXR1cm4gbmV3IFN0eWxlKCBjeSApLmZyb21TdHJpbmcoIHN0cmluZyApO1xufTtcblxuW1xuICByZXF1aXJlKCAnLi9hcHBseScgKSxcbiAgcmVxdWlyZSggJy4vYnlwYXNzJyApLFxuICByZXF1aXJlKCAnLi9jb250YWluZXInICksXG4gIHJlcXVpcmUoICcuL2dldC1mb3ItZWxlJyApLFxuICByZXF1aXJlKCAnLi9qc29uJyApLFxuICByZXF1aXJlKCAnLi9zdHJpbmctc2hlZXQnICksXG4gIHJlcXVpcmUoICcuL3Byb3BlcnRpZXMnICksXG4gIHJlcXVpcmUoICcuL3BhcnNlJyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggc3R5Zm4sIHByb3BzICk7XG59ICk7XG5cblxuU3R5bGUudHlwZXMgPSBzdHlmbi50eXBlcztcblN0eWxlLnByb3BlcnRpZXMgPSBzdHlmbi5wcm9wZXJ0aWVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBqc29uICl7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uWyBpIF07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKCBwcm9wcyApO1xuXG4gICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yICk7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbIG5hbWUgXTtcblxuICAgICAgc3R5bGUuY3NzKCBuYW1lLCB2YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuc3R5Zm4uZnJvbUpzb24gPSBmdW5jdGlvbigganNvbiApe1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGx5RnJvbUpzb24oIGpzb24gKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5zdHlmbi5qc29uID0gZnVuY3Rpb24oKXtcbiAgdmFyIGpzb24gPSBbXTtcblxuICBmb3IoIHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjeHQgPSB0aGlzWyBpIF07XG4gICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcbiAgICAgIGNzc1sgcHJvcC5uYW1lIF0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCgge1xuICAgICAgc2VsZWN0b3I6ICFzZWxlY3RvciA/ICdjb3JlJyA6IHNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICBzdHlsZTogY3NzXG4gICAgfSApO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vbWF0aCcgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGEgY2FjaGluZyBsYXllciBmb3IgcHJvcGVydHkgcGFyc2luZ1xuc3R5Zm4ucGFyc2UgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuICBpZiggaXMuZm4oIHZhbHVlICkgKXtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICk7XG4gIH1cblxuICB2YXIgZmxhdEtleSA9ICggcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnIHx8IHByb3BJc0ZsYXQgPT09IHRydWUgfHwgcHJvcElzRmxhdCA9PT0gZmFsc2UgfHwgcHJvcElzRmxhdCA9PSBudWxsICkgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGFyZ0hhc2ggPSBbIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIGZsYXRLZXkgXS5qb2luKCAnJCcgKTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwge307XG4gIHZhciByZXQ7XG5cbiAgaWYoICEocmV0ID0gcHJvcENhY2hlWyBhcmdIYXNoIF0pICl7XG4gICAgcmV0ID0gcHJvcENhY2hlWyBhcmdIYXNoIF0gPSBzZWxmLnBhcnNlSW1wbFdhcm4oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKTtcbiAgfVxuXG4gIC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG4gIGlmKCBwcm9wSXNCeXBhc3MgfHwgcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnICl7XG4gICAgLy8gbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICAgIHJldCA9IHV0aWwuY29weSggcmV0ICk7XG5cbiAgICBpZiggcmV0ICl7XG4gICAgICByZXQudmFsdWUgPSB1dGlsLmNvcHkoIHJldC52YWx1ZSApOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5zdHlmbi5wYXJzZUltcGxXYXJuID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHByb3AgPSB0aGlzLnBhcnNlSW1wbCggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApO1xuXG4gIGlmKCAhcHJvcCAmJiB2YWx1ZSAhPSBudWxsICl7XG4gICAgdXRpbC5lcnJvcignVGhlIHN0eWxlIHByb3BlcnR5IGAlczogJXNgIGlzIGludmFsaWQnLCBuYW1lLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcHJvcDtcbn07XG5cbi8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuc3R5Zm4ucGFyc2VJbXBsID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG5hbWUgPSB1dGlsLmNhbWVsMmRhc2goIG5hbWUgKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1sgbmFtZSBdO1xuICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBpZiggIXByb3BlcnR5ICl7IHJldHVybiBudWxsOyB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcbiAgaWYoIHByb3BlcnR5LmFsaWFzICl7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgfVxuXG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gaXMuc3RyaW5nKCB2YWx1ZSApO1xuICBpZiggdmFsdWVJc1N0cmluZyApeyAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG4gIGlmKCAhdHlwZSApeyByZXR1cm4gbnVsbDsgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgaWYoIHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSApe1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICBpZiggaXMuZm4oIHZhbHVlICkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICB2YXIgZGF0YSwgbWFwRGF0YTtcbiAgaWYoICF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgKXtcbiAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gIH0gZWxzZSBpZiggZGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLmRhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICl7XG4gICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgIHZhciBtYXBwZWQgPSB0eXBlcy5kYXRhO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIG1hcERhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5tYXBEYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApe1xuICAgIGlmKCBwcm9wSXNCeXBhc3MgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG4gICAgaWYoIHR5cGUubXVsdGlwbGUgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGltcG9zc2libGUgdG8gbWFwIHRvIG51bVxuXG4gICAgdmFyIG1hcHBlZCA9IHR5cGVzLm1hcERhdGE7XG5cbiAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICBpZiggISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNF0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNV0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcbiAgICBpZiggdmFsdWVNaW4udmFsdWUgPT09IHZhbHVlTWF4LnZhbHVlICl7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcblxuICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcblxuICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAmJiAoIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIDtcblxuICAgICAgaWYoIHNhbWUgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KCBtYXBEYXRhWzJdICksIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQoIG1hcERhdGFbM10gKSxcbiAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIGlmKCB0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScgKXtcbiAgICB2YXIgdmFscztcblxuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoIC9cXHMrLyApO1xuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIHZhbHVlICkgKXtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFsgdmFsdWUgXTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5ldmVuTXVsdGlwbGUgJiYgdmFscy5sZW5ndGggJSAyICE9PSAwICl7IHJldHVybiBudWxsOyB9XG5cbiAgICB2YXIgdmFsQXJyID0gW107XG4gICAgdmFyIHVuaXRzQXJyID0gW107XG4gICAgdmFyIHBmVmFsQXJyID0gW107XG4gICAgdmFyIGhhc0VudW0gPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHAgPSBzZWxmLnBhcnNlKCBuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScgKTtcblxuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgaXMuc3RyaW5nKCBwLnZhbHVlICk7XG5cbiAgICAgIHZhbEFyci5wdXNoKCBwLnZhbHVlICk7XG4gICAgICBwZlZhbEFyci5wdXNoKCBwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUgKTtcbiAgICAgIHVuaXRzQXJyLnB1c2goIHAudW5pdHMgKTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS52YWxpZGF0ZSAmJiAhdHlwZS52YWxpZGF0ZSggdmFsQXJyLCB1bml0c0FyciApICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0gKXtcbiAgICAgIGlmKCB2YWxBcnIubGVuZ3RoID09PSAxICYmIGlzLnN0cmluZyggdmFsQXJyWzBdICkgKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogdmFsQXJyLmpvaW4oICcgJyApLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9XG5cbiAgLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbIGkgXTtcblxuICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gIGlmKCB0eXBlLm51bWJlciApe1xuICAgIHZhciB1bml0cztcbiAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgIGlmKCB0eXBlLnVuaXRzICl7IC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuaW1wbGljaXRVbml0cyApe1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG5cbiAgICBpZiggIXR5cGUudW5pdGxlc3MgKXtcbiAgICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICBpZiggdW5pdHMgKXsgdW5pdHNSZWdleCA9IHVuaXRzOyB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCAnXignICsgdXRpbC5yZWdleC5udW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcgKTtcblxuICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoICF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMgKXtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG4gICAgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuICAgIGlmKCBpc05hTiggdmFsdWUgKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgaWYoIGlzTmFOKCB2YWx1ZSApICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcblxuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcbiAgICBpZiggdHlwZS5pbnRlZ2VyICYmICFpcy5pbnRlZ2VyKCB2YWx1ZSApICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiggKCB0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICggdmFsdWUgPCB0eXBlLm1pbiB8fCAodHlwZS5zdHJpY3RNaW4gJiYgdmFsdWUgPT09IHR5cGUubWluKSApIClcbiAgICB8fCAgKCB0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmICggdmFsdWUgPiB0eXBlLm1heCB8fCAodHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSApIClcbiAgICApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgIGlmKCB0eXBlLnVuaXRsZXNzIHx8ICh1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuICAgIGlmKCB1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogbWF0aC5kZWcycmFkKCB2YWx1ZSApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSB2YWx1ZSBpbiAlXG4gICAgaWYoIHVuaXRzID09PSAnJScgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWUgLyAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxuICB9IGVsc2UgaWYoIHR5cGUucHJvcExpc3QgKXtcblxuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgIH0gZWxzZSB7IC8vIGdvIG92ZXIgZWFjaCBwcm9wXG5cbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoICcsJyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbIGkgXS50cmltKCk7XG5cbiAgICAgICAgaWYoIHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXSApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oICcsICcgKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICB2YXIgdHVwbGUgPSB1dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgaWYoICF0dXBsZSApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICByb3VuZFZhbHVlOiB0cnVlXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzICl7XG5cbiAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgIGlmKCB0eXBlLmVudW1zICl7XG4gICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG5cbiAgICAgIGlmKCBlbnVtUHJvcCApeyByZXR1cm4gZW51bVByb3A7IH1cbiAgICB9XG5cbiAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFsgdHlwZS5yZWdleCBdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCByZWdleGVzWyBpIF0gKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG4gICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWMoIHZhbHVlICk7XG5cbiAgICAgIGlmKCBtICl7IC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuXG4gIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuZW51bXMgKXsgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbihmdW5jdGlvbigpe1xuICB2YXIgbnVtYmVyID0gdXRpbC5yZWdleC5udW1iZXI7XG4gIHZhciByZ2JhID0gdXRpbC5yZWdleC5yZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSB1dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICB2YXIgaGV4MyA9IHV0aWwucmVnZXguaGV4MztcbiAgdmFyIGhleDYgPSB1dGlsLnJlZ2V4LmhleDY7XG4gIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2O1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gIH07XG4gIHZhciB1cmxSZWdleGVzID0gW1xuICAgICdedXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKSQnLFxuICAgICdeKG5vbmUpJCcsXG4gICAgJ14oLispJCdcbiAgXTtcblxuICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gIHN0eWZuLnR5cGVzID0ge1xuICAgIHRpbWU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIHVuaXRzOiAnc3xtcycsIGltcGxpY2l0VW5pdHM6ICdtcycgfSxcbiAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJywgaW1wbGljaXRVbml0czogJyUnIH0sXG4gICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIHplcm9PbmVOdW1iZXJzOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIG5PbmVPbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbm9uTmVnYXRpdmVJbnQ6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGludGVnZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgcG9zaXRpb246IHsgZW51bXM6IFsgJ3BhcmVudCcsICdvcmlnaW4nIF0gfSxcbiAgICBub2RlU2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgZW51bXM6IFsgJ2xhYmVsJyBdIH0sXG4gICAgbnVtYmVyOiB7IG51bWJlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBudW1iZXJzOiB7IG51bWJlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUsIG11bHRpcGxlOiB0cnVlIH0sXG4gICAgcG9zaXRpdmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSwgbWluOiAwLCBzdHJpY3RNaW46IHRydWUgfSxcbiAgICBzaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHsgbnVtYmVyOiB0cnVlIH0sIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplczogeyBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlIH0sIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIHNpemVNYXliZVBlcmNlbnQ6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgIHBhZGRpbmdSZWxhdGl2ZVRvOiB7IGVudW1zOiBbICd3aWR0aCcsICdoZWlnaHQnLCAnYXZlcmFnZScsICdtaW4nLCAnbWF4JyBdIH0sXG4gICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWyAnYXV0bycgXSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ1BvczogeyBudW1iZXI6IHRydWUsIGFsbG93UGVyY2VudDogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ1JlcGVhdDogeyBlbnVtczogWyAncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCcgXSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ0ZpdDogeyBlbnVtczogWyAnbm9uZScsICdjb250YWluJywgJ2NvdmVyJyBdLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIGJnQ3Jvc3NPcmlnaW46IHsgZW51bXM6IFsgJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnIF0sIG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYmdDbGlwOiB7IGVudW1zOiBbICdub25lJywgJ25vZGUnIF0gfSxcbiAgICBjb2xvcjogeyBjb2xvcjogdHJ1ZSB9LFxuICAgIGJvb2w6IHsgZW51bXM6IFsgJ3llcycsICdubycgXSB9LFxuICAgIGxpbmVTdHlsZTogeyBlbnVtczogWyAnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcgXSB9LFxuICAgIGJvcmRlclN0eWxlOiB7IGVudW1zOiBbICdzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZScgXSB9LFxuICAgIGN1cnZlU3R5bGU6IHsgZW51bXM6IFsgJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJyBdIH0sXG4gICAgZm9udEZhbWlseTogeyByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCcgfSxcbiAgICBmb250VmFyaWFudDogeyBlbnVtczogWyAnc21hbGwtY2FwcycsICdub3JtYWwnIF0gfSxcbiAgICBmb250U3R5bGU6IHsgZW51bXM6IFsgJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZScgXSB9LFxuICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsgJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwIF0gfSxcbiAgICB0ZXh0RGVjb3JhdGlvbjogeyBlbnVtczogWyAnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJyBdIH0sXG4gICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWyAnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJyBdIH0sXG4gICAgdGV4dFdyYXA6IHsgZW51bXM6IFsgJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcycgXSB9LFxuICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHsgZW51bXM6IFsgJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScgXX0sXG4gICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbICdyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAnY3V0cmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdoZXhhZ29uJywgJ2hlcHRhZ29uJywgJ29jdGFnb24nLCAnc3RhcicsICdkaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJyBdIH0sXG4gICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7IGVudW1zOiBbICdpbmNsdWRlJywgJ2V4Y2x1ZGUnIF0gfSxcbiAgICBhcnJvd1NoYXBlOiB7IGVudW1zOiBbICd0ZWUnLCAndHJpYW5nbGUnLCAndHJpYW5nbGUtdGVlJywgJ3RyaWFuZ2xlLWNyb3NzJywgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsICdoYWxmLXRyaWFuZ2xlLW92ZXJzaG90JywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnbm9uZScgXSB9LFxuICAgIGFycm93RmlsbDogeyBlbnVtczogWyAnZmlsbGVkJywgJ2hvbGxvdycgXSB9LFxuICAgIGRpc3BsYXk6IHsgZW51bXM6IFsgJ2VsZW1lbnQnLCAnbm9uZScgXSB9LFxuICAgIHZpc2liaWxpdHk6IHsgZW51bXM6IFsgJ2hpZGRlbicsICd2aXNpYmxlJyBdIH0sXG4gICAgekNvbXBvdW5kRGVwdGg6IHsgZW51bXM6IFsgJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnIF0gfSxcbiAgICB6SW5kZXhDb21wYXJlOiB7IGVudW1zOiBbICdhdXRvJywgJ21hbnVhbCcgXSB9LFxuICAgIHZhbGlnbjogeyBlbnVtczogWyAndG9wJywgJ2NlbnRlcicsICdib3R0b20nIF0gfSxcbiAgICBoYWxpZ246IHsgZW51bXM6IFsgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JyBdIH0sXG4gICAgdGV4dDogeyBzdHJpbmc6IHRydWUgfSxcbiAgICBkYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCAnZGF0YScgKSB9LFxuICAgIGxheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoICdsYXlvdXREYXRhJyApIH0sXG4gICAgc2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSggJ3NjcmF0Y2gnICkgfSxcbiAgICBtYXBEYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCAnbWFwRGF0YScgKSB9LFxuICAgIG1hcExheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoICdtYXBMYXlvdXREYXRhJyApIH0sXG4gICAgbWFwU2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSggJ21hcFNjcmF0Y2gnICkgfSxcbiAgICBmbjogeyBtYXBwaW5nOiB0cnVlLCBmbjogdHJ1ZSB9LFxuICAgIHVybDogeyByZWdleGVzOiB1cmxSZWdleGVzLCBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUgfSxcbiAgICB1cmxzOiB7IHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBwcm9wTGlzdDogeyBwcm9wTGlzdDogdHJ1ZSB9LFxuICAgIGFuZ2xlOiB7IG51bWJlcjogdHJ1ZSwgdW5pdHM6ICdkZWd8cmFkJywgaW1wbGljaXRVbml0czogJ3JhZCcgfSxcbiAgICB0ZXh0Um90YXRpb246IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnLCBpbXBsaWNpdFVuaXRzOiAncmFkJywgZW51bXM6IFsgJ25vbmUnLCAnYXV0b3JvdGF0ZScgXSB9LFxuICAgIHBvbHlnb25Qb2ludExpc3Q6IHsgbnVtYmVyOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSwgZXZlbk11bHRpcGxlOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgZWRnZURpc3RhbmNlczogeyBlbnVtczogWydpbnRlcnNlY3Rpb24nLCAnbm9kZS1wb3NpdGlvbiddIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlLCB1bml0czogJyV8cHh8ZW18ZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWyAnaW5zaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbGluZScgXSwgc2luZ2xlRW51bTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiggdmFsQXJyLCB1bml0c0FyciApe1xuICAgICAgICBzd2l0Y2goIHZhbEFyci5sZW5ndGggKXtcbiAgICAgICAgICBjYXNlIDI6IC8vIGNhbiBiZSAlIG9yIHB4IG9ubHlcbiAgICAgICAgICAgIHJldHVybiB1bml0c0FyclswXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMF0gIT09ICdyYWQnICYmIHVuaXRzQXJyWzFdICE9PSAnZGVnJyAmJiB1bml0c0FyclsxXSAhPT0gJ3JhZCc7XG4gICAgICAgICAgY2FzZSAxOiAvLyBjYW4gYmUgZW51bSwgZGVnLCBvciByYWQgb25seVxuICAgICAgICAgICAgcmV0dXJuIGlzLnN0cmluZyggdmFsQXJyWzBdICkgfHwgdW5pdHNBcnJbMF0gPT09ICdkZWcnIHx8IHVuaXRzQXJyWzBdID09PSAncmFkJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlYXNpbmc6IHtcbiAgICAgIHJlZ2V4ZXM6IFtcbiAgICAgICAgJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJyxcbiAgICAgICAgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCdcbiAgICAgIF0sXG4gICAgICBlbnVtczogW1xuICAgICAgICAnbGluZWFyJyxcbiAgICAgICAgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsXG4gICAgICAgICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJyxcbiAgICAgICAgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLFxuICAgICAgICAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsXG4gICAgICAgICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JyxcbiAgICAgICAgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLFxuICAgICAgICAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsXG4gICAgICAgICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ1xuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICB2YXIgek9yZGVyRGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24oIHZhbDEsIHZhbDIgKXtcbiAgICAgIGlmKCB2YWwxID09PSAwICYmIHZhbDIgIT09IDAgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYoIHZhbDEgIT09IDAgJiYgdmFsMiA9PT0gMCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueURpZmY6IGZ1bmN0aW9uKCB2YWwxLCB2YWwyICl7XG4gICAgICByZXR1cm4gdmFsMSAhPT0gdmFsMjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHpkID0gek9yZGVyRGlmZjtcblxuICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHQgPSBzdHlmbi50eXBlcztcbiAgdmFyIHByb3BzID0gc3R5Zm4ucHJvcGVydGllcyA9IFtcbiAgICAvLyBtYWluIGxhYmVsXG4gICAgeyBuYW1lOiAnbGFiZWwnLCB0eXBlOiB0LnRleHQgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW1hcmdpbi14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtbWFyZ2luLXknLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG5cbiAgICAvLyBzb3VyY2UgbGFiZWxcbiAgICB7IG5hbWU6ICdzb3VyY2UtbGFiZWwnLCB0eXBlOiB0LnRleHQgfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtdGV4dC1yb3RhdGlvbicsIHR5cGU6IHQudGV4dFJvdGF0aW9uIH0sXG4gICAgeyBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXknLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAnc291cmNlLXRleHQtb2Zmc2V0JywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyB0YXJnZXQgbGFiZWxcbiAgICB7IG5hbWU6ICd0YXJnZXQtbGFiZWwnLCB0eXBlOiB0LnRleHQgfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtdGV4dC1yb3RhdGlvbicsIHR5cGU6IHQudGV4dFJvdGF0aW9uIH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXknLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LXRleHQtb2Zmc2V0JywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyBjb21tb24gbGFiZWwgc3R5bGVcbiAgICB7IG5hbWU6ICd0ZXh0LXZhbGlnbicsIHR5cGU6IHQudmFsaWduIH0sXG4gICAgeyBuYW1lOiAndGV4dC1oYWxpZ24nLCB0eXBlOiB0LmhhbGlnbiB9LFxuICAgIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJywgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlfSxcbiAgICAvLyB7IG5hbWU6ICd0ZXh0LWRlY29yYXRpb24nLCB0eXBlOiB0LnRleHREZWNvcmF0aW9uIH0sIC8vIG5vdCBzdXBwb3J0ZWQgaW4gY2FudmFzXG4gICAgeyBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLCB0eXBlOiB0LnRleHRUcmFuc2Zvcm0gfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXdyYXAnLCB0eXBlOiB0LnRleHRXcmFwIH0sXG4gICAgeyBuYW1lOiAndGV4dC1tYXgtd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWV2ZW50cycsIHR5cGU6IHQuYm9vbCB9LFxuICAgIHsgbmFtZTogJ2ZvbnQtZmFtaWx5JywgdHlwZTogdC5mb250RmFtaWx5IH0sXG4gICAgeyBuYW1lOiAnZm9udC1zdHlsZScsIHR5cGU6IHQuZm9udFN0eWxlIH0sXG4gICAgLy8geyBuYW1lOiAnZm9udC12YXJpYW50JywgdHlwZTogdC5mb250VmFyaWFudCB9LCAvLyBub3QgdXNlZnVsXG4gICAgeyBuYW1lOiAnZm9udC13ZWlnaHQnLCB0eXBlOiB0LmZvbnRXZWlnaHQgfSxcbiAgICB7IG5hbWU6ICdmb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgLy8gYmVoYXZpb3VyXG4gICAgeyBuYW1lOiAnZXZlbnRzJywgdHlwZTogdC5ib29sIH0sXG5cbiAgICAvLyB2aXNpYmlsaXR5XG4gICAgeyBuYW1lOiAnZGlzcGxheScsIHR5cGU6IHQuZGlzcGxheSwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcbiAgICB7IG5hbWU6ICd2aXNpYmlsaXR5JywgdHlwZTogdC52aXNpYmlsaXR5LCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LFxuICAgIHsgbmFtZTogJ29wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsIHRyaWdnZXJzWk9yZGVyOiB6ZC56ZXJvTm9uWmVybyB9LFxuICAgIHsgbmFtZTogJ3otY29tcG91bmQtZGVwdGgnLCB0eXBlOiB0LnpDb21wb3VuZERlcHRoLCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LFxuICAgIHsgbmFtZTogJ3otaW5kZXgtY29tcGFyZScsIHR5cGU6IHQuekluZGV4Q29tcGFyZSwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcbiAgICB7IG5hbWU6ICd6LWluZGV4JywgdHlwZTogdC5ub25OZWdhdGl2ZUludCwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcblxuICAgIC8vIG92ZXJsYXlzXG4gICAgeyBuYW1lOiAnb3ZlcmxheS1wYWRkaW5nJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnb3ZlcmxheS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcblxuICAgIC8vIHRyYW5zaXRpb24gYW5pc1xuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLCB0eXBlOiB0LnByb3BMaXN0IH0sXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsIHR5cGU6IHQudGltZSB9LFxuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLCB0eXBlOiB0LnRpbWUgfSxcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHR5cGU6IHQuZWFzaW5nIH0sXG5cbiAgICAvLyBub2RlIGJvZHlcbiAgICB7IG5hbWU6ICdoZWlnaHQnLCB0eXBlOiB0Lm5vZGVTaXplIH0sXG4gICAgeyBuYW1lOiAnd2lkdGgnLCB0eXBlOiB0Lm5vZGVTaXplIH0sXG4gICAgeyBuYW1lOiAnc2hhcGUnLCB0eXBlOiB0Lm5vZGVTaGFwZSB9LFxuICAgIHsgbmFtZTogJ3NoYXBlLXBvbHlnb24tcG9pbnRzJywgdHlwZTogdC5wb2x5Z29uUG9pbnRMaXN0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWJsYWNrZW4nLCB0eXBlOiB0Lm5PbmVPbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1yZWxhdGl2ZS10bycsIHR5cGU6IHQucGFkZGluZ1JlbGF0aXZlVG8gfSxcblxuICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgeyBuYW1lOiAnYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2JvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuXG4gICAgLy8gbm9kZSBiYWNrZ3JvdW5kIGltYWdlc1xuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybHMgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVycyB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHR5cGU6IHQuYmdQb3MgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLCB0eXBlOiB0LmJnUmVwZWF0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1maXQnLCB0eXBlOiB0LmJnRml0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJywgdHlwZTogdC5iZ1dIIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLCB0eXBlOiB0LmJnV0ggfSxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiB0LnBvc2l0aW9uIH0sXG4gICAgeyBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLCB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyB9LFxuICAgIHsgbmFtZTogJ21pbi13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLCB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQgfSxcbiAgICB7IG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LFxuICAgIHsgbmFtZTogJ21pbi1oZWlnaHQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sXG4gICAgeyBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LFxuXG4gICAgLy8gZWRnZSBsaW5lXG4gICAgeyBuYW1lOiAnbGluZS1zdHlsZScsIHR5cGU6IHQubGluZVN0eWxlIH0sXG4gICAgeyBuYW1lOiAnbGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LFxuICAgIHsgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsIHR5cGU6IHQuZWRnZUVuZHBvaW50IH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JywgdHlwZTogdC5lZGdlRW5kcG9pbnQgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSxcbiAgICB7IG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzIH0sXG4gICAgeyBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJywgdHlwZTogdC5udW1iZXJzIH0sXG4gICAgeyBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLCB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1zY2FsZScsIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdsb29wLWRpcmVjdGlvbicsIHR5cGU6IHQuYW5nbGUgfSxcbiAgICB7IG5hbWU6ICdsb29wLXN3ZWVwJywgdHlwZTogdC5hbmdsZSB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyB0aGVzZSBhcmUganVzdCBmb3IgdGhlIGNvcmVcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfVxuICBdO1xuXG4gIC8vIGRlZmluZSBhbGlhc2VzXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4uYWxpYXNlcyA9IFtcbiAgICB7IG5hbWU6ICdjb250ZW50JywgcG9pbnRzVG86ICdsYWJlbCcgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJywgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyB9LFxuICAgIHsgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbicgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLWxlZnQnLCBwb2ludHNUbzogJ3BhZGRpbmcnIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1yaWdodCcsIHBvaW50c1RvOiAncGFkZGluZycgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLXRvcCcsIHBvaW50c1RvOiAncGFkZGluZycgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsIHBvaW50c1RvOiAncGFkZGluZycgfVxuICBdO1xuXG4gIC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgc3R5Zm4ucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS1zaXplJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0gKTtcbiAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gc3R5Zm4ucGllQmFja2dyb3VuZE47IGkrKyApe1xuICAgIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSApO1xuICAgIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJywgdHlwZTogdC5wZXJjZW50IH0gKTtcbiAgICBwcm9wcy5wdXNoKCB7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9ICk7XG4gIH1cblxuICAvLyBlZGdlIGFycm93c1xuICB2YXIgYXJyb3dQcmVmaXhlcyA9IHN0eWZuLmFycm93UHJlZml4ZXMgPSBbICdzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCcgXTtcbiAgW1xuICAgIHsgbmFtZTogJ2Fycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH1cbiAgXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcCApe1xuICAgIGFycm93UHJlZml4ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHByZWZpeCApe1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcblxuICAgICAgcHJvcHMucHVzaCggeyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlIH0gKTtcbiAgICB9ICk7XG4gIH0sIHt9ICk7XG5cbiAgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICBzdHlmbi5wcm9wZXJ0eU5hbWVzID0gcHJvcHMubWFwKCBmdW5jdGlvbiggcCApeyByZXR1cm4gcC5uYW1lOyB9ICk7XG5cbiAgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuXG4gICAgcHJvcHNbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxuXG4gIC8vIG1hcCBhbGlhc2VzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgYWxpYXNlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbIGkgXTtcbiAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbIGFsaWFzLnBvaW50c1RvIF07XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFsaWFzIHByb3AgZm9yIHBhcnNpbmdcbiAgICBwcm9wcy5wdXNoKCBhbGlhc1Byb3AgKTtcblxuICAgIHByb3BzWyBhbGlhcy5uYW1lIF0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5cbnN0eWZuLmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBuYW1lICl7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbIG5hbWUgXTtcbn07XG5cbnN0eWZuLmdldERlZmF1bHRQcm9wZXJ0aWVzID0gdXRpbC5tZW1vaXplKCBmdW5jdGlvbigpe1xuICB2YXIgcmF3UHJvcHMgPSB1dGlsLmV4dGVuZCgge1xuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgLy8gJ2ZvbnQtdmFyaWFudCc6IGZvbnRWYXJpYW50LFxuICAgICdmb250LXdlaWdodCc6ICdub3JtYWwnLFxuICAgICdmb250LXNpemUnOiAxNixcbiAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICd0ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICdzb3VyY2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndGFyZ2V0LXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgJ2Rpc3BsYXknOiAnZWxlbWVudCcsXG4gICAgJ29wYWNpdHknOiAxLFxuICAgICd6LWNvbXBvdW5kLWRlcHRoJzogJ2F1dG8nLFxuICAgICd6LWluZGV4LWNvbXBhcmUnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgnOiAwLFxuICAgICdsYWJlbCc6ICcnLFxuICAgICd0ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3NvdXJjZS1sYWJlbCc6ICcnLFxuICAgICdzb3VyY2UtdGV4dC1vZmZzZXQnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAndGFyZ2V0LWxhYmVsJzogJycsXG4gICAgJ3RhcmdldC10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXknOiAwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLFxuICAgICdvdmVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICdsaW5lYXInLFxuXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnYXV0bycsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICdoZWlnaHQnOiAzMCxcbiAgICAnd2lkdGgnOiAzMCxcbiAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgJ3BhZGRpbmcnOiAwLFxuICAgICdwYWRkaW5nLXJlbGF0aXZlLXRvJzogJ3dpZHRoJyxcbiAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG4gICAgJ21pbi13aWR0aCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLWxlZnQnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLWJvdHRvbSc6IDBcbiAgfSwge1xuICAgIC8vIG5vZGUgcGllIGJnXG4gICAgJ3BpZS1zaXplJzogJzEwMCUnXG4gIH0sIFtcbiAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsIHZhbHVlOiAnYmxhY2snIH0sXG4gICAgeyBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtc2l6ZScsIHZhbHVlOiAnMCUnIH0sXG4gICAgeyBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsIHZhbHVlOiAxIH1cbiAgXS5yZWR1Y2UoIGZ1bmN0aW9uKCBjc3MsIHByb3AgKXtcbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSBzdHlmbi5waWVCYWNrZ3JvdW5kTjsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCAne3tpfX0nLCBpICk7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcblxuICAgICAgY3NzWyBuYW1lIF0gPSB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30gKSwge1xuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LWRpc3RhbmNlcyc6IDIwLFxuICAgICdlZGdlLWRpc3RhbmNlcyc6ICdpbnRlcnNlY3Rpb24nLFxuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLFxuICAgICdhcnJvdy1zY2FsZSc6IDEsXG4gICAgJ2xvb3AtZGlyZWN0aW9uJzogJy0xMzVkZWcnLFxuICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnXG4gIH0sIFtcbiAgICB7IG5hbWU6ICdhcnJvdy1zaGFwZScsIHZhbHVlOiAnbm9uZScgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1jb2xvcicsIHZhbHVlOiAnIzk5OScgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1maWxsJywgdmFsdWU6ICdmaWxsZWQnIH1cbiAgXS5yZWR1Y2UoIGZ1bmN0aW9uKCBjc3MsIHByb3AgKXtcbiAgICBzdHlmbi5hcnJvd1ByZWZpeGVzLmZvckVhY2goIGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG5cbiAgICAgIGNzc1sgbmFtZSBdID0gdmFsO1xuICAgIH0gKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9ICkgKTtcblxuICB2YXIgcGFyc2VkUHJvcHMgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgaWYoIHByb3AucG9pbnRzVG8gKXsgY29udGludWU7IH1cblxuICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgIHZhciB2YWwgPSByYXdQcm9wc1sgbmFtZSBdO1xuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsICk7XG5cbiAgICBwYXJzZWRQcm9wc1sgbmFtZSBdID0gcGFyc2VkUHJvcDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQcm9wcztcbn0gKTtcblxuc3R5Zm4uYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzXG4gICAgLnNlbGVjdG9yKCAnJG5vZGUgPiBub2RlJyApIC8vIGNvbXBvdW5kIChwYXJlbnQpIG5vZGUgcHJvcGVydGllc1xuICAgICAgLmNzcygge1xuICAgICAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICAgJ3BhZGRpbmcnOiAxMCxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgICAgICdib3JkZXItY29sb3InOiAnI2NjYycsXG4gICAgICAgICdib3JkZXItd2lkdGgnOiAxXG4gICAgICB9IClcbiAgICAuc2VsZWN0b3IoICdlZGdlJyApIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKCB7XG4gICAgICAgICd3aWR0aCc6IDMsXG4gICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdoYXlzdGFjaydcbiAgICAgIH0gKVxuICAgIC5zZWxlY3RvciggJzpzZWxlY3RlZCcgKVxuICAgICAgLmNzcygge1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICAgJ2xpbmUtY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5J1xuICAgICAgfSApXG4gICAgLnNlbGVjdG9yKCAnbm9kZTpwYXJlbnQ6c2VsZWN0ZWQnIClcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0NDRTFGOScsXG4gICAgICAgICdib3JkZXItY29sb3InOiAnI2FlYzhlNSdcbiAgICAgIH0gKVxuICAgIC5zZWxlY3RvciggJzphY3RpdmUnIClcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gICAgICB9IClcbiAgICAuc2VsZWN0b3IoICdjb3JlJyApIC8vIGp1c3QgY29yZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKCB7XG4gICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1XG4gICAgICB9IClcbiAgO1xuXG4gIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoICcuLi9zZWxlY3RvcicgKTtcblxudmFyIHN0eWZuID0ge307XG5cbnN0eWZuLmFwcGx5RnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gIHZhciBzZWxBbmRCbG9ja1N0cjtcbiAgdmFyIGJsb2NrUmVtO1xuICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG4gIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKCAvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnICk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCl7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgaWYoIHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKXtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoIHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1haW5pbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpe1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmKCBibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCApe1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIoIHByb3BBbmRWYWxTdHIubGVuZ3RoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUoIHRydWUgKXtcbiAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKCAvXlxccyokLyApO1xuICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCggL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9LyApO1xuXG4gICAgaWYoICFzZWxBbmRCbG9jayApe1xuICAgICAgdXRpbC5lcnJvciggJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHNlbEFuZEJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMF07XG5cbiAgICAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcbiAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcbiAgICBpZiggc2VsZWN0b3JTdHIgIT09ICdjb3JlJyApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgaWYoIHNlbGVjdG9yLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0ciApO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIHdoaWxlKCB0cnVlICl7XG4gICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goIC9eXFxzKiQvICk7XG4gICAgICBpZiggbm90aGluZ0xlZnRUb1BhcnNlICl7IGJyZWFrOyB9XG5cbiAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goIC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPylcXHMqOy8gKTtcblxuICAgICAgaWYoICFwcm9wQW5kVmFsICl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIGZvcm1hdHRpbmcgb2Ygc3R5bGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlZmluaXRpb25zIGZvdW5kIGluOicgKyBibG9ja1N0ciApO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIHByb3BTdHIgXTtcbiAgICAgIGlmKCAhcHJvcCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIgKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKCBwcm9wU3RyLCB2YWxTdHIgKTtcblxuICAgICAgaWYoICFwYXJzZWRQcm9wICl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0ciApO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLnB1c2goIHtcbiAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgIH0gKTtcbiAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgfVxuXG4gICAgaWYoIGludmFsaWRCbG9jayApe1xuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICBzdHlsZS5zZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBpIF07XG4gICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWwgKTtcbiAgICB9XG5cbiAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnN0eWZuLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3RyaW5nICl7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgc3R5bGUuYXBwbHlGcm9tU3RyaW5nKCBzdHJpbmcgKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4vdXRpbCcgKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoICcuL3N0eWxlJyApO1xuXG4vLyBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IHRoYXQgZG9lc24ndCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlXG4vLyAodXNlZnVsIGZvciBpbml0KVxudmFyIFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgU3R5bGVzaGVldCkgKXtcbiAgICByZXR1cm4gbmV3IFN0eWxlc2hlZXQoKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbnZhciBzaGVldGZuID0gU3R5bGVzaGVldC5wcm90b3R5cGU7XG5cbnNoZWV0Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKztcblxuICB0aGlzWyBpIF0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gIGlmKCBpcy5zdHJpbmcoIG5hbWUgKSApe1xuICAgIHRoaXNbIGkgXS5wcm9wZXJ0aWVzLnB1c2goIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9ICk7XG4gIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIG5hbWUgKSApe1xuICAgIHZhciBtYXAgPSBuYW1lO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBTdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcHJvcCA9IFN0eWxlLnByb3BlcnRpZXNbIGogXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXsgLy8gYWxzbyB0cnkgY2FtZWwgY2FzZSBuYW1lXG4gICAgICAgIG1hcFZhbCA9IG1hcFsgdXRpbC5kYXNoMmNhbWVsKCBwcm9wLm5hbWUgKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1hcFZhbDtcblxuICAgICAgICB0aGlzWyBpIF0ucHJvcGVydGllcy5wdXNoKCB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzO1xuXG4vLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcbnNoZWV0Zm4uZ2VuZXJhdGVTdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoIGN5ICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzWyBpIF07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG5cbiAgICBzdHlsZS5zZWxlY3Rvciggc2VsZWN0b3IgKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcblxuICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlc2hlZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgaGV4MnR1cGxlOiBmdW5jdGlvbiggaGV4ICl7XG4gICAgaWYoICEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJyApeyByZXR1cm47IH1cblxuICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgdmFyIHIsIGcsIGI7XG4gICAgdmFyIGJhc2UgPSAxNjtcblxuICAgIGlmKCBzaG9ydEhleCApe1xuICAgICAgciA9IHBhcnNlSW50KCBoZXhbMV0gKyBoZXhbMV0sIGJhc2UgKTtcbiAgICAgIGcgPSBwYXJzZUludCggaGV4WzJdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICBiID0gcGFyc2VJbnQoIGhleFszXSArIGhleFszXSwgYmFzZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgZyA9IHBhcnNlSW50KCBoZXhbM10gKyBoZXhbNF0sIGJhc2UgKTtcbiAgICAgIGIgPSBwYXJzZUludCggaGV4WzVdICsgaGV4WzZdLCBiYXNlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsgciwgZywgYiBdO1xuICB9LFxuXG4gIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKXtcbiAgICAgIGlmKCB0IDwgMCApIHQgKz0gMTtcbiAgICAgIGlmKCB0ID4gMSApIHQgLT0gMTtcbiAgICAgIGlmKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgIGlmKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcbiAgICAgIGlmKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoICdeJyArIHRoaXMucmVnZXguaHNsYSArICckJyApLmV4ZWMoIGhzbCApO1xuICAgIGlmKCBtICl7XG5cbiAgICAgIC8vIGdldCBodWVcbiAgICAgIGggPSBwYXJzZUludCggbVsxXSApO1xuICAgICAgaWYoIGggPCAwICl7XG4gICAgICAgIGggPSAoIDM2MCAtICgtMSAqIGggJSAzNjApICkgJSAzNjA7XG4gICAgICB9IGVsc2UgaWYoIGggPiAzNjAgKXtcbiAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICB9XG4gICAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBzID0gcGFyc2VGbG9hdCggbVsyXSApO1xuICAgICAgaWYoIHMgPCAwIHx8IHMgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cbiAgICAgIHMgPSBzIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGwgPSBwYXJzZUZsb2F0KCBtWzNdICk7XG4gICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBhID0gbVs0XTtcbiAgICAgIGlmKCBhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICBpZiggYSA8IDAgfHwgYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgICAgfVxuXG4gICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgICAgaWYoIHMgPT09IDAgKXtcbiAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZCggbCAqIDI1NSApOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYiggcCwgcSwgaCArIDEgLyAzICkgKTtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IoIHAsIHEsIGggKSApO1xuICAgICAgICBiID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYiggcCwgcSwgaCAtIDEgLyAzICkgKTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gWyByLCBnLCBiLCBhIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcbiAgcmdiMnR1cGxlOiBmdW5jdGlvbiggcmdiICl7XG4gICAgdmFyIHJldDtcblxuICAgIHZhciBtID0gbmV3IFJlZ0V4cCggJ14nICsgdGhpcy5yZWdleC5yZ2JhICsgJyQnICkuZXhlYyggcmdiICk7XG4gICAgaWYoIG0gKXtcbiAgICAgIHJldCA9IFtdO1xuXG4gICAgICB2YXIgaXNQY3QgPSBbXTtcbiAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IDM7IGkrKyApe1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG1bIGkgXTtcblxuICAgICAgICBpZiggY2hhbm5lbFsgY2hhbm5lbC5sZW5ndGggLSAxIF0gPT09ICclJyApe1xuICAgICAgICAgIGlzUGN0WyBpIF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KCBjaGFubmVsICk7XG5cbiAgICAgICAgaWYoIGlzUGN0WyBpIF0gKXtcbiAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICAgIH1cblxuICAgICAgICBpZiggY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goIE1hdGguZmxvb3IoIGNoYW5uZWwgKSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICBpZiggYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QgKXsgcmV0dXJuOyB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICB2YXIgYWxwaGEgPSBtWzRdO1xuICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KCBhbHBoYSApO1xuXG4gICAgICAgIGlmKCBhbHBoYSA8IDAgfHwgYWxwaGEgPiAxICl7IHJldHVybjsgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBjb2xvcm5hbWUydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgIHJldHVybiB0aGlzLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICB9LFxuXG4gIGNvbG9yMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICByZXR1cm4gKCBpcy5hcnJheSggY29sb3IgKSA/IGNvbG9yIDogbnVsbCApXG4gICAgICB8fCB0aGlzLmNvbG9ybmFtZTJ0dXBsZSggY29sb3IgKVxuICAgICAgfHwgdGhpcy5oZXgydHVwbGUoIGNvbG9yIClcbiAgICAgIHx8IHRoaXMucmdiMnR1cGxlKCBjb2xvciApXG4gICAgICB8fCB0aGlzLmhzbDJ0dXBsZSggY29sb3IgKTtcbiAgfSxcblxuICBjb2xvcnM6IHtcbiAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICBhbGljZWJsdWU6IFsgMjQwLCAyNDgsIDI1NSBdLFxuICAgIGFudGlxdWV3aGl0ZTogWyAyNTAsIDIzNSwgMjE1IF0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1IF0sXG4gICAgYXF1YW1hcmluZTogWyAxMjcsIDI1NSwgMjEyIF0sXG4gICAgYXp1cmU6IFsgMjQwLCAyNTUsIDI1NSBdLFxuICAgIGJlaWdlOiBbIDI0NSwgMjQ1LCAyMjAgXSxcbiAgICBiaXNxdWU6IFsgMjU1LCAyMjgsIDE5NiBdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsgMjU1LCAyMzUsIDIwNSBdLFxuICAgIGJsdWU6IFswLCAwLCAyNTUgXSxcbiAgICBibHVldmlvbGV0OiBbIDEzOCwgNDMsIDIyNiBdLFxuICAgIGJyb3duOiBbIDE2NSwgNDIsIDQyIF0sXG4gICAgYnVybHl3b29kOiBbIDIyMiwgMTg0LCAxMzUgXSxcbiAgICBjYWRldGJsdWU6IFsgOTUsIDE1OCwgMTYwIF0sXG4gICAgY2hhcnRyZXVzZTogWyAxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbIDIxMCwgMTA1LCAzMCBdLFxuICAgIGNvcmFsOiBbIDI1NSwgMTI3LCA4MCBdLFxuICAgIGNvcm5mbG93ZXJibHVlOiBbIDEwMCwgMTQ5LCAyMzcgXSxcbiAgICBjb3Juc2lsazogWyAyNTUsIDI0OCwgMjIwIF0sXG4gICAgY3JpbXNvbjogWyAyMjAsIDIwLCA2MCBdLFxuICAgIGN5YW46IFswLCAyNTUsIDI1NSBdLFxuICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5IF0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOSBdLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFsgMTg0LCAxMzQsIDExIF0sXG4gICAgZGFya2dyYXk6IFsgMTY5LCAxNjksIDE2OSBdLFxuICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgZGFya2dyZXk6IFsgMTY5LCAxNjksIDE2OSBdLFxuICAgIGRhcmtraGFraTogWyAxODksIDE4MywgMTA3IF0sXG4gICAgZGFya21hZ2VudGE6IFsgMTM5LCAwLCAxMzkgXSxcbiAgICBkYXJrb2xpdmVncmVlbjogWyA4NSwgMTA3LCA0NyBdLFxuICAgIGRhcmtvcmFuZ2U6IFsgMjU1LCAxNDAsIDBdLFxuICAgIGRhcmtvcmNoaWQ6IFsgMTUzLCA1MCwgMjA0IF0sXG4gICAgZGFya3JlZDogWyAxMzksIDAsIDBdLFxuICAgIGRhcmtzYWxtb246IFsgMjMzLCAxNTAsIDEyMiBdLFxuICAgIGRhcmtzZWFncmVlbjogWyAxNDMsIDE4OCwgMTQzIF0sXG4gICAgZGFya3NsYXRlYmx1ZTogWyA3MiwgNjEsIDEzOSBdLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOSBdLFxuICAgIGRhcmt2aW9sZXQ6IFsgMTQ4LCAwLCAyMTEgXSxcbiAgICBkZWVwcGluazogWyAyNTUsIDIwLCAxNDcgXSxcbiAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1IF0sXG4gICAgZGltZ3JheTogWyAxMDUsIDEwNSwgMTA1IF0sXG4gICAgZGltZ3JleTogWyAxMDUsIDEwNSwgMTA1IF0sXG4gICAgZG9kZ2VyYmx1ZTogWyAzMCwgMTQ0LCAyNTUgXSxcbiAgICBmaXJlYnJpY2s6IFsgMTc4LCAzNCwgMzQgXSxcbiAgICBmbG9yYWx3aGl0ZTogWyAyNTUsIDI1MCwgMjQwIF0sXG4gICAgZm9yZXN0Z3JlZW46IFsgMzQsIDEzOSwgMzQgXSxcbiAgICBmdWNoc2lhOiBbIDI1NSwgMCwgMjU1IF0sXG4gICAgZ2FpbnNib3JvOiBbIDIyMCwgMjIwLCAyMjAgXSxcbiAgICBnaG9zdHdoaXRlOiBbIDI0OCwgMjQ4LCAyNTUgXSxcbiAgICBnb2xkOiBbIDI1NSwgMjE1LCAwXSxcbiAgICBnb2xkZW5yb2Q6IFsgMjE4LCAxNjUsIDMyIF0sXG4gICAgZ3JheTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgZ3JleTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgIGdyZWVueWVsbG93OiBbIDE3MywgMjU1LCA0NyBdLFxuICAgIGhvbmV5ZGV3OiBbIDI0MCwgMjU1LCAyNDAgXSxcbiAgICBob3RwaW5rOiBbIDI1NSwgMTA1LCAxODAgXSxcbiAgICBpbmRpYW5yZWQ6IFsgMjA1LCA5MiwgOTIgXSxcbiAgICBpbmRpZ286IFsgNzUsIDAsIDEzMCBdLFxuICAgIGl2b3J5OiBbIDI1NSwgMjU1LCAyNDAgXSxcbiAgICBraGFraTogWyAyNDAsIDIzMCwgMTQwIF0sXG4gICAgbGF2ZW5kZXI6IFsgMjMwLCAyMzAsIDI1MCBdLFxuICAgIGxhdmVuZGVyYmx1c2g6IFsgMjU1LCAyNDAsIDI0NSBdLFxuICAgIGxhd25ncmVlbjogWyAxMjQsIDI1MiwgMF0sXG4gICAgbGVtb25jaGlmZm9uOiBbIDI1NSwgMjUwLCAyMDUgXSxcbiAgICBsaWdodGJsdWU6IFsgMTczLCAyMTYsIDIzMCBdLFxuICAgIGxpZ2h0Y29yYWw6IFsgMjQwLCAxMjgsIDEyOCBdLFxuICAgIGxpZ2h0Y3lhbjogWyAyMjQsIDI1NSwgMjU1IF0sXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsgMjUwLCAyNTAsIDIxMCBdLFxuICAgIGxpZ2h0Z3JheTogWyAyMTEsIDIxMSwgMjExIF0sXG4gICAgbGlnaHRncmVlbjogWyAxNDQsIDIzOCwgMTQ0IF0sXG4gICAgbGlnaHRncmV5OiBbIDIxMSwgMjExLCAyMTEgXSxcbiAgICBsaWdodHBpbms6IFsgMjU1LCAxODIsIDE5MyBdLFxuICAgIGxpZ2h0c2FsbW9uOiBbIDI1NSwgMTYwLCAxMjIgXSxcbiAgICBsaWdodHNlYWdyZWVuOiBbIDMyLCAxNzgsIDE3MCBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjUwIF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBbIDExOSwgMTM2LCAxNTMgXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWyAxNzYsIDE5NiwgMjIyIF0sXG4gICAgbGlnaHR5ZWxsb3c6IFsgMjU1LCAyNTUsIDIyNCBdLFxuICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgIGxpbWVncmVlbjogWyA1MCwgMjA1LCA1MCBdLFxuICAgIGxpbmVuOiBbIDI1MCwgMjQwLCAyMzAgXSxcbiAgICBtYWdlbnRhOiBbIDI1NSwgMCwgMjU1IF0sXG4gICAgbWFyb29uOiBbIDEyOCwgMCwgMF0sXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWyAxMDIsIDIwNSwgMTcwIF0sXG4gICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNSBdLFxuICAgIG1lZGl1bW9yY2hpZDogWyAxODYsIDg1LCAyMTEgXSxcbiAgICBtZWRpdW1wdXJwbGU6IFsgMTQ3LCAxMTIsIDIxOSBdLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbIDYwLCAxNzksIDExMyBdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWyAxMjMsIDEwNCwgMjM4IF0sXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NCBdLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogWyA3MiwgMjA5LCAyMDQgXSxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFsgMTk5LCAyMSwgMTMzIF0sXG4gICAgbWlkbmlnaHRibHVlOiBbIDI1LCAyNSwgMTEyIF0sXG4gICAgbWludGNyZWFtOiBbIDI0NSwgMjU1LCAyNTAgXSxcbiAgICBtaXN0eXJvc2U6IFsgMjU1LCAyMjgsIDIyNSBdLFxuICAgIG1vY2Nhc2luOiBbIDI1NSwgMjI4LCAxODEgXSxcbiAgICBuYXZham93aGl0ZTogWyAyNTUsIDIyMiwgMTczIF0sXG4gICAgbmF2eTogWzAsIDAsIDEyOCBdLFxuICAgIG9sZGxhY2U6IFsgMjUzLCAyNDUsIDIzMCBdLFxuICAgIG9saXZlOiBbIDEyOCwgMTI4LCAwXSxcbiAgICBvbGl2ZWRyYWI6IFsgMTA3LCAxNDIsIDM1IF0sXG4gICAgb3JhbmdlOiBbIDI1NSwgMTY1LCAwXSxcbiAgICBvcmFuZ2VyZWQ6IFsgMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbIDIxOCwgMTEyLCAyMTQgXSxcbiAgICBwYWxlZ29sZGVucm9kOiBbIDIzOCwgMjMyLCAxNzAgXSxcbiAgICBwYWxlZ3JlZW46IFsgMTUyLCAyNTEsIDE1MiBdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsgMTc1LCAyMzgsIDIzOCBdLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFsgMjE5LCAxMTIsIDE0NyBdLFxuICAgIHBhcGF5YXdoaXA6IFsgMjU1LCAyMzksIDIxMyBdLFxuICAgIHBlYWNocHVmZjogWyAyNTUsIDIxOCwgMTg1IF0sXG4gICAgcGVydTogWyAyMDUsIDEzMywgNjMgXSxcbiAgICBwaW5rOiBbIDI1NSwgMTkyLCAyMDMgXSxcbiAgICBwbHVtOiBbIDIyMSwgMTYwLCAyMjEgXSxcbiAgICBwb3dkZXJibHVlOiBbIDE3NiwgMjI0LCAyMzAgXSxcbiAgICBwdXJwbGU6IFsgMTI4LCAwLCAxMjggXSxcbiAgICByZWQ6IFsgMjU1LCAwLCAwXSxcbiAgICByb3N5YnJvd246IFsgMTg4LCAxNDMsIDE0MyBdLFxuICAgIHJveWFsYmx1ZTogWyA2NSwgMTA1LCAyMjUgXSxcbiAgICBzYWRkbGVicm93bjogWyAxMzksIDY5LCAxOSBdLFxuICAgIHNhbG1vbjogWyAyNTAsIDEyOCwgMTE0IF0sXG4gICAgc2FuZHlicm93bjogWyAyNDQsIDE2NCwgOTYgXSxcbiAgICBzZWFncmVlbjogWyA0NiwgMTM5LCA4NyBdLFxuICAgIHNlYXNoZWxsOiBbIDI1NSwgMjQ1LCAyMzggXSxcbiAgICBzaWVubmE6IFsgMTYwLCA4MiwgNDUgXSxcbiAgICBzaWx2ZXI6IFsgMTkyLCAxOTIsIDE5MiBdLFxuICAgIHNreWJsdWU6IFsgMTM1LCAyMDYsIDIzNSBdLFxuICAgIHNsYXRlYmx1ZTogWyAxMDYsIDkwLCAyMDUgXSxcbiAgICBzbGF0ZWdyYXk6IFsgMTEyLCAxMjgsIDE0NCBdLFxuICAgIHNsYXRlZ3JleTogWyAxMTIsIDEyOCwgMTQ0IF0sXG4gICAgc25vdzogWyAyNTUsIDI1MCwgMjUwIF0sXG4gICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyNyBdLFxuICAgIHN0ZWVsYmx1ZTogWyA3MCwgMTMwLCAxODAgXSxcbiAgICB0YW46IFsgMjEwLCAxODAsIDE0MCBdLFxuICAgIHRlYWw6IFswLCAxMjgsIDEyOCBdLFxuICAgIHRoaXN0bGU6IFsgMjE2LCAxOTEsIDIxNiBdLFxuICAgIHRvbWF0bzogWyAyNTUsIDk5LCA3MSBdLFxuICAgIHR1cnF1b2lzZTogWyA2NCwgMjI0LCAyMDggXSxcbiAgICB2aW9sZXQ6IFsgMjM4LCAxMzAsIDIzOCBdLFxuICAgIHdoZWF0OiBbIDI0NSwgMjIyLCAxNzkgXSxcbiAgICB3aGl0ZTogWyAyNTUsIDI1NSwgMjU1IF0sXG4gICAgd2hpdGVzbW9rZTogWyAyNDUsIDI0NSwgMjQ1IF0sXG4gICAgeWVsbG93OiBbIDI1NSwgMjU1LCAwXSxcbiAgICB5ZWxsb3dncmVlbjogWyAxNTQsIDIwNSwgNTAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmdsb2JhbCBjb25zb2xlICovXG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uL21hdGgnICk7XG5cbnZhciB1dGlsID0ge1xuXG4gIHRydWVpZnk6IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9LFxuXG4gIGZhbHNpZnk6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfSxcblxuICB6ZXJvaWZ5OiBmdW5jdGlvbigpeyByZXR1cm4gMDsgfSxcblxuICBub29wOiBmdW5jdGlvbigpe30sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKXtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGlmKCBjb25zb2xlLmVycm9yICl7XG4gICAgICBjb25zb2xlLmVycm9yLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCgge30sIG9iaiApO1xuICB9LFxuXG4gIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gIGNvcHk6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBpZiggaXMuYXJyYXkoIG9iaiApICl7XG4gICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggb2JqICkgKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCBvYmogKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sXG5cbiAgdXVpZDogZnVuY3Rpb24oXG4gICAgICBhLGIgICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXJzXG4gICl7XG4gICAgICBmb3IoICAgICAgICAgICAgICAgLy8gbG9vcCA6KVxuICAgICAgICAgIGI9YT0nJzsgICAgICAgIC8vIGIgLSByZXN1bHQgLCBhIC0gbnVtZXJpYyB2YXJpYWJsZVxuICAgICAgICAgIGErKzwzNjsgICAgICAgIC8vXG4gICAgICAgICAgYis9YSo1MSY1MiAgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgICAgICAgICAgICAgICAgICAgICA/ICAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgYV4xNSAgICAgIC8vIGlmIFwiYVwiIGlzIG5vdCAxNVxuICAgICAgICAgICAgICAgICAgPyAgICAgIC8vIGdlbmV0YXRlIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgICAgICAgICAgICAgIDheTWF0aC5yYW5kb20oKSpcbiAgICAgICAgICAgICAgIChhXjIwPzE2OjQpICAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICAgICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgNCAgICAgICAgICAgIC8vICBvdGhlcndpc2UgNFxuICAgICAgICAgICAgICAgKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgJy0nICAgICAgICAgICAgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGI7XG4gIH1cblxufTtcblxudXRpbC5tYWtlQm91bmRpbmdCb3ggPSBtYXRoLm1ha2VCb3VuZGluZ0JveC5iaW5kKCBtYXRoICk7XG5cbnV0aWwuX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG5cbnV0aWwuc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdXRpbC5fc3RhdGljRW1wdHlPYmplY3Q7XG59O1xuXG51dGlsLmV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiggdGd0ICl7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGZvciggdmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBvYmogPSBhcmdzWyBpIF07XG5cbiAgICBpZiggIW9iaiApeyBjb250aW51ZTsgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggb2JqICk7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcblxuICAgICAgdGd0WyBrIF0gPSBvYmpbIGsgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGd0O1xufTtcblxudXRpbC5kZWZhdWx0ID0gZnVuY3Rpb24oIHZhbCwgZGVmICl7XG4gIGlmKCB2YWwgPT09IHVuZGVmaW5lZCApe1xuICAgIHJldHVybiBkZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcblxudXRpbC5yZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiggYXJyLCBlbGUsIG1hbnlDb3BpZXMgKXtcbiAgZm9yKCB2YXIgaSA9IGFyci5sZW5ndGg7IGkgPj0gMDsgaS0tICl7XG4gICAgaWYoIGFycltpXSA9PT0gZWxlICl7XG4gICAgICBhcnIuc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgIGlmKCAhbWFueUNvcGllcyApeyBicmVhazsgfVxuICAgIH1cbiAgfVxufTtcblxudXRpbC5jbGVhckFycmF5ID0gZnVuY3Rpb24oIGFyciApe1xuICBhcnIuc3BsaWNlKCAwLCBhcnIubGVuZ3RoICk7XG59O1xuXG51dGlsLnB1c2ggPSBmdW5jdGlvbiggYXJyICl7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYXJyLCBhcmdzICk7XG59O1xuXG51dGlsLmdldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiggb2JqLCBwcm9wTmFtZSwgcHJlZml4ICl7XG4gIGlmKCBwcmVmaXggKXtcbiAgICBwcm9wTmFtZSA9IHRoaXMucHJlcGVuZENhbWVsKCBwcmVmaXgsIHByb3BOYW1lICk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgcmV0dXJuIG9ialsgcHJvcE5hbWUgXTtcbn07XG5cbnV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICl7XG4gIGlmKCBwcmVmaXggKXtcbiAgICBwcm9wTmFtZSA9IHRoaXMucHJlcGVuZENhbWVsKCBwcmVmaXgsIHByb3BOYW1lICk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqWyBwcm9wTmFtZSBdID0gdmFsdWU7XG59O1xuXG51dGlsLmdldEluZGV4ZWRTdHlsZSA9IGZ1bmN0aW9uKCBub2RlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4ICl7XG4gIHZhciBwc3R5bGUgPSBub2RlLnBzdHlsZSggcHJvcGVydHkgKVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBub2RlLmN5KCkuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkoIHByb3BlcnR5IClbc3VicHJvcGVydHldWzBdO1xufTtcblxuW1xuICByZXF1aXJlKCAnLi9jb2xvcnMnICksXG4gIHJlcXVpcmUoICcuL21hcHMnICksXG4gIHsgbWVtb2l6ZTogcmVxdWlyZSggJy4vbWVtb2l6ZScgKSB9LFxuICByZXF1aXJlKCAnLi9yZWdleCcgKSxcbiAgcmVxdWlyZSggJy4vc3RyaW5ncycgKSxcbiAgcmVxdWlyZSggJy4vdGltaW5nJyApLFxuICByZXF1aXJlKCAnLi9zb3J0JyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCByZXEgKXtcbiAgdXRpbC5leHRlbmQoIHV0aWwsIHJlcSApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGhhcyBhbnl0aGluZyBiZWVuIHNldCBpbiB0aGUgbWFwXG4gIG1hcEVtcHR5OiBmdW5jdGlvbiggbWFwICl7XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcblxuICAgIGlmKCBtYXAgIT0gbnVsbCApe1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKCBtYXAgKS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtcHR5O1xuICB9LFxuXG4gIC8vIHB1c2hlcyB0byB0aGUgYXJyYXkgYXQgdGhlIGVuZCBvZiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gIHB1c2hNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5nZXRNYXAoIG9wdGlvbnMgKTtcblxuICAgIGlmKCBhcnJheSA9PSBudWxsICl7IC8vIGlmIGVtcHR5LCBwdXQgaW5pdGlhbCBhcnJheVxuICAgICAgdGhpcy5zZXRNYXAoIHRoaXMuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgICB2YWx1ZTogWyBvcHRpb25zLnZhbHVlIF1cbiAgICAgIH0gKSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheS5wdXNoKCBvcHRpb25zLnZhbHVlICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgc2V0TWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5O1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGtleSA9IGtleXNbIGkgXTtcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICB0aGlzLmVycm9yKCAnVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpIDwga2V5cy5sZW5ndGggLSAxICl7XG5cbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmKCBvYmpbIGtleSBdID09IG51bGwgKXtcbiAgICAgICAgICBvYmpbIGtleSBdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmpbIGtleSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICBvYmpbIGtleSBdID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcbiAgZ2V0TWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBrZXkgPSBrZXlzWyBpIF07XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgdGhpcy5lcnJvciggJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5JyApO1xuICAgICAgfVxuXG4gICAgICBvYmogPSBvYmpbIGtleSBdO1xuXG4gICAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcbiAgZGVsZXRlTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBrZWVwQ2hpbGRyZW4gPSBvcHRpb25zLmtlZXBDaGlsZHJlbjtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIga2V5ID0ga2V5c1sgaSBdO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgIHRoaXMuZXJyb3IoICdUcmllZCB0byBkZWxldGUgbWFwIHdpdGggb2JqZWN0IGtleScgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RLZXkgPSBpID09PSBvcHRpb25zLmtleXMubGVuZ3RoIC0gMTtcbiAgICAgIGlmKCBsYXN0S2V5ICl7XG5cbiAgICAgICAgaWYoIGtlZXBDaGlsZHJlbiApeyAvLyB0aGVuIG9ubHkgZGVsZXRlIGNoaWxkIGZpZWxkcyBub3QgaW4ga2VlcENoaWxkcmVuXG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gT2JqZWN0LmtleXMoIG9iaiApO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bal07XG5cbiAgICAgICAgICAgIGlmKCAha2VlcENoaWxkcmVuWyBjaGlsZCBdICl7XG4gICAgICAgICAgICAgIG9ialsgY2hpbGQgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBvYmpbIGtleSBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZW1vaXplKCBmbiwga2V5Rm4gKXtcbiAgaWYoICFrZXlGbiApe1xuICAgIGtleUZuID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICl7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBhcmdzLnB1c2goIGFyZ3VtZW50c1sgaSBdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmdzLmpvaW4oICckJyApO1xuICAgIH07XG4gIH1cblxuICB2YXIgbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseSggc2VsZiwgYXJncyApO1xuICAgIHZhciBjYWNoZSA9IG1lbW9pemVkRm4uY2FjaGU7XG5cbiAgICBpZiggIShyZXQgPSBjYWNoZVsgayBdKSApe1xuICAgICAgcmV0ID0gY2FjaGVbIGsgXSA9IGZuLmFwcGx5KCBzZWxmLCBhcmdzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBtZW1vaXplZEZuLmNhY2hlID0ge307XG5cbiAgcmV0dXJuIG1lbW9pemVkRm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVyID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xuXG52YXIgcmdiYSA9ICdyZ2JbYV0/XFxcXCgoJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgcmdiYU5vQmFja1JlZnMgPSAncmdiW2FdP1xcXFwoKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG5cbnZhciBoc2xhID0gJ2hzbFthXT9cXFxcKCgnICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciBoc2xhTm9CYWNrUmVmcyA9ICdoc2xbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcblxudmFyIGhleDMgPSAnXFxcXCNbMC05YS1mQS1GXXszfSc7XG52YXIgaGV4NiA9ICdcXFxcI1swLTlhLWZBLUZdezZ9JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZ2V4OiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgcmdiYTogcmdiYSxcbiAgICByZ2JhTm9CYWNrUmVmczogcmdiYU5vQmFja1JlZnMsXG4gICAgaHNsYTogaHNsYSxcbiAgICBoc2xhTm9CYWNrUmVmczogaHNsYU5vQmFja1JlZnMsXG4gICAgaGV4MzogaGV4MyxcbiAgICBoZXg2OiBoZXg2XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBhc2NlbmRpbmcoIGEsIGIgKXtcbiAgaWYoIGEgPCBiICl7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYoIGEgPiBiICl7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyggYSwgYiApe1xuICByZXR1cm4gLTEgKiBhc2NlbmRpbmcoIGEsIGIgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNvcnQ6IHtcbiAgICBhc2NlbmRpbmc6IGFzY2VuZGluZyxcbiAgICBkZXNjZW5kaW5nOiBkZXNjZW5kaW5nXG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtZW1vaXplID0gcmVxdWlyZSggJy4vbWVtb2l6ZScgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgY2FtZWwyZGFzaDogbWVtb2l6ZSggZnVuY3Rpb24oIHN0ciApe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSggLyhbQS1aXSkvZywgZnVuY3Rpb24oIHYgKXtcbiAgICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gICAgfSApO1xuICB9ICksXG5cbiAgZGFzaDJjYW1lbDogbWVtb2l6ZSggZnVuY3Rpb24oIHN0ciApe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSggLygtXFx3KS9nLCBmdW5jdGlvbiggdiApe1xuICAgICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9ICk7XG4gIH0gKSxcblxuICBwcmVwZW5kQ2FtZWw6IG1lbW9pemUoIGZ1bmN0aW9uKCBwcmVmaXgsIHN0ciApe1xuICAgIHJldHVybiBwcmVmaXggKyBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gIH0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN0ciApe1xuICAgIHJldHVybiBwcmVmaXggKyAnJCcgKyBzdHI7XG4gIH0gKSxcblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiggc3RyICl7XG4gICAgaWYoIGlzLmVtcHR5U3RyaW5nKCBzdHIgKSApe1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG4gIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoICcuLi93aW5kb3cnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cgPyB3aW5kb3cucGVyZm9ybWFuY2UgOiBudWxsO1xuXG52YXIgdXRpbCA9IHt9O1xuXG52YXIgcmFmID0gIXdpbmRvdyA/IGZ1bmN0aW9uKCBmbiApe1xuICBpZiggZm4gKXtcbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgZm4oIHBub3coKSApO1xuICAgIH0sIDEwMDAgLyA2MCApO1xuICB9XG59IDogKGZ1bmN0aW9uKCl7XG4gIGlmKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBmbiApeyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmbiApOyB9O1xuICB9IGVsc2UgaWYoIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuICl7IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZuICk7IH07XG4gIH0gZWxzZSBpZiggd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSApe1xuICAgIHJldHVybiBmdW5jdGlvbiggZm4gKXsgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSggZm4gKTsgfTtcbiAgfSBlbHNlIGlmKCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuICl7IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSggZm4gKTsgfTtcbiAgfVxufSkoKTtcblxudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggZm4gKXtcbiAgcmFmKCBmbiApO1xufTtcblxudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbigpeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH0gOiBmdW5jdGlvbigpeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcblxudXRpbC5wZXJmb3JtYW5jZU5vdyA9IHBub3c7XG5cbi8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbnV0aWwudGhyb3R0bGUgPSBmdW5jdGlvbiggZnVuYywgd2FpdCwgb3B0aW9ucyApe1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYoIG9wdGlvbnMgPT09IGZhbHNlICl7XG4gICAgbGVhZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICBvcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgcmV0dXJuIHV0aWwuZGVib3VuY2UoIGZ1bmMsIHdhaXQsIG9wdGlvbnMgKTtcbn07XG5cbnV0aWwubm93ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuXG51dGlsLmRlYm91bmNlID0gZnVuY3Rpb24oIGZ1bmMsIHdhaXQsIG9wdGlvbnMgKXsgLy8gcG9ydGVkIGxvZGFzaCBkZWJvdW5jZSBmdW5jdGlvblxuICB2YXIgdXRpbCA9IHRoaXM7XG4gIHZhciBhcmdzLFxuICAgICAgbWF4VGltZW91dElkLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhbXAsXG4gICAgICB0aGlzQXJnLFxuICAgICAgdGltZW91dElkLFxuICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYoICFpcy5mbiggZnVuYyApICl7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhaXQgPSBNYXRoLm1heCggMCwgd2FpdCApIHx8IDA7XG4gIGlmKCBvcHRpb25zID09PSB0cnVlICl7XG4gICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChNYXRoLm1heCggd2FpdCwgb3B0aW9ucy5tYXhXYWl0ICkgfHwgMCk7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpe1xuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKHV0aWwubm93KCkgLSBzdGFtcCk7XG4gICAgaWYoIHJlbWFpbmluZyA8PSAwICl7XG4gICAgICBpZiggbWF4VGltZW91dElkICl7XG4gICAgICAgIGNsZWFyVGltZW91dCggbWF4VGltZW91dElkICk7XG4gICAgICB9XG4gICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiggaXNDYWxsZWQgKXtcbiAgICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXNBcmcsIGFyZ3MgKTtcbiAgICAgICAgaWYoICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCApe1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCBkZWxheWVkLCByZW1haW5pbmcgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aW1lb3V0SWQgKXtcbiAgICAgIGNsZWFyVGltZW91dCggdGltZW91dElkICk7XG4gICAgfVxuICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICBpZiggdHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpICl7XG4gICAgICBsYXN0Q2FsbGVkID0gdXRpbC5ub3coKTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXNBcmcsIGFyZ3MgKTtcbiAgICAgIGlmKCAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQgKXtcbiAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN0YW1wID0gdXRpbC5ub3coKTtcbiAgICB0aGlzQXJnID0gdGhpcztcbiAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgIGlmKCBtYXhXYWl0ID09PSBmYWxzZSApe1xuICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiggIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZyApe1xuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICB9XG4gICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgIGlmKCBpc0NhbGxlZCApe1xuICAgICAgICBpZiggbWF4VGltZW91dElkICl7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KCBtYXhUaW1lb3V0SWQgKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXNBcmcsIGFyZ3MgKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoICFtYXhUaW1lb3V0SWQgKXtcbiAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dCggbWF4RGVsYXllZCwgcmVtYWluaW5nICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCBpc0NhbGxlZCAmJiB0aW1lb3V0SWQgKXtcbiAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCggdGltZW91dElkICk7XG4gICAgfVxuICAgIGVsc2UgaWYoICF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCApe1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCggZGVsYXllZCwgd2FpdCApO1xuICAgIH1cbiAgICBpZiggbGVhZGluZ0NhbGwgKXtcbiAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXNBcmcsIGFyZ3MgKTtcbiAgICB9XG4gICAgaWYoIGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCApe1xuICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjIuNy4xNFwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHR5cGVvZiBrZXkgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRnVsbF0gU3BlY2lmeSBhIGNsb25lIGluY2x1ZGluZyBzeW1ib2xzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIGlmIChpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lT2JqZWN0KGlzRnVuYyA/IHt9IDogdmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKCFpc0Fycikge1xuICAgIHZhciBwcm9wcyA9IGlzRnVsbCA/IGdldEFsbEtleXModmFsdWUpIDoga2V5cyh2YWx1ZSk7XG4gIH1cbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKSB7XG4gIHJldHVybiBpc09iamVjdChwcm90bykgPyBvYmplY3RDcmVhdGUocHJvdG8pIDoge307XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKSkge1xuICAgIHZhciBwcm9wcyA9IGJhc2VLZXlzSW4oc291cmNlKTtcbiAgfVxuICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzcmNWYWx1ZTtcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgKHNyY0luZGV4ICYmIGlzRnVuY3Rpb24ob2JqVmFsdWUpKSkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGJhc2VDbG9uZShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgdHJ1ZSkgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgbWVyZ2VEZWZhdWx0cywgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAqL1xudmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgYXJncy5wdXNoKHVuZGVmaW5lZCwgbWVyZ2VEZWZhdWx0cyk7XG4gIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2V2ZW4gYXJndW1lbnRzOlxuICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICpcbiAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICovXG52YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0c0RlZXA7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSl7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBuZXh0OmNhbnQgdGVzdCovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgcm9vdC5vYmplY3RQYXRoID0gZmFjdG9yeSgpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgaWYob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvL3RvIGhhbmRsZSBvYmplY3RzIHdpdGggbnVsbCBwcm90b3R5cGVzICh0b28gZWRnZSBjYXNlPylcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpe1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB0b1N0cmluZyh0eXBlKXtcbiAgICByZXR1cm4gdG9TdHIuY2FsbCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iail7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gIH1cblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKXtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBuZXh0OmNhbnQgdGVzdCovXG4gICAgcmV0dXJuIHRvU3RyLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbihvYmope1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicgfHwgdG9TdHJpbmcob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0S2V5KGtleSl7XG4gICAgdmFyIGludEtleSA9IHBhcnNlSW50KGtleSk7XG4gICAgaWYgKGludEtleS50b1N0cmluZygpID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbnRLZXk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICBmdW5jdGlvbiBmYWN0b3J5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgdmFyIG9iamVjdFBhdGggPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3RQYXRoKS5yZWR1Y2UoZnVuY3Rpb24ocHJveHksIHByb3ApIHtcbiAgICAgICAgaWYocHJvcCA9PT0gJ2NyZWF0ZScpIHtcbiAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH1cblxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbHNlKi9cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RQYXRoW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJveHlbcHJvcF0gPSBvYmplY3RQYXRoW3Byb3BdLmJpbmQob2JqZWN0UGF0aCwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgIH0sIHt9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFzU2hhbGxvd1Byb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgICAgcmV0dXJuIChvcHRpb25zLmluY2x1ZGVJbmhlcml0ZWRQcm9wcyB8fCAodHlwZW9mIHByb3AgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkob2JqKSkgfHwgaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFsbG93UHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgICBpZiAoaGFzU2hhbGxvd1Byb3BlcnR5KG9iaiwgcHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQob2JqLCBwYXRoLCB2YWx1ZSwgZG9Ob3RSZXBsYWNlKXtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0aCB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc2V0KG9iaiwgcGF0aC5zcGxpdCgnLicpLm1hcChnZXRLZXkpLCB2YWx1ZSwgZG9Ob3RSZXBsYWNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50UGF0aCA9IHBhdGhbMF07XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0U2hhbGxvd1Byb3BlcnR5KG9iaiwgY3VycmVudFBhdGgpO1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09IHZvaWQgMCB8fCAhZG9Ob3RSZXBsYWNlKSB7XG4gICAgICAgICAgb2JqW2N1cnJlbnRQYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAvL2NoZWNrIGlmIHdlIGFzc3VtZSBhbiBhcnJheVxuICAgICAgICBpZih0eXBlb2YgcGF0aFsxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvYmpbY3VycmVudFBhdGhdID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW2N1cnJlbnRQYXRoXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQob2JqW2N1cnJlbnRQYXRoXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUsIGRvTm90UmVwbGFjZSk7XG4gICAgfVxuXG4gICAgb2JqZWN0UGF0aC5oYXMgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhdGggfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICEhb2JqO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGogPSBnZXRLZXkocGF0aFtpXSk7XG5cbiAgICAgICAgaWYoKHR5cGVvZiBqID09PSAnbnVtYmVyJyAmJiBpc0FycmF5KG9iaikgJiYgaiA8IG9iai5sZW5ndGgpIHx8XG4gICAgICAgICAgKG9wdGlvbnMuaW5jbHVkZUluaGVyaXRlZFByb3BzID8gKGogaW4gT2JqZWN0KG9iaikpIDogaGFzT3duUHJvcGVydHkob2JqLCBqKSkpIHtcbiAgICAgICAgICBvYmogPSBvYmpbal07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBvYmplY3RQYXRoLmVuc3VyZUV4aXN0cyA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKXtcbiAgICAgIHJldHVybiBzZXQob2JqLCBwYXRoLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIG9iamVjdFBhdGguc2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUsIGRvTm90UmVwbGFjZSl7XG4gICAgICByZXR1cm4gc2V0KG9iaiwgcGF0aCwgdmFsdWUsIGRvTm90UmVwbGFjZSk7XG4gICAgfTtcblxuICAgIG9iamVjdFBhdGguaW5zZXJ0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUsIGF0KXtcbiAgICAgIHZhciBhcnIgPSBvYmplY3RQYXRoLmdldChvYmosIHBhdGgpO1xuICAgICAgYXQgPSB+fmF0O1xuICAgICAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICAgICAgYXJyID0gW107XG4gICAgICAgIG9iamVjdFBhdGguc2V0KG9iaiwgcGF0aCwgYXJyKTtcbiAgICAgIH1cbiAgICAgIGFyci5zcGxpY2UoYXQsIDAsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgb2JqZWN0UGF0aC5lbXB0eSA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgICAgaWYgKGlzRW1wdHkocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUsIGk7XG4gICAgICBpZiAoISh2YWx1ZSA9IG9iamVjdFBhdGguZ2V0KG9iaiwgcGF0aCkpKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RQYXRoLnNldChvYmosIHBhdGgsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0UGF0aC5zZXQob2JqLCBwYXRoLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFBhdGguc2V0KG9iaiwgcGF0aCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmxlbmd0aCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAoaGFzU2hhbGxvd1Byb3BlcnR5KHZhbHVlLCBpKSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFBhdGguc2V0KG9iaiwgcGF0aCwgbnVsbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG9iamVjdFBhdGgucHVzaCA9IGZ1bmN0aW9uIChvYmosIHBhdGggLyosIHZhbHVlcyAqLyl7XG4gICAgICB2YXIgYXJyID0gb2JqZWN0UGF0aC5nZXQob2JqLCBwYXRoKTtcbiAgICAgIGlmICghaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGFyciA9IFtdO1xuICAgICAgICBvYmplY3RQYXRoLnNldChvYmosIHBhdGgsIGFycik7XG4gICAgICB9XG5cbiAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfTtcblxuICAgIG9iamVjdFBhdGguY29hbGVzY2UgPSBmdW5jdGlvbiAob2JqLCBwYXRocywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKHZhbHVlID0gb2JqZWN0UGF0aC5nZXQob2JqLCBwYXRoc1tpXSkpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuXG4gICAgb2JqZWN0UGF0aC5nZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBkZWZhdWx0VmFsdWUpe1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXRoID0gW3BhdGhdO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXRoIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFBhdGguZ2V0KG9iaiwgcGF0aC5zcGxpdCgnLicpLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFBhdGggPSBnZXRLZXkocGF0aFswXSk7XG4gICAgICB2YXIgbmV4dE9iaiA9IGdldFNoYWxsb3dQcm9wZXJ0eShvYmosIGN1cnJlbnRQYXRoKVxuICAgICAgaWYgKG5leHRPYmogPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5leHRPYmo7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3RQYXRoLmdldChvYmpbY3VycmVudFBhdGhdLCBwYXRoLnNsaWNlKDEpLCBkZWZhdWx0VmFsdWUpO1xuICAgIH07XG5cbiAgICBvYmplY3RQYXRoLmRlbCA9IGZ1bmN0aW9uIGRlbChvYmosIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VtcHR5KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgICBpZih0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFBhdGguZGVsKG9iaiwgcGF0aC5zcGxpdCgnLicpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRQYXRoID0gZ2V0S2V5KHBhdGhbMF0pO1xuICAgICAgaWYgKCFoYXNTaGFsbG93UHJvcGVydHkob2JqLCBjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cblxuICAgICAgaWYocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgIG9iai5zcGxpY2UoY3VycmVudFBhdGgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbY3VycmVudFBhdGhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqZWN0UGF0aC5kZWwob2JqW2N1cnJlbnRQYXRoXSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFBhdGg7XG4gIH1cblxuICB2YXIgbW9kID0gZmFjdG9yeSgpO1xuICBtb2QuY3JlYXRlID0gZmFjdG9yeTtcbiAgbW9kLndpdGhJbmhlcml0ZWRQcm9wcyA9IGZhY3Rvcnkoe2luY2x1ZGVJbmhlcml0ZWRQcm9wczogdHJ1ZX0pXG4gIHJldHVybiBtb2Q7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyBjaGFyYWN0ZXIgY2xhc3NlcyBhbmQgdG9rZW5zXG4gIHZhciB3aGl0ZXNwYWNlID0gJ1xcclxcblxcdCAnXG5cbiAgLy8gdGhpcyByZWFsbHkgbmVlZHMgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAgLy8gWE1MIGFsbG93cyBhbGwgbWFubmVyIG9mIHJpZGljdWxvdXMgbnVtYmVycyBhbmQgZGlnaXRzLlxuXG4gIC8vIChMZXR0ZXIgfCBcIl9cIiB8IFwiOlwiKVxuICB2YXIgcXVvdGUgPSAnXFwnXCInXG4gIHZhciBhdHRyaWJFbmQgPSB3aGl0ZXNwYWNlICsgJz4nXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gdHVybiBhbGwgdGhlIHN0cmluZyBjaGFyYWN0ZXIgc2V0cyBpbnRvIGNoYXJhY3RlciBjbGFzcyBvYmplY3RzLlxuICB3aGl0ZXNwYWNlID0gY2hhckNsYXNzKHdoaXRlc3BhY2UpXG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgcXVvdGUgPSBjaGFyQ2xhc3MocXVvdGUpXG4gIGF0dHJpYkVuZCA9IGNoYXJDbGFzcyhhdHRyaWJFbmQpXG5cbiAgZnVuY3Rpb24gY2hhckNsYXNzIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHMsIGMpIHtcbiAgICAgIHNbY10gPSB0cnVlXG4gICAgICByZXR1cm4gc1xuICAgIH0sIHt9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gcmVnZXgudGVzdChjKVxuICB9XG5cbiAgZnVuY3Rpb24gaXMgKGNoYXJjbGFzcywgYykge1xuICAgIHJldHVybiBjaGFyY2xhc3NbY11cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdE1hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiAhaXNNYXRjaChyZWdleCwgYylcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdCAoY2hhcmNsYXNzLCBjKSB7XG4gICAgcmV0dXJuICFpcyhjaGFyY2xhc3MsIGMpXG4gIH1cblxuICB2YXIgUyA9IDBcbiAgc2F4LlNUQVRFID0ge1xuICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgIFNDUklQVF9FTkRJTkc6IFMrKyAvLyA8c2NyaXB0PiAuLi4gPFxuICB9XG5cbiAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCJcbiAgfVxuXG4gIHNheC5FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCIsXG4gICAgJ0FFbGlnJzogMTk4LFxuICAgICdBYWN1dGUnOiAxOTMsXG4gICAgJ0FjaXJjJzogMTk0LFxuICAgICdBZ3JhdmUnOiAxOTIsXG4gICAgJ0FyaW5nJzogMTk3LFxuICAgICdBdGlsZGUnOiAxOTUsXG4gICAgJ0F1bWwnOiAxOTYsXG4gICAgJ0NjZWRpbCc6IDE5OSxcbiAgICAnRVRIJzogMjA4LFxuICAgICdFYWN1dGUnOiAyMDEsXG4gICAgJ0VjaXJjJzogMjAyLFxuICAgICdFZ3JhdmUnOiAyMDAsXG4gICAgJ0V1bWwnOiAyMDMsXG4gICAgJ0lhY3V0ZSc6IDIwNSxcbiAgICAnSWNpcmMnOiAyMDYsXG4gICAgJ0lncmF2ZSc6IDIwNCxcbiAgICAnSXVtbCc6IDIwNyxcbiAgICAnTnRpbGRlJzogMjA5LFxuICAgICdPYWN1dGUnOiAyMTEsXG4gICAgJ09jaXJjJzogMjEyLFxuICAgICdPZ3JhdmUnOiAyMTAsXG4gICAgJ09zbGFzaCc6IDIxNixcbiAgICAnT3RpbGRlJzogMjEzLFxuICAgICdPdW1sJzogMjE0LFxuICAgICdUSE9STic6IDIyMixcbiAgICAnVWFjdXRlJzogMjE4LFxuICAgICdVY2lyYyc6IDIxOSxcbiAgICAnVWdyYXZlJzogMjE3LFxuICAgICdVdW1sJzogMjIwLFxuICAgICdZYWN1dGUnOiAyMjEsXG4gICAgJ2FhY3V0ZSc6IDIyNSxcbiAgICAnYWNpcmMnOiAyMjYsXG4gICAgJ2FlbGlnJzogMjMwLFxuICAgICdhZ3JhdmUnOiAyMjQsXG4gICAgJ2FyaW5nJzogMjI5LFxuICAgICdhdGlsZGUnOiAyMjcsXG4gICAgJ2F1bWwnOiAyMjgsXG4gICAgJ2NjZWRpbCc6IDIzMSxcbiAgICAnZWFjdXRlJzogMjMzLFxuICAgICdlY2lyYyc6IDIzNCxcbiAgICAnZWdyYXZlJzogMjMyLFxuICAgICdldGgnOiAyNDAsXG4gICAgJ2V1bWwnOiAyMzUsXG4gICAgJ2lhY3V0ZSc6IDIzNyxcbiAgICAnaWNpcmMnOiAyMzgsXG4gICAgJ2lncmF2ZSc6IDIzNixcbiAgICAnaXVtbCc6IDIzOSxcbiAgICAnbnRpbGRlJzogMjQxLFxuICAgICdvYWN1dGUnOiAyNDMsXG4gICAgJ29jaXJjJzogMjQ0LFxuICAgICdvZ3JhdmUnOiAyNDIsXG4gICAgJ29zbGFzaCc6IDI0OCxcbiAgICAnb3RpbGRlJzogMjQ1LFxuICAgICdvdW1sJzogMjQ2LFxuICAgICdzemxpZyc6IDIyMyxcbiAgICAndGhvcm4nOiAyNTQsXG4gICAgJ3VhY3V0ZSc6IDI1MCxcbiAgICAndWNpcmMnOiAyNTEsXG4gICAgJ3VncmF2ZSc6IDI0OSxcbiAgICAndXVtbCc6IDI1MixcbiAgICAneWFjdXRlJzogMjUzLFxuICAgICd5dW1sJzogMjU1LFxuICAgICdjb3B5JzogMTY5LFxuICAgICdyZWcnOiAxNzQsXG4gICAgJ25ic3AnOiAxNjAsXG4gICAgJ2lleGNsJzogMTYxLFxuICAgICdjZW50JzogMTYyLFxuICAgICdwb3VuZCc6IDE2MyxcbiAgICAnY3VycmVuJzogMTY0LFxuICAgICd5ZW4nOiAxNjUsXG4gICAgJ2JydmJhcic6IDE2NixcbiAgICAnc2VjdCc6IDE2NyxcbiAgICAndW1sJzogMTY4LFxuICAgICdvcmRmJzogMTcwLFxuICAgICdsYXF1byc6IDE3MSxcbiAgICAnbm90JzogMTcyLFxuICAgICdzaHknOiAxNzMsXG4gICAgJ21hY3InOiAxNzUsXG4gICAgJ2RlZyc6IDE3NixcbiAgICAncGx1c21uJzogMTc3LFxuICAgICdzdXAxJzogMTg1LFxuICAgICdzdXAyJzogMTc4LFxuICAgICdzdXAzJzogMTc5LFxuICAgICdhY3V0ZSc6IDE4MCxcbiAgICAnbWljcm8nOiAxODEsXG4gICAgJ3BhcmEnOiAxODIsXG4gICAgJ21pZGRvdCc6IDE4MyxcbiAgICAnY2VkaWwnOiAxODQsXG4gICAgJ29yZG0nOiAxODYsXG4gICAgJ3JhcXVvJzogMTg3LFxuICAgICdmcmFjMTQnOiAxODgsXG4gICAgJ2ZyYWMxMic6IDE4OSxcbiAgICAnZnJhYzM0JzogMTkwLFxuICAgICdpcXVlc3QnOiAxOTEsXG4gICAgJ3RpbWVzJzogMjE1LFxuICAgICdkaXZpZGUnOiAyNDcsXG4gICAgJ09FbGlnJzogMzM4LFxuICAgICdvZWxpZyc6IDMzOSxcbiAgICAnU2Nhcm9uJzogMzUyLFxuICAgICdzY2Fyb24nOiAzNTMsXG4gICAgJ1l1bWwnOiAzNzYsXG4gICAgJ2Zub2YnOiA0MDIsXG4gICAgJ2NpcmMnOiA3MTAsXG4gICAgJ3RpbGRlJzogNzMyLFxuICAgICdBbHBoYSc6IDkxMyxcbiAgICAnQmV0YSc6IDkxNCxcbiAgICAnR2FtbWEnOiA5MTUsXG4gICAgJ0RlbHRhJzogOTE2LFxuICAgICdFcHNpbG9uJzogOTE3LFxuICAgICdaZXRhJzogOTE4LFxuICAgICdFdGEnOiA5MTksXG4gICAgJ1RoZXRhJzogOTIwLFxuICAgICdJb3RhJzogOTIxLFxuICAgICdLYXBwYSc6IDkyMixcbiAgICAnTGFtYmRhJzogOTIzLFxuICAgICdNdSc6IDkyNCxcbiAgICAnTnUnOiA5MjUsXG4gICAgJ1hpJzogOTI2LFxuICAgICdPbWljcm9uJzogOTI3LFxuICAgICdQaSc6IDkyOCxcbiAgICAnUmhvJzogOTI5LFxuICAgICdTaWdtYSc6IDkzMSxcbiAgICAnVGF1JzogOTMyLFxuICAgICdVcHNpbG9uJzogOTMzLFxuICAgICdQaGknOiA5MzQsXG4gICAgJ0NoaSc6IDkzNSxcbiAgICAnUHNpJzogOTM2LFxuICAgICdPbWVnYSc6IDkzNyxcbiAgICAnYWxwaGEnOiA5NDUsXG4gICAgJ2JldGEnOiA5NDYsXG4gICAgJ2dhbW1hJzogOTQ3LFxuICAgICdkZWx0YSc6IDk0OCxcbiAgICAnZXBzaWxvbic6IDk0OSxcbiAgICAnemV0YSc6IDk1MCxcbiAgICAnZXRhJzogOTUxLFxuICAgICd0aGV0YSc6IDk1MixcbiAgICAnaW90YSc6IDk1MyxcbiAgICAna2FwcGEnOiA5NTQsXG4gICAgJ2xhbWJkYSc6IDk1NSxcbiAgICAnbXUnOiA5NTYsXG4gICAgJ251JzogOTU3LFxuICAgICd4aSc6IDk1OCxcbiAgICAnb21pY3Jvbic6IDk1OSxcbiAgICAncGknOiA5NjAsXG4gICAgJ3Jobyc6IDk2MSxcbiAgICAnc2lnbWFmJzogOTYyLFxuICAgICdzaWdtYSc6IDk2MyxcbiAgICAndGF1JzogOTY0LFxuICAgICd1cHNpbG9uJzogOTY1LFxuICAgICdwaGknOiA5NjYsXG4gICAgJ2NoaSc6IDk2NyxcbiAgICAncHNpJzogOTY4LFxuICAgICdvbWVnYSc6IDk2OSxcbiAgICAndGhldGFzeW0nOiA5NzcsXG4gICAgJ3Vwc2loJzogOTc4LFxuICAgICdwaXYnOiA5ODIsXG4gICAgJ2Vuc3AnOiA4MTk0LFxuICAgICdlbXNwJzogODE5NSxcbiAgICAndGhpbnNwJzogODIwMSxcbiAgICAnenduaic6IDgyMDQsXG4gICAgJ3p3aic6IDgyMDUsXG4gICAgJ2xybSc6IDgyMDYsXG4gICAgJ3JsbSc6IDgyMDcsXG4gICAgJ25kYXNoJzogODIxMSxcbiAgICAnbWRhc2gnOiA4MjEyLFxuICAgICdsc3F1byc6IDgyMTYsXG4gICAgJ3JzcXVvJzogODIxNyxcbiAgICAnc2JxdW8nOiA4MjE4LFxuICAgICdsZHF1byc6IDgyMjAsXG4gICAgJ3JkcXVvJzogODIyMSxcbiAgICAnYmRxdW8nOiA4MjIyLFxuICAgICdkYWdnZXInOiA4MjI0LFxuICAgICdEYWdnZXInOiA4MjI1LFxuICAgICdidWxsJzogODIyNixcbiAgICAnaGVsbGlwJzogODIzMCxcbiAgICAncGVybWlsJzogODI0MCxcbiAgICAncHJpbWUnOiA4MjQyLFxuICAgICdQcmltZSc6IDgyNDMsXG4gICAgJ2xzYXF1byc6IDgyNDksXG4gICAgJ3JzYXF1byc6IDgyNTAsXG4gICAgJ29saW5lJzogODI1NCxcbiAgICAnZnJhc2wnOiA4MjYwLFxuICAgICdldXJvJzogODM2NCxcbiAgICAnaW1hZ2UnOiA4NDY1LFxuICAgICd3ZWllcnAnOiA4NDcyLFxuICAgICdyZWFsJzogODQ3NixcbiAgICAndHJhZGUnOiA4NDgyLFxuICAgICdhbGVmc3ltJzogODUwMSxcbiAgICAnbGFycic6IDg1OTIsXG4gICAgJ3VhcnInOiA4NTkzLFxuICAgICdyYXJyJzogODU5NCxcbiAgICAnZGFycic6IDg1OTUsXG4gICAgJ2hhcnInOiA4NTk2LFxuICAgICdjcmFycic6IDg2MjksXG4gICAgJ2xBcnInOiA4NjU2LFxuICAgICd1QXJyJzogODY1NyxcbiAgICAnckFycic6IDg2NTgsXG4gICAgJ2RBcnInOiA4NjU5LFxuICAgICdoQXJyJzogODY2MCxcbiAgICAnZm9yYWxsJzogODcwNCxcbiAgICAncGFydCc6IDg3MDYsXG4gICAgJ2V4aXN0JzogODcwNyxcbiAgICAnZW1wdHknOiA4NzA5LFxuICAgICduYWJsYSc6IDg3MTEsXG4gICAgJ2lzaW4nOiA4NzEyLFxuICAgICdub3Rpbic6IDg3MTMsXG4gICAgJ25pJzogODcxNSxcbiAgICAncHJvZCc6IDg3MTksXG4gICAgJ3N1bSc6IDg3MjEsXG4gICAgJ21pbnVzJzogODcyMixcbiAgICAnbG93YXN0JzogODcyNyxcbiAgICAncmFkaWMnOiA4NzMwLFxuICAgICdwcm9wJzogODczMyxcbiAgICAnaW5maW4nOiA4NzM0LFxuICAgICdhbmcnOiA4NzM2LFxuICAgICdhbmQnOiA4NzQzLFxuICAgICdvcic6IDg3NDQsXG4gICAgJ2NhcCc6IDg3NDUsXG4gICAgJ2N1cCc6IDg3NDYsXG4gICAgJ2ludCc6IDg3NDcsXG4gICAgJ3RoZXJlNCc6IDg3NTYsXG4gICAgJ3NpbSc6IDg3NjQsXG4gICAgJ2NvbmcnOiA4NzczLFxuICAgICdhc3ltcCc6IDg3NzYsXG4gICAgJ25lJzogODgwMCxcbiAgICAnZXF1aXYnOiA4ODAxLFxuICAgICdsZSc6IDg4MDQsXG4gICAgJ2dlJzogODgwNSxcbiAgICAnc3ViJzogODgzNCxcbiAgICAnc3VwJzogODgzNSxcbiAgICAnbnN1Yic6IDg4MzYsXG4gICAgJ3N1YmUnOiA4ODM4LFxuICAgICdzdXBlJzogODgzOSxcbiAgICAnb3BsdXMnOiA4ODUzLFxuICAgICdvdGltZXMnOiA4ODU1LFxuICAgICdwZXJwJzogODg2OSxcbiAgICAnc2RvdCc6IDg5MDEsXG4gICAgJ2xjZWlsJzogODk2OCxcbiAgICAncmNlaWwnOiA4OTY5LFxuICAgICdsZmxvb3InOiA4OTcwLFxuICAgICdyZmxvb3InOiA4OTcxLFxuICAgICdsYW5nJzogOTAwMSxcbiAgICAncmFuZyc6IDkwMDIsXG4gICAgJ2xveic6IDk2NzQsXG4gICAgJ3NwYWRlcyc6IDk4MjQsXG4gICAgJ2NsdWJzJzogOTgyNyxcbiAgICAnaGVhcnRzJzogOTgyOSxcbiAgICAnZGlhbXMnOiA5ODMwXG4gIH1cblxuICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV1cbiAgICB2YXIgcyA9IHR5cGVvZiBlID09PSAnbnVtYmVyJyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlXG4gICAgc2F4LkVOVElUSUVTW2tleV0gPSBzXG4gIH0pXG5cbiAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHNcbiAgfVxuXG4gIC8vIHNob3J0aGFuZFxuICBTID0gc2F4LlNUQVRFXG5cbiAgZnVuY3Rpb24gZW1pdCAocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdE5vZGUgKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBjbG9zZVRleHQocGFyc2VyKVxuICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGV4dCAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKVxuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGVtaXQocGFyc2VyLCAnb250ZXh0JywgcGFyc2VyLnRleHROb2RlKVxuICAgIHBhcnNlci50ZXh0Tm9kZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0b3B0cyAob3B0LCB0ZXh0KSB7XG4gICAgaWYgKG9wdC50cmltKSB0ZXh0ID0gdGV4dC50cmltKClcbiAgICBpZiAob3B0Lm5vcm1hbGl6ZSkgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yIChwYXJzZXIsIGVyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIGVyICs9ICdcXG5MaW5lOiAnICsgcGFyc2VyLmxpbmUgK1xuICAgICAgICAnXFxuQ29sdW1uOiAnICsgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICdcXG5DaGFyOiAnICsgcGFyc2VyLmNcbiAgICB9XG4gICAgZXIgPSBuZXcgRXJyb3IoZXIpXG4gICAgcGFyc2VyLmVycm9yID0gZXJcbiAgICBlbWl0KHBhcnNlciwgJ29uZXJyb3InLCBlcilcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCAnVW5jbG9zZWQgcm9vdCB0YWcnKVxuICAgIGlmICgocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSkge1xuICAgICAgZXJyb3IocGFyc2VyLCAnVW5leHBlY3RlZCBlbmQnKVxuICAgIH1cbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZVxuICAgIGVtaXQocGFyc2VyLCAnb25lbmQnKVxuICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdClcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RGYWlsIChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gJ29iamVjdCcgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsIHRvIHN0cmljdEZhaWwnKVxuICAgIH1cbiAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1RhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9XG5cbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdGFnLm5zID0gcGFyZW50Lm5zXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWdzdGFydCcsIHRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHFuYW1lIChuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZignOicpXG4gICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbICcnLCBuYW1lIF0gOiBuYW1lLnNwbGl0KCc6JylcbiAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF1cbiAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXVxuXG4gICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgcHJlZml4ID0gJ3htbG5zJ1xuICAgICAgbG9jYWwgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmliIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSlcbiAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsXG5cbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycpIHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgaWYgKGxvY2FsID09PSAneG1sJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gJ3htbG5zJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MTlNfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuVGFnIChwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuXG4gICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSlcbiAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsXG4gICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgJydcblxuICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSlcbiAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeFxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3Blbm5hbWVzcGFjZScsIHtcbiAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV1cbiAgICAgICAgdmFyIG5hbWUgPSBudlswXVxuICAgICAgICB2YXIgdmFsdWUgPSBudlsxXVxuICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKVxuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsXG4gICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09ICcnID8gJycgOiAodGFnLm5zW3ByZWZpeF0gfHwgJycpXG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09ICd4bWxucycgJiYgIXVyaSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpXG4gICAgICAgICAgYS51cmkgPSBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhXG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywgYSlcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICB9XG5cbiAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nXG5cbiAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnJywgcGFyc2VyLnRhZylcbiAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIH1cbiAgICAgIHBhcnNlci50YWcgPSBudWxsXG4gICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdXZWlyZCBlbXB0eSBjbG9zZSB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lXG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZVxuICAgIHdoaWxlICh0LS0pIHtcbiAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdXG4gICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5leHBlY3RlZCBjbG9zZSB0YWcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VubWF0Y2hlZCBjbG9zaW5nIHRhZzogJyArIHBhcnNlci50YWdOYW1lKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKVxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2V0YWcnLCBwYXJzZXIudGFnTmFtZSlcblxuICAgICAgdmFyIHggPSB7fVxuICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgeFtpXSA9IHRhZy5uc1tpXVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdXG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZW5hbWVzcGFjZScsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW50aXR5IChwYXJzZXIpIHtcbiAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eVxuICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIG51bVxuICAgIHZhciBudW1TdHIgPSAnJ1xuXG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV1cbiAgICB9XG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdXG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eUxDXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMilcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNilcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMClcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sICcnKVxuICAgIGlmIChudW1TdHIudG9Mb3dlckNhc2UoKSAhPT0gZW50aXR5KSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGVudGl0eScpXG4gICAgICByZXR1cm4gJyYnICsgcGFyc2VyLmVudGl0eSArICc7J1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChudW0pXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldoaXRlU3BhY2UgKHBhcnNlciwgYykge1xuICAgIGlmIChjID09PSAnPCcpIHtcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgIH0gZWxzZSBpZiAobm90KHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlID0gY1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckF0IChjaHVuaywgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGNodW5rKSB7XG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cbiAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGVycm9yKHBhcnNlcixcbiAgICAgICAgJ0Nhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci4nKVxuICAgIH1cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmQocGFyc2VyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnb2JqZWN0Jykge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBjID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgcGFyc2VyLmMgPSBjXG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRVxuICAgICAgICAgIGlmIChjID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxXG4gICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSAnPCcgJiYgYyAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPCcgJiYgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm90KHdoaXRlc3BhY2UsIGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVDpcbiAgICAgICAgICAvLyBvbmx5IG5vbi1zdHJpY3RcbiAgICAgICAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1dBS0E6XG4gICAgICAgICAgLy8gZWl0aGVyIGEgLywgPywgISwgb3IgdGV4dCBpcyBjb21pbmcgbmV4dC5cbiAgICAgICAgICBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciBpdC4uLlxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmVuY29kZWQgPCcpXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgc29tZSB3aGl0ZXNwYWNlLCB0aGVuIGFkZCB0aGF0IGluLlxuICAgICAgICAgICAgaWYgKHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uICsgMSA8IHBhcnNlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICB2YXIgcGFkID0gcGFyc2VyLnBvc2l0aW9uIC0gcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb25cbiAgICAgICAgICAgICAgYyA9IG5ldyBBcnJheShwYWQpLmpvaW4oJyAnKSArIGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMOlxuICAgICAgICAgIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gQ0RBVEEpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbmNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNnbWxEZWNsICsgYyA9PT0gJy0tJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IERPQ1RZUEUpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgICAgaWYgKHBhcnNlci5kb2N0eXBlIHx8IHBhcnNlci5zYXdSb290KSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgICAgICdJbmFwcHJvcHJpYXRlbHkgbG9jYXRlZCBkb2N0eXBlIGRlY2xhcmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2dtbGRlY2xhcmF0aW9uJywgcGFyc2VyLnNnbWxEZWNsKVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URURcbiAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERfUVVPVEVEXG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVERfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VOREVEXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgaWYgKHBhcnNlci5jb21tZW50KSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY29tbWVudCcsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ01hbGZvcm1lZCBjb21tZW50JylcbiAgICAgICAgICAgIC8vIGFsbG93IDwhLS0gYmxhaCAtLSBibG9vIC0tPiBpbiBub24tc3RyaWN0IG1vZGUsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhIGNvbW1lbnQgb2YgXCIgYmxhaCAtLSBibG9vIFwiXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLS0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdfMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkdfMjpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNkYXRhKSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXV0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1Q6XG4gICAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSAnPycgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIHRhZyBuYW1lJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlciwgdHJ1ZSlcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdGb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+JylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQjpcbiAgICAgICAgICAvLyBoYXZlbid0IHJlYWQgdGhlIGF0dHJpYnV0ZSBuYW1lIHlldC5cbiAgICAgICAgICBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZVxuICAgICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVfU0FXX1dISVRFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ05vIHdoaXRlc3BhY2UgYmV0d2VlbiBhdHRyaWJ1dGVzJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEOlxuICAgICAgICAgIGlmIChub3QoYXR0cmliRW5kLCBjKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90TWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIGNcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdfU0FXX1dISVRFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBR19TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUnKVxuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gJyYnICsgcGFyc2VyLmVudGl0eSArIGNcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgJ1Vua25vd24gc3RhdGU6ICcgKyBwYXJzZXIuc3RhdGUpXG4gICAgICB9XG4gICAgfSAvLyB3aGlsZVxuXG4gICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMFxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW11cbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZVxuICAgICAgICB2YXIgaW5kZXggPSAtMVxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludClcbiAgICAgICAgICB9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDBcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDBcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpXG4gICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiLypqc2xpbnQgbm9kZTp0cnVlICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNhbml0aXplOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIik7XHJcbiAgICB9LFxyXG4gICAgY29weU9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGtleSwgY29weSA9IHt9O1xyXG4gICAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfSxcclxuICAgIGVuc3VyZUZsYWdFeGlzdHM6IGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCEoaXRlbSBpbiBvcHRpb25zKSB8fCB0eXBlb2Ygb3B0aW9uc1tpdGVtXSAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbaXRlbV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZW5zdXJlU3BhY2VzRXhpc3RzOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmICghKCdzcGFjZXMnIGluIG9wdGlvbnMpIHx8ICh0eXBlb2Ygb3B0aW9ucy5zcGFjZXMgIT09ICdudW1iZXInICYmIHR5cGVvZiBvcHRpb25zLnNwYWNlcyAhPT0gJ3N0cmluZycpKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3BhY2VzID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZW5zdXJlS2V5RXhpc3RzOiBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5ICsgJ0tleScgaW4gb3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnNba2V5ICsgJ0tleSddICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvcHRpb25zW2tleSArICdLZXknXSA9IG9wdGlvbnMuY29tcGFjdCA/ICdfJyArIGtleSA6IGtleTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0Q29tbWFuZExpbmVIZWxwOiBmdW5jdGlvbiAoY29tbWFuZCwgcmVxdWlyZWRBcmdzLCBvcHRpb25hbEFyZ3MpIHtcclxuICAgICAgICB2YXIgcmVxQXJncyA9IHJlcXVpcmVkQXJncy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgYXJnKSB7cmV0dXJuIHJlcyArICcgPCcgKyBhcmcuYXJnICsgJz4nO30sICcnKTtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gJ1VzYWdlOiAnICsgY29tbWFuZCArIHJlcUFyZ3MgKyAnIFtvcHRpb25zXScgKyAnXFxuJztcclxuICAgICAgICByZXF1aXJlZEFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9ICcgIDwnICsgYXJndW1lbnQuYXJnICsgJz4nICsgQXJyYXkoMjAgLSBhcmd1bWVudC5hcmcubGVuZ3RoKS5qb2luKCcgJykgKyBhcmd1bWVudC5kZXNjICsgJ1xcbic7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3V0cHV0ICs9ICdcXG5PcHRpb25zOicgKyAnXFxuJztcclxuICAgICAgICBvcHRpb25hbEFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9ICcgIC0tJyArIGFyZ3VtZW50LmFyZyArIEFycmF5KDIwIC0gYXJndW1lbnQuYXJnLmxlbmd0aCkuam9pbignICcpICsgYXJndW1lbnQuZGVzYyArICdcXG4nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgbWFwQ29tbWFuZExpbmVBcmdzOiBmdW5jdGlvbiAocmVxdWlyZWRBcmdzLCBvcHRpb25hbEFyZ3MpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9LCByLCBvLCBhID0gMjtcclxuICAgICAgICBmb3IgKHIgPSAwOyByIDwgcmVxdWlyZWRBcmdzLmxlbmd0aDsgciArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhIDwgcHJvY2Vzcy5hcmd2Lmxlbmd0aCAmJiBwcm9jZXNzLmFyZ3ZbYV0uc3Vic3RyKDAsIDEpICE9PSAnLScgJiYgcHJvY2Vzcy5hcmd2W2FdICE9PSAnSkFTTUlORV9DT05GSUdfUEFUSD0uL2phc21pbmUuanNvbicpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbcmVxdWlyZWRBcmdzW3JdLm9wdGlvbl0gPSBwcm9jZXNzLmFyZ3ZbYSsrXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBhIDwgcHJvY2Vzcy5hcmd2Lmxlbmd0aDsgYSArPSAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBvcHRpb25hbEFyZ3MubGVuZ3RoOyBvICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbEFyZ3Nbb10uYWxpYXMgPT09IHByb2Nlc3MuYXJndlthXS5zbGljZSgxKSB8fCBvcHRpb25hbEFyZ3Nbb10uYXJnID09PSBwcm9jZXNzLmFyZ3ZbYV0uc2xpY2UoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobyA8IG9wdGlvbmFsQXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uYWxBcmdzW29dLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzogY2FzZSAnc3RyaW5nJzogY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgKyAxIDwgcHJvY2Vzcy5hcmd2Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25hbEFyZ3Nbb10ub3B0aW9uXSA9IChvcHRpb25hbEFyZ3Nbb10udHlwZSA9PT0gJ251bWJlcicgPyBOdW1iZXIocHJvY2Vzcy5hcmd2W2FdKSA6IHByb2Nlc3MuYXJndlthXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmxhZyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uYWxBcmdzW29dLm9wdGlvbl0gPSB0cnVlOyBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufTsiLCIvKmpzbGludCBub2RlOnRydWUgKi9cclxuXHJcbnZhciB4bWwyanMgPSByZXF1aXJlKCcuL3htbDJqcycpO1xyXG52YXIgeG1sMmpzb24gPSByZXF1aXJlKCcuL3htbDJqc29uJyk7XHJcbnZhciBqczJ4bWwgPSByZXF1aXJlKCcuL2pzMnhtbCcpO1xyXG52YXIganNvbjJ4bWwgPSByZXF1aXJlKCcuL2pzb24yeG1sJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHhtbDJqczogeG1sMmpzLFxyXG4gICAgeG1sMmpzb246IHhtbDJqc29uLFxyXG4gICAganMyeG1sOiBqczJ4bWwsXHJcbiAgICBqc29uMnhtbDoganNvbjJ4bWxcclxufTsiLCJ2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyAodXNlck9wdGlvbnMpIHtcclxuICAgIHZhciBvcHRpb25zID0gY29tbW9uLmNvcHlPcHRpb25zKHVzZXJPcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCdpZ25vcmVEZWNsYXJhdGlvbicsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2lnbm9yZUF0dHJpYnV0ZXMnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCdpZ25vcmVUZXh0Jywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlRmxhZ0V4aXN0cygnaWdub3JlQ29tbWVudCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2lnbm9yZUNkYXRhJywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlRmxhZ0V4aXN0cygnY29tcGFjdCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2Z1bGxUYWdFbXB0eUVsZW1lbnQnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVTcGFjZXNFeGlzdHMob3B0aW9ucyk7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3BhY2VzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIG9wdGlvbnMuc3BhY2VzID0gQXJyYXkob3B0aW9ucy5zcGFjZXMgKyAxKS5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICBjb21tb24uZW5zdXJlS2V5RXhpc3RzKCdkZWNsYXJhdGlvbicsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygnYXR0cmlidXRlcycsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygndGV4dCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygnY29tbWVudCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygnY2RhdGEnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVLZXlFeGlzdHMoJ3R5cGUnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVLZXlFeGlzdHMoJ25hbWUnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVLZXlFeGlzdHMoJ2VsZW1lbnRzJywgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVJbmRlbnRhdGlvbiAob3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkge1xyXG4gICAgcmV0dXJuICghZmlyc3RMaW5lICYmIG9wdGlvbnMuc3BhY2VzID8gJ1xcbicgOiAnJykgKyBBcnJheShkZXB0aCArIDEpLmpvaW4ob3B0aW9ucy5zcGFjZXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUF0dHJpYnV0ZXMgKGF0dHJpYnV0ZXMpIHtcclxuICAgIHZhciBrZXksIHJlc3VsdCA9ICcnO1xyXG4gICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIGtleSArICc9XCInICsgYXR0cmlidXRlc1trZXldICsgJ1wiJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZURlY2xhcmF0aW9uIChkZWNsYXJhdGlvbiwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuICc8P3htbCcgKyB3cml0ZUF0dHJpYnV0ZXMoZGVjbGFyYXRpb25bb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSkgKyAnPz4nO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUNvbW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBvcHRpb25zLmlnbm9yZUNvbW1lbnQgPyAnJyA6ICc8IS0tJyArIGVsZW1lbnRbb3B0aW9ucy5jb21tZW50S2V5XSArICctLT4nO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUNkYXRhIChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucy5pZ25vcmVDZGF0YSA/ICcnIDogJzwhW0NEQVRBWycgKyBlbGVtZW50W29wdGlvbnMuY2RhdGFLZXldICsgJ11dPic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVGV4dCAoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMuaWdub3JlVGV4dCA/ICcnIDogZWxlbWVudFtvcHRpb25zLnRleHRLZXldLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlRWxlbWVudCAoZWxlbWVudCwgb3B0aW9ucywgZGVwdGgpIHtcclxuICAgIHZhciB4bWwgPSAnJztcclxuICAgIHhtbCArPSAnPCcgKyBlbGVtZW50Lm5hbWU7XHJcbiAgICBpZiAoZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldKSB7XHJcbiAgICAgICAgeG1sICs9IHdyaXRlQXR0cmlidXRlcyhlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuZnVsbFRhZ0VtcHR5RWxlbWVudCB8fCAoZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSAmJiBlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldLmxlbmd0aCkgfHwgKGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSAmJiBlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV1bJ3htbDpzcGFjZSddID09PSAncHJlc2VydmUnKSkge1xyXG4gICAgICAgIHhtbCArPSAnPic7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0gJiYgZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgeG1sICs9IHdyaXRlRWxlbWVudHMoZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSwgb3B0aW9ucywgZGVwdGggKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeG1sICs9IChvcHRpb25zLnNwYWNlcyAmJiBlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldICYmIGVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0ubGVuZ3RoICYmIChlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldLmxlbmd0aCA+IDEgfHwgZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XVswXS50eXBlICE9PSAndGV4dCcpID8gJ1xcbicgKyBBcnJheShkZXB0aCArIDEpLmpvaW4ob3B0aW9ucy5zcGFjZXMpIDogJycpO1xyXG4gICAgICAgIHhtbCArPSAnPC8nICsgZWxlbWVudC5uYW1lICsgJz4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB4bWwgKz0gJy8+JztcclxuICAgIH1cclxuICAgIHJldHVybiB4bWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlRWxlbWVudHMgKGVsZW1lbnRzLCBvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSB7XHJcbiAgICB2YXIgaW5kZW50ID0gd3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKTtcclxuICAgIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHhtbCwgZWxlbWVudCkge1xyXG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VsZW1lbnQnOiByZXR1cm4geG1sICsgaW5kZW50ICsgd3JpdGVFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMsIGRlcHRoKTtcclxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHJldHVybiB4bWwgKyBpbmRlbnQgKyB3cml0ZUNvbW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NkYXRhJzogcmV0dXJuIHhtbCArIGluZGVudCArIHdyaXRlQ2RhdGEoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOiByZXR1cm4geG1sICsgd3JpdGVUZXh0KGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sICcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzQ29udGVudCAoZWxlbWVudCwgb3B0aW9ucywgc2tpcFRleHQpIHtcclxuICAgIHZhciBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBvcHRpb25zLnRleHRLZXk6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHNraXAgdG8gbmV4dCBrZXlcclxuICAgICAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5wYXJlbnRLZXk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIG9wdGlvbnMuYXR0cmlidXRlc0tleTpcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gc2tpcCB0byBuZXh0IGtleVxyXG4gICAgICAgICAgICAgICAgY2FzZSBvcHRpb25zLmNkYXRhS2V5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBvcHRpb25zLmNvbW1lbnRLZXk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIG9wdGlvbnMuZGVjbGFyYXRpb25LZXk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUVsZW1lbnRDb21wYWN0IChlbGVtZW50LCBuYW1lLCBvcHRpb25zLCBkZXB0aCwgaW5kZW50KSB7XHJcbiAgICB2YXIgeG1sID0gJyc7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHhtbCArPSAnPCcgKyBuYW1lO1xyXG4gICAgICAgIGlmIChlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0pIHtcclxuICAgICAgICAgICAgeG1sICs9IHdyaXRlQXR0cmlidXRlcyhlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5mdWxsVGFnRW1wdHlFbGVtZW50IHx8IGhhc0NvbnRlbnQoZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldICYmIGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XVsneG1sOnNwYWNlJ10gPT09ICdwcmVzZXJ2ZScpIHtcclxuICAgICAgICAgICAgeG1sICs9ICc+JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4bWwgKz0gJy8+JztcclxuICAgICAgICAgICAgcmV0dXJuIHhtbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB4bWwgKz0gd3JpdGVFbGVtZW50c0NvbXBhY3QoZWxlbWVudCwgb3B0aW9ucywgZGVwdGggKyAxLCBmYWxzZSk7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHhtbCArPSAoaW5kZW50ID8gd3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmFsc2UpIDogJycpICsgJzwvJyArIG5hbWUgKyAnPic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geG1sO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUVsZW1lbnRzQ29tcGFjdCAoZWxlbWVudCwgb3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkge1xyXG4gICAgdmFyIGtleSwgeG1sID0gJyc7XHJcbiAgICBmb3IgKGtleSBpbiBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBvcHRpb25zLmRlY2xhcmF0aW9uS2V5OiB4bWwgKz0gd3JpdGVEZWNsYXJhdGlvbihlbGVtZW50W29wdGlvbnMuZGVjbGFyYXRpb25LZXldLCBvcHRpb25zKTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIG9wdGlvbnMuYXR0cmlidXRlc0tleTogY2FzZSBvcHRpb25zLnBhcmVudEtleTogYnJlYWs7IC8vIHNraXBcclxuICAgICAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy50ZXh0S2V5OiB4bWwgKz0gd3JpdGVUZXh0KGVsZW1lbnQsIG9wdGlvbnMpOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5jZGF0YUtleTogeG1sICs9IHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkgKyB3cml0ZUNkYXRhKGVsZW1lbnQsIG9wdGlvbnMpOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5jb21tZW50S2V5OiB4bWwgKz0gd3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSArIHdyaXRlQ29tbWVudChlbGVtZW50LCBvcHRpb25zKTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50W2tleV0gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2tleV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbCArPSB3cml0ZUluZGVudGF0aW9uKG9wdGlvbnMsIGRlcHRoLCBmaXJzdExpbmUpICsgd3JpdGVFbGVtZW50Q29tcGFjdChlbCwga2V5LCBvcHRpb25zLCBkZXB0aCwgaGFzQ29udGVudChlbCwgb3B0aW9ucywgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWwgKz0gd3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSArIHdyaXRlRWxlbWVudENvbXBhY3QoZWxlbWVudFtrZXldLCBrZXksIG9wdGlvbnMsIGRlcHRoLCBoYXNDb250ZW50KGVsZW1lbnRba2V5XSwgb3B0aW9ucywgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXJzdExpbmUgPSBmaXJzdExpbmUgJiYgIXhtbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geG1sO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChqcywgb3B0aW9ucykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIHZhciB4bWwgPSAnJztcclxuICAgIGlmIChvcHRpb25zLmNvbXBhY3QpIHtcclxuICAgICAgICB4bWwgPSB3cml0ZUVsZW1lbnRzQ29tcGFjdChqcywgb3B0aW9ucywgMCwgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChqc1tvcHRpb25zLmRlY2xhcmF0aW9uS2V5XSkge1xyXG4gICAgICAgICAgICB4bWwgKz0gd3JpdGVEZWNsYXJhdGlvbihqc1tvcHRpb25zLmRlY2xhcmF0aW9uS2V5XSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqc1tvcHRpb25zLmVsZW1lbnRzS2V5XSAmJiBqc1tvcHRpb25zLmVsZW1lbnRzS2V5XS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgeG1sICs9IHdyaXRlRWxlbWVudHMoanNbb3B0aW9ucy5lbGVtZW50c0tleV0sIG9wdGlvbnMsIDAsICF4bWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB4bWw7XHJcbn07IiwidmFyIGpzMnhtbCA9IHJlcXVpcmUoJy4vanMyeG1sLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChqc29uLCBvcHRpb25zKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBpZiAoanNvbiBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG4gICAgICAgIGpzb24gPSBqc29uLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB2YXIganMgPSBudWxsO1xyXG4gICAgaWYgKHR5cGVvZiAoanNvbikgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAganMgPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gc3RydWN0dXJlIGlzIGludmFsaWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBqcyA9IGpzb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganMyeG1sKGpzLCBvcHRpb25zKTtcclxufTsiLCJ2YXIgc2F4ID0gcmVxdWlyZSgnc2F4Jyk7XHJcbnZhciBleHBhdCAvKj0gcmVxdWlyZSgnbm9kZS1leHBhdCcpOyovID0ge29uOiBmdW5jdGlvbiAoKSB7fSwgcGFyc2U6IGZ1bmN0aW9uICgpIHt9fTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcblxyXG52YXIgb3B0aW9ucztcclxudmFyIHB1cmVKc1BhcnNlciA9IDE7IC8vdHJ1ZTtcclxudmFyIGN1cnJlbnRFbGVtZW50O1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zICh1c2VyT3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IGNvbW1vbi5jb3B5T3B0aW9ucyh1c2VyT3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlRmxhZ0V4aXN0cygnaWdub3JlRGVjbGFyYXRpb24nLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCdpZ25vcmVBdHRyaWJ1dGVzJywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlRmxhZ0V4aXN0cygnaWdub3JlVGV4dCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2lnbm9yZUNvbW1lbnQnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCdpZ25vcmVDZGF0YScsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2NvbXBhY3QnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCdhbHdheXNDaGlsZHJlbicsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ2FkZFBhcmVudCcsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUZsYWdFeGlzdHMoJ3RyaW0nLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVGbGFnRXhpc3RzKCduYXRpdmVUeXBlJywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlRmxhZ0V4aXN0cygnc2FuaXRpemUnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVLZXlFeGlzdHMoJ2RlY2xhcmF0aW9uJywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlS2V5RXhpc3RzKCdhdHRyaWJ1dGVzJywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlS2V5RXhpc3RzKCd0ZXh0Jywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlS2V5RXhpc3RzKCdjb21tZW50Jywgb3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlS2V5RXhpc3RzKCdjZGF0YScsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygndHlwZScsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygnbmFtZScsIG9wdGlvbnMpO1xyXG4gICAgY29tbW9uLmVuc3VyZUtleUV4aXN0cygnZWxlbWVudHMnLCBvcHRpb25zKTtcclxuICAgIGNvbW1vbi5lbnN1cmVLZXlFeGlzdHMoJ3BhcmVudCcsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hdGl2ZVR5cGUgKHZhbHVlKSB7XHJcbiAgICB2YXIgblZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICAgIGlmICghaXNOYU4oblZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBuVmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgYlZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChiVmFsdWUgPT09ICd0cnVlJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChiVmFsdWUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEZpZWxkICh0eXBlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMuY29tcGFjdCkge1xyXG4gICAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnNbdHlwZSArICdLZXknXV0gPSAoY3VycmVudEVsZW1lbnRbb3B0aW9uc1t0eXBlICsgJ0tleSddXSA/IGN1cnJlbnRFbGVtZW50W29wdGlvbnNbdHlwZSArICdLZXknXV0gKyAnXFxuJyA6ICcnKSArIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRFbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGVtZW50ID0ge307XHJcbiAgICAgICAgZWxlbWVudFtvcHRpb25zLnR5cGVLZXldID0gdHlwZTtcclxuICAgICAgICBlbGVtZW50W29wdGlvbnNbdHlwZSArICdLZXknXV0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hZGRQYXJlbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudFtvcHRpb25zLnBhcmVudEtleV0gPSBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0ucHVzaChlbGVtZW50KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25EZWNsYXJhdGlvbiAoZGVjbGFyYXRpb24pIHtcclxuICAgIGlmIChvcHRpb25zLmlnbm9yZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJlbnRFbGVtZW50W29wdGlvbnMuZGVjbGFyYXRpb25LZXldKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5kZWNsYXJhdGlvbktleV0gPSB7fTtcclxuICAgIHdoaWxlIChkZWNsYXJhdGlvbi5ib2R5KSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGRlY2xhcmF0aW9uLmJvZHkubWF0Y2goLyhbXFx3Oi1dKylcXHMqPVxccypcIihbXlwiXSopXCJ8JyhbXiddKiknfChcXHcrKVxccyovKTtcclxuICAgICAgICBpZiAoIWF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjdXJyZW50RWxlbWVudFtvcHRpb25zLmRlY2xhcmF0aW9uS2V5XVtvcHRpb25zLmF0dHJpYnV0ZXNLZXldKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnMuZGVjbGFyYXRpb25LZXldW29wdGlvbnMuYXR0cmlidXRlc0tleV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5kZWNsYXJhdGlvbktleV1bb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XVthdHRyaWJ1dGVbMV1dID0gYXR0cmlidXRlWzJdO1xyXG4gICAgICAgIGRlY2xhcmF0aW9uLmJvZHkgPSBkZWNsYXJhdGlvbi5ib2R5LnNsaWNlKGF0dHJpYnV0ZVswXS5sZW5ndGgpOyAvLyBhZHZhbmNlIHRoZSBzdHJpbmdcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmFkZFBhcmVudCkge1xyXG4gICAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnMuZGVjbGFyYXRpb25LZXldW29wdGlvbnMucGFyZW50S2V5XSA9IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvblN0YXJ0RWxlbWVudCAobmFtZSwgYXR0cmlidXRlcykge1xyXG4gICAgdmFyIGtleSwgZWxlbWVudDtcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBhdHRyaWJ1dGVzID0gbmFtZS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLm5hbWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50cmltICYmIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5jb21wYWN0KSB7XHJcbiAgICAgICAgZWxlbWVudCA9IHt9O1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudFtvcHRpb25zLnBhcmVudEtleV0gPSBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoIShuYW1lIGluIGN1cnJlbnRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudFtuYW1lXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEoY3VycmVudEVsZW1lbnRbbmFtZV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50W25hbWVdID0gW2N1cnJlbnRFbGVtZW50W25hbWVdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudFtuYW1lXS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghY3VycmVudEVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0pIHtcclxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudCA9IHt9O1xyXG4gICAgICAgIGVsZW1lbnRbb3B0aW9ucy50eXBlS2V5XSA9ICdlbGVtZW50JztcclxuICAgICAgICBlbGVtZW50W29wdGlvbnMubmFtZUtleV0gPSBuYW1lO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSA9IGF0dHJpYnV0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnRbb3B0aW9ucy5wYXJlbnRLZXldID0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx3YXlzQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25UZXh0ICh0ZXh0KSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdjdXJyZW50RWxlbWVudDonLCBjdXJyZW50RWxlbWVudCk7XHJcbiAgICBpZiAob3B0aW9ucy5pZ25vcmVUZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0ZXh0LnRyaW0oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnRyaW0pIHtcclxuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5uYXRpdmVUeXBlKSB7XHJcbiAgICAgICAgdGV4dCA9IG5hdGl2ZVR5cGUodGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5zYW5pdGl6ZSkge1xyXG4gICAgICAgIHRleHQgPSBjb21tb24uc2FuaXRpemUodGV4dCk7XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZCgndGV4dCcsIHRleHQsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNvbW1lbnQgKGNvbW1lbnQpIHtcclxuICAgIGlmIChvcHRpb25zLmlnbm9yZUNvbW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50cmltKSB7XHJcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnQudHJpbSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2FuaXRpemUpIHtcclxuICAgICAgICBjb21tZW50ID0gY29tbW9uLnNhbml0aXplKGNvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGQoJ2NvbW1lbnQnLCBjb21tZW50LCBvcHRpb25zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25FbmRFbGVtZW50IChuYW1lKSB7XHJcbiAgICB2YXIgcGFyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50W29wdGlvbnMucGFyZW50S2V5XTtcclxuICAgIGlmICghb3B0aW9ucy5hZGRQYXJlbnQpIHtcclxuICAgICAgICBkZWxldGUgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5wYXJlbnRLZXldO1xyXG4gICAgfVxyXG4gICAgY3VycmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNkYXRhIChjZGF0YSkge1xyXG4gICAgaWYgKG9wdGlvbnMuaWdub3JlQ2RhdGEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50cmltKSB7XHJcbiAgICAgICAgY2RhdGEgPSBjZGF0YS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZCgnY2RhdGEnLCBjZGF0YSwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yKSB7XHJcbiAgICBlcnJvci5ub3RlID0gZXJyb3I7IC8vY29uc29sZS5lcnJvcihlcnJvcik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhtbCwgdXNlck9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgdmFyIHBhcnNlciA9IHB1cmVKc1BhcnNlciA/IHNheC5wYXJzZXIodHJ1ZSwge30pIDogcGFyc2VyID0gbmV3IGV4cGF0LlBhcnNlcignVVRGLTgnKTtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGN1cnJlbnRFbGVtZW50ID0gcmVzdWx0O1xyXG4gICAgXHJcbiAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKHVzZXJPcHRpb25zKTtcclxuICAgIFxyXG4gICAgaWYgKHB1cmVKc1BhcnNlcikge1xyXG4gICAgICAgIHBhcnNlci5vbm9wZW50YWcgPSBvblN0YXJ0RWxlbWVudDtcclxuICAgICAgICBwYXJzZXIub250ZXh0ID0gb25UZXh0O1xyXG4gICAgICAgIHBhcnNlci5vbmNvbW1lbnQgPSBvbkNvbW1lbnQ7XHJcbiAgICAgICAgcGFyc2VyLm9uY2xvc2V0YWcgPSBvbkVuZEVsZW1lbnQ7XHJcbiAgICAgICAgcGFyc2VyLm9uZXJyb3IgPSBvbkVycm9yO1xyXG4gICAgICAgIHBhcnNlci5vbmNkYXRhID0gb25DZGF0YTtcclxuICAgICAgICBwYXJzZXIub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBvbkRlY2xhcmF0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJzZXIub24oJ3N0YXJ0RWxlbWVudCcsIG9uU3RhcnRFbGVtZW50KTtcclxuICAgICAgICBwYXJzZXIub24oJ3RleHQnLCBvblRleHQpO1xyXG4gICAgICAgIHBhcnNlci5vbignY29tbWVudCcsIG9uQ29tbWVudCk7XHJcbiAgICAgICAgcGFyc2VyLm9uKCdlbmRFbGVtZW50Jywgb25FbmRFbGVtZW50KTtcclxuICAgICAgICBwYXJzZXIub24oJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICAgICAgLy9wYXJzZXIub24oJ3N0YXJ0Q2RhdGEnLCBvblN0YXJ0Q2RhdGEpO1xyXG4gICAgICAgIC8vcGFyc2VyLm9uKCdlbmRDZGF0YScsIG9uRW5kQ2RhdGEpO1xyXG4gICAgICAgIC8vcGFyc2VyLm9uKCdlbnRpdHlEZWNsJywgb25FbnRpdHlEZWNsKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHB1cmVKc1BhcnNlcikge1xyXG4gICAgICAgIHBhcnNlci53cml0ZSh4bWwpLmNsb3NlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghcGFyc2VyLnBhcnNlKHhtbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUwgcGFyc2luZyBlcnJvcjogJyArIHBhcnNlci5nZXRFcnJvcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHRbb3B0aW9ucy5lbGVtZW50c0tleV0pIHtcclxuICAgICAgICB2YXIgdGVtcCA9IHJlc3VsdFtvcHRpb25zLmVsZW1lbnRzS2V5XTtcclxuICAgICAgICBkZWxldGUgcmVzdWx0W29wdGlvbnMuZWxlbWVudHNLZXldO1xyXG4gICAgICAgIHJlc3VsdFtvcHRpb25zLmVsZW1lbnRzS2V5XSA9IHRlbXA7XHJcbiAgICAgICAgZGVsZXRlIHJlc3VsdC50ZXh0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxufTsiLCJ2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHhtbDJqcyA9IHJlcXVpcmUoJy4veG1sMmpzJyk7XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMgKHVzZXJPcHRpb25zKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGNvbW1vbi5jb3B5T3B0aW9ucyh1c2VyT3B0aW9ucyk7XHJcbiAgICBjb21tb24uZW5zdXJlU3BhY2VzRXhpc3RzKG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeG1sLCB1c2VyT3B0aW9ucykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIG9wdGlvbnMsIGpzLCBqc29uLCBwYXJlbnRLZXk7XHJcbiAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKHVzZXJPcHRpb25zKTtcclxuICAgIGpzID0geG1sMmpzKHhtbCwgb3B0aW9ucyk7XHJcbiAgICBwYXJlbnRLZXkgPSAnY29tcGFjdCcgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhY3QgPyAnX3BhcmVudCcgOiAncGFyZW50JztcclxuICAgIGlmICgnYWRkUGFyZW50JyBpbiBvcHRpb25zICYmIG9wdGlvbnMuYWRkUGFyZW50KSB7XHJcbiAgICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KGpzLCBmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gayA9PT0gcGFyZW50S2V5PyAnXycgOiB2OyB9LCBvcHRpb25zLnNwYWNlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShqcywgbnVsbCwgb3B0aW9ucy5zcGFjZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XHJcbn07IiwiY29uc3Qgb2JqUGF0aCA9IHJlcXVpcmUoJ29iamVjdC1wYXRoJyk7XG5cbmNvbnN0IGdldElkID0gKGFyYykgPT4gb2JqUGF0aC5nZXQoYXJjLCAnX2F0dHJpYnV0ZXMuaWQnKTtcblxuY29uc3QgZ2V0Q2xhc3MgPSAoYXJjKSA9PiBvYmpQYXRoLmdldChhcmMsICdfYXR0cmlidXRlcy5jbGFzcycsICcnKTtcblxuY29uc3QgZ2V0U291cmNlID0gKGFyYywgbm9kZUlkU2V0LCBwb3J0SWRNYXApID0+IHtcbiAgY29uc3QgcG9ydFNvdXJjZSA9IGdldFBvcnRTb3VyY2UoYXJjKTtcbiAgcmV0dXJuIG5vZGVJZFNldC5oYXMocG9ydFNvdXJjZSkgPyBwb3J0U291cmNlIDogcG9ydElkTWFwLmdldChwb3J0U291cmNlKTtcbn07XG5cbmNvbnN0IGdldFRhcmdldCA9IChhcmMsIG5vZGVJZFNldCwgcG9ydElkTWFwKSA9PiB7XG4gIGNvbnN0IHBvcnRUYXJnZXQgPSBnZXRQb3J0VGFyZ2V0KGFyYyk7XG4gIHJldHVybiBub2RlSWRTZXQuaGFzKHBvcnRUYXJnZXQpID8gcG9ydFRhcmdldCA6IHBvcnRJZE1hcC5nZXQocG9ydFRhcmdldCk7XG59O1xuXG5jb25zdCBnZXRQb3J0U291cmNlID0gKGFyYykgPT4gb2JqUGF0aC5nZXQoYXJjLCAnX2F0dHJpYnV0ZXMuc291cmNlJywgJycpO1xuXG5jb25zdCBnZXRQb3J0VGFyZ2V0ID0gKGFyYykgPT4gb2JqUGF0aC5nZXQoYXJjLCAnX2F0dHJpYnV0ZXMudGFyZ2V0JywgJycpO1xuXG5jb25zdCBnZXRDYXJkaW5hbGl0eSA9IChnbHlwaCkgPT4gcGFyc2VJbnQob2JqUGF0aC5nZXQoZ2x5cGgsICdsYWJlbC5fYXR0cmlidXRlcy50ZXh0JywgJycpKTtcblxuY29uc3QgZ2V0QmVuZFBvaW50UG9zaXRpb25zID0gKGFyYykgPT4ge1xuICByZXR1cm4gW10uY29uY2F0KG9ialBhdGguZ2V0KGFyYywgJ25leHQnLCBbXSkpXG4gIC5tYXAoKGJlbmRQb2ludCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwYXJzZUludChiZW5kUG9pbnQueCksXG4gICAgICB5OiBwYXJzZUludChiZW5kUG9pbnQueSlcbiAgICB9O1xuICB9KTtcbn07XG5cblxuY29uc3QgY29udmVydEFyYyA9IChhcmMsIG5vZGVJZFNldCwgcG9ydElkTWFwKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgaWQ6IGdldElkKGFyYyksXG4gICAgICAnY2xhc3MnOiBnZXRDbGFzcyhhcmMpLFxuICAgICAgY2FyZGluYWxpdHk6IGFyYy5nbHlwaCA/IGdldENhcmRpbmFsaXR5KGFyYy5nbHlwaCk6IDAsXG4gICAgICBzb3VyY2U6IGdldFNvdXJjZShhcmMsIG5vZGVJZFNldCwgcG9ydElkTWFwKSxcbiAgICAgIHRhcmdldDogZ2V0VGFyZ2V0KGFyYywgbm9kZUlkU2V0LCBwb3J0SWRNYXApLFxuICAgICAgYmVuZFBvaW50UG9zaXRpb25zOiBnZXRCZW5kUG9pbnRQb3NpdGlvbnMoYXJjKSxcbiAgICAgIHBvcnRTb3VyY2U6IGdldFBvcnRTb3VyY2UoYXJjKSxcbiAgICAgIHBvcnRUYXJnZXQ6IGdldFBvcnRUYXJnZXQoYXJjKVxuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkQXJjID0gKGFyYywgbm9kZUlkU2V0LCBwb3J0SWRNYXApID0+IHtcbiAgY29uc3Qgc3JjTm9kZUlkID0gZ2V0U291cmNlKGFyYywgbm9kZUlkU2V0LCBwb3J0SWRNYXApO1xuICBjb25zdCB0Z3ROb2RlSWQgPSBnZXRUYXJnZXQoYXJjLCBub2RlSWRTZXQsIHBvcnRJZE1hcCk7XG5cbiAgcmV0dXJuIChub2RlSWRTZXQuaGFzKHNyY05vZGVJZCkpICYmIChub2RlSWRTZXQuaGFzKHRndE5vZGVJZCkpO1xufTtcblxuY29uc3QgY29udmVydEVkZ2VzID0gKGFyY3MsIG5vZGVJZFNldCwgcG9ydElkTWFwKSA9PiB7XG4gIHJldHVybiBhcmNzXG4gIC5maWx0ZXIoKGFyYykgPT4gdmFsaWRBcmMoYXJjLCBub2RlSWRTZXQsIHBvcnRJZE1hcCkpXG4gIC5tYXAoKGFyYykgPT4gY29udmVydEFyYyhhcmMsIG5vZGVJZFNldCwgcG9ydElkTWFwKSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0RWRnZXM7XG4iLCJ2YXIgY29udmVydGVyID0gcmVxdWlyZSgnLi9zYmdubWxDb252ZXJ0ZXInKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9ICh0ZXh0KSA9PiB7XG4gIHJldHVybiBjb252ZXJ0ZXIodGV4dCk7XG59O1xuIiwiY29uc3Qgb2JqUGF0aCA9IHJlcXVpcmUoJ29iamVjdC1wYXRoJyk7XG5cbmNvbnN0IHZhbGlkU2JnbkNsYXNzID0gcmVxdWlyZSgnLi9zYmduVGFncycpO1xuXG5jb25zdCBnZXRDZW50ZXJlZEJib3ggPSAoZ2x5cGgpID0+IHtcbiAgbGV0IHt4OngsIHk6eSwgdzp3LCBoOmh9ID0gb2JqUGF0aC5nZXQoZ2x5cGgsICdiYm94Ll9hdHRyaWJ1dGVzJywge3g6IDAsIHk6IDAsIHc6IDAsIGg6IDB9KTtcblxuICByZXR1cm4ge1xuICAgIHg6IHBhcnNlRmxvYXQoeCkgKyAoIHBhcnNlRmxvYXQodykgLyAyICksXG4gICAgeTogcGFyc2VGbG9hdCh5KSArICggcGFyc2VGbG9hdChoKSAvIDIgKSxcbiAgICB3OiBwYXJzZUZsb2F0KHcpLFxuICAgIGg6IHBhcnNlRmxvYXQoaClcbiAgfTtcbn07XG5cbmNvbnN0IGdldElkID0gKGdseXBoKSA9PiBvYmpQYXRoLmdldChnbHlwaCwgJ19hdHRyaWJ1dGVzLmlkJyk7XG5cbmNvbnN0IGdldENsYXNzID0gKGdseXBoKSA9PiBvYmpQYXRoLmdldChnbHlwaCwgJ19hdHRyaWJ1dGVzLmNsYXNzJywgJycpO1xuXG5jb25zdCBnZXRMYWJlbCA9IChnbHlwaCkgPT4gb2JqUGF0aC5nZXQoZ2x5cGgsICdsYWJlbC5fYXR0cmlidXRlcy50ZXh0JywgJycpO1xuXG5jb25zdCBnZXRQYXJlbnQgPSAoZ2x5cGgpID0+IG9ialBhdGguZ2V0KGdseXBoLCAnX2F0dHJpYnV0ZXMuY29tcGFydG1lbnRSZWYnLCAnJyk7XG5cbmNvbnN0IGdldENsb25lbWFya2VyID0gKGdseXBoKSA9PiBnbHlwaC5jbG9uZSAhPT0gdW5kZWZpbmVkO1xuXG5jb25zdCBnZXRTdGF0ZSA9IChnbHlwaCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHZhcmlhYmxlOiBvYmpQYXRoLmdldChnbHlwaCwgJ3N0YXRlLl9hdHRyaWJ1dGVzLnZhcmlhYmxlJywgJycpLFxuICAgIHZhbHVlOiBvYmpQYXRoLmdldChnbHlwaCwgJ3N0YXRlLl9hdHRyaWJ1dGVzLnZhbHVlJywgJycpXG4gIH07XG59O1xuXG5jb25zdCBnZXRTdGF0ZVZhciA9IChnbHlwaCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZXRJZChnbHlwaCksXG4gICAgJ2NsYXNzJzogZ2V0Q2xhc3MoZ2x5cGgpLFxuICAgIHN0YXRlOiBnZXRTdGF0ZShnbHlwaClcbiAgfTtcbn07XG5cbmNvbnN0IGdldFVuaXRPZkluZm9ybWF0aW9uID0gKGdseXBoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGdldElkKGdseXBoKSxcbiAgICAnY2xhc3MnOiBnZXRDbGFzcyhnbHlwaCksXG4gICAgbGFiZWw6IHtcbiAgICAgIHRleHQ6IG9ialBhdGguZ2V0KGdseXBoLCAnbGFiZWwuX2F0dHJpYnV0ZXMudGV4dCcsICcnKVxuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IGdldFN0YXRlVmFycyA9IChnbHlwaCkgPT4ge1xuICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShnbHlwaClcbiAgICAuZmlsdGVyKChjaGlsZCkgPT4gIGdldENsYXNzKGNoaWxkKSA9PT0gJ3N0YXRlIHZhcmlhYmxlJylcbiAgICAubWFwKChzdGF0ZVZhcikgPT4gZ2V0U3RhdGVWYXIoc3RhdGVWYXIpKTtcbn07XG5cbmNvbnN0IGdldFVuaXRzT2ZJbmZvcm1hdGlvbiA9IChnbHlwaCkgPT4ge1xuICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShnbHlwaClcbiAgICAuZmlsdGVyKChjaGlsZCkgPT4gIGdldENsYXNzKGNoaWxkKSA9PT0gJ3VuaXQgb2YgaW5mb3JtYXRpb24nKVxuICAgIC5tYXAoKGcpID0+IGdldFVuaXRPZkluZm9ybWF0aW9uKGcpKTtcbn07XG5cbmNvbnN0IGdldENoaWxkcmVuID0gKGdseXBoKSA9PiB7XG4gIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGdseXBoKS5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgcmV0dXJuIGdldENsYXNzKGNoaWxkKSAhPT0gJ3VuaXQgb2YgaW5mb3JtYXRpb24nICYmIGdldENsYXNzKGNoaWxkKSAhPT0gJ3N0YXRlIHZhcmlhYmxlJztcbiAgfSk7XG59O1xuXG5jb25zdCBnZXRDaGlsZHJlbkFycmF5ID0gKGdseXBoKSA9PiB7XG4gIHJldHVybiBbXS5jb25jYXQob2JqUGF0aC5nZXQoZ2x5cGgsICdnbHlwaCcsIFtdKSk7XG59O1xuXG5jb25zdCBjb252ZXJ0R2x5cGggPSAoZ2x5cGgsIHBhcmVudD0nJykgPT4ge1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHtcbiAgICAgIGlkOiBnZXRJZChnbHlwaCksXG4gICAgICAnY2xhc3MnOiBnZXRDbGFzcyhnbHlwaCksXG4gICAgICBsYWJlbDogZ2V0TGFiZWwoZ2x5cGgpLFxuICAgICAgcGFyZW50OiBnbHlwaC5wYXJlbnQgfHwgZ2V0UGFyZW50KGdseXBoKSB8fCBwYXJlbnQsICAvLyBpbW1lZGlhdGUgcGFyZW50IHRha2VzIHByZWNlbmRlbmNlIG92ZXIgY29tcGFydG1lbnRzXG4gICAgICBjbG9uZW1hcmtlcjogZ2V0Q2xvbmVtYXJrZXIoZ2x5cGgpLFxuICAgICAgc3RhdGVWYXJpYWJsZXM6IGdldFN0YXRlVmFycyhnbHlwaCksXG4gICAgICB1bml0c09mSW5mb3JtYXRpb246IGdldFVuaXRzT2ZJbmZvcm1hdGlvbihnbHlwaCksXG4gICAgICBiYm94OiBnZXRDZW50ZXJlZEJib3goZ2x5cGgpXG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGdldFBvcnRzID0gKGdseXBoKSA9PiB7XG4gIHJldHVybiBbXS5jb25jYXQob2JqUGF0aC5nZXQoZ2x5cGgsICdwb3J0JywgW10pKS5tYXAoKHBvcnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdldElkKHBvcnQpLFxuICAgICAgYmJveDogZ2V0Q2VudGVyZWRCYm94KHBvcnQpXG4gICAgfTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChnbHlwaHMpID0+IHtcbiAgY29uc3Qgbm9kZUlkU2V0ID0gbmV3IFNldCgpO1xuICBjb25zdCBwb3J0SWRNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IG5vZGVzID0gW107XG5cbiAgc3RhY2sucHVzaCguLi5nbHlwaHMpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGN1cnJHbHlwaCA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGN1cnJHbHlwaElkID0gZ2V0SWQoY3VyckdseXBoKTtcbiAgICBjb25zdCBwcm9jZXNzZWRHbHlwaCA9IGNvbnZlcnRHbHlwaChjdXJyR2x5cGgpO1xuXG4gICAgaWYgKHZhbGlkU2JnbkNsYXNzKHByb2Nlc3NlZEdseXBoLmRhdGFbJ2NsYXNzJ10pKSB7XG4gICAgICBub2Rlcy5wdXNoKHByb2Nlc3NlZEdseXBoKTtcbiAgICAgIG5vZGVJZFNldC5hZGQoY3VyckdseXBoSWQpO1xuXG4gICAgICBmb3IgKGNvbnN0IHBvcnQgb2YgZ2V0UG9ydHMoY3VyckdseXBoKSkge1xuICAgICAgICBwb3J0SWRNYXAuc2V0KHBvcnQuaWQsIGN1cnJHbHlwaElkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihjdXJyR2x5cGgpO1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gY3VyckdseXBoSWQ7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZXM6IG5vZGVzLFxuICAgIG5vZGVJZFNldDogbm9kZUlkU2V0LFxuICAgIHBvcnRJZE1hcDogcG9ydElkTWFwXG4gIH07XG59O1xuIiwiXG5cbmNvbnN0IGhhbmRsZWRTYmduQ2xhc3NlcyA9IG5ldyBTZXQoKVxuLmFkZCgndW5zcGVjaWZpZWQgZW50aXR5Jylcbi5hZGQoJ3NpbXBsZSBjaGVtaWNhbCcpXG4uYWRkKCdtYWNyb21vbGVjdWxlJylcbi5hZGQoJ251Y2xlaWMgYWNpZCBmZWF0dXJlJylcbi5hZGQoJ3BlcnR1cmJpbmcgYWdlbnQnKVxuLmFkZCgnc291cmNlIGFuZCBzaW5rJylcbi5hZGQoJ2NvbXBsZXgnKVxuLmFkZCgncHJvY2VzcycpXG4uYWRkKCdvbWl0dGVkIHByb2Nlc3MnKVxuLmFkZCgndW5jZXJ0YWluIHByb2Nlc3MnKVxuLmFkZCgnYXNzb2NpYXRpb24nKVxuLmFkZCgnZGlzc29jaWF0aW9uJylcbi5hZGQoJ3BoZW5vdHlwZScpXG4uYWRkKCd0YWcnKVxuLmFkZCgnY29uc3VtcHRpb24nKVxuLmFkZCgncHJvZHVjdGlvbicpXG4uYWRkKCdtb2R1bGF0aW9uJylcbi5hZGQoJ3N0aW11bGF0aW9uJylcbi5hZGQoJ2NhdGFseXNpcycpXG4uYWRkKCdpbmhpYml0aW9uJylcbi5hZGQoJ25lY2Vzc2FyeSBzdGltdWxhdGlvbicpXG4uYWRkKCdsb2dpYyBhcmMnKVxuLmFkZCgnZXF1aXZhbGVuY2UgYXJjJylcbi5hZGQoJ2FuZCBvcGVyYXRvcicpXG4uYWRkKCdvciBvcGVyYXRvcicpXG4uYWRkKCdub3Qgb3BlcmF0b3InKVxuLmFkZCgnYW5kJylcbi5hZGQoJ29yJylcbi5hZGQoJ25vdCcpXG4uYWRkKCdudWNsZWljIGFjaWQgZmVhdHVyZSBtdWx0aW1lcicpXG4uYWRkKCdtYWNyb21vbGVjdWxlIG11bHRpbWVyJylcbi5hZGQoJ3NpbXBsZSBjaGVtaWNhbCBtdWx0aW1lcicpXG4uYWRkKCdjb21wbGV4IG11bHRpbWVyJylcbi5hZGQoJ2NvbXBhcnRtZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHNiZ25DbGFzcykgPT4gaGFuZGxlZFNiZ25DbGFzc2VzLmhhcyhzYmduQ2xhc3MpO1xuIiwiY29uc3QgY29udmVydCA9IHJlcXVpcmUoJ3htbC1qcycpO1xuY29uc3Qgb2JqUGF0aCA9IHJlcXVpcmUoJ29iamVjdC1wYXRoJyk7XG5cbmNvbnN0IG5vZGVzQ29udmVydGVyID0gcmVxdWlyZSgnLi9ub2Rlc0NvbnZlcnRlcicpO1xuY29uc3QgZWRnZXNDb252ZXJ0ZXIgPSByZXF1aXJlKCcuL2VkZ2VzQ29udmVydGVyJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoc2Jnbm1sVGV4dCkgPT4ge1xuXG4gIGlmIChzYmdubWxUZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtzYmdubWxUZXh0fSBpcyBpbnZhbGlkIGlucHV0LmApO1xuICB9XG5cbiAgY29uc3QgY29udmVydGVkID0gY29udmVydC54bWwyanMoc2Jnbm1sVGV4dCwge2NvbXBhY3Q6IHRydWUsIHNwYWNlczogMiwgdHJpbTogdHJ1ZSwgbmF0aXZlVHlwZTogdHJ1ZSB9KTtcblxuICBjb25zdCByZXN1bHQgPSBvYmpQYXRoLmdldChjb252ZXJ0ZWQsICdzYmduLm1hcCcsIHVuZGVmaW5lZCk7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7bm9kZXM6IFtdLCBlZGdlczogW119O1xuICB9XG5cbiAgY29uc3QgZ2x5cGhzID0gW107XG4gIGNvbnN0IGFyY3MgPSBbXTtcbiAgaWYgKHJlc3VsdC5nbHlwaCkge1xuICAgIGdseXBocy5wdXNoKC4uLnJlc3VsdC5nbHlwaCk7XG4gIH1cbiAgaWYgKHJlc3VsdC5hcmMpIHtcbiAgICBhcmNzLnB1c2goLi4ucmVzdWx0LmFyYyk7XG4gIH1cblxuICBjb25zdCB7bm9kZXM6IG5vZGVzLCBub2RlSWRTZXQ6IG5vZGVJZFNldCwgcG9ydElkTWFwfSA9IG5vZGVzQ29udmVydGVyKGdseXBocyk7XG4gIGNvbnN0IGVkZ2VzID0gZWRnZXNDb252ZXJ0ZXIoYXJjcywgbm9kZUlkU2V0LCBwb3J0SWRNYXApO1xuXG4gIHJldHVybiB7bm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXN9O1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG5cbnZhciBzdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcblx0aWYodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0aWYodHlwZW9mIGNhbnZhcy5nZXRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cblx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0cmV0dXJuICEhY29udGV4dCAmJiAodHlwZW9mIGNvbnRleHQubWVhc3VyZVRleHQgPT09ICdmdW5jdGlvbicpO1xufTtcblxudmFyIGluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdHZhciB3aWR0aCA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBleHRlbmQoe1xuXHRcdFx0c3R5bGU6ICdub3JtYWwnLFxuXHRcdFx0dmFyaWFudDogJ25vcm1hbCcsXG5cdFx0XHR3ZWlnaHQ6ICdub3JtYWwnLFxuXHRcdFx0c2l6ZTogJ21lZGl1bScsXG5cdFx0XHRmYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRcdGFsaWduOiAnc3RhcnQnLFxuXHRcdFx0YmFzZWxpbmU6ICdhbHBoYWJldGljJ1xuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0dmFyIHNpemUgPSBvcHRpb25zLnNpemU7XG5cdFx0aWYodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSBzaXplID0gc2l6ZSArICdweCc7XG5cblx0XHRjb250ZXh0LmZvbnQgPSB1dGlsLmZvcm1hdCgnJXMgJXMgJXMgJXMgJXMnLFxuXHRcdFx0b3B0aW9ucy5zdHlsZSxcblx0XHRcdG9wdGlvbnMudmFyaWFudCxcblx0XHRcdG9wdGlvbnMud2VpZ2h0LFxuXHRcdFx0c2l6ZSxcblx0XHRcdG9wdGlvbnMuZmFtaWx5KTtcblx0XHRjb250ZXh0LnRleHRBbGlnbiA9IG9wdGlvbnMuYWxpZ247XG5cdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSBvcHRpb25zLmJhc2VsaW5lO1xuXG5cdFx0cmV0dXJuIGNvbnRleHQubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblx0fTtcblxuXHR3aWR0aC5zdXBwb3J0ZWQgPSB0cnVlO1xuXHRyZXR1cm4gd2lkdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRlZCgpID8gaW5pdGlhbGl6ZSgpIDogKGZ1bmN0aW9uKCkge1xuXHR2YXIgd2lkdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHR3aWR0aC5zdXBwb3J0ZWQgPSBmYWxzZTtcblx0cmV0dXJuIHdpZHRoO1xufSgpKTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJsZXQgQ3l0b3NjYXBlID0gcmVxdWlyZSgnY3l0b3NjYXBlJyk7XG5sZXQgZGVmYXVsdHNEZWVwID0gcmVxdWlyZSgnbG9kYXNoLmRlZmF1bHRzZGVlcCcpO1xuXG5sZXQgc2JnblN0eWxlU2hlZXQgPSByZXF1aXJlKCcuL3NiZ25TdHlsZS9ncmFwaCcpO1xubGV0IHJlbmRlckdyYXBoID0gcmVxdWlyZSgnLi9yZW5kZXJHcmFwaCcpO1xuXG5sZXQgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gIHNob3dPdmVybGF5OiBmYWxzZSxcbiAgbWluWm9vbTogZmFsc2UsXG4gIG1heFpvb206IGZhbHNlLFxuICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgd2hlZWxTZW5zaXRpdml0eTogMC4xXG59O1xuXG5jbGFzcyBTQkdOUmVuZGVyZXIgZXh0ZW5kcyBDeXRvc2NhcGUge1xuICBjb25zdHJ1Y3Rvciggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0c0RlZXAoIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyApO1xuXG4gICAgaWYoICFvcHRpb25zLnN0eWxlICl7XG4gICAgICBvcHRpb25zLnN0eWxlID0gc2JnblN0eWxlU2hlZXQoQ3l0b3NjYXBlKTtcbiAgICB9XG5cbiAgICBzdXBlciggZGVmYXVsdHNEZWVwKCB7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgKSApO1xuICB9XG59XG5cblNCR05SZW5kZXJlci5zdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHNiZ25TdHlsZVNoZWV0KEN5dG9zY2FwZSk7XG59O1xuXG5TQkdOUmVuZGVyZXIucmVuZGVyR3JhcGggPSByZW5kZXJHcmFwaDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNCR05SZW5kZXJlcjtcbiIsImNvbnN0IGNvbnZlcnRTYmdubWwgPSByZXF1aXJlKCdzYmdubWwtdG8tY3l0b3NjYXBlJyk7XG5cbmNvbnN0IHJlbW92ZURpc2Nvbm5lY3RlZE5vZGVzID0gKGN5KSA9PiB7XG4gIGNvbnN0IGNvbXBhcnRtZW50Q2hpbGRyZW4gPSBjeS5ub2RlcygnW2NsYXNzPVwiY29tcGFydG1lbnRcIl0nKS5jaGlsZHJlbigpO1xuICBjb21wYXJ0bWVudENoaWxkcmVuLmZpbHRlckZuKChlbGUpID0+IGVsZS5uZWlnaGJvcmhvb2QoKS5sZW5ndGggPT09IDApLnJlbW92ZSgpO1xuXG4gIGNvbnN0IGRhbmdsaW5nTm9kZXMgPSBjeS5ub2RlcygnW2NsYXNzICE9IFwiY29tcGFydG1lbnRcIl0sIFtjbGFzcyAhPSBcImNvbXBsZXhcIl0sIFtjbGFzcyAhPSBcImNvbXBsZXggbXVsdGltZXJcIl0nKTtcbiAgZGFuZ2xpbmdOb2Rlcy5maWx0ZXJGbigoZWxlKSA9PiAhZWxlLmlzQ2hpbGQoKSAmJiBlbGUubmVpZ2hib3Job29kLmxlbmd0aCA9PT0gMCkucmVtb3ZlKCk7XG59O1xuXG5jb25zdCBleHBhbmRDb2xsYXBzZUNvbXBsZXhOb2Rlc0JpbGtlbnQgPSAoY3kpID0+IHtcbiAgY3kuZXhwYW5kQ29sbGFwc2Uoe1xuICAgIGZpc2hleWU6IGZhbHNlLFxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgdW5kb2FibGU6IGZhbHNlLFxuICAgIGN1ZUVuYWJsZWQ6IGZhbHNlXG4gIH0pO1xuXG4gIGN5Lm5vZGVzKCkub24oJ2V4cGFuZGNvbGxhcHNlLmFmdGVyZXhwYW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGNvbnN0IG5vZGUgPSBldnQudGFyZ2V0O1xuICAgIGN5Lnpvb21pbmdFbmFibGVkKGZhbHNlKTtcbiAgICBub2RlLmNoaWxkcmVuKCkubGF5b3V0KHtcbiAgICAgIG5hbWU6J2dyaWQnLFxuICAgICAgZml0OiAnZmFsc2UnLFxuICAgICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgICAgY29uZGVuc2U6IHRydWUsXG4gICAgICByb3dzOiBub2RlLmNoaWxkcmVuKCkuc2l6ZSgpIC8gMixcbiAgICAgIGNvbHM6IG5vZGUuY2hpbGRyZW4oKS5zaXplKCkgLyAyLFxuICAgICAgYm91bmRpbmdCb3g6IG5vZGUuYm91bmRpbmdCb3goKVxuICAgIH0pLnJ1bigpO1xuICAgIGN5Lnpvb21pbmdFbmFibGVkKHRydWUpO1xuICB9KTtcblxuICBjb25zdCBjb21wbGV4ZXMgPSBjeS5ub2RlcygnW2NsYXNzPVwiY29tcGxleFwiXSwgW2NsYXNzPVwiY29tcGxleCBtdWx0aW1lclwiXScpO1xuICBjb25zdCBhcGkgPSBjeS5leHBhbmRDb2xsYXBzZSgnZ2V0Jyk7XG5cbiAgYXBpLmNvbGxhcHNlKGNvbXBsZXhlcyk7XG5cbiAgY3kub24oJ3RhcCcsICdub2RlW2NsYXNzPVwiY29tcGxleFwiXSwgbm9kZVtjbGFzcz1cImNvbXBsZXggbXVsdGltZXJcIl0nLCB7fSwgKGV2dCkgPT4ge1xuXG4gICAgY29uc3Qgbm9kZSA9IGV2dC50YXJnZXQ7XG4gICAgaWYgKGFwaS5pc0NvbGxhcHNpYmxlKG5vZGUpKSB7XG4gICAgICBhcGkuY29sbGFwc2VSZWN1cnNpdmVseShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLmV4cGFuZChub2RlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5jb25zdCByZWR1Y2VHcmFwaENvbXBsZXhpdHkgPSAoY3kpID0+IHtcbiAgcmVtb3ZlRGlzY29ubmVjdGVkTm9kZXMoY3kpO1xuICBleHBhbmRDb2xsYXBzZUNvbXBsZXhOb2Rlc0JpbGtlbnQoY3kpO1xufTtcblxuY29uc3QgcmVuZGVyR3JhcGggPSAoY3ksIHNiZ25tbFRleHQpID0+IHtcbiAgY29uc3QgZ3JhcGhKU09OID0gY29udmVydFNiZ25tbChzYmdubWxUZXh0KTtcblxuICBjeS5iYXRjaChmdW5jdGlvbigpe1xuICAgIGN5LnJlbW92ZSgnKicpO1xuICAgIGN5LmFkZChncmFwaEpTT04pO1xuXG4gICAgdmFyIG5vZGVQb3NpdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoSlNPTi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHhQb3MgPSBncmFwaEpTT04ubm9kZXNbaV0uZGF0YS5iYm94Lng7XG4gICAgICB2YXIgeVBvcyA9IGdyYXBoSlNPTi5ub2Rlc1tpXS5kYXRhLmJib3gueTtcbiAgICAgIG5vZGVQb3NpdGlvbnNbZ3JhcGhKU09OLm5vZGVzW2ldLmRhdGEuaWRdID0geyd4JzogeFBvcywgJ3knOiB5UG9zfTtcbiAgICB9XG5cbiAgICBjeS5sYXlvdXQoe1xuICAgICAgbmFtZTogJ3ByZXNldCcsXG4gICAgICBwb3NpdGlvbnM6IG5vZGVQb3NpdGlvbnMsXG4gICAgICBmaXQ6IHRydWUsXG4gICAgICBwYWRkaW5nOiA1MFxuICAgIH0pLnJ1bigpO1xuICB9KTtcblxuICByZWR1Y2VHcmFwaENvbXBsZXhpdHkoY3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJHcmFwaDtcbiIsImNvbnN0IHNiZ25EYXRhID0gcmVxdWlyZSgnLi91dGlsL3NiZ24uanMnKTtcblxuY29uc3Qgc2Jnbk5vZGVEaW1lbnNpb25zID0gbmV3IE1hcCgpXG4uc2V0KCd1bnNwZWNpZmllZCBlbnRpdHknLCB7dzogNDAsIGg6IDQwfSlcbi5zZXQoJ3NpbXBsZSBjaGVtaWNhbCcsIHt3OiA2MCwgaDogNjB9KVxuLnNldCgnc2ltcGxlIGNoZW1pY2FsIG11bHRpbWVyJywge3c6IDYwLCBoOiA2MH0pXG4uc2V0KCdtYWNyb21vbGVjdWxlJywge3c6IDEwMCwgaDogNjB9KVxuLnNldCgnbWFjcm9tb2xlY3VsZSBtdWx0aW1lcicsIHt3OiAxMDAsIGg6IDYwfSlcbi5zZXQoJ251Y2xlaWMgYWNpZCBmZWF0dXJlJywge3c6IDEwMCwgaDogNjB9KVxuLnNldCgnbnVjbGVpYyBhY2lkIGZlYXR1cmUgbXVsdGltZXInLCB7dzogMTAwLCBoOiA2MH0pXG4uc2V0KCdjb21wbGV4Jywge3c6IDQ1LCBoOiA0NX0pXG4uc2V0KCdjb21wbGV4IG11bHRpbWVyJywge3c6IDI1MCwgaDogMjUwfSlcbi5zZXQoJ3NvdXJjZSBhbmQgc2luaycsIHt3OiA2MCwgaDogNjB9KVxuLnNldCgncGVydHVyYmluZyBhZ2VudCcsIHt3OiAxNDAsIGg6IDYwfSlcblxuLnNldCgncGhlbm90eXBlJywge3c6IDE0MCwgaDogNjB9KVxuLnNldCgncHJvY2VzcycsIHt3OjI1LCBoOiAyNX0pXG4uc2V0KCd1bmNlcnRhaW4gcHJvY2VzcycsIHt3OjI1LCBoOiAyNX0pXG4uc2V0KCdvbWl0dGVkIHByb2Nlc3MnLCB7dzoyNSwgaDogMjV9KVxuLnNldCgnYXNzb2NpYXRpb24nLCB7dzoyNSwgaDogMjV9KVxuLnNldCgnZGlzc29jaWF0aW9uJywge3c6MjUsIGg6IDI1fSlcblxuLnNldCgnY29tcGFydG1lbnQnLCB7dzogMjAwLCBoOiAxMDB9KVxuXG4uc2V0KCd0YWcnLCB7dzogMTAwLCBoOiA2NX0pXG4uc2V0KCdhbmQnLCB7dzogNDAsIGg6IDQwfSlcbi5zZXQoJ29yJywge3c6IDQwLCBoOiA0MH0pXG4uc2V0KCdub3QnLCB7dzogNDAsIGg6IDQwfSk7XG5cblxuXG5jb25zdCBnZXQgPSAobm9kZSkgPT4ge1xuICBjb25zdCBzYmduQ2xhc3MgPSBzYmduRGF0YS5zYmduQ2xhc3Mobm9kZSk7XG4gIGNvbnN0IGRpbSA9IHNiZ25Ob2RlRGltZW5zaW9ucy5nZXQoc2JnbkNsYXNzKTtcbiAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtzYmduQ2xhc3N9IGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IHdpZHRoIC8gaGVpZ2h0YCk7XG4gIH1cbiAgcmV0dXJuIGRpbTtcbn07XG5cbmNvbnN0IHdpZHRoID0gKG5vZGUpID0+IHtcbiAgcmV0dXJuIGdldChub2RlKS53O1xufTtcblxuY29uc3QgaGVpZ2h0ID0gKG5vZGUpID0+IHtcbiAgcmV0dXJuIGdldChub2RlKS5oO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhlaWdodDogaGVpZ2h0LFxuICB3aWR0aDogd2lkdGgsXG4gIGdldDogZ2V0XG59O1xuIiwiY29uc3Qgc2JnbkRhdGEgPSByZXF1aXJlKCcuL3V0aWwvc2Jnbi5qcycpO1xudmFyIGVsZW1lbnRTdHlsZSA9IHt9O1xuXG5lbGVtZW50U3R5bGUuc2JnblNoYXBlID0gKG5vZGUpID0+IHtcbiAgbGV0IHNiZ25DbGFzcyA9IHNiZ25EYXRhLnNiZ25DbGFzcyhub2RlKTtcbiAgaWYgKHNiZ25DbGFzcy5lbmRzV2l0aCgnIG11bHRpbWVyJykpIHtcbiAgICBzYmduQ2xhc3MgPSBzYmduQ2xhc3MucmVwbGFjZSgnIG11bHRpbWVyJywgJycpO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAncGhlbm90eXBlJykge1xuICAgIHJldHVybiAnaGV4YWdvbic7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdjb21wYXJ0bWVudCcpIHtcbiAgICByZXR1cm4gJ2JhcnJlbCc7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdwcm9jZXNzJyB8fCBzYmduQ2xhc3MgPT0gJ29taXR0ZWQgcHJvY2VzcycgfHwgc2JnbkNsYXNzID09ICd1bmNlcnRhaW4gcHJvY2VzcycpIHtcbiAgICByZXR1cm4gJ3NxdWFyZSc7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdwZXJ0dXJiaW5nIGFnZW50JyB8fCBzYmduQ2xhc3MgPT0gJ3RhZydcbiAgICB8fCBzYmduQ2xhc3MgPT0gJ3NvdXJjZSBhbmQgc2luaycpIHtcbiAgICByZXR1cm4gJ3BvbHlnb24nO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAnZGlzc29jaWF0aW9uJyB8fCBzYmduQ2xhc3MgPT0gJ2Fzc29jaWF0aW9uJyB8fCBzYmduQ2xhc3MgPT0gJ3NpbXBsZSBjaGVtaWNhbCcpIHtcbiAgICByZXR1cm4gJ2VsbGlwc2UnO1xuICB9XG5cbiAgaWYgKCBzYmduQ2xhc3MgPT0gJ251Y2xlaWMgYWNpZCBmZWF0dXJlJyB8fCBzYmduQ2xhc3MgPT0gJ21hY3JvbW9sZWN1bGUnKSB7XG4gICAgcmV0dXJuICdyb3VuZHJlY3RhbmdsZSc7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdjb21wbGV4Jykge1xuICAgIHJldHVybiAnY3V0cmVjdGFuZ2xlJztcbiAgfVxuICByZXR1cm4gJ2VsbGlwc2UnO1xufTtcblxuZWxlbWVudFN0eWxlLnNiZ25BcnJvd1NoYXBlID0gKGVkZ2UpID0+IHtcbiAgbGV0IHNiZ25DbGFzcyA9IHNiZ25EYXRhLnNiZ25DbGFzcyhlZGdlKTtcbiAgaWYgKHNiZ25DbGFzcyA9PSAnbmVjZXNzYXJ5IHN0aW11bGF0aW9uJykge1xuICAgIHJldHVybiAndHJpYW5nbGUtY3Jvc3MnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2luaGliaXRpb24nKSB7XG4gICAgcmV0dXJuICd0ZWUnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2NhdGFseXNpcycpIHtcbiAgICByZXR1cm4gJ2NpcmNsZSc7XG4gIH1cbiAgaWYgKHNiZ25DbGFzcyA9PSAnc3RpbXVsYXRpb24nIHx8IHNiZ25DbGFzcyA9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gJ3RyaWFuZ2xlJztcbiAgfVxuICBpZiAoc2JnbkNsYXNzID09ICdtb2R1bGF0aW9uJykge1xuICAgIHJldHVybiAnZGlhbW9uZCc7XG4gIH1cbiAgcmV0dXJuICdub25lJztcbn07XG5cbmVsZW1lbnRTdHlsZS5zYmduQ29udGVudCA9IChub2RlKSA9PiB7XG4gIGxldCBzYmduQ2xhc3MgPSBzYmduRGF0YS5zYmduQ2xhc3Mobm9kZSk7XG4gIGxldCBjb250ZW50ID0gJyc7XG5cbiAgaWYgKHNiZ25DbGFzcy5lbmRzV2l0aCgnIG11bHRpbWVyJykpIHtcbiAgICBzYmduQ2xhc3MgPSBzYmduQ2xhc3MucmVwbGFjZSgnIG11bHRpbWVyJywgJycpO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAnbWFjcm9tb2xlY3VsZScgfHwgc2JnbkNsYXNzID09ICdzaW1wbGUgY2hlbWljYWwnXG4gICAgICB8fCBzYmduQ2xhc3MgPT0gJ3BoZW5vdHlwZSdcbiAgICAgIHx8IHNiZ25DbGFzcyA9PSAndW5zcGVjaWZpZWQgZW50aXR5JyB8fCBzYmduQ2xhc3MgPT0gJ251Y2xlaWMgYWNpZCBmZWF0dXJlJ1xuICAgICAgfHwgc2JnbkNsYXNzID09ICdwZXJ0dXJiaW5nIGFnZW50JyB8fCBzYmduQ2xhc3MgPT0gJ3RhZycpIHtcbiAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdsYWJlbCcpID8gbm9kZS5kYXRhKCdsYWJlbCcpIDogJyc7XG4gIH1cbiAgZWxzZSBpZihzYmduQ2xhc3MgPT0gJ2NvbXBhcnRtZW50Jyl7XG4gICAgY29udGVudCA9IG5vZGUuZGF0YSgnbGFiZWwnKSA/IG5vZGUuZGF0YSgnbGFiZWwnKSA6ICcnO1xuICB9XG4gIGVsc2UgaWYoc2JnbkNsYXNzID09ICdjb21wbGV4Jyl7XG4gICAgaWYobm9kZS5jaGlsZHJlbigpLmxlbmd0aCA9PSAwKXtcbiAgICAgIGlmKG5vZGUuZGF0YSgnbGFiZWwnKSl7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmRhdGEoJ2xhYmVsJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKG5vZGUuZGF0YSgnaW5mb0xhYmVsJykpe1xuICAgICAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdpbmZvTGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdhbmQnKSB7XG4gICAgY29udGVudCA9ICdBTkQnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb3InKSB7XG4gICAgY29udGVudCA9ICdPUic7XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdub3QnKSB7XG4gICAgY29udGVudCA9ICdOT1QnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb21pdHRlZCBwcm9jZXNzJykge1xuICAgIGNvbnRlbnQgPSAnXFxcXFxcXFwnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAndW5jZXJ0YWluIHByb2Nlc3MnKSB7XG4gICAgY29udGVudCA9ICc/JztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufTtcblxuY29uc3QgZHluYW1pY0xhYmVsVGV4dFNpemUgPSAobm9kZUhlaWdodCwgc2l6ZUNvZWZmaWNpZW50ID0gMSkgPT4ge1xuICByZXR1cm4gKG5vZGVIZWlnaHQgLyAyLjQ1KSAqIHNpemVDb2VmZmljaWVudDtcbn07XG5cbmVsZW1lbnRTdHlsZS5sYWJlbFRleHRTaXplID0gKG5vZGUpID0+IHtcbiAgY29uc3Qgc2JnbkNsYXNzID0gc2JnbkRhdGEuc2JnbkNsYXNzKG5vZGUpO1xuICBjb25zdCBuaCA9IDQwOyAvLyBkb250IHVzZSBub2RlLndpZHRoKCkgbGVhZHMgdG8gZXhwZW5zaXZlIGN5Y2xpYyB1cGRhdGVzXG5cbiAgLy8gRGlydHkgbGVnYWN5IGhhY2suICBUaGVzZSB0eXBlcyBvZiBub2RlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGhhdmUgbGFiZWxzXG4gIC8vIGJ1dCBhcHBhcmVudGx5IHRoZXkgbmVlZCB0byBoYXZlIGEgdGV4dCBzaXplXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhc3NvY2lhdGlvbicgfHwgc2JnbkNsYXNzID09PSAnZGlzc29jaWF0aW9uJykge1xuICAgIHJldHVybiAyMDtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhbmQnIHx8IHNiZ25DbGFzcyA9PT0gJ29yJyB8fCBzYmduQ2xhc3MgPT09ICdub3QnKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNMYWJlbFRleHRTaXplKG5oLCAxKTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MuZW5kc1dpdGgoJ3Byb2Nlc3MnKSkge1xuICAgIHJldHVybiBkeW5hbWljTGFiZWxUZXh0U2l6ZShuaCwgMS41KTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MuaW5jbHVkZXMoJ2NvbXBsZXgnKSkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdjb21wYXJ0bWVudCcpIHtcbiAgICByZXR1cm4gNTA7XG4gIH1cblxuICByZXR1cm4gZHluYW1pY0xhYmVsVGV4dFNpemUobmgpO1xufTtcblxuZWxlbWVudFN0eWxlLmNhcmRpbmFsaXR5RGlzdGFuY2UgPSAoZWRnZSkgPT4ge1xuICBjb25zdCBzcmNQb3MgPSBlZGdlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gIGNvbnN0IHRndFBvcyA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdygoc3JjUG9zLnggLSB0Z3RQb3MueCksIDIpICsgTWF0aC5wb3coKHNyY1Bvcy55IC0gdGd0UG9zLnkpLCAyKSk7XG4gIHJldHVybiBkaXN0YW5jZSAqIDAuMTU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRTdHlsZTtcbiIsImNvbnN0IHRleHRXaWR0aCA9IHJlcXVpcmUoJ3RleHQtd2lkdGgnKTtcblxuY29uc3QgYmFzZVNoYXBlcyA9IHJlcXVpcmUoJy4vYmFzZVNoYXBlcy5qcycpO1xuXG5jb25zdCBzdGF0ZVZhckxhYmVsID0gKHN0YXRlVmFyKSA9PiB7XG4gIGNvbnN0IHZhcmlhYmxlID0gc3RhdGVWYXIuc3RhdGUudmFyaWFibGU7XG4gIGNvbnN0IHZhbHVlID0gc3RhdGVWYXIuc3RhdGUudmFsdWU7XG4gIGlmICh2YWx1ZSAmJiB2YXJpYWJsZSkge1xuICAgIHJldHVybiBgJHt2YWx1ZX1AJHt2YXJpYWJsZX1gO1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YXJpYWJsZSkge1xuICAgIHJldHVybiB2YXJpYWJsZTtcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuXG5jb25zdCBhdXhpbGlhcnlJdGVtcyA9IHtcblxuICBzdGF0ZVZhcmlhYmxlICh4LCB5LCByYWRpdXMsIHN0YXRlVmFyKSB7XG5cbiAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuXG4gICAgY29uc3Qgc3RhdGVWYXJTdHlsZSA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMS41JylcbiAgICAuc2V0KCdmaWxsJywgJ3doaXRlJylcbiAgICAuc2V0KCdmaWxsLW9wYWNpdHknLCAnMScpO1xuXG4gICAgY29uc3QgdGV4dFN0eWxlID0gbmV3IE1hcCgpXG4gICAgLnNldCgnYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgLnNldCgnZm9udC1zaXplJywgYCR7Zm9udFNpemV9YClcbiAgICAuc2V0KCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAuc2V0KCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgIC5zZXQoJ3N0cm9rZScsICdibGFjaycpO1xuXG4gICAgY29uc3QgdHcgPSB0ZXh0V2lkdGgoc3RhdGVWYXJMYWJlbChzdGF0ZVZhciwgeyBmYW1pbHk6IHRleHRTdHlsZS5nZXQoJ2ZvbnQtZmFtaWx5JyksIHNpemU6IGZvbnRTaXplfSksIDIwKTtcbiAgICBjb25zdCBzdGF0ZVZhcldpZHRoID0gTWF0aC5tYXgodHcgKiAuNSwgMjApO1xuXG4gICAgY29uc3Qgc3RhdGV2YXJpYWJsZVN2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmVsbGlwc2UoeCwgeSwgc3RhdGVWYXJXaWR0aCwgcmFkaXVzLCBzdGF0ZVZhclN0eWxlKX1cbiAgICAgICR7YmFzZVNoYXBlcy50ZXh0KHN0YXRlVmFyTGFiZWwoc3RhdGVWYXIpLCB4LCB5LCB0ZXh0U3R5bGUpfVxuICAgIGA7XG5cbiAgICByZXR1cm4gc3RhdGV2YXJpYWJsZVN2ZztcbiAgfSxcblxuICB1bml0T2ZJbmZvcm1hdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdW5pdEluZm8pIHtcblxuICAgIGNvbnN0IGZvbnRTaXplID0gMTI7XG4gICAgY29uc3QgdGV4dCA9IHVuaXRJbmZvLmxhYmVsLnRleHQ7XG5cbiAgICBjb25zdCB1aW5mb1JlY3RTdHlsZSA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMS41JylcbiAgICAuc2V0KCdmaWxsJywgJ3doaXRlJylcbiAgICAuc2V0KCdmaWxsLW9wYWNpdHknLCAnMScpO1xuXG4gICAgY29uc3QgdGV4dFN0eWxlID0gbmV3IE1hcCgpXG4gICAgLnNldCgnYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgLnNldCgnZm9udC1zaXplJywgYCR7Zm9udFNpemV9YClcbiAgICAuc2V0KCdmb250LWZhbWlseScsICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJylcbiAgICAuc2V0KCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgIC5zZXQoJ3N0cm9rZScsICdibGFjaycpO1xuXG4gICAgY29uc3QgdUluZm9XaWR0aCA9IHRleHRXaWR0aCh0ZXh0LCB7IGZhbWlseTogdGV4dFN0eWxlLmdldCgnZm9udC1mYW1pbHknKSwgc2l6ZTogZm9udFNpemV9KSArIDU7XG5cbiAgICBjb25zdCB1bml0T2ZJbmZvcm1hdGlvblN2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLnJvdW5kUmVjdGFuZ2xlKHggLSAodUluZm9XaWR0aCAvIDIpLCB5LCB1SW5mb1dpZHRoLCBoZWlnaHQsIHVpbmZvUmVjdFN0eWxlKX1cbiAgICAgICR7YmFzZVNoYXBlcy50ZXh0KHVuaXRJbmZvLmxhYmVsLnRleHQsIHgsIHkgKyAoIGhlaWdodCAvIDIpLCAgdGV4dFN0eWxlKX1cbiAgICBgO1xuXG4gICAgcmV0dXJuIHVuaXRPZkluZm9ybWF0aW9uU3ZnO1xuICB9LFxuXG4gIGNsb25lTWFya2VyIChub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHNoYXBlRm4sIHNoYXBlRm5BcmdzKSB7XG4gICAgY29uc3QgY2xpcElkID0gJ2Nsb25lbWFya2VyJztcblxuICAgIGNvbnN0IGNsb25lTWFya2VyU3R5bGUgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzEuNScpXG4gICAgLnNldCgnY2xpcC1wYXRoJywgYHVybCgjJHtjbGlwSWR9KWApXG4gICAgLnNldCgnZmlsbCcsICcjRDJEMkQyJyk7XG5cbiAgICBjb25zdCBjbG9uZU1hcmtlclN2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNsaXBQYXRoKGNsaXBJZCwgYmFzZVNoYXBlcy5yZWN0YW5nbGUsICBbMCwgMyAqIG5vZGVIZWlnaHQgLyA0LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIG5ldyBNYXAoKV0pfVxuICAgICAgJHtzaGFwZUZuKC4uLnNoYXBlRm5BcmdzLCBjbG9uZU1hcmtlclN0eWxlKX1cbiAgICBgO1xuXG4gICAgcmV0dXJuIGNsb25lTWFya2VyU3ZnO1xuICB9LFxuXG4gIG11bHRpbWVyIChzaGFwZUZuLCBzaGFwZUZuQXJncykge1xuICAgIGNvbnN0IGNsaXBJZCA9ICdtdWx0aW1lcic7XG5cbiAgICBjb25zdCBtdWx0aW1lclN0eWxlID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzMnKVxuICAgIC5zZXQoJ2NsaXAtcGF0aCcsIGB1cmwoIyR7Y2xpcElkfSlgKTtcblxuICAgIGNvbnN0IG11bHRpbWVyU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuY2xpcFBhdGgoY2xpcElkLCBzaGFwZUZuLCBzaGFwZUZuQXJncywgbmV3IE1hcCgpKX1cbiAgICAgICR7c2hhcGVGbiguLi5zaGFwZUZuQXJncywgbXVsdGltZXJTdHlsZSl9XG4gICAgYDtcbiAgICByZXR1cm4gbXVsdGltZXJTdmc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXV4aWxpYXJ5SXRlbXM7XG4iLCJjb25zdCBzdHlsZU1hcDJTdHIgPSByZXF1aXJlKCcuLi91dGlsL3N2Zy5qcycpLnN0eWxlTWFwMlN0cjtcblxubGV0IGJhc2VSZWN0YW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcjEsIHIyLCByMywgcjQsIHN0eWxlTWFwKSB7XG4gIHJldHVybiBgXG4gIDxwYXRoICR7c3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0gZD0nXG4gICAgTSAke3ggKyByMX0gJHt5fVxuICAgIEwgJHt4ICsgdyAtIHIyfSAke3l9IFEgJHt4ICsgd30gJHt5fSAke3ggKyB3fSAke3kgKyByMn1cbiAgICBMICR7eCArIHcgfSAke3kgKyBoIC0gcjN9IFEgJHt4ICsgd30gJHt5ICsgaH0gJHt4ICsgdyAtIHIzfSAke3kgKyBofVxuICAgIEwgJHt4ICsgcjR9ICR7eSArIGh9IFEgJHt4fSAke3kgKyBofSAke3h9ICR7eSArIGggLSByNH1cbiAgICBMICR7eH0gJHt5ICsgcjF9IFEgJHt4fSAke3l9ICR7eCArIHIxfSAke3l9XG4gICAgWidcbiAgLz5cbiAgYDtcbn07XG5cbmNvbnN0IGJhc2VTaGFwZXMgPSB7XG4gIGJhcnJlbCAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuXG4gICAgPGcgJHtzdHlsZU1hcDJTdHIoc3R5bGVNYXApfT5cbiAgICAgIDxwYXRoIGQ9XCJNICR7MCp3aWR0aCArIHh9ICR7LjAzKmhlaWdodCArIHl9IEwgJHswKndpZHRoICsgeH0gJHsuOTcqaGVpZ2h0ICsgeX0gUSAkezAuMDYqd2lkdGggKyB4fSAke2hlaWdodCArIHl9ICR7MC4yNSp3aWR0aCArIHh9ICR7aGVpZ2h0ICsgeX1cIi8+XG5cbiAgICAgIDxwYXRoIGQ9XCJNICR7MC4yNSp3aWR0aCArIHh9ICR7aGVpZ2h0ICsgeX0gTCAkezAuNzUqd2lkdGggKyB4fSAke2hlaWdodCArIHl9IFEgJHswLjk1KndpZHRoICsgeH0gJHtoZWlnaHQgKyB5fSAke3dpZHRoICsgeH0gJHswLjk1KmhlaWdodCArIHl9XCIvPlxuXG4gICAgICA8cGF0aCBkPVwiTSAke3dpZHRoICsgeH0gJHsuOTUqaGVpZ2h0ICsgeX0gTCAke3dpZHRoICsgeH0gJHswLjA1KmhlaWdodCArIHl9IFEgJHt3aWR0aCArIHh9ICR7MCpoZWlnaHQgKyB5fSAkezAuNzUqd2lkdGggKyB4fSAkezAqaGVpZ2h0ICsgeX1cIi8+XG5cbiAgICAgIDxwYXRoIGQ9XCJNICR7MC43NSp3aWR0aCArIHh9ICR7MCpoZWlnaHQgKyB5fSBMICR7MC4yNSp3aWR0aCArIHh9ICR7MCpoZWlnaHQgKyB5fSBRICR7MC4wNip3aWR0aCArIHh9ICR7MCpoZWlnaHQgKyB5fSAkezAqd2lkdGggKyB4fSAkezAuMDMqaGVpZ2h0ICsgeX1cIi8+XG4gICAgPC9nPlxuXG4gICAgYDtcbiAgfSxcblxuICBjaXJjbGUgKGN4LCBjeSwgciwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYDxjaXJjbGUgY3g9JyR7Y3h9JyBjeT0nJHtjeX0nIHI9JyR7cn0nICR7c3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0gLz5gO1xuICB9LFxuXG4gIGNsaXBQYXRoIChpZCwgYmFzZVNoYXBlRm4sIGJhc2VTaGFwZUZuQXJncywgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGRlZnM+XG4gICAgICAgIDxjbGlwUGF0aCBpZD0nJHtpZH0nICR7c3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0+XG4gICAgICAgICR7YmFzZVNoYXBlRm4oLi4uYmFzZVNoYXBlRm5BcmdzKX1cbiAgICAgICAgPC9jbGlwUGF0aD5cbiAgICAgIDwvZGVmcz5cbiAgICBgO1xuICB9LFxuXG4gIGNvbmNhdmVIZXhhZ29uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG4gICAgPHBvbHlnb24gJHtzdHlsZU1hcDJTdHIoc3R5bGVNYXApfVxuICAgICAgcG9pbnRzPScke3ggKyAwfSwgJHt5ICsgMH0sICR7eCArIHdpZHRofSwgJHt5ICsgMH0sICR7eCArIDAuODUqd2lkdGh9LCAke3kgKyAwLjUqaGVpZ2h0fSwgJHt4ICsgd2lkdGh9LCAke3kgKyBoZWlnaHR9LCAke3ggKyAwfSwgJHt5ICsgaGVpZ2h0fSwgJHsgeCArIDAuMTUqd2lkdGh9LCAke3kgKyAwLjUqaGVpZ2h0fSdcbiAgICAvPmA7XG4gIH0sXG5cbiAgY3V0UmVjdGFuZ2xlICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJMZW5ndGgsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGBcbiAgICA8cG9seWdvbiAke3N0eWxlTWFwMlN0cihzdHlsZU1hcCl9XG4gICAgICBwb2ludHM9J1xuICAgICAgJHt4ICsgMCp3aWR0aH0gJHt5ICsgY29ybmVyTGVuZ3RofSAke3ggKyBjb3JuZXJMZW5ndGh9ICR7eSArIDAqaGVpZ2h0fSAke3ggKyB3aWR0aCAtIGNvcm5lckxlbmd0aH0gJHt5ICsgMCpoZWlnaHR9ICR7eCArIHdpZHRofSAke3kgKyBjb3JuZXJMZW5ndGh9XG4gICAgICAke3ggKyB3aWR0aH0gJHt5ICsgaGVpZ2h0IC0gY29ybmVyTGVuZ3RofSAke3ggKyB3aWR0aCAtIGNvcm5lckxlbmd0aH0gJHt5ICsgaGVpZ2h0fSAke3ggKyBjb3JuZXJMZW5ndGh9ICR7eSArIGhlaWdodH0gJHt4ICsgMCp3aWR0aH0gJHt5ICsgaGVpZ2h0IC0gY29ybmVyTGVuZ3RofVxuICAgICAgJ1xuICAgIC8+XG4gICAgYDtcbiAgfSxcblxuICBlbGxpcHNlIChjeCwgY3ksIHJ4LCByeSwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGVsbGlwc2UgY3g9JyR7Y3h9JyBjeT0nJHtjeX0nIHJ4PScke3J4fScgcnk9JyR7cnl9JyAke3N0eWxlTWFwMlN0cihzdHlsZU1hcCl9IC8+XG4gICAgYDtcbiAgfSxcblxuICBoZXhhZ29uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG4gICAgPHBvbHlnb24gJHtzdHlsZU1hcDJTdHIoc3R5bGVNYXApfVxuICAgICAgcG9pbnRzPScke3ggKyAwfSwgJHt5ICsgMC41KmhlaWdodH0sICR7eCArIDAuMjUqd2lkdGh9LCAke3kgKyAwKmhlaWdodH0sICR7eCArIDAuNzUqd2lkdGh9LCAke3kgKyAwKmhlaWdodH0sICR7eCArIHdpZHRofSwgJHt5ICsgMC41KmhlaWdodH0sICR7eCArIDAuNzUqd2lkdGh9LCAke3kgKyBoZWlnaHR9LCAke3ggKyAwLjI1KndpZHRofSwgJHt5ICsgaGVpZ2h0fSdcbiAgICAvPmA7XG4gIH0sXG5cbiAgbGluZSAoeDEsIHkxLCB4MiwgeTIsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGA8bGluZSB4MT0nJHt4MX0nIHkxPScke3kxfScgeDI9JyR7eDJ9JyB5Mj0nJHt5Mn0nICR7c3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0gLz5gO1xuICB9LFxuXG4gIHJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYmFzZVJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCAwLCAwLCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgcm91bmRCb3R0b21SZWN0YW5nbGUgKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGJhc2VSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgLjMqaGVpZ2h0LCAuMypoZWlnaHQsIHN0eWxlTWFwKTtcbiAgfSxcblxuICByb3VuZFJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYmFzZVJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAuMSp3aWR0aCwgLjEqd2lkdGgsIC4xKndpZHRoLCAuMSp3aWR0aCwgc3R5bGVNYXApO1xuICB9LFxuXG4gIHNxdWFyZSAoeCwgeSwgbGVuZ3RoLCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBiYXNlUmVjdGFuZ2xlKHgsIHksIGxlbmd0aCwgbGVuZ3RoLCAwLCAwLCAwLCAwLCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgdGV4dCAodCwgeCwgeSwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYDx0ZXh0IHg9JyR7eH0nIHk9JyR7eX0nICR7c3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0+JHt0fTwvdGV4dD5gO1xuICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2hhcGVzO1xuIiwiY29uc3Qgc3ZnU3RyID0gcmVxdWlyZSgnLi4vdXRpbC9zdmcnKS5zdmdTdHI7XG5jb25zdCBzYmduRGF0YSA9IHJlcXVpcmUoJy4uL3V0aWwvc2JnbicpO1xuXG5jb25zdCBhdXhpbGlhcnlJdGVtcyA9IHJlcXVpcmUoJy4vYXV4aWxpYXJ5SXRlbXMnKTtcbmNvbnN0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMnKTtcblxuY29uc3QgY29udGFpbmVyTm9kZXMgPSB7XG5cbiAgY29tcGFydG1lbnQgKG5vZGUpIHtcbiAgICBjb25zdCBuaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgICBjb25zdCBudyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgTWFwKClcbiAgICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICczLjc1JylcbiAgICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpO1xuXG4gICAgY29uc3QgdW5pdEluZm9zID0gc2JnbkRhdGEuZ2V0VW5pdEluZm9zKG5vZGUpO1xuICAgIGNvbnN0IHVpbmZvVyA9IE1hdGgubWluKDEwMCwgMC40Km53KTtcbiAgICBjb25zdCB1aW5mb0ggPSBNYXRoLm1pbigyNSwgMC4yKm5oKTtcblxuICAgIGxldCBzaGFwZUFyZ3MgPSBbMTAsIDUsIG53IC0gMjAsIG5oIC0gMTBdO1xuXG4gICAgaWYgKHVuaXRJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbMTAsICh1aW5mb0ggLyAyKSwgbncgLSAyMCwgbmggLSAxMF07XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGFydG1lbnRTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5iYXJyZWwoLi4uc2hhcGVBcmdzLCBzdHlsZSl9XG4gICAgICAke3VuaXRJbmZvcy5sZW5ndGggPiAwID8gYXV4aWxpYXJ5SXRlbXMudW5pdE9mSW5mb3JtYXRpb24oKG5oIC8gMyksIDUsIHVpbmZvVywgdWluZm9ILCB1bml0SW5mb3NbMF0pIDogJyd9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKGNvbXBhcnRtZW50U3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbmVyTm9kZXM7XG4iLCJjb25zdCBtZW1vaXplID0gcmVxdWlyZSgnbG9kYXNoLm1lbW9pemUnKTtcblxuY29uc3QgYmFzZVNoYXBlcyA9IHJlcXVpcmUoJy4vYmFzZVNoYXBlcycpO1xuY29uc3QgYXV4aWxpYXJ5SXRlbXMgPSByZXF1aXJlKCcuL2F1eGlsaWFyeUl0ZW1zJyk7XG5cbmNvbnN0IHN2Z1N0ciA9IHJlcXVpcmUoJy4uL3V0aWwvc3ZnJykuc3ZnU3RyO1xuY29uc3QgZ2V0VW5pdEluZm9zID0gcmVxdWlyZSgnLi4vdXRpbC9zYmduJykuZ2V0VW5pdEluZm9zO1xuY29uc3QgZ2V0U3RhdGVWYXJzID0gcmVxdWlyZSgnLi4vdXRpbC9zYmduJykuZ2V0U3RhdGVWYXJzO1xuY29uc3QgaGFzQ2xvbmVtYXJrZXIgPSByZXF1aXJlKCcuLi91dGlsL3NiZ24nKS5oYXNDbG9uZW1hcmtlcjtcbmNvbnN0IGlzTXVsdGltZXIgPSByZXF1aXJlKCcuLi91dGlsL3NiZ24nKS5pc011bHRpbWVyO1xuY29uc3QgZGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uL2RpbWVuc2lvbnMnKTtcblxuXG5jb25zdCBlbnRpdHlQb29sTm9kZXMgPSB7XG5cbiAgdW5zcGVjaWZpZWRFbnRpdHkgKG5vZGUpIHtcbiAgICBjb25zdCB7dzogbncsIGg6IG5ofSA9IGRpbWVuc2lvbnMuZ2V0KG5vZGUpO1xuXG4gICAgY29uc3Qgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzInKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgbGV0IHNoYXBlQXJncyA9IFtudyAvIDIsIG5oIC8gMiwgKCBuaCAtIDIgKSAvIDIsICggbncgLSAyICkgLyAyXTtcblxuICAgIGxldCB1bnNwZWNFbnRpdHlTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5lbGxpcHNlKC4uLnNoYXBlQXJncywgc3R5bGVNYXApfVxuICAgICAgJHtoYXNDbG9uZW1hcmtlcihub2RlKSA/IGF1eGlsaWFyeUl0ZW1zLmNsb25lTWFya2VyKG53LCBuaCwgYmFzZVNoYXBlcy5lbGxpcHNlLCBzaGFwZUFyZ3MpIDogJyd9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHVuc3BlY0VudGl0eVN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuXG4gIHNpbXBsZUNoZW1pY2FsIChub2RlKSB7XG4gICAgY29uc3Qge3c6IG53LCBoOiBuaH0gPSBkaW1lbnNpb25zLmdldChub2RlKTtcblxuXG5cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICd3aGl0ZScpXG4gICAgLnNldCgnZmlsbC1vcGFjaXR5JywgJzEnKTtcblxuICAgIGNvbnN0IG11bHRpbWVyU2hhcGVBcmdzID0gWyhudyArIDMpIC8gMiwgKG5oICsgMykgLyAyLCAoTWF0aC5taW4obncsIG5oKSAtIDIgLSA1KSAvIDJdO1xuICAgIGxldCBzaGFwZUFyZ3MgPSBbKG53KSAvIDIsIChuaCkgLyAyLCAoTWF0aC5taW4obmgsIG53KSAtIDIpIC8gMl07XG5cbiAgICBjb25zdCB1SW5mb3MgPSBnZXRVbml0SW5mb3Mobm9kZSk7XG4gICAgaWYgKHVJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbKG53KSAvIDIsIChuaCkgLyAyLCAoTWF0aC5taW4obmgsIG53KSAtIDIgIC0gNSkgLyAyXTtcbiAgICB9XG5cbiAgICBpZiAoaXNNdWx0aW1lcihub2RlKSkge1xuICAgICAgc2hhcGVBcmdzID0gWyhudyAtIDMpIC8gMiwgKG5oIC0gMykgLyAyLCAoTWF0aC5taW4obmgsIG53KSAtIDIgLSA3KSAvIDJdO1xuICAgIH1cblxuICAgIGNvbnN0IHNpbXBsZUNoZW1pY2FsU3ZnID1cbiAgICBgXG4gICAgICAke2lzTXVsdGltZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5tdWx0aW1lcihiYXNlU2hhcGVzLmNpcmNsZSwgbXVsdGltZXJTaGFwZUFyZ3MpIDogJyd9XG4gICAgICAke2Jhc2VTaGFwZXMuY2lyY2xlKC4uLnNoYXBlQXJncywgc3R5bGVNYXApfVxuICAgICAgJHtoYXNDbG9uZW1hcmtlcihub2RlKSA/IGF1eGlsaWFyeUl0ZW1zLmNsb25lTWFya2VyKG53LCBuaCwgYmFzZVNoYXBlcy5jaXJjbGUsIHNoYXBlQXJncykgOiAnJ31cbiAgICAgICR7dUluZm9zLmxlbmd0aCA+IDAgPyBhdXhpbGlhcnlJdGVtcy51bml0T2ZJbmZvcm1hdGlvbigobncgLyAyKSwgMSwgMC40Km53LCAwLjIqbmgsIHVJbmZvc1swXSkgOiAnJ31cbiAgICBgO1xuXG4gICAgcmV0dXJuIHN2Z1N0cihzaW1wbGVDaGVtaWNhbFN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuXG4gIG1hY3JvbW9sZWN1bGU6IG1lbW9pemUoIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCB7dzogbncsIGg6IG5ofSA9IGRpbWVuc2lvbnMuZ2V0KG5vZGUpO1xuXG4gICAgY29uc3Qgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzInKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpXG4gICAgLnNldCgnZmlsbCcsICd3aGl0ZScpXG4gICAgLnNldCgnZmlsbC1vcGFjaXR5JywgJzEnKTtcblxuICAgIGNvbnN0IG11bHRpbWVyU2hhcGVBcmdzID0gWzE1LCAxMCwgLjgqbncsIC44Km5oXTtcbiAgICBsZXQgc2hhcGVBcmdzID0gWzUsIDUsIG53IC0gMTAsIG5oIC0gMTBdO1xuXG4gICAgY29uc3QgdUluZm9zID0gZ2V0VW5pdEluZm9zKG5vZGUpO1xuICAgIGNvbnN0IHNWYXJzID0gZ2V0U3RhdGVWYXJzKG5vZGUpO1xuXG4gICAgaWYgKHVJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbNSwgNSwgLjkqbncsIC45Km5oXTtcbiAgICB9XG5cbiAgICBpZiAoc1ZhcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2hhcGVBcmdzWzNdID0gLjg1Km5oO1xuICAgIH1cblxuICAgIGlmIChpc011bHRpbWVyKG5vZGUpKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbNSwgNSwgLjgzKm53LCAuNzgqbmhdO1xuICAgIH1cblxuICAgIGxldCBtYWNyb21vbGVjdWxlU3ZnID1cbiAgICBgXG4gICAgICAke2lzTXVsdGltZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5tdWx0aW1lcihiYXNlU2hhcGVzLnJvdW5kUmVjdGFuZ2xlLCBtdWx0aW1lclNoYXBlQXJncykgOiAnJ31cbiAgICAgICR7YmFzZVNoYXBlcy5yb3VuZFJlY3RhbmdsZSguLi5zaGFwZUFyZ3MsIHN0eWxlTWFwKX1cbiAgICAgICR7aGFzQ2xvbmVtYXJrZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5jbG9uZU1hcmtlcihudyAtIDMsIG5oIC0gMywgYmFzZVNoYXBlcy5yb3VuZFJlY3RhbmdsZSwgc2hhcGVBcmdzKSA6ICcnfVxuICAgICAgJHt1SW5mb3MubGVuZ3RoID4gMCA/IGF1eGlsaWFyeUl0ZW1zLnVuaXRPZkluZm9ybWF0aW9uKChudyAvIDMpLCAxLCAwLjQqbncsIDAuMipuaCwgdUluZm9zWzBdKSA6ICcnfVxuICAgICAgJHtzVmFycy5sZW5ndGggPiAwID8gYXV4aWxpYXJ5SXRlbXMuc3RhdGVWYXJpYWJsZSgoMiAqIG53IC8gNCksIG5oIC0gKDAuMjI1Km5oIC8gMiksIDAuMSpuaCwgc1ZhcnNbMF0pIDogJyd9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKG1hY3JvbW9sZWN1bGVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSwgZnVuY3Rpb24gbWFjcm9tb2xlY3VsZVNoYXBlS2V5KCBub2RlICl7XG4gICAgcmV0dXJuICcnICtcbiAgICAgIG5vZGUub3V0ZXJXaWR0aCgpICsgJyQnICtcbiAgICAgIG5vZGUub3V0ZXJIZWlnaHQoKSArICckJyArXG4gICAgICBKU09OLnN0cmluZ2lmeSggbm9kZS5kYXRhKCkgKVxuICAgIDtcbiAgfSApLFxuXG4gIG51Y2xlaWNBY2lkRmVhdHVyZSAobm9kZSkge1xuICAgIGNvbnN0IHt3OiBudywgaDogbmh9ID0gZGltZW5zaW9ucy5nZXQobm9kZSk7XG5cblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnd2hpdGUnKVxuICAgIC5zZXQoJ2ZpbGwtb3BhY2l0eScsICcxJyk7XG5cbiAgICBjb25zdCBtdWx0aW1lclNoYXBlQXJncyA9IFsxNSwgMTAsIC44Km53LCAuOCpuaF07XG4gICAgbGV0IHNoYXBlQXJncyA9IFsxLjUsIDEuNSwgbncgLSAzLCBuaCAtIDNdO1xuXG4gICAgY29uc3QgdUluZm9zID0gZ2V0VW5pdEluZm9zKG5vZGUpO1xuICAgIGNvbnN0IHNWYXJzID0gZ2V0U3RhdGVWYXJzKG5vZGUpO1xuXG4gICAgaWYgKHVJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbNSwgNSwgLjkqbncsIC44OCpuaF07XG4gICAgfVxuXG4gICAgaWYgKHNWYXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNoYXBlQXJnc1szXSA9IC44NSpuaDtcbiAgICB9XG5cbiAgICBpZiAoaXNNdWx0aW1lcihub2RlKSkge1xuICAgICAgc2hhcGVBcmdzID0gWzUsIDUsIC44MypudywgLjc4Km5oXTtcbiAgICB9XG5cbiAgICBsZXQgbnVjbGVpY0FjaWRGZWF0dXJlU3ZnID1cbiAgICBgXG4gICAgICAke2lzTXVsdGltZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5tdWx0aW1lcihiYXNlU2hhcGVzLnJvdW5kQm90dG9tUmVjdGFuZ2xlLCBtdWx0aW1lclNoYXBlQXJncykgOiAnJ31cbiAgICAgICR7YmFzZVNoYXBlcy5yb3VuZEJvdHRvbVJlY3RhbmdsZSguLi5zaGFwZUFyZ3MsIHN0eWxlTWFwKX1cbiAgICAgICR7aGFzQ2xvbmVtYXJrZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5jbG9uZU1hcmtlcihudywgbmgsIGJhc2VTaGFwZXMucm91bmRCb3R0b21SZWN0YW5nbGUsIHNoYXBlQXJncykgOiAnJ31cbiAgICAgICR7dUluZm9zLmxlbmd0aCA+IDAgPyBhdXhpbGlhcnlJdGVtcy51bml0T2ZJbmZvcm1hdGlvbigobncgLyAzKSwgMSwgMC40Km53LCAwLjIqbmgsIHVJbmZvc1swXSkgOiAnJ31cbiAgICAgICR7c1ZhcnMubGVuZ3RoID4gMCA/IGF1eGlsaWFyeUl0ZW1zLnN0YXRlVmFyaWFibGUoKDIgKiBudyAvIDQpLCBuaCAtICgwLjIyNSpuaCAvIDIpLCAwLjEqbmgsIHNWYXJzWzBdKSA6ICcnfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihudWNsZWljQWNpZEZlYXR1cmVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBjb21wbGV4IChub2RlKSB7XG4gICAgbGV0IG53ID0gbm9kZS53aWR0aCgpO1xuICAgIGxldCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgICBsZXQgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzInKVxuICAgIC5zZXQoJ2ZpbGwnLCAnd2hpdGUnKVxuICAgIC5zZXQoJ2ZpbGwtb3BhY2l0eScsICcxJyk7XG5cbiAgICBsZXQgc2hhcGVBcmdzID0gWzEsIDIsIG53IC0gMiwgbmggLSA1LCAxMF07XG4gICAgY29uc3QgbXVsdGltZXJTaGFwZUFyZ3MgPSBbMTUsIDE1LCAuOTMqbncsIC45MypuaCwgMTBdO1xuXG4gICAgY29uc3QgdUluZm9zID0gZ2V0VW5pdEluZm9zKG5vZGUpO1xuICAgIGNvbnN0IHNWYXJzID0gZ2V0U3RhdGVWYXJzKG5vZGUpO1xuXG4gICAgaWYgKHVJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3NbMF0gKz0gNTtcbiAgICAgIHNoYXBlQXJnc1sxXSArPSAxMDtcbiAgICAgIHNoYXBlQXJnc1syXSAqPSAuOTU7XG4gICAgICBzaGFwZUFyZ3NbM10gKj0gLjk7XG4gICAgfVxuXG4gICAgaWYgKHNWYXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNoYXBlQXJnc1szXSA9IC44NSpuaDtcbiAgICB9XG5cbiAgICBpZiAoaXNNdWx0aW1lcihub2RlKSkge1xuICAgICAgc2hhcGVBcmdzID0gWzUsIDEwLCAuOTMqbncsIC45Km5oLCAxMF07XG4gICAgfVxuXG4gICAgY29uc3QgdWluZm9XID0gTWF0aC5taW4oMTAwLCAwLjQqbncpO1xuICAgIGNvbnN0IHVpbmZvSCA9IE1hdGgubWluKDI1LCAwLjIqbmgpO1xuICAgIGNvbnN0IHNWYXJSYWRpdXMgPSAxNTtcblxuICAgIGxldCBjb21wbGV4U3ZnID1cbiAgICBgXG4gICAgICAke2lzTXVsdGltZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5tdWx0aW1lcihiYXNlU2hhcGVzLmN1dFJlY3RhbmdsZSwgbXVsdGltZXJTaGFwZUFyZ3MpIDogJyd9XG4gICAgICAke2Jhc2VTaGFwZXMuY3V0UmVjdGFuZ2xlKC4uLnNoYXBlQXJncywgc3R5bGVNYXApfVxuICAgICAgJHtoYXNDbG9uZW1hcmtlcihub2RlKSA/IGF1eGlsaWFyeUl0ZW1zLmNsb25lTWFya2VyKG53LCBuaCwgYmFzZVNoYXBlcy5jdXRSZWN0YW5nbGUsIHNoYXBlQXJncykgOiAnJ31cbiAgICAgICR7dUluZm9zLmxlbmd0aCA+IDAgPyBhdXhpbGlhcnlJdGVtcy51bml0T2ZJbmZvcm1hdGlvbigobncgLyAzKSwgMSwgdWluZm9XLCB1aW5mb0gsIHVJbmZvc1swXSkgOiAnJ31cbiAgICAgICR7c1ZhcnMubGVuZ3RoID4gMCA/IGF1eGlsaWFyeUl0ZW1zLnN0YXRlVmFyaWFibGUoKDIgKiBudyAvIDQpLCBzaGFwZUFyZ3NbM10gKyBzaGFwZUFyZ3NbMV0gLSA1LCBzVmFyUmFkaXVzLCBzVmFyc1swXSkgOiAnJ31cbiAgICBgO1xuICAgIHJldHVybiBzdmdTdHIoY29tcGxleFN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuXG4gIHNvdXJjZUFuZFNpbmsgKG5vZGUpIHtcbiAgICBjb25zdCB7dzogbncsIGg6IG5ofSA9IGRpbWVuc2lvbnMuZ2V0KG5vZGUpO1xuXG5cbiAgICBjb25zdCBjZW50ZXJYID0gbncgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBuaCAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gKG53IC0gMikgLyAyO1xuXG4gICAgY29uc3Qgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLWxpbmVjYXAnLCAnc3F1YXJlJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMS41JylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGNvbnN0IHNoYXBlQXJncyA9IFtjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXNdO1xuXG4gICAgY29uc3Qgc291cmNlQW5kU2lua1N2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZSguLi5zaGFwZUFyZ3MsIHN0eWxlTWFwKX1cbiAgICAgICR7aGFzQ2xvbmVtYXJrZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5jbG9uZU1hcmtlcihudywgbmgsIGJhc2VTaGFwZXMuY2lyY2xlLCBzaGFwZUFyZ3MpIDogJyd9XG4gICAgICAke2Jhc2VTaGFwZXMubGluZSgwLCBuaCwgbncsIDAsIHN0eWxlTWFwKX1cbiAgICBgO1xuXG4gICAgcmV0dXJuIHN2Z1N0cihzb3VyY2VBbmRTaW5rU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgcGVydHVyYmluZ0FnZW50IChub2RlKSB7XG4gICAgY29uc3Qge3c6IG53LCBoOiBuaH0gPSBkaW1lbnNpb25zLmdldChub2RlKTtcblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCBzaGFwZUFyZ3MgPSBbMSwgMSwgbncgLSA0LCBuaCAtIDJdO1xuXG4gICAgY29uc3QgdUluZm9zID0gZ2V0VW5pdEluZm9zKG5vZGUpO1xuXG4gICAgaWYgKHVJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICBzaGFwZUFyZ3MgPSBbNSwgNSwgLjkqbncsIC45Km5oXTtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJ0dXJiaW5nQWdlbnRTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jb25jYXZlSGV4YWdvbiguLi5zaGFwZUFyZ3MsIHN0eWxlTWFwKX1cbiAgICAgICR7aGFzQ2xvbmVtYXJrZXIobm9kZSkgPyBhdXhpbGlhcnlJdGVtcy5jbG9uZU1hcmtlcihudyAtIDMsIG5oIC0gMywgYmFzZVNoYXBlcy5jb25jYXZlSGV4YWdvbiwgc2hhcGVBcmdzKSA6ICcnfVxuICAgICAgJHt1SW5mb3MubGVuZ3RoID4gMCA/IGF1eGlsaWFyeUl0ZW1zLnVuaXRPZkluZm9ybWF0aW9uKChudyAvIDMpLCAxLCAwLjQqbncsIDAuMipuaCwgdUluZm9zWzBdKSA6ICcnfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihwZXJ0dXJiaW5nQWdlbnRTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRpdHlQb29sTm9kZXM7XG4iLCJjb25zdCBjb250YWluZXJOb2RlcyA9IHJlcXVpcmUoJy4vY29udGFpbmVyTm9kZXMuanMnKTtcbmNvbnN0IGVudGl0eVBvb2xOb2RlcyA9IHJlcXVpcmUoJy4vZW50aXR5UG9vbE5vZGVzLmpzJyk7XG5jb25zdCBwcm9jZXNzTm9kZXMgPSByZXF1aXJlKCcuL3Byb2Nlc3NOb2Rlcy5qcycpO1xuXG5jb25zdCBzYmduRGF0YSA9IHJlcXVpcmUoJy4uL3V0aWwvc2Jnbi5qcycpO1xuXG5jb25zdCBzYmduTm9kZVNoYXBlTWFwID0gbmV3IE1hcCgpXG4vLyBwcm9jZXNzIG5vZGVzXG4uc2V0KCdwcm9jZXNzJywgcHJvY2Vzc05vZGVzLnByb2Nlc3MpXG4uc2V0KCdvbWl0dGVkIHByb2Nlc3MnLCBwcm9jZXNzTm9kZXMucHJvY2Vzcylcbi5zZXQoJ3VuY2VydGFpbiBwcm9jZXNzJywgcHJvY2Vzc05vZGVzLnByb2Nlc3MpXG4uc2V0KCdhc3NvY2lhdGlvbicsIHByb2Nlc3NOb2Rlcy5hc3NvY2lhdGlvbilcbi5zZXQoJ2Rpc3NvY2lhdGlvbicsIHByb2Nlc3NOb2Rlcy5kaXNzb2NpYXRpb24pXG4uc2V0KCdwaGVub3R5cGUnLCBwcm9jZXNzTm9kZXMucGhlbm90eXBlKVxuXG4vLyBlbnRpdHkgcG9vbCBub2Rlc1xuLnNldCgnc291cmNlIGFuZCBzaW5rJywgZW50aXR5UG9vbE5vZGVzLnNvdXJjZUFuZFNpbmspXG4uc2V0KCd1bnNwZWNpZmllZCBlbnRpdHknLCBlbnRpdHlQb29sTm9kZXMudW5zcGVjaWZpZWRFbnRpdHkpXG4uc2V0KCdzaW1wbGUgY2hlbWljYWwnLCBlbnRpdHlQb29sTm9kZXMuc2ltcGxlQ2hlbWljYWwpXG4uc2V0KCdzaW1wbGUgY2hlbWljYWwgbXVsdGltZXInLCBlbnRpdHlQb29sTm9kZXMuc2ltcGxlQ2hlbWljYWwpXG4uc2V0KCdtYWNyb21vbGVjdWxlJywgZW50aXR5UG9vbE5vZGVzLm1hY3JvbW9sZWN1bGUpXG4uc2V0KCdtYWNyb21vbGVjdWxlIG11bHRpbWVyJywgZW50aXR5UG9vbE5vZGVzLm1hY3JvbW9sZWN1bGUpXG4uc2V0KCdudWNsZWljIGFjaWQgZmVhdHVyZScsIGVudGl0eVBvb2xOb2Rlcy5udWNsZWljQWNpZEZlYXR1cmUpXG4uc2V0KCdudWNsZWljIGFjaWQgZmVhdHVyZSBtdWx0aW1lcicsIGVudGl0eVBvb2xOb2Rlcy5udWNsZWljQWNpZEZlYXR1cmUpXG4uc2V0KCdjb21wbGV4JywgZW50aXR5UG9vbE5vZGVzLmNvbXBsZXgpXG4uc2V0KCdjb21wbGV4IG11bHRpbWVyJywgZW50aXR5UG9vbE5vZGVzLmNvbXBsZXgpXG4uc2V0KCdwZXJ0dXJiaW5nIGFnZW50JywgZW50aXR5UG9vbE5vZGVzLnBlcnR1cmJpbmdBZ2VudClcblxuLy8gY29udGFpbmVyIG5vZGVzXG4uc2V0KCdjb21wYXJ0bWVudCcsIGNvbnRhaW5lck5vZGVzLmNvbXBhcnRtZW50KTtcblxuXG5jb25zdCBkcmF3ID0gKG5vZGUpID0+IHtcbiAgY29uc3Qgc2JnbkNsYXNzID0gc2JnbkRhdGEuc2JnbkNsYXNzKG5vZGUpO1xuICBsZXQgc2hhcGVGbiA9IHNiZ25Ob2RlU2hhcGVNYXAuZ2V0KHNiZ25DbGFzcyk7XG4gIGlmIChzaGFwZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3NiZ25DbGFzc30gZG9lcyBub3QgaGF2ZSBhIHNoYXBlIGltcGxlbWVudGF0aW9uYCk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlRm4obm9kZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhd1xufTsiLCJjb25zdCBiYXNlU2hhcGVzID0gcmVxdWlyZSgnLi9iYXNlU2hhcGVzJyk7XG5jb25zdCBhdXhpbGlhcnlJdGVtcyA9IHJlcXVpcmUoJy4vYXV4aWxpYXJ5SXRlbXMnKTtcblxuY29uc3Qgc3ZnU3RyID0gcmVxdWlyZSgnLi4vdXRpbC9zdmcnKS5zdmdTdHI7XG5jb25zdCBkaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vZGltZW5zaW9ucycpO1xuXG5jb25zdCBwcm9jZXNzTm9kZXMgPSB7XG5cbiAgcHJvY2VzcyAobm9kZSkge1xuICAgIGNvbnN0IHt3OiBudywgaDogbmh9ID0gZGltZW5zaW9ucy5nZXQobm9kZSk7XG5cbiAgICBjb25zdCBzcXVhcmVTdHlsZSA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBjb25zdCBwcm9jZXNzU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuc3F1YXJlKDEsIDEsIE1hdGgubWluKG53LCBuaCkgLSAyLCBzcXVhcmVTdHlsZSl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHByb2Nlc3NTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBhc3NvY2lhdGlvbiAobm9kZSkge1xuICAgIGNvbnN0IHt3OiBudywgaDogbmh9ID0gZGltZW5zaW9ucy5nZXQobm9kZSk7XG5cbiAgICBjb25zdCBjZW50ZXJYID0gbncgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBuaCAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gKE1hdGgubWluKG53LCBuaCkgLSAyKSAvIDI7XG5cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICcjNkE2QTZBJylcbiAgICAuc2V0KCdmaWxsLW9wYWNpdHknLCAnMCcpO1xuXG4gICAgY29uc3QgYXNzb2NpYXRpb25TdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKGFzc29jaWF0aW9uU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgZGlzc29jaWF0aW9uIChub2RlKSB7XG4gICAgY29uc3Qge3c6IG53LCBoOiBuaH0gPSBkaW1lbnNpb25zLmdldChub2RlKTtcblxuICAgIGNvbnN0IGNlbnRlclggPSBudyAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IG5oIC8gMjtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IChNYXRoLm1pbihudywgbmgpIC0gMikgLyAyO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gKE1hdGgubWluKG53LCBuaCkgLSAyKSAvIDM7XG5cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBjb25zdCBkaXNzb2NpYXRpb25TdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0eWxlTWFwKX1cbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgaW5uZXJSYWRpdXMsIHN0eWxlTWFwKX1cbiAgICBgO1xuICAgIHJldHVybiBzdmdTdHIoZGlzc29jaWF0aW9uU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgcGhlbm90eXBlIChub2RlKSB7XG4gICAgY29uc3Qge3c6IG53LCBoOiBuaH0gPSBkaW1lbnNpb25zLmdldChub2RlKTtcblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICczJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGNvbnN0IHNoYXBlQXJncyA9IFsxLCAxLCBudyAtIDMsIG5oIC0gM107XG5cbiAgICBsZXQgcGhlbm90eXBlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuaGV4YWdvbiguLi5zaGFwZUFyZ3MsIHN0eWxlTWFwKX1cbiAgICAgICR7bm9kZS5kYXRhKCdjbG9uZW1hcmtlcicpID8gYXV4aWxpYXJ5SXRlbXMuY2xvbmVNYXJrZXIobncgLSAzLCBuaCAtIDMsIGJhc2VTaGFwZXMuaGV4YWdvbiwgc2hhcGVBcmdzKSA6ICcnfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihwaGVub3R5cGVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzTm9kZXM7XG4iLCJjb25zdCBlbGVtZW50U3R5bGUgPSByZXF1aXJlKCcuL2VsZW1lbnQuanMnKTtcblxuY29uc3Qgc2JnblNoYXBlcyA9IHJlcXVpcmUoJy4vZ2x5cGgnKTtcbmNvbnN0IHNiZ25EaW1lbnNpb25zID0gcmVxdWlyZSgnLi9kaW1lbnNpb25zJyk7XG5cbmNvbnN0IGlzTXVsdGltZXIgPSByZXF1aXJlKCcuL3V0aWwvc2Jnbi5qcycpLmlzTXVsdGltZXI7XG5jb25zdCBoYXNBdXhJdGVtcyA9IHJlcXVpcmUoJy4vdXRpbC9zYmduLmpzJykuaGFzQXV4SXRlbXM7XG5cbnZhciBzYmduU3R5bGVTaGVldCA9IGZ1bmN0aW9uIChjeXRvc2NhcGUpIHtcblxuICByZXR1cm4gY3l0b3NjYXBlLnN0eWxlc2hlZXQoKVxuICAgICAgICAvLyBnZW5lcmFsIG5vZGUgc3R5bGVcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlJzogKG5vZGUpID0+IGVsZW1lbnRTdHlsZS5zYmduU2hhcGUobm9kZSksXG4gICAgICAgICAgJ2NvbnRlbnQnOiAobm9kZSkgPT4gZWxlbWVudFN0eWxlLnNiZ25Db250ZW50KG5vZGUpLFxuICAgICAgICAgICdmb250LXNpemUnOiAobm9kZSkgPT4gZWxlbWVudFN0eWxlLmxhYmVsVGV4dFNpemUobm9kZSksXG4gICAgICAgICAgJ3RleHQtdmFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDEuNSxcbiAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyM1NTUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNmNmY2ZjYnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjUsXG4gICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ29wYWNpdHknOiAxXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZTpzZWxlY3RlZCcpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGU6YWN0aXZlJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDAuNywgJ292ZXJsYXktY29sb3InOiAnI2Q2NzYxNCcsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6ICcxNCdcbiAgICAgICAgfSlcblxuXG4gICAgICAgIC8vIGV2ZXJ5IHByb2Nlc3MvZW50aXR5IHBvb2wgbm9kZSBuZWVkcyB0aGVzZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5zZWxlY3RvcihgXG4gICAgICAgICAgbm9kZVtjbGFzcz1cInByb2Nlc3NcIl0sIG5vZGVbY2xhc3M9XCJ1bmNlcnRhaW4gcHJvY2Vzc1wiXSwgbm9kZVtjbGFzcz1cIm9taXR0ZWQgcHJvY2Vzc1wiXSxcbiAgICAgICAgICBub2RlW2NsYXNzPVwiYXNzb2NpYXRpb25cIl0sIG5vZGVbY2xhc3M9XCJkaXNzb2NpYXRpb25cIl0sXG4gICAgICAgICAgbm9kZVtjbGFzcz1cInBoZW5vdHlwZVwiXSxcbiAgICAgICAgICBub2RlW2NsYXNzPVwic291cmNlIGFuZCBzaW5rXCJdLFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJwZXJ0dXJiaW5nIGFnZW50XCJdLFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJ1bnNwZWNpZmllZCBlbnRpdHlcIl0sXG4gICAgICAgICAgbm9kZVtjbGFzcz1cIm51Y2xlaWMgYWNpZCBmZWF0dXJlXCJdLCBub2RlW2NsYXNzPVwibnVjbGVpYyBhY2lkIGZlYXR1cmUgbXVsdGltZXJcIl0sXG4gICAgICAgICAgbm9kZVtjbGFzcz1cIm1hY3JvbW9sZWN1bGVcIl0sIG5vZGVbY2xhc3M9XCJtYWNyb21vbGVjdWxlIG11bHRpbWVyXCJdLFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJzaW1wbGUgY2hlbWljYWxcIl0sIG5vZGVbY2xhc3M9XCJzaW1wbGUgY2hlbWljYWwgbXVsdGltZXJcIl1cbiAgICAgICAgYClcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUpLFxuICAgICAgICAgICd3aWR0aCc6IChub2RlKSA9PiBzYmduRGltZW5zaW9ucy53aWR0aChub2RlKSxcbiAgICAgICAgICAnaGVpZ2h0JzogKG5vZGUpID0+IHNiZ25EaW1lbnNpb25zLmhlaWdodChub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgIH0pXG5cblxuICAgICAgICAvLyBwcm9jZXNzIG5vZGUgc3BlY2lmaWMgc3R5bGVcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwiYXNzb2NpYXRpb25cIl0sIG5vZGVbY2xhc3M9XCJkaXNzb2NpYXRpb25cIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJhc3NvY2lhdGlvblwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM2QjZCNkInXG4gICAgICAgIH0pXG5cblxuICAgICAgICAvLyBlbnRpdHkgcG9vbCBub2RlIHNwZWNpZmljIHN0eWxlc1xuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJzb3VyY2UgYW5kIHNpbmtcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTAuODYsIDAuNSwgLTAuNzUsIDAuNjUsIC0xLCAwLjk1LCAtMC45NSwgMSwgLTAuNjUsIDAuNzUsIC0wLjUsIDAuODYsIDAsIDEsIDAuNSwgMC44NiwgMC43MSwgMC43MSwgMC44NiwgMC41LCAxLCAwLCAwLjg2LCAtMC41LCAwLjc1LCAtMC42NSwgMSwgLTAuOTUsIDAuOTUsIC0xLCAwLjY1LCAtMC43NSwgMC41LCAtMC44NiwgMCwgLTEsIC0wLjUsIC0wLjg2LCAtMC43MSwgLTAuNzEsIC0wLjg2LCAtMC41LCAtMSwgMCcsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cInRhZ1wiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IChub2RlKSA9PiBzYmduRGltZW5zaW9ucy53aWR0aChub2RlKSxcbiAgICAgICAgICAnaGVpZ2h0JzogKG5vZGUpID0+IHNiZ25EaW1lbnNpb25zLmhlaWdodChub2RlKSxcbiAgICAgICAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTEsIC0xLCAgIDAuMjUsIC0xLCAgIDEsIDAsICAgIDAuMjUsIDEsICAgIC0xLCAxJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJwZXJ0dXJiaW5nIGFnZW50XCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMC45NSwgLTAuNzUsIDAsIC0xLCAwLjk1LCAxLCAwLjk1LCAwLjc1LCAwLCAxLCAtMC45NScsXG4gICAgICAgIH0pXG5cblxuICAgICAgICAvLyBlbnRpdHkgcG9vbCBub2RlcyB0aGF0IGhhdmUgb25lIG9yIG1vcmUgb2YgKHVuaXRzIG9mIGluZm9ybWF0aW9uLCBzdGF0ZSB2YXJpYWJsZXMsIG11bHRpbWVyKVxuICAgICAgICAuc2VsZWN0b3IoYFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJudWNsZWljIGFjaWQgZmVhdHVyZVwiXSwgbm9kZVtjbGFzcz1cIm51Y2xlaWMgYWNpZCBmZWF0dXJlIG11bHRpbWVyXCJdLFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJtYWNyb21vbGVjdWxlXCJdLCBub2RlW2NsYXNzPVwibWFjcm9tb2xlY3VsZSBtdWx0aW1lclwiXSxcbiAgICAgICAgICBub2RlW2NsYXNzPVwic2ltcGxlIGNoZW1pY2FsXCJdLCBub2RlW2NsYXNzPVwic2ltcGxlIGNoZW1pY2FsIG11bHRpbWVyXCJdLFxuICAgICAgICAgIG5vZGVbY2xhc3M9XCJwZXJ0dXJiaW5nIGFnZW50XCJdXG4gICAgICAgIGApXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdwYWRkaW5nJzogKG5vZGUpID0+ICAoaXNNdWx0aW1lcihub2RlKSB8fCBoYXNBdXhJdGVtcyhub2RlKSkgPyA1IDogMCxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6IChub2RlKSA9PiAgKGlzTXVsdGltZXIobm9kZSkgfHwgaGFzQXV4SXRlbXMobm9kZSkpID8gJzEyMCUnIDogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6IChub2RlKSA9PiAgKGlzTXVsdGltZXIobm9kZSkgfHwgaGFzQXV4SXRlbXMobm9kZSkpID8gJzEyMCUnIDogJzEwMCUnLFxuICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gY29tcG91bmQgbm9kZSBzcGVjaWZpYyBzdHlsZVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJjb21wbGV4XCJdLCBub2RlW2NsYXNzPVwiY29tcGxleCBtdWx0aW1lclwiXSwgbm9kZVtjbGFzcz1cImNvbXBhcnRtZW50XCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2V4Y2x1ZGUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAuMixcbiAgICAgICAgICAndGV4dC12YWxpZ24nOiAnYm90dG9tJyxcbiAgICAgICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAnbWluLXdpZHRoJzogKG5vZGUpID0+IHNiZ25EaW1lbnNpb25zLndpZHRoKG5vZGUpLFxuICAgICAgICAgICdtaW4taGVpZ2h0JzogKG5vZGUpID0+IHNiZ25EaW1lbnNpb25zLmhlaWdodChub2RlKSxcbiAgICAgICAgfSlcblxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJjb21wYXJ0bWVudFwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdwYWRkaW5nJzogJzEwJScsXG4gICAgICAgICAgJ3BhZGRpbmctcmVsYXRpdmUtdG8nOiAnbWF4JyxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBlZGdlIHN0eWxpbmdcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1maWxsJzogJ2hvbGxvdycsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1maWxsJzogJ2hvbGxvdycsXG4gICAgICAgICAgJ3dpZHRoJzogMS41LFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjNTU1JyxcbiAgICAgICAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ2NvbG9yJzogJyM1NTUnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZTpzZWxlY3RlZCcpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdjb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAnbGluZS1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAndGV4dC1ib3JkZXItY29sb3InOiAnI2Q2NzYxNCcsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyNkNjc2MTQnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZTphY3RpdmUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMC43LCAnb3ZlcmxheS1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogJzgnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZVtjYXJkaW5hbGl0eSA+IDBdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RleHQtcm90YXRpb24nOiAnYXV0b3JvdGF0ZScsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogJzEnLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci13aWR0aCc6ICcxJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJ3doaXRlJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAnMSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzPVwiY29uc3VtcHRpb25cIl1bY2FyZGluYWxpdHkgPiAwXSwgZWRnZVtjbGFzcz1cInByb2R1Y3Rpb25cIl1bY2FyZGluYWxpdHkgPiAwXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzb3VyY2UtbGFiZWwnOiAoZWRnZSkgPT4gJycgKyBlZGdlLmRhdGEoJ2NhcmRpbmFsaXR5JyksXG4gICAgICAgICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogJy0xMCcsXG4gICAgICAgICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IChlZGdlKSA9PiBlbGVtZW50U3R5bGUuY2FyZGluYWxpdHlEaXN0YW5jZShlZGdlKVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3NdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1zaGFwZSc6IChlZGdlKSA9PiBlbGVtZW50U3R5bGUuc2JnbkFycm93U2hhcGUoZWRnZSksXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1zaGFwZSc6ICdub25lJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3M9XCJpbmhpYml0aW9uXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1maWxsJzogJ2ZpbGxlZCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzPVwicHJvZHVjdGlvblwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnXG4gICAgICAgIH0pXG5cblxuICAgICAgICAvLyBjb3JlXG4gICAgICAgIC5zZWxlY3RvcignY29yZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAnMC4yJywgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNkNjc2MTQnXG4gICAgICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzYmduU3R5bGVTaGVldDtcbiIsImNvbnN0IHNiZ25EYXRhSGFuZGxlciA9IHtcbiAgaXNNdWx0aW1lciAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmRhdGEoJ2NsYXNzJykuaW5jbHVkZXMoJ211bHRpbWVyJyk7XG4gIH0sXG4gIGhhc0Nsb25lbWFya2VyIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZGF0YSgnY2xvbmVtYXJrZXInKTtcbiAgfSxcbiAgZ2V0U3RhdGVWYXJzIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZGF0YSgnc3RhdGVWYXJpYWJsZXMnKTtcbiAgfSxcbiAgZ2V0VW5pdEluZm9zIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZGF0YSgndW5pdHNPZkluZm9ybWF0aW9uJyk7XG4gIH0sXG4gIGhhc0F1eEl0ZW1zIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmRhdGEoJ3N0YXRlVmFyaWFibGVzJykubGVuZ3RoICsgbm9kZS5kYXRhKCd1bml0c09mSW5mb3JtYXRpb24nKS5sZW5ndGggPiAwKTtcbiAgfSxcbiAgc2JnbkNsYXNzIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YSgnY2xhc3MnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzYmduRGF0YUhhbmRsZXI7XG4iLCJjb25zdCBzdHlsZU1hcDJTdHIgPSAoc3R5bGVNYXApID0+IHtcbiAgaWYoICFzdHlsZU1hcCApe1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGxldCBzID0gJyc7XG5cbiAgZm9yKCBsZXQgW2ssIHZdIG9mIHN0eWxlTWFwICl7XG4gICAgcyArPSBrICsgJz0nICsgXCInXCIgKyB2ICsgXCInXCIgKyAnICc7XG4gIH1cblxuICByZXR1cm4gcztcbn07XG5cbmNvbnN0IHN2ZyA9IChzdmdTdHIsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDAsIHZiWCA9IDAsIHZiWSA9IDAsIHZiV2lkdGggPSAxMDAsIHZiSGVpZ2h0ID0gMTAwKSA9PiB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgbGV0IHN2Z1RleHQgPWA8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgdmVyc2lvbj0nMS4xJyB3aWR0aD0nJHt3aWR0aH0nIGhlaWdodD0nJHtoZWlnaHR9JyB2aWV3Qm94PScke3ZiWH0gJHt2Yll9ICR7dmJXaWR0aH0gJHt2YkhlaWdodH0nPiR7c3ZnU3RyfTwvc3ZnPmA7XG4gIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Z1RleHQsICd0ZXh0L3htbCcpLmRvY3VtZW50RWxlbWVudDtcbn07XG5cbmNvbnN0IHN2Z1N0ciA9IChzdmdUZXh0LCB2aWV3UG9ydFdpZHRoLCB2aWV3UG9ydEhlaWdodCwgdmlld0JveFgsIHZpZXdCb3hZLCB2aWV3Qm94V2lkdGgsIHZpZXdCb3hIZWlnaHQpID0+IHtcbiAgbGV0IHMgPSBzdmcoc3ZnVGV4dCwgdmlld1BvcnRXaWR0aCwgdmlld1BvcnRIZWlnaHQsIHZpZXdCb3hYLCB2aWV3Qm94WSwgdmlld0JveFdpZHRoLCB2aWV3Qm94SGVpZ2h0KTtcbiAgbGV0IGRhdGEgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwnICsgYnRvYShzLm91dGVySFRNTCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ZnU3RyOiBzdmdTdHIsXG4gIHN0eWxlTWFwMlN0cjogc3R5bGVNYXAyU3RyXG59O1xuIl19
