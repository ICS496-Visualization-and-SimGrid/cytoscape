(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _index = require('../src/index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var convertSbgnml = require('sbgnml-to-cytoscape'); /* global $ */

var saveAs = require('file-saver').saveAs;

var defaultData = require('./test-data');

var loadFileText = function loadFileText(absFilePath) {
  var xhttp;
  if (window.XMLHttpRequest) {
    xhttp = new XMLHttpRequest();
  } else {
    xhttp = new ActiveXObject('Microsoft.XMLHTTP');
  }
  xhttp.open('GET', absFilePath, false);
  xhttp.send();
  return xhttp.responseText;
};

var readFile = function readFile(renderer, file) {
  var reader = new FileReader();

  reader.onload = function (e) {
    var graph = convertSbgnml(e.target.result);
    renderGraph(renderer, graph);
  };

  reader.readAsText(file);
};

var renderGraph = function renderGraph(cy, cyGraph) {
  cy.startBatch();
  cy.remove('*');
  cy.add(cyGraph);

  var nodePositions = {};
  for (var i = 0; i < cyGraph.nodes.length; i++) {
    var xPos = cyGraph.nodes[i].data.bbox.x;
    var yPos = cyGraph.nodes[i].data.bbox.y;
    nodePositions[cyGraph.nodes[i].data.id] = { 'x': xPos, 'y': yPos };
  }

  cy.layout({
    name: 'preset',
    positions: nodePositions,
    fit: true,
    padding: 50
  });

  cy.endBatch();
  cy.style().update();
};

var b64toBlob = function b64toBlob(b64Data, contentType, sliceSize) {
  contentType = contentType || '';
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

var save = function save(renderer, filename) {
  var graphFileString = renderer.png({ scale: 3, full: true });

  var b64Data = graphFileString.substr(graphFileString.indexOf(',') + 1);
  saveAs(b64toBlob(b64Data, 'image/png'), filename);
};

$(document).ready(function () {

  var container = $('#sbgn-network-container');

  var renderer = new _index2.default({
    container: container
  });

  window.r = window.cy = renderer;
  renderGraph(renderer, defaultData);

  $('#graph-load').click(function () {
    $('#graph-input').trigger('click');
  });

  $('#graph-input').change(function () {
    if ($(this).val() != '') {
      var file = this.files[0];

      readFile(renderer, file);
    }
  });

  $('#graph-save').click(function () {
    save(renderer, 'graph');
  });

  $('.sample-file').click(function () {
    var fileText = loadFileText('samples/' + $(this)[0].innerText + '.xml');
    var graphJson = convertSbgnml(fileText);
    renderGraph(renderer, graphJson);
  });
});

},{"../src/index":118,"./test-data":2,"file-saver":111,"sbgnml-to-cytoscape":116}],2:[function(require,module,exports){
"use strict";

var mapkCascadeData = {
    "nodes": [{
        "data": {
            "id": "glyph4",
            "bbox": {
                "x": 318.1589165885067,
                "y": 162.59898679973332,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph5",
            "bbox": {
                "x": 368.7150698032765,
                "y": 353.3425311332147,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph7",
            "bbox": {
                "x": 423.4601247086921,
                "y": 103.68144699737059,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph6",
            "bbox": {
                "x": 514.8286564804162,
                "y": 40.16169718646756,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph10",
            "bbox": {
                "x": 588.775693273037,
                "y": 410.5318087906144,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph9",
            "bbox": {
                "x": 497.6859428037237,
                "y": 352.2241646137692,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph2",
            "bbox": {
                "x": 467.18302213209245,
                "y": 240.2873064873903,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAF",
            "statesandinfos": [{
                "id": "glyph2a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph18",
            "bbox": {
                "x": 944.040949176361,
                "y": 284.0657446868406,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph16",
            "bbox": {
                "x": 689.1314585303767,
                "y": 482.44467100584745,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph15",
            "bbox": {
                "x": 882.8443326294546,
                "y": 482.5246268128043,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph17",
            "bbox": {
                "x": 759.9810408902129,
                "y": 220.58540441014577,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph12",
            "bbox": {
                "x": 722.5240088762721,
                "y": 352.770069365478,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph12a",
                "clazz": "state variable",
                "state": {
                    "value": "2P"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "32.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph19",
            "bbox": {
                "x": 887.0312955929699,
                "y": 188.01104320899924,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph19a",
                "clazz": "state variable",
                "state": {
                    "value": "2P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "32.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph20",
            "bbox": {
                "x": 971.0567176507191,
                "y": 84.6685272739719,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "tag",
            "label": "ERK",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph1",
            "bbox": {
                "x": 213.55056132706864,
                "y": 236.18933213306605,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAS",
            "statesandinfos": [{
                "id": "glyph1a",
                "clazz": "state variable",
                "state": {
                    "value": "active"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "50.0",
                    "h": "26.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph0",
            "bbox": {
                "x": 60.134389512288635,
                "y": 200.02587224541605,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "tag",
            "label": "RAS",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph24",
            "bbox": {
                "x": 607.5584862953788,
                "y": 216.36466489184716,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph24a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph11",
            "bbox": {
                "x": 592.6185230656652,
                "y": 313.4502085225929,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph25",
            "bbox": {
                "x": 247.4431965319236,
                "y": 338.29565236558483,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAF",
            "statesandinfos": [{
                "id": "glyph25a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph3",
            "bbox": {
                "x": 337.77918025112933,
                "y": 259.13454532846924,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph23",
            "bbox": {
                "x": 631.3665810796247,
                "y": 93.61445750305336,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph23a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph8",
            "bbox": {
                "x": 516.9252315842282,
                "y": 142.01290840429613,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph22",
            "bbox": {
                "x": 786.1602768573573,
                "y": 557.4534904328991,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph22a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph13",
            "bbox": {
                "x": 844.4300288939096,
                "y": 284.87165823750354,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph14",
            "bbox": {
                "x": 783.7402046808443,
                "y": 453.1501505501591,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph21",
            "bbox": {
                "x": 872.1517334162531,
                "y": 378.5680972732039,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph21a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }],
    "edges": [{
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph3",
            "target": "glyph2",
            "portsource": "glyph3",
            "porttarget": "glyph2"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph4",
            "target": "glyph3",
            "portsource": "glyph4",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph3",
            "target": "glyph5",
            "portsource": "glyph3",
            "porttarget": "glyph5"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph1",
            "target": "glyph3",
            "portsource": "glyph1",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph7",
            "target": "glyph8",
            "portsource": "glyph7",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph8",
            "target": "glyph6",
            "portsource": "glyph8",
            "porttarget": "glyph6"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph10",
            "target": "glyph11",
            "portsource": "glyph10",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph11",
            "target": "glyph12",
            "portsource": "glyph11",
            "porttarget": "glyph12"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph11",
            "target": "glyph9",
            "portsource": "glyph11",
            "porttarget": "glyph9"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph2",
            "target": "glyph11",
            "portsource": "glyph2",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph2",
            "target": "glyph8",
            "portsource": "glyph2",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph13",
            "target": "glyph19",
            "portsource": "glyph13",
            "porttarget": "glyph19"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph13",
            "target": "glyph18",
            "portsource": "glyph13",
            "porttarget": "glyph18"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph14",
            "target": "glyph16",
            "portsource": "glyph14",
            "porttarget": "glyph16"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph15",
            "target": "glyph14",
            "portsource": "glyph15",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph17",
            "target": "glyph13",
            "portsource": "glyph17",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph12",
            "target": "glyph13",
            "portsource": "glyph12",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph12",
            "target": "glyph14",
            "portsource": "glyph12",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "equivalence arc",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph19",
            "target": "glyph20",
            "portsource": "glyph19",
            "porttarget": "glyph20"
        }
    }, {
        "data": {
            "class": "equivalence arc",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph1",
            "target": "glyph0",
            "portsource": "glyph1",
            "porttarget": "glyph0"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph8",
            "target": "glyph24",
            "portsource": "glyph8",
            "porttarget": "glyph24"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph24",
            "target": "glyph11",
            "portsource": "glyph24",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph25",
            "target": "glyph3",
            "portsource": "glyph25",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph23",
            "target": "glyph8",
            "portsource": "glyph23",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph22",
            "target": "glyph14",
            "portsource": "glyph22",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph21",
            "target": "glyph13",
            "portsource": "glyph21",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph14",
            "target": "glyph21",
            "portsource": "glyph14",
            "porttarget": "glyph21"
        }
    }]
};

module.exports = mapkCascadeData;

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){

/*!

Cytoscape.js {{VERSION}} (MIT licensed)

Copyright (c) The Cytoscape Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

'use strict';

},{}],5:[function(require,module,exports){
'use strict';

var util = require( './util' );
var is = require( './is' );
var Promise = require( './promise' );

var Animation = function( target, opts, opts2 ){
  if( !(this instanceof Animation) ){
    return new Animation( target, opts, opts2 );
  }

  var _p = this._private = util.extend( {
    duration: 1000
  }, opts, opts2 );

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if( _p.complete && is.fn( _p.complete ) ){
    _p.completes.push( _p.complete );
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend( anifn, {

  instanceString: function(){ return 'animation'; },

  hook: function(){
    var _p = this._private;

    if( !_p.hooked ){
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;
      if( _p.queue ){
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push( this );

      // add to the animation loop pool
      if( is.elementOrCollection( _p.target ) ){
        _p.target.cy().addToAnimationPool( _p.target );
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function(){
    var _p = this._private;

    // autorewind
    if( _p.progress === 1 ){
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function(){
    return this._private.playing;
  },

  apply: function(){
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function(){
    return this._private.applying;
  },

  pause: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function(){
    return this.progress( 0 );
  },

  fastforward: function(){
    return this.progress( 1 );
  },

  time: function( t ){
    var _p = this._private;

    if( t === undefined ){
      return _p.progress * _p.duration;
    } else {
      return this.progress( t / _p.duration );
    }
  },

  progress: function( p ){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( p === undefined ){
      return _p.progress;
    } else {
      if( wasPlaying ){
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if( wasPlaying ){
        this.play();
      }
    }

    return this;
  },

  completed: function(){
    return this._private.progress === 1;
  },

  reverse: function(){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( wasPlaying ){
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function( a, b ){
      var _pa = _p[ a ];

      _p[ a ] = _p[ b ];
      _p[ b ] = _pa;
    };

    swap( 'zoom', 'startZoom' );
    swap( 'pan', 'startPan' );
    swap( 'position', 'startPosition' );

    // swap styles
    for( var i = 0; i < _p.style.length; i++ ){
      var prop = _p.style[ i ];
      var name = prop.name;
      var startStyleProp = _p.startStyle[ name ];

      _p.startStyle[ name ] = prop;
      _p.style[ i ] = startStyleProp;
    }

    if( wasPlaying ){
      this.play();
    }

    return this;
  },

  promise: function( type ){
    var _p = this._private;

    var arr;

    switch( type ){
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise( function( resolve, reject ){
      arr.push( function(){
        resolve();
      } );
    } );
  }

} );

anifn.complete = anifn.completed;

module.exports = Animation;

},{"./is":86,"./promise":89,"./util":103}],6:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  aStar: function( options ){
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function( start, end, cameFromMap, pathAcum ){
      // Base case
      if( start == end ){
        pathAcum.push( cy.getElementById( end ) );
        return pathAcum;
      }

      if( end in cameFromMap ){
        // We know which node is before the last one
        var previous = cameFromMap[ end ];
        var previousEdge = cameFromEdge[ end ];

        pathAcum.push( cy.getElementById( end ) );
        pathAcum.push( cy.getElementById( previousEdge ) );


        return reconstructPath( start,
                     previous,
                     cameFromMap,
                     pathAcum );
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function( openSet, fScore ){
      if( openSet.length === 0 ){
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[ openSet[0] ];
      for( var i = 1; i < openSet.length; i++ ){
        var s = fScore[ openSet[ i ] ];
        if( s < tempScore ){
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if( options != null && options.root != null ){
      var source = is.string( options.root ) ?
        // use it as a selector, e.g. "#rootID
        this.filter( options.root )[0] :
        options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if( options.goal != null ){
      var target = is.string( options.goal ) ?
        // use it as a selector, e.g. "#goalID
        this.filter( options.goal )[0] :
        options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if( options.heuristic != null && is.fn( options.heuristic ) ){
      var heuristic = options.heuristic;
    } else {
      var heuristic = function(){ return 0; }; // use constant if unspecified
    }

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var closedSet = [];
    var openSet = [ source.id() ];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[ source.id() ] = 0;
    fScore[ source.id() ] = heuristic( source );

    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();

    // Counter
    var steps = 0;

    // Main loop
    while( openSet.length > 0 ){
      var minPos = findMin( openSet, fScore );
      var cMin = cy.getElementById( openSet[ minPos ] );
      steps++;

      // If we've found our goal, then we are done
      if( cMin.id() == target.id() ){
        var rPath = reconstructPath( source.id(), target.id(), cameFrom, [] );
        rPath.reverse();
        return {
          found: true,
          distance: gScore[ cMin.id() ],
          path: eles.spawn( rPath ),
          steps: steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push( cMin.id() );
      // Remove cMin from boundary nodes
      openSet.splice( minPos, 1 );

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin.connectedEdges();
      if( directed ){ vwEdges = vwEdges.stdFilter( function( ele ){ return ele.data( 'source' ) === cMin.id(); } ); }
      vwEdges = vwEdges.intersect( edges );

      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];
        var w = e.connectedNodes().stdFilter( function( n ){ return n.id() !== cMin.id(); } ).intersect( nodes );

        // if node is in closedSet, ignore it
        if( closedSet.indexOf( w.id() ) != -1 ){
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[ cMin.id() ] + weightFn.apply( e, [ e ] );

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if( openSet.indexOf( w.id() ) == -1 ){
          gScore[ w.id() ] = tempScore;
          fScore[ w.id() ] = tempScore + heuristic( w );
          openSet.push( w.id() ); // Add node to openSet
          cameFrom[ w.id() ] = cMin.id();
          cameFromEdge[ w.id() ] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if( tempScore < gScore[ w.id() ] ){
          gScore[ w.id() ] = tempScore;
          fScore[ w.id() ] = tempScore + heuristic( w );
          cameFrom[ w.id() ] = cMin.id();
        }

      } // End of neighbors update

    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }

}); // elesfn


module.exports = elesfn;

},{"../../is":86}],7:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var util = require( '../../util' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  bellmanFord: function( options ){
    var eles = this;

    options = options || {};

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var source = this.filter( options.root )[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for( var i = 0; i < numNodes; i++ ){
      if( nodes[ i ].id() === source.id() ){
        cost[ i ] = 0;
      } else {
        cost[ i ] = Infinity;
      }
      predecessor[ i ] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for( var i = 1; i < numNodes; i++ ){
      flag = false;
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );

        var temp = cost[ sourceIndex ] + weight;
        if( temp < cost[ targetIndex ] ){
          cost[ targetIndex ] = temp;
          predecessor[ targetIndex ] = sourceIndex;
          predEdge[ targetIndex ] = edges[ e ];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if( !directed ){
          var temp = cost[ targetIndex ] + weight;
          if( temp < cost[ sourceIndex ] ){
            cost[ sourceIndex ] = temp;
            predecessor[ sourceIndex ] = targetIndex;
            predEdge[ sourceIndex ] = edges[ e ];
            flag = true;
          }
        }
      }

      if( !flag ){
        break;
      }
    }

    if( flag ){
      // Check for negative weight cycles
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );

        if( cost[ sourceIndex ] + weight < cost[ targetIndex ] ){
          util.error( 'Graph contains a negative weight cycle for Bellman-Ford' );
          return { pathTo: undefined,
               distanceTo: undefined,
               hasNegativeWeightCycle: true};
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }


    var res = {
      distanceTo: function( to ){
        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[ id2position[ toId ] ];
      },

      pathTo: function( to ){

        var reconstructPathAux = function( predecessor, fromPos, toPos, position2id, acumPath, predEdge ){
          for( ;; ){
            // Add toId to path
            acumPath.push( cy.getElementById( position2id[ toPos ] ) );
            acumPath.push( predEdge[ toPos ] );

            if( fromPos === toPos ){
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[ toPos ];
            if( typeof predPos === 'undefined' ){
              return undefined;
            }

            toPos = predPos;
          }

        };

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res =  reconstructPathAux( predecessor,
                      id2position[ source.id() ],
                      id2position[ toId ],
                      position2id,
                      path,
                      predEdge );

        // Get it in the correct order and return it
        if( res != null ){
          res.reverse();
        }

        return eles.spawn( res );
      },

      hasNegativeWeightCycle: false
    };

    return res;

  } // bellmanFord

}); // elesfn

module.exports = elesfn;

},{"../../is":86,"../../util":103}],8:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var Heap = require( '../../heap' );

var elesfn = ({

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function( options ){
    options = options || {};

    // Weight - optional
    var weighted, weightFn;
    if( is.fn( options.weight ) ){
      weightFn = options.weight;
      weighted = true;
    } else {
      weighted = false;
    }

    // Directed - default false
    var directed = options.directed != null ? options.directed : false;

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function( key, val ){
        _C[ key ] = val;

        if( val > max ){ max = val; }
      },

      get: function( key ){ return _C[ key ]; }
    };

    // A contains the neighborhoods of every node
    for( var i = 0; i < V.length; i++ ){
      var v = V[ i ];
      var vid = v.id();

      if( directed ){
        A[ vid ] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[ vid ] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set( vid, 0 );
    }

    for( var s = 0; s < V.length; s++ ){
      var sid = V[s].id();
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function( a, b ){
        return d[a] - d[b];
      }); // queue

      // init dictionaries
      for( var i = 0; i < V.length; i++ ){
        var vid = V[ i ].id();

        P[ vid ] = [];
        g[ vid ] = 0;
        d[ vid ] = Infinity;
      }

      g[ sid ] = 1; // sigma
      d[ sid ] = 0; // distance to s

      Q.push( sid );

      while( !Q.empty() ){
        var v = Q.pop();

        S.push( v );

        if( weighted ){
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j];
            var vEle = cy.getElementById( v );

            var edge;
            if( vEle.edgesTo( w ).length > 0 ){
              edge = vEle.edgesTo( w )[0];
            } else {
              edge = w.edgesTo( vEle )[0];
            }

            var edgeWeight = weightFn.apply( edge, [ edge ] );

            w = w.id();

            if( d[w] > d[v] + edgeWeight ){
              d[w] = d[v] + edgeWeight;

              if( Q.nodes.indexOf( w ) < 0 ){ //if w is not in Q
                Q.push( w );
              } else { // update position if w is in Q
                Q.updateItem( w );
              }

              g[w] = 0;
              P[w] = [];
            }

            if( d[w] == d[v] + edgeWeight ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        } else {
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j].id();

            if( d[w] == Infinity ){
              Q.push( w );

              d[w] = d[v] + 1;
            }

            if( d[w] == d[v] + 1 ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        }
      }

      var e = {};
      for( var i = 0; i < V.length; i++ ){
        e[ V[ i ].id() ] = 0;
      }

      while( S.length > 0 ){
        var w = S.pop();

        for( var j = 0; j < P[w].length; j++ ){
          var v = P[w][j];

          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);

          if( w != V[s].id() ){
            C.set( w, C.get( w ) + e[w] );
          }
        }
      }
    }

    var ret = {
      betweenness: function( node ){
        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node );
      },

      betweennessNormalized: function( node ){
        if ( max == 0 )
          return 0;

        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node ) / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

},{"../../heap":84,"../../is":86}],9:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var defineSearch = function( params ){
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn( roots, fn, directed ){
    var options;
    var std;
    var thisArg;
    if( is.plainObject( roots ) && !is.elementOrCollection( roots ) ){
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
      std = options.std;
      thisArg = options.thisArg;
    }

    directed = arguments.length === 2 && !is.fn( fn ) ? fn : directed;
    fn = is.fn( fn ) ? fn : function(){};

    var cy = this._private.cy;
    var v = roots = is.string( roots ) ? this.filter( roots ) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for( var i = 0; i < v.length; i++ ){
      if( v[ i ].isNode() ){
        Q.unshift( v[ i ] );

        if( params.bfs ){
          V[ v[ i ].id() ] = true;

          connectedNodes.push( v[ i ] );
        }

        id2depth[ v[ i ].id() ] = 0;
      }
    }

    while( Q.length !== 0 ){
      var v = params.bfs ? Q.shift() : Q.pop();

      if( params.dfs ){
        if( V[ v.id() ] ){ continue; }

        V[ v.id() ] = true;

        connectedNodes.push( v );
      }

      var depth = id2depth[ v.id() ];
      var prevEdge = connectedBy[ v.id() ];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
      var ret;

      if( std ){
        ret = fn.call( thisArg, v, prevEdge, prevNode, j++, depth );
      } else {
        ret = fn.call( v, j++, depth, v, prevEdge, prevNode );
      }

      if( ret === true ){
        found = v;
        break;
      }

      if( ret === false ){
        break;
      }

      var vwEdges = v.connectedEdges( directed ? function(){ return this.data( 'source' ) === v.id(); } : undefined ).intersect( edges );
      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];
        var w = e.connectedNodes( function(){ return this.id() !== v.id(); } ).intersect( nodes );

        if( w.length !== 0 && !V[ w.id() ] ){
          w = w[0];

          Q.push( w );

          if( params.bfs ){
            V[ w.id() ] = true;

            connectedNodes.push( w );
          }

          connectedBy[ w.id() ] = e;

          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
        }
      }

    }

    var connectedEles = [];

    for( var i = 0; i < connectedNodes.length; i++ ){
      var node = connectedNodes[ i ];
      var edge = connectedBy[ node.id() ];

      if( edge ){
        connectedEles.push( edge );
      }

      connectedEles.push( node );
    }

    return {
      path: cy.collection( connectedEles, { unique: true } ),
      found: cy.collection( found )
    };
  };
};

// search, spanning trees, etc
var elesfn = ({
  breadthFirstSearch: defineSearch( { bfs: true } ),
  depthFirstSearch: defineSearch( { dfs: true } )
});

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

},{"../../is":86}],10:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  closenessCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall( { weight: options.weight, directed: options.directed } );

    // Compute closeness for every node and find the maximum closeness
    for( var i = 0; i < nodes.length; i++ ){
      var currCloseness = 0;
      for( var j = 0; j < nodes.length; j++ ){
        if( i != j ){
          var d = fw.distance( nodes[ i ], nodes[ j ] );

          if( harmonic ){
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if( !harmonic ){
        currCloseness = 1 / currCloseness;
      }

      if( maxCloseness < currCloseness ){
        maxCloseness = currCloseness;
      }

      closenesses[ nodes[ i ].id() ] = currCloseness;
    }

    return {
      closeness: function( node ){
        if( maxCloseness == 0 ){ return 0; }

        if( is.string( node ) ){
          // from is a selector string
          var node = (cy.filter( node )[0]).id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[ node ] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function( options ){
    options = options || {};

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var root = this.filter( options.root )[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weight = options.weight;
    } else {
      var weight = function(){return 1;};
    }

    // directed - optional
    if( options.directed != null && is.bool( options.directed ) ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra( {
      root: root,
      weight: weight,
      directed: directed
    } );
    var totalDistance = 0;

    var nodes = this.nodes();
    for( var i = 0; i < nodes.length; i++ ){
      if( nodes[ i ].id() != root.id() ){
        var d = dijkstra.distanceTo( nodes[ i ] );

        if( harmonic ){
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

},{"../../is":86}],11:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var util = require( '../../util' );

var elesfn = ({

  degreeCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if( !directed ){
      var degrees = {};
      var maxDegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );
        if( maxDegree < currDegree.degree )
          maxDegree = currDegree.degree;

        degrees[ node.id() ] = currDegree.degree;
      }

      return {
        degree: function( node ){
          if( maxDegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[ node ] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );

        if( maxIndegree < currDegree.indegree )
          maxIndegree = currDegree.indegree;

        if( maxOutdegree < currDegree.outdegree )
          maxOutdegree = currDegree.outdegree;

        indegrees[ node.id() ] = currDegree.indegree;
        outdegrees[ node.id() ] = currDegree.outdegree;
      }

      return {
        indegree: function( node ){
          if ( maxIndegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[ node ] / maxIndegree;
        },
        outdegree: function( node ){
          if ( maxOutdegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[ node ] / maxOutdegree;
        }

      };
    }

  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function( options ){
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if( options != null && options.root != null ){
      var root = is.string( options.root ) ? this.filter( options.root )[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){
        return 1;
      };
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if( options.alpha != null && is.number( options.alpha ) ){
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }


    if( !directed ){
      var connEdges = root.connectedEdges().intersection( callingEles );
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for( var i = 0; i < connEdges.length; i++ ){
        var edge = connEdges[ i ];
        s += weightFn.apply( edge, [ edge ] );
      }

      return {
        degree: Math.pow( k, 1 - alpha ) * Math.pow( s, alpha )
      };
    } else {
      var incoming = root.connectedEdges( 'edge[target = "' + root.id() + '"]' ).intersection( callingEles );
      var outgoing = root.connectedEdges( 'edge[source = "' + root.id() + '"]' ).intersection( callingEles );
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for( var i = 0; i < incoming.length; i++ ){
        var edge = incoming[ i ];
        s_in += weightFn.apply( edge, [ edge ] );
      }

      // Now, sum outgoing edge weights
      for( var i = 0; i < outgoing.length; i++ ){
        var edge = outgoing[ i ];
        s_out += weightFn.apply( edge, [ edge ] );
      }

      return {
        indegree: Math.pow( k_in, 1 - alpha ) * Math.pow( s_in, alpha ),
        outdegree: Math.pow( k_out, 1 - alpha ) * Math.pow( s_out, alpha )
      };
    }
  } // degreeCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

},{"../../is":86,"../../util":103}],12:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var Heap = require( '../../heap' );

var elesfn = ({

  dijkstra: function( root, weightFn, directed ){
    var options;
    if( is.plainObject( root ) && !is.elementOrCollection( root ) ){
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    var source = is.string( root ) ? this.filter( root )[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter( function(){ return !this.isLoop(); } );
    var nodes = this.nodes();

    var getDist = function( node ){
      return dist[ node.id() ];
    };

    var setDist = function( node, d ){
      dist[ node.id() ] = d;

      Q.updateItem( node );
    };

    var Q = new Heap( function( a, b ){
      return getDist( a ) - getDist( b );
    } );

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];

      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
      Q.push( node );
    }

    var distBetween = function( u, v ){
      var uvs = ( directed ? u.edgesTo( v ) : u.edgesWith( v ) ).intersect( edges );
      var smallestDistance = Infinity;
      var smallestEdge;

      for( var i = 0; i < uvs.length; i++ ){
        var edge = uvs[ i ];
        var weight = weightFn.apply( edge, [ edge ] );

        if( weight < smallestDistance || !smallestEdge ){
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while( Q.size() > 0 ){
      var u = Q.pop();
      var smalletsDist = getDist( u );
      var uid = u.id();

      knownDist[ uid ] = smalletsDist;

      if( smalletsDist === Math.Infinite ){
        break;
      }

      var neighbors = u.neighborhood().intersect( nodes );
      for( var i = 0; i < neighbors.length; i++ ){
        var v = neighbors[ i ];
        var vid = v.id();
        var vDist = distBetween( u, v );

        var alt = smalletsDist + vDist.dist;

        if( alt < getDist( v ) ){
          setDist( v, alt );

          prev[ vid ] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];

        return knownDist[ target.id() ];
      },

      pathTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];
        var S = [];
        var u = target;

        if( target.length > 0 ){
          S.unshift( target );

          while( prev[ u.id() ] ){
            var p = prev[ u.id() ];

            S.unshift( p.edge );
            S.unshift( p.node );

            u = p.node;
          }
        }

        return cy.collection( S );
      }
    };
  }
});

module.exports = elesfn;

},{"../../heap":84,"../../is":86}],13:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  floydWarshall: function( options ){
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for( var i = 0; i < numNodes; i++ ){
      var newRow = new Array( numNodes );
      for( var j = 0; j < numNodes; j++ ){
        if( i == j ){
          newRow[ j ] = 0;
        } else {
          newRow[ j ] = Infinity;
        }
      }
      dist.push( newRow );
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function( next ){
      for( var i = 0; i < numNodes; i++ ){
        var newRow = new Array( numNodes );
        for( var j = 0; j < numNodes; j++ ){
          newRow[ j ] = undefined;
        }
        next.push( newRow );
      }
    };

    initMatrix( next );
    initMatrix( edgeNext );

    // Process edges
    for( var i = 0; i < edges.length ; i++ ){
      var sourceIndex = id2position[ edges[ i ].source().id() ];
      var targetIndex = id2position[ edges[ i ].target().id() ];
      var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );

      // Check if already process another edge between same 2 nodes
      if( dist[ sourceIndex ][ targetIndex ] > weight ){
        dist[ sourceIndex ][ targetIndex ] = weight;
        next[ sourceIndex ][ targetIndex ] = targetIndex;
        edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
      }
    }

    // If undirected graph, process 'reversed' edges
    if( !directed ){
      for( var i = 0; i < edges.length ; i++ ){
        var sourceIndex = id2position[ edges[ i ].target().id() ];
        var targetIndex = id2position[ edges[ i ].source().id() ];
        var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );

        // Check if already process another edge between same 2 nodes
        if( dist[ sourceIndex ][ targetIndex ] > weight ){
          dist[ sourceIndex ][ targetIndex ] = weight;
          next[ sourceIndex ][ targetIndex ] = targetIndex;
          edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
        }
      }
    }

    // Main loop
    for( var k = 0; k < numNodes; k++ ){
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] ){
            dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];
            next[ i ][ j ] = next[ i ][ k ];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }

    var res = {
      distance: function( from, to ){
        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[ id2position[ fromId ] ][ id2position[ toId ] ];
      },

      path: function( from, to ){
        var reconstructPathAux = function( from, to, next, position2id, edgeNext ){
          if( from === to ){
            return cy.getElementById( position2id[ from ] );
          }
          if( next[ from ][ to ] === undefined ){
            return undefined;
          }

          var path = [ cy.getElementById( position2id[ from ] ) ];
          var prev = from;
          while( from !== to ){
            prev = from;
            from = next[ from ][ to ];

            var edge = edgeNext[ prev ][ from ];
            path.push( edge );

            path.push( cy.getElementById( position2id[ from ] ) );
          }
          return path;
        };

        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux( id2position[ fromId ],
                      id2position[ toId ],
                      next,
                      position2id,
                      edgeNext );

        return cy.collection( pathArr );
      }
    };

    return res;

  } // floydWarshall

}); // elesfn

module.exports = elesfn;

},{"../../is":86}],14:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

var elesfn = {};

[
  require( './bfs-dfs' ),
  require( './dijkstra' ),
  require( './kruskal' ),
  require( './a-star' ),
  require( './floyd-warshall' ),
  require( './bellman-ford' ),
  require( './kerger-stein' ),
  require( './page-rank' ),
  require( './degree-centrality' ),
  require( './closeness-centrality' ),
  require( './betweenness-centrality' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = elesfn;

},{"../../util":103,"./a-star":6,"./bellman-ford":7,"./betweenness-centrality":8,"./bfs-dfs":9,"./closeness-centrality":10,"./degree-centrality":11,"./dijkstra":12,"./floyd-warshall":13,"./kerger-stein":15,"./kruskal":16,"./page-rank":17}],15:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

var elesfn = ({

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function( options ){
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function( edgeIndex, nodeMap, remainingEdges ){
      var edgeInfo = remainingEdges[ edgeIndex ];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[ sourceIn ];
      var partition2 = nodeMap[ targetIn ];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter( function( edge ){
        if( nodeMap[ edge[1] ] === partition1 && nodeMap[ edge[2] ] === partition2 ){
          return false;
        }
        if( nodeMap[ edge[1] ] === partition2 && nodeMap[ edge[2] ] === partition1 ){
          return false;
        }
        return true;
      } );

      // All edges pointing to partition2 should now point to partition1
      for( var i = 0; i < newEdges.length; i++ ){
        var edge = newEdges[ i ];
        if( edge[1] === partition2 ){ // Check source
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][1] = partition1;
        } else if( edge[2] === partition2 ){ // Check target
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for( var i = 0; i < nodeMap.length; i++ ){
        if( nodeMap[ i ] === partition2 ){
          nodeMap[ i ] = partition1;
        }
      }

      return newEdges;
    };


    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function( metaNodeMap,
                   remainingEdges,
                   size,
                   sizeLimit ){
      // Stop condition
      if( size <= sizeLimit ){
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor( (Math.random() * remainingEdges.length) );

      // Colapse graph based on edge
      var newEdges = colapse( edgeIndex, metaNodeMap, remainingEdges );

      return contractUntil( metaNodeMap,
                 newEdges,
                 size - 1,
                 sizeLimit );
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil( Math.pow( Math.log( numNodes ) / Math.LN2, 2 ) );
    var stopSize = Math.floor( numNodes / Math.sqrt( 2 ) );

    if( numNodes < 2 ){
      util.error( 'At least 2 nodes are required for Karger-Stein algorithm' );
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for( var i = 0; i < numEdges; i++ ){
      var e = edges[ i ];
      edgeIndexes.push( [ i, id2position[ e.source().id() ], id2position[ e.target().id() ] ] );
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for( var i = 0; i < numNodes; i++ ){
      originalMetaNode.push( i );
    }

    // Main loop
    for( var iter = 0; iter <= numIter; iter++ ){
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice( 0 );

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil( metaNodeMap, edgeIndexes, numNodes, stopSize );

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice( 0 );

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil( metaNodeMap, edgesState, stopSize, 2 );
      var res2 = contractUntil( metaNodeMap2, edgesState, stopSize, 2 );

      // Is any of the 2 results the best cut so far?
      if( res1.length <= res2.length && res1.length < minCutSize ){
        minCutSize = res1.length;
        minCut = [ res1, metaNodeMap ];
      } else if( res2.length <= res1.length && res2.length < minCutSize ){
        minCutSize = res2.length;
        minCut = [ res2, metaNodeMap2 ];
      }
    } // end of main loop


    // Construct result
    var resEdges = (minCut[0]).map( function( e ){ return edges[ e[0] ]; } );
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for( var i = 0; i < minCut[1].length; i++ ){
      var partitionId = minCut[1][ i ];
      if( partitionId === witnessNodePartition ){
        partition1.push( nodes[ i ] );
      } else {
        partition2.push( nodes[ i ] );
      }
    }

    var ret = {
      cut: eles.spawn( cy, resEdges ),
      partition1: eles.spawn( partition1 ),
      partition2: eles.spawn( partition2 )
    };

    return ret;
  }
}); // elesfn


module.exports = elesfn;

},{"../../util":103}],16:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

// search, spanning trees, etc
var elesfn = ({

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function( weightFn ){
    var cy = this.cy();

    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    function findSet( ele ){
      for( var i = 0; i < forest.length; i++ ){
        var eles = forest[ i ];

        if( eles.anySame( ele ) ){
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection( cy, [] );
    var forest = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      forest.push( nodes[ i ].collection() );
    }

    var edges = this.edges();
    var S = edges.toArray().sort( function( a, b ){
      var weightA = weightFn.call( a, a );
      var weightB = weightFn.call( b, b );

      return weightA - weightB;
    } );

    for( var i = 0; i < S.length; i++ ){
      var edge = S[ i ];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet( u );
      var setV = findSet( v );

      if( setU.index !== setV.index ){
        A = A.add( edge );

        // combine forests for u and v
        forest[ setU.index ] = setU.eles.add( setV.eles );
        forest.splice( setV.index, 1 );
      }
    }

    return nodes.add( A );
  }
});

module.exports = elesfn;

},{"../../is":86}],17:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  pageRank: function( options ){
    options = options || {};

    var normalizeVector = function( vector ){
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for( var i = 0; i < length; i++ ){
        total += vector[ i ];
      }

      // Now, divide each by the sum of all elements
      for( var i = 0; i < length; i++ ){
        vector[ i ] = vector[ i ] / total;
      }
    };

    // dampingFactor - optional
    if( options != null &&
      options.dampingFactor != null ){
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if( options != null &&
      options.precision != null ){
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if( options != null &&
      options.iterations != null ){
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if( options != null &&
      options.weight != null &&
      is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for( var i = 0; i < numNodes; i++ ){
      var newRow = [];
      for( var j = 0; j < numNodes; j++ ){
        newRow.push( 0.0 );
      }
      matrix.push( newRow );
      columnSum.push( 0.0 );
    }

    // Now, process edges
    for( var i = 0; i < numEdges; i++ ){
      var edge = edges[ i ];
      var s = id2position[ edge.source().id() ];
      var t = id2position[ edge.target().id() ];
      var w = weightFn.apply( edge, [ edge ] );

      // Update matrix
      matrix[ t ][ s ] += w;

      // Update column sum
      columnSum[ s ] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for( var j = 0; j < numNodes; j++ ){
      if( columnSum[ j ] === 0 ){
        // No 'links' out from node jth, assume equal probability for each possible node
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = matrix[ i ][ j ] / columnSum[ j ] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for( var i = 0; i < numNodes; i++ ){
      eigenvector.push( 1.0 );
      nullVector.push( 0.0 );
    }

    for( var iter = 0; iter < numIter; iter++ ){
      // New array with all 0's
      var temp = nullVector.slice( 0 );

      // Multiply matrix with previous result
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          temp[ i ] += matrix[ i ][ j ] * eigenvector[ j ];
        }
      }

      normalizeVector( temp );
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for( var i = 0; i < numNodes; i++ ){
        diff += Math.pow( previous[ i ] - eigenvector[ i ], 2 );
      }

      // If difference is less than the desired threshold, stop iterating
      if( diff < epsilon ){
        break;
      }
    }

    // Construct result
    var res = {
      rank: function( node ){
        if( is.string( node ) ){
          // is a selector string
          var nodeId = (cy.filter( node )[0]).id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[ id2position[ nodeId ] ];
      }
    };


    return res;
  } // pageRank

}); // elesfn

module.exports = elesfn;

},{"../../is":86}],18:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var elesfn = ({
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
});

module.exports = elesfn;

},{"../define":47}],19:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var elesfn = ({
  classes: function( classes ){
    classes = ( classes || '' ).match( /\S+/g ) || [];
    var self = this;
    var changed = [];
    var classesMap = {};

    // fill in classes map
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[ i ];

      classesMap[ cls ] = true;
    }

    // check and update each ele
    for( var j = 0; j < self.length; j++ ){
      var ele = self[ j ];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[ i ];
        var eleHasClass = eleClasses[ cls ];

        if( !eleHasClass ){
          changedEle = true;
          break;
        }
      }

      // check if ele has classes outside of those passed
      if( !changedEle ){
        var classes = Object.keys( eleClasses );

        for( var i = 0; i < classes.length; i++ ){
          var eleCls = classes[i];
          var eleHasClass = eleClasses[ eleCls ];
          var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function

          if( eleHasClass && !specdClass ){
            changedEle = true;
            break;
          }
        }
      }

      if( changedEle ){
        _p.classes = util.copy( classesMap );

        changed.push( ele );
      }
    }

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  addClass: function( classes ){
    return this.toggleClass( classes, true );
  },

  hasClass: function( className ){
    var ele = this[0];
    return ( ele != null && ele._private.classes[ className ] ) ? true : false;
  },

  toggleClass: function( classesStr, toggle ){
    var classes = classesStr.match( /\S+/g ) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for( var i = 0, il = self.length; i < il; i++ ){
      var ele = self[ i ];
      var changedEle = false;

      for( var j = 0; j < classes.length; j++ ){
        var cls = classes[ j ];
        var eleClasses = ele._private.classes;
        var hasClass = eleClasses[ cls ];
        var shouldAdd = toggle || (toggle === undefined && !hasClass);

        if( shouldAdd ){
          eleClasses[ cls ] = true;

          if( !hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        } else { // then remove
          eleClasses[ cls ] = false;

          if( hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        }

      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  removeClass: function( classes ){
    return this.toggleClass( classes, false );
  },

  flashClass: function( classes, duration ){
    var self = this;

    if( duration == null ){
      duration = 250;
    } else if( duration === 0 ){
      return self; // nothing to do really
    }

    self.addClass( classes );
    setTimeout( function(){
      self.removeClass( classes );
    }, duration );

    return self;
  }
});

module.exports = elesfn;

},{"../util":103}],20:[function(require,module,exports){
'use strict';

var elesfn = ({
  allAre: function( selector ){
    return this.filter( selector ).length === this.length;
  },

  is: function( selector ){
    return this.filter( selector ).length > 0;
  },

  some: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( ret ){
        return true;
      }
    }

    return false;
  },

  every: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( !ret ){
        return false;
      }
    }

    return true;
  },

  same: function( collection ){
    collection = this.cy().collection( collection );

    // cheap extra check
    if( this.length !== collection.length ){
      return false;
    }

    return this.intersect( collection ).length === this.length;
  },

  anySame: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length > 0;
  },

  allAreNeighbors: function( collection ){
    collection = this.cy().collection( collection );

    return this.neighborhood().intersect( collection ).length === collection.length;
  },

  contains: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length === collection.length;
  }
});

elesfn.allAreNeighbours = elesfn.allAreNeighbors;
elesfn.has = elesfn.contains;

module.exports = elesfn;

},{}],21:[function(require,module,exports){
'use strict';

var elesfn = ({
  parent: function( selector ){
    var parents = [];
    var cy = this._private.cy;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parent = cy.getElementById( ele._private.data.parent );

      if( parent.size() > 0 ){
        parents.push( parent );
      }
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  parents: function( selector ){
    var parents = [];

    var eles = this.parent();
    while( eles.nonempty() ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];
        parents.push( ele );
      }

      eles = eles.parent();
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  commonAncestors: function( selector ){
    var ancestors;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
    }

    return ancestors.filter( selector );
  },

  orphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isNode() && ele.parent().empty();
    } ).filter( selector );
  },

  nonorphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isNode() && ele.parent().nonempty();
    } ).filter( selector );
  },

  children: function( selector ){
    var children = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      children = children.concat( ele._private.children );
    }

    return this.spawn( children, { unique: true } ).filter( selector );
  },

  siblings: function( selector ){
    return this.parent().children().not( this ).filter( selector );
  },

  isParent: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.children.length !== 0;
    }
  },

  isChild: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.parent !== undefined && ele.parent().length !== 0;
    }
  },

  descendants: function( selector ){
    var elements = [];

    function add( eles ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        elements.push( ele );

        if( ele.children().nonempty() ){
          add( ele.children() );
        }
      }
    }

    add( this.children() );

    return this.spawn( elements, { unique: true } ).filter( selector );
  }
});

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

},{}],22:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var fn, elesfn;

fn = elesfn = ({

  data: define.data( {
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  removeData: define.removeData( {
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  } ),

  rscratch: define.data( {
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  } ),

  removeRscratch: define.removeData( {
    field: 'rscratch',
    triggerEvent: false
  } ),

  id: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.id;
    }
  }

});

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

},{"../define":47}],23:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var elesfn = {};

function defineDegreeFunction( callback ){
  return function( includeLoops ){
    var self = this;

    if( includeLoops === undefined ){
      includeLoops = true;
    }

    if( self.length === 0 ){ return; }

    if( self.isNode() && !self.removed() ){
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for( var i = 0; i < connectedEdges.length; i++ ){
        var edge = connectedEdges[ i ];

        if( !includeLoops && edge.isLoop() ){
          continue;
        }

        degree += callback( node, edge );
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend( elesfn, {
  degree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( edge.target() ) ){
      return 2;
    } else {
      return 1;
    }
  } ),

  indegree: defineDegreeFunction( function( node, edge ){
    if( edge.target().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } ),

  outdegree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } )
} );

function defineDegreeBoundsFunction( degreeFn, callback ){
  return function( includeLoops ){
    var ret;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[ i ];
      var degree = ele[ degreeFn ]( includeLoops );
      if( degree !== undefined && (ret === undefined || callback( degree, ret )) ){
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend( elesfn, {
  minDegree: defineDegreeBoundsFunction( 'degree', function( degree, min ){
    return degree < min;
  } ),

  maxDegree: defineDegreeBoundsFunction( 'degree', function( degree, max ){
    return degree > max;
  } ),

  minIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, min ){
    return degree < min;
  } ),

  maxIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, max ){
    return degree > max;
  } ),

  minOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, min ){
    return degree < min;
  } ),

  maxOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, max ){
    return degree > max;
  } )
} );

util.extend( elesfn, {
  totalDegree: function( includeLoops ){
    var total = 0;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      total += nodes[ i ].degree( includeLoops );
    }

    return total;
  }
} );

module.exports = elesfn;

},{"../util":103}],24:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var is = require( '../is' );
var util = require( '../util' );
var math = require( '../math' );
var fn, elesfn;

fn = elesfn = ({

  position: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'rtrigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      var updatedEles = eles.updateCompoundBounds();
      updatedEles.rtrigger( 'position' );
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  // position but no notification to renderer
  silentPosition: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      eles.updateCompoundBounds();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  positions: function( pos, silent ){
    if( is.plainObject( pos ) ){
      this.position( pos );

    } else if( is.fn( pos ) ){
      var fn = pos;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];

        var pos = fn.apply( ele, [ i, ele ] );

        if( pos && !ele.locked() && !ele.isParent() ){
          var elePos = ele._private.position;
          elePos.x = pos.x;
          elePos.y = pos.y;
        }
      }

      var updatedEles = this.updateCompoundBounds();
      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

      if( silent ){
        toTrigger.trigger( 'position' );
      } else {
        toTrigger.rtrigger( 'position' );
      }
    }

    return this; // chaining
  },

  silentPositions: function( pos ){
    return this.positions( pos, true );
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject( dim ) ? dim : undefined;
    var setting = rpos !== undefined || ( val !== undefined && is.string( dim ) );

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = ( val - pan[ dim ] ) / zoom;
          } else if( rpos !== undefined ){ // set whole position
            ele._private.position = {
              x: ( rpos.x - pan.x ) / zoom,
              y: ( rpos.y - pan.y ) / zoom
            };
          }
        }

        this.rtrigger( 'position' );
      } else { // getting
        var pos = ele._private.position;
        rpos = {
          x: pos.x * zoom + pan.x,
          y: pos.y * zoom + pan.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return rpos;
        } else { // then return the specified dimension
          return rpos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject( dim ) ? dim : undefined;
    var setting = ppos !== undefined || ( val !== undefined && is.string( dim ) );
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = val + origin[ dim ];
          } else if( ppos !== undefined ){ // set whole position
            ele._private.position = {
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            };
          }
        }

        this.rtrigger( 'position' );

      } else { // getting
        var pos = ele._private.position;
        var parent = hasCompoundNodes ? ele.parent() : null;
        var hasParent = parent && parent.length > 0;
        var relativeToParent = hasParent;

        if( hasParent ){
          parent = parent[0];
        }

        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

        ppos = {
          x: pos.x - origin.x,
          y: pos.y - origin.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return ppos;
        } else { // then return the specified dimension
          return ppos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  renderedBoundingBox: function( options ){
    var bb = this.boundingBox( options );
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();

    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  },

  updateCompoundBounds: function(){
    var cy = this.cy();

    // save cycles for non compound graphs or when style disabled
    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); }

    var updated = [];

    function update( parent ){
      if( !parent.isParent() ){ return; }

      var _p = parent._private;
      var children = parent.children();
      var includeLabels = parent.pstyle( 'compound-sizing-wrt-labels' ).value === 'include';

      var min = {
        width: {
          val: parent.pstyle( 'min-width' ).pfValue,
          left: parent.pstyle( 'min-width-bias-left' ),
          right: parent.pstyle( 'min-width-bias-right' )
        },
        height: {
          val: parent.pstyle( 'min-height' ).pfValue,
          top: parent.pstyle( 'min-height-bias-top' ),
          bottom: parent.pstyle( 'min-height-bias-bottom' )
        }
      };

      var bb = children.boundingBox( {
        includeLabels: includeLabels,
        includeShadows: false,
        includeOverlays: false,

        // updating the compound bounds happens outside of the regular
        // cache cycle (i.e. before fired events)
        useCache: false
      } );
      var pos = _p.position;

      function computeBiasValues( propDiff, propBias, propBiasComplement ){
        var biasDiff = 0;
        var biasComplementDiff = 0;
        var biasTotal = propBias + propBiasComplement;

        if( propDiff > 0 && biasTotal > 0 ){
          biasDiff = ( propBias / biasTotal ) * propDiff;
          biasComplementDiff = ( propBiasComplement / biasTotal ) * propDiff;
        }
        return {
          biasDiff: biasDiff,
          biasComplementDiff: biasComplementDiff
        };
      }

      var leftVal = min.width.left.value;
      if( min.width.left.units === 'px' && min.width.val > 0 ){
        leftVal = ( leftVal * 100 ) / min.width.val;
      }
      var rightVal = min.width.right.value;
      if( min.width.right.units === 'px' && min.width.val > 0 ){
        rightVal = ( rightVal * 100 ) / min.width.val;
      }

      var topVal = min.height.top.value;
      if( min.height.top.units === 'px' && min.height.val > 0 ){
        topVal = ( topVal * 100 ) / min.height.val;
      }

      var bottomVal = min.height.bottom.value;
      if( min.height.bottom.units === 'px' && min.height.val > 0 ){
        bottomVal = ( bottomVal * 100 ) / min.height.val;
      }

      var widthBiasDiffs = computeBiasValues( min.width.val - bb.w, leftVal, rightVal );
      var diffLeft = widthBiasDiffs.biasDiff;
      var diffRight = widthBiasDiffs.biasComplementDiff;

      var heightBiasDiffs = computeBiasValues( min.height.val - bb.h, topVal, bottomVal );
      var diffTop = heightBiasDiffs.biasDiff;
      var diffBottom = heightBiasDiffs.biasComplementDiff;

      _p.autoWidth = Math.max(bb.w, min.width.val);
      pos.x = (- diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

      _p.autoHeight = Math.max(bb.h, min.height.val);
      pos.y = (- diffBottom + bb.y1 + bb.y2 + diffTop) / 2;

      updated.push( parent );
    }

    // go up, level by level
    var eles = this;
    while( eles.nonempty() ){

      // update each parent node in this level
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        update( ele );
      }

      // next level
      eles = eles.parent();
    }

    // return changed
    return this.spawn( updated );
  }
});

var noninf = function( x ){
  if( x === Infinity || x === -Infinity ){
    return 0;
  }

  return x;
};

var updateBounds = function( b, x1, y1, x2, y2 ){
  // don't update with zero area boxes
  if( x2 - x1 === 0 || y2 - y1 === 0 ){ return; }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
};

var updateBoundsFromBox = function( b, b2 ){
  return updateBounds( b, b2.x1, b2.y1, b2.x2, b2.y2 );
};

var prefixedProperty = function( obj, field, prefix ){
  return util.getPrefixedProperty( obj, field, prefix );
};

var updateBoundsFromArrow = function( bounds, ele, prefix, options ){
  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle( prefix + '-arrow-shape' ).value;
  var x;
  var y;

  if( arrowType !== 'none' ){
    if( prefix === 'source' ){
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if( prefix === 'target' ){
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    }

    updateBounds( bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW );
  }
};

var updateBoundsFromLabel = function( bounds, ele, prefix, options ){
  var prefixDash;

  if( prefix ){
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle( prefixDash + 'label' ).strValue;

  if( label ){
    var halign = ele.pstyle( 'text-halign' );
    var valign = ele.pstyle( 'text-valign' );
    var labelWidth = prefixedProperty( rstyle, 'labelWidth', prefix );
    var labelHeight = prefixedProperty( rstyle, 'labelHeight', prefix );
    var labelX = prefixedProperty( rstyle, 'labelX', prefix );
    var labelY = prefixedProperty( rstyle, 'labelY', prefix );
    var marginX = ele.pstyle( prefixDash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( prefixDash + 'text-margin-y' ).pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle( prefixDash + 'text-rotation' );
    var shadowR = ele.pstyle( 'text-shadow-blur' ).pfValue / 2;
    var shadowX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;
    var shadowY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;
    var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;
    var outlineWidth = ele.pstyle( 'text-outline-width' ).pfValue;
    var borderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle( 'text-background-padding' ).pfValue;

    var lh = labelHeight + 2 * padding;
    var lw = labelWidth + 2 * padding;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if( isEdge ){
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch( halign.value ){
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch( valign.value ){
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }

    var isAutorotate = ( isEdge && rotation.strValue === 'autorotate' );
    var isPfValue = ( rotation.pfValue != null && rotation.pfValue !== 0 );

    if( isAutorotate || isPfValue ){
      var theta = isAutorotate ? prefixedProperty( _p.rstyle, 'labelAngle', prefix ) : rotation.pfValue;
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - labelX;
        y = y - labelY;

        return {
          x: x * cos - y * sin + labelX,
          y: x * sin + y * cos + labelY
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
      ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
    }

    lx1 += marginX - Math.max( outlineWidth, halfBorderWidth );
    lx2 += marginX + Math.max( outlineWidth, halfBorderWidth );
    ly1 += marginY - Math.max( outlineWidth, halfBorderWidth );
    ly2 += marginY + Math.max( outlineWidth, halfBorderWidth );

    updateBounds( bounds, lx1, ly1, lx2, ly2 );

    if( options.includeShadows && shadowOpacity > 0 ){
      lx1 += - shadowR + shadowX;
      lx2 += + shadowR + shadowX;
      ly1 += - shadowR + shadowY;
      ly2 += + shadowR + shadowY;

      updateBounds( bounds, lx1, ly1, lx2, ly2 );
    }
  }

  return bounds;
};

// get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function( ele, options ){
  var cy = ele._private.cy;
  var cy_p = cy._private;
  var styleEnabled = cy_p.styleEnabled;

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  var _p = ele._private;
  var display = styleEnabled ? ele.pstyle( 'display' ).value : 'element';
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2, x, y;
  var displayed = display !== 'none';

  if( displayed ){
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if( styleEnabled && options.includeOverlays ){
      overlayOpacity = ele.pstyle( 'overlay-opacity' ).value;

      if( overlayOpacity !== 0 ){
        overlayPadding = ele.pstyle( 'overlay-padding' ).value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if( styleEnabled ){
      w = ele.pstyle( 'width' ).pfValue;
      wHalf = w / 2;
    }

    if( isNode && options.includeNodes ){
      var pos = _p.position;
      x = pos.x;
      y = pos.y;
      var w = ele.outerWidth();
      var halfW = w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;

      // handle node dimensions
      /////////////////////////

      ex1 = x - halfW - overlayPadding;
      ex2 = x + halfW + overlayPadding;
      ey1 = y - halfH - overlayPadding;
      ey2 = y + halfH + overlayPadding;

      updateBounds( bounds, ex1, ey1, ex2, ey2 );

    } else if( isEdge && options.includeEdges ){
      var rstyle = _p.rstyle || {};

      // handle edge dimensions (rough box estimate)
      //////////////////////////////////////////////
      if( styleEnabled ){
        ex1 = Math.min( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ex2 = Math.max( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ey1 = Math.min( rstyle.srcY, rstyle.midY, rstyle.tgtY );
        ey2 = Math.max( rstyle.srcY, rstyle.midY, rstyle.tgtY );

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        updateBounds( bounds, ex1, ey1, ex2, ey2 );
      }

      // precise haystacks
      ////////////////////
      if( styleEnabled && ele.pstyle( 'curve-style' ).strValue === 'haystack' ){
        var hpts = rstyle.haystackPts;

        ex1 = hpts[0].x;
        ey1 = hpts[0].y;
        ex2 = hpts[1].x;
        ey2 = hpts[1].y;

        if( ex1 > ex2 ){
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if( ey1 > ey2 ){
          var temp = ey1;
          ey1 = ey2;
          ey2 = temp;
        }

        updateBounds( bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf );

      // handle points along edge
      ///////////////////////////
      } else {
        var pts = rstyle.bezierPts || rstyle.linePts || [];

        for( var j = 0; j < pts.length; j++ ){
          var pt = pts[ j ];

          ex1 = pt.x - wHalf;
          ex2 = pt.x + wHalf;
          ey1 = pt.y - wHalf;
          ey2 = pt.y + wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }

        // fallback on source and target positions
        //////////////////////////////////////////
        if( pts.length === 0 ){
          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;

          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          // take into account edge width
          ex1 -= wHalf;
          ex2 += wHalf;
          ey1 -= wHalf;
          ey2 += wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }
      }

    } // edges

    // shadow and overlay
    /////////////////////

    if( styleEnabled ){

      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;

      if( options.includeShadows && ele.pstyle('shadow-opacity').value > 0 ){
        var r = ele.pstyle('shadow-blur').pfValue / 2;
        var ox = ele.pstyle('shadow-offset-x').pfValue;
        var oy = ele.pstyle('shadow-offset-y').pfValue;

        updateBounds( bounds, ex1 - r + ox, ey1 - r + oy, ex2 + r + ox, ey2 + r + oy );
      }

      updateBounds( bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding );
    }

    // handle edge arrow size
    /////////////////////////

    if( styleEnabled && options.includeEdges && isEdge ){
      updateBoundsFromArrow( bounds, ele, 'mid-source', options );
      updateBoundsFromArrow( bounds, ele, 'mid-target', options );
      updateBoundsFromArrow( bounds, ele, 'source', options );
      updateBoundsFromArrow( bounds, ele, 'target', options );
    }

    // handle label dimensions
    //////////////////////////

    if( styleEnabled && options.includeLabels ){
      updateBoundsFromLabel( bounds, ele, null, options );

      if( isEdge ){
        updateBoundsFromLabel( bounds, ele, 'source', options );
        updateBoundsFromLabel( bounds, ele, 'target', options );
      }
    } // style enabled for labels
  } // if displayed

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  if( bounds.w > 0 && bounds.h > 0 && displayed ){
    math.expandBoundingBox( bounds, 1 );
  }

  return bounds;
};

var tf = function( val ){
  if( val ){
    return 't';
  } else {
    return 'f';
  }
};

var getKey = function( opts ){
  var key = '';

  key += tf( opts.incudeNodes );
  key += tf( opts.includeEdges );
  key += tf( opts.includeLabels );
  key += tf( opts.includeShadows );
  key += tf( opts.includeOverlays );

  return key;
};

var cachedBoundingBoxImpl = function( ele, opts ){
  var _p = ele._private;
  var bb;
  var headless = ele.cy().headless();
  var key = opts === defBbOpts ? defBbOptsKey : getKey( opts );

  if( !opts.useCache || headless || !_p.bbCache || !_p.bbCache[key] ){
    bb = boundingBoxImpl( ele, opts );

    if( !headless ){
      _p.bbCache = _p.bbCache || {};
      _p.bbCache[key] = bb;
    }
  } else {
    bb = _p.bbCache[key];
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeShadows: true,
  includeOverlays: true,
  useCache: true
};

var defBbOptsKey = getKey( defBbOpts );

elesfn.recalculateRenderedStyle = function( useCache ){
  var cy = this.cy();
  var renderer = cy.renderer();
  var styleEnabled = cy.styleEnabled();

  if( renderer && styleEnabled ){
    renderer.recalculateRenderedStyle( this, useCache );
  }

  return this;
};

function filledBbOpts( options ){
  return {
    includeNodes: util.default( options.includeNodes, defBbOpts.includeNodes ),
    includeEdges: util.default( options.includeEdges, defBbOpts.includeEdges ),
    includeLabels: util.default( options.includeLabels, defBbOpts.includeLabels ),
    includeShadows: util.default( options.includeShadows, defBbOpts.includeShadows ),
    includeOverlays: util.default( options.includeOverlays, defBbOpts.includeOverlays ),
    useCache: util.default( options.useCache, defBbOpts.useCache )
  };
}

elesfn.boundingBox = function( options ){
  // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function
  if( this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true) ){
    if( options === undefined ){
      options = defBbOpts;
    } else {
      options = filledBbOpts( options );
    }

    return cachedBoundingBoxImpl( this[0], options );
  }

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  options = options || util.staticEmptyObject();

  var opts = filledBbOpts( options );

  var eles = this;
  var cy = eles.cy();
  var styleEnabled = cy.styleEnabled();

  if( styleEnabled ){
    this.recalculateRenderedStyle( opts.useCache );
  }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' ){
      ele.parallelEdges().recalculateRenderedStyle( opts.useCache ); // n.b. ele.parallelEdges() single is cached
    }

    updateBoundsFromBox( bounds, cachedBoundingBoxImpl( ele, opts ) );
  }

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  return bounds;
};

var defineDimFns = function( opts ){
  opts.uppercaseName = util.capitalize( opts.name );
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize( opts.outerName );

  fn[ opts.name ] = function dimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        if( ele.isParent() ){
          return _p[ opts.autoName ] || 0;
        }

        var d = ele.pstyle( opts.name );

        switch( d.strValue ){
          case 'label':
            return _p.rstyle[ opts.labelName ] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var dim = ele[ opts.name ]();
        var border = ele.pstyle( 'border-width' ).pfValue; // n.b. 1/2 each side
        var padding = 2 * ele.pstyle( 'padding' ).pfValue;

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
    var ele = this[0];

    if( ele ){
      var d = ele[ opts.name ]();
      return d * this.cy().zoom();
    }
  };

  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
    var ele = this[0];

    if( ele ){
      var od = ele[ opts.outerName ]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns( {
  name: 'width'
} );

defineDimFns( {
  name: 'height'
} );

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;
fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

},{"../define":47,"../is":86,"../math":88,"../util":103}],25:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

// represents a node or an edge
var Element = function( cy, params, restore ){
  var self = this;
  restore = (restore === undefined || restore ? true : false);

  if( cy === undefined || params === undefined || !is.core( cy ) ){
    util.error( 'An element must have a core reference and parameters set' );
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if( group == null ){
    if( params.data && params.data.source != null && params.data.target != null ){
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if( group !== 'nodes' && group !== 'edges' ){
    util.error( 'An element must be of type `nodes` or `edges`; you specified `' + group + '`' );
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: {}, // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [], // array of children
    traversalCache: {} // cache of output of traversal functions
  };

  // renderedPosition overrides if specified
  if( params.renderedPosition ){
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    this._private.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  if( is.string( params.classes ) ){
    var classes = params.classes.split( /\s+/ );
    for( var i = 0, l = classes.length; i < l; i++ ){
      var cls = classes[ i ];
      if( !cls || cls === '' ){ continue; }

      self._private.classes[ cls ] = true;
    }
  }

  if( params.style || params.css ){
    cy.style().applyBypass( this, params.style || params.css );
  }

  if( restore === undefined || restore ){
    this.restore();
  }

};

module.exports = Element;

},{"../is":86,"../util":103}],26:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var elesfn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger(), // .trigger( events [, extraParams] )

  rtrigger: function( event, extraParams ){ // for internal use only
    if( this.length === 0 ){ return; } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify( {
      type: event,
      eles: this
    } );

    this.trigger( event, extraParams );
    return this;
  }
});

// aliases:
define.eventAliasesOn( elesfn );

module.exports = elesfn;

},{"../define":47}],27:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Selector = require( '../selector' );

var elesfn = ({
  nodes: function( selector ){
    return this.filter( function( i, element ){
      return element.isNode();
    } ).filter( selector );
  },

  edges: function( selector ){
    return this.filter( function( i, element ){
      return element.isEdge();
    } ).filter( selector );
  },

  filter: function( filter ){
    if( filter === undefined ){ // check this first b/c it's the most common/performant case
      return this;
    } else if( is.string( filter ) || is.elementOrCollection( filter ) ){
      return Selector( filter ).filter( this );
    } else if( is.fn( filter ) ){
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];

        if( filter.apply( ele, [ i, ele ] ) ){
          elements.push( ele );
        }
      }

      return this.spawn( elements );
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function( toRemove ){
    if( !toRemove ){
      return this;
    } else {

      if( is.string( toRemove ) ){
        toRemove = this.filter( toRemove );
      }

      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var element = this[ i ];

        var remove = toRemove._private.ids[ element.id() ];
        if( !remove ){
          elements.push( element );
        }
      }

      return this.spawn( elements );
    }

  },

  absoluteComplement: function(){
    var cy = this._private.cy;

    return cy.mutableElements().not( this );
  },

  intersect: function( other ){
    // if a selector is specified, then filter by it instead
    if( is.string( other ) ){
      var selector = other;
      return this.filter( selector );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
    var col = col1Smaller ? col1 : col2;

    for( var i = 0; i < col.length; i++ ){
      var id = col[ i ]._private.data.id;
      var ele = ids2[ id ];

      if( ele ){
        elements.push( ele );
      }
    }

    return this.spawn( elements );
  },

  xor: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( !inOther ){
          elements.push( ele );
        }
      }

    };

    add( col1, col2 );
    add( col2, col1 );

    return this.spawn( elements );
  },

  diff: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other, retEles ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( inOther ){
          both.push( ele );
        } else {
          retEles.push( ele );
        }
      }

    };

    add( col1, col2, left );
    add( col2, col1, right );

    return {
      left: this.spawn( left, { unique: true } ),
      right: this.spawn( right, { unique: true } ),
      both: this.spawn( both, { unique: true } )
    };
  },

  add: function( toAdd ){
    var cy = this._private.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    var elements = [];

    for( var i = 0; i < this.length; i++ ){
      elements.push( this[ i ] );
    }

    for( var i = 0; i < toAdd.length; i++ ){

      var add = !this._private.ids[ toAdd[ i ].id() ];
      if( add ){
        elements.push( toAdd[ i ] );
      }
    }

    return this.spawn( elements );
  },

  // in place merge on calling collection
  merge: function( toAdd ){
    var _p = this._private;
    var cy = _p.cy;

    if( !toAdd ){
      return this;
    }

    if( toAdd && is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    for( var i = 0; i < toAdd.length; i++ ){
      var toAddEle = toAdd[ i ];
      var id = toAddEle._private.data.id;
      var add = !_p.ids[ id ];

      if( add ){
        var index = this.length++;

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
        _p.indexes[ id ] = index;
      } else { // replace
        var index = _p.indexes[ id ];

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function( ele ){
    ele = ele[0];

    var _p = this._private;
    var id = ele._private.data.id;
    var i = _p.indexes[ id ];

    if( i == null ){
      return this; // no need to remove
    }

    // remove ele
    this[ i ] = undefined;
    _p.ids[ id ] = undefined;
    _p.indexes[ id ] = undefined;

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if( this.length > 1 && !unmergedLastEle ){
      var lastEleI = this.length - 1;
      var lastEle = this[ lastEleI ];
      var lastEleId = lastEle._private.data.id;

      this[ lastEleI ] = undefined;
      this[ i ] = lastEle;
      _p.indexes[ lastEleId ] = i;
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function( toRemove ){
    var cy = this._private.cy;

    if( !toRemove ){
      return this;
    }

    if( toRemove && is.string( toRemove ) ){
      var selector = toRemove;
      toRemove = cy.mutableElements().filter( selector );
    }

    for( var i = 0; i < toRemove.length; i++ ){
      this.unmergeOne( toRemove[ i ] );
    }

    return this; // chaining
  },

  map: function( mapFn, thisArg ){
    var arr = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var ret = thisArg ? mapFn.apply( thisArg, [ ele, i, eles ] ) : mapFn( ele, i, eles );

      arr.push( ret );
    }

    return arr;
  },

  reduce: function( fn, initialValue ){
    var val = initialValue;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      val = fn( val, eles[i], i, eles );
    }

    return val;
  },

  stdFilter: function( fn, thisArg ){
    var filterEles = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var include = thisArg ? fn.apply( thisArg, [ ele, i, eles ] ) : fn( ele, i, eles );

      if( include ){
        filterEles.push( ele );
      }
    }

    return this.spawn( filterEles );
  },

  max: function( valFn, thisArg ){
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val > max ){
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function( valFn, thisArg ){
    var min = Infinity;
    var minEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val < min ){
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
});

// aliases
var fn = elesfn;
fn[ 'u' ] = fn[ '|' ] = fn[ '+' ] = fn.union = fn.or = fn.add;
fn[ '\\' ] = fn[ '!' ] = fn[ '-' ] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn[ 'n' ] = fn[ '&' ] = fn[ '.' ] = fn.and = fn.intersection = fn.intersect;
fn[ '^' ] = fn[ '(+)' ] = fn[ '(-)' ] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

},{"../is":86,"../selector":90}],28:[function(require,module,exports){
'use strict';

var elesfn = ({
  isNode: function(){
    return this.group() === 'nodes';
  },

  isEdge: function(){
    return this.group() === 'edges';
  },

  isLoop: function(){
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function(){
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.group;
    }
  }
});


module.exports = elesfn;

},{}],29:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var Element = require( './element' );

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  generate: function( cy, element, tryThisId ){
    var id = tryThisId != null ? tryThisId : util.uuid();

    while( cy.hasElementWithId( id ) ){
      id = util.uuid();
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function( cy, elements, options ){
  if( cy === undefined || !is.core( cy ) ){
    util.error( 'A collection must have a reference to the core' );
    return;
  }

  var ids = {};
  var indexes = {};
  var createdElements = false;

  if( !elements ){
    elements = [];
  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = {};

    for( var i = 0, l = elements.length; i < l; i++ ){
      var json = elements[ i ];

      if( json.data == null ){
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if( data.id == null ){
        data.id = idFactory.generate( cy, json );
      } else if( cy.hasElementWithId( data.id ) || elesIds[ data.id ] ){
        continue; // can't create element if prior id already exists
      }

      var ele = new Element( cy, json, false );
      eles.push( ele );
      elesIds[ data.id ] = true;
    }

    elements = eles;
  }

  this.length = 0;

  for( var i = 0, l = elements.length; i < l; i++ ){
    var element = elements[ i ];
    if( !element ){  continue; }

    var id = element._private.data.id;

    if( !options || (options.unique && !ids[ id ] ) ){
      ids[ id ] = element;
      indexes[ id ] = this.length;

      this[ this.length ] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    ids: ids,
    indexes: indexes
  };

  // restore the elements if we created them from json
  if( createdElements ){
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function(){
  return 'collection';
};

elesfn.spawn = function( cy, eles, opts ){
  if( !is.core( cy ) ){ // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection( cy, eles, opts );
};

elesfn.spawnSelf = function(){
  return this.spawn( this );
};

elesfn.cy = function(){
  return this._private.cy;
};

elesfn.element = function(){
  return this[0];
};

elesfn.collection = function(){
  if( is.collection( this ) ){
    return this;
  } else { // an element
    return new Collection( this._private.cy, [ this ] );
  }
};

elesfn.unique = function(){
  return new Collection( this._private.cy, this, { unique: true } );
};

elesfn.hasElementWithId = function( id ){
  return !!this._private.ids[ id ];
};

elesfn.getElementById = function( id ){
  var cy = this._private.cy;
  var ele = this._private.ids[ id ];

  return ele ? ele : new Collection( cy ); // get ele or empty collection
};

elesfn.poolIndex = function(){
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this._private.data.id;

  return eles._private.indexes[ id ];
};

elesfn.json = function( obj ){
  var ele = this.element();
  var cy = this.cy();

  if( ele == null && obj ){ return this; } // can't set to no eles

  if( ele == null ){ return undefined; } // can't get from no eles

  var p = ele._private;

  if( is.plainObject( obj ) ){ // set

    cy.startBatch();

    if( obj.data ){
      ele.data( obj.data );
    }

    if( obj.position ){
      ele.position( obj.position );
    }

    // ignore group -- immutable

    var checkSwitch = function( k, trueFnName, falseFnName ){
      var obj_k = obj[ k ];

      if( obj_k != null && obj_k !== p[ k ] ){
        if( obj_k ){
          ele[ trueFnName ]();
        } else {
          ele[ falseFnName ]();
        }
      }
    };

    checkSwitch( 'removed', 'remove', 'restore' );

    checkSwitch( 'selected', 'select', 'unselect' );

    checkSwitch( 'selectable', 'selectify', 'unselectify' );

    checkSwitch( 'locked', 'lock', 'unlock' );

    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );

    if( obj.classes != null ){
      ele.classes( obj.classes );
    }

    cy.endBatch();

    return this;

  } else if( obj === undefined ){ // get

    var json = {
      data: util.copy( p.data ),
      position: util.copy( p.position ),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    json.classes = Object.keys( p.classes ).filter(function( cls ){
      return p.classes[cls];
    }).join(' ');

    return json;
  }
};

elesfn.jsons = function(){
  var jsons = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();

    jsons.push( json );
  }

  return jsons;
};

elesfn.clone = function(){
  var cy = this.cy();
  var elesArr = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();
    var clone = new Element( cy, json, false ); // NB no restore

    elesArr.push( clone );
  }

  return new Collection( cy, elesArr );
};
elesfn.copy = elesfn.clone;

elesfn.restore = function( notifyRenderer ){
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var nodes = [];
  var edges = [];
  var elements;
  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    if( !ele.removed() ){
      // don't need to handle this ele
      continue;
    }

    // keep nodes first in the array and edges after
    if( ele.isNode() ){ // put to front of array if node
      nodes.push( ele );
    } else { // put to end of array if edge
      edges.push( ele );
    }
  }

  elements = nodes.concat( edges );

  var i;
  var removeFromElements = function(){
    elements.splice( i, 1 );
    i--;
  };

  // now, restore each element
  for( i = 0; i < elements.length; i++ ){
    var ele = elements[ i ];

    var _private = ele._private;
    var data = _private.data;

    // the traversal cache should start fresh when ele is added
    _private.traversalCache = null;

    // set id and validate
    if( data.id === undefined ){
      data.id = idFactory.generate( cy, ele );

    } else if( is.number( data.id ) ){
      data.id = '' + data.id; // now it's a string

    } else if( is.emptyString( data.id ) || !is.string( data.id ) ){
      util.error( 'Can not create element with invalid string ID `' + data.id + '`' );

      // can't create element if it has empty string as id or non-string id
      removeFromElements();
      continue;
    } else if( cy.hasElementWithId( data.id ) ){
      util.error( 'Can not create second element with ID `' + data.id + '`' );

      // can't create element if one already has that id
      removeFromElements();
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if( ele.isNode() ){ // extra checks for nodes
      var node = ele;
      var pos = _private.position;

      // make sure the nodes have a defined position

      if( pos.x == null ){
        pos.x = 0;
      }

      if( pos.y == null ){
        pos.y = 0;
      }
    }

    if( ele.isEdge() ){ // extra checks for edges

      var edge = ele;
      var fields = [ 'source', 'target' ];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for( var j = 0; j < fieldsLength; j++ ){

        var field = fields[ j ];
        var val = data[ field ];

        if( is.number( val ) ){
          val = data[ field ] = '' + data[ field ]; // now string
        }

        if( val == null || val === '' ){
          // can't create if source or target is not defined properly
          util.error( 'Can not create edge `' + id + '` with unspecified ' + field );
          badSourceOrTarget = true;
        } else if( !cy.hasElementWithId( val ) ){
          // can't create edge if one of its nodes doesn't exist
          util.error( 'Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`' );
          badSourceOrTarget = true;
        }
      }

      if( badSourceOrTarget ){ removeFromElements(); continue; } // can't create this

      var src = cy.getElementById( data.source );
      var tgt = cy.getElementById( data.target );

      src._private.edges.push( edge );
      tgt._private.edges.push( edge );

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge

    // create mock ids / indexes maps for element so it can be used like collections
    _private.ids = {};
    _private.ids[ id ] = ele;
    _private.indexes = {};
    _private.indexes[ id ] = ele;

    _private.removed = false;
    cy.addToPool( ele );
  } // for each element

  // do compound node sanity checks
  for( var i = 0; i < nodes.length; i++ ){ // each node
    var node = nodes[ i ];
    var data = node._private.data;

    if( is.number( data.parent ) ){ // then automake string
      data.parent = '' + data.parent;
    }

    var parentId = data.parent;

    var specifiedParent = parentId != null;

    if( specifiedParent ){
      var parent = cy.getElementById( parentId );

      if( parent.empty() ){
        // non-existant parent; just remove it
        data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while( !ancestor.empty() ){
          if( node.same( ancestor ) ){
            // mark self as parent and remove from data
            selfAsParent = true;
            data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if( !selfAsParent ){
          // connect with children
          parent[0]._private.children.push( node );
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy_p.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  if( elements.length > 0 ){
    var restored = new Collection( cy, elements );

    for( var i = 0; i < restored.length; i++ ){
      var ele = restored[i];

      if( ele.isNode() ){ continue; }

      // adding an edge invalidates the traversal caches for the parallel edges
      var pedges = ele.parallelEdges();
      for( var j = 0; j < pedges.length; j++ ){
        pedges[j]._private.traversalCache = null;
      }

      // adding an edge invalidates the traversal cache for the connected nodes
      ele.source()[0]._private.traversalCache = null;
      ele.target()[0]._private.traversalCache = null;
    }

    var toUpdateStyle;

    if( cy_p.hasCompoundNodes ){
      toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.updateStyle( notifyRenderer );

    if( notifyRenderer ){
      restored.rtrigger( 'add' );
    } else {
      restored.trigger( 'add' );
    }
  }

  return self; // chainability
};

elesfn.removed = function(){
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function(){
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function( notifyRenderer ){
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges( node ){
    var edges = node._private.edges;
    for( var i = 0; i < edges.length; i++ ){
      add( edges[ i ] );
    }
  }


  // add descendant nodes
  function addChildren( node ){
    var children = node._private.children;

    for( var i = 0; i < children.length; i++ ){
      add( children[ i ] );
    }
  }

  function add( ele ){
    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
    if( alreadyAdded ){
      return;
    } else {
      elesToRemoveIds[ ele.id() ] = true;
    }

    if( ele.isNode() ){
      elesToRemove.push( ele ); // nodes are removed last

      addConnectedEdges( ele );
      addChildren( ele );
    } else {
      elesToRemove.unshift( ele ); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    add( ele );
  }

  function removeEdgeRef( node, edge ){
    var connectedEdges = node._private.edges;

    util.removeFromArray( connectedEdges, edge );

    // removing an edges invalidates the traversal cache for its nodes
    node._private.traversalCache = null;
  }

  function removeParallelRefs( edge ){
    // removing an edge invalidates the traversal caches for the parallel edges
    var pedges = edge.parallelEdges();
    for( var j = 0; j < pedges.length; j++ ){
      pedges[j]._private.traversalCache = null;
    }
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef( parent, ele ){
    ele = ele[0];
    parent = parent[0];

    var children = parent._private.children;
    var pid = parent.id();

    util.removeFromArray( children, ele );

    if( !alteredParents.ids[ pid ] ){
      alteredParents.ids[ pid ] = true;
      alteredParents.push( parent );
    }
  }

  // remove from core pool
  cy.removeFromPool( elesToRemove );

  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[ i ];

    // mark as removed
    ele._private.removed = true;

    // add to list of removed elements
    removed.push( ele );

    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
      var src = ele.source()[0];
      var tgt = ele.target()[0];

      removeEdgeRef( src, ele );
      removeEdgeRef( tgt, ele );
      removeParallelRefs( ele );

    } else { // remove reference to parent
      var parent = ele.parent();

      if( parent.length !== 0 ){
        removeChildRef( parent, ele );
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for( var i = 0; i < elesStillInside.length; i++ ){
    var ele = elesStillInside[ i ];

    if( ele.isParent() ){
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection( this.cy(), removed );
  if( removedElements.size() > 0 ){
    // must manually notify since trigger won't do this automatically once removed

    if( notifyRenderer ){
      this.cy().notify( {
        type: 'remove',
        eles: removedElements
      } );
    }

    removedElements.trigger( 'remove' );
  }

  // the parents who were modified by the removal need their style updated
  for( var i = 0; i < alteredParents.length; i++ ){
    var ele = alteredParents[ i ];

    if( !ele.removed() ){
      ele.updateStyle();
    }
  }

  return new Collection( cy, removed );
};

elesfn.move = function( struct ){
  var cy = this._private.cy;

  if( struct.source !== undefined || struct.target !== undefined ){
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.hasElementWithId( srcId );
    var tgtExists = cy.hasElementWithId( tgtId );

    if( srcExists || tgtExists ){
      var jsons = this.jsons();

      this.remove();

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'edges' ){
          if( srcExists ){ json.data.source = srcId; }

          if( tgtExists ){ json.data.target = tgtId; }

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons );
    }

  } else if( struct.parent !== undefined ){ // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.hasElementWithId( parentId );

    if( parentExists ){
      var jsons = this.jsons();
      var descs = this.descendants();
      var descsEtcJsons = descs.union( descs.union( this ).connectedEdges() ).jsons();

      this.remove(); // NB: also removes descendants and their connected edges

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'nodes' ){
          json.data.parent = parentId === null ? undefined : parentId;

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons.concat( descsEtcJsons ) );
    }
  }

  return this; // if nothing done
};

[
  require( './algorithms' ),
  require( './animation' ),
  require( './class' ),
  require( './comparators' ),
  require( './compounds' ),
  require( './data' ),
  require( './degree' ),
  require( './dimensions' ),
  require( './events' ),
  require( './filter' ),
  require( './group' ),
  require( './index' ),
  require( './iteration' ),
  require( './layout' ),
  require( './style' ),
  require( './switch-functions' ),
  require( './traversing' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = Collection;

},{"../is":86,"../util":103,"./algorithms":14,"./animation":18,"./class":19,"./comparators":20,"./compounds":21,"./data":22,"./degree":23,"./dimensions":24,"./element":25,"./events":26,"./filter":27,"./group":28,"./index":29,"./iteration":30,"./layout":31,"./style":32,"./switch-functions":33,"./traversing":34}],30:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var zIndexSort = require( './zsort' );

var elesfn = ({
  each: function( fn ){
    if( is.fn( fn ) ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var ret = fn.apply( ele, [ i, ele ] );

        if( ret === false ){ break; } // exit each early on return false
      }
    }
    return this;
  },

  forEach: function( fn, thisArg ){
    if( is.fn( fn ) ){

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

        if( ret === false ){ break; } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function(){
    var array = [];

    for( var i = 0; i < this.length; i++ ){
      array.push( this[ i ] );
    }

    return array;
  },

  slice: function( start, end ){
    var array = [];
    var thisSize = this.length;

    if( end == null ){
      end = thisSize;
    }

    if( start == null ){
      start = 0;
    }

    if( start < 0 ){
      start = thisSize + start;
    }

    if( end < 0 ){
      end = thisSize + end;
    }

    for( var i = start; i >= 0 && i < end && i < thisSize; i++ ){
      array.push( this[ i ] );
    }

    return this.spawn( array );
  },

  size: function(){
    return this.length;
  },

  eq: function( i ){
    return this[ i ] || this.spawn();
  },

  first: function(){
    return this[0] || this.spawn();
  },

  last: function(){
    return this[ this.length - 1 ] || this.spawn();
  },

  empty: function(){
    return this.length === 0;
  },

  nonempty: function(){
    return !this.empty();
  },

  sort: function( sortFn ){
    if( !is.fn( sortFn ) ){
      return this;
    }

    var sorted = this.toArray().sort( sortFn );

    return this.spawn( sorted );
  },

  sortByZIndex: function(){
    return this.sort( zIndexSort );
  },

  zDepth: function(){
    var ele = this[0];
    if( !ele ){ return undefined; }

    // var cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if( group === 'nodes' ){
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if( !ele.isParent() ){
        return Number.MAX_SAFE_INTEGER - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
    }
  }
});

module.exports = elesfn;

},{"../is":86,"./zsort":35}],31:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Promise = require('../promise');

var elesfn = ({

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function( layout, options, fn ){
    var nodes = this.nodes();
    var cy = this.cy();

    layout.trigger( { type: 'layoutstart', layout: layout } );

    layout.animations = [];

    var calculateSpacing = function( spacing, nodesBb, pos ){
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };
      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    if( options.animate ){
      var nodesBb = nodes.boundingBox();
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];

        var newPos = fn.call( node, i, node );
        var pos = node.position();

        if( !is.number( pos.x ) || !is.number( pos.y ) ){
          node.silentPosition( { x: 0, y: 0 } );
        }

        if ( options.spacingFactor && options.spacingFactor !== 1){
          var spacing = Math.abs(options.spacingFactor);
          newPos = calculateSpacing(spacing, nodesBb, newPos);
        }

        var ani = node.animation( {
          position: newPos,
          duration: options.animationDuration,
          easing: options.animationEasing
        } );

        layout.animations.push( ani );

        ani.play();
      }

      var onStep;
      cy.on( 'step.*', ( onStep = function(){
        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }
      }) );

      layout.one('layoutstop', function(){
        cy.off('step.*', onStep);
      });

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      Promise.all( layout.animations.map(function( ani ){
        return ani.promise();
      }) ).then(function(){
        cy.off('step.*', onStep);

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        }

        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }

        layout.one( 'layoutstop', options.stop );
        layout.trigger( { type: 'layoutstop', layout: layout } );
      });
    } else {
      if( options.spacingFactor && options.spacingFactor !== 1 ){
        var spacing = Math.abs( options.spacingFactor );
        nodes.positions( function( i, node ){
          var pos = fn( i, node );
          var nodesBb = nodes.boundingBox();
          return calculateSpacing( spacing, nodesBb, pos );
        });
      } else {
        nodes.positions( fn );
      }

      if( options.fit ){
        cy.fit( options.eles, options.padding );
      }

      if( options.zoom != null ){
        cy.zoom( options.zoom );
      }

      if( options.pan ){
        cy.pan( options.pan );
      }

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      layout.one( 'layoutstop', options.stop );
      layout.trigger( { type: 'layoutstop', layout: layout } );
    }

    return this; // chaining
  },

  layout: function( options ){
    var cy = this.cy();

    cy.layout( util.extend( {}, options, {
      eles: this
    } ) );

    return this;
  },

  makeLayout: function( options ){
    var cy = this.cy();

    return cy.makeLayout( util.extend( {}, options, {
      eles: this
    } ) );
  }

});

// aliases:
elesfn.createLayout = elesfn.makeLayout;

module.exports = elesfn;

},{"../is":86,"../promise":89,"../util":103}],32:[function(require,module,exports){
'use strict';

var is = require( '../is' );

var elesfn = ({

  // fully updates (recalculates) the style for the elements
  updateStyle: function( notifyRenderer ){
    var cy = this._private.cy;

    if( !cy.styleEnabled() ){ return this; }

    if( cy._private.batchingStyle ){
      var bEles = cy._private.batchStyleEles;

      bEles.merge( this );

      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;

    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( hasCompounds ){ // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge( this.descendants() ).merge( this.parents() );
    }

    style.apply( updatedEles );

    if( hasCompounds ){
      var updatedCompounds = updatedEles.updateCompoundBounds();

      // disable for performance for now
      // (as updatedCompounds would be a subset of updatedEles ayway b/c of selectors check)
      // if( updatedCompounds.length > 0 ){
      //   updatedEles.merge( updatedCompounds );
      // }
    }

    if( notifyRenderer ){
      updatedEles.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      updatedEles.trigger( 'style' ); // just fire the event
    }

    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function( notifyRenderer ){
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( !cy.styleEnabled() ){ return this; }

    style.updateMappers( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      toNotify.trigger( 'style' ); // just fire the event
    }
    return this; // chaining
  },

  // get the internal parsed style object for the specified property
  parsedStyle: function( property ){
    var ele = this[0];
    var cy = ele.cy();

    if( !cy.styleEnabled() ){ return; }

    if( ele ){
      return ele._private.style[ property ] || cy.style().getDefaultProperty( property );
    }
  },

  numericStyle: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      var pstyle = ele.pstyle( property );

      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },

  numericStyleUnits: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      return ele.pstyle( property ).units;
    }
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function( property ){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return this; }

    var ele = this[0];

    if( ele ){
      return cy.style().getRenderedStyle( ele, property );
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  style: function( name, value ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();

    if( is.plainObject( name ) ){ // then extend the bypass
      var props = name;
      style.applyBypass( this, props, updateTransitions );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger( 'style' ); // let the renderer know we've updated style

    } else if( is.string( name ) ){

      if( value === undefined ){ // then get the property from the style
        var ele = this[0];

        if( ele ){
          return style.getStylePropertyValue( ele, name );
        } else { // empty collection => can't get any value
          return;
        }

      } else { // then set the bypass with the property value
        style.applyBypass( this, name, value, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger( 'style' ); // let the renderer know we've updated style
      }

    } else if( name === undefined ){
      var ele = this[0];

      if( ele ){
        return style.getRawStyle( ele );
      } else { // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeStyle: function( names ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if( names === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeAllBypasses( ele, updateTransitions );
      }
    } else {
      names = names.split( /\s+/ );

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeBypasses( ele, names, updateTransitions );
      }
    }

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
    toNotify.rtrigger( 'style' ); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function(){
    this.css( 'display', 'element' );
    return this; // chaining
  },

  hide: function(){
    this.css( 'display', 'none' );
    return this; // chaining
  },

  visible: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return true; }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele ){
      if(
        ele.pstyle( 'visibility' ).value !== 'visible'
        || ele.pstyle( 'display' ).value !== 'element'
        || ele.pstyle('width').pfValue === 0
      ){
        return false;
      }

      if( ele._private.group === 'nodes' ){
        if( ele.pstyle('height').pfValue === 0 ){ return false; }

        if( !hasCompoundNodes ){ return true; }

        var parents = ele._private.data.parent ? ele.parents() : null;

        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[ i ];
            var pVis = parent.pstyle( 'visibility' ).value;
            var pDis = parent.pstyle( 'display' ).value;

            if( pVis !== 'visible' || pDis !== 'element' ){
              return false;
            }
          }
        }

        return true;
      } else {
        var src = ele._private.source;
        var tgt = ele._private.target;

        return src.visible() && tgt.visible();
      }

    }
  },

  hidden: function(){
    var ele = this[0];

    if( ele ){
      return !ele.visible();
    }
  },

  effectiveOpacity: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return 1; }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if( ele ){
      var _p = ele._private;
      var parentOpacity = ele.pstyle( 'opacity' ).value;

      if( !hasCompoundNodes ){ return parentOpacity; }

      var parents = !_p.data.parent ? null : ele.parents();

      if( parents ){
        for( var i = 0; i < parents.length; i++ ){
          var parent = parents[ i ];
          var opacity = parent.pstyle( 'opacity' ).value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if( ele ){
      if( !hasCompoundNodes ){
        return ele.pstyle( 'opacity' ).value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  backgrounding: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

});


elesfn.bypass = elesfn.css = elesfn.style;
elesfn.renderedCss = elesfn.renderedStyle;
elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
elesfn.pstyle = elesfn.parsedStyle;

module.exports = elesfn;

},{"../is":86}],33:[function(require,module,exports){
'use strict';

var elesfn = {};

function defineSwitchFunction( params ){
  return function(){
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if( args.length === 2 ){
      var data = args[0];
      var handler = args[1];
      this.on( params.event, data, handler );
    }

    // e.g. cy.nodes().select( handler )
    else if( args.length === 1 ){
      var handler = args[0];
      this.on( params.event, handler );
    }

    // e.g. cy.nodes().select()
    else if( args.length === 0 ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var able = !params.ableField || ele._private[ params.ableField ];
        var changed = ele._private[ params.field ] != params.value;

        if( params.overrideAble ){
          var overrideAble = params.overrideAble( ele );

          if( overrideAble !== undefined ){
            able = overrideAble;

            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
          }
        }

        if( able ){
          ele._private[ params.field ] = params.value;

          if( changed ){
            changedEles.push( ele );
          }
        }
      }

      var changedColl = this.spawn( changedEles );
      changedColl.updateStyle(); // change of state => possible change of style
      changedColl.trigger( params.event );
    }

    return this;
  };
}

function defineSwitchSet( params ){
  elesfn[ params.field ] = function(){
    var ele = this[0];

    if( ele ){
      if( params.overrideField ){
        var val = params.overrideField( ele );

        if( val !== undefined ){
          return val;
        }
      }

      return ele._private[ params.field ];
    }
  };

  elesfn[ params.on ] = defineSwitchFunction( {
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  } );

  elesfn[ params.off ] = defineSwitchFunction( {
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  } );
}

defineSwitchSet( {
  field: 'locked',
  overrideField: function( ele ){
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
} );

defineSwitchSet( {
  field: 'grabbable',
  overrideField: function( ele ){
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
} );

defineSwitchSet( {
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
} );

defineSwitchSet( {
  field: 'selectable',
  overrideField: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
} );

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function(){
  var ele = this[0];
  if( ele ){
    return ele._private.grabbed;
  }
};

defineSwitchSet( {
  field: 'active',
  on: 'activate',
  off: 'unactivate'
} );

elesfn.inactive = function(){
  var ele = this[0];
  if( ele ){
    return !ele._private.active;
  }
};

module.exports = elesfn;

},{}],34:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var elesfn = {};

var cache = function( fn, name ){
  return function traversalCache( arg1, arg2, arg3, arg4 ){
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if( selectorOrEles == null ){
      key = 'null';
    } else if( is.elementOrCollection( selectorOrEles ) && selectorOrEles.length === 1 ){
      key = '#' + selectorOrEles.id();
    }

    if( eles.length === 1 && key ){
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[ name ] = tch[ name ] || {};
      var cacheHit = ch[ key ];

      if( cacheHit ){
        return cacheHit;
      } else {
        return ( ch[ key ] = fn.call( eles, arg1, arg2, arg3, arg4 ) );
      }
    } else {
      return fn.call( eles, arg1, arg2, arg3, arg4 );
    }
  };
};

// DAG functions
////////////////

var defineDagExtremity = function( params ){
  return function dagExtremityImpl( selector ){
    var eles = this;
    var ret = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      if( !ele.isNode() ){
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if(
             ( params.noIncomingEdges && tgt === ele && src !== ele )
          || ( params.noOutgoingEdges && src === ele && tgt !== ele )
        ){
          disqualified = true;
          break;
        }
      }

      if( !disqualified ){
        ret.push( ele );
      }
    }

    return this.spawn( ret, { unique: true } ).filter( selector );
  };
};

var defineDagOneHop = function( params ){
  return function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];

      if( !ele.isNode() ){ continue; }

      var edges = ele.connectedEdges();
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        var src = edge.source();
        var tgt = edge.target();

        if( params.outgoing && src === ele ){
          oEles.push( edge );
          oEles.push( tgt );
        } else if( params.incoming && tgt === ele ){
          oEles.push( edge );
          oEles.push( src );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  };
};

var defineDagAllHops = function( params ){
  return function( selector ){
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for( ;; ){
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if( next.length === 0 ){ break; } // done if none left

      var newNext = false;
      for( var i = 0; i < next.length; i++ ){
        var n = next[ i ];
        var nid = n.id();

        if( !sElesIds[ nid ] ){
          sElesIds[ nid ] = true;
          sEles.push( n );
          newNext = true;
        }
      }

      if( !newNext ){ break; } // done if touched all outgoers already

      eles = next;
    }

    return this.spawn( sEles, { unique: true } ).filter( selector );
  };
};

util.extend( elesfn, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({ noIncomingEdges: true }),

  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({ noOutgoingEdges: true }),

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache( defineDagOneHop({ outgoing: true }) , 'outgoers' ),

  // aka DAG descendants
  successors: defineDagAllHops({ outgoing: true }),

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache( defineDagOneHop({ incoming: true }), 'incomers' ),

  // aka DAG ancestors
  predecessors: defineDagAllHops({ incoming: true })
} );


// Neighbourhood functions
//////////////////////////

util.extend( elesfn, {
  neighborhood: cache(function( selector ){
    var elements = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
      var node = nodes[ i ];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for( var j = 0; j < connectedEdges.length; j++ ){
        var edge = connectedEdges[ j ];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if( otherNode.length > 0 ){
          elements.push( otherNode[0] ); // add node 1 hop away
        }

        // add connected edge
        elements.push( edge[0] );
      }

    }

    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
  }, 'neighborhood'),

  closedNeighborhood: function( selector ){
    return this.neighborhood().add( this ).filter( selector );
  },

  openNeighborhood: function( selector ){
    return this.neighborhood( selector );
  }
} );

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend( elesfn, {
  source: cache(function sourceImpl( selector ){
    var ele = this[0];
    var src;

    if( ele ){
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter( selector ) : src;
  }, 'source'),

  target: cache(function targetImpl( selector ){
    var ele = this[0];
    var tgt;

    if( ele ){
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter( selector ) : tgt;
  }, 'target'),

  sources: defineSourceFunction( {
    attr: 'source'
  } ),

  targets: defineSourceFunction( {
    attr: 'target'
  } )
} );

function defineSourceFunction( params ){
  return function sourceImpl( selector ){
    var sources = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var src = ele._private[ params.attr ];

      if( src ){
        sources.push( src );
      }
    }

    return this.spawn( sources, { unique: true } ).filter( selector );
  };
}

util.extend( elesfn, {
  edgesWith: cache( defineEdgesWithFunction(), 'edgesWith', true ),

  edgesTo: cache( defineEdgesWithFunction( {
    thisIsSrc: true
  } ), 'edgesTo', true )
} );

function defineEdgesWithFunction( params ){

  return function edgesWithImpl( otherNodes ){
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if( is.string( otherNodes ) ){
      otherNodes = cy.$( otherNodes );
    }

    var thisIds = this._private.ids;
    var otherIds = otherNodes._private.ids;

    for( var h = 0; h < otherNodes.length; h++ ){
      var edges = otherNodes[ h ]._private.edges;

      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[ i ];
        var edgeData = edge._private.data;
        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if( !edgeConnectsThisAndOther ){ continue; }

        if( p.thisIsSrc || p.thisIsTgt ){
          if( p.thisIsSrc && !thisToOther ){ continue; }

          if( p.thisIsTgt && !otherToThis ){ continue; }
        }

        elements.push( edge );
      }
    }

    return this.spawn( elements, { unique: true } );
  };
}

util.extend( elesfn, {
  connectedEdges: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var node = eles[ i ];
      if( !node.isNode() ){ continue; }

      var edges = node._private.edges;

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        retEles.push( edge );
      }
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedEdges'),

  connectedNodes: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var edge = eles[ i ];
      if( !edge.isEdge() ){ continue; }

      retEles.push( edge.source()[0] );
      retEles.push( edge.target()[0] );
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedNodes'),

  parallelEdges: cache( defineParallelEdgesFunction(), 'parallelEdges' ),

  codirectedEdges: cache( defineParallelEdgesFunction( {
    codirected: true
  } ), 'codirectedEdges' )
} );

function defineParallelEdgesFunction( params ){
  var defaults = {
    codirected: false
  };
  params = util.extend( {}, defaults, params );

  return function parallelEdgesImpl( selector ){ // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for( var i = 0; i < edges.length; i++ ){
      var edge1 = edges[ i ];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for( var j = 0; j < srcEdges1.length; j++ ){
        var edge2 = srcEdges1[ j ];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
          elements.push( edge2 );
        }
      }
    }

    return this.spawn( elements, { unique: true } ).filter( selector );
  };

}

// Misc functions
/////////////////

util.extend( elesfn, {
  components: function(){
    var self = this;
    var cy = self.cy();
    var visited = self.spawn();
    var unvisited = self.nodes().spawnSelf();
    var components = [];

    var visitInComponent = function( node, component ){
      visited.merge( node );
      unvisited.unmerge( node );
      component.merge( node );
    };

    if( unvisited.empty() ){ return self.spawn(); }

    do {
      var component = cy.collection();
      components.push( component );

      var root = unvisited[0];
      visitInComponent( root, component );

      self.bfs({
        directed: false,
        roots: root,
        visit: function( i, depth, v, e, u ){
          visitInComponent( v, component );
        }
      } );

    } while( unvisited.length > 0 );

    return components.map(function( component ){
      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){
        return component.anySame( edge.source() ) && component.anySame( edge.target() );
      });

      return component.union( connectedEdges );
    });
  }
} );

module.exports = elesfn;

},{"../is":86,"../util":103}],35:[function(require,module,exports){
'use strict';

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */
var zIndexSort = function( a, b ){
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele){
    var style = ele.pstyle( 'z-compound-depth' );
    if ( style.value === 'auto' ){
      return hasCompoundNodes ? ele.zDepth() : 0
    } else if ( style.value === 'bottom' ){
      return -1
    } else if ( style.value === 'top' ){
      return Number.MAX_SAFE_INTEGER
    }
    // 'orphan'
    return 0
  }
  var depthDiff = getDepth(a) - getDepth(b);
  if ( depthDiff !== 0 ){
    return depthDiff
  }

  function getEleDepth(ele){
    var style = ele.pstyle( 'z-index-compare' );
    if ( style.value === 'auto' ){
      return ele.isNode() ? 1 : 0
    }
    // 'manual'
    return 0
  }
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if ( eleDiff !== 0 ){
    return eleDiff
  }

  var zDiff = a.pstyle( 'z-index' ).value - b.pstyle( 'z-index' ).value;
  if ( zDiff !== 0 ){
    return zDiff
  }
  // compare indices in the core (order added to graph w/ last on top)
  return a.poolIndex() - b.poolIndex();
};

module.exports = zIndexSort;

},{}],36:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Collection = require( '../collection' );
var Element = require( '../collection/element' );

var corefn = {
  add: function( opts ){

    var elements;
    var cy = this;

    // add the elements
    if( is.elementOrCollection( opts ) ){
      var eles = opts;

      if( eles._private.cy === cy ){ // same instance => just restore
        elements = eles.restore();

      } else { // otherwise, copy from json
        var jsons = [];

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[ i ];
          jsons.push( ele.json() );
        }

        elements = new Collection( cy, jsons );
      }
    }

    // specify an array of options
    else if( is.array( opts ) ){
      var jsons = opts;

      elements = new Collection( cy, jsons );
    }

    // specify via opts.nodes and opts.edges
    else if( is.plainObject( opts ) && (is.array( opts.nodes ) || is.array( opts.edges )) ){
      var elesByGroup = opts;
      var jsons = [];

      var grs = [ 'nodes', 'edges' ];
      for( var i = 0, il = grs.length; i < il; i++ ){
        var group = grs[ i ];
        var elesArray = elesByGroup[ group ];

        if( is.array( elesArray ) ){

          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
            var json = util.extend( { group: group }, elesArray[ j ] );

            jsons.push( json );
          }
        }
      }

      elements = new Collection( cy, jsons );
    }

    // specify options for one element
    else {
      var json = opts;
      elements = (new Element( cy, json )).collection();
    }

    return elements;
  },

  remove: function( collection ){
    if( is.elementOrCollection( collection ) ){
      // already have right ref
    } else if( is.string( collection ) ){
      var selector = collection;
      collection = this.$( selector );
    }

    return collection.remove();
  },

  load: function( elements, onload, ondone ){
    var cy = this;

    cy.notifications( false );

    // remove old elements
    var oldEles = cy.mutableElements();
    if( oldEles.length > 0 ){
      oldEles.remove();
    }

    if( elements != null ){
      if( is.plainObject( elements ) || is.array( elements ) ){
        cy.add( elements );
      }
    }

    cy.one( 'layoutready', function( e ){
      cy.notifications( true );
      cy.trigger( e ); // we missed this event by turning notifications off, so pass it on

      cy.notify( {
        type: 'load',
        eles: cy.mutableElements()
      } );

      cy.one( 'load', onload );
      cy.trigger( 'load' );
    } ).one( 'layoutstop', function(){
      cy.one( 'done', ondone );
      cy.trigger( 'done' );
    } );

    var layoutOpts = util.extend( {}, cy._private.options.layout );
    layoutOpts.eles = cy.elements();

    cy.layout( layoutOpts );

    return this;
  }
};

module.exports = corefn;

},{"../collection":29,"../collection/element":25,"../is":86,"../util":103}],37:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var util = require( '../util' );
var is = require( '../is' );

var corefn = ({

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function( eles ){
    var cy = this;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    cy._private.aniEles.merge( eles );
  },

  stopAnimationLoop: function(){
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function(){
    var cy = this;

    cy._private.animationsRunning = true;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function globalAnimationStep(){
      if( !cy._private.animationsRunning ){ return; }

      util.requestAnimationFrame( function animationStep( now ){
        handleElements( now );
        globalAnimationStep();
      } );
    }

    var renderer = cy.renderer();

    if( renderer && renderer.beforeRender ){ // let the renderer schedule animations
      renderer.beforeRender( function rendererAnimationStep( willDraw, now ){
        handleElements( now );
      }, renderer.beforeRenderPriorities.animations );
    } else { // manage the animation loop ourselves
      globalAnimationStep(); // first call
    }

    function handleElements( now ){
      var eles = cy._private.aniEles;
      var doneEles = [];

      function handleElement( ele, isCore ){
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false;

        // cancel all animations on display:none ele
        if( !isCore && ele.pstyle('display').value === 'none' ){
          // put all current and queue animations in this tick's current list
          // and empty the lists for the element
          current = current.splice( 0, current.length ).concat( queue.splice( 0, queue.length ) );

          // stop all animations
          for( var i = 0; i < current.length; i++ ){ current[i].stop(); }
        }

        // if nothing currently animating, get something from the queue
        if( current.length === 0 ){
          var next = queue.shift();

          if( next ){
            current.push( next );
          }
        }

        var callbacks = function( callbacks ){
          for( var j = callbacks.length - 1; j >= 0; j-- ){
            var cb = callbacks[ j ];

            cb();
          }

          callbacks.splice( 0, callbacks.length );
        };

        // step and remove if done
        for( var i = current.length - 1; i >= 0; i-- ){
          var ani = current[ i ];
          var ani_p = ani._private;

          if( ani_p.stopped ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.frames );

            continue;
          }

          if( !ani_p.playing && !ani_p.applying ){ continue; }

          // an apply() while playing shouldn't do anything
          if( ani_p.playing && ani_p.applying ){
            ani_p.applying = false;
          }

          if( !ani_p.started ){
            startAnimation( ele, ani, now );
          }

          step( ele, ani, now, isCore );

          if( is.fn( ani_p.step ) ){
            ani_p.step.call( ele, now );
          }

          if( ani_p.applying ){
            ani_p.applying = false;
          }

          callbacks( ani_p.frames );

          if( ani.completed() ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.completes );
          }

          ranAnis = true;
        }

        if( !isCore && current.length === 0 && queue.length === 0 ){
          doneEles.push( ele );
        }

        return ranAnis;
      } // handleElement

      // handle all eles
      var ranEleAni = false;
      for( var e = 0; e < eles.length; e++ ){
        var ele = eles[ e ];
        var handledThisEle = handleElement( ele );

        ranEleAni = ranEleAni || handledThisEle;
      } // each element

      var ranCoreAni = handleElement( cy, true );

      // notify renderer
      if( ranEleAni || ranCoreAni ){
        if( eles.length > 0 ){
          var updatedEles = eles.updateCompoundBounds().spawnSelf().merge( eles );

          cy.notify({
            type: 'draw',
            eles: updatedEles
          });
        } else {
          cy.notify({
            type: 'draw'
          });
        }
      }

      // remove elements from list of currently animating if its queues are empty
      eles.unmerge( doneEles );

      cy.trigger('step');

    } // handleElements

    function startAnimation( self, ani, now ){
      var isCore = is.core( self );
      var isEles = !isCore;
      var ele = self;
      var style = cy._private.style;
      var ani_p = ani._private;

      if( isEles ){
        var pos = ele._private.position;

        ani_p.startPosition = ani_p.startPosition || {
          x: pos.x,
          y: pos.y
        };

        ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle( ele, ani_p.style );
      }

      if( isCore ){
        var pan = cy._private.pan;

        ani_p.startPan = ani_p.startPan || {
          x: pan.x,
          y: pan.y
        };

        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
      }

      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }

    function step( self, ani, now, isCore ){
      var style = cy._private.style;
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;

      if( !ani_p.easingImpl ){

        if( pEasing == null ){ // use default
          ani_p.easingImpl = easings[ 'linear' ];

        } else { // then define w/ name
          var easingVals;

          if( is.string( pEasing ) ){
            var easingProp = style.parse( 'transition-timing-function', pEasing );

            easingVals = easingProp.value;

          } else { // then assume preparsed array
            easingVals = pEasing;
          }

          var name, args;

          if( is.string( easingVals ) ){
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice( 2 ).map( function( n ){ return +n; } );
          }

          if( args.length > 0 ){ // create with args
            if( name === 'spring' ){
              args.push( ani_p.duration ); // need duration to generate spring
            }

            ani_p.easingImpl = easings[ name ].apply( null, args );
          } else { // static impl by name
            ani_p.easingImpl = easings[ name ];
          }
        }

      }

      var easing = ani_p.easingImpl;
      var percent;

      if( ani_p.duration === 0 ){
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }

      if( ani_p.applying ){
        percent = ani_p.progress;
      }

      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( ani_p.delay == null ){ // then update

        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        var pos = _p.position;
        if( endPos && isEles ){
          if( valid( startPos.x, endPos.x ) ){
            pos.x = ease( startPos.x, endPos.x, percent, easing );
          }

          if( valid( startPos.y, endPos.y ) ){
            pos.y = ease( startPos.y, endPos.y, percent, easing );
          }

          self.trigger('position');
        }

        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if( animatingPan ){
          if( valid( startPan.x, endPan.x ) ){
            pan.x = ease( startPan.x, endPan.x, percent, easing );
          }

          if( valid( startPan.y, endPan.y ) ){
            pan.y = ease( startPan.y, endPan.y, percent, easing );
          }

          self.trigger( 'pan' );
        }

        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if( animatingZoom ){
          if( valid( startZoom, endZoom ) ){
            _p.zoom = ease( startZoom, endZoom, percent, easing );
          }

          self.trigger( 'zoom' );
        }

        if( animatingPan || animatingZoom ){
          self.trigger( 'viewport' );
        }

        var props = ani_p.style;
        if( props && props.length > 0 && isEles ){
          for( var i = 0; i < props.length; i++ ){
            var prop = props[ i ];
            var name = prop.name;
            var end = prop;

            var start = ani_p.startStyle[ name ];
            var easedVal = ease( start, end, percent, easing );

            style.overrideBypass( self, name, easedVal );
          } // for props

          self.trigger('style');

        } // if

      }

      ani_p.progress = percent;

      return percent;
    }

    function valid( start, end ){
      if( start == null || end == null ){
        return false;
      }

      if( is.number( start ) && is.number( end ) ){
        return true;
      } else if( (start) && (end) ){
        return true;
      }

      return false;
    }

    // assumes p0 = 0, p3 = 1
    function evalCubicBezier( p1, p2, t ){
      var one_t = 1 - t;
      var tsq = t * t;

      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
    }

    function cubicBezier( p1, p2 ){
      return function( start, end, percent ){
        return start + (end - start) * evalCubicBezier( p1, p2, percent );
      };
    }

    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function(){
      function springAccelerationForState( state ){
        return (-state.tension * state.x) - (state.friction * state.v);
      }

      function springEvaluateStateWithDerivative( initialState, dt, derivative ){
        var state = {
          x: initialState.x + derivative.dx * dt,
          v: initialState.v + derivative.dv * dt,
          tension: initialState.tension,
          friction: initialState.friction
        };

        return { dx: state.v, dv: springAccelerationForState( state ) };
      }

      function springIntegrateState( state, dt ){
        var a = {
          dx: state.v,
          dv: springAccelerationForState( state )
        },
        b = springEvaluateStateWithDerivative( state, dt * 0.5, a ),
        c = springEvaluateStateWithDerivative( state, dt * 0.5, b ),
        d = springEvaluateStateWithDerivative( state, dt, c ),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;

        return state;
      }

      return function springRK4Factory( tension, friction, duration ){

        var initState = {
          x: -1,
          v: 0,
          tension: null,
          friction: null
        },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration, dt, last_state;

        tension = parseFloat( tension ) || 500;
        friction = parseFloat( friction ) || 20;
        duration = duration || null;

        initState.tension = tension;
        initState.friction = friction;

        have_duration = duration !== null;

        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
        if( have_duration ){
          /* Run the simulation without a duration. */
          time_lapsed = springRK4Factory( tension, friction );
          /* Compute the adjusted time delta. */
          dt = time_lapsed / duration * DT;
        } else {
          dt = DT;
        }

        while( true ){
          /* Next/step function .*/
          last_state = springIntegrateState( last_state || initState, dt );
          /* Store the position. */
          path.push( 1 + last_state.x );
          time_lapsed += 16;
          /* If the change threshold is reached, break. */
          if( !(Math.abs( last_state.x ) > tolerance && Math.abs( last_state.v ) > tolerance) ){
            break;
          }
        }

        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
           computed path and returns a snapshot of the position according to a given percentComplete. */
        return !have_duration ? time_lapsed : function( percentComplete ){ return path[ (percentComplete * (path.length - 1)) | 0 ]; };
      };
    }());

    var easings = {
      'linear': function( start, end, percent ){
        return start + (end - start) * percent;
      },

      // default easings
      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),

      // sine
      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),

      // quad
      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),

      // cubic
      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),

      // quart
      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),

      // quint
      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),

      // expo
      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),

      // circ
      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),


      // user param easings...

      'spring': function( tension, friction, duration ){
        if( duration === 0 ){ // can't get a spring w/ duration 0
          return easings.linear; // duration 0 => jump to end so impl doesn't matter
        }

        var spring = generateSpringRK4( tension, friction, duration );

        return function( start, end, percent ){
          return start + (end - start) * spring( percent );
        };
      },

      'cubic-bezier': function( x1, y1, x2, y2 ){
        return cubicBezier( x1, y1, x2, y2 );
      }
    };

    function ease( startProp, endProp, percent, easingFn ){
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      var start, end;

      if( startProp.pfValue != null || startProp.value != null ){
        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
      } else {
        start = startProp;
      }

      if( endProp.pfValue != null || endProp.value != null ){
        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
      } else {
        end = endProp;
      }

      if( is.number( start ) && is.number( end ) ){
        return easingFn( start, end, percent );

      } else if( is.array( start ) && is.array( end ) ){
        var easedArr = [];

        for( var i = 0; i < end.length; i++ ){
          var si = start[ i ];
          var ei = end[ i ];

          if( si != null && ei != null ){
            var val = easingFn( si, ei, percent );

            if( startProp.roundValue ){ val = Math.round( val ); }

            easedArr.push( val );
          } else {
            easedArr.push( ei );
          }
        }

        return easedArr;
      }

      return undefined;
    }

  }

});

module.exports = corefn;

},{"../define":47,"../is":86,"../util":103}],38:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var corefn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger() // .trigger( events [, extraParams] )
});

define.eventAliasesOn( corefn );

module.exports = corefn;

},{"../define":47}],39:[function(require,module,exports){
'use strict';

var corefn = ({

  png: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png( options );
  },

  jpg: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg( options );
  }

});

corefn.jpeg = corefn.jpg;

module.exports = corefn;

},{}],40:[function(require,module,exports){
'use strict';

var window = require( '../window' );
var util = require( '../util' );
var Collection = require( '../collection' );
var is = require( '../is' );
var Promise = require( '../promise' );
var define = require( '../define' );

var Core = function( opts ){
  var cy = this;

  opts = util.extend( {}, opts );

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if( reg && reg.cy ){
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );

  var defVal = function( def, val, altVal ){
    if( val !== undefined ){
      return val;
    } else if( altVal !== undefined ){
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    initrender: false, // has initrender has been triggered
    options: options, // cached options
    elements: new Collection( this ), // elements in the graph
    listeners: [], // list of listeners
    aniEles: new Collection( this ), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false, // whether destroy was called
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal( true, options.zoomingEnabled ),
    userZoomingEnabled: defVal( true, options.userZoomingEnabled ),
    panningEnabled: defVal( true, options.panningEnabled ),
    userPanningEnabled: defVal( true, options.userPanningEnabled ),
    boxSelectionEnabled: defVal( true, options.boxSelectionEnabled ),
    autolock: defVal( false, options.autolock, options.autolockNodes ),
    autoungrabify: defVal( false, options.autoungrabify, options.autoungrabifyNodes ),
    autounselectify: defVal( false, options.autounselectify ),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number( options.zoom ) ? options.zoom : 1,
    pan: {
      x: is.plainObject( options.pan ) && is.number( options.pan.x ) ? options.pan.x : 0,
      y: is.plainObject( options.pan ) && is.number( options.pan.y ) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  // set selection type
  var selType = options.selectionType;
  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if( is.number( options.minZoom ) && is.number( options.maxZoom ) && options.minZoom < options.maxZoom ){
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if( is.number( options.minZoom ) && options.maxZoom === undefined ){
    _p.minZoom = options.minZoom;
  } else if( is.number( options.maxZoom ) && options.minZoom === undefined ){
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function( extData, next ){
    var anyIsPromise = extData.some( is.promise );

    if( anyIsPromise ){
      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
    } else {
      next( extData ); // exec synchronously for convenience
    }
  };

  // create the renderer
  cy.initRenderer( util.extend( {
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number( options.wheelSensitivity ) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number( options.pixelRatio ) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer ) );

  loadExtData([ options.style, options.elements ], function( thens ){
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if( _p.styleEnabled ){
      cy.setStyle( initStyle );
    }

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on( 'initrender', options.initrender );
      cy.on( 'initrender', function(){
        _p.initrender = true;
      } );
    }

    // initial load
    cy.load( initEles, function(){ // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( is.fn( options.ready ) ){
        cy.on( 'ready', options.ready );
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[ i ];
        cy.on( 'ready', fn );
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.trigger( 'ready' );
    }, options.done );

  } );
};

var corefn = Core.prototype; // short alias

util.extend( corefn, {
  instanceString: function(){
    return 'core';
  },

  isReady: function(){
    return this._private.ready;
  },

  isDestroyed: function(){
    return this._private.destroyed;
  },

  ready: function( fn ){
    if( this.isReady() ){
      this.trigger( 'ready', [], fn ); // just calls fn as though triggered via ready event
    } else {
      this.on( 'ready', fn );
    }

    return this;
  },

  initrender: function(){
    return this._private.initrender;
  },

  destroy: function(){
    var cy = this;
    if( cy.isDestroyed() ) return;

    cy.stopAnimationLoop();

    cy.destroyRenderer();

    this.trigger( 'destroy' );

    cy._private.destroyed = true;

    return cy;
  },

  hasElementWithId: function( id ){
    return this._private.elements.hasElementWithId( id );
  },

  getElementById: function( id ){
    return this._private.elements.getElementById( id );
  },

  selectionType: function(){
    return this._private.selectionType;
  },

  hasCompoundNodes: function(){
    return this._private.hasCompoundNodes;
  },

  headless: function(){
    return this._private.options.renderer.name === 'null';
  },

  styleEnabled: function(){
    return this._private.styleEnabled;
  },

  addToPool: function( eles ){
    this._private.elements.merge( eles );

    return this; // chaining
  },

  removeFromPool: function( eles ){
    this._private.elements.unmerge( eles );

    return this;
  },

  container: function(){
    return this._private.container;
  },

  options: function(){
    return util.copy( this._private.options );
  },

  json: function( obj ){
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    if( is.plainObject( obj ) ){ // set

      cy.startBatch();

      if( obj.elements ){
        var idInJson = {};

        var updateEles = function( jsons, gr ){
          for( var i = 0; i < jsons.length; i++ ){
            var json = jsons[ i ];
            var id = json.data.id;
            var ele = cy.getElementById( id );

            idInJson[ id ] = true;

            if( ele.length !== 0 ){ // existing element should be updated
              ele.json( json );
            } else { // otherwise should be added
              if( gr ){
                cy.add( util.extend( { group: gr }, json ) );
              } else {
                cy.add( json );
              }
            }
          }
        };

        if( is.array( obj.elements ) ){ // elements: []
          updateEles( obj.elements );

        } else { // elements: { nodes: [], edges: [] }
          var grs = [ 'nodes', 'edges' ];
          for( var i = 0; i < grs.length; i++ ){
            var gr = grs[ i ];
            var elements = obj.elements[ gr ];

            if( is.array( elements ) ){
              updateEles( elements, gr );
            }
          }
        }

        // elements not specified in json should be removed
        eles.stdFilter( function( ele ){
          return !idInJson[ ele.id() ];
        } ).remove();
      }

      if( obj.style ){
        cy.style( obj.style );
      }

      if( obj.zoom != null && obj.zoom !== _p.zoom ){
        cy.zoom( obj.zoom );
      }

      if( obj.pan ){
        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
          cy.pan( obj.pan );
        }
      }

      var fields = [
        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
        'panningEnabled', 'userPanningEnabled',
        'boxSelectionEnabled',
        'autolock', 'autoungrabify', 'autounselectify'
      ];

      for( var i = 0; i < fields.length; i++ ){
        var f = fields[ i ];

        if( obj[ f ] != null ){
          cy[ f ]( obj[ f ] );
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if( obj === undefined ){ // get
      var json = {};

      json.elements = {};
      eles.forEach( function( ele ){
        var group = ele.group();

        if( !json.elements[ group ] ){
          json.elements[ group ] = [];
        }

        json.elements[ group ].push( ele.json() );
      } );

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy( cy._private.pan );
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy( cy._private.options.renderer );
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  } )

} );

[
  require( './add-remove' ),
  require( './animation' ),
  require( './events' ),
  require( './export' ),
  require( './layout' ),
  require( './notification' ),
  require( './renderer' ),
  require( './search' ),
  require( './style' ),
  require( './viewport' )
].forEach( function( props ){
  util.extend( corefn, props );
} );

module.exports = Core;

},{"../collection":29,"../define":47,"../is":86,"../promise":89,"../util":103,"../window":110,"./add-remove":36,"./animation":37,"./events":38,"./export":39,"./layout":41,"./notification":42,"./renderer":43,"./search":44,"./style":45,"./viewport":46}],41:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var corefn = ({

  layout: function( params ){
    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );

    layout.run();

    return this; // chaining
  },

  makeLayout: function( options ){
    var cy = this;

    if( options == null ){
      util.error( 'Layout options must be specified to make a layout' );
      return;
    }

    if( options.name == null ){
      util.error( 'A `name` must be specified to make a layout' );
      return;
    }

    var name = options.name;
    var Layout = cy.extension( 'layout', name );

    if( Layout == null ){
      util.error( 'Can not apply layout: No such layout `' + name + '` found; did you include its JS file?' );
      return;
    }

    var eles;
    if( is.string( options.eles ) ){
      eles = cy.$( options.eles );
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout( util.extend( {}, options, {
      cy: cy,
      eles: eles
    } ) );

    return layout;
  }

});

corefn.createLayout = corefn.makeLayout;

module.exports = corefn;

},{"../is":86,"../util":103}],42:[function(require,module,exports){
'use strict';

var corefn = ({
  notify: function( params ){
    var _p = this._private;

    if( _p.batchingNotify ){
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if( params.eles ){
        bEles.merge( params.eles );
      }

      if( !bTypes.ids[ params.type ] ){
        bTypes.push( params.type );
        bTypes.ids[ params.type ] = true;
      }

      return; // notifications are disabled during batching
    }

    if( !_p.notificationsEnabled ){ return; } // exit on disabled

    var renderer = this.renderer();

    // exit if destroy() called on core or renderer in between frames #1499 #1528
    if( this.isDestroyed() || !renderer ){ return; }

    renderer.notify( params );
  },

  notifications: function( bool ){
    var p = this._private;

    if( bool === undefined ){
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function( callback ){
    this.notifications( false );
    callback();
    this.notifications( true );
  },

  startBatch: function(){
    var _p = this._private;

    if( _p.batchCount == null ){
      _p.batchCount = 0;
    }

    if( _p.batchCount === 0 ){
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];
      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function(){
    var _p = this._private;

    _p.batchCount--;

    if( _p.batchCount === 0 ){
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify( {
        type: _p.batchNotifyTypes,
        eles: _p.batchNotifyEles
      } );
    }

    return this;
  },

  batch: function( callback ){
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function( map ){
    var cy = this;

    return this.batch( function(){
      var ids = Object.keys( map );

      for( var i = 0; i < ids.length; i++ ){
        var id = ids[i];
        var data = map[ id ];
        var ele = cy.getElementById( id );

        ele.data( data );
      }
    } );
  }
});

module.exports = corefn;

},{}],43:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var corefn = ({

  renderTo: function( context, zoom, pan, pxRatio ){
    var r = this._private.renderer;

    r.renderTo( context, zoom, pan, pxRatio );
    return this;
  },

  renderer: function(){
    return this._private.renderer;
  },

  forceRender: function(){
    this.notify( {
      type: 'draw'
    } );

    return this;
  },

  resize: function(){
    this.invalidateSize();

    this.notify( {
      type: 'resize'
    } );

    this.trigger( 'resize' );

    return this;
  },

  initRenderer: function( options ){
    var cy = this;

    var RendererProto = cy.extension( 'renderer', options.name );
    if( RendererProto == null ){
      util.error( 'Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name );
      return;
    }

    var rOpts = util.extend( {}, options, {
      cy: cy
    } );

    cy._private.renderer = new RendererProto( rOpts );
  },

  destroyRenderer: function(){
    var cy = this;

    cy.notify( { type: 'destroy' } ); // destroy the renderer

    var domEle = cy.container();
    if( domEle ){
      domEle._cyreg = null;

      while( domEle.childNodes.length > 0 ){
        domEle.removeChild( domEle.childNodes[0] );
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref
  },

  onRender: function( fn ){
    return this.on('render', fn);
  },

  offRender: function( fn ){
    return this.off('render', fn);
  }

});

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

},{"../util":103}],44:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Collection = require( '../collection' );

var corefn = ({

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function( eles, opts ){

    if( is.string( eles ) ){
      return this.$( eles );

    } else if( is.elementOrCollection( eles ) ){
      return eles.collection();

    } else if( is.array( eles ) ){
      return new Collection( this, eles, opts );
    }

    return new Collection( this );
  },

  nodes: function( selector ){
    var nodes = this.$( function(){
      return this.isNode();
    } );

    if( selector ){
      return nodes.filter( selector );
    }

    return nodes;
  },

  edges: function( selector ){
    var edges = this.$( function(){
      return this.isEdge();
    } );

    if( selector ){
      return edges.filter( selector );
    }

    return edges;
  },

  // search the graph like jQuery
  $: function( selector ){
    var eles = this._private.elements;

    if( selector ){
      return eles.filter( selector );
    } else {
      return eles.spawnSelf();
    }
  },

  mutableElements: function(){
    return this._private.elements;
  }

});

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

},{"../collection":29,"../is":86}],45:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Style = require( '../style' );

var corefn = ({

  style: function( newStyle ){
    if( newStyle ){
      var s = this.setStyle( newStyle );

      s.update();
    }

    return this._private.style;
  },

  setStyle: function( style ){
    var _p = this._private;

    if( is.stylesheet( style ) ){
      _p.style = style.generateStyle( this );

    } else if( is.array( style ) ){
      _p.style = Style.fromJson( this, style );

    } else if( is.string( style ) ){
      _p.style = Style.fromString( this, style );

    } else {
      _p.style = Style( this );
    }

    return _p.style;
  }
});

module.exports = corefn;

},{"../is":86,"../style":95}],46:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var window = require( '../window' );

var corefn = ({

  autolock: function( bool ){
    if( bool !== undefined ){
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function( bool ){
    if( bool !== undefined ){
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function( bool ){
    if( bool !== undefined ){
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function(){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch( args.length ){
    case 0: // .pan()
      return pan;

    case 1:

      if( is.string( args[0] ) ){ // .pan('x')
        dim = args[0];
        return pan[ dim ];

      } else if( is.plainObject( args[0] ) ){ // .pan({ x: 0, y: 100 })
        if( !this._private.panningEnabled ){
          return this;
        }

        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x = x;
        }

        if( is.number( y ) ){
          pan.y = y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .pan('x', 100)
      if( !this._private.panningEnabled ){
        return this;
      }

      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] = val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  panBy: function( params ){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if( !this._private.panningEnabled ){
      return this;
    }

    switch( args.length ){
    case 1:

      if( is.plainObject( args[0] ) ){ // .panBy({ x: 0, y: 100 })
        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x += x;
        }

        if( is.number( y ) ){
          pan.y += y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .panBy('x', 100)
      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] += val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  fit: function( elements, padding ){
    var viewportState = this.getFitViewport( elements, padding );

    if( viewportState ){
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.trigger( 'pan zoom viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getFitViewport: function( elements, padding ){
    if( is.number( elements ) && padding === undefined ){ // elements is optional
      padding = elements;
      elements = undefined;
    }

    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return;
    }

    var bb;

    if( is.string( elements ) ){
      var sel = elements;
      elements = this.$( sel );

    } else if( is.boundingBox( elements ) ){ // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom;
    padding = is.number( padding ) ? padding : 0;

    if( !isNaN( w ) && !isNaN( h ) && w > 0 && h > 0 && !isNaN( bb.w ) && !isNaN( bb.h ) &&  bb.w > 0 && bb.h > 0 ){
      zoom = Math.min( (w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h );

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
        y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.minZoom;
    } else if( is.number( zoom ) ){
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.maxZoom;
    } else if( is.number( zoom ) ){
      this._private.maxZoom = zoom;
    }

    return this;
  },

  zoom: function( params ){
    var pos; // in rendered px
    var zoom;

    if( params === undefined ){ // then get the zoom
      return this._private.zoom;

    } else if( is.number( params ) ){ // then set the zoom
      zoom = params;

    } else if( is.plainObject( params ) ){ // then zoom about a point
      zoom = params.level;

      if( params.position ){
        var p = params.position;
        var pan = this._private.pan;
        var z = this._private.zoom;

        pos = { // convert to rendered px
          x: p.x * z + pan.x,
          y: p.y * z + pan.y
        };
      } else if( params.renderedPosition ){
        pos = params.renderedPosition;
      }

      if( pos && !this._private.panningEnabled ){
        return this; // panning disabled
      }
    }

    if( !this._private.zoomingEnabled ){
      return this; // zooming disabled
    }

    if( !is.number( zoom ) || ( pos && (!is.number( pos.x ) || !is.number( pos.y )) ) ){
      return this; // can't zoom with invalid params
    }

    // crop zoom
    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

    if( pos ){ // set zoom about position
      var pan1 = this._private.pan;
      var zoom1 = this._private.zoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };

      this._private.zoom = zoom;
      this._private.pan = pan2;

      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
      this.trigger( ' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );

    } else { // just set the zoom
      this._private.zoom = zoom;
      this.trigger( 'zoom viewport' );
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  viewport: function( opts ){
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if( !opts ){ return this; }
    if( !is.number( opts.zoom ) ){ zoomDefd = false; }
    if( !is.plainObject( opts.pan ) ){ panDefd = false; }
    if( !zoomDefd && !panDefd ){ return this; }

    if( zoomDefd ){
      var z = opts.zoom;

      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
        zoomFailed = true;

      } else {
        _p.zoom = z;

        events.push( 'zoom' );
      }
    }

    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
      var p = opts.pan;

      if( is.number( p.x ) ){
        _p.pan.x = p.x;
        panFailed = false;
      }

      if( is.number( p.y ) ){
        _p.pan.y = p.y;
        panFailed = false;
      }

      if( !panFailed ){
        events.push( 'pan' );
      }
    }

    if( events.length > 0 ){
      events.push( 'viewport' );
      this.trigger( events.join( ' ' ) );

      this.notify( {
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  center: function( elements ){
    var pan = this.getCenterPan( elements );

    if( pan ){
      this._private.pan = pan;

      this.trigger( 'pan viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getCenterPan: function( elements, zoom ){
    if( !this._private.panningEnabled ){
      return;
    }

    if( is.string( elements ) ){
      var selector = elements;
      elements = this.mutableElements().filter( selector );
    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
      y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
    };

    return pan;
  },

  reset: function(){
    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return this;
    }

    this.viewport( {
      pan: { x: 0, y: 0 },
      zoom: 1
    } );

    return this; // chaining
  },

  invalidateSize: function(){
    this._private.sizeCache = null;
  },

  size: function(){
    var _p = this._private;
    var container = _p.container;

    return ( _p.sizeCache = _p.sizeCache || ( container ? (function(){
      var rect = container.getBoundingClientRect();
      var style = window.getComputedStyle( container );
      var val = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };

      return {
        width: rect.width - val('padding-left') - val('padding-right') - val('border-left-width') - val('border-right-width'),
        height: rect.height - val('padding-top') - val('padding-bottom') - val('border-top-width') - val('border-bottom-width')
      };
    })() : { // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    } ) );
  },

  width: function(){
    return this.size().width;
  },

  height: function(){
    return this.size().height;
  },

  extent: function(){
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: ( rb.x1 - pan.x ) / zoom,
      x2: ( rb.x2 - pan.x ) / zoom,
      y1: ( rb.y1 - pan.y ) / zoom,
      y2: ( rb.y2 - pan.y ) / zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function(){
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
});

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

},{"../is":86,"../window":110}],47:[function(require,module,exports){
'use strict';

// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// var foo = define.foo({ /* params... */ })

var util = require( './util' );
var is = require( './is' );
var Selector = require( './selector' );
var Promise = require( './promise' );
var Event = require( './event' );
var Animation = require( './animation' );

var define = {

  // access data field
  data: function( params ){
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      onSet: function( self ){},
      canSet: function( self ){ return true; }
    };
    params = util.extend( {}, defaults, params );

    return function dataImpl( name, value ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if( is.string( name ) ){ // set or get property

        // .data('foo')
        if( p.allowGetting && value === undefined ){ // get

          var ret;
          if( single ){
            ret = single._private[ p.field ][ name ];
          }
          return ret;

        // .data('foo', 'bar')
        } else if( p.allowSetting && value !== undefined ){ // set
          var valid = !p.immutableKeys[ name ];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[ i ] ) ){
                all[ i ]._private[ p.field ][ name ] = value;
              }
            }

            // update mappers if asked
            if( p.updateStyle ){ self.updateStyle(); }

            // call onSet callback
            p.onSet( self );

            if( p.settingTriggersEvent ){
              self[ p.triggerFnName ]( p.settingEvent );
            }
          }
        }

      // .data({ 'foo': 'bar' })
      } else if( p.allowSetting && is.plainObject( name ) ){ // extend
        var obj = name;
        var k, v;
        var keys = Object.keys( obj );

        for( var i = 0; i < keys.length; i++ ){
          k = keys[ i ];
          v = obj[ k ];

          var valid = !p.immutableKeys[ k ];
          if( valid ){
            for( var j = 0; j < all.length; j++ ){
              var ele = all[j];

              if( p.canSet( ele ) ){
                ele._private[ p.field ][ k ] = v;
              }
            }
          }
        }

        // update mappers if asked
        if( p.updateStyle ){ self.updateStyle(); }

        // call onSet callback
        p.onSet( self );

        if( p.settingTriggersEvent ){
          self[ p.triggerFnName ]( p.settingEvent );
        }

      // .data(function(){ ... })
      } else if( p.allowBinding && is.fn( name ) ){ // bind to event
        var fn = name;
        self.on( p.bindingEvent, fn );

      // .data()
      } else if( p.allowGetting && name === undefined ){ // get whole object
        var ret;
        if( single ){
          ret = single._private[ p.field ];
        }
        return ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function( params ){
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend( {}, defaults, params );

    return function removeDataImpl( names ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like

      // .removeData('foo bar')
      if( is.string( names ) ){ // then get the list of keys, and delete them
        var keys = names.split( /\s+/ );
        var l = keys.length;

        for( var i = 0; i < l; i++ ){ // delete each non-empty key
          var key = keys[ i ];
          if( is.emptyString( key ) ){ continue; }

          var valid = !p.immutableKeys[ key ]; // not valid if immutable
          if( valid ){
            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
              all[ i_a ]._private[ p.field ][ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }

      // .removeData()
      } else if( names === undefined ){ // then delete all keys

        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
          var _privateFields = all[ i_a ]._private[ p.field ];
          var keys = Object.keys( _privateFields );

          for( var i = 0; i < keys.length; i++ ){
            var key = keys[i];
            var validKeyToDelete = !p.immutableKeys[ key ];

            if( validKeyToDelete ){
              _privateFields[ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }
      }

      return self; // maintain chaining
    }; // function
  }, // removeData

  // event function reusable stuff
  event: {
    regex: /(\w+)(\.(?:\w+|\*))?/, // regex for matching event strings (e.g. "click.namespace")
    universalNamespace: '.*', // matches as if no namespace specified and prevents users from unbinding accidentally
    optionalTypeRegex: /(\w+)?(\.(?:\w+|\*))?/,
    falseCallback: function(){ return false; }
  },

  // event binding
  on: function( params ){
    var defaults = {
      unbindSelfOnTrigger: false,
      unbindAllBindersOnTrigger: false
    };
    params = util.extend( {}, defaults, params );

    return function onImpl( events, selector, data, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var p = params;

      if( is.plainObject( selector ) ){ // selector is actually data
        callback = data;
        data = selector;
        selector = undefined;
      } else if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        data = undefined;
        selector = undefined;
      }

      if( is.fn( data ) || data === false ){ // data is actually callback
        callback = data;
        data = undefined;
      }

      // if there isn't a callback, we can't really do anything
      // (can't speak for mapped events arg version)
      if( !(is.fn( callback ) || callback === false) && eventsIsString ){
        return self; // maintain chaining
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];
        if( callback === false ){
          callback = define.event.falseCallback;
        }

        if( !is.fn( callback ) ){ continue; }

        evts = evts.split( /\s+/ );
        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]

          if( match ){
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            var listener = {
              callback: callback, // callback to run
              data: data, // extra data in eventObj.data
              delegated: selector ? true : false, // whether the evt is delegated
              selector: selector, // the selector to match for delegated events
              selObj: new Selector( selector ), // cached selector object to save rebuilding
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
              binders: all // who bound together
            };

            for( var j = 0; j < all.length; j++ ){
              var _p = all[ j ]._private = all[ j ]._private || {};

              _p.listeners = _p.listeners || [];
              _p.listeners.push( listener );
            }
          }
        } // for events array
      } // for events map

      return self; // maintain chaining
    }; // function
  }, // on

  eventAliasesOn: function( proto ){
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.removeListener = p.unlisten = p.unbind = p.off;
    p.emit = p.trigger;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function( events, selector ){
      var self = this;
      var args = Array.prototype.slice.call( arguments, 0 );

      return new Promise( function( resolve, reject ){
        var callback = function( e ){
          self.off.apply( self, offArgs );

          resolve( e );
        };

        var onArgs = args.concat( [ callback ] );
        var offArgs = onArgs.concat( [] );

        self.on.apply( self, onArgs );
      } );
    };
  },

  off: function offImpl( params ){
    var defaults = {
    };
    params = util.extend( {}, defaults, params );

    return function( events, selector, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );

      if( arguments.length === 0 ){ // then unbind all

        for( var i = 0; i < all.length; i++ ){
          all[ i ]._private = all[ i ]._private || {};

          _p.listeners = [];
        }

        return self; // maintain chaining
      }

      if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        selector = undefined;
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];

        if( callback === false ){
          callback = define.event.falseCallback;
        }

        evts = evts.split( /\s+/ );
        for( var h = 0; h < evts.length; h++ ){
          var evt = evts[ h ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
          if( match ){
            var type = match[1] ? match[1] : undefined;
            var namespace = match[2] ? match[2] : undefined;

            for( var i = 0; i < all.length; i++ ){ //
              var _p = all[ i ]._private = all[ i ]._private || {};
              var listeners = _p.listeners = _p.listeners || [];

              for( var j = 0; j < listeners.length; j++ ){
                var listener = listeners[ j ];
                var nsMatches = !namespace || namespace === listener.namespace;
                var typeMatches = !type || listener.type === type;
                var cbMatches = !callback || callback === listener.callback;
                var listenerMatches = nsMatches && typeMatches && cbMatches;

                // delete listener if it matches
                if( listenerMatches ){
                  listeners.splice( j, 1 );
                  j--;
                }
              } // for listeners
            } // for all
          } // if match
        } // for events array

      } // for events map

      return self; // maintain chaining
    }; // function
  }, // off

  trigger: function( params ){
    var defaults = {};
    params = util.extend( {}, defaults, params );

    return function triggerImpl( events, extraParams, fnToTrigger ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var eventsIsObject = is.plainObject( events );
      var eventsIsEvent = is.event( events );
      var _p = this._private = this._private || {};
      var cy = _p.cy || ( is.core( this ) ? this : null );
      var hasCompounds = cy ? cy.hasCompoundNodes() : false;

      if( eventsIsString ){ // then make a plain event object for each event name
        var evts = events.split( /\s+/ );
        events = [];

        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]
          var type = match[1];
          var namespace = match[2] ? match[2] : undefined;

          events.push( {
            type: type,
            namespace: namespace
          } );
        }
      } else if( eventsIsObject ){ // put in length 1 array
        var eventArgObj = events;

        events = [ eventArgObj ];
      }

      if( extraParams ){
        if( !is.array( extraParams ) ){ // make sure extra params are in an array if specified
          extraParams = [ extraParams ];
        }
      } else { // otherwise, we've got nothing
        extraParams = [];
      }

      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
        var evtObj = events[ i ];

        for( var j = 0; j < all.length; j++ ){ // for each
          var triggerer = all[ j ];
          var _p = triggerer._private = triggerer._private || {};
          var listeners = _p.listeners = _p.listeners || [];
          var triggererIsElement = is.element( triggerer );
          var bubbleUp = triggererIsElement || params.layout;

          // create the event for this element from the event object
          var evt;

          if( eventsIsEvent ){ // then just get the object
            evt = evtObj;

            evt.cyTarget = evt.cyTarget || triggerer;
            evt.cy = evt.cy || cy;

          } else { // then we have to make one
            evt = new Event( evtObj, {
              cyTarget: triggerer,
              cy: cy,
              namespace: evtObj.namespace
            } );
          }

          // if a layout was specified, then put it in the typed event
          if( evtObj.layout ){
            evt.layout = evtObj.layout;
          }

          // if triggered by layout, put in event
          if( params.layout ){
            evt.layout = triggerer;
          }

          // create a rendered position based on the passed position
          if( evt.cyPosition ){
            var pos = evt.cyPosition;
            var zoom = cy.zoom();
            var pan = cy.pan();

            evt.cyRenderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          if( fnToTrigger ){ // then override the listeners list with just the one we specified
            listeners = [ {
              namespace: evt.namespace,
              type: evt.type,
              callback: fnToTrigger
            } ];
          }

          for( var k = 0; k < listeners.length; k++ ){ // check each listener
            var lis = listeners[ k ];
            var nsMatches = !lis.namespace || lis.namespace === evt.namespace || lis.namespace === define.event.universalNamespace;
            var typeMatches = lis.type === evt.type;
            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element( evt.cyTarget ) && lis.selObj.matches( evt.cyTarget ) ) : (true); // we're not going to validate the hierarchy; that's too expensive
            var listenerMatches = nsMatches && typeMatches && targetMatches;

            if( listenerMatches ){ // then trigger it
              var args = [ evt ];
              args = args.concat( extraParams ); // add extra params to args list

              if( lis.data ){ // add on data plugged into binding
                evt.data = lis.data;
              } else { // or clear it in case the event obj is reused
                evt.data = undefined;
              }

              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                listeners.splice( k, 1 );
                k--;
              }

              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                var binders = lis.binders;
                for( var l = 0; l < binders.length; l++ ){
                  var binder = binders[ l ];
                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                  var binderListeners = binder._private.listeners;
                  for( var m = 0; m < binderListeners.length; m++ ){
                    var binderListener = binderListeners[ m ];

                    if( binderListener === lis ){ // delete listener from list
                      binderListeners.splice( m, 1 );
                      m--;
                    }
                  }
                }
              }

              // run the callback
              var context = lis.delegated ? evt.cyTarget : triggerer;
              var ret = lis.callback.apply( context, args );

              if( ret === false || evt.isPropagationStopped() ){
                // then don't bubble
                bubbleUp = false;

                if( ret === false ){
                  // returning false is a shorthand for stopping propagation and preventing the def. action
                  evt.stopPropagation();
                  evt.preventDefault();
                }
              }
            } // if listener matches
          } // for each listener

          // bubble up event for elements
          if( bubbleUp ){
            var parent = hasCompounds ? triggerer._private.parent : null;
            var hasParent = parent != null && parent.length !== 0;

            if( hasParent ){ // then bubble up to parent
              parent = parent[0];
              parent.trigger( evt );
            } else { // otherwise, bubble up to the core
              cy.trigger( evt );
            }
          }

        } // for each of all
      } // for each event

      return self; // maintain chaining
    }; // function
  }, // trigger

  animated: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animatedImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return false; }

      var ele = all[0];

      if( ele ){
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function clearQueueImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animate( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  delayAnimation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayAnimationImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animation( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  animation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animationImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if( !cy.styleEnabled() ){ return this; }

      var style = cy.style();

      properties = util.extend( {}, properties, params );

      if( properties.duration === undefined ){
        properties.duration = 400;
      }

      switch( properties.duration ){
      case 'slow':
        properties.duration = 600;
        break;
      case 'fast':
        properties.duration = 200;
        break;
      }

      var propertiesEmpty = Object.keys( properties ).length === 0;

      if( propertiesEmpty ){
        return new Animation( all[0], properties ); // nothing to animate
      }

      if( isEles ){
        properties.style = style.getPropsList( properties.style || properties.css );

        properties.css = undefined;
      }

      if( properties.renderedPosition && isEles ){
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = {
          x: ( rpos.x - pan.x ) / zoom,
          y: ( rpos.y - pan.y ) / zoom
        };
      }

      // override pan w/ panBy if set
      if( properties.panBy && isCore ){
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if( center && isCore ){
        var centerPan = cy.getCenterPan( center.eles, properties.zoom );

        if( centerPan ){
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if( properties.fit && isCore ){
        var fit = properties.fit;
        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

        if( fitVp ){
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      return new Animation( all[0], properties );
    };
  }, // animate

  animate: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animateImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      if( params ){
        properties = util.extend( {}, properties, params );
      }

      // manually hook and run the animation
      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function stopImpl( clearQueue, jumpToEnd ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var _p = ele._private;
        var anis = _p.animation.current;

        for( var j = 0; j < anis.length; j++ ){
          var ani = anis[ j ];
          var ani_p = ani._private;

          if( jumpToEnd ){
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if( clearQueue ){
          _p.animation.queue = [];
        }

        if( !jumpToEnd ){
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify( {
        eles: this,
        type: 'draw'
      } );

      return this;
    };
  } // stop

}; // define

module.exports = define;

},{"./animation":5,"./event":48,"./is":86,"./promise":89,"./selector":90,"./util":103}],48:[function(require,module,exports){
'use strict';

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function( src, props ){
  // Allow instantiation without the 'new' keyword
  if( !(this instanceof Event) ){
    return new Event( src, props );
  }

  // Event object
  if( src && src.type ){
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if( props ){
    // util.extend( this, props );

    // more efficient to manually copy fields we use
    this.type = props.type !== undefined ? props.type : this.type;
    this.cy = props.cy;
    this.cyTarget = props.cyTarget;
    this.cyPosition = props.cyPosition;
    this.cyRenderedPosition = props.cyRenderedPosition;
    this.namespace = props.namespace;
    this.layout = props.layout;
    this.data = props.data;
    this.message = props.message;
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();
};

function returnFalse(){
  return false;
}

function returnTrue(){
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function(){
    return 'event';
  },

  preventDefault: function(){
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if preventDefault exists run it on the original event
    if( e.preventDefault ){
      e.preventDefault();
    }
  },

  stopPropagation: function(){
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if stopPropagation exists run it on the original event
    if( e.stopPropagation ){
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function(){
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

},{}],49:[function(require,module,exports){
'use strict';

var util = require( './util' );
var define = require( './define' );
var Collection = require( './collection' );
var Core = require( './core' );
var incExts = require( './extensions' );
var is = require( './is' );

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension( type, name, registrant ){

  var ext = registrant;

  var overrideErr = function( field ){
    util.error( 'Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden' );
  };

  if( type === 'core' ){
    if( Core.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Core.prototype[ name ] = registrant;
    }

  } else if( type === 'collection' ){
    if( Collection.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Collection.prototype[ name ] = registrant;
    }

  } else if( type === 'layout' ){
    // fill in missing layout functions in the prototype

    var Layout = function( options ){
      this.options = options;

      registrant.call( this, options );

      // make sure layout has _private for use w/ std apis like .on()
      if( !is.plainObject( this._private ) ){
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
    };

    var layoutProto = Layout.prototype = Object.create( registrant.prototype );

    var optLayoutFns = [];

    for( var i = 0; i < optLayoutFns.length; i++ ){
      var fnName = optLayoutFns[ i ];

      layoutProto[ fnName ] = layoutProto[ fnName ] || function(){ return this; };
    }

    // either .start() or .run() is defined, so autogen the other
    if( layoutProto.start && !layoutProto.run ){
      layoutProto.run = function(){ this.start(); return this; };
    } else if( !layoutProto.start && layoutProto.run ){
      layoutProto.start = function(){ this.run(); return this; };
    }

    var regStop = registrant.prototype.stop;
    layoutProto.stop = function(){
      var opts = this.options;

      if( opts && opts.animate ){
        var anis = this.animations;

        if( anis ){
          for( var i = 0; i < anis.length; i++ ){
            anis[ i ].stop();
          }
        }
      }

      if( regStop ){
        regStop.call( this );
      } else {
        this.trigger( 'layoutstop' );
      }

      return this;
    };

    if( !layoutProto.destroy ){
      layoutProto.destroy = function(){
        return this;
      };
    }

    layoutProto.on = define.on( { layout: true } );
    layoutProto.one = define.on( { layout: true, unbindSelfOnTrigger: true } );
    layoutProto.once = define.on( { layout: true, unbindAllBindersOnTrigger: true } );
    layoutProto.off = define.off( { layout: true } );
    layoutProto.trigger = define.trigger( { layout: true } );

    define.eventAliasesOn( layoutProto );

    ext = Layout; // replace with our wrapped layout

  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
    // user registered renderers inherit from base

    var BaseRenderer = getExtension( 'renderer', 'base' );
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function(){
      BaseRenderer.apply( this, arguments );
      RegistrantRenderer.apply( this, arguments );
    };

    var proto = Renderer.prototype;

    for( var pName in bProto ){
      var pVal = bProto[ pName ];
      var existsInR = rProto[ pName ] != null;

      if( existsInR ){
        return overrideErr( pName );
      }

      proto[ pName ] = pVal; // take impl from base
    }

    for( var pName in rProto ){
      proto[ pName ] = rProto[ pName ]; // take impl from registrant
    }

    bProto.clientFunctions.forEach( function( name ){
      proto[ name ] = proto[ name ] || function(){
        util.error( 'Renderer does not implement `renderer.' + name + '()` on its prototype' );
      };
    } );

    ext = Renderer;

  }

  return util.setMap( {
    map: extensions,
    keys: [ type, name ],
    value: ext
  } );
}

function getExtension( type, name ){
  return util.getMap( {
    map: extensions,
    keys: [ type, name ]
  } );
}

function setModule( type, name, moduleType, moduleName, registrant ){
  return util.setMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ],
    value: registrant
  } );
}

function getModule( type, name, moduleType, moduleName ){
  return util.getMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ]
  } );
}

var extension = function(){
  // e.g. extension('renderer', 'svg')
  if( arguments.length === 2 ){
    return getExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if( arguments.length === 3 ){
    return setExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
  else if( arguments.length === 4 ){
    return getModule.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
  else if( arguments.length === 5 ){
    return setModule.apply( null, arguments );
  }

  else {
    util.error( 'Invalid extension access syntax' );
  }

};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach( function( group ){
  group.extensions.forEach( function( ext ){
    setExtension( group.type, ext.name, ext.impl );
  } );
} );

module.exports = extension;

},{"./collection":29,"./core":40,"./define":47,"./extensions":50,"./is":86,"./util":103}],50:[function(require,module,exports){
'use strict';

module.exports = [
  {
    type: 'layout',
    extensions: require( './layout' )
  },

  {
    type: 'renderer',
    extensions: require( './renderer' )
  }
];

},{"./layout":56,"./renderer":81}],51:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );
var is = require( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function BreadthFirstLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

BreadthFirstLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );
  var graph = eles;

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var roots;
  if( is.elementOrCollection( options.roots ) ){
    roots = options.roots;
  } else if( is.array( options.roots ) ){
    var rootsArray = [];

    for( var i = 0; i < options.roots.length; i++ ){
      var id = options.roots[ i ];
      var ele = cy.getElementById( id );
      rootsArray.push( ele );
    }

    roots = cy.collection( rootsArray );
  } else if( is.string( options.roots ) ){
    roots = cy.$( options.roots );

  } else {
    if( options.directed ){
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      while( unhandledNodes.length > 0 ){
        var currComp = cy.collection();

        eles.bfs( {
          roots: unhandledNodes[0],
          visit: function( i, depth, node, edge, pNode ){
            currComp = currComp.add( node );
          },
          directed: false
        } );

        unhandledNodes = unhandledNodes.not( currComp );
        components.push( currComp );
      }

      roots = cy.collection();
      for( var i = 0; i < components.length; i++ ){
        var comp = components[ i ];
        var maxDegree = comp.maxDegree( false );
        var compRoots = comp.filter( function(){
          return this.degree( false ) === maxDegree;
        } );

        roots = roots.add( compRoots );
      }

    }
  }


  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs( {
    roots: roots,
    directed: options.directed,
    visit: function( i, depth, node, edge, pNode ){
      var ele = this[0];
      var id = ele.id();

      if( !depths[ depth ] ){
        depths[ depth ] = [];
      }

      depths[ depth ].push( ele );
      foundByBfs[ id ] = true;
      id2depth[ id ] = depth;
      prevNode[ id ] = pNode;
      prevEdge[ id ] = edge;

      if( pNode ){
        var prevId = pNode.id();
        var succ = successors[ prevId ] = successors[ prevId ] || [];

        succ.push( node );
      }
    }
  } );

  // check for nodes not found by bfs
  var orphanNodes = [];
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[ i ];

    if( foundByBfs[ ele.id() ] ){
      continue;
    } else {
      orphanNodes.push( ele );
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while( orphanNodes.length !== 0 && checks < maxChecks ){
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for( var i = 0; i < neighbors.length; i++ ){
      var depth = id2depth[ neighbors[ i ].id() ];

      if( depth !== undefined ){
        depths[ depth ].push( node );
        assignedDepth = true;
        break;
      }
    }

    if( !assignedDepth ){
      orphanNodes.push( node );
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while( orphanNodes.length !== 0 ){
    var node = orphanNodes.shift();
    //var subgraph = graph.bfs( node ).path;
    var assignedDepth = false;

    // for( var i = 0; i < subgraph.length; i++ ){
    //   var depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
      if( depths.length === 0 ){
        depths.push( [] );
      }

      depths[0].push( node );
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function(){
    for( var i = 0; i < depths.length; i++ ){
      var eles = depths[ i ];

      for( var j = 0; j < eles.length; j++ ){
        var ele = eles[ j ];

        ele._private.scratch.breadthfirst = {
          depth: i,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();


  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges( function(){
      return this.data( 'target' ) === node.id();
    } );
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther;
    for( var i = 0; i < edges.length; i++ ){
      var edge = edges[ i ];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

  // make maximal if so set by adjusting depths
  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

    var nDepths = depths.length;
    var elesToMove = [];
    for( var i = 0; i < nDepths; i++ ){
      var depth = depths[ i ];

      var nDepth = depth.length;
      for( var j = 0; j < nDepth; j++ ){
        var ele = depth[ j ];
        var info = ele._private.scratch.breadthfirst;
        var intEle = intersectsDepth( ele );

        if( intEle ){
          info.intEle = intEle;
          elesToMove.push( ele );
        }
      }
    }

    for( var i = 0; i < elesToMove.length; i++ ){
      var ele = elesToMove[ i ];
      var info = ele._private.scratch.breadthfirst;
      var intEle = info.intEle;
      var intInfo = intEle._private.scratch.breadthfirst;

      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while( newDepth > depths.length - 1 ){
        depths.push( [] );
      }
      depths[ newDepth ].push( ele );

      info.depth = newDepth;
      info.index = depths[ newDepth ].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if( options.avoidOverlap ){
    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[ i ];
      var nbb = n.boundingBox();
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max( minDistance, w, h );
    }
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function( ele ){
    if( cachedWeightedPercent[ ele.id() ] ){
      return cachedWeightedPercent[ ele.id() ];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not( ':parent' ).intersection(nodes);
    var percent = 0;
    var samples = 0;

    for( var i = 0; i < neighbors.length; i++ ){
      var neighbor = neighbors[ i ];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var depth = bf.depth;
      var nDepth = depths[ depth ].length;

      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max( 1, samples );
    percent = percent / samples;

    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ ele.id() ] = percent;
    return percent;
  };


  // rearrange the indices in each depth level based on connectivity

  var sortFn = function( a, b ){
    var apct = getWeightedPercent( a );
    var bpct = getWeightedPercent( b );

    return apct - bpct;
  };

  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

    for( var i = 0; i < depths.length; i++ ){
      depths[ i ] = depths[ i ].sort( sortFn );
    }
    assignDepthsToEles(); // and update

  }

  var biggestDepthSize = 0;
  for( var i = 0; i < depths.length; i++ ){
    biggestDepthSize = Math.max( depths[ i ].length, biggestDepthSize );
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };

  var getPosition = function( ele, isBottomDepth ){
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[ depth ].length;

    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
    radiusStepSize = Math.max( radiusStepSize, minDistance );

    if( !options.circle ){

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if( isBottomDepth ){
        return epos;
      }

      // var succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( var i = 0 ; i < succs.length; i++ ){
      //     var spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;

    } else {
      if( options.circle ){
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
        var theta = 2 * Math.PI / depths[ depth ].length * index;

        if( depth === 0 && depths[0].length === 1 ){
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos( theta ),
          y: center.y + radius * Math.sin( theta )
        };

      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }

  };

  // get positions in reverse depth order
  var pos = {};
  for( var i = depths.length - 1; i >= 0; i-- ){
    var depth = depths[ i ];

    for( var j = 0; j < depth.length; j++ ){
      var node = depth[ j ];

      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
    }
  }

  nodes.layoutPositions( this, options, function(){
    return pos[ this.id() ];
  } );

  return this; // chaining
};

module.exports = BreadthFirstLayout;

},{"../../is":86,"../../math":88,"../../util":103}],52:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );
var is = require( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined, // the radius of the circle
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function CircleLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

CircleLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;

  var dTheta = sweep / ( Math.max( 1, nodes.length - 1 ) );
  var r;

  var minDistance = 0;
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max( minDistance, w, h );
  }

  if( is.number( options.radius ) ){
    r = options.radius;
  } else if( nodes.length <= 1 ){
    r = 0;
  } else {
    r = Math.min( bb.h, bb.w ) / 2 - minDistance;
  }

  // calculate the radius
  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos( dTheta ) - Math.cos( 0 );
    var dsin = Math.sin( dTheta ) - Math.sin( 0 );
    var rMin = Math.sqrt( minDistance * minDistance / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping
    r = Math.max( rMin, r );
  }

  var getPos = function( i, ele ){
    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );

    var rx = r * Math.cos( theta );
    var ry = r * Math.sin( theta );
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = CircleLayout;

},{"../../is":86,"../../math":88,"../../util":103}],53:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up  
  concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function( nodes ){ // the variation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function ConcentricLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

ConcentricLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var value;

    // calculate the node value
    value = options.concentric.apply( node, [ node ] );
    nodeValues.push( {
      value: value,
      node: node
    } );

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var nbb = node.boundingBox();

    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
  }

  // sort node values in descreasing order
  nodeValues.sort( function( a, b ){
    return b.value - a.value;
  } );

  var levelWidth = options.levelWidth( nodes );

  // put the values into levels
  var levels = [ [] ];
  var currentLevel = levels[0];
  for( var i = 0; i < nodeValues.length; i++ ){
    var val = nodeValues[ i ];

    if( currentLevel.length > 0 ){
      var diff = Math.abs( currentLevel[0].value - val.value );

      if( diff >= levelWidth ){
        currentLevel = [];
        levels.push( currentLevel );
      }
    }

    currentLevel.push( val );
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if( !options.avoidOverlap ){ // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = ( Math.min( bb.w, bb.h ) / 2 - minDist );
    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

    minDist = Math.min( minDist, rStep );
  }

  // find the metrics for each level
  var r = 0;
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / ( Math.max( 1, level.length - 1 ) );

    // calculate the radius
    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      var dcos = Math.cos( dTheta ) - Math.cos( 0 );
      var dsin = Math.sin( dTheta ) - Math.sin( 0 );
      var rMin = Math.sqrt( minDist * minDist / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping

      r = Math.max( rMin, r );
    }

    level.r = r;

    r += minDist;
  }

  if( options.equidistant ){
    var rDeltaMax = 0;
    var r = 0;

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];
      var rDelta = level.r - r;

      rDeltaMax = Math.max( rDeltaMax, rDelta );
    }

    r = 0;
    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];

      if( i === 0 ){
        r = level.r;
      }

      level.r = r;

      r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var dTheta = level.dTheta;
    var r = level.r;

    for( var j = 0; j < level.length; j++ ){
      var val = level[ j ];
      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;

      var p = {
        x: center.x + r * Math.cos( theta ),
        y: center.y + r * Math.sin( theta )
      };

      pos[ val.node.id() ] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions( this, options, function(){
    var id = this.id();

    return pos[ id ];
  } );

  return this; // chaining
};

module.exports = ConcentricLayout;

},{"../../math":88,"../../util":103}],54:[function(require,module,exports){
'use strict';

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = require( '../../util' );
var math = require( '../../math' );
var Thread = require( '../../thread' );
var is = require( '../../is' );

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready: function(){},

  // Called on `layoutstop`
  stop: function(){},

  // Whether to animate while running the layout
  animate: true,

  // The layout animates only after this many milliseconds
  // (prevents flashing on fast runs)
  animationThreshold: 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh: 20,

  // Whether to fit the network view after when done
  fit: true,

  // Padding on fit
  padding: 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,

  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,

  // Extra spacing between components in non-compound graphs
  componentSpacing: 100,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function( node ){ return 400000; },

  // Node repulsion (overlapping) multiplier
  nodeOverlap: 10,

  // Ideal edge (non nested) length
  idealEdgeLength: function( edge ){ return 10; },

  // Divisor to compute edge forces
  edgeElasticity: function( edge ){ return 100; },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 5,

  // Gravity force (constant)
  gravity: 80,

  // Maximum number of iterations to perform
  numIter: 1000,

  // Initial temperature (maximum node displacement)
  initialTemp: 200,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.95,

  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0,

  // Whether to use threading to speed up the layout
  useMultitasking: true,

  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  spacingFactor: undefined
};


/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout( options ){
  this.options = util.extend( {}, defaults, options );

  this.options.layout = this;
}


/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function(){
  var options = this.options;
  var cy      = options.cy;
  var layout  = this;
  var thread  = this.thread;

  if( !thread || thread.stopped() ){
    thread = this.thread = Thread( { disabled: !options.useMultitasking } );
  }

  layout.stopped = false;

  layout.trigger( { type: 'layoutstart', layout: layout } );

  // Set DEBUG - Global variable
  if( true === options.debug ){
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo( cy, layout, options );

  // Show LayoutInfo contents if debugging
  if( DEBUG ){
    printLayoutInfo( layoutInfo );
  }

  // If required, randomize node positions
  if (options.randomize) {
    randomizePositions( layoutInfo, cy );
  }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function( rOpts ){
    rOpts = rOpts || {};

    if( refreshRequested && !rOpts.next ){
      return;
    }

    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame( function(){
      refreshPositions( layoutInfo, cy, options );

      // Fit the graph if necessary
      if( true === options.fit ){
        cy.fit( options.padding );
      }

      refreshRequested = false;

      if( rOpts.next ){ rOpts.next(); }
    });
  };

  thread.on( 'message', function( e ){
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  } );

  thread.pass( {
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  } ).run( function( pass ){
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function( layoutInfo, options, step ){
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces( layoutInfo, options );
      // Calculate edge forces
      calculateEdgeForces( layoutInfo, options );
      // Calculate gravity forces
      calculateGravityForces( layoutInfo, options );
      // Propagate forces from parent to child
      propagateForces( layoutInfo, options );
      // Update positions based on calculated forces
      updatePositions( layoutInfo, options );
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function( layoutInfo, options ){
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for( var j = 0; j < numNodes; j++ ){
          var node1 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];

          for( var k = j + 1; k < numNodes; k++ ){
            var node2 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ k ] ] ];

            nodeRepulsion( node1, node2, layoutInfo, options );
          }
        }
      }
    };

    var randomDistance = function( max ){
      return -max + 2 * max * Math.random();
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function( node1, node2, layoutInfo, options ){
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if( 0 === directionX && 0 === directionY ){
        directionX = randomDistance( maxRandDist );
        directionY = randomDistance( maxRandDist );
      }

      var overlap = nodesOverlap( node1, node2, directionX, directionY );

      if( overlap > 0 ){
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force    = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt( directionX * directionX + directionY * directionY );
        // s += "\nDistance: " + distance;
        var forceX   = force * directionX / distance;
        var forceY   = force * directionY / distance;

      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint( node1, directionX, directionY );
        var point2 = findClippingPoint( node2, -1 * directionX, -1 * directionY );

        // Use clipping points to compute distance
        var distanceX   = point2.x - point1.x;
        var distanceY   = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance    = Math.sqrt( distanceSqr );
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if( !node1.isLocked ){
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if( !node2.isLocked ){
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function( node1, node2, dX, dY ){

      if( dX > 0 ){
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if( dY > 0 ){
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if( overlapX >= 0 && overlapY >= 0 ){
        return Math.sqrt( overlapX * overlapX + overlapY * overlapY );
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function( node, dX, dY ){

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope     = dY / dX;
      var nodeSlope    = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};
      do {
        // Case: Vertical direction (up)
        if( 0 === dX && 0 < dY ){
          res.x = X;
          // s += "\nUp direction";
          res.y = Y + H / 2;
          break;
        }

        // Case: Vertical direction (down)
        if( 0 === dX && 0 > dY ){
          res.x = X;
          res.y = Y + H / 2;
          // s += "\nDown direction";
          break;
        }

        // Case: Intersects the right border
        if( 0 < dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope ){
          res.x = X + W / 2;
          res.y = Y + (W * dY / 2 / dX);
          // s += "\nRightborder";
          break;
        }

        // Case: Intersects the left border
        if( 0 > dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope ){
          res.x = X - W / 2;
          res.y = Y - (W * dY / 2 / dX);
          // s += "\nLeftborder";
          break;
        }

        // Case: Intersects the top border
        if( 0 < dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope ) ){
          res.x = X + (H * dX / 2 / dY);
          res.y = Y + H / 2;
          // s += "\nTop border";
          break;
        }

        // Case: Intersects the bottom border
        if( 0 > dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope ) ){
          res.x = X - (H * dX / 2 / dY);
          res.y = Y - H / 2;
          // s += "\nBottom border";
          break;
        }

      } while( false);

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function( layoutInfo, options ){
      // Iterate over all edges
      for( var i = 0; i < layoutInfo.edgeSize; i++ ){
        // Get edge, source & target nodes
        var edge     = layoutInfo.layoutEdges[ i ];
        var sourceIx = layoutInfo.idToIndex[ edge.sourceId ];
        var source   = layoutInfo.layoutNodes[ sourceIx ];
        var targetIx = layoutInfo.idToIndex[ edge.targetId ];
        var target   = layoutInfo.layoutNodes[ targetIx ];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if( 0 === directionX && 0 === directionY ){
          return;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint( source, directionX, directionY );
        var point2 = findClippingPoint( target, -1 * directionX, -1 * directionY );


        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l  = Math.sqrt( lx * lx + ly * ly );

        var force  = Math.pow( edge.idealLength - l, 2 ) / edge.elasticity;

        if( 0 !== l ){
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if( !source.isLocked ){
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if( !target.isLocked ){
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function( layoutInfo, options ){
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if( 0 === i ){
          var centerX   = layoutInfo.clientHeight / 2;
          var centerY   = layoutInfo.clientWidth  / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp    = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[0] ] ];
          var parent  = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ temp.parentId ] ];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for( var j = 0; j < numNodes; j++ ){
          var node = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];
          // s = "Node: " + node.id;

          if( node.isLocked ){ continue; }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d  = Math.sqrt( dx * dx + dy * dy );
          if( d > distThreshold ){
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {
            // s += ": skypped since it's too close to center";
          }
          // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function( layoutInfo, options ){
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0;   // Points to the start the queue
      var end   = -1;  // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply( queue, layoutInfo.graphSet[0] );
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while( start <= end ){
        // Get the node to visit and remove it from queue
        var nodeId    = queue[ start++ ];
        var nodeIndex = layoutInfo.idToIndex[ nodeId ];
        var node      = layoutInfo.layoutNodes[ nodeIndex ];
        var children  = node.children;

        // We only need to process the node if it's compound
        if( 0 < children.length && !node.isLocked ){
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for( var i = 0; i < children.length; i++ ){
            var childNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ children[ i ] ] ];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[ ++end ] = children[ i ];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }

      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function( layoutInfo, options ){
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length ){
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length || n.isLocked ){
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce( n.offsetX, n.offsetY, layoutInfo.temperature );
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX    = n.positionX - n.width;
        n.maxX    = n.positionX + n.width;
        n.minY    = n.positionY - n.height;
        n.maxY    = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries( n, layoutInfo );
      }

      // Update size, position of compund nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length && !n.isLocked ){
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width     = n.maxX - n.minX;
          n.height    = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function( forceX, forceY, max ){
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt( forceX * forceX + forceY * forceY );

      if( force > max ){
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };

      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function( node, layoutInfo ){
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if( null == parentId ){
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ parentId ] ];
      var flag = false;

      // MaxX
      if( null == p.maxX || node.maxX + p.padRight > p.maxX ){
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if( null == p.minX || node.minX - p.padLeft < p.minX ){
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if( null == p.maxY || node.maxY + p.padBottom > p.maxY ){
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if( null == p.minY || node.minY - p.padTop < p.minY ){
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if( flag ){
        // logDebug(s);
        return updateAncestryBoundaries( p, layoutInfo );
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function( layutInfo, options ){
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var cid = node.cmptId;
        var component = components[ cid ] = components[ cid ] || [];

        component.push( node );
      }

      var totalA = 0;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          c.x1 = Math.min( c.x1, n.positionX - n.width / 2 );
          c.x2 = Math.max( c.x2, n.positionX + n.width / 2 );
          c.y1 = Math.min( c.y1, n.positionY - n.height / 2 );
          c.y2 = Math.max( c.y2, n.positionY + n.height / 2 );
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort( function( c1, c2 ){
        return c2.w * c2.h - c1.w * c1.h;
      } );

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          if( !n.isLocked ){
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max( rowH, c.h );

        if( usedW > maxRowW ){
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function( i ){
      if( stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step( layoutInfo, options, i );

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if( layoutInfo.temperature < options.minTemp ){
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while( f < options.refresh && i < options.numIter ){
        var loopRet = mainLoop( i );
        if( !loopRet ){ break; }

        f++;
        i++;
      }

      if( options.animate ){
        broadcast( layoutInfo.layoutNodes ); // eslint-disable-line no-undef
      }

    } while( loopRet && i + 1 < options.numIter );

    separateComponents( layoutInfo, options );

    return layoutInfo;
  } ).then( function( layoutInfoUpdated ){
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  } );

  var done = function(){
    refresh({
      force: true,
      next: function(){
        // Layout has finished
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }
    });
  };

  return this; // chaining
};


/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function(){
  this.stopped = true;

  if( this.thread ){
    this.thread.stop();
  }

  this.trigger( 'layoutstop' );

  return this; // chaining
};

CoseLayout.prototype.destroy = function(){
  if( this.thread ){
    this.thread.stop();
  }

  return this; // chaining
};


/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function( cy, layout, options ){
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo   = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
                   } )
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for( var i = 0; i < components.length; i++ ){
    var component = components[ i ];

    for( var j = 0; j < component.length; j++ ){
      var node = component[ j ];

      id2cmptId[ node.id() ] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();

    var tempNode        = {};
    tempNode.isLocked   = n.locked();
    tempNode.id         = n.data( 'id' );
    tempNode.parentId   = n.data( 'parent' );
    tempNode.cmptId     = id2cmptId[ n.id() ];
    tempNode.children   = [];
    tempNode.positionX  = n.position( 'x' );
    tempNode.positionY  = n.position( 'y' );
    tempNode.offsetX    = 0;
    tempNode.offsetY    = 0;
    tempNode.height     = nbb.w;
    tempNode.width      = nbb.h;
    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft    = parseFloat( n.style( 'padding' ) );
    tempNode.padRight   = parseFloat( n.style( 'padding' ) );
    tempNode.padTop     = parseFloat( n.style( 'padding' ) );
    tempNode.padBottom  = parseFloat( n.style( 'padding' ) );

    // forces
    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push( tempNode );
    // Add entry to id-index map
    layoutInfo.idToIndex[ tempNode.id ] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0;   // Points to the start the queue
  var end   = -1;  // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if( null != p_id ){
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[ layoutInfo.idToIndex[ p_id ] ].children.push( n.id );
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[ ++end ] = n.id;
      tempGraph.push( n.id );
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push( tempGraph );

  // Traverse the graph, level by level,
  while( start <= end ){
    // Get the node to visit and remove it from queue
    var node_id  = queue[ start++ ];
    var node_ix  = layoutInfo.idToIndex[ node_id ];
    var node     = layoutInfo.layoutNodes[ node_ix ];
    var children = node.children;
    if( children.length > 0 ){
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push( children );
      // Add children to que queue to be visited
      for( var i = 0; i < children.length; i++ ){
        queue[ ++end ] = children[ i ];
      }
    }
  }

  // Create indexToGraph map
  for( var i = 0; i < layoutInfo.graphSet.length; i++ ){
    var graph = layoutInfo.graphSet[ i ];
    for( var j = 0; j < graph.length; j++ ){
      var index = layoutInfo.idToIndex[ graph[ j ] ];
      layoutInfo.indexToGraph[ index ] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for( var i = 0; i < layoutInfo.edgeSize; i++ ){
    var e = edges[ i ];
    var tempEdge = {};
    tempEdge.id       = e.data( 'id' );
    tempEdge.sourceId = e.data( 'source' );
    tempEdge.targetId = e.data( 'target' );

    // Compute ideal length
    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;
    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx    = layoutInfo.idToIndex[ tempEdge.sourceId ];
    var targetIx    = layoutInfo.idToIndex[ tempEdge.targetId ];
    var sourceGraph = layoutInfo.indexToGraph[ sourceIx ];
    var targetGraph = layoutInfo.indexToGraph[ targetIx ];

    if( sourceGraph != targetGraph ){
      // Find lowest common graph ancestor
      var lca = findLCA( tempEdge.sourceId, tempEdge.targetId, layoutInfo );

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[ lca ];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[ sourceIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[ targetIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push( tempEdge );
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};


/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function( node1, node2, layoutInfo ){
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux( node1, node2, 0, layoutInfo );
  if( 2 > res.count ){
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};


/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function( node1, node2, graphIx, layoutInfo ){
  var graph = layoutInfo.graphSet[ graphIx ];
  // If both nodes belongs to graphIx
  if( -1 < graph.indexOf( node1 ) && -1 < graph.indexOf( node2 ) ){
    return {count: 2, graph: graphIx};
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for( var i = 0; i < graph.length; i++ ){
    var nodeId   = graph[ i ];
    var nodeIx   = layoutInfo.idToIndex[ nodeId ];
    var children = layoutInfo.layoutNodes[ nodeIx ].children;

    // If the node has no child, skip it
    if( 0 === children.length ){
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[ layoutInfo.idToIndex[ children[0] ] ];
    var result = findLCA_aux( node1, node2, childGraphIx, layoutInfo );
    if( 0 === result.count ){
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if( 1 === result.count ){
      // One of (node1, node2) is present in this subgraph
      c++;
      if( 2 === c ){
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {count: c, graph: graphIx};
};


/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function( layoutInfo ){
  /* eslint-disable */

  if( !DEBUG ){
    return;
  }
  console.debug( 'layoutNodes:' );
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var s =
    '\nindex: '     + i +
    '\nId: '        + n.id +
    '\nChildren: '  + n.children.toString() +
    '\nparentId: '  + n.parentId  +
    '\npositionX: ' + n.positionX +
    '\npositionY: ' + n.positionY +
    '\nOffsetX: ' + n.offsetX +
    '\nOffsetY: ' + n.offsetY +
    '\npadLeft: ' + n.padLeft +
    '\npadRight: ' + n.padRight +
    '\npadTop: ' + n.padTop +
    '\npadBottom: ' + n.padBottom;

    console.debug( s );
  }

  console.debug( 'idToIndex' );
  for( var i in layoutInfo.idToIndex ){
    console.debug( 'Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[ i ] );
  }

  console.debug( 'Graph Set' );
  var set = layoutInfo.graphSet;
  for( var i = 0; i < set.length; i ++ ){
    console.debug( 'Set : ' + i + ': ' + set[ i ].toString() );
  }

  var s = 'IndexToGraph';
  for( var i = 0; i < layoutInfo.indexToGraph.length; i ++ ){
    s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[ i ];
  }
  console.debug( s );

  s = 'Layout Edges';
  for( var i = 0; i < layoutInfo.layoutEdges.length; i++ ){
    var e = layoutInfo.layoutEdges[ i ];
    s += '\nEdge Index: ' + i + ' ID: ' + e.id +
    ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId +
    ' Ideal Length: ' + e.idealLength;
  }
  console.debug( s );

  s =  'nodeSize: ' + layoutInfo.nodeSize;
  s += '\nedgeSize: ' + layoutInfo.edgeSize;
  s += '\ntemperature: ' + layoutInfo.temperature;
  console.debug( s );

  return;
  /* eslint-enable */
};


/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function( layoutInfo, cy ){
  var width     = layoutInfo.clientWidth;
  var height    = layoutInfo.clientHeight;

  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];

    // No need to randomize compound nodes or locked nodes
    if( 0 === n.children.length && !n.isLocked ){
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};


/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function( layoutInfo, cy, options ){
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if( options.boundingBox ){
    nodes.forEach( function( node ){
      var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ node.data( 'id' ) ] ];

      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
    } );

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions( function( i, ele ){
    var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ ele.data( 'id' ) ] ];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if( options.boundingBox ){ // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  } );

  // Trigger layoutReady only on first call
  if( true !== layoutInfo.ready ){
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one( 'layoutready', options.ready );
    layout.trigger( { type: 'layoutready', layout: this } );
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

},{"../../is":86,"../../math":88,"../../thread":101,"../../util":103}],55:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function( node ){}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function GridLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

GridLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  if( bb.h === 0 || bb.w === 0 ){
    nodes.layoutPositions( this, options, function(){
      return { x: bb.x1, y: bb.y1 };
    } );

  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt( cells * bb.h / bb.w );
    var rows = Math.round( splits );
    var cols = Math.round( bb.w / bb.h * splits );

    var small = function( val ){
      if( val == null ){
        return Math.min( rows, cols );
      } else {
        var min = Math.min( rows, cols );
        if( min == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function( val ){
      if( val == null ){
        return Math.max( rows, cols );
      } else {
        var max = Math.max( rows, cols );
        if( max == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if( oRows != null && oCols != null ){
      rows = oRows;
      cols = oCols;
    } else if( oRows != null && oCols == null ){
      rows = oRows;
      cols = Math.ceil( cells / rows );
    } else if( oRows == null && oCols != null ){
      cols = oCols;
      rows = Math.ceil( cells / cols );
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if( cols * rows > cells ){
      var sm = small();
      var lg = large();

      // reducing the small side takes away the most cells, so try it first
      if( (sm - 1) * lg >= cells ){
        small( sm - 1 );
      } else if( (lg - 1) * sm >= cells ){
        large( lg - 1 );
      }
    } else {

      // if rounding was too low, add rows or columns
      while( cols * rows < cells ){
        var sm = small();
        var lg = large();

        // try to add to larger side first (adds less in multiplication)
        if( (lg + 1) * sm >= cells ){
          large( lg + 1 );
        } else {
          small( sm + 1 );
        }
      }
    }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if( options.condense ){
      cellWidth = 0;
      cellHeight = 0;
    }

    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var pos = node._private.position;

        if( pos.x == null || pos.y == null ){ // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.boundingBox();
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max( cellWidth, w );
        cellHeight = Math.max( cellHeight, h );
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function( row, col ){
      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;
    };

    var use = function( row, col ){
      cellUsed[ 'c-' + row + '-' + col ] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function(){
      col++;
      if( col >= cols ){
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];
      var rcPos = options.position( node );

      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
        var pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if( pos.col === undefined ){ // find unused col
          pos.col = 0;

          while( used( pos.row, pos.col ) ){
            pos.col++;
          }
        } else if( pos.row === undefined ){ // find unused row
          pos.row = 0;

          while( used( pos.row, pos.col ) ){
            pos.row++;
          }
        }

        id2manPos[ node.id() ] = pos;
        use( pos.row, pos.col );
      }
    }

    var getPos = function( i, element ){
      var x, y;

      if( element.locked() || element.isParent() ){
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[ element.id() ];
      if( rcPos ){
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;

      } else { // otherwise set automatically

        while( used( row, col ) ){
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use( row, col );

        moveToNextCell();
      }

      return { x: x, y: y };

    };

    nodes.layoutPositions( this, options, getPos );
  }

  return this; // chaining

};

module.exports = GridLayout;

},{"../../math":88,"../../util":103}],56:[function(require,module,exports){
'use strict';

module.exports = [
  { name: 'breadthfirst', impl: require( './breadthfirst' ) },
  { name: 'circle', impl: require( './circle' ) },
  { name: 'concentric',impl: require( './concentric' ) },
  { name: 'cose', impl: require( './cose' ) },
  { name: 'grid', impl: require( './grid' ) },
  { name: 'null', impl: require( './null' ) },
  { name: 'preset', impl: require( './preset' ) },
  { name: 'random', impl: require( './random' ) }
];

},{"./breadthfirst":51,"./circle":52,"./concentric":53,"./cose":54,"./grid":55,"./null":57,"./preset":58,"./random":59}],57:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

// default layout options
var defaults = {
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

// runs the layout
NullLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.trigger( 'layoutstart' );

  // puts all nodes at (0, 0)
  eles.nodes().positions( function(){
    return {
      x: 0,
      y: 0
    };
  } );

  // trigger layoutready when each node has had its position set at least once
  layout.one( 'layoutready', options.ready );
  layout.trigger( 'layoutready' );

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one( 'layoutstop', options.stop );
  layout.trigger( 'layoutstop' );

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function(){
  return this; // chaining
};

module.exports = NullLayout;

},{"../../util":103}],58:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var is = require( '../../is' );

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function PresetLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

PresetLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn( options.positions );

  function getPosition( node ){
    if( options.positions == null ){
      return null;
    }

    if( posIsFn ){
      return options.positions.apply( node, [ node ] );
    }

    var pos = options.positions[ node._private.data.id ];

    if( pos == null ){
      return null;
    }

    return pos;
  }

  nodes.layoutPositions( this, options, function( i, node ){
    var position = getPosition( node );

    if( node.locked() || position == null ){
      return false;
    }

    return position;
  } );

  return this; // chaining
};

module.exports = PresetLayout;

},{"../../is":86,"../../util":103}],59:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function RandomLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

RandomLayout.prototype.run = function(){
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var getPos = function( i, node ){
    return {
      x: bb.x1 + Math.round( Math.random() * bb.w ),
      y: bb.y1 + Math.round( Math.random() * bb.h )
    };
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = RandomLayout;

},{"../../math":88,"../../util":103}],60:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var is = require( '../../../is' );
var util = require( '../../../util' );

var BRp = {};

BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function(){
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function( x, y, size, angle, translation, padding ){
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;

    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);

    return inside;
  };

  var transform = function( x, y, size, angle, translation ){
    var xRotated = x * Math.cos( angle ) - y * Math.sin( angle );
    var yRotated = x * Math.sin( angle ) + y * Math.cos( angle );

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function( pts, size, angle, translation ){
    var retPts = [];

    for( var i = 0; i < pts.length; i += 2 ){
      var x = pts[ i ];
      var y = pts[ i + 1];

      retPts.push( transform( x, y, size, angle, translation ) );
    }

    return retPts;
  };

  var pointsToArr = function( pts ){
    var ret = [];

    for( var i = 0; i < pts.length; i++ ){
      var p = pts[ i ];

      ret.push( p.x, p.y );
    }

    return ret;
  };

  var standardGap = function( edge ) {
    return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).pfValue * 2;
  };

  var defineArrowShape = function( name, defn ){
    if( is.string( defn ) ){
      defn = arrowShapes[ defn ];
    }

    arrowShapes[ name ] = util.extend( {
      name: name,

      points: [
        -0.15, -0.3,
        0.15, -0.3,
        0.15, 0.3,
        -0.15, 0.3
      ],

      collide: function( x, y, size, angle, translation, padding ){
        var points = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
        var inside = math.pointInsidePolygonPoints( x, y, points );

        return inside;
      },

      roughCollide: bbCollide,

      draw: function( context, size, angle, translation ){
        var points = transformPoints( this.points, size, angle, translation );

        renderer.arrowShapeImpl( 'polygon' )( context, points );
      },

      spacing: function( edge ){
        return 0;
      },

      gap: standardGap
    }, defn );
  };

  defineArrowShape( 'none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  } );

  defineArrowShape( 'triangle', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ]
  } );

  defineArrowShape( 'arrow', 'triangle' );

  defineArrowShape( 'triangle-backcurve', {
    points: arrowShapes[ 'triangle' ].points,

    controlPoint: [ 0, -0.15 ],

    roughCollide: bbCollide,

    draw: function( context, size, angle, translation ){
      var ptsTrans = transformPoints( this.points, size, angle, translation );
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
    },

    gap: function( edge ) {
      return standardGap(edge) * 0.985;
    }
  } );


  defineArrowShape( 'triangle-tee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      var triPts = transformPoints( this.points, size, angle, translation );
      var teePts = transformPoints( this.pointsTee, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
    }
  } );

  defineArrowShape( 'triangle-cross', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    crossLinePoints: [
      -0.24175, -0.4,
      0.24175, -0.4,
    ],

    forceStroke: true,

    matchEdgeWidth: true,

    scaleCoord: function ( constant, size, edgeWidth ){
     return constant + ( edgeWidth * 0.012 ) + ( math.log2( size - 28.95 ) * 0.001 );
    },

   scaleCrossLineXCoord: function( size, edgeWidth ){
      return this.scaleCoord( 0.42, size, edgeWidth );
    },

    scaleCrossLineYCoord: function( size, edgeWidth ){
      return this.scaleCoord( -0.01, size, edgeWidth );
    },

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var crossLinePts = pointsToArr( transformPoints( this.crossLinePoints, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts )
      || math.inLineVicinity( x, y,
        crossLinePts[0], crossLinePts[1], crossLinePts[2], crossLinePts[3], padding );

      return inside;
    },

    draw: function( context, size, angle, translation, edgeWidth ){
      var scaledCrossLine = [
        this.crossLinePoints[0] + this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[1] - this.scaleCrossLineYCoord( size, edgeWidth ),
        this.crossLinePoints[2] - this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[3] - this.scaleCrossLineYCoord( size, edgeWidth )
      ];
      var triPts = transformPoints( this.points, size, angle, translation );
      var crossLinePts = transformPoints( scaledCrossLine, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, crossLinePts );
    }
  } );

  defineArrowShape( 'vee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      0, -0.15
    ],

    gap: function( edge ){
      return standardGap(edge) * 0.985;
    }
  } );

  defineArrowShape( 'circle', {
    radius: 0.15,

    collide: function( x, y, size, angle, translation, padding ){
      var t = translation;
      var inside = ( Math.pow( t.x - x, 2 ) + Math.pow( t.y - y, 2 ) <= Math.pow( (size + 2 * padding) * this.radius, 2 ) );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
    },

    spacing: function( edge ){
      return renderer.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.radius;
    }
  } );

  defineArrowShape( 'inhibitor', {
    points: [
      -0.15, 0,
      -0.15, -0.1,
      0.15, -0.1,
      0.15, 0
    ],

    spacing: function( edge ){
      return 1;
    },

    gap: function( edge ){
      return 1;
    }
  } );

  defineArrowShape( 'tee', 'inhibitor' );

  defineArrowShape( 'square', {
    points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ]
  } );

  defineArrowShape( 'diamond', {
    points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    gap: function( edge ){
      return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).value;
    }
  } );

};

module.exports = BRp;

},{"../../../is":86,"../../../math":88,"../../../util":103}],61:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var is = require( '../../../is' );
var util = require( '../../../util' );
var zIndexSort = require( '../../../collection/zsort' );
var window = require( '../../../window' );

var BRp = {};

BRp.registerCalculationListeners = function(){
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function( eles, e ){
    elesToUpdate.merge( eles );

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var rstyle = _p.rstyle;

      rstyle.clean = false;
      _p.bbCache = null;

      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

      if( !evts[ e.type ] ){
        evts[ e.type ] = true;
        evts.length++;
//
        // elesToUpdate.merge( ele );
      }
    }
  };

  r.binder( cy )
    // nodes

    .on('position.* style.* free.*', 'node', function onDirtyModNode( e ){
      var node = e.cyTarget;

      enqueue( node, e );
      enqueue( node.connectedEdges(), e );

      if( cy.hasCompoundNodes() ){
        var parents = node.parents();

        enqueue( parents, e );
        enqueue( parents.connectedEdges(), e );
      }
    })

    .on('add.* background.*', 'node', function onDirtyAddNode( e ){
      var ele = e.cyTarget;

      enqueue( ele, e );
    })

    // edges

    .on('add.* style.*', 'edge', function onDirtyEdge( e ){
      var edge = e.cyTarget;

      enqueue( edge, e );
      enqueue( edge.parallelEdges(), e );
    })

    .on('remove.*', 'edge', function onDirtyRemoveEdge( e ){
      var edge = e.cyTarget;
      var pEdges = edge.parallelEdges();

      for( var i = 0; i < pEdges.length; i++ ){
        var pEdge = pEdges[i];

        if( !pEdge.removed() ){
          enqueue( pEdge, e );
        }
      }
    })
  ;

  var updateEleCalcs = function( willDraw ){
    if( willDraw ){
      var fns = r.onUpdateEleCalcsFns;

      if( fns ){ for( var i = 0; i < fns.length; i++ ){
        var fn = fns[i];

        fn( willDraw, elesToUpdate );
      } }

      r.recalculateRenderedStyle( elesToUpdate, false );

      for( var i = 0; i < elesToUpdate.length; i++ ){
        elesToUpdate[i]._private.rstyle.dirtyEvents = null;
      }

      elesToUpdate = cy.collection();
    }
  };

  r.beforeRender( updateEleCalcs, r.beforeRenderPriorities.eleCalcs );
};

BRp.onUpdateEleCalcs = function( fn ){
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

  fns.push( fn );
};

BRp.recalculateRenderedStyle = function( eles, useCache ){
  var edges = [];
  var nodes = [];

  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  if( this.destroyed ){ return; }

  // use cache by default for perf
  if( useCache === undefined ){ useCache = true; }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;

    // only update if dirty and in graph
    if( (useCache && rstyle.clean) || ele.removed() ){ continue; }

    // only update if not display: none
    if( ele.pstyle('display').value === 'none' ){ continue; }

    if( _p.group === 'nodes' ){
      nodes.push( ele );
    } else { // edges
      edges.push( ele );
    }

    rstyle.clean = true;
    // rstyle.dirtyEvents = null;
  }

  // update node data from projections
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = _p.position;

    this.recalculateNodeLabelProjection( ele );

    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle( 'width' ).pfValue;
    rstyle.nodeH = ele.pstyle( 'height' ).pfValue;
  }

  this.recalculateEdgeProjections( edges );

  // update edge data from projections
  for( var i = 0; i < edges.length; i++ ){
    var ele = edges[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch;

    this.recalculateEdgeLabelProjections( ele );

    // update rstyle positions
    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

// Project mouse
BRp.projectIntoViewport = function( clientX, clientY ){
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var pan = cy.pan();
  var zoom = cy.zoom();

  var x = ( clientX - offsetLeft - pan.x ) / zoom;
  var y = ( clientY - offsetTop - pan.y ) / zoom;

  return [ x, y ];
};

BRp.findContainerClientCoords = function(){
  if( this.containerBB ){
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window.getComputedStyle( container );
  var styleValue = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };
  var extra = {
    left: styleValue('padding-left') + styleValue('border-left-width'),
    right: styleValue('padding-right') + styleValue('border-right-width'),
    top: styleValue('padding-top') + styleValue('border-top-width'),
    bottom: styleValue('padding-bottom') + styleValue('border-bottom-width')
  };

  return ( this.containerBB = [ // x, y, w, h
    rect.left + extra.left,
    rect.top + extra.top,
    rect.right - rect.left - extra.left - extra.right,
    rect.bottom - rect.top - extra.top - extra.bottom
  ] );
};

BRp.invalidateContainerClientCoordsCache = function(){
  this.containerBB = null;
};

BRp.findNearestElement = function( x, y, isTouch ){
  return this.findNearestElements( x, y, isTouch )[0];
};

BRp.findNearestElements = function( x, y, isTouch ){
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  function addEle( ele, sqDist ){
    if( ele.isNode() ){
      if( nearNode ){
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push( ele );
      }
    }

    if( ele.isEdge() && ( sqDist == null || sqDist < minSqDist ) ){
      if( nearEdge ){ // then replace existing edge
        // can replace only if same z-index
        if( nearEdge.pstyle( 'z-index' ).value === ele.pstyle('z-index').value ){
          for( var i = 0; i < near.length; i++ ){
            if( near[i].isEdge() ){
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push( ele );
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode( node ){
    var _p = node._private;

    if( node.pstyle( 'events' ).strValue === 'no' ){ return; }

    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = _p.position;

    if(
      pos.x - hw <= x && x <= pos.x + hw // bb check x
        &&
      pos.y - hh <= y && y <= pos.y + hh // bb check y
    ){
      var shape = r.nodeShapes[ self.getNodeShape( node ) ];

      if(
        shape.checkPoint( x, y, 0, width, height, pos.x, pos.y )
      ){
        addEle( node, 0 );
        return true;
      }

    }
  }

  function checkEdge( edge ){
    var _p = edge._private;

    if( edge.pstyle('events').strValue === 'no' ){ return; }

    var rs = _p.rscratch;
    var styleWidth = edge.pstyle( 'width' ).pfValue;
    var scale = edge.pstyle( 'arrow-scale' ).value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
      var pts = rs.allpts;

      for( var i = 0; i + 3 < pts.length; i += 2 ){
        if(
          (inEdgeBB = math.inLineVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], width2 ))
            &&
          widthSq > ( sqDist = math.sqdistToFiniteLine( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] ) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }

    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
      var pts = rs.allpts;
      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
        if(
          (inEdgeBB = math.inBezierVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5], width2 ))
            &&
          (widthSq > (sqDist = math.sqdistToQuadraticBezier( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5] )) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows

    var src = src || _p.source;
    var tgt = tgt || _p.target;

    var arSize = self.getArrowWidth( styleWidth, scale );

    var arrows = [
      { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
      { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
      { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
      { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
    ];

    for( var i = 0; i < arrows.length; i++ ){
      var ar = arrows[ i ];
      var shape = r.arrowShapes[ edge.pstyle( ar.name + '-arrow-shape' ).value ];

      if(
        shape.roughCollide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
         &&
        shape.collide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
      ){
        addEle( edge );
        return true;
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if( hasCompounds && near.length > 0 ){
      checkNode( src );
      checkNode( tgt );
    }
  }

  function preprop( obj, name, pre ){
    return util.getPrefixedProperty( obj, name, pre );
  }

  function checkLabel( ele, prefix ){
    var _p = ele._private;
    var th = labelThreshold;

    var prefixDash;
    if( prefix ){
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    var text = ele.pstyle( prefixDash + 'label' ).value;
    var eventsEnabled = ele.pstyle( 'text-events' ).strValue === 'yes';

    if( !eventsEnabled || !text ){ return; }

    var rstyle = _p.rstyle;
    var bw = ele.pstyle('text-border-width').pfValue;
    var pw = ele.pstyle('text-background-padding').pfValue;
    var lw = preprop( rstyle, 'labelWidth', prefix ) + bw + 2*th + 2*pw;
    var lh = preprop( rstyle, 'labelHeight', prefix ) + bw + 2*th + 2*pw;
    var lx = preprop( rstyle, 'labelX', prefix );
    var ly = preprop( rstyle, 'labelY', prefix );

    var theta = preprop( _p.rscratch, 'labelAngle', prefix );

    var lx1 = lx - lw / 2;
    var lx2 = lx + lw / 2;
    var ly1 = ly - lh / 2;
    var ly2 = ly + lh / 2;

    if( theta ){
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - lx;
        y = y - ly;

        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      var points = [
        px1y1.x, px1y1.y,
        px2y1.x, px2y1.y,
        px2y2.x, px2y2.y,
        px1y2.x, px1y2.y
      ];

      if( math.pointInsidePolygonPoints( x, y, points ) ){
        addEle( ele );
        return true;
      }
    } else { // do a cheaper bb check
      var bb = {
        w: lw,
        h: lh,
        x1: lx1,
        x2: lx2,
        y1: ly1,
        y2: ly2
      };

      if( math.inBoundingBox( bb, x, y ) ){
        addEle( ele );
        return true;
      }
    }

  }

  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
    var ele = eles[ i ];

    if( ele.isNode() ){
      checkNode( ele ) || checkLabel( ele );

    } else { // then edge
      checkEdge( ele ) || checkLabel( ele ) || checkLabel( ele, 'source' ) || checkLabel( ele, 'target' );
    }
  }

  return near;
};

// 'Give me everything from this box'
BRp.getAllInBox = function( x1, y1, x2, y2 ){
  var eles = this.getCachedZSortedEles();
  var nodes = eles.nodes;
  var edges = eles.edges;
  var box = [];

  var x1c = Math.min( x1, x2 );
  var x2c = Math.max( x1, x2 );
  var y1c = Math.min( y1, y2 );
  var y2c = Math.max( y1, y2 );

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox( {
    x1: x1, y1: y1,
    x2: x2, y2: y2
  } );

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var nodeBb = node.boundingBox( {
      includeNodes: true,
      includeEdges: false,
      includeLabels: false,
      includeShadows: false
    } );

    if( math.boundingBoxesIntersect( boxBb, nodeBb ) ){
      box.push( nodes[ i ] );
    }
  }

  for( var e = 0; e < edges.length; e++ ){
    var edge = edges[ e ];
    var _p = edge._private;
    var rs = _p.rscratch;

    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }

    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){

      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
      var allInside = true;

      for( var i = 0; i < pts.length; i++ ){
        if( !math.pointInBoundingBox( boxBb, pts[ i ] ) ){
          allInside = false;
          break;
        }
      }

      if( allInside ){
        box.push( edge );
      }

    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
      box.push( edge );
    }

  }

  return box;
};


/**
 * Returns the shape of the given node. If the height or width of the given node
 * is set to auto, the node is considered to be a compound.
 *
 * @param node          a node
 * @return {String}     shape of the node
 */
BRp.getNodeShape = function( node ){
  var r = this;
  var shape = node.pstyle( 'shape' ).value;

  if( node.isParent() ){
    if( shape === 'rectangle' || shape === 'roundrectangle' ){
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if( shape === 'polygon' ){
    var points = node.pstyle( 'shape-polygon-points' ).value;

    return r.nodeShapes.makePolygon( points ).name;
  }

  return shape;
};

BRp.updateCachedGrabbedEles = function(){
  var eles = this.cachedZSortedEles;

  if( !eles ){
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];

  var grabTargets = [];

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.grabbed() && !ele.isParent() ){
      grabTargets.push( ele );
    } else if( rs.inDragLayer ){
      eles.drag.push( ele );
    } else {
      eles.nondrag.push( ele );
    }
  }

  // put the grab target nodes last so it's on top of its neighbourhood
  for( var i = 0; i < grabTargets.length; i++ ){
    var ele = grabTargets[i];

    eles.drag.push( ele );
  }
};

BRp.invalidateCachedZSortedEles = function(){
  this.cachedZSortedEles = null;
};

BRp.getCachedZSortedEles = function( forceRecalc ){
  if( forceRecalc || !this.cachedZSortedEles ){
    var cyEles = this.cy.mutableElements();
    var eles = [];

    eles.nodes = [];
    eles.edges = [];

    for( var i = 0; i < cyEles.length; i++ ){
      var ele = cyEles[i];

      if( ele.animated() || (ele.visible() && !ele.transparent()) ){
        eles.push( ele );

        if( ele.isNode() ){
          eles.nodes.push( ele );
        } else {
          eles.edges.push( ele );
        }
      }
    }

    eles.sort( zIndexSort );

    this.cachedZSortedEles = eles;

    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

function pushBezierPts( r, edge, pts ){
  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt( p1, p2, p3, t ); };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for( var i = 0; i < r.bezierProjPcts.length; i++ ){
    var p = r.bezierProjPcts[i];

    bpts.push( {
      x: qbezierAt( pts[0], pts[2], pts[4], p ),
      y: qbezierAt( pts[1], pts[3], pts[5], p )
    } );
  }
}

BRp.projectLines = function( edge ){
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  // clear the cached points state
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      pushBezierPts( this, edge, rs.allpts.slice( i, i + 6 ) );
    }
  } else if(  et === 'segments' ){
    var lpts = _p.rstyle.linePts = [];

    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
      lpts.push( {
        x: rs.allpts[ i ],
        y: rs.allpts[ i + 1]
      } );
    }
  } else if( et === 'haystack' ){
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [
      { x: hpts[0], y: hpts[1] },
      { x: hpts[2], y: hpts[3] }
    ];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth( edge.pstyle('width').pfValue, edge.pstyle( 'arrow-scale' ).value )
    * this.arrowShapeWidth;
};

BRp.projectBezier = BRp.projectLines;

BRp.recalculateNodeLabelProjection = function( node ){
  var content = node.pstyle( 'label' ).strValue;

  if( is.emptyString(content) ){ return; }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.pstyle('padding').pfValue;
  var nodePos = _p.position;
  var textHalign = node.pstyle( 'text-halign' ).strValue;
  var textValign = node.pstyle( 'text-valign' ).strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch( textHalign ){
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default: // e.g. center
      textX = nodePos.x;
  }

  switch( textValign ){
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default: // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( node );
};

BRp.recalculateEdgeLabelProjections = function( edge ){
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if( content.mid || content.source || content.target ){
    // then we have to calculate...
  } else {
    return; // no labels => no calcs
  }

  // add center point to style so bounding box calculations can use it
  //
  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function( propName, prefix, value ){
    util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
    util.setPrefixedProperty( _p.rstyle, propName, prefix, value );
  };

  setRs( 'labelX', null, p.x );
  setRs( 'labelY', null, p.y );

  var createControlPointInfo = function(){
    if( createControlPointInfo.cache ){ return createControlPointInfo.cache; } // use cache so only 1x per edge

    var ctrlpts = [];

    // store each ctrlpt info init
    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      var p0 = { x: rs.allpts[i], y: rs.allpts[i+1] };
      var p1 = { x: rs.allpts[i+2], y: rs.allpts[i+3] }; // ctrlpt
      var p2 = { x: rs.allpts[i+4], y: rs.allpts[i+5] };

      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment( cp, p0, p1, t0, t1 ){
      var length = math.dist( p0, p1 );
      var prevSegment = cp.segments[ cp.segments.length - 1 ];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };

      cp.segments.push( segment );

      cp.length += length;
    }

    // update each ctrlpt with segment info
    for( var i = 0; i < ctrlpts.length; i++ ){
      var cp = ctrlpts[i];
      var prevCp = ctrlpts[i - 1];

      if( prevCp ){
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(
        cp,
        cp.p0,   bpts[ i * nProjs ],
        0,       r.bezierProjPcts[ 0 ]
      ); // first

      for( var j = 0; j < nProjs - 1; j++ ){
        addSegment(
          cp,
          bpts[ i * nProjs + j ],   bpts[ i * nProjs + j + 1 ],
          r.bezierProjPcts[ j ],    r.bezierProjPcts[ j + 1 ]
        );
      }

      addSegment(
        cp,
        bpts[ i * nProjs + nProjs - 1 ],   cp.p2,
        r.bezierProjPcts[ nProjs - 1 ],    1
      ); // last
    }

    return ( createControlPointInfo.cache = ctrlpts );
  };

  var calculateEndProjection = function( prefix ){
    var angle;
    var isSrc = prefix === 'source';

    if( !content[ prefix ] ){ return; }

    var offset = edge.pstyle(prefix+'-text-offset').pfValue;

    var lineAngle = function( p0, p1 ){
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;

      return Math.atan( dy / dx );
    };

    var bezierAngle = function( p0, p1, p2, t ){
      var t0 = math.bound( 0, t - 0.001, 1 );
      var t1 = math.bound( 0, t + 0.001, 1 );

      var lp0 = math.qbezierPtAt( p0, p1, p2, t0 );
      var lp1 = math.qbezierPtAt( p0, p1, p2, t1 );

      return lineAngle( lp0, lp1 );
    };

    switch( rs.edgeType ){
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        var cps = createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;

        // find the segment we're on
        for( var i = 0; i < cps.length; i++ ){
          var cp = cps[ isSrc ? i : cps.length - 1 - i ];

          for( var j = 0; j < cp.segments.length; j++ ){
            var seg = cp.segments[ isSrc ? j : cp.segments.length - 1 - j ];
            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

            startDist = totalDist;
            totalDist += seg.length;

            if( totalDist >= offset || lastSeg ){
              selected = { cp: cp, segment: seg };
              break;
            }
          }

          if( selected ){ break; }
        }

        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = ( offset - startDist ) / ( seg.length );
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

        t = math.bound( 0, t, 1 );
        p = math.qbezierPtAt( cp.p0, cp.p1, cp.p2, t );
        angle = bezierAngle( cp.p0, cp.p1, cp.p2, t, p );

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        var d = 0, di, d0;
        var p0, p1;
        var l = rs.allpts.length;

        for( var i = 0; i + 3 < l; i += 2 ){
          if( isSrc ){
            p0 = { x: rs.allpts[i],     y: rs.allpts[i+1] };
            p1 = { x: rs.allpts[i+2],   y: rs.allpts[i+3] };
          } else {
            p0 = { x: rs.allpts[l-2-i], y: rs.allpts[l-1-i] };
            p1 = { x: rs.allpts[l-4-i], y: rs.allpts[l-3-i] };
          }

          di = math.dist( p0, p1 );
          d0 = d;
          d += di;

          if( d >= offset ){ break; }
        }

        var pD = offset - d0;
        var t = pD / di;

        t  = math.bound( 0, t, 1 );
        p = math.lineAt( p0, p1, t );
        angle = lineAngle( p0, p1 );

        break;
    }

    setRs( 'labelX', prefix, p.x );
    setRs( 'labelY', prefix, p.y );
    setRs( 'labelAutoAngle', prefix, angle );
  };

  calculateEndProjection( 'source' );
  calculateEndProjection( 'target' );

  this.applyLabelDimensions( edge );
};

BRp.applyLabelDimensions = function( ele ){
  this.applyPrefixedLabelDimensions( ele );

  if( ele.isEdge() ){
    this.applyPrefixedLabelDimensions( ele, 'source' );
    this.applyPrefixedLabelDimensions( ele, 'target' );
  }
};

BRp.applyPrefixedLabelDimensions = function( ele, prefix ){
  var _p = ele._private;

  var text = this.getLabelText( ele, prefix );
  var labelDims = this.calculateLabelDimensions( ele, text );

  util.setPrefixedProperty( _p.rstyle,   'labelWidth', prefix, labelDims.width );
  util.setPrefixedProperty( _p.rscratch, 'labelWidth', prefix, labelDims.width );

  util.setPrefixedProperty( _p.rstyle,   'labelHeight', prefix, labelDims.height );
  util.setPrefixedProperty( _p.rscratch, 'labelHeight', prefix, labelDims.height );
};

BRp.getLabelText = function( ele, prefix ){
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle( pfd + 'label' ).strValue;
  var textTransform = ele.pstyle( 'text-transform' ).value;
  var rscratch = function( propName, value ){
    if( value ){
      util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
      return value;
    } else {
      return util.getPrefixedProperty( _p.rscratch, propName, prefix );
    }
  };

  if( textTransform == 'none' ){
    // passthrough
  } else if( textTransform == 'uppercase' ){
    text = text.toUpperCase();
  } else if( textTransform == 'lowercase' ){
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle( 'text-wrap' ).value;

  if( wrapStyle === 'wrap' ){
    //console.log('wrap');

    var labelKey = rscratch( 'labelKey' );

    // save recalc if the label is the same as before
    if( labelKey && rscratch( 'labelWrapKey' ) === labelKey ){
      // console.log('wrap cache hit');
      return rscratch( 'labelWrapCachedText' );
    }
    // console.log('wrap cache miss');

    var lines = text.split( '\n' );
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var wrappedLines = [];

    for( var l = 0; l < lines.length; l++ ){
      var line = lines[ l ];
      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
      var lineW = lineDims.width;

      if( lineW > maxW ){ // line is too long
        var words = line.split( /\s+/ ); // NB: assume collapsed whitespace into single space
        var subline = '';

        for( var w = 0; w < words.length; w++ ){
          var word = words[ w ];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
          var testW = testDims.width;

          if( testW <= maxW ){ // word fits on current line
            subline += word + ' ';
          } else { // word starts new line
            wrappedLines.push( subline );
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if( !subline.match( /^\s+$/ ) ){
          wrappedLines.push( subline );
        }
      } else { // line is already short enough
        wrappedLines.push( line );
      }
    } // for

    rscratch( 'labelWrapCachedLines', wrappedLines );
    text = rscratch( 'labelWrapCachedText', wrappedLines.join( '\n' ) );
    rscratch( 'labelWrapKey', labelKey );

    // console.log(text)
  } else if( wrapStyle === 'ellipsis' ){
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var ellipsized = '';
    var ellipsis = '\u2026';
    var incLastCh = false;

    for( var i = 0; i < text.length; i++ ){
      var widthWithNextCh = this.calculateLabelDimensions( ele, ellipsized + text[i] + ellipsis ).width;

      if( widthWithNextCh > maxW ){ break; }

      ellipsized += text[i];

      if( i === text.length - 1 ){ incLastCh = true; }
    }

    if( !incLastCh ){
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize

  return text;
};

BRp.calculateLabelDimensions = function( ele, text, extraKey ){
  var r = this;

  var cacheKey = ele._private.labelStyleKey + '$@$' + text;

  if( extraKey ){
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if( cache[ cacheKey ] ){
    return cache[ cacheKey ];
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ( sizeMult * ele.pstyle( 'font-size' ).pfValue ) + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;

  var div = this.labelCalcDiv;

  if( !div ){
    div = this.labelCalcDiv = document.createElement( 'div' ); // eslint-disable-line no-undef
    document.body.appendChild( div ); // eslint-disable-line no-undef
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[ cacheKey ] = {
    width: Math.ceil( div.clientWidth / sizeMult ),
    height: Math.ceil( div.clientHeight / sizeMult )
  };

  return cache[ cacheKey ];
};

BRp.recalculateEdgeProjections = function( edges ){
  this.findEdgeControlPoints( edges );
};


// Find edge control points
BRp.findEdgeControlPoints = function( edges ){
  if( !edges || edges.length === 0 ){ return; }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for( var i = 0; i < edges.length; i++ ){
    var edge = edges[ i ];
    var _p = edge._private;
    var data = _p.data;
    var curveStyle = edge.pstyle( 'curve-style' ).value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( edge.pstyle( 'display').value === 'none' ){
      continue;
    }

    if( curveStyle === 'haystack' ){
      haystackEdges.push( edge );
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ?
      tgtId + '$-$' + srcId :
      srcId + '$-$' + tgtId ;

    if( edgeIsUnbundled ){
      pairId = 'unbundled' + '$-$' + data.id;
    }

    if( hashTable[ pairId ] == null ){
      hashTable[ pairId ] = [];
      pairIds.push( pairId );
    }

    hashTable[ pairId ].push( edge );

    if( edgeIsUnbundled ){
      hashTable[ pairId ].hasUnbundled = true;
    }
  }

  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for( var p = 0; p < pairIds.length; p++ ){
    pairId = pairIds[ p ];
    var pairEdges = hashTable[ pairId ];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort( function( edge1, edge2 ){
      return edge1.poolIndex() - edge2.poolIndex();
    } );

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    // make sure src/tgt distinction is consistent for bundled edges
    if( !pairEdges.hasUnbundled && src.id() > tgt.id() ){
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    src_p = src._private;
    tgt_p = tgt._private;

    srcPos = src_p.position;
    tgtPos = tgt_p.position;

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[ this.getNodeShape( src ) ];
    tgtShape = r.nodeShapes[ this.getNodeShape( tgt ) ];

    badBezier = false;


    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

      // pt outside src shape to calc distance/displacement from src to tgt
      var srcOutside = srcShape.intersectLine(
        srcPos.x,
        srcPos.y,
        srcW,
        srcH,
        tgtPos.x,
        tgtPos.y,
        0
      );

      // pt outside tgt shape to calc distance/displacement from src to tgt
      var tgtOutside = tgtShape.intersectLine(
        tgtPos.x,
        tgtPos.y,
        tgtW,
        tgtH,
        srcPos.x,
        srcPos.y,
        0
      );

      var midptSrcPts = {
        x1: srcOutside[0],
        x2: tgtOutside[0],
        y1: srcOutside[1],
        y2: tgtOutside[1]
      };

      var posPts = {
        x1: srcPos.x,
        x2: tgtPos.x,
        y1: srcPos.y,
        y2: tgtPos.y
      };

      var dy = ( tgtOutside[1] - srcOutside[1] );
      var dx = ( tgtOutside[0] - srcOutside[0] );
      var l = Math.sqrt( dx * dx + dy * dy );

      var vector = {
        x: dx,
        y: dy
      };

      var vectorNorm = {
        x: vector.x / l,
        y: vector.y / l
      };
      vectorNormInverse = {
        x: -vectorNorm.y,
        y: vectorNorm.x
      };


      // if node shapes overlap, then no ctrl pts to draw
      if(
        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  &&
        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
      ){
        vectorNormInverse = {};
        badBezier = true;
      }

    }

    var edge;
    var edge_p;
    var rs;

    var dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    for( var i = 0; i < pairEdges.length; i++ ){
      edge = pairEdges[ i ];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;
      var numEdges2 = pairEdges.length;

      var curveStyle = edge.pstyle( 'curve-style' ).value;
      var ctrlptDists = edge.pstyle( 'control-point-distances' );

      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;

      var ctrlptWs = edge.pstyle( 'control-point-weights' );
      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
      var stepSize = edge.pstyle( 'control-point-step-size' ).pfValue;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      var srcX1 = rs.lastSrcCtlPtX;
      var srcX2 = srcPos.x;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcY2 = srcPos.y;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcW2 = src.outerWidth();
      var srcH1 = rs.lastSrcCtlPtH;
      var srcH2 = src.outerHeight();

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtX2 = tgtPos.x;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtY2 = tgtPos.y;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtW2 = tgt.outerWidth();
      var tgtH1 = rs.lastTgtCtlPtH;
      var tgtH2 = tgt.outerHeight();

      var width1 = rs.lastW;
      var width2 = edge.pstyle( 'control-point-step-size' ).pfValue;

      var edgeDistances = edge.pstyle('edge-distances').value;

      if( badBezier ){
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
      &&  width1 === width2
      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
        // console.log('edge ctrl pt cache HIT')
        continue; // then the control points haven't changed and we can skip calculating them
      } else {
        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastWidth = width2;
        // console.log('edge ctrl pt cache MISS')
      }

      if( src === tgt ){
        // Self-edge

        rs.edgeType = 'self';

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var outAngle =  loopDir - loopSwp / 2;
        var inAngle  =  loopDir + loopSwp / 2;

        // increase by step size for overlapping loops, keyed on direction and sweep values
        var dc = String(loopDir + '_' + loopSwp);
        j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

        rs.ctrlpts = [
          srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)
        ];

      } else if(
        hasCompounds &&
        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
        ( src.parents().anySame( tgt ) || tgt.parents().anySame( src ) )
      ){
        // Compound edge

        rs.edgeType = 'compound';

        // because the line approximation doesn't apply for compound beziers
        // (loop/self edges are already elided b/c of cheap src==tgt check)
        rs.badBezier = false;

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var loopW = 50;

        var loopaPos = {
          x: srcPos.x - srcW / 2,
          y: srcPos.y - srcH / 2
        };

        var loopbPos = {
          x: tgtPos.x - tgtW / 2,
          y: tgtPos.y - tgtH / 2
        };

        var loopPos = {
          x: Math.min( loopaPos.x, loopbPos.x ),
          y: Math.min( loopaPos.y, loopbPos.y )
        };

        // avoids cases with impossible beziers
        var minCompoundStretch = 0.5;
        var compoundStretchA = Math.max( minCompoundStretch, Math.log( srcW * 0.01 ) );
        var compoundStretchB = Math.max( minCompoundStretch, Math.log( tgtW * 0.01 ) );

        rs.ctrlpts = [
          loopPos.x,
          loopPos.y - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,

          loopPos.x - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
          loopPos.y
        ];

      } else if( curveStyle === 'segments' ){
        // Segments (multiple straight lines)

        rs.edgeType = 'segments';
        rs.segpts = [];

        var segmentWs = edge.pstyle( 'segment-weights' ).pfValue;
        var segmentDs = edge.pstyle( 'segment-distances' ).pfValue;
        var segmentsN = Math.min( segmentWs.length, segmentDs.length );

        for( var s = 0; s < segmentsN; s++ ){
          var w = segmentWs[ s ];
          var d = segmentDs[ s ];

          var w1 = 1 - w;
          var w2 = w;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.segpts.push(
            adjustedMidpt.x + vectorNormInverse.x * d,
            adjustedMidpt.y + vectorNormInverse.y * d
          );
        }

      // Straight edge
      } else if(
        pairEdges.length % 2 === 1
        && i === Math.floor( pairEdges.length / 2 )
        && !edgeIsUnbundled
      ){

        rs.edgeType = 'straight';

      } else {
        // (Multi)bezier

        var multi = edgeIsUnbundled;

        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for( var b = 0; b < bezierN; b++ ){
          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manctrlptDist;
          var sign = math.signum( normctrlptDist );

          if( multi ){
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[ b ] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[ b ];
          }

          if( edgeIsUnbundled ){ // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

          var w1 = 1 - ctrlptWeight;
          var w2 = ctrlptWeight;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.ctrlpts.push(
            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
          );
        }

      }

      // find endpts for edge
      this.findEndpoints( edge );

      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );

      var minCpADistFactor = 3;
      var arrowW = this.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.arrowShapeWidth;
      var minCpADist = minCpADistFactor * arrowW;

      if( rs.edgeType === 'bezier' ){
        var startACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        var overlapping = false;

        if( badStart || badAStart || closeStartACp ){
          overlapping = true;

          // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var srcCtrlPtIntn = srcShape.intersectLine(
            srcPos.x,
            srcPos.y,
            srcW,
            srcH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeStartACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }

        if( badEnd || badAEnd || closeEndACp ){
          overlapping = true;

          // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var tgtCtrlPtIntn = tgtShape.intersectLine(
            tgtPos.x,
            tgtPos.y,
            tgtW,
            tgtH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeEndACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
          }

        }

        if( overlapping ){
          // recalc endpts
          this.findEndpoints( edge );
        }

      }

      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.allpts = [];

        rs.allpts.push( rs.startX, rs.startY );

        for( var b = 0; b + 1 < rs.ctrlpts.length; b += 2 ){
          // ctrl pt itself
          rs.allpts.push( rs.ctrlpts[ b ], rs.ctrlpts[ b + 1] );

          // the midpt between ctrlpts as intermediate destination pts
          if( b + 3 < rs.ctrlpts.length ){
            rs.allpts.push( (rs.ctrlpts[ b ] + rs.ctrlpts[ b + 2]) / 2, (rs.ctrlpts[ b + 1] + rs.ctrlpts[ b + 3]) / 2 );
          }
        }

        rs.allpts.push( rs.endX, rs.endY );

        var m, mt;
        if( rs.ctrlpts.length / 2 % 2 === 0 ){
          m = rs.allpts.length / 2 - 1;

          rs.midX = rs.allpts[ m ];
          rs.midY = rs.allpts[ m + 1];
        } else {
          m = rs.allpts.length / 2 - 3;
          mt = 0.5;

          rs.midX = math.qbezierAt( rs.allpts[ m ], rs.allpts[ m + 2], rs.allpts[ m + 4], mt );
          rs.midY = math.qbezierAt( rs.allpts[ m + 1], rs.allpts[ m + 3], rs.allpts[ m + 5], mt );
        }

      } else if( rs.edgeType === 'straight' ){
        // need to calc these after endpts
        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];

        // default midpt for labels etc
        rs.midX = ( rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX ) / 4;
        rs.midY = ( rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY ) / 4;

      } else if( rs.edgeType === 'segments' ){
        rs.allpts = [];
        rs.allpts.push( rs.startX, rs.startY );
        rs.allpts.push.apply( rs.allpts, rs.segpts );
        rs.allpts.push( rs.endX, rs.endY );

        if( rs.segpts.length % 4 === 0 ){
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;

          rs.midX = ( rs.segpts[ i1 ] + rs.segpts[ i2 ] ) / 2;
          rs.midY = ( rs.segpts[ i1 + 1] + rs.segpts[ i2 + 1] ) / 2;
        } else {
          var i1 = rs.segpts.length / 2 - 1;

          rs.midX = rs.segpts[ i1 ];
          rs.midY = rs.segpts[ i1 + 1];
        }


      }

      this.projectLines( edge );
      this.calculateArrowAngles( edge );
      this.recalculateEdgeLabelProjections( edge );
      this.calculateLabelAngles( edge );

    } // for pair edges
  } // for pair ids

  for( var i = 0; i < haystackEdges.length; i++ ){
    var edge = haystackEdges[ i ];
    var _p = edge._private;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if( !rscratch.haystack ){
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src._private.position;
    var tgtPos = tgt._private.position;
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle( 'haystack-radius' ).value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [
      rs.source.x * srcW * halfRadius + srcPos.x,
      rs.source.y * srcH * halfRadius + srcPos.y,
      rs.target.x * tgtW * halfRadius + tgtPos.x,
      rs.target.y * tgtH * halfRadius + tgtPos.y
    ];

    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = 'haystack';
    rscratch.haystack = true;

    this.projectLines( edge );
    this.calculateArrowAngles( edge );
    this.recalculateEdgeLabelProjections( edge );
    this.calculateLabelAngles( edge );
  }

  return hashTable;
};

var getAngleFromDisp = function( dispX, dispY ){
  return Math.atan2( dispY, dispX ) - Math.PI / 2;
};

BRp.calculateArrowAngles = function( edge ){
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  var srcPos = edge._private.source._private.position;
  var tgtPos = edge._private.target._private.position;

  if( isHaystack ){
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY;

  // source
  //

  if( isSegments ){
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var bX = math.qbezierAt( pts[0], pts[2], pts[4], 0.1 );
    var bY = math.qbezierAt( pts[1], pts[3], pts[5], 0.1 );

    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if( isHaystack ){
    midX = ( startX + endX ) / 2;
    midY = ( startY + endY ) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if( isSelf ){
    dispX = -1;
    dispY = 1;
  } else if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    }
  } else if( isMultibezier || isCompound ){
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if( cpts.length / 2 % 2 === 0 ){
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0001 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0001 );
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.4999 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.4999 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.5 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.5 );
    }

    dispX = ( bp1x - bp0x );
    dispY = ( bp1y - bp0y );
  }

  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -( pts[ i3 ] - pts[ i2 ] );
      dispY = -( pts[ i3 + 1] - pts[ i2 + 1] );
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );

  // target
  //

  if( isSegments ){
    dispX = endX - rs.segpts[ rs.segpts.length - 2 ];
    dispY = endY - rs.segpts[ rs.segpts.length - 1 ];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var l = pts.length;
    var bX = math.qbezierAt( pts[l-6], pts[l-4], pts[l-2], 0.9 );
    var bY = math.qbezierAt( pts[l-5], pts[l-3], pts[l-1], 0.9 );

    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
};

BRp.calculateLabelAngles = function( ele ){
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var rot = ele.pstyle( 'text-rotation' );
  var rotStr = rot.strValue;

  if( rotStr === 'none' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else if( isEdge && rotStr === 'autorotate' ){
    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
    rs.targetLabelAngle = rs.targetLabelAutoAngle;
  } else if( rotStr === 'autorotate' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
  }
};

BRp.manualEndptToPx = function( node, prop ){
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if( prop.value.length === 2 ){
    var p = [
      prop.pfValue[0],
      prop.pfValue[1]
    ];

    if( prop.units[0] === '%' ){
      p[0] = p[0] * w;
    }

    if( prop.units[1] === '%' ){
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;

    return p;
  } else {
    var angle = prop.pfValue[0];

    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max( w, h );

    var p = [
      npos.x + Math.cos( angle ) * l,
      npos.y + Math.sin( angle ) * l
    ];

    return r.nodeShapes[ this.getNodeShape( node ) ].intersectLine(
      npos.x, npos.y,
      w, h,
      p[0], p[1],
      0
    );
  }
};

BRp.findEndpoints = function( edge ){
  var r = this;
  var intersect;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var src_p = source._private;
  var tgt_p = target._private;

  var srcPos = src_p.position;
  var tgtPos = tgt_p.position;

  var tgtArShape = edge.pstyle( 'target-arrow-shape' ).value;
  var srcArShape = edge.pstyle( 'source-arrow-shape' ).value;

  var tgtDist = edge.pstyle( 'target-distance-from-node' ).pfValue;
  var srcDist = edge.pstyle( 'source-distance-from-node' ).pfValue;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var tgtManEndpt = edge.pstyle('target-endpoint');

  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;

  var p1; // last known point of edge on target side
  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape
  var p2_i; // point to intersect with source shape

  if( bezier ){
    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
    var cpEnd = multi ? [ rs.ctrlpts[ rs.ctrlpts.length - 2], rs.ctrlpts[ rs.ctrlpts.length - 1] ] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if( lines ){
    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if( tgtManEndpt.value === 'inside-to-node' ){
    intersect = [ tgtPos.x, tgtPos.y ];
  } else if( tgtManEndpt.units ){
    intersect = this.manualEndptToPx( target, tgtManEndpt );
  } else {
    if( tgtManEndpt.value === 'outside-to-node' ){
      p1_i = p1;
    } else if( tgtManEndpt.value === 'outside-to-line' ){
      p1_i = [ srcPos.x, srcPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( target ) ].intersectLine(
      tgtPos.x,
      tgtPos.y,
      target.outerWidth(),
      target.outerHeight(),
      p1_i[0],
      p1_i[1],
      0
    );
  }

  var arrowEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].spacing( edge ) + tgtDist
  );
  var edgeEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].gap( edge ) + tgtDist
  );

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if( srcManEndpt.value === 'inside-to-node' ){
    intersect = [ srcPos.x, srcPos.y ];
  } else if( srcManEndpt.units ){
    intersect = this.manualEndptToPx( source, srcManEndpt );
  } else {
    if( srcManEndpt.value === 'outside-to-node' ){
      p2_i = p2;
    } else if( srcManEndpt.value === 'outside-to-line' ){
      p2_i = [ tgtPos.x, tgtPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( source ) ].intersectLine(
      srcPos.x,
      srcPos.y,
      source.outerWidth(),
      source.outerHeight(),
      p2_i[0],
      p2_i[1],
      0
    );
  }

  var arrowStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].spacing( edge ) + srcDist
  );
  var edgeStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].gap( edge ) + srcDist
  );

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if( hasEndpts ){
    if( !is.number( rs.startX ) || !is.number( rs.startY ) || !is.number( rs.endX ) || !is.number( rs.endY ) ){
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getArrowWidth = BRp.getArrowHeight = function( edgeWidth, scale ){
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[ edgeWidth + ', ' + scale ];
  if( cachedVal ){
    return cachedVal;
  }

  cachedVal =  Math.max( Math.pow( edgeWidth * 13.37, 0.9 ), 29 ) * scale;
  cache[ edgeWidth + ', ' + scale ] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

},{"../../../collection/zsort":35,"../../../is":86,"../../../math":88,"../../../util":103,"../../../window":110}],62:[function(require,module,exports){
'use strict';

var BRp = {};

BRp.getCachedImage = function( url, crossOrigin, onLoad ){
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[ url ];

  if( cache ){
    if( !cache.image.complete ){
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[ url ] = imageCache[ url ] || {};

    var image = cache.image = new Image(); // eslint-disable-line no-undef
    image.addEventListener('load', onLoad);

    // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978
    var dataUriPrefix = 'data:';
    var isDataUri = url.substring( 0, dataUriPrefix.length ).toLowerCase() === dataUriPrefix;
    if( !isDataUri ){
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;

    return image;
  }
};

module.exports = BRp;

},{}],63:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );
var util = require( '../../../util' );

var BaseRenderer = function( options ){ this.init( options ); };
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];

BRp.init = function( options ){
  var r = this;

  r.options = options;

  r.cy = options.cy;

  r.container = options.cy.container();

  r.selection = [ undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [ 0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95 ];

  //--Pointer-related data
  r.hoverData = {down: null, last: null,
      downTime: null, triggerMode: null,
      dragging: false,
      initialPan: [ null, null ], capture: false};

  r.dragData = {possibleDragElements: []};

  r.touchData = {
    start: null, capture: false,

    // These 3 fields related to tap, taphold events
    startPosition: [ null, null, null, null, null, null ],
    singleTouchStartTime: null,
    singleTouchMoved: true,

    now: [ null, null, null, null, null, null ],
    earlier: [ null, null, null, null, null, null ]
  };

  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = options.motionBlur; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = { // higher priority execs before lower one
    animations:   400,
    eleCalcs:     300,
    eleTxrDeq:    200,
    lyrTxrDeq:    100
  };

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
  r.load();
};

BRp.notify = function( params ){
  var types;
  var r = this;

  // the renderer can't be notified after it's destroyed
  if( this.destroyed ){ return; }

  if( is.array( params.type ) ){
    types = params.type;

  } else {
    types = [ params.type ];
  }

  var has = {};
  for( var i = 0; i < types.length; i++ ){
    var type = types[ i ];

    has[ type ] = true;
  } // for

  if( has['destroy'] ){
    r.destroy();
    return;
  }

  if( has['add'] || has['remove'] || has['load'] || has['zorder'] ){
    r.invalidateCachedZSortedEles();
  }

  if( has['viewport'] ){
    r.redrawHint( 'select', true );
  }

  if( has['load'] || has['resize'] ){
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize( r.container );
  }

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function(){
  var r = this;

  r.destroyed = true;

  r.cy.stopAnimationLoop();

  for( var i = 0; i < r.bindings.length; i++ ){
    var binding = r.bindings[ i ];
    var b = binding;
    var tgt = b.target;

    ( tgt.off || tgt.removeEventListener ).apply( tgt, b.args );
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if( r.removeObserver ){
    r.removeObserver.disconnect();
  }

  if( r.styleObserver ){
    r.styleObserver.disconnect();
  }

  if( r.labelCalcDiv ){
    try {
      document.body.removeChild( r.labelCalcDiv ); // eslint-disable-line no-undef
    } catch( e ){
      // ie10 issue #1014
    }
  }
};

[
  require( './arrow-shapes' ),
  require( './coord-ele-math' ),
  require( './images' ),
  require( './load-listeners' ),
  require( './node-shapes' ),
  require( './redraw' )
].forEach( function( props ){
  util.extend( BRp, props );
} );

module.exports = BR;

},{"../../../is":86,"../../../util":103,"./arrow-shapes":60,"./coord-ele-math":61,"./images":62,"./load-listeners":64,"./node-shapes":65,"./redraw":66}],64:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );
var util = require( '../../../util' );
var math = require( '../../../math' );
var Event = require( '../../../event' );

var BRp = {};

BRp.registerBinding = function( target, event, handler, useCapture ){
  var args = Array.prototype.slice.apply( arguments, [1] ); // copy
  var b = this.binder( target );

  return b.on.apply( b, args );
};

BRp.binder = function( tgt ){
  var r = this;

  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement( tgt );

  if( r.supportsPassiveEvents == null ){

    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty( {}, 'passive', {
        get: function(){
          supportsPassive = true;
        }
      } );

      window.addEventListener( 'test', null, opts );
    } catch( err ){}

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function( event, handler, useCapture ){
    var args = Array.prototype.slice.call( arguments );

    if( tgtIsDom && r.supportsPassiveEvents ){ // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });

    ( tgt.addEventListener || tgt.on ).apply( tgt, args );

    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp.nodeIsDraggable = function( node ){
  return (
    node
    && node.isNode()
    && !node.locked()
    && node.grabbable()
  );
};

BRp.nodeIsGrabbable = function( node ){
  return (
    this.nodeIsDraggable( node )
    && node.pstyle( 'opacity' ).value !== 0
    && node.pstyle( 'visibility' ).value === 'visible'
    && node.pstyle( 'display' ).value === 'element'
  );
};

BRp.load = function(){
  var r = this;

  var triggerEvents = function( target, names, e, props ){
    if( target == null ){
      target = r.cy;
    }

    for( var i = 0; i < names.length; i++ ){
      var name = names[ i ];

      var event = new Event( e, util.extend( { type: name }, props ) );
      target.trigger( event );
    }
  };

  var isMultSelKeyDown = function( e ){
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function( down, downs ){
    var allowPassthrough = true;

    if( r.cy.hasCompoundNodes() && down && down.isEdge() ){
      // a compound node below the edge => no passthrough panning
      for( var i = 0; downs && i < downs.length; i++ ){
        var down = downs[i];

        if( down.isNode() && down.isParent() ){
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var getDragListIds = function( opts ){
    var listHasId;

    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for( var i = 0; i < opts.addToList.length; i++ ){
          var ele = opts.addToList[ i ];

          opts.addToList.hasId[ ele.id() ] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  var setGrabbed = function( ele ){
    ele[0]._private.grabbed = true;
  };

  var setFreed = function( ele ){
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function( ele, opts ){
    var listHasId = getDragListIds( opts );

    if( !listHasId[ ele.id() ] ){
      opts.addToList.push( ele );
      listHasId[ ele.id() ] = true;

      setGrabbed( ele );
    }
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function( node, opts ){
    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    var innerNodes = node.descendants();

    if( opts.inDragLayer ){
      innerNodes.forEach( setInDragLayer );
      innerNodes.connectedEdges().forEach( setInDragLayer );
    }

    if( opts.addToList ){
      innerNodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  // adds the given nodes and its neighbourhood to the drag layer
  var addNodesToDrag = function( nodes, opts ){
    opts = opts || {};

    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if( opts.inDragLayer ){
      nodes.forEach( setInDragLayer );

      nodes.neighborhood().stdFilter(function( ele ){
        return !hasCompoundNodes || ele.isEdge();
      }).forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }

    addDescendantsToDrag( nodes, opts ); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer( nodes, {
      inDragLayer: opts.inDragLayer
    } );

    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function( grabbedEles ){
    if( !grabbedEles ){ return; }

    grabbedEles.hasId = {}; // clear the id list

    // just go over all elements rather than doing a bunch of (possibly expensive) traversals
    r.getCachedZSortedEles().forEach(function( ele ){
      setFreed( ele );
      setOutDragLayer( ele );
      removeGrabTarget( ele );
    });

    r.updateCachedGrabbedEles();
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function( node, opts ){

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    // find top-level parent
    var parent = node.ancestors().orphans();

    // no parent node: no nodes to add to the drag layer
    if( parent.same( node ) ){
      return;
    }

    var nodes = parent.descendants().spawnSelf()
      .merge( parent )
      .unmerge( node )
      .unmerge( node.descendants() )
    ;

    var edges = nodes.connectedEdges();

    if( opts.inDragLayer ){
      edges.forEach( setInDragLayer );
      nodes.forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';

  // watch for when the cy container is removed from the dom
  if( haveMutationsApi ){
    r.removeObserver = new MutationObserver( function( mutns ){ // eslint-disable-line no-undef
      for( var i = 0; i < mutns.length; i++ ){
        var mutn = mutns[ i ];
        var rNodes = mutn.removedNodes;

        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
          var rNode = rNodes[ j ];

          if( rNode === r.container ){
            r.destroy();
            break;
          }
        } }
      }
    } );

    if( r.container.parentNode ){
      r.removeObserver.observe( r.container.parentNode, { childList: true } );
    }
  } else {
    r.registerBinding( r.container, 'DOMNodeRemoved', function( e ){
      r.destroy();
    } );
  }

  var onResize = util.debounce( function(){
    r.cy.invalidateSize();
    r.invalidateContainerClientCoordsCache();

    r.matchCanvasSize( r.container );
    r.redrawHint( 'eles', true );
    r.redrawHint( 'drag', true );
    r.redraw();
  }, 100 );

  if( haveMutationsApi ){
    r.styleObserver = new MutationObserver( onResize ); // eslint-disable-line no-undef

    r.styleObserver.observe( r.container, { attributes: true } );
  }

  // auto resize
  r.registerBinding( window, 'resize', onResize ); // eslint-disable-line no-undef

  var invalCtnrBBOnScroll = function( domEle ){
    r.registerBinding( domEle, 'scroll', function( e ){
      r.invalidateContainerClientCoordsCache();
    } );
  };

  var bbCtnr = r.cy.container();

  for( ;; ){

    invalCtnrBBOnScroll( bbCtnr );

    if( bbCtnr.parentNode ){
      bbCtnr = bbCtnr.parentNode;
    } else {
      break;
    }

  }

  // stop right click menu from appearing on cy
  r.registerBinding( r.container, 'contextmenu', function( e ){
    e.preventDefault();
  } );

  var inBoxSelection = function(){
    return r.selection[4] !== 0;
  };

  var eventInContainer = function( e ){
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];

    var positions = e.touches ? e.touches : [ e ];
    var atLeastOnePosInside = false;

    for( var i = 0; i < positions.length; i++ ){
      var p = positions[i];

      if( x <= p.clientX && p.clientX <= x + width
        && y <= p.clientY && p.clientY <= y + height
      ){
        atLeastOnePosInside = true;
        break;
      }
    }

    if( !atLeastOnePosInside ){ return false; }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while( tParent ){
      if( tParent === container ){
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if( !containerIsTarget ){ return false; } // if target is outisde cy container, then this event is not for us

    return true;
  };

  // Primary key
  r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){
    if( !eventInContainer(e) ){ return; }

    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var select = r.selection;
    var nears = r.findNearestElements( pos[0], pos[1], false );
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout( function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.trigger( new Event( e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          } else {
            cy.trigger( new Event( e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }
        }

      }, r.tapholdDuration );
    };

    // Right click button
    if( e.which == 3 ){

      r.hoverData.cxtStarted = true;

      var cxtEvt = new Event( e, {
        type: 'cxttapstart',
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( near ){
        near.activate();
        near.trigger( cxtEvt );

        r.hoverData.down = near;
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.downTime = (new Date()).getTime();
      r.hoverData.cxtDragged = false;

    // Primary button
    } else if( e.which == 1 ){

      if( near ){
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if( near != null ){

          if( r.nodeIsGrabbable( near ) ){

            var grabEvent = new Event( e, {
              type: 'grab',
              cyPosition: { x: pos[0], y: pos[1] }
            } );

            setGrabTarget( near );

            if( !near.selected() ){

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag( near, { addToList: draggedElements } );

              near.trigger( grabEvent );

            } else if( near.selected() ){
              draggedElements = r.dragData.possibleDragElements = [  ];

              var selectedNodes = cy.$( function(){ return this.isNode() && this.selected() && r.nodeIsGrabbable( this ); } );

              addNodesToDrag( selectedNodes, { addToList: draggedElements } );

              near.trigger( grabEvent );
            }

            r.redrawHint( 'eles', true );
            r.redrawHint( 'drag', true );

          }

        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = (new Date()).getTime();
      }

      triggerEvents( near, [ 'mousedown', 'tapstart', 'vmousedown' ], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( near == null ){
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );

        r.redraw();
      } else if( near.isEdge() ){
        select[4] = 1; // for future pan
      }

      checkForTaphold();

    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];

  }, false );

  r.registerBinding( window, 'mousemove', function mousemoveHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;

    var near = null;
    if( !r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting ){
      near = r.findNearestElement( pos[0], pos[1], false );
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [ pos[0] - select[2], pos[1] - select[3] ];

    var draggedElements = r.dragData.possibleDragElements;

    var isOverThresholdDrag;

    if( mdownGPos ){
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown( e );

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function(){
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if( dragDelta.length === 0 ){
        dragDelta.push( disp[0] );
        dragDelta.push( disp[1] );
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };


    preventDefault = true;

    triggerEvents( near, [ 'mousemove', 'vmousemove', 'tapdrag' ], e, {
      cyPosition: { x: pos[0], y: pos[1] }
    } );

    var goIntoBoxMode = function(){
      r.data.bgActivePosistion = undefined;

      if( !r.hoverData.selecting ){
        cy.trigger('boxstart');
      }

      select[4] = 1;
      r.hoverData.selecting = true;

      r.redrawHint( 'select', true );
      r.redraw();
    };

    // trigger context drag if rmouse down
    if( r.hoverData.which === 3 ){
      // but only if over threshold
      if( isOverThresholdDrag ){
        var cxtEvt = new Event( e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new Event( e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new Event( e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }

        }
      }

    // Check if we are drag panning the entire graph
    } else if( r.hoverData.dragging ){
      preventDefault = true;

      if( cy.panningEnabled() && cy.userPanningEnabled() ){
        var deltaP;

        if( r.hoverData.justStartedPan ){
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: ( pos[0] - mdPos[0] ) * zoom,
            y: ( pos[1] - mdPos[1] ) * zoom
          };

          r.hoverData.justStartedPan = false;

        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };

        }

        cy.panBy( deltaP );

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport( e.clientX, e.clientY );

    // Checks primary button down & out of time & mouse not moved much
    } else if(
        select[4] == 1 && (down == null || down.isEdge())
    ){

      if( isOverThresholdDrag ){

        if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
          goIntoBoxMode();

        } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
          var allowPassthrough = allowPanningPassthrough( down, r.hoverData.downs );

          if( allowPassthrough ){
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;

            r.data.bgActivePosistion = math.array2point( mdownPos );

            r.redrawHint( 'select', true );
            r.redraw();
          }
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      }

    } else {
      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      if( ( !down || !down.grabbed() ) && near != last ){

        if( last ){
          triggerEvents( last, [ 'mouseout', 'tapdragout' ], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        if( near ){
          triggerEvents( near, [ 'mouseover', 'tapdragover' ], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        r.hoverData.last = near;
      }

      if( down && r.nodeIsDraggable( down ) ){

        if( isOverThresholdDrag ){ // then we can take action

          if( cy.boxSelectionEnabled() && multSelKeyDown ){ // then selection overrides
            if( down && down.grabbed() ){
              freeDraggedElements( draggedElements );

              down.trigger('free');
            }

            goIntoBoxMode();

          } else { // otherwise drag
            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ){
              r.redrawHint( 'eles', true );
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            // now, add the elements to the drag layer if not done already
            if( !r.hoverData.draggingEles ){
              addNodesToDrag( cy.collection( draggedElements ), { inDragLayer: true } );
            }

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[ i ];

              // Locked nodes not draggable, as well as non-visible nodes
              if( r.nodeIsDraggable( dEle ) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( is.number( disp[0] ) && is.number( disp[1] ) ){
                  var updatePos = !dEle.isParent();

                  if( updatePos ){
                    dPos.x += disp[0];
                    dPos.y += disp[1];
                  }

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = cy.collection( toTrigger );

            tcol.updateCompoundBounds();
            tcol.trigger( 'position drag' );

            r.redrawHint( 'drag', true );
            r.redraw();
          }

        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0]; select[3] = pos[1];

    if( preventDefault ){
      if( e.stopPropagation ) e.stopPropagation();
      if( e.preventDefault ) e.preventDefault();
      return false;
    }
  }, false );

  r.registerBinding( window, 'mouseup', function mouseupHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;
    if( !capture ){ return; }
    r.hoverData.capture = false;

    var cy = r.cy; var pos = r.projectIntoViewport( e.clientX, e.clientY ); var select = r.selection;
    var near = r.findNearestElement( pos[0], pos[1], false );
    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown( e );

    if( r.data.bgActivePosistion ){
      r.redrawHint( 'select', true );
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if( down ){
      down.unactivate();
    }

    if( r.hoverData.which === 3 ){
      var cxtEvt = new Event( e, {
        type: 'cxttapend',
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( !r.hoverData.cxtDragged ){
        var cxtTap = new Event( e, {
          type: 'cxttap',
          cyPosition: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtTap );
        } else {
          cy.trigger( cxtTap );
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;

    } else if( r.hoverData.which === 1 ){

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if( (down == null) // not mousedown on node
        && !r.dragData.didDrag // didn't move the node around
        && !r.hoverData.selecting // not box selection
        && !r.hoverData.dragged // didn't pan
        && !isMultSelKeyDown( e )
      ){

        cy.$( function(){
          return this.selected();
        } ).unselect();

        if( draggedElements.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents( near, [ 'mouseup', 'tapend', 'vmouseup' ], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if(
        !r.dragData.didDrag // didn't move a node around
        && !r.hoverData.dragged // didn't pan
        && !r.hoverData.selecting // not box selection
      ){
        triggerEvents( down, ['click', 'tap', 'vclick'], e, {
          cyPosition: { x: pos[0], y: pos[1] }
        } );
      }

      // Single selection
      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
        if( near != null && near._private.selectable ){

          if( r.hoverData.dragging ){
            // if panning, don't change selection state
          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
            if( near.selected() ){
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if( !multSelKeyDown ){
              cy.$( ':selected' ).unmerge( near ).unselect();
              near.select();
            }
          }

          r.redrawHint( 'eles', true );
        }
      }

      if( r.hoverData.selecting ){
        var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

        r.redrawHint( 'select', true );

        if( box.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        cy.trigger('boxend');

        var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

        if( cy.selectionType() === 'additive' ){
          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        } else {
          if( !multSelKeyDown ){
            cy.$( ':selected' ).unmerge( box ).unselect();
          }

          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        }

        // always need redraw in case eles unselectable
        r.redraw();

      }

      // Cancel drag pan
      if( r.hoverData.dragging ){
        r.hoverData.dragging = false;

        r.redrawHint( 'select', true );
        r.redrawHint( 'eles', true );

        r.redraw();
      }

      if( !select[4] ) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        var downWasGrabbed = down && down.grabbed();

        freeDraggedElements( draggedElements );

        if( downWasGrabbed ){ down.trigger('free'); }
      }

    } // else not right mouse

    select[4] = 0; r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;

  }, false );

  var wheelHandler = function( e ){


    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport( e.clientX, e.clientY );
    var rpos = [ pos[0] * cy.zoom() + cy.pan().x,
                  pos[1] * cy.zoom() + cy.pan().y ];

    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout( r.data.wheelTimeout );
      r.data.wheelTimeout = setTimeout( function(){
        r.data.wheelZooming = false;

        r.redrawHint( 'eles', true );
        r.redraw();
      }, 150 );

      var diff;

      if( e.deltaY != null ){
        diff = e.deltaY / -250;
      } else if( e.wheelDeltaY != null ){
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom( {
        level: cy.zoom() * Math.pow( 10, diff ),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      } );
    }

  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding( r.container, 'wheel', wheelHandler, true );

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding( window, 'scroll', function scrollHandler( e ){ // eslint-disable-line no-undef
    r.scrollingPage = true;

    clearTimeout( r.scrollingPageTimeout );
    r.scrollingPageTimeout = setTimeout( function(){
      r.scrollingPage = false;
    }, 250 );
  }, true );

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container
  r.registerBinding( r.container, 'mouseout', function mouseOutHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseout',
      cyPosition: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  r.registerBinding( r.container, 'mouseover', function mouseOverHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseover',
      cyPosition: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function( x1, y1, x2, y2 ){
    return Math.sqrt( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) );
  };

  var distanceSq = function( x1, y1, x2, y2 ){
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding( r.container, 'touchstart', touchstartHandler = function( e ){
    if( !eventInContainer(e) ){ return; }

    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    // record starting points for pinch-to-zoom
    if( e.touches[1] ){

      freeDraggedElements( r.dragData.touchDragEles );

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside =
           0 <= f1x1 && f1x1 <= containerWidth
        && 0 <= f2x1 && f2x1 <= containerWidth
        && 0 <= f1y1 && f1y1 <= containerHeight
        && 0 <= f2y1 && f2y1 <= containerHeight
      ;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
      center1 = [ (f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2 ];
      modelCenter1 = [
        (center1[0] - pan.x) / zoom,
        (center1[1] - pan.y) / zoom
      ];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

        var near1 = r.findNearestElement( now[0], now[1], true );
        var near2 = r.findNearestElement( now[2], now[3], true );

        if( near1 && near1.isNode() ){
          near1.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near1;

        } else if( near2 && near2.isNode() ){
          near2.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near2;

        } else {
          cy.trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;

      }

    }

    if( e.touches[2] ){
      // ignore
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      var nears = r.findNearestElements( now[0], now[1], true );
      var near = nears[0];

      if( near != null ){
        near.activate();

        r.touchData.start = near;
        r.touchData.starts = nears;

        if( r.nodeIsGrabbable( near ) ){

          var draggedEles = r.dragData.touchDragEles = [];

          r.redrawHint( 'eles', true );
          r.redrawHint( 'drag', true );

          if( near.selected() ){
            // reset drag elements, since near will be added again

            var selectedNodes = cy.$( function(){
              return this.selected() && r.nodeIsGrabbable( this );
            } );

            addNodesToDrag( selectedNodes, { addToList: draggedEles } );
          } else {
            addNodeToDrag( near, { addToList: draggedEles } );
          }

          setGrabTarget( near );

          near.trigger( new Event( e, {
            type: 'grab',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }
      }

      triggerEvents( near, [ 'touchstart', 'tapstart', 'vmousedown' ], e, {
        cyPosition: { x: now[0], y: now[1] }
      } );

      if( near == null ){
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );
        r.redraw();
      }


      // Tap, taphold
      // -----

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout( r.touchData.tapholdTimeout );
      r.touchData.tapholdTimeout = setTimeout( function(){
        if(
            r.touchData.singleTouchMoved === false
            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
            && !r.touchData.selecting // box selection shouldn't allow taphold through
        ){
          triggerEvents( r.touchData.start, [ 'taphold' ], e, {
            cyPosition: { x: now[0], y: now[1] }
          } );

          if( !r.touchData.start ){
            cy.$( ':selected' ).unselect();
          }

        }
      }, r.tapholdDuration );
    }

    if( e.touches.length >= 1 ){
      var sPos = r.touchData.startPosition = [];

      for( var i = 0; i < now.length; i++ ){
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];

      r.touchData.startGPosition = [ touch0.clientX, touch0.clientY ];
    }

  }, false );

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) { // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if( capture && e.touches[0] && startGPos ){
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    }

    // context swipe cancelling
    if( capture && r.touchData.cxt ){
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
        r.touchData.cxt = false;

        r.data.bgActivePosistion = undefined;

        r.redrawHint( 'select', true );

        var cxtEvt = new Event( e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( r.touchData.start ){
          r.touchData.start
            .unactivate()
            .trigger( cxtEvt )
          ;

          r.touchData.start = null;
        } else {
          cy.trigger( cxtEvt );
        }
      }

    }

    // context swipe
    if( capture && r.touchData.cxt ){
      var cxtEvt = new Event( e, {
        type: 'cxtdrag',
        cyPosition: { x: now[0], y: now[1] }
      } );
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      if( r.touchData.start ){
        r.touchData.start.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement( now[0], now[1], true );

      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

        if( r.touchData.cxtOver ){
          r.touchData.cxtOver.trigger( new Event( e, {
            type: 'cxtdragout',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }

        r.touchData.cxtOver = near;

        if( near ){
          near.trigger( new Event( e, {
            type: 'cxtdragover',
            cyPosition: { x: now[0], y: now[1] }
          } ) );

        }

      }

    // box selection
    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();

      if( !r.touchData.selecting ){
        cy.trigger('boxstart');
      }

      r.touchData.selecting = true;

      r.redrawHint( 'select', true );

      if( !select || select.length === 0 || select[0] === undefined ){
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

    // pinch to zoom
    } else if( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ){ // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;
      if( draggedEles ){
        r.redrawHint( 'drag', true );

        for( var i = 0; i < draggedEles.length; i++ ){
          var de_p = draggedEles[i]._private;

          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;


      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if( twoFingersStartInside ){
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if( r.touchData.start && r.touchData.start.active() ){
          var draggedEles = r.dragData.touchDragEles;

          freeDraggedElements( draggedEles );

          r.redrawHint( 'drag', true );
          r.redrawHint( 'eles', true );

          r.touchData.start
            .unactivate()
            .trigger( 'free' )
          ;
        }

        cy.viewport( {
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        } );

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
      if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
      if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    } else if( e.touches[0] ){
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near;

      if( !r.hoverData.draggingEles && !r.swipePanning ){
        near = r.findNearestElement( now[0], now[1], true );
      }

      if( capture && start != null ){
        e.preventDefault();
      }

      // dragging nodes
      if( capture && start != null && r.nodeIsDraggable( start ) ){

        if( isOverThresholdDrag ){ // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          if( justStartedDrag ){
            addNodesToDrag( cy.collection( draggedEles ), { inDragLayer: true } );
          }

          for( var k = 0; k < draggedEles.length; k++ ){
            var draggedEle = draggedEles[ k ];

            if( r.nodeIsDraggable( draggedEle ) && draggedEle.grabbed() ){
              r.dragData.didDrag = true;
              var dPos = draggedEle._private.position;
              var updatePos = !draggedEle.isParent();

              if( updatePos && is.number( disp[0] ) && is.number( disp[1] ) ){
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if( justStartedDrag ){
                r.redrawHint( 'eles', true );

                var dragDelta = r.touchData.dragDelta;

                if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }

              }
            }
          }

          var tcol = cy.collection( draggedEles );

          tcol.updateCompoundBounds();
          tcol.trigger( 'position drag' );

          r.hoverData.draggingEles = true;

          r.redrawHint( 'drag', true );

          if(
               r.touchData.startPosition[0] == earlier[0]
            && r.touchData.startPosition[1] == earlier[1]
          ){

            r.redrawHint( 'eles', true );
          }

          r.redraw();
        } else { // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if( dragDelta.length === 0 ){
            dragDelta.push( disp[0] );
            dragDelta.push( disp[1] );
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents( (start || near), [ 'touchmove', 'tapdrag', 'vmousemove' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( ( !start || !start.grabbed() ) && near != last ){
          if( last ){ last.trigger( new Event( e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } } ) ); }
          if( near ){ near.trigger( new Event( e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } } ) ); }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      if( capture ){
        for( var i = 0; i < now.length; i++ ){
          if( now[ i ]
            && r.touchData.startPosition[ i ]
            && isOverThresholdDrag ){

            r.touchData.singleTouchMoved = true;
          }
        }
      }

      // panning
      if(
          capture
          && ( start == null || start.isEdge() )
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){

        var allowPassthrough = allowPanningPassthrough( start, r.touchData.starts );

        if( allowPassthrough ){
          e.preventDefault();

          if( r.swipePanning ){
            cy.panBy( {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            } );

          } else if( isOverThresholdDrag ){
            r.swipePanning = true;

            cy.panBy( {
              x: dx * zoom,
              y: dy * zoom
            } );

            if( start ){
              start.unactivate();

              if( !r.data.bgActivePosistion ){
                r.data.bgActivePosistion = math.array2point( r.touchData.startPosition );
              }

              r.redrawHint( 'select', true );

              r.touchData.start = null;
            }
          }

        }

        // Re-project
        var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY );
        now[0] = pos[0]; now[1] = pos[1];
      }
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }
    //r.redraw();

  }, false );

  var touchcancelHandler;
  r.registerBinding( window, 'touchcancel', touchcancelHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    r.touchData.capture = false;

    if( start ){
      start.unactivate();
    }
  } );

  var touchendHandler;
  r.registerBinding( window, 'touchend', touchendHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if( capture ){
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    if( start ){
      start.unactivate();
    }

    var ctxTapend;
    if( r.touchData.cxt ){
      ctxTapend = new Event( e, {
        type: 'cxttapend',
        cyPosition: { x: now[0], y: now[1] }
      } );

      if( start ){
        start.trigger( ctxTapend );
      } else {
        cy.trigger( ctxTapend );
      }

      if( !r.touchData.cxtDragged ){
        var ctxTap = new Event( e, {
          type: 'cxttap',
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( start ){
          start.trigger( ctxTap );
        } else {
          cy.trigger( ctxTap );
        }

      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
      r.touchData.selecting = false;

      var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint( 'select', true );

      cy.trigger('boxend');

      var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

      box
        .trigger('box')
        .stdFilter( eleWouldBeSelected )
          .select()
          .trigger('boxselect')
      ;

      if( box.nonempty() ){
        r.redrawHint( 'eles', true );
      }

      r.redraw();
    }

    if( start != null ){
      start.unactivate();
    }

    if( e.touches[2] ){
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      // ignore

    // Last touch released
    } else if( !e.touches[0] ){

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;

      if( start != null ){

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements( draggedEles );

        r.redrawHint( 'drag', true );
        r.redrawHint( 'eles', true );

        if( startWasGrabbed ){
          start.trigger( 'free' );
        }

        triggerEvents( start, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        start.unactivate();

        r.touchData.start = null;

      } else {
        var near = r.findNearestElement( now[0], now[1], true );

        triggerEvents( near, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if( start != null
          && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable
          && rdist2 < r.touchTapThreshold2
          && !r.pinching // pinch to zoom should not affect selection
      ){

        if( cy.selectionType() === 'single' ){
          cy.$( ':selected' ).unmerge( start ).unselect();
          start.select();
        } else {
          if( start.selected() ){
            start.unselect();
          } else {
            start.select();
          }
        }

        r.redrawHint( 'eles', true );
      }

      // Tap event, roughly same as mouse click event for touch
      if( !r.touchData.singleTouchMoved ){
        triggerEvents( start, [ 'tap', 'vclick' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );
      }

      r.touchData.singleTouchMoved = true;
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }

    r.dragData.didDrag = false; // reset for next mousedown

    if( e.touches.length === 0 ){
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
    }

    if( e.touches.length < 2 ){
      r.pinching = false;
      r.redrawHint( 'eles', true );
      r.redraw();
    }

    //r.redraw();

  }, false );

  // fallback compatibility layer for ms pointer events
  if( typeof TouchEvent === 'undefined' ){

    var pointers = [];

    var makeTouch = function( e ){
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function( e ){
      return {
        event: e,
        touch: makeTouch( e )
      };
    };

    var addPointer = function( e ){
      pointers.push( makePointer( e ) );
    };

    var removePointer = function( e ){
      for( var i = 0; i < pointers.length; i++ ){
        var p = pointers[ i ];

        if( p.event.pointerId === e.pointerId ){
          pointers.splice( i, 1 );
          return;
        }
      }
    };

    var updatePointer = function( e ){
      var p = pointers.filter( function( p ){
        return p.event.pointerId === e.pointerId;
      } )[0];

      p.event = e;
      p.touch = makeTouch( e );
    };

    var addTouchesToEvent = function( e ){
      e.touches = pointers.map( function( p ){
        return p.touch;
      } );
    };

    r.registerBinding( r.container, 'pointerdown', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      addPointer( e );

      addTouchesToEvent( e );
      touchstartHandler( e );
    } );

    r.registerBinding( r.container, 'pointerup', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchendHandler( e );
    } );

    r.registerBinding( r.container, 'pointercancel', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchcancelHandler( e );
    } );

    r.registerBinding( r.container, 'pointermove', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      updatePointer( e );

      addTouchesToEvent( e );
      touchmoveHandler( e );
    } );

  }
};

module.exports = BRp;

},{"../../../event":48,"../../../is":86,"../../../math":88,"../../../util":103}],65:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var BRp = {};

BRp.generatePolygon = function( name, points ){
  return ( this.nodeShapes[ name ] = {
    renderer: this,

    name: name,

    points: points,

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( 'polygon', context, centerX, centerY, width, height, this.points );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.polygonIntersectLine(
          x, y,
          this.points,
          nodeX,
          nodeY,
          width / 2, height / 2,
          padding )
        ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      return math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height, [0, -1], padding )
      ;
    }
  } );
};

BRp.generateEllipse = function(){
  return ( this.nodeShapes['ellipse'] = {
    renderer: this,

    name: 'ellipse',

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding )
      ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      x -= centerX;
      y -= centerY;

      x /= (width / 2 + padding);
      y /= (height / 2 + padding);

      return x * x + y * y <= 1;
    }
  } );
};

BRp.generateRoundRectangle = function(){
  return ( this.nodeShapes['roundrectangle'] = {
    renderer: this,

    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding )
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius( width, height );

      // Check hBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){
        return true;
      }

      // Check vBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x * x + y * y <= 1);
      };


      // Check top left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check top right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      return false;
    }
  } );
};

BRp.registerNodeShapes = function(){
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  this.generateEllipse();

  this.generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare( 3, 0 ) );

  this.generatePolygon( 'rectangle', math.generateUnitNgonPointsFitToSquare( 4, 0 ) );
  nodeShapes[ 'square' ] = nodeShapes[ 'rectangle' ];

  this.generateRoundRectangle();

  this.generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );

  this.generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare( 5, 0 ) );

  this.generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare( 6, 0 ) );

  this.generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare( 7, 0 ) );

  this.generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare( 8, 0 ) );

  var star5Points = new Array( 20 );
  {
    var outerPoints = math.generateUnitNgonPoints( 5, 0 );
    var innerPoints = math.generateUnitNgonPoints( 5, Math.PI / 5 );

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt( 5 ));
    innerRadius *= 1.57;

    for( var i = 0;i < innerPoints.length / 2;i++ ){
      innerPoints[ i * 2] *= innerRadius;
      innerPoints[ i * 2 + 1] *= innerRadius;
    }

    for( var i = 0;i < 20 / 4;i++ ){
      star5Points[ i * 4] = outerPoints[ i * 2];
      star5Points[ i * 4 + 1] = outerPoints[ i * 2 + 1];

      star5Points[ i * 4 + 2] = innerPoints[ i * 2];
      star5Points[ i * 4 + 3] = innerPoints[ i * 2 + 1];
    }
  }

  star5Points = math.fitPolygonToSquare( star5Points );

  this.generatePolygon( 'star', star5Points );

  this.generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );

  this.generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

  nodeShapes.makePolygon = function( points ){

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join( '$' );
    var name = 'polygon-' + key;
    var shape;

    if( (shape = this[ name ]) ){ // got cached shape
      return shape;
    }

    // create and cache new shape
    return renderer.generatePolygon( name, points );
  };

};

module.exports = BRp;

},{"../../../math":88}],66:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );

var BRp = {};

BRp.timeToRender = function(){
  return this.redrawTotalTime / this.redrawCount;
};

BRp.redraw = function( options ){
  options = options || util.staticEmptyObject();

  var r = this;

  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }
  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp.beforeRender = function( fn, priority ){
  // the renderer can't add tick callbacks when destroyed
  if( this.destroyed ){ return; }

  priority = priority || 0;

  var cbs = this.beforeRenderCallbacks;

  cbs.push({ fn: fn, priority: priority });

  // higher priority callbacks executed first
  cbs.sort(function( a, b ){ return b.priority - a.priority; });
};

var beforeRenderCallbacks = function( r, willDraw, startTime ){
  var cbs = r.beforeRenderCallbacks;

  for( var i = 0; i < cbs.length; i++ ){
    cbs[i].fn( willDraw, startTime );
  }
};

BRp.startRenderLoop = function(){
  var r = this;

  if( r.renderLoopStarted ){
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function( requestTime ){
    if( r.destroyed ){ return; }

    if( r.requestedFrame && !r.skipFrame ){
      beforeRenderCallbacks( r, true, requestTime );

      var startTime = util.performanceNow();

      r.render( r.renderOptions );

      var endTime = r.lastDrawTime = util.performanceNow();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks( r, false, requestTime );
    }

    r.skipFrame = false;

    util.requestAnimationFrame( renderFn );
  };

  util.requestAnimationFrame( renderFn );

};

module.exports = BRp;

},{"../../../util":103}],67:[function(require,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.arrowShapeImpl = function( name ){
  return ( impl || (impl = {
    'polygon': function( context, points ){
      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        context.lineTo( pt.x, pt.y );
      }
    },

    'triangle-backcurve': function( context, points, controlPoint ){
      var firstPt;

      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo( pt.x, pt.y );
      }

      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
    },

    'triangle-tee': function( context, trianglePoints, teePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }

      if( context.beginPath ){ context.beginPath(); }

        var teePts = teePoints;
        var firstTeePt = teePoints[0];
        context.moveTo( firstTeePt.x, firstTeePt.y );

        for( var i = 0; i < teePts.length; i++ ){
          var pt = teePts[ i ];

          context.lineTo( pt.x, pt.y );
        }
      if( context.closePath ){ context.closePath(); }
    },

    'triangle-cross': function( context, trianglePoints, crossLinePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }


      if( context.beginPath ){ context.beginPath(); }

      var crossLinePts = crossLinePoints;
      var firstTeePt = crossLinePoints[0];
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for( var i = 0; i < crossLinePts.length; i++ ){
        var pt = crossLinePts[ i ];

        context.lineTo( pt.x, pt.y );
      }
      if( context.closePath ){ context.closePath(); }
    },

    'circle': function( context, rx, ry, r ){
      context.arc( rx, ry, r, 0, Math.PI * 2, false );
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],68:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.drawEdge = function( context, edge, shiftToOriginWithBb, drawLabel, drawOverlayInstead ){
  var rs = edge._private.rscratch;
  var usePaths = this.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if( rs.badLine || isNaN(rs.allpts[0]) ){ // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  if( !edge.visible() ){ return; }

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  var overlayPadding = edge.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = edge.pstyle( 'overlay-opacity' ).value;
  var overlayColor = edge.pstyle( 'overlay-color' ).value;

  // Edge color & opacity
  if( drawOverlayInstead ){

    if( overlayOpacity === 0 ){ // exit early if no overlay
      return;
    }

    this.strokeStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );
    context.lineCap = 'round';

    if( rs.edgeType == 'self' && !usePaths ){
      context.lineCap = 'butt';
    }

  } else {
    var lineColor = edge.pstyle( 'line-color' ).value;

    this.strokeStyle( context, lineColor[0], lineColor[1], lineColor[2], edge.pstyle( 'opacity' ).value );

    context.lineCap = 'butt';
  }

  context.lineJoin = 'round';

  var edgeWidth = edge.pstyle( 'width' ).pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
  var lineStyle = drawOverlayInstead ? 'solid' : edge.pstyle( 'line-style' ).value;
  context.lineWidth = edgeWidth;

  var shadowBlur = edge.pstyle( 'shadow-blur' ).pfValue;
  var shadowOpacity = edge.pstyle( 'shadow-opacity' ).value;
  var shadowColor = edge.pstyle( 'shadow-color' ).value;
  var shadowOffsetX = edge.pstyle( 'shadow-offset-x' ).pfValue;
  var shadowOffsetY = edge.pstyle( 'shadow-offset-y' ).pfValue;

  this.shadowStyle( context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );

  this.drawEdgePath(
    edge,
    context,
    rs.allpts,
    lineStyle,
    edgeWidth
  );

  this.drawArrowheads( context, edge, drawOverlayInstead );

  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy

  if( !drawOverlayInstead ){
    this.drawEdge( context, edge, false, drawLabel, true );
  }

  this.drawElementText( context, edge, drawLabel );

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }
};


CRp.drawEdgePath = function( edge, context, pts, type, width ){
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if( usePaths ){
    var pathCacheKey = pts.join( '$' );
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if( keyMatches ){
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( canvasCxt.setLineDash ){ // for very outofdate browsers
    switch( type ){
      case 'dotted':
        canvasCxt.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        canvasCxt.setLineDash( [ 6, 3 ] );
        break;

      case 'solid':
        canvasCxt.setLineDash( [ ] );
        break;
    }
  }

  if( !pathCacheHit && !rs.badLine ){
    if( context.beginPath ){ context.beginPath(); }
    context.moveTo( pts[0], pts[1] );

    switch( rs.edgeType ){
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for( var i = 2; i + 3 < pts.length; i += 4 ){
          context.quadraticCurveTo( pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] );
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for( var i = 2; i + 1 < pts.length; i += 2 ){
          context.lineTo( pts[ i ], pts[ i + 1] );
        }
        break;
    }
  }

  context = canvasCxt;
  if( usePaths ){
    context.stroke( path );
  } else {
    context.stroke();
  }

  // reset any line dashes
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

};

CRp.drawArrowheads = function( context, edge, drawOverlayInstead ){
  if( drawOverlayInstead ){ return; } // don't do anything for overlays

  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
  }

  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );

  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
  }
};

CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
  if( isNaN( x ) || x == null || isNaN( y ) || y == null || isNaN( angle ) || angle == null ){ return; }

  var self = this;
  var arrowShape = edge.pstyle( prefix + '-arrow-shape' ).value;
  if( arrowShape === 'none' ) { return; }

  var arrowClearFill = edge.pstyle( prefix + '-arrow-fill' ).value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle( prefix + '-arrow-fill' ).value;
  var edgeWidth = edge.pstyle( 'width' ).pfValue;
  var opacity = edge.pstyle( 'opacity' ).value;

  var gco = context.globalCompositeOperation;

  var shapeImpl = self.arrowShapes[ arrowShape ];

  // check if the shape needs both fill and stroke operations to be drawn
  if( shapeImpl.forceStroke && arrowFill === 'filled' ){
    arrowFill = 'both';
  }

  if( opacity !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle( context, 255, 255, 255, 1 );
    self.strokeStyle( context, 255, 255, 255, 1 );

    self.drawArrowShape( edge, prefix, context,
      arrowClearFill, edgeWidth, arrowShape, x, y, angle
    );

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = edge.pstyle( prefix + '-arrow-color' ).value;
  self.fillStyle( context, color[0], color[1], color[2], opacity );
  self.strokeStyle( context, color[0], color[1], color[2], opacity );

  self.drawArrowShape( edge, prefix, context,
    arrowFill, edgeWidth, arrowShape, x, y, angle
  );
};

CRp.drawArrowShape = function( edge, arrowType, context, fill, edgeWidth, shape, x, y, angle ){
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var scale = edge.pstyle( 'arrow-scale' ).value;
  var size = this.getArrowWidth( edgeWidth, scale );
  var shapeImpl = r.arrowShapes[ shape ];

  if( usePaths ){
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[ arrowType ] === pathCacheKey;
    if( alreadyCached ){
      path = context = rs.arrowPathCache[ arrowType ];
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.arrowPathCacheKey[ arrowType ] = pathCacheKey;
      rs.arrowPathCache[ arrowType ] = path;
    }
  }

  if( context.beginPath ){ context.beginPath(); }

  if( !pathCacheHit ){
    shapeImpl.draw( context, size, angle, translation, edgeWidth );
  }

  if( !shapeImpl.leavePathOpen && context.closePath ){
    context.closePath();
  }

  context = canvasContext;

  if( fill === 'filled' || fill === 'both' ){
    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  if( fill === 'hollow' || fill === 'both' ){
    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
    context.lineJoin = 'miter';

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  }
};

module.exports = CRp;

},{}],69:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var CRp = {};

CRp.drawElement = function( context, ele, shiftToOriginWithBb, showLabel ){
  var r = this;

  if( ele.isNode() ){
    r.drawNode( context, ele, shiftToOriginWithBb, showLabel );
  } else {
    r.drawEdge( context, ele, shiftToOriginWithBb, showLabel );
  }
};

CRp.drawCachedElement = function( context, ele, pxRatio, extent ){
  var r = this;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  if( !extent || math.boundingBoxesIntersect( bb, extent ) ){
    var cache = r.data.eleTxrCache.getElement( ele, bb, pxRatio );

    if( cache ){
      context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );
    } else { // if the element is not cacheable, then draw directly
      r.drawElement( context, ele );
    }
  }
};

CRp.drawElements = function( context, eles ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawElement( context, ele );
  }
};

CRp.drawCachedElements = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawCachedNodes = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    if( !ele.isNode() ){ continue; }

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawLayeredElements = function( context, eles, pxRatio, extent ){
  var r = this;

  var layers = r.data.lyrTxrCache.getLayers( eles, pxRatio );

  if( layers ){
    for( var i = 0; i < layers.length; i++ ){
      var layer = layers[i];
      var bb = layer.bb;

      if( bb.w === 0 || bb.h === 0 ){ continue; }

      context.drawImage( layer.canvas, bb.x1, bb.y1, bb.w, bb.h );
    }
  } else { // fall back on plain caching if no layers
    r.drawCachedElements( context, eles, pxRatio, extent );
  }
};

CRp.drawDebugPoints = function( context, eles ){
  var draw = function( x, y, color ){
    context.fillStyle = color;
    context.fillRect( x - 1, y - 1, 3, 3 );
  }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.isNode() ){
      var p = ele.position();

      draw( p.x, p.y, 'magenta' );
    } else {
      var pts = rs.allpts;

      for( var j = 0; j + 1 < pts.length; j += 2 ){
        var x = pts[ j ];
        var y = pts[ j + 1 ];

        draw( x, y, 'cyan' );
      }

      draw( rs.midX, rs.midY, 'yellow' );
    }
  }
};

module.exports = CRp;

},{"../../../math":88}],70:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
  var r = this;

  try {
    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
  } catch( e ){
    r.redrawHint( 'eles', true );
    r.redrawHint( 'drag', true );

    r.drawingImage = true;

    r.redraw();
  }
};

CRp.drawInscribedImage = function( context, img, node ){
  var r = this;
  var nodeX = node._private.position.x;
  var nodeY = node._private.position.y;
  var fit = node.pstyle( 'background-fit' ).value;
  var xPos = node.pstyle( 'background-position-x' );
  var yPos = node.pstyle( 'background-position-y' );
  var repeat = node.pstyle( 'background-repeat' ).value;
  var nodeW = node.width();
  var nodeH = node.height();
  var rs = node._private.rscratch;
  var clip = node.pstyle( 'background-clip' ).value;
  var shouldClip = clip === 'node';
  var imgOpacity = node.pstyle( 'background-image-opacity' ).value;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if( null == imgW || null == imgH ){
    document.body.appendChild( img ); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild( img ); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  var bgW = node.pstyle( 'background-width' );
  if( bgW.value !== 'auto' ){
    if( bgW.units === '%' ){
      w = bgW.pfValue * nodeW;
    } else {
      w = bgW.pfValue;
    }
  }

  var bgH = node.pstyle( 'background-height' );
  if( bgH.value !== 'auto' ){
    if( bgH.units === '%' ){
      h = bgH.pfValue * nodeH;
    } else {
      h = bgH.pfValue;
    }
  }

  if( w === 0 || h === 0 ){
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if( fit === 'contain' ){
    var scale = Math.min( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;

  } else if( fit === 'cover' ){
    var scale = Math.max( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;
  }

  var x = (nodeX - nodeW / 2); // left
  if( xPos.units === '%' ){
    x += (nodeW - w) * xPos.pfValue;
  } else {
    x += xPos.pfValue;
  }

  var y = (nodeY - nodeH / 2); // top
  if( yPos.units === '%' ){
    y += (nodeH - h) * yPos.pfValue;
  } else {
    y += yPos.pfValue;
  }

  if( rs.pathCache ){
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if( repeat === 'no-repeat' ){

    if( shouldClip ){
      context.save();

      if( rs.pathCache ){
        context.clip( rs.pathCache );
      } else {
        r.nodeShapes[ r.getNodeShape( node ) ].draw(
          context,
          nodeX, nodeY,
          nodeW, nodeH );

        context.clip();
      }
    }

    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );

    if( shouldClip ){
      context.restore();
    }
  } else {
    var pattern = context.createPattern( img, repeat );
    context.fillStyle = pattern;

    r.nodeShapes[ r.getNodeShape( node ) ].draw(
        context,
        nodeX, nodeY,
        nodeW, nodeH );

    context.translate( x, y );
    context.fill();
    context.translate( -x, -y );
  }

  context.globalAlpha = gAlpha;

};

module.exports = CRp;

},{}],71:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );
var math = require( '../../../math' );

var CRp = {};

CRp.eleTextBiggerThanMin = function( ele, scale ){
  if( !scale ){
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil( math.log2( zoom * pxRatio ) ); // the effective texture level

    scale = Math.pow( 2, lvl );
  }

  var computedSize = ele.pstyle( 'font-size' ).pfValue * scale;
  var minSize = ele.pstyle( 'min-zoomed-font-size' ).pfValue;

  if( computedSize < minSize ){
    return false;
  }

  return true;
};

CRp.drawElementText = function( context, ele, force ){
  var r = this;

  if( force === undefined ){
    if( !r.eleTextBiggerThanMin( ele ) ){ return; }
  } else {
    if( !force ){ return; }
  }

  if( ele.isNode() ){
    var label = ele.pstyle( 'label' );

    if( !label || !label.value ){ return; }

    var textHalign = ele.pstyle( 'text-halign' ).strValue;
    var textValign = ele.pstyle( 'text-valign' ).strValue;

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    context.textBaseline = 'bottom';
  } else {
    var label = ele.pstyle( 'label' );
    var srcLabel = ele.pstyle( 'source-label' );
    var tgtLabel = ele.pstyle( 'target-label' );

    if(
      ( !label || !label.value )
      && ( !srcLabel || !srcLabel.value )
      && ( !tgtLabel || !tgtLabel.value )
    ){
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }


  r.drawText( context, ele );

  if( ele.isEdge() ){
    r.drawText( context, ele, 'source' );

    r.drawText( context, ele, 'target' );
  }
};

CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

CRp.getFontCache = function( context ){
  var cache;

  this.fontCaches = this.fontCaches || [];

  for( var i = 0; i < this.fontCaches.length; i++ ){
    cache = this.fontCaches[ i ];

    if( cache.context === context ){
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push( cache );

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function( context, ele ){
  // Font style
  var parentOpacity = ele.effectiveOpacity();
  var labelStyle = ele.pstyle( 'font-style' ).strValue;
  var labelSize = ele.pstyle( 'font-size' ).pfValue + 'px';
  var labelFamily = ele.pstyle( 'font-family' ).strValue;
  var labelWeight = ele.pstyle( 'font-weight' ).strValue;
  var opacity = ele.pstyle( 'text-opacity' ).value * ele.pstyle( 'opacity' ).value * parentOpacity;
  var outlineOpacity = ele.pstyle( 'text-outline-opacity' ).value * opacity;
  var color = ele.pstyle( 'color' ).value;
  var outlineColor = ele.pstyle( 'text-outline-color' ).value;
  var shadowBlur = ele.pstyle( 'text-shadow-blur' ).pfValue;
  var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;
  var shadowColor = ele.pstyle( 'text-shadow-color' ).value;
  var shadowOffsetX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;
  var shadowOffsetY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;

  var fontCacheKey = ele._private.fontKey;
  var cache = this.getFontCache( context );

  if( cache.key !== fontCacheKey ){
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle( context, color[ 0 ], color[ 1 ], color[ 2 ], opacity );

  this.strokeStyle( context, outlineColor[ 0 ], outlineColor[ 1 ], outlineColor[ 2 ], outlineOpacity );

  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );
};

function roundRect( ctx, x, y, width, height, radius ){
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo( x + radius, y );
  ctx.lineTo( x + width - radius, y );
  ctx.quadraticCurveTo( x + width, y, x + width, y + radius );
  ctx.lineTo( x + width, y + height - radius );
  ctx.quadraticCurveTo( x + width, y + height, x + width - radius, y + height );
  ctx.lineTo( x + radius, y + height );
  ctx.quadraticCurveTo( x, y + height, x, y + height - radius );
  ctx.lineTo( x, y + radius );
  ctx.quadraticCurveTo( x, y, x + radius, y );
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function( context, ele, prefix ){
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = ele.effectiveOpacity();
  if( parentOpacity === 0 || ele.pstyle( 'text-opacity' ).value === 0 ){
    return;
  }

  var textX = util.getPrefixedProperty( rscratch, 'labelX', prefix );
  var textY = util.getPrefixedProperty( rscratch, 'labelY', prefix );
  var text = this.getLabelText( ele, prefix );

  if( text != null && text !== '' && !isNaN( textX ) && !isNaN( textY ) ){
    this.setupTextStyle( context, ele );

    var pdash = prefix ? prefix + '-' : '';
    var textW = util.getPrefixedProperty( rscratch, 'labelWidth', prefix );
    var textH = util.getPrefixedProperty( rscratch, 'labelHeight', prefix );
    var textAngle = util.getPrefixedProperty( rscratch, 'labelAngle', prefix );
    var marginX = ele.pstyle( pdash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( pdash + 'text-margin-y' ).pfValue;

    var isEdge = ele.isEdge();
    var isNode = ele.isNode();

    var halign = ele.pstyle( 'text-halign' ).value;
    var valign = ele.pstyle( 'text-valign' ).value;

    if( isEdge ){
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;

    var rotation = ele.pstyle( 'text-rotation' );
    var theta;

    if( rotation.strValue === 'autorotate' ){
      theta = isEdge ? textAngle : 0;
    } else if( rotation.strValue === 'none' ){
      theta = 0;
    } else {
      theta = rotation.pfValue;
    }

    if( theta !== 0 ){
      var orgTextX = textX;
      var orgTextY = textY;

      context.translate( orgTextX, orgTextY );
      context.rotate( theta );

      textX = 0;
      textY = 0;
    }

    switch( valign ){
      case 'top':
        break;
      case 'center':
        textY += textH / 2;
        break;
      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle( 'text-background-opacity' ).value;
    var borderOpacity = ele.pstyle( 'text-border-opacity' ).value;
    var textBorderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var backgroundPadding = ele.pstyle( 'text-background-padding' ).pfValue;

    if( backgroundOpacity > 0 || ( textBorderWidth > 0 && borderOpacity > 0 ) ){
      var bgX = textX - backgroundPadding;

      switch( halign ){
        case 'left':
          bgX -= textW;
          break;
        case 'center':
          bgX -= textW / 2;
          break;
        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2*backgroundPadding;
      var bgH = textH + 2*backgroundPadding;

      if( backgroundOpacity > 0 ){
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle( 'text-background-color' ).value;

        context.fillStyle = 'rgba(' + textBackgroundColor[ 0 ] + ',' + textBackgroundColor[ 1 ] + ',' + textBackgroundColor[ 2 ] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle( 'text-background-shape' ).strValue;
        if( styleShape == 'roundrectangle' ){
          roundRect( context, bgX, bgY, bgW, bgH, 2 );
        } else {
          context.fillRect( bgX, bgY, bgW, bgH );
        }
        context.fillStyle = textFill;
      }

      if( textBorderWidth > 0 && borderOpacity > 0 ){
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle( 'text-border-color' ).value;
        var textBorderStyle = ele.pstyle( 'text-border-style' ).value;

        context.strokeStyle = 'rgba(' + textBorderColor[ 0 ] + ',' + textBorderColor[ 1 ] + ',' + textBorderColor[ 2 ] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if( context.setLineDash ){ // for very outofdate browsers
          switch( textBorderStyle ){
            case 'dotted':
              context.setLineDash( [ 1, 1 ] );
              break;
            case 'dashed':
              context.setLineDash( [ 4, 2 ] );
              break;
            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
              context.setLineDash( [] );
              break;
            case 'solid':
              context.setLineDash( [] );
              break;
          }
        }

        context.strokeRect( bgX, bgY, bgW, bgH );

        if( textBorderStyle === 'double' ){
          var whiteWidth = textBorderWidth / 2;

          context.strokeRect( bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2 );
        }

        if( context.setLineDash ){ // for very outofdate browsers
          context.setLineDash( [] );
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }

    }

    var lineWidth = 2 * ele.pstyle( 'text-outline-width' ).pfValue; // *2 b/c the stroke is drawn centred on the middle

    if( lineWidth > 0 ){
      context.lineWidth = lineWidth;
    }

    if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
      var lines = util.getPrefixedProperty( rscratch, 'labelWrapCachedLines', prefix );
      var lineHeight = textH / lines.length;

      switch( valign ){
        case 'top':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
        case 'center':
        case 'bottom':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
      }

      for( var l = 0; l < lines.length; l++ ){
        if( lineWidth > 0 ){
          context.strokeText( lines[ l ], textX, textY );
        }

        context.fillText( lines[ l ], textX, textY );

        textY += lineHeight;
      }

    } else {
      if( lineWidth > 0 ){
        context.strokeText( text, textX, textY );
      }

      context.fillText( text, textX, textY );
    }

    if( theta !== 0 ){
      context.rotate( -theta );
      context.translate( -orgTextX, -orgTextY );
    }

    this.shadowStyle( context, 'transparent', 0 ); // reset for next guy
  }
};

module.exports = CRp;

},{"../../../math":88,"../../../util":103}],72:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );

var CRp = {};

CRp.drawNode = function( context, node, shiftToOriginWithBb, drawLabel ){
  var r = this;
  var nodeWidth, nodeHeight;
  var rs = node._private.rscratch;
  var _p = node._private;
  var pos = pos || _p.position;

  if( !is.number( pos.x ) || !is.number( pos.y ) ){
    return; // can't draw node with undefined position
  }

  if( !node.visible() ){ return; }

  var parentOpacity = node.effectiveOpacity();

  var usePaths = this.usePaths();
  var path;
  var pathCacheHit = false;

  var padding = node.pstyle('padding').pfValue;

  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;

  context.lineWidth = node.pstyle( 'border-width' ).pfValue;

  //
  // setup shift

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  //
  // load bg image

  var bgImgProp = node.pstyle( 'background-image' );
  var url = bgImgProp.value[2] || bgImgProp.value[1];
  var image;

  if( url !== undefined ){

    var bgImgCrossOrigin = node.pstyle( 'background-image-crossorigin' );

    // get image, and if not loaded then ask to redraw when later loaded
    image = this.getCachedImage( url, bgImgCrossOrigin, function(){
      node.trigger('background');

      r.redrawHint( 'eles', true );
      r.redrawHint( 'drag', true );

      r.drawingImage = true;

      r.redraw();
    } );

    var prevBging = _p.backgrounding;
    _p.backgrounding = !image.complete;

    if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
      node.updateStyle( false );
    }
  }

  //
  // setup styles

  var bgColor = node.pstyle( 'background-color' ).value;
  var borderColor = node.pstyle( 'border-color' ).value;
  var borderStyle = node.pstyle( 'border-style' ).value;

  this.fillStyle( context, bgColor[0], bgColor[1], bgColor[2], node.pstyle( 'background-opacity' ).value * parentOpacity );

  this.strokeStyle( context, borderColor[0], borderColor[1], borderColor[2], node.pstyle( 'border-opacity' ).value * parentOpacity );

  var shadowBlur = node.pstyle( 'shadow-blur' ).pfValue;
  var shadowOpacity = node.pstyle( 'shadow-opacity' ).value;
  var shadowColor = node.pstyle( 'shadow-color' ).value;
  var shadowOffsetX = node.pstyle( 'shadow-offset-x' ).pfValue;
  var shadowOffsetY = node.pstyle( 'shadow-offset-y' ).pfValue;

  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );

  context.lineJoin = 'miter'; // so borders are square with the node shape

  if( context.setLineDash ){ // for very outofdate browsers
    switch( borderStyle ){
      case 'dotted':
        context.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        context.setLineDash( [ 4, 2 ] );
        break;

      case 'solid':
      case 'double':
        context.setLineDash( [ ] );
        break;
    }
  }


  //
  // draw shape

  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if( usePaths ){
    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + ( styleShape === 'polygon' ? '$' + shapePts.join('$') : '' );

    context.translate( pos.x, pos.y );

    if( rs.pathCacheKey === pathCacheKey ){
      path = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( !pathCacheHit ){

    var npos = pos;

    if( usePaths ){
      npos = {
        x: 0,
        y: 0
      };
    }

    r.nodeShapes[ this.getNodeShape( node ) ].draw(
          ( path || context ),
          npos.x,
          npos.y,
          nodeWidth,
          nodeHeight );
  }

  if( usePaths ){
    context.fill( path );
  } else {
    context.fill();
  }

  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy

  //
  // bg image

  if( url !== undefined ){
    if( image.complete ){
      this.drawInscribedImage( context, image, node );
    }
  }

  //
  // pie

  var darkness = node.pstyle( 'background-blacken' ).value;
  var borderWidth = node.pstyle( 'border-width' ).pfValue;

  if( this.hasPie( node ) ){
    this.drawPie( context, node, parentOpacity );

    // redraw path for blacken and border
    if( darkness !== 0 || borderWidth !== 0 ){

      if( !usePaths ){
        r.nodeShapes[ this.getNodeShape( node ) ].draw(
            context,
            pos.x,
            pos.y,
            nodeWidth,
            nodeHeight );
      }
    }
  }

  //
  // darken/lighten

  if( darkness > 0 ){
    this.fillStyle( context, 0, 0, 0, darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }

  } else if( darkness < 0 ){
    this.fillStyle( context, 255, 255, 255, -darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  //
  // border

  if( borderWidth > 0 ){

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }

    if( borderStyle === 'double' ){
      context.lineWidth = node.pstyle( 'border-width' ).pfValue / 3;

      var gco = context.globalCompositeOperation;
      context.globalCompositeOperation = 'destination-out';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }

      context.globalCompositeOperation = gco;
    }

  }

  if( usePaths ){
    context.translate( -pos.x, -pos.y );
  }

  // reset in case we changed the border style
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

  //
  // label

  r.drawElementText( context, node, drawLabel );

  //
  // overlay

  var overlayPadding = node.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = node.pstyle( 'overlay-opacity' ).value;
  var overlayColor = node.pstyle( 'overlay-color' ).value;

  if( overlayOpacity > 0 ){
    this.fillStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );

    r.nodeShapes[ 'roundrectangle' ].draw(
      context,
      node._private.position.x,
      node._private.position.y,
      nodeWidth + overlayPadding * 2,
      nodeHeight + overlayPadding * 2
    );

    context.fill();
  }

  //
  // clean up shift

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }

};

// does the node have at least one pie piece?
CRp.hasPie = function( node ){
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function( context, node, nodeOpacity, pos ){
  node = node[0]; // ensure ele ref

  var _p = node._private;
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle( 'pie-size' );
  var nodeW = node.width();
  var nodeH = node.height();
  var pos = pos || _p.position;
  var x = pos.x;
  var y = pos.y;
  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if( usePaths ){
    x = 0;
    y = 0;
  }

  if( pieSize.units === '%' ){
    radius = radius * pieSize.pfValue;
  } else if( pieSize.pfValue !== undefined ){
    radius = pieSize.pfValue / 2;
  }

  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
    var size = node.pstyle( 'pie-' + i + '-background-size' ).value;
    var color = node.pstyle( 'pie-' + i + '-background-color' ).value;
    var opacity = node.pstyle( 'pie-' + i + '-background-opacity' ).value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if( percent + lastPercent > 1 ){
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
      continue;
    }

    context.beginPath();
    context.moveTo( x, y );
    context.arc( x, y, radius, angleStart, angleEnd );
    context.closePath();

    this.fillStyle( context, color[0], color[1], color[2], opacity );

    context.fill();

    lastPercent += percent;
  }

};


module.exports = CRp;

},{"../../../is":86}],73:[function(require,module,exports){
'use strict';

var CRp = {};

var util = require( '../../../util' );

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function(){
  var context = this.data.contexts[0];

  if( this.forcedPixelRatio != null ){
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp.paintCache = function( context ){
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for( var i = 0; i < caches.length; i++ ){
    cache = caches[ i ];

    if( cache.context === context ){
      needToCreateCache = false;
      break;
    }
  }

  if( needToCreateCache ){
    cache = {
      context: context
    };
    caches.push( cache );
  }

  return cache;
};

CRp.fillStyle = function( context, r, g, b, a ){
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function( context, r, g, b, a ){
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp.shadowStyle = function( context, color, opacity, blur, offsetX, offsetY ){
  var zoom = this.cy.zoom();

  // var cache = this.paintCache( context );
  //
  // // don't make expensive changes to the shadow style if it's not used
  // if( cache.shadowOpacity === 0 && opacity === 0 ){
  //   return;
  // }
  //
  // cache.shadowOpacity = opacity;

  if( opacity > 0 ){
    context.shadowBlur = blur * zoom;
    context.shadowColor = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + opacity + ')';
    context.shadowOffsetX = offsetX * zoom;
    context.shadowOffsetY = offsetY * zoom;
  } else {
    context.shadowBlur = 0;
    context.shadowColor = 'transparent';
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
};

// Resize canvas
CRp.matchCanvasSize = function( container ){
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if(
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ] ||
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ]
  ){
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for( var i = 0; i < r.CANVAS_LAYERS; i++ ){

    canvas = data.canvases[ i ];

    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  for( var i = 0; i < r.BUFFER_COUNT; i++ ){

    canvas = data.bufferCanvases[ i ];

    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  r.textureMult = 1;
  if( pixelRatio <= 1 ){
    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;

};

CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
  this.render( {
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  } );
};

CRp.render = function( options ){
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy; var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if( !forcedContext ){
    if( r.prevPxRatio !== pixelRatio ){
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize( r.container );

      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if( !forcedContext && r.motionBlurTimeout ){
    clearTimeout( r.motionBlurTimeout );
  }

  if( motionBlur ){
    if( r.mbFrames == null ){
      r.mbFrames = 0;
    }

    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
      r.mbFrames++;
    }

    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if( r.mbFrames > r.minMbLowQualFrames ){
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if( r.clearingMotionBlur ){
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if( r.textureDrawLastFrame && !textureDraw ){
    needDraw[ r.NODE ] = true;
    needDraw[ r.SELECT_BOX ] = true;
  }

  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
    r.motionBlurPxRatio = 1;
  }

  if( forcedPan ){
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = r.getCachedZSortedEles();

  function mbclear( context, x, y, w, h ){
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
    context.fillRect( x, y, w, h );

    context.globalCompositeOperation = gco;
  }

  function setContextTransform( context, clear ){
    var ePan, eZoom, w, h;

    if( !r.clearingMotionBlur && (context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] || context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ]) ){
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( clear === 'motionBlur' ){
      mbclear( context, 0, 0, w, h );
    } else if( !forcedContext && (clear === undefined || clear) ){
      context.clearRect( 0, 0, w, h );
    }

    if( !drawAllLayers ){
      context.translate( ePan.x, ePan.y );
      context.scale( eZoom, eZoom );
    }
    if( forcedPan ){
      context.translate( forcedPan.x, forcedPan.y );
    }
    if( forcedZoom ){
      context.scale( forcedZoom, forcedZoom );
    }
  }

  if( !textureDraw ){
    r.textureDrawLastFrame = false;
  }

  if( textureDraw ){
    r.textureDrawLastFrame = true;

    var bb;

    if( !r.textureCache ){
      r.textureCache = {};

      bb = r.textureCache.bb = cy.mutableElements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];

      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];

      cxt.setTransform( 1, 0, 0, 1, 0, 0 );
      cxt.clearRect( 0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult );

      r.render( {
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      } );

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[ r.DRAG ] = false;
    needDraw[ r.NODE ] = false;

    var context = data.contexts[ r.NODE ];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( motionBlur ){
      mbclear( context, 0, 0, vp.width, vp.height );
    } else {
      context.clearRect( 0, 0, vp.width, vp.height );
    }

    var outsideBgColor = coreStyle[ 'outside-texture-bg-color' ].value;
    var outsideBgOpacity = coreStyle[ 'outside-texture-bg-opacity' ].value;
    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
    context.fillRect( 0, 0, vp.width, vp.height );

    var zoom = cy.zoom();

    setContextTransform( context, false );

    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );
    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );

  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
  var hideEdges = r.hideEdgesOnViewport && vpManip;

  var needMbClear = [];

  needMbClear[ r.NODE ] = !needDraw[ r.NODE ] && motionBlur && !r.clearedForMotionBlur[ r.NODE ] || r.clearingMotionBlur;
  if( needMbClear[ r.NODE ] ){ r.clearedForMotionBlur[ r.NODE ] = true; }

  needMbClear[ r.DRAG ] = !needDraw[ r.DRAG ] && motionBlur && !r.clearedForMotionBlur[ r.DRAG ] || r.clearingMotionBlur;
  if( needMbClear[ r.DRAG ] ){ r.clearedForMotionBlur[ r.DRAG ] = true; }

  if( needDraw[ r.NODE ] || drawAllLayers || drawOnlyNodeLayer || needMbClear[ r.NODE ] ){
    var useBuffer = motionBlur && !needMbClear[ r.NODE ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[ r.NODE ] );
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform( context, clear );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.nondrag, pixelRatio, extent );
    } else {
      r.drawLayeredElements( context, eles.nondrag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.nondrag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.NODE ] = false;
    }
  }

  if( !drawOnlyNodeLayer && (needDraw[ r.DRAG ] || drawAllLayers || needMbClear[ r.DRAG ]) ){
    var useBuffer = motionBlur && !needMbClear[ r.DRAG ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[ r.DRAG ] );

    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.drag, pixelRatio, extent );
    } else {
      r.drawCachedElements( context, eles.drag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.drag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.DRAG ] = false;
    }
  }

  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[ r.SELECT_BOX ] && !drawAllLayers)) ){
    var context = forcedContext || data.contexts[ r.SELECT_BOX ];

    setContextTransform( context );

    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle[ 'selection-box-border-width' ].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba('
        + coreStyle[ 'selection-box-color' ].value[0] + ','
        + coreStyle[ 'selection-box-color' ].value[1] + ','
        + coreStyle[ 'selection-box-color' ].value[2] + ','
        + coreStyle[ 'selection-box-opacity' ].value + ')';

      context.fillRect(
        r.selection[0],
        r.selection[1],
        r.selection[2] - r.selection[0],
        r.selection[3] - r.selection[1] );

      if( borderWidth > 0 ){
        context.strokeStyle = 'rgba('
          + coreStyle[ 'selection-box-border-color' ].value[0] + ','
          + coreStyle[ 'selection-box-border-color' ].value[1] + ','
          + coreStyle[ 'selection-box-border-color' ].value[2] + ','
          + coreStyle[ 'selection-box-opacity' ].value + ')';

        context.strokeRect(
          r.selection[0],
          r.selection[1],
          r.selection[2] - r.selection[0],
          r.selection[3] - r.selection[1] );
      }
    }

    if( data.bgActivePosistion && !r.hoverData.selecting ){
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = 'rgba('
        + coreStyle[ 'active-bg-color' ].value[0] + ','
        + coreStyle[ 'active-bg-color' ].value[1] + ','
        + coreStyle[ 'active-bg-color' ].value[2] + ','
        + coreStyle[ 'active-bg-opacity' ].value + ')';

      context.beginPath();
      context.arc( pos.x, pos.y, coreStyle[ 'active-bg-size' ].pfValue / zoom, 0, 2 * Math.PI );
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if( r.showFps && timeToRender ){
      timeToRender = Math.round( timeToRender );
      var fps = Math.round( 1000 / timeToRender );

      context.setTransform( 1, 0, 0, 1, 0, 0 );

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20 );

      var maxFps = 60;
      context.strokeRect( 0, 30, 250, 20 );
      context.fillRect( 0, 30, 250 * Math.min( fps / maxFps, 1 ), 20 );
    }

    if( !drawAllLayers ){
      needDraw[ r.SELECT_BOX ] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if( motionBlur && mbPxRatio !== 1 ){
    var cxtNode = data.contexts[ r.NODE ];
    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];

    var cxtDrag = data.contexts[ r.DRAG ];
    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];

    var drawMotionBlur = function( cxt, txt, needClear ){
      cxt.setTransform( 1, 0, 0, 1, 0, 0 );

      if( needClear || !motionBlurFadeEffect ){
        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
      } else {
        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
      }

      var pxr = mbPxRatio;

      cxt.drawImage(
        txt, // img
        0, 0, // sx, sy
        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
        0, 0, // x, y
        r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if( needDraw[ r.NODE ] || needMbClear[ r.NODE ] ){
      drawMotionBlur( cxtNode, txtNode, needMbClear[ r.NODE ] );
      needDraw[ r.NODE ] = false;
    }

    if( needDraw[ r.DRAG ] || needMbClear[ r.DRAG ] ){
      drawMotionBlur( cxtDrag, txtDrag, needMbClear[ r.DRAG ] );
      needDraw[ r.DRAG ] = false;
    }
  }

  r.prevViewport = vp;

  if( r.clearingMotionBlur ){
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if( motionBlur ){
    r.motionBlurTimeout = setTimeout( function(){
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[ r.NODE ] = false;
      r.clearedForMotionBlur[ r.DRAG ] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[ r.NODE ] = true;
      needDraw[ r.DRAG ] = true;

      r.redraw();
    }, motionBlurDelay );
  }

  r.drawingImage = false;


  if( !forcedContext && !r.initrender ){
    r.initrender = true;
    cy.trigger( 'initrender' );
  }

  if( !forcedContext ){
    cy.trigger('render');
  }

};

module.exports = CRp;

},{"../../../util":103}],74:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var CRp = {};

// @O Polygon drawing
CRp.drawPolygonPath = function(
  context, x, y, width, height, points ){

  var halfW = width / 2;
  var halfH = height / 2;

  if( context.beginPath ){ context.beginPath(); }

  context.moveTo( x + halfW * points[0], y + halfH * points[1] );

  for( var i = 1; i < points.length / 2; i++ ){
    context.lineTo( x + halfW * points[ i * 2], y + halfH * points[ i * 2 + 1] );
  }

  context.closePath();
};

// Round rectangle drawing
CRp.drawRoundRectanglePath = function(
  context, x, y, width, height ){

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius( width, height );

  if( context.beginPath ){ context.beginPath(); }

  // Start at top middle
  context.moveTo( x, y - halfHeight );
  // Arc from middle top to right side
  context.arcTo( x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius );
  // Arc from right side to bottom
  context.arcTo( x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius );
  // Arc from bottom to left side
  context.arcTo( x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius );
  // Arc from left side to topBorder
  context.arcTo( x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius );
  // Join line
  context.lineTo( x, y - halfHeight );


  context.closePath();
};

var sin0 = Math.sin( 0 );
var cos0 = Math.cos( 0 );

var sin = {};
var cos = {};

var ellipseStepSize = Math.PI / 40;

for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
  sin[ i ] = Math.sin( i );
  cos[ i ] = Math.cos( i );
}

CRp.drawEllipsePath = function( context, centerX, centerY, width, height ){
    if( context.beginPath ){ context.beginPath(); }

    if( context.ellipse ){
      context.ellipse( centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI );
    } else {
      var xPos, yPos;
      var rw = width / 2;
      var rh = height / 2;
      for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
        xPos = centerX - (rw * sin[ i ]) * sin0 + (rw * cos[ i ]) * cos0;
        yPos = centerY + (rh * cos[ i ]) * sin0 + (rh * sin[ i ]) * cos0;

        if( i === 0 ){
          context.moveTo( xPos, yPos );
        } else {
          context.lineTo( xPos, yPos );
        }
      }
    }

    context.closePath();
  };

module.exports = CRp;

},{"../../../math":88}],75:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var util = require( '../../../util' );
var Heap = require( '../../../heap' );
var defs = require( './texture-cache-defs' );

var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024;  // the maximum height of a texture
var minUtility = 0.5; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};

var ElementTextureCache = function( renderer ){
  var self = this;

  self.renderer = renderer;
  self.onDequeues = [];

  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;

ETCp.reasons = getTxrReasons;

// the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function( txrH ){
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};

  return ( self.eleImgCaches[ txrH ] = self.eleImgCaches[ txrH ] || [] );
};

// the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function( txrH ){
  var self = this;

  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[ txrH ] = rtxtrQs[ txrH ] || [];

  return rtxtrQ;
};

// queue of element draw requests at different scale levels
ETCp.getElementQueue = function(){
  var self = this;

  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function( a, b ){
    return b.reqs - a.reqs;
  });

  return q;
};

// queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementIdToQueue = function(){
  var self = this;

  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

  return id2q;
};

ETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){
  var self = this;
  var r = this.renderer;
  var rs = ele._private.rscratch;
  var zoom = r.cy.zoom();

  if( bb.w === 0 || bb.h === 0 ){ return null; }

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );
  }

  if( lvl < minLvl ){
    lvl = minLvl;
  } else if( zoom >= maxZoom || lvl > maxLvl ){
    return null;
  }

  var scale = Math.pow( 2, lvl );
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var caches = rs.imgCaches = rs.imgCaches || {};
  var eleCache = caches[lvl];

  if( eleCache ){
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if( eleScaledH <= minTxrH ){
    txrH = minTxrH;
  } else if( eleScaledH <= txrStepH ){
    txrH = txrStepH;
  } else {
    txrH = Math.ceil( eleScaledH / txrStepH ) * txrStepH;
  }

  if(
    eleScaledH > maxTxrH
    || eleScaledW > maxTxrW
    || ( !allowEdgeTxrCaching && ele.isEdge() )
    || ( !allowParentTxrCaching && ele.isParent() )
  ){
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue( txrH );

  // first try the second last one in case it has space at the end
  var txr = txrQ[ txrQ.length - 2 ];

  var addNewTxr = function(){
    return self.recycleTexture( txrH, eleScaledW ) || self.addTexture( txrH, eleScaledW );
  };

  // try the last one if there is no second last one
  if( !txr ){
    txr = txrQ[ txrQ.length - 1 ];
  }

  // if the last one doesn't exist, we need a first one
  if( !txr ){
    txr = addNewTxr();
  }

  // if there's no room in the current texture, we need a new one
  if( txr.width - txr.usedWidth < eleScaledW ){
    txr = addNewTxr();
  }

  var scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );
  var scalableFrom = function( otherCache ){
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;

  var higherCache; // the nearest cache with a higher level
  for( var l = lvl + 1; l <= maxLvl; l++ ){
    var c = caches[l];

    if( c ){ higherCache = c; break; }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function(){
    txr.context.drawImage(
      oneUpCache.texture.canvas,
      oneUpCache.x, 0,
      oneUpCache.width, oneUpCache.height,
      txr.usedWidth, 0,
      eleScaledW, eleScaledH
    );
  };

  if( scalableFrom(oneUpCache) ){
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();

  } else if( scalableFrom(higherCache) ){
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level

    if( highQualityReq ){
      for( var l = higherCache.level; l > lvl; l-- ){
        oneUpCache = self.getElement( ele, bb, pxRatio, l, getTxrReasons.downscale );
      }

      downscale();

    } else {
      self.queueElement( ele, bb, higherCache.level - 1 );

      return higherCache;
    }
  } else {

    var lowerCache; // the nearest cache with a lower level
    if( !deqing && !highQualityReq && !downscaleReq ){
      for( var l = lvl - 1; l >= minLvl; l-- ){
        var c = caches[l];

        if( c ){ lowerCache = c; break; }
      }
    }

    if( scalableFrom(lowerCache) ){
      // then use the lower quality cache for now and queue the better one for later

      self.queueElement( ele, bb, lvl );

      return lowerCache;
    }

    txr.context.translate( txr.usedWidth, 0 );
    txr.context.scale( scale, scale );

    r.drawElement( txr.context, ele, bb, scaledLabelShown );

    txr.context.scale( 1/scale, 1/scale );
    txr.context.translate( -txr.usedWidth, 0 );
  }

  eleCache = caches[lvl] = {
    ele: ele,
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };

  txr.usedWidth += Math.ceil( eleScaledW + eleTxrSpacing );

  txr.eleCaches.push( eleCache );

  self.checkTextureFullness( txr );

  return eleCache;
};

ETCp.invalidateElement = function( ele ){
  var self = this;
  var caches = ele._private.rscratch.imgCaches;

  if( caches ){
    for( var lvl = minLvl; lvl <= maxLvl; lvl++ ){
      var cache = caches[ lvl ];

      if( cache ){
        var txr = cache.texture;

        // remove space from the texture it belongs to
        txr.invalidatedWidth += cache.width;

        // remove refs with the element
        caches[ lvl ] = null;
        util.removeFromArray( txr.eleCaches, cache );

        // might have to remove the entire texture if it's not efficiently using its space
        self.checkTextureUtility( txr );
      }
    }
  }
};

ETCp.checkTextureUtility = function( txr ){
  // invalidate all entries in the cache if the cache size is small
  if( txr.invalidatedWidth >= minUtility * txr.width ){
    this.retireTexture( txr );
  }
};

ETCp.checkTextureFullness = function( txr ){
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things

  var self = this;
  var txrQ = self.getTextureQueue( txr.height );

  if( txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks ){
    util.removeFromArray( txrQ, txr );
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function( txr ){
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue( txrH );

  // retire the texture from the active / searchable queue:

  util.removeFromArray( txrQ, txr );

  txr.retired = true;

  // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for( var i = 0; i < eleCaches.length; i++ ){
    var eleCache = eleCaches[i];
    var ele = eleCache.ele;
    var lvl = eleCache.level;
    var imgCaches = ele._private.rscratch.imgCaches;

    if( imgCaches ){
      imgCaches[ lvl ] = null;
    }
  }

  util.clearArray( eleCaches );

  // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  rtxtrQ.push( txr );
};

ETCp.addTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var txr = {};

  txrQ.push( txr );

  txr.eleCaches = [];

  txr.height = txrH;
  txr.width = Math.max( defTxrWidth, minW );
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;

  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  txr.canvas.width = txr.width;
  txr.canvas.height = txr.height;

  txr.context = txr.canvas.getContext('2d');

  return txr;
};

ETCp.recycleTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  for( var i = 0; i < rtxtrQ.length; i++ ){
    var txr = rtxtrQ[i];

    if( txr.width >= minW ){
      txr.retired = false;

      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;

      util.clearArray( txr.eleCaches );

      txr.context.clearRect( 0, 0, txr.width, txr.height );

      util.removeFromArray( rtxtrQ, txr );
      txrQ.push( txr );

      return txr;
    }
  }
};

ETCp.queueElement = function( ele, bb, lvl ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var id = ele.id();
  var existingReq = id2q[ id ];

  if( existingReq ){ // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max( existingReq.level, lvl );
    existingReq.reqs++;

    q.updateItem( existingReq );
  } else {
    var req = {
      ele: ele,
      bb: bb,
      position: math.copyPosition( ele.position() ),
      level: lvl,
      reqs: 1
    };

    if( ele.isEdge() ){
      req.positions = {
        source: math.copyPosition( ele.source().position() ),
        target: math.copyPosition( ele.target().position() )
      };
    }

    q.push( req );

    id2q[ id ] = req;
  }
};

ETCp.dequeue = function( pxRatio, extent ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var dequeued = [];

  for( var i = 0; i < maxDeqSize; i++ ){
    if( q.size() > 0 ){
      var req = q.pop();

      id2q[ req.ele.id() ] = null;

      dequeued.push( req );

      var ele = req.ele;
      var bb;

      if(
        ( ele.isEdge()
          && (
            !math.arePositionsSame( ele.source().position(), req.positions.source )
            || !math.arePositionsSame( ele.target().position(), req.positions.target )
          )
        )
        || ( !math.arePositionsSame( ele.position(), req.position ) )
      ){
        bb = ele.boundingBox();
      } else {
        bb = req.bb;
      }

      self.getElement( req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue );
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.onDequeue = function( fn ){ this.onDequeues.push( fn ); };
ETCp.offDequeue = function( fn ){ util.removeFromArray( this.onDequeues, fn ); };

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio, extent ){
    return self.dequeue( pxRatio, extent );
  },
  onDeqd: function( self, deqd ){
    for( var i = 0; i < self.onDequeues.length; i++ ){
      var fn = self.onDequeues[i];

      fn( deqd );
    }
  },
  shouldRedraw: function( self, deqd, pxRatio, extent ){
    for( var i = 0; i < deqd.length; i++ ){
      var bb = deqd[i].bb;

      if( math.boundingBoxesIntersect( bb, extent ) ){
        return true;
      }
    }

    return false;
  },
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

module.exports = ElementTextureCache;

},{"../../../heap":84,"../../../math":88,"../../../util":103,"./texture-cache-defs":80}],76:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );

var CRp = {};

CRp.createBuffer = function( w, h ){
  var buffer = document.createElement( 'canvas' ); // eslint-disable-line no-undef
  buffer.width = w;
  buffer.height = h;

  return [ buffer, buffer.getContext( '2d' ) ];
};

CRp.bufferCanvasImage = function( options ){
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil( bb.w ) : ctrRect[2];
  var height = options.full ? Math.ceil( bb.h ) : ctrRect[3];
  var specdMaxDims = is.number( options.maxWidth ) || is.number( options.maxHeight );
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if( options.scale !== undefined ){
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if( specdMaxDims ){
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if( is.number( options.maxWidth ) ){
      maxScaleW = scale * options.maxWidth / width;
    }

    if( is.number( options.maxHeight ) ){
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min( maxScaleW, maxScaleH );

    width *= scale;
    height *= scale;
  }

  if( !specdMaxDims ){
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement( 'canvas' ); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext( '2d' );

  // Rasterize the layers, but only if container has nonzero size
  if( width > 0 && height > 0 ){

    buffCxt.clearRect( 0, 0, width, height );

    if( options.bg ){
      buffCxt.fillStyle = options.bg;
      buffCxt.rect( 0, 0, width, height );
      buffCxt.fill();
    }

    buffCxt.globalCompositeOperation = 'source-over';

    var zsortedEles = this.getCachedZSortedEles();

    if( options.full ){ // draw the full bounds of the graph
      buffCxt.translate( -bb.x1 * scale, -bb.y1 * scale );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    } else { // draw the current view
      var pan = cy.pan();

      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };

      scale *= cy.zoom();

      buffCxt.translate( translation.x, translation.y );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    }
  }

  return buffCanvas;
};

function b64ToBlob( b64, mimeType ){
  var bytes = atob( b64 );
  var buff = new ArrayBuffer( bytes.length );
  var buffUint8 = new Uint8Array( buff );

  for( var i = 0; i < bytes.length; i++ ){
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob( [buff], { type: mimeType } );
}

function b64UriToB64( b64uri ){
  var i = b64uri.indexOf(',');

  return b64uri.substr( i + 1 );
};

function output( options, canvas, mimeType ){
  var b64Uri = canvas.toDataURL( mimeType, options.quality );

  switch( options.output ){
    case 'blob':
      return b64ToBlob( b64UriToB64( b64Uri ), mimeType );

    case 'base64':
      return b64UriToB64( b64Uri );

    case 'base64uri':
    default:
      return b64Uri;
  }
}

CRp.png = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/png' );
};

CRp.jpg = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/jpeg' );
};

module.exports = CRp;

},{"../../../is":86}],77:[function(require,module,exports){
/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

'use strict';

var util = require( '../../../util' );
var is = require( '../../../is' );
var ElementTextureCache = require('./ele-texture-cache');
var LayeredTextureCache = require('./layered-texture-cache');

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer( options ){
  var r = this;

  r.data = {
    canvases: new Array( CRp.CANVAS_LAYERS ),
    contexts: new Array( CRp.CANVAS_LAYERS ),
    canvasNeedsRedraw: new Array( CRp.CANVAS_LAYERS ),

    bufferCanvases: new Array( CRp.BUFFER_COUNT ),
    bufferContexts: new Array( CRp.CANVAS_LAYERS ),
  };

  r.data.canvasContainer = document.createElement( 'div' ); // eslint-disable-line no-undef
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute( 'style', '-webkit-tap-highlight-color: rgba(0,0,0,0);' );
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild( r.data.canvasContainer );
  container.setAttribute( 'style', ( container.getAttribute( 'style' ) || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);' );

  for( var i = 0; i < CRp.CANVAS_LAYERS; i++ ){
    var canvas = r.data.canvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.contexts[ i ] = canvas.getContext( '2d' );
    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
    canvas.style.position = 'absolute';
    canvas.setAttribute( 'data-id', 'layer' + i );
    canvas.style.zIndex = String( CRp.CANVAS_LAYERS - i );
    r.data.canvasContainer.appendChild( canvas );

    r.data.canvasNeedsRedraw[ i ] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[ CRp.NODE ].setAttribute( 'data-id', 'layer' + CRp.NODE + '-node' );
  r.data.canvases[ CRp.SELECT_BOX ].setAttribute( 'data-id', 'layer' + CRp.SELECT_BOX + '-selectbox' );
  r.data.canvases[ CRp.DRAG ].setAttribute( 'data-id', 'layer' + CRp.DRAG + '-drag' );

  for( var i = 0; i < CRp.BUFFER_COUNT; i++ ){
    r.data.bufferCanvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.bufferContexts[ i ] = r.data.bufferCanvases[ i ].getContext( '2d' );
    r.data.bufferCanvases[ i ].style.position = 'absolute';
    r.data.bufferCanvases[ i ].setAttribute( 'data-id', 'buffer' + i );
    r.data.bufferCanvases[ i ].style.zIndex = String( -i - 1 );
    r.data.bufferCanvases[ i ].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;

  r.data.eleTxrCache = new ElementTextureCache( r );
  r.data.lyrTxrCache = new LayeredTextureCache( r, r.data.eleTxrCache );

  r.onUpdateEleCalcs(function invalidateTextureCaches( willDraw, eles ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var rs = ele._private.rstyle;
      var de = rs.dirtyEvents;

      if( ele.isNode() && de && de.length === 1 && de['position'] ){
        // then keep cached ele texture
      } else {
        r.data.eleTxrCache.invalidateElement( ele );
      }
    }

    if( eles.length > 0 ){
      r.data.lyrTxrCache.invalidateElements( eles );
    }
  });
}

CRp.redrawHint = function( group, bool ){
  var r = this;

  switch( group ){
    case 'eles':
      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function( on ){
  if( on === undefined ){
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function(){
  return pathsImpld && this.pathsEnabled;
};

[
  require( './arrow-shapes' ),
  require( './drawing-elements' ),
  require( './drawing-edges' ),
  require( './drawing-images' ),
  require( './drawing-label-text' ),
  require( './drawing-nodes' ),
  require( './drawing-redraw' ),
  require( './drawing-shapes' ),
  require( './export-image' ),
  require( './node-shapes' )
].forEach( function( props ){
  util.extend( CRp, props );
} );

module.exports = CR;

},{"../../../is":86,"../../../util":103,"./arrow-shapes":67,"./drawing-edges":68,"./drawing-elements":69,"./drawing-images":70,"./drawing-label-text":71,"./drawing-nodes":72,"./drawing-redraw":73,"./drawing-shapes":74,"./ele-texture-cache":75,"./export-image":76,"./layered-texture-cache":78,"./node-shapes":79}],78:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );
var math = require( '../../../math' );
var Heap = require( '../../../heap' );
var is = require( '../../../is' );
var defs = require( './texture-cache-defs' );

var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function( renderer, eleTxrCache ){
  var self = this;

  var r = self.renderer = renderer;

  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;

  self.lastInvalidationTime = util.performanceNow() - 2*invalidThreshold;

  self.skipping = false;

  r.beforeRender(function( willDraw, now ){
    if( now - self.lastInvalidationTime <= invalidThreshold ){
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  });

  var qSort = function(a, b){
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap( qSort );

  self.eleTxrCache = eleTxrCache;

  self.setupEleCacheInvalidation();

  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;

var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;

LTCp.makeLayer = function( bb, lvl ){
  var scale = Math.pow( 2, lvl );

  var w = Math.ceil( bb.w * scale );
  var h = Math.ceil( bb.h * scale );

  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

  canvas.width = w;
  canvas.height = h;

  var layer = {
    id: (layerIdPool = ++layerIdPool % MAX_INT ),
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  };

  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;

  // do the transform on creation to save cycles (it's the same for all eles)
  cxt.scale( scale, scale );
  cxt.translate( dx, dy );

  return layer;
};

LTCp.getLayers = function( eles, pxRatio, lvl ){
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;

  self.firstGet = false;

  // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );

    if( lvl < minLvl ){
      lvl = minLvl;
    } else if( zoom >= maxZoom || lvl > maxLvl ){
      return null;
    }
  }

  self.validateLayersElesOrdering( lvl, eles );

  var layersByLvl = self.layersByLevel;
  var scale = Math.pow( 2, lvl );
  var layers = layersByLvl[ lvl ] = layersByLvl[ lvl ] || [];
  var bb;

  var lvlComplete = self.levelIsComplete( lvl, eles );
  var tmpLayers;

  var checkTempLevels = function(){
    var canUseAsTmpLvl = function( l ){
      self.validateLayersElesOrdering( l, eles );

      if( self.levelIsComplete( l, eles ) ){
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function( dir ){
      if( tmpLayers ){ return; }

      for( var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir ){
        if( canUseAsTmpLvl(l) ){ break; }
      }
    };

    checkLvls( +1 );
    checkLvls( -1 );

    // remove the invalid layers; they will be replaced as needed later in this function
    for( var i = layers.length - 1; i >= 0; i-- ){
      var layer = layers[i];

      if( layer.invalid ){
        util.removeFromArray( layers, layer );
      }
    }
  };

  if( !lvlComplete ){
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon

    checkTempLevels();

  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function(){
    if( !bb ){
      bb = math.makeBoundingBox();

      for( var i = 0; i < eles.length; i++ ){
        math.updateBoundingBox( bb, eles[i].boundingBox() );
      }
    }

    return bb;
  };

  var makeLayer = function( opts ){
    opts = opts || {};

    var after = opts.after;

    getBb();

    var area = ( bb.w * scale ) * ( bb.h * scale );

    if( area > maxLayerArea ){
      return null;
    }

    var layer = self.makeLayer( bb, lvl );

    if( after != null ){
      var index = layers.indexOf( after ) + 1;

      layers.splice( index, 0, layer );
    } else if( opts.insert === undefined || opts.insert ){
      // no after specified => first layer made so put at start
      layers.unshift( layer );
    }

    // if( tmpLayers ){
      //self.queueLayer( layer );
    // }

    return layer;
  };

  if( self.skipping && !firstGet ){
    // log('skip layers');
    return null;
  }

  // log('do layers');

  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = alwaysQueue && !firstGet;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    // log('look at ele', ele.id());

    var existingLayer = caches[ lvl ];

    if( existingLayer ){
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if(
      !layer
      || layer.eles.length >= maxElesPerLayer
      || !math.boundingBoxInBoundingBox( layer.bb, ele.boundingBox() )
    ){
      // log('make new layer for ele %s', ele.id());

      layer = makeLayer({ insert: true, after: layer });

      // if now layer can be built then we can't use layers at this level
      if( !layer ){ return null; }

      // log('new layer with id %s', layer.id);
    }

    if( tmpLayers || allowLazyQueueing ){
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer( layer, ele );
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer( layer, ele, lvl, pxRatio );
    }

    layer.eles.push( ele );

    caches[ lvl ] = layer;
  }

  // log('--');

  if( tmpLayers ){ // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if( allowLazyQueueing ){
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
};

// a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function( lvl, pxRatio ){
  return lvl;
};

function imgSmoothing( context, bool ){
  if( context.imageSmoothingEnabled != null ){
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
}

LTCp.drawEleInLayer = function( layer, ele, lvl, pxRatio ){
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  var eleCache = self.eleTxrCache;
  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

  lvl = self.getEleLevelForLayerLevel( lvl, pxRatio );

  var cache = useEleTxrCaching ? eleCache.getElement( ele, bb, null, lvl, reason ) : null;

  if( cache ){
    if( disableEleImgSmoothing ){ imgSmoothing( context, false ); }

    context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );

    if( disableEleImgSmoothing ){ imgSmoothing( context, true ); }
  } else { // if the element is not cacheable, then draw directly
    r.drawElement( context, ele );
  }
};

LTCp.levelIsComplete = function( lvl, eles ){
  var self = this;
  var layers = self.layersByLevel[ lvl ];

  if( !layers || layers.length === 0 ){ return false; }

  var numElesInLayers = 0;

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];

    // if there are any eles needed to be drawn yet, the level is not complete
    if( layer.reqs > 0 ){ return false; }

    // if the layer is invalid, the level is not complete
    if( layer.invalid ){ return false; }

    numElesInLayers += layer.eles.length;
  }

  // we should have exactly the number of eles passed in to be complete
  if( numElesInLayers !== eles.length ){ return false; }

  return true;
};

LTCp.validateLayersElesOrdering = function( lvl, eles ){
  var layers = this.layersByLevel[ lvl ];

  if( !layers ){ return; }

  // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];
    var offset = -1;

    // find the offset
    for( var j = 0; j < eles.length; j++ ){
      if( layer.eles[0] === eles[j] ){
        offset = j;
        break;
      }
    }

    if( offset < 0 ){
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer( layer );
      continue;
    }

    // the eles in the layer must be in the same continuous order, else the layer is invalid

    var o = offset;

    for( var j = 0; j < layer.eles.length; j++ ){
      if( layer.eles[j] !== eles[o+j] ){
        // log('invalidate based on ordering', layer.id);

        this.invalidateLayer( layer );
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function( eles, update ){
  var self = this;
  var isEles = is.element( eles[0] );

  // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way
  for( var i = 0; i < eles.length; i++ ){
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for( var l = minLvl; l <= maxLvl; l++ ){
      var layer = caches[l];

      if( !layer ){ continue; }

      // if update is a request from the ele cache, then it affects only
      // the matching level
      if( req && self.getEleLevelForLayerLevel( layer.level ) !== req.level ){
        continue;
      }

      update( layer, ele, req );
    }
  }
};

LTCp.haveLayers = function(){
  var self = this;
  var haveLayers = false;

  for( var l = minLvl; l <= maxLvl; l++ ){
    var layers = self.layersByLevel[l];

    if( layers && layers.length > 0 ){
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function( eles ){
  var self = this;

  self.lastInvalidationTime = util.performanceNow();

  // log('update invalidate layer time from eles');

  if( eles.length === 0 || !self.haveLayers() ){ return; }

  self.updateElementsInLayers( eles, function invalAssocLayers( layer, ele, req ){
    self.invalidateLayer( layer );
  } );
};

LTCp.invalidateLayer = function( layer ){
  // log('update invalidate layer time');

  this.lastInvalidationTime = util.performanceNow();

  if( layer.invalid ){ return; } // save cycles

  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[ lvl ];

   // log('invalidate layer', layer.id );

  util.removeFromArray( layers, layer );
  // layer.eles = [];

  layer.elesQueue = [];

  layer.invalid = true;

  if( layer.replacement ){
    layer.replacement.invalid = true;
  }

  for( var i = 0; i < eles.length; i++ ){
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if( caches ){
      caches[ lvl ] = null;
    }
  }
};

LTCp.refineElementTextures = function( eles ){
  var self = this;

  // log('refine', eles.length);

  self.updateElementsInLayers( eles, function refineEachEle( layer, ele, req ){
    var rLyr = layer.replacement;

    if( !rLyr ){
      rLyr = layer.replacement = self.makeLayer( layer.bb, layer.level );
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;

       // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if( !rLyr.reqs ){
      for( var i = 0; i < rLyr.eles.length; i++ ){
        self.queueLayer( rLyr, rLyr.eles[i] );
      }

       // log('queue replacement layer refinement', rLyr.id);
    }
  } );
};

LTCp.setupEleCacheInvalidation = function(){
  var self = this;
  var eleDeqs = [];

  if( !useEleTxrCaching ){ return; }

  var updatedElesInLayers = util.debounce( function(){
    self.refineElementTextures( eleDeqs );

    eleDeqs = [];
  }, refineEleDebounceTime );

  self.eleTxrCache.onDequeue(function( reqs ){
    for( var i = 0; i < reqs.length; i++ ){
      eleDeqs.push( reqs[i] );
    }

    updatedElesInLayers();
  });
};

LTCp.queueLayer = function( layer, ele ){
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};

  // if a layer is going to be replaced, queuing is a waste of time
  if( layer.replacement ){ return; }

  if( ele ){
    if( hasId[ ele.id() ] ){
      return;
    }

    elesQ.push( ele );
    hasId[ ele.id() ] = true;
  }

  if( layer.reqs ){
    layer.reqs++;

    q.updateItem( layer );
  } else {
    layer.reqs = 1;

    q.push( layer );
  }
};

LTCp.dequeue = function( pxRatio ){
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while( eleDeqs < maxDeqSize ){
    if( q.size() === 0 ){ break; }

    var layer = q.peek();

    // if a layer has been or will be replaced, then don't waste time with it
    if( layer.replacement ){
       // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    }

    // if this is a replacement layer that has been superceded, then forget it
    if( layer.replaces && layer !== layer.replaces.replacement ){
       // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if( layer.invalid ){
       // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if( ele ){
       // log('dequeue layer %s', layer.id);

      self.drawEleInLayer( layer, ele, layer.level, pxRatio );

      eleDeqs++;
    }

    if( deqd.length === 0 ){
      // we need only one entry in deqd to queue redrawing etc
      deqd.push( true );
    }

    // if the layer has all its eles done, then remove from the queue
    if( layer.elesQueue.length === 0 ){
      q.pop();

      layer.reqs = 0;

       // log('dequeue of layer %s complete', layer.id);

      // when a replacement layer is dequeued, it replaces the old layer in the level
      if( layer.replaces ){
        self.applyLayerReplacement( layer );
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function( layer ){
  var self = this;
  var layersInLevel = self.layersByLevel[ layer.level ];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf( replaced );

  // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)
  if( index < 0 || replaced.invalid ){
     // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[ index ] = layer; // replace level ref

  // replace refs in eles
  for( var i = 0; i < layer.eles.length; i++ ){
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if( cache ){
      cache[ layer.level ] = layer;
    }
  }

   // log('apply replacement layer %s over %s', layer.id, replaced.id);

  self.requestRedraw();
};

LTCp.requestRedraw = util.debounce( function(){
  var r = this.renderer;

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );
  r.redraw();
}, 100 );

LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio ){
    return self.dequeue( pxRatio );
  },
  onDeqd: util.noop,
  shouldRedraw: util.trueify,
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

module.exports = LayeredTextureCache;

},{"../../../heap":84,"../../../is":86,"../../../math":88,"../../../util":103,"./texture-cache-defs":80}],79:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.nodeShapeImpl = function( name, context, centerX, centerY, width, height, points ){
  switch( name ){
    case 'ellipse':
      return this.drawEllipsePath( context, centerX, centerY, width, height );
    case 'polygon':
      return this.drawPolygonPath( context, centerX, centerY, width, height, points );
    case 'roundrectangle':
      return this.drawRoundRectanglePath( context, centerX, centerY, width, height );
  }
};

module.exports = CRp;

},{}],80:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );

var fullFpsTime = 1000/60; // assume 60 frames per second

module.exports = {
  setupDequeueing: function( opts ){
    return function setupDequeueingImpl(){
      var self = this;
      var r = this.renderer;

      if( self.dequeueingSetup ){
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util.debounce( function(){
        r.redrawHint( 'eles', true );
        r.redrawHint( 'drag', true );

        r.redraw();
      }, opts.deqRedrawThreshold );

      var dequeue = function( willDraw, frameStartTime ){
        var startTime = util.performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio();

        while( true ){
          var now = util.performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if( renderTime < fullFpsTime ){
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time

            var timeAvailable = fullFpsTime - ( willDraw ? avgRenderTime : 0 );

            if( frameDuration >= opts.deqFastCost * timeAvailable ){
              break;
            }
          } else {
            if( willDraw ){
              if(
                   duration >= opts.deqCost * renderTime
                || duration >= opts.deqAvgCost * avgRenderTime
              ){
                break;
              }
            } else if( frameDuration >= opts.deqNoDrawCost * fullFpsTime ){
              break;
            }
          }

          var thisDeqd = opts.deq( self, pixelRatio, extent );

          if( thisDeqd.length > 0 ){
            for( var i = 0; i < thisDeqd.length; i++ ){
              deqd.push( thisDeqd[i] );
            }
          } else {
            break;
          }
        }

        // callbacks on dequeue
        if( deqd.length > 0 ){
          opts.onDeqd( self, deqd );

          if( !willDraw && opts.shouldRedraw( self, deqd, pixelRatio, extent ) ){
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || util.noop;

      r.beforeRender( dequeue, priority( self ) );
    };
  }
};

},{"../../../util":103}],81:[function(require,module,exports){
'use strict';

module.exports = [
  { name: 'null', impl: require( './null' ) },
  { name: 'base', impl: require( './base' ) },
  { name: 'canvas', impl: require( './canvas' ) }
];

},{"./base":63,"./canvas":77,"./null":82}],82:[function(require,module,exports){
'use strict';

function NullRenderer( options ){
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function(){};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function(){ this.notifications++; },
  init: noop
};

module.exports = NullRenderer;

},{}],83:[function(require,module,exports){
/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */

'use strict';

var is = require('./is');
var util = require('./util');
var Thread = require('./thread');
var Promise = require('./promise');
var define = require('./define');

var Fabric = function( N ){
  if( !(this instanceof Fabric) ){
    return new Fabric( N );
  }

  this._private = {
    pass: []
  };

  var defN = 4;

  if( is.number(N) ){
    // then use the specified number of threads
  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
    N = navigator.hardwareConcurrency;
  } else {
    try{
      N = require('os').cpus().length;
    } catch( err ){
      N = defN;
    }
  } // TODO could use an estimation here but would the additional expense be worth it?

  for( var i = 0; i < N; i++ ){
    this[i] = new Thread();
  }

  this.length = N;
};

var fabfn = Fabric.prototype; // short alias

util.extend(fabfn, {

  instanceString: function(){ return 'fabric'; },

  // require fn in all threads
  require: function( fn, as ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.require( fn, as );
    }

    return this;
  },

  // get a random thread
  random: function(){
    var i = Math.round( (this.length - 1) * Math.random() );
    var thread = this[i];

    return thread;
  },

  // run on random thread
  run: function( fn ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass ).run( fn );
  },

  // sends a random thread a message
  message: function( m ){
    return this.random().message( m );
  },

  // send all threads a message
  broadcast: function( m ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.message( m );
    }

    return this; // chaining
  },

  // stop all threads
  stop: function(){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.stop();
    }

    return this; // chaining
  },

  // pass data to be used with .spread() etc.
  pass: function( data ){
    var pass = this._private.pass;

    if( is.array(data) ){
      pass.push( data );
    } else {
      throw 'Only arrays may be used with fabric.pass()';
    }

    return this; // chaining
  },

  spreadSize: function(){
    var subsize =  Math.ceil( this._private.pass[0].length / this.length );

    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

    return subsize;
  },

  // split the data into slices to spread the data equally among threads
  spread: function( fn ){
    var self = this;
    var _p = self._private;
    var subsize = self.spreadSize(); // number of pass eles to handle in each thread
    var pass = _p.pass.shift().concat([]); // keep a copy
    var runPs = [];

    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];
      var slice = pass.splice( 0, subsize );

      var runP = thread.pass( slice ).run( fn );

      runPs.push( runP );

      var doneEarly = pass.length === 0;
      if( doneEarly ){ break; }
    }

    return Promise.all( runPs ).then(function( thens ){
      var postpass = [];
      var p = 0;

      // fill postpass with the total result joined from all threads
      for( var i = 0; i < thens.length; i++ ){
        var then = thens[i]; // array result from thread i

        for( var j = 0; j < then.length; j++ ){
          var t = then[j]; // array element

          postpass[ p++ ] = t;
        }
      }

      return postpass;
    });
  },

  // parallel version of array.map()
  map: function( fn ){
    var self = this;

    self.require( fn, '_$_$_fabmap' );

    return self.spread(function( split ){
      var mapped = [];
      var origResolve = resolve; // jshint ignore:line

      resolve = function( val ){ // jshint ignore:line
        mapped.push( val );
      };

      for( var i = 0; i < split.length; i++ ){
        var oldLen = mapped.length;
        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line
        var nothingInsdByResolve = oldLen === mapped.length;

        if( nothingInsdByResolve ){
          mapped.push( ret );
        }
      }

      resolve = origResolve; // jshint ignore:line

      return mapped;
    });

  },

  // parallel version of array.filter()
  filter: function( fn ){
    var _p = this._private;
    var pass = _p.pass[0];

    return this.map( fn ).then(function( include ){
      var ret = [];

      for( var i = 0; i < pass.length; i++ ){
        var datum = pass[i];
        var incDatum = include[i];

        if( incDatum ){
          ret.push( datum );
        }
      }

      return ret;
    });
  },

  // sorts the passed array using a divide and conquer strategy
  sort: function( cmp ){
    var self = this;
    var P = this._private.pass[0].length;
    var subsize = this.spreadSize();

    cmp = cmp || function( a, b ){ // default comparison function
      if( a < b ){
        return -1;
      } else if( a > b ){
        return 1;
      }

      return 0;
    };

    self.require( cmp, '_$_$_cmp' );

    return self.spread(function( split ){ // sort each split normally
      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line
      resolve( sortedSplit ); // jshint ignore:line

    }).then(function( joined ){
      // do all the merging in the main thread to minimise data transfer

      // TODO could do merging in separate threads but would incur add'l cost of data transfer
      // for each level of the merge

      var merge = function( i, j, max ){
        // don't overflow array
        j = Math.min( j, P );
        max = Math.min( max, P );

        // left and right sides of merge
        var l = i;
        var r = j;

        var sorted = [];

        for( var k = l; k < max; k++ ){

          var eleI = joined[i];
          var eleJ = joined[j];

          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
            sorted.push( eleI );
            i++;
          } else {
            sorted.push( eleJ );
            j++;
          }

        }

        // in the array proper, put the sorted values
        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
          var index = l + k;

          joined[ index ] = sorted[k];
        }
      };

      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

        for( var i = 0; i < P; i += 2*splitL ){
          merge( i, i + splitL, i + 2*splitL );
        }

      }

      return joined;
    });
  }


});

var defineRandomPasser = function( opts ){
  opts = opts || {};

  return function( fn, arg1 ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
  };
};

util.extend(fabfn, {
  randomMap: defineRandomPasser({ threadFn: 'map' }),

  reduce: defineRandomPasser({ threadFn: 'reduce' }),

  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
});

// aliases
var fn = fabfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(fabfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( fabfn );

module.exports = Fabric;

},{"./define":47,"./is":86,"./promise":89,"./thread":101,"./util":103,"os":113}],84:[function(require,module,exports){
/*!
Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;

PSF LICENSE AGREEMENT FOR PYTHON 2.7.2

1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
*/

'use strict';
// Generated by CoffeeScript 1.8.0

var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

floor = Math.floor, min = Math.min;


/*
Default comparison function to be used
 */

defaultCmp = function( x, y ){
  if( x < y ){
    return -1;
  }
  if( x > y ){
    return 1;
  }
  return 0;
};


/*
Insert item x in list a, and keep it sorted assuming a is sorted.

If x is already in a, insert it to the right of the rightmost x.

Optional args lo (default 0) and hi (default a.length) bound the slice
of a to be searched.
 */

insort = function( a, x, lo, hi, cmp ){
  var mid;
  if( lo == null ){
    lo = 0;
  }
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( lo < 0 ){
    throw new Error( 'lo must be non-negative' );
  }
  if( hi == null ){
    hi = a.length;
  }
  while( lo < hi ){
    mid = floor( (lo + hi) / 2 );
    if( cmp( x, a[ mid ] ) < 0 ){
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return ([].splice.apply( a, [ lo, lo - lo ].concat( x ) ), x);
};


/*
Push item onto heap, maintaining the heap invariant.
 */

heappush = function( array, item, cmp ){
  if( cmp == null ){
    cmp = defaultCmp;
  }
  array.push( item );
  return _siftdown( array, 0, array.length - 1, cmp );
};


/*
Pop the smallest item off the heap, maintaining the heap invariant.
 */

heappop = function( array, cmp ){
  var lastelt, returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if( array.length ){
    returnitem = array[0];
    array[0] = lastelt;
    _siftup( array, 0, cmp );
  } else {
    returnitem = lastelt;
  }
  return returnitem;
};


/*
Pop and return the current smallest value, and add the new item.

This is more efficient than heappop() followed by heappush(), and can be
more appropriate when using a fixed size heap. Note that the value
returned may be larger than item! That constrains reasonable use of
this routine unless written as part of a conditional replacement:
    if item > array[0]
      item = heapreplace(array, item)
 */

heapreplace = function( array, item, cmp ){
  var returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup( array, 0, cmp );
  return returnitem;
};


/*
Fast version of a heappush followed by a heappop.
 */

heappushpop = function( array, item, cmp ){
  var _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( array.length && cmp( array[0], item ) < 0 ){
    _ref = [ array[0], item ], item = _ref[0], array[0] = _ref[1];
    _siftup( array, 0, cmp );
  }
  return item;
};


/*
Transform list into a heap, in-place, in O(array.length) time.
 */

heapify = function( array, cmp ){
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  _ref1 = (function(){
    _results1 = [];
    for( var _j = 0, _ref = floor( array.length / 2 ); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j-- ){ _results1.push( _j ); }
    return _results1;
  }).apply( this ).reverse();
  _results = [];
  for( _i = 0, _len = _ref1.length; _i < _len; _i++ ){
    i = _ref1[ _i ];
    _results.push( _siftup( array, i, cmp ) );
  }
  return _results;
};


/*
Update the position of the given item in the heap.
This function should be called every time the item is being modified.
 */

updateItem = function( array, item, cmp ){
  var pos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  pos = array.indexOf( item );
  if( pos === -1 ){
    return;
  }
  _siftdown( array, 0, pos, cmp );
  return _siftup( array, pos, cmp );
};


/*
Find the n largest elements in a dataset.
 */

nlargest = function( array, n, cmp ){
  var elem, result, _i, _len, _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  result = array.slice( 0, n );
  if( !result.length ){
    return result;
  }
  heapify( result, cmp );
  _ref = array.slice( n );
  for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
    elem = _ref[ _i ];
    heappushpop( result, elem, cmp );
  }
  return result.sort( cmp ).reverse();
};


/*
Find the n smallest elements in a dataset.
 */

nsmallest = function( array, n, cmp ){
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( n * 10 <= array.length ){
    result = array.slice( 0, n ).sort( cmp );
    if( !result.length ){
      return result;
    }
    los = result[ result.length - 1];
    _ref = array.slice( n );
    for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
      elem = _ref[ _i ];
      if( cmp( elem, los ) < 0 ){
        insort( result, elem, 0, null, cmp );
        result.pop();
        los = result[ result.length - 1];
      }
    }
    return result;
  }
  heapify( array, cmp );
  _results = [];
  for( i = _j = 0, _ref1 = min( n, array.length ); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j ){
    _results.push( heappop( array, cmp ) );
  }
  return _results;
};

_siftdown = function( array, startpos, pos, cmp ){
  var newitem, parent, parentpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  newitem = array[ pos ];
  while( pos > startpos ){
    parentpos = (pos - 1) >> 1;
    parent = array[ parentpos ];
    if( cmp( newitem, parent ) < 0 ){
      array[ pos ] = parent;
      pos = parentpos;
      continue;
    }
    break;
  }
  return array[ pos ] = newitem;
};

_siftup = function( array, pos, cmp ){
  var childpos, endpos, newitem, rightpos, startpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  endpos = array.length;
  startpos = pos;
  newitem = array[ pos ];
  childpos = 2 * pos + 1;
  while( childpos < endpos ){
    rightpos = childpos + 1;
    if( rightpos < endpos && !(cmp( array[ childpos ], array[ rightpos ] ) < 0) ){
      childpos = rightpos;
    }
    array[ pos ] = array[ childpos ];
    pos = childpos;
    childpos = 2 * pos + 1;
  }
  array[ pos ] = newitem;
  return _siftdown( array, startpos, pos, cmp );
};

Heap = (function(){
  Heap.push = heappush;

  Heap.pop = heappop;

  Heap.replace = heapreplace;

  Heap.pushpop = heappushpop;

  Heap.heapify = heapify;

  Heap.updateItem = updateItem;

  Heap.nlargest = nlargest;

  Heap.nsmallest = nsmallest;

  function Heap( cmp ){
    this.cmp = cmp != null ? cmp : defaultCmp;
    this.nodes = [];
  }

  Heap.prototype.push = function( x ){
    return heappush( this.nodes, x, this.cmp );
  };

  Heap.prototype.pop = function(){
    return heappop( this.nodes, this.cmp );
  };

  Heap.prototype.peek = function(){
    return this.nodes[0];
  };

  Heap.prototype.contains = function( x ){
    return this.nodes.indexOf( x ) !== -1;
  };

  Heap.prototype.replace = function( x ){
    return heapreplace( this.nodes, x, this.cmp );
  };

  Heap.prototype.pushpop = function( x ){
    return heappushpop( this.nodes, x, this.cmp );
  };

  Heap.prototype.heapify = function(){
    return heapify( this.nodes, this.cmp );
  };

  Heap.prototype.updateItem = function( x ){
    return updateItem( this.nodes, x, this.cmp );
  };

  Heap.prototype.clear = function(){
    return this.nodes = [];
  };

  Heap.prototype.empty = function(){
    return this.nodes.length === 0;
  };

  Heap.prototype.size = function(){
    return this.nodes.length;
  };

  Heap.prototype.clone = function(){
    var heap;
    heap = new Heap();
    heap.nodes = this.nodes.slice( 0 );
    return heap;
  };

  Heap.prototype.toArray = function(){
    return this.nodes.slice( 0 );
  };

  Heap.prototype.insert = Heap.prototype.push;

  Heap.prototype.top = Heap.prototype.peek;

  Heap.prototype.front = Heap.prototype.peek;

  Heap.prototype.has = Heap.prototype.contains;

  Heap.prototype.copy = Heap.prototype.clone;

  return Heap;

})();

module.exports = Heap;

},{}],85:[function(require,module,exports){
'use strict';

require('./-preamble');

var window = require( './window' );
var is = require( './is' );
var Core = require( './core' );
var extension = require( './extension' );
var registerJquery = require( './jquery-plugin' );
var Stylesheet = require( './stylesheet' );
var Thread = require( './thread' );
var Fabric = require( './fabric' );

var cytoscape = function( options ){ // jshint ignore:line
  // if no options specified, use default
  if( options === undefined ){
    options = {};
  }

  // create instance
  if( is.plainObject( options ) ){
    return new Core( options );
  }

  // allow for registration of extensions
  else if( is.string( options ) ){
    return extension.apply( extension, arguments );
  }
};

// replaced by build system
cytoscape.version = require('./version');

// try to register w/ jquery
if( window && window.jQuery ){
  registerJquery( window.jQuery, cytoscape );
}

// expose register api
cytoscape.registerJquery = function( jQuery ){
  registerJquery( jQuery, cytoscape );
};

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
cytoscape.thread = cytoscape.Thread = Thread;
cytoscape.fabric = cytoscape.Fabric = Fabric;

module.exports = cytoscape;

},{"./-preamble":4,"./core":40,"./extension":49,"./fabric":83,"./is":86,"./jquery-plugin":87,"./stylesheet":100,"./thread":101,"./version":109,"./window":110}],86:[function(require,module,exports){
'use strict';

/*global HTMLElement DocumentTouch */

var window = require( './window' );
var navigator = window ? window.navigator : null;
var document = window ? window.document : null;

var typeofstr = typeof '';
var typeofobj = typeof {};
var typeoffn = typeof function(){};
var typeofhtmlele = typeof HTMLElement;

var instanceStr = function( obj ){
  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
};

var is = {
  defined: function( obj ){
    return obj != null; // not undefined or null
  },

  string: function( obj ){
    return obj != null && typeof obj == typeofstr;
  },

  fn: function( obj ){
    return obj != null && typeof obj === typeoffn;
  },

  array: function( obj ){
    return Array.isArray ? Array.isArray( obj ) : obj != null && obj instanceof Array;
  },

  plainObject: function( obj ){
    return obj != null && typeof obj === typeofobj && !is.array( obj ) && obj.constructor === Object;
  },

  object: function( obj ){
    return obj != null && typeof obj === typeofobj;
  },

  number: function( obj ){
    return obj != null && typeof obj === typeof 1 && !isNaN( obj );
  },

  integer: function( obj ){
    return is.number( obj ) && Math.floor( obj ) === obj;
  },

  bool: function( obj ){
    return obj != null && typeof obj === typeof true;
  },

  htmlElement: function( obj ){
    if( 'undefined' === typeofhtmlele ){
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function( obj ){
    return is.element( obj ) || is.collection( obj );
  },

  element: function( obj ){
    return instanceStr( obj ) === 'collection' && obj._private.single;
  },

  collection: function( obj ){
    return instanceStr( obj ) === 'collection' && !obj._private.single;
  },

  core: function( obj ){
    return instanceStr( obj ) === 'core';
  },

  style: function( obj ){
    return instanceStr( obj ) === 'style';
  },

  stylesheet: function( obj ){
    return instanceStr( obj ) === 'stylesheet';
  },

  event: function( obj ){
    return instanceStr( obj ) === 'event';
  },

  thread: function( obj ){
    return instanceStr( obj ) === 'thread';
  },

  fabric: function( obj ){
    return instanceStr( obj ) === 'fabric';
  },

  emptyString: function( obj ){
    if( obj === undefined || obj === null ){ // null is empty
      return true;
    } else if( obj === '' || obj.match( /^\s+$/ ) ){
      return true; // empty string is empty
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function( obj ){
    if( obj && is.string( obj ) && obj !== '' && !obj.match( /^\s+$/ ) ){
      return true;
    }

    return false;
  },

  domElement: function( obj ){
    if( typeof HTMLElement === 'undefined' ){
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function( obj ){
    return is.plainObject( obj ) &&
      is.number( obj.x1 ) && is.number( obj.x2 ) &&
      is.number( obj.y1 ) && is.number( obj.y2 )
    ;
  },

  promise: function( obj ){
    return is.object( obj ) && is.fn( obj.then );
  },

  touch: function(){
    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
  },

  gecko: function(){
    return window && ( typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style) );
  },

  webkit: function(){
    return window && ( typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style) );
  },

  chromium: function(){
    return window && ( typeof chrome !== 'undefined' );
  },

  khtml: function(){
    return navigator && navigator.vendor.match( /kde/i ); // probably a better way to detect this...
  },

  khtmlEtc: function(){
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function(){
    return navigator && navigator.userAgent.match( /msie|trident|edge/i ); // probably a better way to detect this...
  },

  windows: function(){
    return navigator && navigator.appVersion.match( /Win/i );
  },

  mac: function(){
    return navigator && navigator.appVersion.match( /Mac/i );
  },

  linux: function(){
    return navigator && navigator.appVersion.match( /Linux/i );
  },

  unix: function(){
    return navigator && navigator.appVersion.match( /X11/i );
  }
};

module.exports = is;

},{"./window":110}],87:[function(require,module,exports){
'use strict';

var is = require( './is' );

var cyReg = function( $ele ){
  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

  return d;
};

var registerJquery = function( $, cytoscape ){
  if( !$ ){ return; } // no jquery => don't need this

  if( $.fn.cytoscape ){ return; } // already registered

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function( opts ){
    var $this = $( this );

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }

    // bind to ready
    else if( is.fn( opts ) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;

      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger( 'ready', [], ready );

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      }

    }

    // proxy to create instance
    else if( is.plainObject( opts ) ){
      return $this.each( function(){
        var options = $.extend( {}, opts, {
          container: $( this )[0]
        } );

        cytoscape( options );
      } );
    }
  };

  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;

  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
};

module.exports = registerJquery;

},{"./is":86}],88:[function(require,module,exports){
'use strict';

var math = {};

math.arePositionsSame = function( p1, p2 ){
  return p1.x === p2.x && p1.y === p2.y;
};

math.copyPosition = function( p ){
  return { x: p.x, y: p.y };
};

math.array2point = function( arr ){
  return {
    x: arr[0],
    y: arr[1]
  };
};

math.deg2rad = function( deg ){
  return Math.PI * deg / 180;
};

math.log2 = Math.log2 || function( n ){
  return Math.log( n ) / Math.log( 2 );
};

math.signum = function( x ){
  if( x > 0 ){
    return 1;
  } else if( x < 0 ){
    return -1;
  } else {
    return 0;
  }
};

math.dist = function( p1, p2 ){
  return Math.sqrt( math.sqdist( p1, p2 ) );
};

math.sqdist = function( p1, p2 ){
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx * dx + dy * dy;
};

// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
math.qbezierAt = function( p0, p1, p2, t ){
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};

math.qbezierPtAt = function( p0, p1, p2, t ){
  return {
    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
  };
};

math.lineAt = function( p0, p1, t, d ){
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };

  var vecDist = math.dist( p0, p1 );

  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };

  t = t == null ? 0 : t;

  var d = d != null ? d : t * vecDist;

  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};

math.lineAtDist = function( p0, p1, d ){
  return math.lineAt( p0, p1, undefined, d );
};

// get angle at A via cosine law
math.triangleAngle = function( A, B, C ){
  var a = math.dist( B, C );
  var b = math.dist( A, C );
  var c = math.dist( A, B );

  return Math.acos( (a*a + b*b - c*c)/(2*a*b) );
};

math.bound = function( min, val, max ){
  return Math.max( min, Math.min( max, val ) );
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function( bb ){
  if( bb == null ){
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if( bb.x1 != null && bb.y1 != null ){
    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.updateBoundingBox = function( bb1, bb2 ){
  // update bb1 with bb2 bounds

  bb1.x1 = Math.min( bb1.x1, bb2.x1 );
  bb1.x2 = Math.max( bb1.x2, bb2.x2 );
  bb1.w = bb1.x2 - bb1.x1;

  bb1.y1 = Math.min( bb1.y1, bb2.y1 );
  bb1.y2 = Math.max( bb1.y2, bb2.y2 );
  bb1.h = bb1.y2 - bb1.y1;
};

math.expandBoundingBox = function( bb, padding ){
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;

  return bb;
};

math.boundingBoxesIntersect = function( bb1, bb2 ){
  // case: one bb to right of other
  if( bb1.x1 > bb2.x2 ){ return false; }
  if( bb2.x1 > bb1.x2 ){ return false; }

  // case: one bb to left of other
  if( bb1.x2 < bb2.x1 ){ return false; }
  if( bb2.x2 < bb1.x1 ){ return false; }

  // case: one bb above other
  if( bb1.y2 < bb2.y1 ){ return false; }
  if( bb2.y2 < bb1.y1 ){ return false; }

  // case: one bb below other
  if( bb1.y1 > bb2.y2 ){ return false; }
  if( bb2.y1 > bb1.y2 ){ return false; }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function( bb, x, y ){
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function( bb, pt ){
  return this.inBoundingBox( bb, pt.x, pt.y );
};

math.boundingBoxInBoundingBox = function( bb1, bb2 ){
  return (
       math.inBoundingBox( bb1, bb2.x1, bb2.y1 )
    && math.inBoundingBox( bb1, bb2.x2, bb2.y2 )
  );
};

math.roundRectangleIntersectLine = function(
  x, y, nodeX, nodeY, width, height, padding ){

  var cornerRadius = this.getRoundRectangleRadius( width, height );

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topLeftCenterX, topLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= topLeftCenterX
      && arcIntersections[1] <= topLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topRightCenterX, topRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= topRightCenterX
      && arcIntersections[1] <= topRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= bottomRightCenterX
      && arcIntersections[1] >= bottomRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= bottomLeftCenterX
      && arcIntersections[1] >= bottomLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function( x, y, lx1, ly1, lx2, ly2, tolerance ){
  var t = tolerance;

  var x1 = Math.min( lx1, lx2 );
  var x2 = Math.max( lx1, lx2 );
  var y1 = Math.min( ly1, ly2 );
  var y2 = Math.max( ly1, ly2 );

  return x1 - t <= x && x <= x2 + t
    && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function(
  x, y, x1, y1, x2, y2, x3, y3, tolerance ){

  var bb = {
    x1: Math.min( x1, x3, x2 ) - tolerance,
    x2: Math.max( x1, x3, x2 ) + tolerance,
    y1: Math.min( y1, y3, y2 ) - tolerance,
    y2: Math.max( y1, y3, y2 ) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }

};

math.solveCubic = function( a, b, c, d, result ){

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant, q, r, dum1, s, t, term1, r13;

  q = (3.0 * c - (b * b)) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = (b / 3.0);

  if( discriminant > 0 ){
    s = r + Math.sqrt( discriminant );
    s = ((s < 0) ? -Math.pow( -s, (1.0 / 3.0) ) : Math.pow( s, (1.0 / 3.0) ));
    t = r - Math.sqrt( discriminant );
    t = ((t < 0) ? -Math.pow( -t, (1.0 / 3.0) ) : Math.pow( t, (1.0 / 3.0) ));
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt( 3.0 ) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if( discriminant === 0 ){
    r13 = ((r < 0) ? -Math.pow( -r, (1.0 / 3.0) ) : Math.pow( r, (1.0 / 3.0) ));
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos( r / Math.sqrt( dum1 ) );
  r13 = 2.0 * Math.sqrt( q );
  result[0] = -term1 + r13 * Math.cos( dum1 / 3.0 );
  result[2] = -term1 + r13 * Math.cos( (dum1 + 2.0 * Math.PI) / 3.0 );
  result[4] = -term1 + r13 * Math.cos( (dum1 + 4.0 * Math.PI) / 3.0 );

  return;
};

math.sqdistToQuadraticBezier = function(
  x, y, x1, y1, x2, y2, x3, y3 ){

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3
    + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3
    + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x
    + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x
    + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic( a, b, c, d, roots );

  var zeroThreshold = 0.0000001;

  var params = [];

  for( var index = 0; index < 6; index += 2 ){
    if( Math.abs( roots[ index + 1] ) < zeroThreshold
        && roots[ index ] >= 0
        && roots[ index ] <= 1.0 ){
      params.push( roots[ index ] );
    }
  }

  params.push( 1.0 );
  params.push( 0.0 );

  var minDistanceSquared = -1;
  var closestParam;

  var curX, curY, distSquared;
  for( var i = 0; i < params.length; i++ ){
    curX = Math.pow( 1.0 - params[ i ], 2.0 ) * x1
      + 2.0 * (1 - params[ i ]) * params[ i ] * x2
      + params[ i ] * params[ i ] * x3;

    curY = Math.pow( 1 - params[ i ], 2.0 ) * y1
      + 2 * (1.0 - params[ i ]) * params[ i ] * y2
      + params[ i ] * params[ i ] * y3;

    distSquared = Math.pow( curX - x, 2 ) + Math.pow( curY - y, 2 );
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if( minDistanceSquared >= 0 ){
      if( distSquared < minDistanceSquared ){
        minDistanceSquared = distSquared;
        closestParam = params[ i ];
      }
    } else {
      minDistanceSquared = distSquared;
      closestParam = params[ i ];
    }
  }

  return minDistanceSquared;
};

math.sqdistToFiniteLine = function( x, y, x1, y1, x2, y2 ){
  var offset = [ x - x1, y - y1 ];
  var line = [ x2 - x1, y2 - y1 ];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if( dotProduct < 0 ){
    return hypSq;
  }

  if( adjSq > lineSq ){
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function( x, y, points ){
  var x1, y1, x2, y2;
  var y3;

  // Intersect with vertical line through (x, y)
  var up = 0;
  var down = 0;
  for( var i = 0; i < points.length / 2; i++ ){

    x1 = points[ i * 2];
    y1 = points[ i * 2 + 1];

    if( i + 1 < points.length / 2 ){
      x2 = points[ (i + 1) * 2];
      y2 = points[ (i + 1) * 2 + 1];
    } else {
      x2 = points[ (i + 1 - points.length / 2) * 2];
      y2 = points[ (i + 1 - points.length / 2) * 2 + 1];
    }

    if( x1 == x && x2 == x ){
      // then ignore
    } else if( (x1 >= x && x >= x2)
      || (x1 <= x && x <= x2) ){

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if( y3 > y ){
        up++;
      }

      if( y3 < y ){
        down++;
      }

    } else {
      continue;
    }

  }

  if( up % 2 === 0 ){
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function(
  x, y, basePoints, centerX, centerY, width, height, direction, padding ){

  //var direction = arguments[6];
  var transformedPoints = new Array( basePoints.length );

  // Gives negative angle
  var angle;

  if( direction[0] != null ){
    angle = Math.atan( direction[1] / direction[0] );

    if( direction[0] < 0 ){
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos( -angle );
  var sin = Math.sin( -angle );

  //    console.log("base: " + basePoints);
  for( var i = 0; i < transformedPoints.length / 2; i++ ){
    transformedPoints[ i * 2] =
      width / 2 * (basePoints[ i * 2] * cos
        - basePoints[ i * 2 + 1] * sin);

    transformedPoints[ i * 2 + 1] =
      height / 2 * (basePoints[ i * 2 + 1] * cos
        + basePoints[ i * 2] * sin);

    transformedPoints[ i * 2] += centerX;
    transformedPoints[ i * 2 + 1] += centerY;
  }

  var points;

  if( padding > 0 ){
    var expandedLineSet = this.expandPolygon(
      transformedPoints,
      -padding );

    points = this.joinLines( expandedLineSet );
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints( x, y, points );
};

math.joinLines = function( lineSet ){

  var vertices = new Array( lineSet.length / 2 );

  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for( var i = 0; i < lineSet.length / 4; i++ ){
    currentLineStartX = lineSet[ i * 4];
    currentLineStartY = lineSet[ i * 4 + 1];
    currentLineEndX = lineSet[ i * 4 + 2];
    currentLineEndY = lineSet[ i * 4 + 3];

    if( i < lineSet.length / 4 - 1 ){
      nextLineStartX = lineSet[ (i + 1) * 4];
      nextLineStartY = lineSet[ (i + 1) * 4 + 1];
      nextLineEndX = lineSet[ (i + 1) * 4 + 2];
      nextLineEndY = lineSet[ (i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(
      currentLineStartX, currentLineStartY,
      currentLineEndX, currentLineEndY,
      nextLineStartX, nextLineStartY,
      nextLineEndX, nextLineEndY,
      true );

    vertices[ i * 2] = intersection[0];
    vertices[ i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function( points, pad ){

  var expandedLineSet = new Array( points.length * 2 );

  var currentPointX, currentPointY, nextPointX, nextPointY;

  for( var i = 0; i < points.length / 2; i++ ){
    currentPointX = points[ i * 2];
    currentPointY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextPointX = points[ (i + 1) * 2];
      nextPointY = points[ (i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = (nextPointY - currentPointY);
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt( offsetX * offsetX + offsetY * offsetY );
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[ i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[ i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function(
  x, y, centerX, centerY, ellipseWradius, ellipseHradius ){

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt( dispX * dispX + dispY * dispY );

  var newLength = len - 1;

  if( newLength < 0 ){
    return [];
  }

  var lenProportion = newLength / len;

  return [ (centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y ];
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function(
  x1, y1, x2, y2, centerX, centerY, radius ){

  // Calculate d, direction vector of line
  var d = [ x2 - x1, y2 - y1 ]; // Direction vector of line
  var c = [ centerX, centerY ]; // Center of circle
  var f = [ x1 - centerX, y1 - centerY ];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;

  var discriminant = b * b - 4 * a * c;

  if( discriminant < 0 ){
    return [];
  }

  var t1 = (-b + Math.sqrt( discriminant )) / (2 * a);
  var t2 = (-b - Math.sqrt( discriminant )) / (2 * a);

  var tMin = Math.min( t1, t2 );
  var tMax = Math.max( t1, t2 );
  var inRangeParams = [];

  if( tMin >= 0 && tMin <= 1 ){
    inRangeParams.push( tMin );
  }

  if( tMax >= 0 && tMax <= 1 ){
    inRangeParams.push( tMax );
  }

  if( inRangeParams.length === 0 ){
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if( inRangeParams.length > 1 ){

    if( inRangeParams[0] == inRangeParams[1] ){
      return [ nearIntersectionX, nearIntersectionY ];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [ nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY ];
    }

  } else {
    return [ nearIntersectionX, nearIntersectionY ];
  }

};

math.findCircleNearPoint = function( centerX, centerY,
  radius, farX, farY ){

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt( displacementX * displacementX
    + displacementY * displacementY );

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [ centerX + unitDisplacementX * radius,
    centerY + unitDisplacementY * radius ];
};

math.findMaxSqDistanceToOrigin = function( points ){
  var maxSqDistance = 0.000001;
  var sqDistance;

  for( var i = 0; i < points.length / 2; i++ ){

    sqDistance = points[ i * 2] * points[ i * 2]
      + points[ i * 2 + 1] * points[ i * 2 + 1];

    if( sqDistance > maxSqDistance ){
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.midOfThree = function( a, b, c ){
  if( (b <= a && a <= c) || (c <= a && a <= b) ){
    return a;
  } else if( (a <= b && b <= c) || (c <= b && b <= a) ){
    return b;
  } else {
    return c;
  }
};

math.finiteLinesIntersect = function( x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines ){

  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;

  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;

  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b  = dy43 * dx21 - dx43 * dy21;

  if( u_b !== 0 ){
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    var flptThreshold = 0.001;
    var min = 0 - flptThreshold;
    var max = 1 + flptThreshold;

    if( min <= ua && ua <= max && min <= ub && ub <= max ){
      return [ x1 + ua * dx21, y1 + ua * dy21 ];

    } else {
      if( !infiniteLines ){
        return [];
      } else {
        return [ x1 + ua * dx21, y1 + ua * dy21 ];
      }
    }
  } else {
    if( ua_t === 0 || ub_t === 0 ){

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if( this.midOfThree( x1, x2, x4 ) === x4 ){
        return [ x4, y4 ];
      }

      // Check start point of second line
      if( this.midOfThree( x1, x2, x3 ) === x3 ){
        return [ x3, y3 ];
      }

      // Endpoint of first line
      if( this.midOfThree( x3, x4, x2 ) === x2 ){
        return [ x2, y2 ];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

math.polygonIntersectLine = function(
  x, y, basePoints, centerX, centerY, width, height, padding ){

  var intersections = [];
  var intersection;

  var transformedPoints = new Array( basePoints.length );

  for( var i = 0; i < transformedPoints.length / 2; i++ ){
    transformedPoints[ i * 2] = basePoints[ i * 2] * width + centerX;
    transformedPoints[ i * 2 + 1] = basePoints[ i * 2 + 1] * height + centerY;
  }

  var points;

  if( padding > 0 ){
    var expandedLineSet = math.expandPolygon(
      transformedPoints,
      -padding );

    points = math.joinLines( expandedLineSet );
  } else {
    points = transformedPoints;
  }
  // var points = transformedPoints;

  var currentX, currentY, nextX, nextY;

  for( var i = 0; i < points.length / 2; i++ ){

    currentX = points[ i * 2];
    currentY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextX = points[ (i + 1) * 2];
      nextY = points[ (i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(
      x, y, centerX, centerY,
      currentX, currentY,
      nextX, nextY );

    if( intersection.length !== 0 ){
      intersections.push( intersection[0], intersection[1] );
    }
  }

  return intersections;
};

math.shortenIntersection = function(
  intersection, offset, amount ){

  var disp = [ intersection[0] - offset[0], intersection[1] - offset[1] ];

  var length = Math.sqrt( disp[0] * disp[0] + disp[1] * disp[1] );

  var lenRatio = (length - amount) / length;

  if( lenRatio < 0 ){
    lenRatio = 0.00001;
  }

  return [ offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1] ];
};

math.generateUnitNgonPointsFitToSquare = function( sides, rotationRadians ){
  var points = math.generateUnitNgonPoints( sides, rotationRadians );
  points = math.fitPolygonToSquare( points );

  return points;
};

math.fitPolygonToSquare = function( points ){
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ];
    y = points[2 * i + 1];

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ] = points[2 * i ] * sx;
    y = points[2 * i + 1] = points[2 * i + 1] * sy;

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  if( minY < -1 ){
    for( var i = 0; i < sides; i++ ){
      y = points[2 * i + 1] = points[2 * i + 1] + (-1 - minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function( sides, rotationRadians ){

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ?
    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  //    console.log(nodeShapes['square']);
  startAngle += rotationRadians;

  var points = new Array( sides * 2 );

  var currentAngle, x, y;
  for( var i = 0; i < sides; i++ ){
    currentAngle = i * increment + startAngle;

    x = points[2 * i ] = Math.cos( currentAngle );// * (1 + i/2);
    y = points[2 * i + 1] = Math.sin( -currentAngle );//  * (1 + i/2);
  }

  return points;
};

math.getRoundRectangleRadius = function( width, height ){

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min( width / 4, height / 4, 8 );
};

module.exports = math;

},{}],89:[function(require,module,exports){
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

'use strict';

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function( executor ){
  /*  optionally support non-constructor/plain-function call  */
  if( !(this instanceof api) )
    return new api( executor );

  /*  initialize object  */
  this.id           = 'Thenable/1.0.7';
  this.state        = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled  = [];            /*  initial handlers  */
  this.onRejected   = [];            /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind( this )
  };

  /*  support optional executor function  */
  if( typeof executor === 'function' )
    executor.call( this, this.fulfill.bind( this ), this.reject.bind( this ) );
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function( value ){ return deliver( this, STATE_FULFILLED, 'fulfillValue', value ); },
  reject:  function( value ){ return deliver( this, STATE_REJECTED,  'rejectReason', value ); },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function( onFulfilled, onRejected ){
    var curr = this;
    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(
      resolver( onFulfilled, next, 'fulfill' ) );             /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(
      resolver( onRejected,  next, 'reject' ) );             /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute( curr );
    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function( curr, state, name, value ){
  if( curr.state === STATE_PENDING ){
    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[ name ] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute( curr );
  }
  return curr;
};

/*  execute all handlers  */
var execute = function( curr ){
  if( curr.state === STATE_FULFILLED )
    execute_handlers( curr, 'onFulfilled', curr.fulfillValue );
  else if( curr.state === STATE_REJECTED )
    execute_handlers( curr, 'onRejected',  curr.rejectReason );
};

/*  execute particular set of handlers  */
var execute_handlers = function( curr, name, value ){
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if( curr[ name ].length === 0 )
    return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[ name ];
  curr[ name ] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function(){
    for( var i = 0; i < handlers.length; i++ )
      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
  if( typeof setImmediate === 'function' )
    setImmediate( func );
  else
    setTimeout( func, 0 );
};

/*  generate a resolver function  */
var resolver = function( cb, next, method ){
  return function( value ){
    if( typeof cb !== 'function' )                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[ method ].call( next, value );                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
      var result;
      try { result = cb( value ); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
      catch( e ){
        next.reject( e );                                  /*  [Promises/A+ 2.2.7.2]  */
        return;
      }
      resolve( next, result );                               /*  [Promises/A+ 2.2.7.1]  */
    }
  };
};

/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
var resolve = function( promise, x ){
  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
  if( promise === x || promise.proxy === x ){
    promise.reject( new TypeError( 'cannot resolve promise with itself' ) );
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if( (typeof x === 'object' && x !== null) || typeof x === 'function' ){
    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch( e ){
      promise.reject( e );                                   /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if( typeof then === 'function' ){
    var resolved = false;
    try {
      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
      then.call( x,
        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
        function( y ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          if( y === x )                                 /*  [Promises/A+ 3.6]  */
            promise.reject( new TypeError( 'circular thenable chain' ) );
          else
            resolve( promise, y );
        },

        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
        function( r ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject( r );
        }
      );
    }
    catch( e ){
      if( !resolved )                                       /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject( e );                               /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill( x );                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// so we always have Promise.all()
api.all = function( ps ){
  return new api(function( resolveAll, rejectAll ){
    var vals = new Array( ps.length );
    var doneCount = 0;

    var fulfill = function( i, val ){
      vals[ i ] = val;
      doneCount++;

      if( doneCount === ps.length ){
        resolveAll( vals );
      }
    };

    for( var i = 0; i < ps.length; i++ ){
      (function( i ){
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if( isPromise ){
          p.then( function( val ){
            fulfill( i, val );
          }, function( err ){
            rejectAll( err );
          } );
        } else {
          var val = p;
          fulfill( i, val );
        }
      })( i );
    }

  } );
};

api.resolve = function( val ){
  return new api(function( resolve, reject ){ resolve( val ); });
};

api.reject = function( val ){
  return new api(function( resolve, reject ){ reject( val ); });
};

module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

},{}],90:[function(require,module,exports){
'use strict';

var is = require( './is' );
var util = require( './util' );

var Selector = function( selector ){

  if( !(this instanceof Selector) ){
    return new Selector( selector );
  }

  var self = this;

  self._private = {
    selectorText: null,
    invalid: true
  };

  // storage for parsed queries
  var newQuery = function(){
    return {
      classes: [],
      colonSelectors: [],
      data: [],
      group: null,
      ids: [],
      meta: [],

      // fake selectors
      collection: null, // a collection to match against
      filter: null, // filter function

      // these are defined in the upward direction rather than down (e.g. child)
      // because we need to go up in Selector.filter()
      parent: null, // parent query obj
      ancestor: null, // ancestor query obj
      subject: null, // defines subject in compound query (subject query obj; points to self if subject)

      // use these only when subject has been defined
      child: null,
      descendant: null
    };
  };

  if( !selector || ( is.string( selector ) && selector.match( /^\s*$/ ) ) ){

    self.length = 0;

  } else if( selector === '*' || selector === 'edge' || selector === 'node' ){

    // make single, group-only selectors cheap to make and cheap to filter

    self[0] = newQuery();
    self[0].group = selector === '*' ? selector : selector + 's';
    self[0].groupOnly = true;
    self._private.invalid = false;
    self._private.selectorText = selector;
    self.length = 1;

  } else if( is.elementOrCollection( selector ) ){

    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self.length = 1;

  } else if( is.fn( selector ) ){

    self[0] = newQuery();
    self[0].filter = selector;
    self.length = 1;

  } else if( is.string( selector ) ){

    // the current subject in the query
    var currentSubject = null;

    // tokens in the query language
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
    tokens.className = tokens.variable; // a class name (follows variable conventions)
    tokens.id = tokens.variable; // an element id (follows variable conventions)

    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
    // so that values get compared properly in Selector.filter()
    var cleanMetaChars = function( str ){
      return str.replace( new RegExp( '\\\\(' + tokens.metaChar + ')', 'g' ), function( match, $1, offset, original ){
        return $1;
      } );
    };

    // add @ variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];
      tokens.comparatorOp += '|@' + op;
    }

    // add ! variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];

      if( op.indexOf( '!' ) >= 0 ){ continue; } // skip ops that explicitly contain !
      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

      tokens.comparatorOp += '|\\!' + op;
    }

    // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
    // - when you add something here, also add to Selector.toString()
    var exprs = [
      {
        name: 'group',
        query: true,
        regex: '(node|edge|\\*)',
        populate: function( group ){
          this.group = group === '*' ? group : group + 's';
        }
      },

      {
        name: 'state',
        query: true,
        // NB: if one colon selector is a substring of another from its start, place the longer one first
        // e.g. :foobar|:foo
        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
        populate: function( state ){
          this.colonSelectors.push( state );
        }
      },

      {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function( id ){
          this.ids.push( cleanMetaChars( id ) );
        }
      },

      {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function( className ){
          this.classes.push( cleanMetaChars( className ) );
        }
      },

      {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( variable ){
          this.data.push( {
            field: cleanMetaChars( variable )
          } );
        }
      },

      {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function( variable, comparatorOp, value ){
          var valueIsString = new RegExp( '^' + tokens.string + '$' ).exec( value ) != null;

          if( valueIsString ){
            value = value.substring( 1, value.length - 1 );
          } else {
            value = parseFloat( value );
          }

          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: comparatorOp,
            value: value
          } );
        }
      },

      {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( boolOp, variable ){
          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: boolOp
          } );
        }
      },

      {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function( meta, comparatorOp, number ){
          this.meta.push( {
            field: cleanMetaChars( meta ),
            operator: comparatorOp,
            value: parseFloat( number )
          } );
        }
      },

      {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function(){
          // go on to next query
          self[ ++i ] = newQuery();
          currentSubject = null;
        }
      },

      {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function(){
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = this;
          childQuery.subject = currentSubject;

          // we're now populating the child query with expressions that follow
          self[ i ] = childQuery;
        }
      },

      {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function(){
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = this;
          descendantQuery.subject = currentSubject;

          // we're now populating the descendant query with expressions that follow
          self[ i ] = descendantQuery;
        }
      },

      {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function(){
          if( currentSubject != null && this.subject != this ){
            util.error( 'Redefinition of subject in selector `' + selector + '`' );
            return false;
          }

          currentSubject = this;
          this.subject = this;
        }

      }
    ];

    self._private.selectorText = selector;
    var remaining = selector;
    var i = 0;

    // of all the expressions, find the first match in the remaining text
    var consumeExpr = function( expectation ){
      var expr;
      var match;
      var name;

      for( var j = 0; j < exprs.length; j++ ){
        var e = exprs[ j ];
        var n = e.name;

        // ignore this expression if it doesn't meet the expectation function
        if( is.fn( expectation ) && !expectation( n, e ) ){ continue; }

        var m = remaining.match( new RegExp( '^' + e.regex ) );

        if( m != null ){
          match = m;
          expr = e;
          name = n;

          var consumed = m[0];
          remaining = remaining.substring( consumed.length );

          break; // we've consumed one expr, so we can return now
        }
      }

      return {
        expr: expr,
        match: match,
        name: name
      };
    };

    // consume all leading whitespace
    var consumeWhitespace = function(){
      var match = remaining.match( /^\s+/ );

      if( match ){
        var consumed = match[0];
        remaining = remaining.substring( consumed.length );
      }
    };

    self[0] = newQuery(); // get started

    consumeWhitespace(); // get rid of leading whitespace
    for( ;; ){
      var check = consumeExpr();

      if( check.expr == null ){
        util.error( 'The selector `' + selector + '`is invalid' );
        return;
      } else {
        var args = [];
        for( var j = 1; j < check.match.length; j++ ){
          args.push( check.match[ j ] );
        }

        // let the token populate the selector object (i.e. in self[i])
        var ret = check.expr.populate.apply( self[ i ], args );

        if( ret === false ){ return; } // exit if population failed
      }

      // we're done when there's nothing left to parse
      if( remaining.match( /^\s*$/ ) ){
        break;
      }
    }

    self.length = i + 1;

    // adjust references for subject
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( query.subject != null ){
        // go up the tree until we reach the subject
        for( ;; ){
          if( query.subject == query ){ break; } // done if subject is self

          if( query.parent != null ){ // swap parent/child reference
            var parent = query.parent;
            var child = query;

            child.parent = null;
            parent.child = child;

            query = parent; // go up the tree
          } else if( query.ancestor != null ){ // swap ancestor/descendant
            var ancestor = query.ancestor;
            var descendant = query;

            descendant.ancestor = null;
            ancestor.descendant = descendant;

            query = ancestor; // go up the tree
          } else {
            util.error( 'When adjusting references for the selector `' + query + '`, neither parent nor ancestor was found' );
            break;
          }
        } // for

        self[ j ] = query.subject; // subject should be the root query
      } // if
    } // for

  } else {
    util.error( 'A selector must be created from a string; found ' + selector );
    return;
  }

  self._private.invalid = false;

};

var selfn = Selector.prototype;

selfn.size = function(){
  return this.length;
};

selfn.eq = function( i ){
  return this[ i ];
};

var queryMatches = function( query, ele ){
  var ele_p = ele._private;

  // make single group-only selectors really cheap to check since they're the most common ones
  if( query.groupOnly ){
    return query.group === '*' || query.group === ele_p.group;
  }

  // check group
  if( query.group != null && query.group != '*' && query.group != ele_p.group ){
    return false;
  }

  var cy = ele.cy();

  // check colon selectors
  var allColonSelectorsMatch = true;
  for( var k = 0; k < query.colonSelectors.length; k++ ){
    var sel = query.colonSelectors[ k ];

    switch( sel ){
      case ':selected':
        allColonSelectorsMatch = ele.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !ele.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = ele.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !ele.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = ele.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !ele.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = ele.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !ele.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = ele.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = ele.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !ele.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = ele.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !ele.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = ele.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !ele.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = ele.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !ele.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = ele.isNode() && ele.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = ele.isNode() && ele.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = ele.isNode() && ele.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) === ele.data( 'target' );
        break;
      case ':simple':
        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) !== ele.data( 'target' );
        break;
      case ':active':
        allColonSelectorsMatch = ele.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !ele.active();
        break;
      case ':touch':
        allColonSelectorsMatch = is.touch();
        break;
      case ':backgrounding':
        allColonSelectorsMatch = ele.backgrounding();
        break;
      case ':nonbackgrounding':
        allColonSelectorsMatch = !ele.backgrounding();
        break;
    }

    if( !allColonSelectorsMatch ) break;
  }
  if( !allColonSelectorsMatch ) return false;

  // check id
  var allIdsMatch = true;
  for( var k = 0; k < query.ids.length; k++ ){
    var id = query.ids[ k ];
    var actualId = ele_p.data.id;

    allIdsMatch = allIdsMatch && (id == actualId);

    if( !allIdsMatch ) break;
  }
  if( !allIdsMatch ) return false;

  // check classes
  var allClassesMatch = true;
  for( var k = 0; k < query.classes.length; k++ ){
    var cls = query.classes[ k ];

    allClassesMatch = allClassesMatch && ele.hasClass( cls );

    if( !allClassesMatch ) break;
  }
  if( !allClassesMatch ) return false;

  // generic checking for data/metadata
  var operandsMatch = function( params ){
    var allDataMatches = true;
    for( var k = 0; k < query[ params.name ].length; k++ ){
      var data = query[ params.name ][ k ];
      var operator = data.operator;
      var value = data.value;
      var field = data.field;
      var matches;

      if( operator != null && value != null ){

        var fieldVal = params.fieldValue( field );
        var fieldStr = !is.string( fieldVal ) && !is.number( fieldVal ) ? '' : '' + fieldVal;
        var valStr = '' + value;

        var caseInsensitive = false;
        if( operator.indexOf( '@' ) >= 0 ){
          fieldStr = fieldStr.toLowerCase();
          valStr = valStr.toLowerCase();

          operator = operator.replace( '@', '' );
          caseInsensitive = true;
        }

        var notExpr = false;
        if( operator.indexOf( '!' ) >= 0 ){
          operator = operator.replace( '!', '' );
          notExpr = true;
        }

        // if we're doing a case insensitive comparison, then we're using a STRING comparison
        // even if we're comparing numbers
        if( caseInsensitive ){
          value = valStr.toLowerCase();
          fieldVal = fieldStr.toLowerCase();
        }

        var isIneqCmp = false;

        switch( operator ){
        case '*=':
          matches = fieldStr.indexOf( valStr ) >= 0;
          break;
        case '$=':
          matches = fieldStr.indexOf( valStr, fieldStr.length - valStr.length ) >= 0;
          break;
        case '^=':
          matches = fieldStr.indexOf( valStr ) === 0;
          break;
        case '=':
          matches = fieldVal === value;
          break;
        case '>':
          isIneqCmp = true;
          matches = fieldVal > value;
          break;
        case '>=':
          isIneqCmp = true;
          matches = fieldVal >= value;
          break;
        case '<':
          isIneqCmp = true;
          matches = fieldVal < value;
          break;
        case '<=':
          isIneqCmp = true;
          matches = fieldVal <= value;
          break;
        default:
          matches = false;
          break;
        }

        // apply the not op, but null vals for inequalities should always stay non-matching
        if( notExpr && ( fieldVal != null || !isIneqCmp ) ){
          matches = !matches;
        }
      } else if( operator != null ){
        switch( operator ){
        case '?':
          matches = params.fieldTruthy( field );
          break;
        case '!':
          matches = !params.fieldTruthy( field );
          break;
        case '^':
          matches = params.fieldUndefined( field );
          break;
        }
      } else {
        matches = !params.fieldUndefined( field );
      }

      if( !matches ){
        allDataMatches = false;
        break;
      }
    } // for

    return allDataMatches;
  }; // operandsMatch

  // check data matches
  var allDataMatches = operandsMatch( {
    name: 'data',
    fieldValue: function( field ){
      return ele_p.data[ field ];
    },
    fieldUndefined: function( field ){
      return ele_p.data[ field ] === undefined;
    },
    fieldTruthy: function( field ){
      if( ele_p.data[ field ] ){
        return true;
      }
      return false;
    }
  } );

  if( !allDataMatches ){
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch( {
    name: 'meta',
    fieldValue: function( field ){
      return ele[ field ]();
    },
    fieldUndefined: function( field ){
      return ele[ field ]() == null;
    },
    fieldTruthy: function( field ){
      if( ele[ field ]() ){
        return true;
      }
      return false;
    }
  } );

  if( !allMetaMatches ){
    return false;
  }

  // check collection
  if( query.collection != null ){
    var matchesAny = query.collection.hasElementWithId( ele.id() );

    if( !matchesAny ){
      return false;
    }
  }

  // check filter function
  if( query.filter != null && ele.collection().filter( query.filter ).size() === 0 ){
    return false;
  }

  // check parent/child relations
  var confirmRelations = function( query, eles ){
    if( query != null ){
      var matches = false;

      if( !cy.hasCompoundNodes() ){
        return false;
      }

      eles = eles(); // save cycles if query == null

      // query must match for at least one element (may be recursive)
      for( var i = 0; i < eles.length; i++ ){
        if( queryMatches( query, eles[ i ] ) ){
          matches = true;
          break;
        }
      }

      return matches;
    } else {
      return true;
    }
  };

  if( !confirmRelations( query.parent, function(){
    return ele.parent();
  } ) ){ return false; }

  if( !confirmRelations( query.ancestor, function(){
    return ele.parents();
  } ) ){ return false; }

  if( !confirmRelations( query.child, function(){
    return ele.children();
  } ) ){ return false; }

  if( !confirmRelations( query.descendant, function(){
    return ele.descendants();
  } ) ){ return false; }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
selfn.filter = function( collection ){
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return cy.collection();
  }

  var selectorFunction = function( i, element ){
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( queryMatches( query, element ) ){
        return true;
      }
    }

    return false;
  };

  if( self._private.selectorText == null ){
    selectorFunction = function(){ return true; };
  }

  var filteredCollection = collection.filter( selectorFunction );

  return filteredCollection;
}; // filter

// does selector match a single element?
selfn.matches = function( ele ){
  var self = this;

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return false;
  }

  for( var j = 0; j < self.length; j++ ){
    var query = self[ j ];

    if( queryMatches( query, ele ) ){
      return true;
    }
  }

  return false;
}; // filter

// ith query to string
selfn.toString = selfn.selector = function(){

  var str = '';

  var clean = function( obj ){
    if( obj == null ){
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function( val ){
    if( is.string( val ) ){
      return '"' + val + '"';
    } else {
      return clean( val );
    }
  };

  var space = function( val ){
    return ' ' + val + ' ';
  };

  var queryToString = function( query ){
    var str = '';

    if( query.subject === query ){
      str += '$';
    }

    var group = clean( query.group );
    str += group.substring( 0, group.length - 1 );

    for( var j = 0; j < query.data.length; j++ ){
      var data = query.data[ j ];

      if( data.value ){
        str += '[' + data.field + space( clean( data.operator ) ) + cleanVal( data.value ) + ']';
      } else {
        str += '[' + clean( data.operator ) + data.field + ']';
      }
    }

    for( var j = 0; j < query.meta.length; j++ ){
      var meta = query.meta[ j ];
      str += '[[' + meta.field + space( clean( meta.operator ) ) + cleanVal( meta.value ) + ']]';
    }

    for( var j = 0; j < query.colonSelectors.length; j++ ){
      var sel = query.colonSelectors[ i ];
      str += sel;
    }

    for( var j = 0; j < query.ids.length; j++ ){
      var sel = '#' + query.ids[ i ];
      str += sel;
    }

    for( var j = 0; j < query.classes.length; j++ ){
      var sel = '.' + query.classes[ j ];
      str += sel;
    }

    if( query.parent != null ){
      str = queryToString( query.parent ) + ' > ' + str;
    }

    if( query.ancestor != null ){
      str = queryToString( query.ancestor ) + ' ' + str;
    }

    if( query.child != null ){
      str += ' > ' + queryToString( query.child );
    }

    if( query.descendant != null ){
      str += ' ' + queryToString( query.descendant );
    }

    return str;
  };

  for( var i = 0; i < this.length; i++ ){
    var query = this[ i ];

    str += queryToString( query );

    if( this.length > 1 && i < this.length - 1 ){
      str += ', ';
    }
  }

  return str;
};

module.exports = Selector;

},{"./is":86,"./util":103}],91:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function( eles ){
  var self = this;
  var _p = self._private;

  if( _p.newStyle ){ // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};

    self.cleanElements( eles, true );
  }

  for( var ie = 0; ie < eles.length; ie++ ){
    var ele = eles[ ie ];

    var cxtMeta = self.getContextMeta( ele );
    var cxtStyle = self.getContextStyle( cxtMeta );
    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

    self.updateTransitions( ele, app.diffProps );
    self.updateStyleHints( ele );

  } // for elements

  _p.newStyle = false;
};

styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[ dualCxtKey ];

  if( cachedVal ){
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var oldHasCxt = oldCxtKey[ i ] === 't';
    var newHasCxt = newCxtKey[ i ] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if( cxtHasDiffed || cxtHasMappedProps ){
      var props;

      if( cxtHasDiffed && cxtHasMappedProps ){
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if( cxtHasDiffed ){
        props = cxt.properties; // need to check them all
      } else if( cxtHasMappedProps ){
        props = cxt.mappedProperties; // only need to check mapped
      }

      for( var j = 0; j < props.length; j++ ){
        var prop = props[ j ];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for( var k = i + 1; k < self.length; k++ ){
          var laterCxt = self[ k ];
          var hasLaterCxt = newCxtKey[ k ] === 't';

          if( !hasLaterCxt ){ continue; } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
        }

        if( !addedProp[ name ] && !laterCxtOverrides ){
          addedProp[ name ] = true;
          diffProps.push( name );
        }
      } // for props
    } // if

  } // for contexts

  cache[ dualCxtKey ] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function( ele ){
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if( self._private.newStyle ){
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for( var i = 0; i < self.length; i++ ){
    var context = self[ i ];
    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

    if( contextSelectorMatches ){
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff( prevKey, cxtKey );

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function( cxtMeta ){
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if( cxtStyles[ cxtKey ] ){ return cxtStyles[ cxtKey ]; }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var hasCxt = cxtKey[ i ] === 't';

    if( !hasCxt ){ continue; }

    for( var j = 0; j < cxt.properties.length; j++ ){
      var prop = cxt.properties[ j ];

      style[ prop.name ] = prop;
    }
  }

  cxtStyles[ cxtKey ] = style;
  return style;
};

styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for( var i = 0; i < diffProps.length; i++ ){
    var diffPropName = diffProps[ i ];
    var cxtProp = cxtStyle[ diffPropName ];
    var eleProp = ele.pstyle( diffPropName );

    if( !cxtProp ){ // no context prop means delete
      if( !eleProp ){
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if( eleProp.bypass ){
        cxtProp = { name: diffPropName, deleteBypassed: true };
      } else {
        cxtProp = { name: diffPropName, delete: true };
      }
    }

    // save cycles when the context prop doesn't need to be applied
    if( eleProp === cxtProp ){ continue; }

    var retDiffProp = retDiffProps[ diffPropName ] = {
      prev: eleProp
    };

    self.applyParsedProperty( ele, cxtProp );

    retDiffProp.next = ele.pstyle( diffPropName );

    if( retDiffProp.next && retDiffProp.next.bypass ){
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function(ele){
  var _p = ele._private;
  var self = this;

  if( ele.removed() ){ return; }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if( _p.group === 'nodes' ){
    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
      var size = ele.pstyle( 'pie-' + i + '-background-size' ).value;

      if( size > 0 ){
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = ele.pstyle( 'text-transform' ).strValue;
  var content = ele.pstyle( 'label' ).strValue;
  var srcContent = ele.pstyle( 'source-label' ).strValue;
  var tgtContent = ele.pstyle( 'target-label' ).strValue;
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ele.pstyle( 'font-size' ).pfValue + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  // var variant = style['font-variant'].strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;
  var valign = ele.pstyle( 'text-valign' ).strValue;
  var halign = ele.pstyle( 'text-valign' ).strValue;
  var oWidth = ele.pstyle( 'text-outline-width' ).pfValue;
  var wrap = ele.pstyle( 'text-wrap' ).strValue;
  var wrapW = ele.pstyle( 'text-max-width' ).pfValue;
  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
  _p.labelStyleKey = labelStyleKey;
  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
  _p.labelKey = labelStyleKey + '$' + content;
  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function( ele, parsedProp ){
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal, flatProp;
  var types = self.types;
  var type = self.properties[ prop.name ].type;
  var propIsBypass = prop.bypass;
  var origProp = style[ prop.name ];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  // edges connected to compound nodes can not be haystacks
  if(
    parsedProp.name === 'curve-style'
    && parsedProp.value === 'haystack'
    && ele.isEdge()
    && ( ele.isLoop() || ele.source().isParent() || ele.target().isParent() )
  ){
    prop = parsedProp = this.parse( parsedProp.name, 'bezier', propIsBypass );
  }

  if( prop.delete ){ // delete the property and use the default value on falsey value
    style[ prop.name ] = undefined;

    return true;
  }

  if( prop.deleteBypassed ){ // delete the property that the
    if( !origProp ){
      return true; // can't delete if no prop

    } else if( origProp.bypass ){ // delete bypassed
      origProp.bypassed = undefined;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  }

  // check if we need to delete the current bypass
  if( prop.deleteBypass ){ // then this property is just here to indicate we need to delete
    if( !origProp ){
      return true; // property is already not defined

    } else if( origProp.bypass ){ // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[ prop.name ] = origProp.bypassed;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function(){
    util.error( 'Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined' );
  };

  // put the property in the style objects
  switch( prop.mapped ){ // flatten the property if mapped
  case types.mapData:
  case types.mapLayoutData:
  case types.mapScratch:

    var isLayout = prop.mapped === types.mapLayoutData;
    var isScratch = prop.mapped === types.mapScratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    for( var i = 0; i < fields.length && fieldVal; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    }

    var percent;
    if( !is.number( fieldVal ) ){ // then keep the mapping but assume 0% for now
      percent = 0;
    } else {
      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
    }

    // make sure to bound percent value
    if( percent < 0 ){
      percent = 0;
    } else if( percent > 1 ){
      percent = 1;
    }

    if( type.color ){
      var r1 = prop.valueMin[0];
      var r2 = prop.valueMax[0];
      var g1 = prop.valueMin[1];
      var g2 = prop.valueMax[1];
      var b1 = prop.valueMin[2];
      var b2 = prop.valueMax[2];
      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

      var clr = [
        Math.round( r1 + (r2 - r1) * percent ),
        Math.round( g1 + (g2 - g1) * percent ),
        Math.round( b1 + (b2 - b1) * percent ),
        Math.round( a1 + (a2 - a1) * percent )
      ];

      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
        name: prop.name,
        value: clr,
        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
      };

    } else if( type.number ){
      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
      flatProp = this.parse( prop.name, calcValue, prop.bypass, flatPropMapping );

    } else {
      return false; // can only map to colours and numbers
    }

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  // direct mapping
  case types.data:
  case types.layoutData:
  case types.scratch:
    var isLayout = prop.mapped === types.layoutData;
    var isScratch = prop.mapped === types.scratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    } }

    flatProp = this.parse( prop.name, fieldVal, prop.bypass, flatPropMapping );

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      var flatPropVal = origProp ? origProp.strValue : '';

      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case types.fn:
    var fn = prop.value;
    var fnRetVal = fn( ele );

    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, flatPropMapping );
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case undefined:
    break; // just set the property

  default:
    return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if( propIsBypass ){
    if( origPropIsBypass ){ // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else { // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[ prop.name ] = prop; // and set

  } else { // prop is not bypass
    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else { // then just replace the old prop with the new one
      style[ prop.name ] = prop;
    }
  }

  this.checkZOrderTrigger( ele, prop.name, origProp ? origProp.value : null, prop.value );

  return true;
};

styfn.cleanElements = function( eles, keepBypasses ){
  var self = this;
  var props = self.properties;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( !keepBypasses ){
      ele._private.style = {};
    } else {
      var style = ele._private.style;

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        var eleProp = style[ prop.name ];

        if( eleProp ){
          if( eleProp.bypass ){
            eleProp.bypassed = null;
          } else {
            style[ prop.name ] = null;
          }
        }
      }
    }
  }
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function(){
  var cy = this._private.cy;
  var eles = cy.mutableElements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function( eles ){
  var self = this;

  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var style = ele._private.style;

    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
      var prop = self.properties[ j ];
      var propInStyle = style[ prop.name ];

      if( propInStyle && propInStyle.mapping ){
        var mapping = propInStyle.mapping;
        this.applyParsedProperty( ele, mapping ); // reapply the mapping property
      }
    }

    this.updateStyleHints( ele );
  }
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function( ele, diffProps, isBypass ){
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle( 'transition-property' ).value;
  var duration = ele.pstyle( 'transition-duration' ).pfValue;
  var delay = ele.pstyle( 'transition-delay' ).pfValue;

  if( props.length > 0 && duration > 0 ){

    var css = {};

    // build up the style to animate towards
    var anyPrev = false;
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      var styProp = ele.pstyle( prop );
      var diffProp = diffProps[ prop ];

      if( !diffProp ){ continue; }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if( !fromProp ){ continue; }

      // consider px values
      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

      // consider numerical values
      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

      // consider colour values
      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
        diff = fromProp.value[0] !== toProp.value[0]
          || fromProp.value[1] !== toProp.value[1]
          || fromProp.value[2] !== toProp.value[2]
        ;

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if( diff ){
        css[ prop ] = toProp.strValue; // to val
        this.applyBypass( ele, prop, initVal ); // from val
        anyPrev = true;
      }

    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if( !anyPrev ){ return; }

    _p.transitioning = true;

    ele.stop();

    if( delay > 0 ){
      ele.delay( delay );
    }

    ele.animate( {
      css: css
    }, {
      duration: duration,
      easing: ele.pstyle( 'transition-timing-function' ).value,
      queue: false,
      complete: function(){
        if( !isBypass ){
          self.removeBypasses( ele, props );
        }

        _p.transitioning = false;
      }
    } );

  } else if( _p.transitioning ){
    ele.stop();

    this.removeBypasses( ele, props );

    _p.transitioning = false;
  }
};

styfn.checkZOrderTrigger = function( ele, name, fromValue, toValue ){
  var prop = this.properties[ name ];

  if( prop.triggersZOrder && ( fromValue == null || prop.triggersZOrder( fromValue, toValue ) ) ){
    this._private.cy.notify({
      type: 'zorder',
      eles: ele
    });
  }
};

module.exports = styfn;

},{"../is":86,"../util":103}],92:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function( eles, name, value, updateTransitions ){
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if( name === '*' || name === '**' ){ // apply to all property names

    if( value !== undefined ){
      for( var i = 0; i < self.properties.length; i++ ){
        var prop = self.properties[ i ];
        var name = prop.name;

        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }

  } else if( is.string( name ) ){ // then parse the single property
    var parsedProp = this.parse( name, value, true );

    if( parsedProp ){
      props.push( parsedProp );
    }
  } else if( is.plainObject( name ) ){ // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var name = prop.name;
      var value = specifiedProps[ name ];

      if( value === undefined ){ // try camel case name too
        value = specifiedProps[ util.dash2camel( name ) ];
      }

      if( value !== undefined ){
        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }
  } else { // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if( props.length === 0 ){ return false; }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var diffProps = {};
    var diffProp;

    for( var j = 0; j < props.length; j++ ){ // for each prop
      var prop = props[ j ];

      if( updateTransitions ){
        var prevProp = ele.pstyle( prop.name );
        diffProp = diffProps[ prop.name ] = { prev: prevProp };
      }

      ret = this.applyParsedProperty( ele, prop ) || ret;

      if( updateTransitions ){
        diffProp.next = ele.pstyle( prop.name );
      }

    } // for props

    if( ret ){
      this.updateStyleHints( ele );
    }

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function( eles, name, value ){
  name = util.camel2dash( name );

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var prop = ele._private.style[ name ];
    var type = this.properties[ name ].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if( !prop || !prop.bypass ){ // need a bypass if one doesn't exist
      this.applyBypass( ele, name, value );
      continue;
    }

    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

    prop.value = value;

    if( prop.pfValue != null ){
      prop.pfValue = value;
    }

    if( isColor ){
      prop.strValue = 'rgb(' + value.join( ',' ) + ')';
    } else if( isMulti ){
      prop.strValue = value.join( ' ' );
    } else {
      prop.strValue = '' + value;
    }

    this.checkZOrderTrigger( ele, name, oldValue, value );
  }
};

styfn.removeAllBypasses = function( eles, updateTransitions ){
  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
};

styfn.removeBypasses = function( eles, props, updateTransitions ){
  var isBypass = true;

  for( var j = 0; j < eles.length; j++ ){
    var ele = eles[ j ];
    var diffProps = {};

    for( var i = 0; i < props.length; i++ ){
      var name = props[ i ];
      var prop = this.properties[ name ];
      var prevProp = ele.pstyle( prop.name );

      if( !prevProp || !prevProp.bypass ){
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass
      var parsedProp = this.parse( name, value, true );
      var diffProp = diffProps[ prop.name ] = { prev: prevProp };

      this.applyParsedProperty( ele, parsedProp );

      diffProp.next = ele.pstyle( prop.name );
    } // for props

    this.updateStyleHints( ele );

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles
};

module.exports = styfn;

},{"../is":86,"../util":103}],93:[function(require,module,exports){
'use strict';

var window = require( '../window' );

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function(){
  var px = this.containerCss( 'font-size' );

  if( px != null ){
    return parseFloat( px );
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function( propName ){
  var cy = this._private.cy;
  var domElement = cy.container();

  if( window && domElement && window.getComputedStyle ){
    return window.getComputedStyle( domElement ).getPropertyValue( propName );
  }
};

module.exports = styfn;

},{"../window":110}],94:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function( ele, prop ){
  if( prop ){
    return this.getStylePropertyValue( ele, prop, true );
  } else {
    return this.getRawStyle( ele, true );
  }
};

// gets the raw style for an element
styfn.getRawStyle = function( ele, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var rstyle = {};

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );

      if( val != null ){
        rstyle[ prop.name ] = val;
        rstyle[ util.dash2camel( prop.name ) ] = val;
      }
    }

    return rstyle;
  }
};

styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var prop = self.properties[ propName ];

    if( prop.alias ){
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle( prop.name );
    var zoom = ele.cy().zoom();

    if( styleProp ){
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat( styleProp.pfValue ).map( function( pfValue ){
        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
      } ).join( ' ' ) : styleProp.strValue;

      return val;
    }
  }
};

styfn.getAnimationStartStyle = function( ele, aniProps ){
  var rstyle = {};

  for( var i = 0; i < aniProps.length; i++ ){
    var aniProp = aniProps[ i ];
    var name = aniProp.name;

    var styleProp = ele.pstyle( name );

    if( styleProp !== undefined ){ // then make a prop of it
      if( is.plainObject( styleProp ) ){
        styleProp = this.parse( name, styleProp.strValue );
      } else {
        styleProp = this.parse( name, styleProp );
      }
    }

    if( styleProp ){
      rstyle[ name ] = styleProp;
    }
  }

  return rstyle;
};

styfn.getPropsList = function( propsObj ){
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if( style ){
    var names = Object.keys( style );

    for( var i = 0; i < names.length; i++ ){
      var name = names[i];
      var val = style[ name ];
      var prop = props[ name ] || props[ util.camel2dash( name ) ];
      var styleProp = this.parse( prop.name, val );

      rstyle.push( styleProp );
    }
  }

  return rstyle;
};

module.exports = styfn;

},{"../is":86,"../util":103}],95:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Selector = require( '../selector' );

var Style = function( cy ){

  if( !(this instanceof Style) ){
    return new Style( cy );
  }

  if( !is.core( cy ) ){
    util.error( 'A style must have a core reference' );
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };

  this.length = 0;

  this.resetToDefault();
};

var styfn = Style.prototype;

styfn.instanceString = function(){
  return 'style';
};

// remove all contexts
styfn.clear = function(){
  for( var i = 0; i < this.length; i++ ){
    this[ i ] = undefined;
  }
  this.length = 0;

  var _p = this._private;

  _p.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function(){
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function(){
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function( selectorStr ){
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );

  var i = this.length++; // new context means new index
  this[ i ] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function(){
  var self = this;
  var args = arguments;

  switch( args.length ){
  case 1:
    var map = args[0];

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        this.cssRule( prop.name, mapVal );
      }
    }

    break;

  case 2:
    this.cssRule( args[0], args[1] );
    break;

  default:
    break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function( name, value ){
  // name-value pair
  var property = this.parse( name, value );

  // add property to current context if valid
  if( property ){
    var i = this.length - 1;
    this[ i ].properties.push( property );
    this[ i ].properties[ property.name ] = property; // allow access by name as well

    if( property.name.match( /pie-(\d+)-background-size/ ) && property.value ){
      this._private.hasPie = true;
    }

    if( property.mapped ){
      this[ i ].mappedProperties.push( property );
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[ i ].selector;
    if( currentSelectorIsCore ){
      this._private.coreStyle[ property.name ] = property;
    }
  }

  return this; // chaining
};

// static function
Style.fromJson = function( cy, json ){
  var style = new Style( cy );

  style.fromJson( json );

  return style;
};

Style.fromString = function( cy, string ){
  return new Style( cy ).fromString( string );
};

[
  require( './apply' ),
  require( './bypass' ),
  require( './container' ),
  require( './get-for-ele' ),
  require( './json' ),
  require( './string-sheet' ),
  require( './properties' ),
  require( './parse' )
].forEach( function( props ){
  util.extend( styfn, props );
} );


Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

},{"../is":86,"../selector":90,"../util":103,"./apply":91,"./bypass":92,"./container":93,"./get-for-ele":94,"./json":96,"./parse":97,"./properties":98,"./string-sheet":99}],96:[function(require,module,exports){
'use strict';

var styfn = {};

styfn.applyFromJson = function( json ){
  var style = this;

  for( var i = 0; i < json.length; i++ ){
    var context = json[ i ];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys( props );

    style.selector( selector ); // apply selector

    for( var j = 0; j < names.length; j++ ){
      var name = names[j];
      var value = props[ name ];

      style.css( name, value ); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function( json ){
  var style = this;

  style.resetToDefault();
  style.applyFromJson( json );

  return style;
};

// get json from cy.style() api
styfn.json = function(){
  var json = [];

  for( var i = this.defaultLength; i < this.length; i++ ){
    var cxt = this[ i ];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];
      css[ prop.name ] = prop.strValue;
    }

    json.push( {
      selector: !selector ? 'core' : selector.toString(),
      style: css
    } );
  }

  return json;
};

module.exports = styfn;

},{}],97:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );
var math = require( '../math' );

var styfn = {};

// a caching layer for property parsing
styfn.parse = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  if( is.fn( value ) ){
    return self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  var flatKey = ( propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ) ? 'dontcare' : propIsFlat;
  var argHash = [ name, value, propIsBypass, flatKey ].join( '$' );
  var propCache = self.propCache = self.propCache || {};
  var ret;

  if( !(ret = propCache[ argHash ]) ){
    ret = propCache[ argHash ] = self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element
  if( propIsBypass || propIsFlat === 'mapping' ){
    // need a copy since props are mutated later in their lifecycles
    ret = util.copy( ret );

    if( ret ){
      ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn.parseImplWarn = function( name, value, propIsBypass, propIsFlat ){
  var prop = this.parseImpl( name, value, propIsBypass, propIsFlat );

  if( !prop && value != null ){
    util.error('The style property `%s: %s` is invalid', name, value);
  }

  return prop;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn.parseImpl = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[ name ];
  var passedValue = value;
  var types = self.types;

  if( !property ){ return null; } // return null on property of unknown name
  if( value === undefined || value === null ){ return null; } // can't assign null

  // the property may be an alias
  if( property.alias ){
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string( value );
  if( valueIsString ){ // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if( !type ){ return null; } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if( propIsBypass && (value === '' || value === null) ){
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if( is.fn( value ) ){
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
  if( !valueIsString || propIsFlat ){
    // then don't bother to do the expensive regex checks

  } else if(
    ( data = new RegExp( types.data.regex ).exec( value ) ) ||
    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass

    var mapped;
    if( data ){
      mapped = types.data;
    } else if( layoutData ){
      mapped = types.layoutData;
    } else {
      mapped = types.scratch;
    }

    data = data || layoutData || scratch;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };

  } else if(
    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass
    if( type.multiple ){ return false; } // impossible to map to num

    var mapped;
    if( mapData ){
      mapped = types.mapData;
    } else if( mapLayoutData ){
      mapped = types.mapLayoutData;
    } else {
      mapped = types.mapScratch;
    }

    mapData = mapData || mapLayoutData || mapScratch;

    // we can map only if the type is a colour or a number
    if( !(type.color || type.number) ){ return false; }

    var valueMin = this.parse( name, mapData[4] ); // parse to validate
    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

    var valueMax = this.parse( name, mapData[5] ); // parse to validate
    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if( valueMin.value === valueMax.value ){
      return false; // can't make much of a mapper without a range

    } else if( type.color ){
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
        && c1[1] === c2[1] // green
        && c1[2] === c2[2] // blue
        && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (
            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
            &&
            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          )
        )
      ;

      if( same ){ return false; } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: mapped,
      field: mapData[1],
      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
      fieldMax: parseFloat( mapData[3] ),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if( type.multiple && propIsFlat !== 'multiple' ){
    var vals;

    if( valueIsString ){
      vals = value.split( /\s+/ );
    } else if( is.array( value ) ){
      vals = value;
    } else {
      vals = [ value ];
    }

    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var hasEnum = false;

    for( var i = 0; i < vals.length; i++ ){
      var p = self.parse( name, vals[i], propIsBypass, 'multiple' );

      hasEnum = hasEnum || is.string( p.value );

      valArr.push( p.value );
      pfValArr.push( p.pfValue != null ? p.pfValue : p.value );
      unitsArr.push( p.units );
    }

    if( type.validate && !type.validate( valArr, unitsArr ) ){
      return null;
    }

    if( type.singleEnum && hasEnum ){
      if( valArr.length === 1 && is.string( valArr[0] ) ){
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: valArr.join( ' ' ),
      bypass: propIsBypass,
      units: unitsArr
    };
  }

  // several types also allow enums
  var checkEnums = function(){
    for( var i = 0; i < type.enums.length; i++ ){
      var en = type.enums[ i ];

      if( en === value ){
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if( type.number ){
    var units;
    var implicitUnits = 'px'; // not set => px

    if( type.units ){ // use specified units if set
      units = type.units;
    }

    if( type.implicitUnits ){
      implicitUnits = type.implicitUnits;
    }

    if( !type.unitless ){
      if( valueIsString ){
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if( units ){ unitsRegex = units; } // only allow explicit units if so set
        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );

        if( match ){
          value = match[1];
          units = match[2] || implicitUnits;
        }

      } else if( !units || type.implicitUnits ){
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat( value );

    // if not a number and enums not allowed, then the value is invalid
    if( isNaN( value ) && type.enums === undefined ){
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if( isNaN( value ) && type.enums !== undefined ){
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if( type.integer && !is.integer( value ) ){
      return null;
    }

    // check value is within range
    if( ( type.min !== undefined && ( value < type.min || (type.strictMin && value === type.min) ) )
    ||  ( type.max !== undefined && ( value > type.max || (type.strictMax && value === type.max) ) )
    ){
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if( type.unitless || (units !== 'px' && units !== 'em') ){
      ret.pfValue = value;
    } else {
      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
    }

    // normalise value in ms
    if( units === 'ms' || units === 's' ){
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if( units === 'deg' || units === 'rad' ){
      ret.pfValue = units === 'rad' ? value : math.deg2rad( value );
    }

    // normalize value in %
    if( units === '%' ){
      ret.pfValue = value / 100;
    }

    return ret;

  } else if( type.propList ){

    var props = [];
    var propsStr = '' + value;

    if( propsStr === 'none' ){
      // leave empty

    } else { // go over each prop

      var propsSplit = propsStr.split( ',' );
      for( var i = 0; i < propsSplit.length; i++ ){
        var propName = propsSplit[ i ].trim();

        if( self.properties[ propName ] ){
          props.push( propName );
        }
      }

      if( props.length === 0 ){ return null; }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join( ', ' ),
      bypass: propIsBypass
    };

  } else if( type.color ){
    var tuple = util.color2tuple( value );

    if( !tuple ){ return null; }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: '' + value,
      bypass: propIsBypass,
      roundValue: true
    };

  } else if( type.regex || type.regexes ){

    // first check enums
    if( type.enums ){
      var enumProp = checkEnums();

      if( enumProp ){ return enumProp; }
    }

    var regexes = type.regexes ? type.regexes : [ type.regex ];

    for( var i = 0; i < regexes.length; i++ ){
      var regex = new RegExp( regexes[ i ] ); // make a regex from the type string
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };

      }
    }

    return null; // didn't match any

  } else if( type.string ){
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };

  } else if( type.enums ){ // check enums last because it's a combo type in others
    return checkEnums();

  } else {
    return null; // not a type we can handle
  }

};

module.exports = styfn;

},{"../is":86,"../math":88,"../util":103}],98:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

(function(){
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
  var mapData = function( prefix ){
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: [ 'parent', 'origin' ] },
    nodeSize: { number: true, min: 0, enums: [ 'label' ] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    sizeMaybePercent: { number: true, min: 0, allowPercent: true },
    bgWH: { number: true, min: 0, allowPercent: true, enums: [ 'auto' ] },
    bgPos: { number: true, allowPercent: true },
    bgRepeat: { enums: [ 'repeat', 'repeat-x', 'repeat-y', 'no-repeat' ] },
    bgFit: { enums: [ 'none', 'contain', 'cover' ] },
    bgCrossOrigin: { enums: [ 'anonymous', 'use-credentials' ] },
    bgClip: { enums: [ 'none', 'node' ] },
    color: { color: true },
    bool: { enums: [ 'yes', 'no' ] },
    lineStyle: { enums: [ 'solid', 'dotted', 'dashed' ] },
    borderStyle: { enums: [ 'solid', 'dotted', 'dashed', 'double' ] },
    curveStyle: { enums: [ 'bezier', 'unbundled-bezier', 'haystack', 'segments' ] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontVariant: { enums: [ 'small-caps', 'normal' ] },
    fontStyle: { enums: [ 'italic', 'normal', 'oblique' ] },
    fontWeight: { enums: [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900 ] },
    textDecoration: { enums: [ 'none', 'underline', 'overline', 'line-through' ] },
    textTransform: { enums: [ 'none', 'uppercase', 'lowercase' ] },
    textWrap: { enums: [ 'none', 'wrap', 'ellipsis' ] },
    textBackgroundShape: { enums: [ 'rectangle', 'roundrectangle' ]},
    nodeShape: { enums: [ 'rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon' ] },
    compoundIncludeLabels: { enums: [ 'include', 'exclude' ] },
    arrowShape: { enums: [ 'tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none' ] },
    arrowFill: { enums: [ 'filled', 'hollow' ] },
    display: { enums: [ 'element', 'none' ] },
    visibility: { enums: [ 'hidden', 'visible' ] },
    zCompoundDepth: { enums: [ 'bottom', 'orphan', 'auto', 'top' ] },
    zIndexCompare: { enums: [ 'auto', 'manual' ] },
    valign: { enums: [ 'top', 'center', 'bottom' ] },
    halign: { enums: [ 'left', 'center', 'right' ] },
    text: { string: true },
    data: { mapping: true, regex: data( 'data' ) },
    layoutData: { mapping: true, regex: data( 'layoutData' ) },
    scratch: { mapping: true, regex: data( 'scratch' ) },
    mapData: { mapping: true, regex: mapData( 'mapData' ) },
    mapLayoutData: { mapping: true, regex: mapData( 'mapLayoutData' ) },
    mapScratch: { mapping: true, regex: mapData( 'mapScratch' ) },
    fn: { mapping: true, fn: true },
    url: { regex: 'url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)|none|(.+)$' },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: [ 'none', 'autorotate' ] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    edgeDistances: { enums: ['intersection', 'node-position'] },
    edgeEndpoint: {
      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
      enums: [ 'inside-to-node', 'outside-to-node', 'outside-to-line' ], singleEnum: true,
      validate: function( valArr, unitsArr ){
        switch( valArr.length ){
          case 2: // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
          case 1: // can be enum, deg, or rad only
            return is.string( valArr[0] ) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
          default:
            return false;
        }
      }
    },
    easing: {
      regexes: [
        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
      ],
      enums: [
        'linear',
        'ease', 'ease-in', 'ease-out', 'ease-in-out',
        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
      ]
    }
  };

  var zOrderDiff = {
    zeroNonZero: function( val1, val2 ){
      if( val1 === 0 && val2 !== 0 ){
        return true;
      } else if( val1 !== 0 && val2 === 0 ){
        return true;
      } else {
        return false;
      }
    },
    anyDiff: function( val1, val2 ){
      return val1 !== val2;
    }
  };

  var zd = zOrderDiff;

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
    // main label
    { name: 'label', type: t.text },
    { name: 'text-rotation', type: t.textRotation },
    { name: 'text-margin-x', type: t.bidirectionalSize },
    { name: 'text-margin-y', type: t.bidirectionalSize },

    // source label
    { name: 'source-label', type: t.text },
    { name: 'source-text-rotation', type: t.textRotation },
    { name: 'source-text-margin-x', type: t.bidirectionalSize },
    { name: 'source-text-margin-y', type: t.bidirectionalSize },
    { name: 'source-text-offset', type: t.size },

    // target label
    { name: 'target-label', type: t.text },
    { name: 'target-text-rotation', type: t.textRotation },
    { name: 'target-text-margin-x', type: t.bidirectionalSize },
    { name: 'target-text-margin-y', type: t.bidirectionalSize },
    { name: 'target-text-offset', type: t.size },

    // common label style
    { name: 'text-valign', type: t.valign },
    { name: 'text-halign', type: t.halign },
    { name: 'color', type: t.color },
    { name: 'text-outline-color', type: t.color },
    { name: 'text-outline-width', type: t.size },
    { name: 'text-outline-opacity', type: t.zeroOneNumber },
    { name: 'text-opacity', type: t.zeroOneNumber },
    { name: 'text-background-color', type: t.color },
    { name: 'text-background-opacity', type: t.zeroOneNumber },
    { name: 'text-background-padding', type: t.size },
    { name: 'text-border-opacity', type: t.zeroOneNumber },
    { name: 'text-border-color', type: t.color },
    { name: 'text-border-width', type: t.size },
    { name: 'text-border-style', type: t.borderStyle },
    { name: 'text-background-shape', type: t.textBackgroundShape},
    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
    { name: 'text-transform', type: t.textTransform },
    { name: 'text-wrap', type: t.textWrap },
    { name: 'text-max-width', type: t.size },
    { name: 'text-events', type: t.bool },
    { name: 'font-family', type: t.fontFamily },
    { name: 'font-style', type: t.fontStyle },
    // { name: 'font-variant', type: t.fontVariant }, // not useful
    { name: 'font-weight', type: t.fontWeight },
    { name: 'font-size', type: t.size },
    { name: 'min-zoomed-font-size', type: t.size },

    // behaviour
    { name: 'events', type: t.bool },

    // visibility
    { name: 'display', type: t.display, triggersZOrder: zd.anyDiff },
    { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff },
    { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero },
    { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff },
    { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff },
    { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

    // overlays
    { name: 'overlay-padding', type: t.size },
    { name: 'overlay-color', type: t.color },
    { name: 'overlay-opacity', type: t.zeroOneNumber },

    // shadows
    { name: 'shadow-blur', type: t.size },
    { name: 'shadow-color', type: t.color },
    { name: 'shadow-opacity', type: t.zeroOneNumber },
    { name: 'shadow-offset-x', type: t.bidirectionalSize },
    { name: 'shadow-offset-y', type: t.bidirectionalSize },

    // label shadows
    { name: 'text-shadow-blur', type: t.size },
    { name: 'text-shadow-color', type: t.color },
    { name: 'text-shadow-opacity', type: t.zeroOneNumber },
    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },
    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },

    // transition anis
    { name: 'transition-property', type: t.propList },
    { name: 'transition-duration', type: t.time },
    { name: 'transition-delay', type: t.time },
    { name: 'transition-timing-function', type: t.easing },

    // node body
    { name: 'height', type: t.nodeSize },
    { name: 'width', type: t.nodeSize },
    { name: 'shape', type: t.nodeShape },
    { name: 'shape-polygon-points', type: t.polygonPointList },
    { name: 'background-color', type: t.color },
    { name: 'background-opacity', type: t.zeroOneNumber },
    { name: 'background-blacken', type: t.nOneOneNumber },
    { name: 'padding', type: t.size },

    // node border
    { name: 'border-color', type: t.color },
    { name: 'border-opacity', type: t.zeroOneNumber },
    { name: 'border-width', type: t.size },
    { name: 'border-style', type: t.borderStyle },

    // node background images
    { name: 'background-image', type: t.url },
    { name: 'background-image-crossorigin', type: t.bgCrossOrigin },
    { name: 'background-image-opacity', type: t.zeroOneNumber },
    { name: 'background-position-x', type: t.bgPos },
    { name: 'background-position-y', type: t.bgPos },
    { name: 'background-repeat', type: t.bgRepeat },
    { name: 'background-fit', type: t.bgFit },
    { name: 'background-clip', type: t.bgClip },
    { name: 'background-width', type: t.bgWH },
    { name: 'background-height', type: t.bgWH },

    // compound props
    { name: 'position', type: t.position },
    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },
    { name: 'min-width', type: t.size },
    { name: 'min-width-bias-left', type: t.sizeMaybePercent },
    { name: 'min-width-bias-right', type: t.sizeMaybePercent },
    { name: 'min-height', type: t.size },
    { name: 'min-height-bias-top', type: t.sizeMaybePercent },
    { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

    // edge line
    { name: 'line-style', type: t.lineStyle },
    { name: 'line-color', type: t.color },
    { name: 'curve-style', type: t.curveStyle },
    { name: 'haystack-radius', type: t.zeroOneNumber },
    { name: 'source-endpoint', type: t.edgeEndpoint },
    { name: 'target-endpoint', type: t.edgeEndpoint },
    { name: 'control-point-step-size', type: t.size },
    { name: 'control-point-distances', type: t.bidirectionalSizes },
    { name: 'control-point-weights', type: t.numbers },
    { name: 'segment-distances', type: t.bidirectionalSizes },
    { name: 'segment-weights', type: t.numbers },
    { name: 'edge-distances', type: t.edgeDistances },
    { name: 'arrow-scale', type: t.positiveNumber },
    { name: 'loop-direction', type: t.angle },
    { name: 'loop-sweep', type: t.angle },
    { name: 'source-distance-from-node', type: t.size },
    { name: 'target-distance-from-node', type: t.size },

    // these are just for the core
    { name: 'selection-box-color', type: t.color },
    { name: 'selection-box-opacity', type: t.zeroOneNumber },
    { name: 'selection-box-border-color', type: t.color },
    { name: 'selection-box-border-width', type: t.size },
    { name: 'active-bg-color', type: t.color },
    { name: 'active-bg-opacity', type: t.zeroOneNumber },
    { name: 'active-bg-size', type: t.size },
    { name: 'outside-texture-bg-color', type: t.color },
    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
  ];

  // define aliases
  var aliases = styfn.aliases = [
    { name: 'content', pointsTo: 'label' },
    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
    { name: 'control-point-weight', pointsTo: 'control-point-weights' },
    { name: 'edge-text-rotation', pointsTo: 'text-rotation' },
    { name: 'padding-left', pointsTo: 'padding' },
    { name: 'padding-right', pointsTo: 'padding' },
    { name: 'padding-top', pointsTo: 'padding' },
    { name: 'padding-bottom', pointsTo: 'padding' }
  ];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push( { name: 'pie-size', type: t.sizeMaybePercent } );
  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
    props.push( { name: 'pie-' + i + '-background-color', type: t.color } );
    props.push( { name: 'pie-' + i + '-background-size', type: t.percent } );
    props.push( { name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber } );
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = [ 'source', 'mid-source', 'target', 'mid-target' ];
  [
    { name: 'arrow-shape', type: t.arrowShape },
    { name: 'arrow-color', type: t.color },
    { name: 'arrow-fill', type: t.arrowFill }
  ].forEach( function( prop ){
    arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push( { name: name, type: type } );
    } );
  }, {} );

  // list of property names
  styfn.propertyNames = props.map( function( p ){ return p.name; } );

  // allow access of properties by name ( e.g. style.properties.height )
  for( var i = 0; i < props.length; i++ ){
    var prop = props[ i ];

    props[ prop.name ] = prop; // allow lookup by name
  }

  // map aliases
  for( var i = 0; i < aliases.length; i++ ){
    var alias = aliases[ i ];
    var pointsToProp = props[ alias.pointsTo ];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push( aliasProp );

    props[ alias.name ] = aliasProp; // allow lookup by name
  }
})();

styfn.getDefaultProperty = function( name ){
  return this.getDefaultProperties()[ name ];
};

styfn.getDefaultProperties = util.memoize( function(){
  var rawProps = util.extend( {
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    // 'font-variant': fontVariant,
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'shadow-opacity': 0,
    'shadow-color': '#000',
    'shadow-blur': 10,
    'shadow-offset-x': 0,
    'shadow-offset-y': 0,
    'text-shadow-opacity': 0,
    'text-shadow-color': '#000',
    'text-shadow-blur': 5,
    'text-shadow-offset-x': 0,
    'text-shadow-offset-y': 0,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',

    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

    // compound props
    'padding': 0,
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [
    { name: 'pie-{{i}}-background-color', value: 'black' },
    { name: 'pie-{{i}}-background-size', value: '0%' },
    { name: 'pie-{{i}}-background-opacity', value: 1 }
  ].reduce( function( css, prop ){
    for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
      var name = prop.name.replace( '{{i}}', i );
      var val = prop.value;

      css[ name ] = val;
    }

    return css;
  }, {} ), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'edge-distances': 'intersection',
    'curve-style': 'bezier',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-135deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node'
  }, [
    { name: 'arrow-shape', value: 'none' },
    { name: 'arrow-color', value: '#999' },
    { name: 'arrow-fill', value: 'filled' }
  ].reduce( function( css, prop ){
    styfn.arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var val = prop.value;

      css[ name ] = val;
    } );

    return css;
  }, {} ) );

  var parsedProps = {};

  for( var i = 0; i < this.properties.length; i++ ){
    var prop = this.properties[i];

    if( prop.pointsTo ){ continue; }

    var name = prop.name;
    var val = rawProps[ name ];
    var parsedProp = this.parse( name, val );

    parsedProps[ name ] = parsedProp;
  }

  return parsedProps;
} );

styfn.addDefaultStylesheet = function(){
  this
    .selector( '$node > node' ) // compound (parent) node properties
      .css( {
        'shape': 'rectangle',
        'padding': 10,
        'background-color': '#eee',
        'border-color': '#ccc',
        'border-width': 1
      } )
    .selector( 'edge' ) // just edge properties
      .css( {
        'width': 3,
        'curve-style': 'haystack'
      } )
    .selector( ':selected' )
      .css( {
        'background-color': '#0169D9',
        'line-color': '#0169D9',
        'source-arrow-color': '#0169D9',
        'target-arrow-color': '#0169D9',
        'mid-source-arrow-color': '#0169D9',
        'mid-target-arrow-color': '#0169D9'
      } )
    .selector( 'node:parent:selected' )
      .css( {
        'background-color': '#CCE1F9',
        'border-color': '#aec8e5'
      } )
    .selector( ':active' )
      .css( {
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      } )
    .selector( 'core' ) // just core properties
      .css( {
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125
      } )
  ;

  this.defaultLength = this.length;
};

module.exports = styfn;

},{"../is":86,"../util":103}],99:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var Selector = require( '../selector' );

var styfn = {};

styfn.applyFromString = function( string ){
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;

  // remove comments from the style string
  remaining = remaining.replace( /[/][*](\s|.)+?[*][/]/g, '' );

  function removeSelAndBlockFromRemaining(){
    // remove the parsed selector and block from the remaining text to parse
    if( remaining.length > selAndBlockStr.length ){
      remaining = remaining.substr( selAndBlockStr.length );
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem(){
    // remove the parsed property and value from the remaining block text to parse
    if( blockRem.length > propAndValStr.length ){
      blockRem = blockRem.substr( propAndValStr.length );
    } else {
      blockRem = '';
    }
  }

  while( true ){
    var nothingLeftToParse = remaining.match( /^\s*$/ );
    if( nothingLeftToParse ){ break; }

    var selAndBlock = remaining.match( /^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/ );

    if( !selAndBlock ){
      util.error( 'Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining );
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if( selectorStr !== 'core' ){
      var selector = new Selector( selectorStr );
      if( selector._private.invalid ){
        util.error( 'Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr );

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while( true ){
      var nothingLeftToParse = blockRem.match( /^\s*$/ );
      if( nothingLeftToParse ){ break; }

      var propAndVal = blockRem.match( /^\s*(.+?)\s*:\s*(.+?)\s*;/ );

      if( !propAndVal ){
        util.error( 'Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr );
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[ propStr ];
      if( !prop ){
        util.error( 'Skipping property: Invalid property name in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse( propStr, valStr );

      if( !parsedProp ){
        util.error( 'Skipping property: Invalid property definition in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push( {
        name: propStr,
        val: valStr
      } );
      removePropAndValFromRem();
    }

    if( invalidBlock ){
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector( selectorStr );
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      style.css( prop.name, prop.val );
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function( string ){
  var style = this;

  style.resetToDefault();
  style.applyFromString( string );

  return style;
};

module.exports = styfn;

},{"../selector":90,"../util":103}],100:[function(require,module,exports){
'use strict';

var is = require( './is' );
var util = require( './util' );
var Style = require( './style' );

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function(){
  if( !(this instanceof Stylesheet) ){
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function(){
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function( selector ){
  var i = this.length++;

  this[ i ] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function( name, value ){
  var i = this.length - 1;

  if( is.string( name ) ){
    this[ i ].properties.push( {
      name: name,
      value: value
    } );
  } else if( is.plainObject( name ) ){
    var map = name;

    for( var j = 0; j < Style.properties.length; j++ ){
      var prop = Style.properties[ j ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){ // also try camel case name
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        var name = prop.name;
        var value = mapVal;

        this[ i ].properties.push( {
          name: name,
          value: value
        } );
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function( cy ){
  var style = new Style( cy );

  for( var i = 0; i < this.length; i++ ){
    var context = this[ i ];
    var selector = context.selector;
    var props = context.properties;

    style.selector( selector ); // apply selector

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];

      style.css( prop.name, prop.value ); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

},{"./is":86,"./style":95,"./util":103}],101:[function(require,module,exports){
(function (__dirname){
/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */

// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

'use strict';

var window = require('./window');
var util = require('./util');
var Promise = require('./promise');
var Event = require('./event');
var define = require('./define');
var is = require('./is');

var Thread = function( opts ){
  if( !(this instanceof Thread) ){
    return new Thread( opts );
  }

  var _p = this._private = {
    requires: [],
    files: [],
    queue: null,
    pass: [],
    disabled: false
  };

  if( is.plainObject(opts) ){
    if( opts.disabled != null ){
      _p.disabled = !!opts.disabled;
    }
  }

};

var thdfn = Thread.prototype; // short alias

var stringifyFieldVal = function( val ){
  var valStr = is.fn( val ) ? val.toString() : "JSON.parse('" + JSON.stringify(val) + "')";

  return valStr;
};

// allows for requires with prototypes and subobjs etc
var fnAsRequire = function( fn ){
  var req;
  var fnName;

  if( is.object(fn) && fn.fn ){ // manual fn
    req = fnAs( fn.fn, fn.name );
    fnName = fn.name;
    fn = fn.fn;
  } else if( is.fn(fn) ){ // auto fn
    req = fn.toString();
    fnName = fn.name;
  } else if( is.string(fn) ){ // stringified fn
    req = fn;
  } else if( is.object(fn) ){ // plain object
    if( fn.proto ){
      req = '';
    } else {
      req = fn.name + ' = {};';
    }

    fnName = fn.name;
    fn = fn.obj;
  }

  req += '\n';

  var protoreq = function( val, subname ){
    if( val.prototype ){
      var protoNonempty = false;
      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line

      if( protoNonempty ){
        req += fnAsRequire( {
          name: subname,
          obj: val,
          proto: true
        }, val );
      }
    }
  };

  // pull in prototype
  if( fn.prototype && fnName != null ){

    for( var name in fn.prototype ){
      var protoStr = '';

      var val = fn.prototype[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '.prototype.' + name;

      protoStr += subname + ' = ' + valStr + ';\n';

      if( protoStr ){
        req += protoStr;
      }

      protoreq( val, subname ); // subobject with prototype
    }

  }

  // pull in properties for obj/fns
  if( !is.string(fn) ){ for( var name in fn ){
    var propsStr = '';

    if( fn.hasOwnProperty(name) ){
      var val = fn[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '["' + name + '"]';

      propsStr += subname + ' = ' + valStr + ';\n';
    }

    if( propsStr ){
      req += propsStr;
    }

    protoreq( val, subname ); // subobject with prototype
  } }

  return req;
};

var isPathStr = function( str ){
  return is.string(str) && str.match(/\.js$/);
};

util.extend(thdfn, {

  instanceString: function(){ return 'thread'; },

  require: function( fn, as ){
    var requires = this._private.requires;

    if( isPathStr(fn) ){
      this._private.files.push( fn );

      return this;
    }

    if( as ){
      if( is.fn(fn) ){
        fn = { name: as, fn: fn };
      } else {
        fn = { name: as, obj: fn };
      }
    } else {
      if( is.fn(fn) ){
        if( !fn.name ){
          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, "someFunction" )';
        }

        fn = { name: fn.name, fn: fn };
      }
    }

    requires.push( fn );

    return this; // chaining
  },

  pass: function( data ){
    this._private.pass.push( data );

    return this; // chaining
  },

  run: function( fn, pass ){ // fn used like main()
    var self = this;
    var _p = this._private;
    pass = pass || _p.pass.shift();

    if( _p.stopped ){
      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';
    }

    if( _p.running ){
      return ( _p.queue = _p.queue.then(function(){ // inductive step
        return self.run( fn, pass );
      }) );
    }

    var useWW = window != null && !_p.disabled;
    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;

    self.trigger('run');

    var runP = new Promise(function( resolve, reject ){

      _p.running = true;

      var threadTechAlreadyExists = _p.ran;

      var fnImplStr = is.string( fn ) ? fn : fn.toString();

      // worker code to exec
      var fnStr = '\n' + ( _p.requires.map(function( r ){
        return fnAsRequire( r );
      }) ).concat( _p.files.map(function( f ){
        if( useWW ){
          var wwifyFile = function( file ){
            if( file.match(/^\.\//) || file.match(/^\.\./) ){
              return window.location.origin + window.location.pathname + file;
            } else if( file.match(/^\//) ){
              return window.location.origin + '/' + file;
            }
            return file;
          };

          return 'importScripts("' + wwifyFile(f) + '");';
        } else if( useNode ) {
          return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
        } else {
          throw 'External file `' + f + '` can not be required without any threading technology.';
        }
      }) ).concat([
        '( function(){',
          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
        '} )()\n'
      ]).join('\n');

      // because we've now consumed the requires, empty the list so we don't dupe on next run()
      _p.requires = [];
      _p.files = [];

      if( useWW ){
        var fnBlob, fnUrl;

        // add normalised thread api functions
        if( !threadTechAlreadyExists ){
          var fnPre = fnStr + '';

          fnStr = [
            'function _ref_(o){ return eval(o); };',
            'function broadcast(m){ return message(m); };', // alias
            'function message(m){ postMessage(m); };',
            'function listen(fn){',
            '  self.addEventListener("message", function(m){ ',
            '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
            '    } else { ',
            '      fn( m.data );',
            '    }',
            '  });',
            '};',
            'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
            'function resolve(v){ postMessage({ $$resolve: v }); };',
            'function reject(v){ postMessage({ $$reject: v }); };'
          ].join('\n');

          fnStr += fnPre;

          fnBlob = new Blob([ fnStr ], {
            type: 'application/javascript'
          });
          fnUrl = window.URL.createObjectURL( fnBlob );
        }
        // create webworker and let it exec the serialised code
        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

        if( threadTechAlreadyExists ){ // then just exec new run() code
          ww.postMessage({
            $$eval: fnStr
          });
        }

        // worker messages => events
        var cb;
        ww.addEventListener('message', cb = function( m ){
          var isObject = is.object(m) && is.object( m.data );

          if( isObject && ('$$resolve' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c resolve()

            resolve( m.data.$$resolve );
          } else if( isObject && ('$$reject' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c reject()

            reject( m.data.$$reject );
          } else {
            self.trigger( new Event(m, { type: 'message', message: m.data }) );
          }
        }, false);

        if( !threadTechAlreadyExists ){
          ww.postMessage('$$start'); // start up the worker
        }

      } else if( useNode ){
        // create a new process

        if( !_p.child ){
          _p.child = ( require('child_process').fork( require('path').join(__dirname, 'thread-node-fork') ) );
        }

        var child = _p.child;

        // child process messages => events
        var cb;
        child.on('message', cb = function( m ){
          if( is.object(m) && ('$$resolve' in m) ){
            child.removeListener('message', cb); // done listening b/c resolve()

            resolve( m.$$resolve );
          } else if( is.object(m) && ('$$reject' in m) ){
            child.removeListener('message', cb); // done listening b/c reject()

            reject( m.$$reject );
          } else {
            self.trigger( new Event({}, { type: 'message', message: m }) );
          }
        });

        // ask the child process to eval the worker code
        child.send({
          $$eval: fnStr
        });

      } else { // use a fallback mechanism using a timeout

        var promiseResolve = resolve;
        var promiseReject = reject;

        var timer = _p.timer = _p.timer || {

          listeners: [],

          exec: function(){
            // as a string so it can't be mangled by minifiers and processors
            fnStr = [
              'function _ref_(o){ return eval(o); };',
              'function broadcast(m){ return message(m); };',
              'function message(m){ self.trigger( new Event({}, { type: "message", message: m }) ); };',
              'function listen(fn){ timer.listeners.push( fn ); };',
              'function resolve(v){ promiseResolve(v); };',
              'function reject(v){ promiseReject(v); };'
            ].join('\n') + fnStr;

            // the .run() code
            eval( fnStr ); // jshint ignore:line
          },

          message: function( m ){
            var ls = timer.listeners;

            for( var i = 0; i < ls.length; i++ ){
              var fn = ls[i];

              fn( m );
            }
          }

        };

        timer.exec();
      }

    }).then(function( v ){
      _p.running = false;
      _p.ran = true;

      self.trigger('ran');

      return v;
    });

    if( _p.queue == null ){
      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
    }

    return runP;
  },

  // send the thread a message
  message: function( m ){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.postMessage( m );
    }

    if( _p.child ){
      _p.child.send( m );
    }

    if( _p.timer ){
      _p.timer.message( m );
    }

    return this; // chaining
  },

  stop: function(){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.terminate();
    }

    if( _p.child ){
      _p.child.kill();
    }

    if( _p.timer ){
      // nothing we can do if we've run a timeout
    }

    _p.stopped = true;

    return this.trigger('stop'); // chaining
  },

  stopped: function(){
    return this._private.stopped;
  }

});

// turns a stringified function into a (re)named function
var fnAs = function( fn, name ){
  var fnStr = fn.toString();
  fnStr = fnStr.replace(/function\s*?\S*?\s*?\(/, 'function ' + name + '(');

  return fnStr;
};

var defineFnal = function( opts ){
  opts = opts || {};

  return function fnalImpl( fn, arg1 ){
    var fnStr = fnAs( fn, '_$_$_' + opts.name );

    this.require( fnStr );

    return this.run( [
      'function( data ){',
      '  var origResolve = resolve;',
      '  var res = [];',
      '  ',
      '  resolve = function( val ){',
      '    res.push( val );',
      '  };',
      '  ',
      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
      '  ',
      '  resolve = origResolve;',
      '  resolve( res.length > 0 ? res : ret );',
      '}'
    ].join('\n') );
  };
};

util.extend(thdfn, {
  reduce: defineFnal({ name: 'reduce' }),

  reduceRight: defineFnal({ name: 'reduceRight' }),

  map: defineFnal({ name: 'map' })
});

// aliases
var fn = thdfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(thdfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( thdfn );

module.exports = Thread;

}).call(this,"/node_modules/cytoscape/src")

},{"./define":47,"./event":48,"./is":86,"./promise":89,"./util":103,"./window":110,"child_process":3,"path":114}],102:[function(require,module,exports){
'use strict';

var is = require( '../is' );

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function( hex ){
    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== '#' ){ return; }

    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;

    if( shortHex ){
      r = parseInt( hex[1] + hex[1], base );
      g = parseInt( hex[2] + hex[2], base );
      b = parseInt( hex[3] + hex[3], base );
    } else {
      r = parseInt( hex[1] + hex[2], base );
      g = parseInt( hex[3] + hex[4], base );
      b = parseInt( hex[5] + hex[6], base );
    }

    return [ r, g, b ];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function( hsl ){
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb( p, q, t ){
      if( t < 0 ) t += 1;
      if( t > 1 ) t -= 1;
      if( t < 1 / 6 ) return p + (q - p) * 6 * t;
      if( t < 1 / 2 ) return q;
      if( t < 2 / 3 ) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    var m = new RegExp( '^' + this.regex.hsla + '$' ).exec( hsl );
    if( m ){

      // get hue
      h = parseInt( m[1] );
      if( h < 0 ){
        h = ( 360 - (-1 * h % 360) ) % 360;
      } else if( h > 360 ){
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat( m[2] );
      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
      s = s / 100; // normalise on [0, 1]

      l = parseFloat( m[3] );
      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
      l = l / 100; // normalise on [0, 1]

      a = m[4];
      if( a !== undefined ){
        a = parseFloat( a );

        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if( s === 0 ){
        r = g = b = Math.round( l * 255 ); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round( 255 * hue2rgb( p, q, h + 1 / 3 ) );
        g = Math.round( 255 * hue2rgb( p, q, h ) );
        b = Math.round( 255 * hue2rgb( p, q, h - 1 / 3 ) );
      }

      ret = [ r, g, b, a ];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function( rgb ){
    var ret;

    var m = new RegExp( '^' + this.regex.rgba + '$' ).exec( rgb );
    if( m ){
      ret = [];

      var isPct = [];
      for( var i = 1; i <= 3; i++ ){
        var channel = m[ i ];

        if( channel[ channel.length - 1 ] === '%' ){
          isPct[ i ] = true;
        }
        channel = parseFloat( channel );

        if( isPct[ i ] ){
          channel = channel / 100 * 255; // normalise to [0, 255]
        }

        if( channel < 0 || channel > 255 ){ return; } // invalid channel value

        ret.push( Math.floor( channel ) );
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

      var alpha = m[4];
      if( alpha !== undefined ){
        alpha = parseFloat( alpha );

        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

        ret.push( alpha );
      }
    }

    return ret;
  },

  colorname2tuple: function( color ){
    return this.colors[ color.toLowerCase() ];
  },

  color2tuple: function( color ){
    return ( is.array( color ) ? color : null )
      || this.colorname2tuple( color )
      || this.hex2tuple( color )
      || this.rgb2tuple( color )
      || this.hsl2tuple( color );
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [ 240, 248, 255 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [0, 0, 0],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 135 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    cyan: [0, 255, 255 ],
    darkblue: [0, 0, 139 ],
    darkcyan: [0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [0, 100, 0],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    grey: [ 128, 128, 128 ],
    green: [0, 128, 0],
    greenyellow: [ 173, 255, 47 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [0, 255, 0],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    magenta: [ 255, 0, 255 ],
    maroon: [ 128, 0, 0],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0],
    orangered: [ 255, 69, 0],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    red: [ 255, 0, 0],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 192 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0],
    yellowgreen: [ 154, 205, 50 ]
  }
};

},{"../is":86}],103:[function(require,module,exports){
'use strict';

/*global console */

var is = require( '../is' );
var math = require( '../math' );

var util = {

  trueify: function(){ return true; },

  falsify: function(){ return false; },

  zeroify: function(){ return 0; },

  noop: function(){},

  error: function( msg ){
    /* eslint-disable */
    if( console.error ){
      console.error.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    } else {
      console.log.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    }
    /* eslint-enable */
  },

  clone: function( obj ){
    return this.extend( {}, obj );
  },

  // gets a shallow copy of the argument
  copy: function( obj ){
    if( obj == null ){
      return obj;
    } if( is.array( obj ) ){
      return obj.slice();
    } else if( is.plainObject( obj ) ){
      return this.clone( obj );
    } else {
      return obj;
    }
  },

  uuid: function(
      a,b                // placeholders
  ){
      for(               // loop :)
          b=a='';        // b - result , a - numeric variable
          a++<36;        //
          b+=a*51&52  // if "a" is not 9 or 14 or 19 or 24
                      ?  //  return a random number or 4
             (
               a^15      // if "a" is not 15
                  ?      // genetate a random number from 0 to 15
               8^Math.random()*
               (a^20?16:4)  // unless "a" is 20, in which case a random number from 8 to 11
                  :
               4            //  otherwise 4
               ).toString(16)
                      :
             '-'            //  in other cases (if "a" is 9,14,19,24) insert "-"
          );
      return b;
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind( math );

util._staticEmptyObject = {};

util.staticEmptyObject = function(){
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign : function( tgt ){
  var args = arguments;

  for( var i = 1; i < args.length; i++ ){
    var obj = args[ i ];

    if( !obj ){ continue; }

    var keys = Object.keys( obj );

    for( var j = 0; j < keys.length; j++ ){
      var k = keys[j];

      tgt[ k ] = obj[ k ];
    }
  }

  return tgt;
};

util.default = function( val, def ){
  if( val === undefined ){
    return def;
  } else {
    return val;
  }
};

util.removeFromArray = function( arr, ele, manyCopies ){
  for( var i = arr.length; i >= 0; i-- ){
    if( arr[i] === ele ){
      arr.splice( i, 1 );

      if( !manyCopies ){ break; }
    }
  }
};

util.clearArray = function( arr ){
  arr.splice( 0, arr.length );
};

util.getPrefixedProperty = function( obj, propName, prefix ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[ propName ];
};

util.setPrefixedProperty = function( obj, propName, prefix, value ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[ propName ] = value;
};

[
  require( './colors' ),
  require( './maps' ),
  { memoize: require( './memoize' ) },
  require( './regex' ),
  require( './strings' ),
  require( './timing' )
].forEach( function( req ){
  util.extend( util, req );
} );

module.exports = util;

},{"../is":86,"../math":88,"./colors":102,"./maps":104,"./memoize":105,"./regex":106,"./strings":107,"./timing":108}],104:[function(require,module,exports){
'use strict';

var is = require( '../is' );

module.exports = {
  // has anything been set in the map
  mapEmpty: function( map ){
    var empty = true;

    if( map != null ){
      return Object.keys( map ).length === 0;
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function( options ){
    var array = this.getMap( options );

    if( array == null ){ // if empty, put initial array
      this.setMap( this.extend( {}, options, {
        value: [ options.value ]
      } ) );
    } else {
      array.push( options.value );
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function( options ){
    var obj = options.map;
    var key;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to set map with object key' );
      }

      if( i < keys.length - 1 ){

        // extend the map if necessary
        if( obj[ key ] == null ){
          obj[ key ] = {};
        }

        obj = obj[ key ];
      } else {
        // set the value
        obj[ key ] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to get map with object key' );
      }

      obj = obj[ key ];

      if( obj == null ){
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to delete map with object key' );
      }

      var lastKey = i === options.keys.length - 1;
      if( lastKey ){

        if( keepChildren ){ // then only delete child fields not in keepChildren
          var children = Object.keys( obj );

          for( var j = 0; j < children.length; j++ ){
            var child = children[j];

            if( !keepChildren[ child ] ){
              obj[ child ] = undefined;
            }
          }
        } else {
          obj[ key ] = undefined;
        }

      } else {
        obj = obj[ key ];
      }
    }
  }
};

},{"../is":86}],105:[function(require,module,exports){
'use strict';

module.exports = function memoize( fn, keyFn ){
  if( !keyFn ){
    keyFn = function(){
      if( arguments.length === 1 ){
        return arguments[0];
      } else if( arguments.length === 0 ){
        return 'undefined';
      }

      var args = [];

      for( var i = 0; i < arguments.length; i++ ){
        args.push( arguments[ i ] );
      }

      return args.join( '$' );
    };
  }

  var memoizedFn = function(){
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply( self, args );
    var cache = memoizedFn.cache;

    if( !(ret = cache[ k ]) ){
      ret = cache[ k ] = fn.apply( self, args );
    }

    return ret;
  };

  memoizedFn.cache = {};

  return memoizedFn;
};

},{}],106:[function(require,module,exports){
'use strict';

var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

},{}],107:[function(require,module,exports){
'use strict';

var memoize = require( './memoize' );
var is = require( '../is' );

module.exports = {

  camel2dash: memoize( function( str ){
    return str.replace( /([A-Z])/g, function( v ){
      return '-' + v.toLowerCase();
    } );
  } ),

  dash2camel: memoize( function( str ){
    return str.replace( /(-\w)/g, function( v ){
      return v[1].toUpperCase();
    } );
  } ),

  prependCamel: memoize( function( prefix, str ){
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function( prefix, str ){
    return prefix + '$' + str;
  } ),

  capitalize: function( str ){
    if( is.emptyString( str ) ){
      return str;
    }

    return str.charAt( 0 ).toUpperCase() + str.substring( 1 );
  }

};

},{"../is":86,"./memoize":105}],108:[function(require,module,exports){
'use strict';

var window = require( '../window' );
var is = require( '../is' );
var performance = window ? window.performance : null;

var util = {};

var raf = !window ? function( fn ){
  if( fn ){
    setTimeout( function(){
      fn( pnow() );
    }, 1000 / 60 );
  }
} : (function(){
  if( window.requestAnimationFrame ){
    return function( fn ){ window.requestAnimationFrame( fn ); };
  } else if( window.mozRequestAnimationFrame ){
    return function( fn ){ window.mozRequestAnimationFrame( fn ); };
  } else if( window.webkitRequestAnimationFrame ){
    return function( fn ){ window.webkitRequestAnimationFrame( fn ); };
  } else if( window.msRequestAnimationFrame ){
    return function( fn ){ window.msRequestAnimationFrame( fn ); };
  }
})();

util.requestAnimationFrame = function( fn ){
  raf( fn );
};

var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };

util.performanceNow = pnow;

// ported lodash throttle function
util.throttle = function( func, wait, options ){
  var leading = true,
      trailing = true;

  if( options === false ){
    leading = false;
  } else if( is.plainObject( options ) ){
    leading = 'leading' in options ? options.leading : leading;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  options = options || {};
  options.leading = leading;
  options.maxWait = wait;
  options.trailing = trailing;

  return util.debounce( func, wait, options );
};

util.now = function(){
  return Date.now();
};

util.debounce = function( func, wait, options ){ // ported lodash debounce function
  var util = this;
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if( !is.fn( func ) ){
    return;
  }
  wait = Math.max( 0, wait ) || 0;
  if( options === true ){
    var leading = true;
    trailing = false;
  } else if( is.plainObject( options ) ){
    leading = options.leading;
    maxWait = 'maxWait' in options && (Math.max( wait, options.maxWait ) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function(){
    var remaining = wait - (util.now() - stamp);
    if( remaining <= 0 ){
      if( maxTimeoutId ){
        clearTimeout( maxTimeoutId );
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if( isCalled ){
        lastCalled = util.now();
        result = func.apply( thisArg, args );
        if( !timeoutId && !maxTimeoutId ){
          args = thisArg = null;
        }
      }
    } else {
      timeoutId = setTimeout( delayed, remaining );
    }
  };

  var maxDelayed = function(){
    if( timeoutId ){
      clearTimeout( timeoutId );
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if( trailing || (maxWait !== wait) ){
      lastCalled = util.now();
      result = func.apply( thisArg, args );
      if( !timeoutId && !maxTimeoutId ){
        args = thisArg = null;
      }
    }
  };

  return function(){
    args = arguments;
    stamp = util.now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if( maxWait === false ){
      var leadingCall = leading && !timeoutId;
    } else {
      if( !maxTimeoutId && !leading ){
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0;

      if( isCalled ){
        if( maxTimeoutId ){
          maxTimeoutId = clearTimeout( maxTimeoutId );
        }
        lastCalled = stamp;
        result = func.apply( thisArg, args );
      }
      else if( !maxTimeoutId ){
        maxTimeoutId = setTimeout( maxDelayed, remaining );
      }
    }
    if( isCalled && timeoutId ){
      timeoutId = clearTimeout( timeoutId );
    }
    else if( !timeoutId && wait !== maxWait ){
      timeoutId = setTimeout( delayed, wait );
    }
    if( leadingCall ){
      isCalled = true;
      result = func.apply( thisArg, args );
    }
    if( isCalled && !timeoutId && !maxTimeoutId ){
      args = thisArg = null;
    }
    return result;
  };
};

module.exports = util;

},{"../is":86,"../window":110}],109:[function(require,module,exports){
module.exports = "2.7.14";

},{}],110:[function(require,module,exports){
module.exports = ( typeof window === 'undefined' ? null : window ); // eslint-disable-line no-undef

},{}],111:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("FileSaver.js", function() {
    return saveAs;
  });
}

},{}],112:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = baseKeysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function mergeDefaults(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, mergeDefaults);
  return apply(mergeWith, undefined, args);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with seven arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = defaultsDeep;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],113:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],114:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":115}],115:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],116:[function(require,module,exports){
var converter = require('./sbgnmlConverter');

module.exports = function (text) {
  return converter.convert(text);
};

},{"./sbgnmlConverter":117}],117:[function(require,module,exports){
/* jslint browser: true */
/* global ActiveXObject: false */

var sbgnmlConverter = {
  loadXMLFromString: function (text) {
    var doc;
    if (window.ActiveXObject) {
      doc = new ActiveXObject('Microsoft.XMLDOM');
      doc.async = 'false';
      doc.loadXML(text);
    } else {
      var parser = new DOMParser();
      doc = parser.parseFromString(text, 'text/xml');
    }

    var parseError = doc.getElementsByTagName('parsererror');
    if (parseError.length > 0) {
      throw new Error('Could not convert the following text to xml: ' + JSON.stringify(text));
    }

    return doc;
  },
  sbgnmlTags: {
    'unspecified entity': true,
    'simple chemical': true,
    'macromolecule': true,
    'nucleic acid feature': true,
    'perturbing agent': true,
    'source and sink': true,
    'complex': true,
    'process': true,
    'omitted process': true,
    'uncertain process': true,
    'association': true,
    'dissociation': true,
    'phenotype': true,
    'tag': true,
    'consumption': true,
    'production': true,
    'modulation': true,
    'stimulation': true,
    'catalysis': true,
    'inhibition': true,
    'necessary stimulation': true,
    'logic arc': true,
    'equivalence arc': true,
    'and operator': true,
    'or operator': true,
    'not operator': true,
    'and': true,
    'or': true,
    'not': true,
    'nucleic acid feature multimer': true,
    'macromolecule multimer': true,
    'simple chemical multimer': true,
    'complex multimer': true,
    'compartment': true
  },
  insertedNodes: {},
  getAllCompartments: function (xmlObject) {
    var compartments = [];

    var compartmentEls = xmlObject.querySelectorAll("glyph[class='compartment']");

    for (var i = 0; i < compartmentEls.length; i++) {
      var compartment = compartmentEls[i];
      var bbox = this.findChildNode(compartment, 'bbox');
      compartments.push({
        'x': parseFloat(bbox.getAttribute('x')),
        'y': parseFloat(bbox.getAttribute('y')),
        'w': parseFloat(bbox.getAttribute('w')),
        'h': parseFloat(bbox.getAttribute('h')),
        'id': compartment.getAttribute('id')
      });
    }

    compartments.sort(function (c1, c2) {
      if (c1.h * c1.w < c2.h * c2.w) {
        return -1;
      }
      if (c1.h * c1.w > c2.h * c2.w) {
        return 1;
      }
      return 0;
    });

    return compartments;
  },
  isInBoundingBox: function (bbox1, bbox2) {
    if (bbox1.x > bbox2.x &&
        bbox1.y > bbox2.y &&
        bbox1.x + bbox1.w < bbox2.x + bbox2.w &&
        bbox1.y + bbox1.h < bbox2.y + bbox2.h) {
      return true;
    }
    return false;
  },
  bboxProp: function (ele) {
    var bbox = {};
    var bboxEl = ele.querySelector('bbox');

    bbox.x = bboxEl.getAttribute('x');
    bbox.y = bboxEl.getAttribute('y');
    bbox.w = bboxEl.getAttribute('w');
    bbox.h = bboxEl.getAttribute('h');
    // set positions as center
    bbox.x = parseFloat(bbox.x) + parseFloat(bbox.w) / 2;
    bbox.y = parseFloat(bbox.y) + parseFloat(bbox.h) / 2;

    return bbox;
  },
  stateAndInfoBboxProp: function (ele, parentBbox) {
    var xPos = parseFloat(parentBbox.x);
    var yPos = parseFloat(parentBbox.y);

    var bbox = {};
    var bboxEl = ele.querySelector('bbox');

    bbox.x = bboxEl.getAttribute('x');
    bbox.y = bboxEl.getAttribute('y');
    bbox.w = bboxEl.getAttribute('w');
    bbox.h = bboxEl.getAttribute('h');

    // set positions as center
    bbox.x = parseFloat(bbox.x) + parseFloat(bbox.w) / 2 - xPos;
    bbox.y = parseFloat(bbox.y) + parseFloat(bbox.h) / 2 - yPos;

    bbox.x = bbox.x / parseFloat(parentBbox.w) * 100;
    bbox.y = bbox.y / parseFloat(parentBbox.h) * 100;

    return bbox;
  },
  findChildNodes: function (ele, childTagName) {
    // find child nodes at depth level of 1 relative to the element
    var children = [];
    for (var i = 0; i < ele.childNodes.length; i++) {
      var child = ele.childNodes[i];
      if (child.nodeType === 1 && child.tagName === childTagName) {
        children.push(child);
      }
    }
    return children;
  },
  findChildNode: function (ele, childTagName) {
    var nodes = this.findChildNodes(ele, childTagName);
    return nodes.length > 0 ? nodes[0] : undefined;
  },
  stateAndInfoProp: function (ele, parentBbox) {
    var self = this;
    var stateAndInfoArray = [];

    var childGlyphs = this.findChildNodes(ele, 'glyph');

    for (var i = 0; i < childGlyphs.length; i++) {
      var glyph = childGlyphs[i];
      var info = {};

      if (glyph.className === 'unit of information') {
        info.id = glyph.getAttribute('id') || undefined;
        info.clazz = glyph.className || undefined;
        var label = glyph.querySelector('label');
        info.label = {
          'text': (label && label.getAttribute('text')) || undefined
        };
        info.bbox = self.stateAndInfoBboxProp(glyph, parentBbox);
        stateAndInfoArray.push(info);
      } else if (glyph.className === 'state variable') {
        info.id = glyph.getAttribute('id') || undefined;
        info.clazz = glyph.className || undefined;
        var state = glyph.querySelector('state');
        var value = (state && state.getAttribute('value')) || undefined;
        var variable = (state && state.getAttribute('variable')) || undefined;
        info.state = {
          'value': value,
          'variable': variable
        };
        info.bbox = self.stateAndInfoBboxProp(glyph, parentBbox);
        stateAndInfoArray.push(info);
      }
    }


    return stateAndInfoArray;
  },
  addParentInfoToNode: function (ele, nodeObj, parent, compartments) {
    var self = this;
    var compartmentRef = ele.getAttribute('compartmentRef');

    if (parent) {
      nodeObj.parent = parent;
      return;
    }

    if (compartmentRef) {
      nodeObj.parent = compartmentRef;
    } else {
      nodeObj.parent = '';

      // add compartment according to geometry
      for (var i = 0; i < compartments.length; i++) {
        var bboxEl = self.findChildNode(ele, 'bbox');
        var bbox = {
          'x': parseFloat(bboxEl.getAttribute('x')),
          'y': parseFloat(bboxEl.getAttribute('y')),
          'w': parseFloat(bboxEl.getAttribute('w')),
          'h': parseFloat(bboxEl.getAttribute('h')),
          'id': ele.getAttribute('id')
        };
        if (self.isInBoundingBox(bbox, compartments[i])) {
          nodeObj.parent = compartments[i].id;
          break;
        }
      }
    }
  },
  addCytoscapeJsNode: function (ele, jsonArray, parent, compartments) {
    var self = this;
    var nodeObj = {};

    // add id information
    nodeObj.id = ele.getAttribute('id');
    // add node bounding box information
    nodeObj.bbox = self.bboxProp(ele);
    // add class information
    nodeObj.class = ele.className;
    // add label information
    var label = self.findChildNode(ele, 'label');
    nodeObj.label = (label && label.getAttribute('text')) || undefined;
    // add state and info box information
    nodeObj.statesandinfos = self.stateAndInfoProp(ele, nodeObj.bbox);
    // adding parent information
    self.addParentInfoToNode(ele, nodeObj, parent, compartments);

    // add clone information
    var cloneMarkers = self.findChildNodes(ele, 'clone');
    if (cloneMarkers.length > 0) {
      nodeObj.clonemarker = true;
    } else {
      nodeObj.clonemarker = undefined;
    }

    // add port information
    var ports = [];
    var portElements = ele.querySelectorAll('port');

    for (var i = 0; i < portElements.length; i++) {
      var portEl = portElements[i];
      var id = portEl.getAttribute('id');
      var relativeXPos = parseFloat(portEl.getAttribute('x')) - nodeObj.bbox.x;
      var relativeYPos = parseFloat(portEl.getAttribute('y')) - nodeObj.bbox.y;

      relativeXPos = relativeXPos / parseFloat(nodeObj.bbox.w) * 100;
      relativeYPos = relativeYPos / parseFloat(nodeObj.bbox.h) * 100;

      ports.push({
        id: id,
        x: relativeXPos,
        y: relativeYPos
      });
    }

    nodeObj.ports = ports;

    var cytoscapeJsNode = {data: nodeObj};
    jsonArray.push(cytoscapeJsNode);
  },
  traverseNodes: function (ele, jsonArray, parent, compartments) {
    var elId = ele.getAttribute('id');
    if (!this.sbgnmlTags[ele.className]) {
      return;
    }
    this.insertedNodes[elId] = true;
    var self = this;
    // add complex nodes here

    var eleClass = ele.className;

    if (eleClass === 'complex' || eleClass === 'submap') {
      self.addCytoscapeJsNode(ele, jsonArray, parent, compartments);

      var childGlyphs = self.findChildNodes(ele, 'glyph');
      for (var i = 0; i < childGlyphs.length; i++) {
        var glyph = childGlyphs[i];
        var glyphClass = glyph.className;
        if (glyphClass !== 'state variable' && glyphClass !== 'unit of information') {
          self.traverseNodes(glyph, jsonArray, elId, compartments);
        }
      }
    } else {
      self.addCytoscapeJsNode(ele, jsonArray, parent, compartments);
    }
  },
  getPorts: function (xmlObject) {
    return ( xmlObject._cachedPorts = xmlObject._cachedPorts || xmlObject.querySelectorAll('port'));
  },
  getGlyphs: function (xmlObject) {
    var glyphs = xmlObject._cachedGlyphs;

    if (!glyphs) {
      glyphs = xmlObject._cachedGlyphs = xmlObject._cachedGlyphs || xmlObject.querySelectorAll('glyph');

      var id2glyph = xmlObject._id2glyph = {};

      for ( var i = 0; i < glyphs.length; i++ ) {
        var g = glyphs[i];
        var id = g.getAttribute('id');

        id2glyph[ id ] = g;
      }
    }

    return glyphs;
  },
  getGlyphById: function (xmlObject, id) {
    this.getGlyphs(xmlObject); // make sure cache is built

    return xmlObject._id2glyph[id];
  },
  getArcSourceAndTarget: function (arc, xmlObject) {
    // source and target can be inside of a port
    var source = arc.getAttribute('source');
    var target = arc.getAttribute('target');
    var sourceNodeId;
    var targetNodeId;

    var sourceExists = this.getGlyphById(xmlObject, source);
    var targetExists = this.getGlyphById(xmlObject, target);

    if (sourceExists) {
      sourceNodeId = source;
    }

    if (targetExists) {
      targetNodeId = target;
    }


    var i;
    var portEls = this.getPorts(xmlObject);
    var port;
    if (sourceNodeId === undefined) {
      for (i = 0; i < portEls.length; i++ ) {
        port = portEls[i];
        if (port.getAttribute('id') === source) {
          sourceNodeId = port.parentElement.getAttribute('id');
        }
      }
    }

    if (targetNodeId === undefined) {
      for (i = 0; i < portEls.length; i++) {
        port = portEls[i];
        if (port.getAttribute('id') === target) {
          targetNodeId = port.parentElement.getAttribute('id');
        }
      }
    }

    return {'source': sourceNodeId, 'target': targetNodeId};
  },

  getArcBendPointPositions: function (ele) {
    var bendPointPositions = [];

    var children = this.findChildNodes(ele, 'next');

    for (var i = 0; i < children.length; i++) {
      var posX = children[i].getAttribute('x');
      var posY = children[i].getAttribute('y');

      bendPointPositions.push({
        x: posX,
        y: posY
      });
    }

    return bendPointPositions;
  },
  addCytoscapeJsEdge: function (ele, jsonArray, xmlObject) {
    if (!this.sbgnmlTags[ele.className]) {
      return;
    }

    var self = this;
    var sourceAndTarget = self.getArcSourceAndTarget(ele, xmlObject);

    if (!this.insertedNodes[sourceAndTarget.source] || !this.insertedNodes[sourceAndTarget.target]) {
      return;
    }

    var edgeObj = {};
    var bendPointPositions = self.getArcBendPointPositions(ele);

    edgeObj.id = ele.getAttribute('id') || undefined;
    edgeObj.class = ele.className;
    edgeObj.bendPointPositions = bendPointPositions;

    var glyphChildren = self.findChildNodes(ele, 'glyph');
    var glyphDescendents = ele.querySelectorAll('glyph');
    if (glyphDescendents.length <= 0) {
      edgeObj.cardinality = 0;
    } else {
      for (var i = 0; i < glyphChildren.length; i++) {
        if (glyphChildren[i].className === 'cardinality') {
          var label = glyphChildren[i].querySelector('label');
          edgeObj.cardinality = label.getAttribute('text') || undefined;
        }
      }
    }

    edgeObj.source = sourceAndTarget.source;
    edgeObj.target = sourceAndTarget.target;

    edgeObj.portsource = ele.getAttribute('source');
    edgeObj.porttarget = ele.getAttribute('target');

    var cytoscapeJsEdge = {data: edgeObj};
    jsonArray.push(cytoscapeJsEdge);
  },
  convert: function (sbgnmlText) {
    var self = this;
    var cytoscapeJsNodes = [];
    var cytoscapeJsEdges = [];

    var xmlObject = this.loadXMLFromString(sbgnmlText);

    var compartments = self.getAllCompartments(xmlObject);

    var glyphs = self.findChildNodes(xmlObject.querySelector('map'), 'glyph');
    var arcs = self.findChildNodes(xmlObject.querySelector('map'), 'arc');

    var i;
    for (i = 0; i < glyphs.length; i++) {
      var glyph = glyphs[i];
      self.traverseNodes(glyph, cytoscapeJsNodes, '', compartments);
    }

    for (i = 0; i < arcs.length; i++) {
      var arc = arcs[i];
      self.addCytoscapeJsEdge(arc, cytoscapeJsEdges, xmlObject);
    }

    var cytoscapeJsGraph = {};
    cytoscapeJsGraph.nodes = cytoscapeJsNodes;
    cytoscapeJsGraph.edges = cytoscapeJsEdges;

    this.insertedNodes = {};

    return cytoscapeJsGraph;
  }
};

module.exports = sbgnmlConverter;

},{}],118:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cytoscape = require('cytoscape');
var defaultsDeep = require('lodash.defaultsdeep');

var sbgnStyleSheet = require('./sbgnStyle/graph');

var defaultOptions = {
  style: sbgnStyleSheet(Cytoscape),
  boxSelectionEnabled: true,
  showOverlay: false,
  minZoom: false,
  maxZoom: false,
  motionBlur: false,
  wheelSensitivity: 0.1
};

var SBGNRenderer = function (_Cytoscape) {
  _inherits(SBGNRenderer, _Cytoscape);

  function SBGNRenderer(options) {
    _classCallCheck(this, SBGNRenderer);

    return _possibleConstructorReturn(this, (SBGNRenderer.__proto__ || Object.getPrototypeOf(SBGNRenderer)).call(this, defaultsDeep({}, defaultOptions, options)));
  }
  //   TODO: Initial sbgn-renderer api
  //   sbgn (kdfkd) { // the function that can possibly turned into an extension
  //   ...; // style sheet can be set in here
  //   ...; // accept sbngml file or string, promise to resolve to string (fetch support), possibly always treat it as a promise
  //   ...; // export  to sbgnml file or picture
  //  }


  return SBGNRenderer;
}(Cytoscape);

module.exports = SBGNRenderer;

},{"./sbgnStyle/graph":126,"cytoscape":85,"lodash.defaultsdeep":112}],119:[function(require,module,exports){
'use strict';

var elementStyle = {};

elementStyle.sbgnShape = function (node) {
  var sbgnClass = node.data('class');
  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'phenotype') {
    return 'hexagon';
  }

  if (sbgnClass == 'process') {
    return 'square';
  }

  if (sbgnClass == 'perturbing agent' || sbgnClass == 'tag' || sbgnClass == 'source and sink' || sbgnClass == 'compartment' || sbgnClass == 'complex') {
    return 'polygon';
  }

  if (sbgnClass == 'dissociation') {
    return 'ellipse';
  }

  if (sbgnClass == 'nucleic acid feature' || sbgnClass == 'macromolecule' || sbgnClass == 'simple chemical' || sbgnClass == 'omitted process' || sbgnClass == 'uncertain process' || sbgnClass == 'association') {
    return 'roundrectangle';
  }
  return 'ellipse';
};

elementStyle.sbgnArrowShape = function (edge) {
  var sbgnClass = edge.data('class');
  if (sbgnClass == 'necessary stimulation') {
    return 'triangle-cross';
  }
  if (sbgnClass == 'inhibition') {
    return 'tee';
  }
  if (sbgnClass == 'catalysis') {
    return 'circle';
  }
  if (sbgnClass == 'stimulation' || sbgnClass == 'production') {
    return 'triangle';
  }
  if (sbgnClass == 'modulation') {
    return 'diamond';
  }
  return 'none';
};

elementStyle.sbgnContent = function (node) {
  var sbgnClass = node.data('class');
  var content = '';

  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'macromolecule' || sbgnClass == 'simple chemical' || sbgnClass == 'phenotype' || sbgnClass == 'unspecified entity' || sbgnClass == 'nucleic acid feature' || sbgnClass == 'perturbing agent' || sbgnClass == 'tag') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'compartment') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'complex') {
    if (node.children().length == 0) {
      if (node.data('label')) {
        content = node.data('label');
      } else if (node.data('infoLabel')) {
        content = node.data('infoLabel');
      } else {
        content = '';
      }
    } else {
      content = '';
    }
  } else if (sbgnClass == 'and') {
    content = 'AND';
  } else if (sbgnClass == 'or') {
    content = 'OR';
  } else if (sbgnClass == 'not') {
    content = 'NOT';
  } else if (sbgnClass == 'omitted process') {
    content = '\\\\';
  } else if (sbgnClass == 'uncertain process') {
    content = '?';
  }

  return content;
};

var dynamicLabelTextSize = function dynamicLabelTextSize(nodeHeight) {
  var sizeCoefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return nodeHeight / 2.45 * sizeCoefficient;
};

elementStyle.labelTextSize = function (node) {
  var sbgnClass = node.data('class');
  var nh = node.height();

  // Dirty legacy hack.  These types of nodes are not supposed to have labels
  // but apparently they need to have a text size
  if (sbgnClass === 'association' || sbgnClass === 'dissociation') {
    return 20;
  }

  if (sbgnClass === 'and' || sbgnClass === 'or' || sbgnClass === 'not') {
    return dynamicLabelTextSize(nh, 1);
  }

  if (sbgnClass.endsWith('process')) {
    return dynamicLabelTextSize(nh, 1.5);
  }

  if (sbgnClass === 'complex' || sbgnClass === 'compartment') {
    return 16;
  }

  return dynamicLabelTextSize(nh);
};

elementStyle.cardinalityDistance = function (edge) {
  var srcPos = edge.source().position();
  var tgtPos = edge.target().position();

  var distance = Math.sqrt(Math.pow(srcPos.x - tgtPos.x, 2) + Math.pow(srcPos.y - tgtPos.y, 2));
  return distance * 0.15;
};

module.exports = elementStyle;

},{}],120:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var baseShapes = {
  styleMap2Str: function styleMap2Str(styleMap) {
    return '' + [].concat(_toConsumableArray(styleMap)).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return k + ': ' + v + ';';
    }).join(' ');
  },
  baseRectangle: function baseRectangle(x, y, w, h, r1, r2, r3, r4, styleMap) {
    return '\n    <path style=\'' + this.styleMap2Str(styleMap) + '\' d=\'\n      M ' + (x + r1) + ' ' + y + '\n      L ' + (x + w - r2) + ' ' + y + ' Q ' + (x + w) + ' ' + y + ' ' + (x + w) + ' ' + (y + r2) + '\n      L ' + (x + w) + ' ' + (y + h - r3) + ' Q ' + (x + w) + ' ' + (y + h) + ' ' + (x + w - r3) + ' ' + (y + h) + '\n      L ' + (x + r4) + ' ' + (y + h) + ' Q ' + x + ' ' + (y + h) + ' ' + x + ' ' + (y + h - r4) + '\n      L ' + x + ' ' + (y + r1) + ' Q ' + x + ' ' + y + ' ' + (x + r1) + ' ' + y + '\n      Z\'\n    />\n    ';
  },
  barrel: function barrel(width, height, styleMap) {
    return '\n\n    <g style="' + this.styleMap2Str(styleMap) + '">\n      <path d="M ' + 0 * width + ' ' + .03 * height + ' L ' + 0 * width + ' ' + .97 * height + ' Q ' + 0.06 * width + ' ' + height + ' ' + 0.25 * width + ' ' + height + '"/>\n\n      <path d="M ' + 0.25 * width + ' ' + height + ' L ' + 0.75 * width + ' ' + height + ' Q ' + 0.95 * width + ' ' + height + ' ' + width + ' ' + 0.95 * height + '"/>\n\n      <path d="M ' + width + ' ' + .95 * height + ' L ' + width + ' ' + 0.05 * height + ' Q ' + width + ' ' + 0 * height + ' ' + 0.75 * width + ' ' + 0 * height + '"/>\n\n      <path d="M ' + 0.75 * width + ' ' + 0 * height + ' L ' + 0.25 * width + ' ' + 0 * height + ' Q ' + 0.06 * width + ' ' + 0 * height + ' ' + 0 * width + ' ' + 0.03 * height + '"/>\n    </g>\n\n    ';
  },
  circle: function circle(cx, cy, r, styleMap) {
    return '<circle cx=\'' + cx + '\' cy=\'' + cy + '\' r=\'' + r + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />';
  },
  concaveHexagon: function concaveHexagon(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'' + 0 + ', ' + 0 + ', ' + width + ', ' + 0 + ', ' + 0.85 * width + ', ' + 0.5 * height + ', ' + width + ', ' + height + ', ' + 0 + ', ' + height + ', ' + 0.15 * width + ', ' + 0.5 * height + '\'\n    />';
  },
  cutRectangle: function cutRectangle(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'\n      ' + 0 * width + ' ' + 0.05 * height + ' ' + 0.05 * width + ' ' + 0 * height + ' ' + 0.95 * width + ' ' + 0 * height + ' ' + width + ' ' + 0.05 * height + '\n      ' + width + ' ' + 0.95 * height + ' ' + 0.95 * width + ' ' + height + ' ' + 0.05 * width + ' ' + height + ' ' + 0 * width + ' ' + 0.95 * height + '\n      \'\n    />\n    ';
  },
  ellipse: function ellipse(cx, cy, rx, ry, styleMap) {
    return '\n      <ellipse cx=\'' + cx + '\' cy=\'' + cy + '\' rx=\'' + rx + '\' ry=\'' + ry + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />\n    ';
  },
  hexagon: function hexagon(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'' + 0 + ', ' + 0.5 * height + ', ' + 0.25 * width + ', ' + 0 * height + ', ' + 0.75 * width + ', ' + 0 * height + ', ' + width + ', ' + 0.5 * height + ', ' + 0.75 * width + ', ' + height + ', ' + 0.25 * width + ', ' + height + '\'\n    />';
  },
  line: function line(x1, y1, x2, y2, styleMap) {
    return '<line x1=\'' + x1 + '\' y1=\'' + y1 + '\' x2=\'' + x2 + '\' y2=\'' + y2 + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />';
  },
  rectangle: function rectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, 0, 0, 0, 0, styleMap);
  },
  roundBottomRectangle: function roundBottomRectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, 0, 0, .3 * height, .3 * height, styleMap);
  },
  roundRectangle: function roundRectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, .3 * height, .3 * height, .3 * height, .3 * height, styleMap);
  },
  square: function square(x, y, length, styleMap) {
    return this.baseRectangle(x, y, length, length, 0, 0, 0, 0, styleMap);
  },
  text: function text(t, x, y, textAnchor, styleMap) {
    return '<text x=\'' + x + '\' y=\'' + x + '\' textAnchor=\'' + textAnchor + '\' style=\'' + this.styleMap2Str(styleMap) + '\'>' + t + '</text>';
  }
};

module.exports = baseShapes;

},{}],121:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');

var svgb64Str = require('../util/svg.js');
var unitOfInfo = require('./unitOfInformation.js');
// QUAD1  |  QUAD2
// (-, -) |  (+, -)
// -------------
// QUAD4  | QUAD3
// (-, +) |  (+, +)
var quad1 = '-1, -0.9, -0.95, -0.95, -0.33, -1';

var quad2 = '0.33, -1, 0.9, -0.95, 1, -0.9';

var quad3 = '1, 0.9, 0.95, 0.95, 0.33, 1';

var quad4 = '-0.33, 1, -0.95, 0.95, -1, 0.9';

var points = function points() {
  return quad1 + ', ' + quad2 + ', ' + quad3 + ', ' + quad4;
};

var svgUri = function svgUri(node) {
  var borderWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3.75;


  var nh = node.outerHeight();
  var nw = node.outerWidth();

  var uInfo = '';

  if (node.data('statesandinfos').length > 0) {
    var info = node.data('statesandinfos')[0].label.text; // fragile
    uInfo = unitOfInfo.place(info, 0, nh / 2, .1 * nw, 0.05 * nw, nw, nh);
  }

  var style = new Map().set('stroke-width', borderWidth).set('fill', 'none').set('stroke', '#6A6A6A');

  var compartment = '\n  ' + baseShapes.barrel(nw, nh, style) + '\n  ' + uInfo + '\n  ';

  return svgb64Str(compartment, nw, nh, 0, 0, nw, nh);
};

module.exports = {
  points: points,
  svgUri: svgUri
};

},{"../util/svg.js":127,"./baseShapes.js":120,"./unitOfInformation.js":125}],122:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');
var svgStr = require('../util/svg.js');

var entityPoolNodes = {
  unspecifiedEntity: function unspecifiedEntity(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var unspecEntitySvg = '\n      ' + baseShapes.ellipse(nw / 2, nh / 2, (nh - 2) / 2, (nw - 2) / 2, styleMap) + '\n    ';
    return svgStr(unspecEntitySvg, nw, nh, 0, 0, nw, nh);
  },
  simpleChemical: function simpleChemical(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var simpleChemicalSvg = '\n      ' + baseShapes.circle(nw / 2, nh / 2, (Math.min(nw, nh) - 2) / 2, styleMap) + '\n    ';
    return svgStr(simpleChemicalSvg, nw, nh, 0, 0, nw, nh);
  },
  macromolecule: function macromolecule(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var macromoleculeSvg = '\n      ' + baseShapes.roundRectangle(0, 0, nw, nh, styleMap) + '\n    ';
    return svgStr(macromoleculeSvg, nw, nh, 0, 0, nw, nh);
  },
  nucleicAcidFeature: function nucleicAcidFeature(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var nucleicAcidFeatureSvg = '\n      ' + baseShapes.roundBottomRectangle(0, 0, nw, nh, styleMap) + '\n    ';
    return svgStr(nucleicAcidFeatureSvg, nw, nh, 0, 0, nw, nh);
  },
  complex: function complex(node) {
    var nw = node.outerWidth();
    var nh = node.outerHeight();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var complexSvg = '\n      ' + baseShapes.cutRectangle(nw, nh, styleMap) + '\n    ';
    return svgStr(complexSvg, nw, nh, 0, 0, nw, nh);
  },
  sourceAndSink: function sourceAndSink(node) {
    var nodeCenterX = node.width() / 2;
    var nodeCenterY = node.height() / 2;
    var circleRadius = (node.width() - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-linecap', 'square').set('stroke-width', '1.5').set('fill', 'none');

    var sourceAndSinkSvg = '\n      ' + baseShapes.circle(nodeCenterX, nodeCenterY, circleRadius, styleMap) + '\n      ' + baseShapes.line(0, node.height(), node.width(), 0, styleMap) + '\n    ';
    return svgStr(sourceAndSinkSvg, node.width(), node.height(), 0, 0, node.width(), node.height());
  },
  perturbingAgent: function perturbingAgent(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var perturbingAgentSvg = '\n      ' + baseShapes.concaveHexagon(nw, nh, styleMap) + '\n    ';
    return svgStr(perturbingAgentSvg, nw, nh, 0, 0, nw, nh);
  }
};

var epnMap = new Map().set('source and sink', entityPoolNodes.sourceAndSink).set('unspecified entity', entityPoolNodes.unspecifiedEntity).set('simple chemical', entityPoolNodes.simpleChemical).set('macromolecule', entityPoolNodes.macromolecule).set('nucleic acid feature', entityPoolNodes.nucleicAcidFeature).set('complex', entityPoolNodes.complex).set('perturbing agent', entityPoolNodes.perturbingAgent);

var draw = function draw(node) {
  return epnMap.get(node.data('class'))(node) || '';
};

module.exports = {
  draw: draw
};

},{"../util/svg.js":127,"./baseShapes.js":120}],123:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');
var svgStr = require('../util/svg.js');

var processNodes = {
  process: function process(node) {
    var nw = node.width();
    var nh = node.height();

    var lineStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1').set('fill', 'none');

    var squareStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1').set('fill', 'white').set('fill-opacity', '1');

    var line = baseShapes.line(0, nh / 2, nw, nh / 2, lineStyle);

    var processSvg = '\n      ' + baseShapes.square(0.1 * nw, 0.1 * nh, 0.8 * Math.max(nw, nh), squareStyle) + '\n    ';
    return svgStr(processSvg, nw, nh, 0, 0, nw, nh);
  },
  association: function association(node) {
    var nw = node.width();
    var nh = node.height();

    var centerX = nw / 2;
    var centerY = nh / 2;
    var radius = (Math.min(nw, nh) - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', '#6A6A6A');

    var line = baseShapes.line(0, nh / 2, nw, nh / 2, styleMap);

    var associationSvg = '\n      ' + baseShapes.circle(centerX, centerY, radius, styleMap) + '\n    ';
    return svgStr(associationSvg, nw, nh, 0, 0, nw, nh);
  },
  dissociation: function dissociation(node) {
    var nw = node.width();
    var nh = node.height();

    var centerX = node.width() / 2;
    var centerY = node.height() / 2;
    var outerRadius = (Math.min(nw, nh) - 2) / 2;
    var innerRadius = (Math.min(nw, nh) - 2) / 3;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var dissociationSvg = '\n      ' + baseShapes.circle(centerX, centerY, outerRadius, styleMap) + '\n      ' + baseShapes.circle(centerX, centerY, innerRadius, styleMap) + '\n    ';
    return svgStr(dissociationSvg, nw, nh, 0, 0, nw, nh);
  },
  phenotype: function phenotype(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var phenotypeSvg = '\n      ' + baseShapes.hexagon(nw, nh, styleMap) + '\n    ';
    return svgStr(phenotypeSvg, nw, nh, 0, 0, nw, nh);
  }
};

var processMap = new Map().set('process', processNodes.process).set('omitted process', processNodes.process).set('uncertain process', processNodes.process).set('association', processNodes.association).set('dissociation', processNodes.dissociation).set('phenotype', processNodes.phenotype);

var draw = function draw(node) {
  return processMap.get(node.data('class'))(node) || '';
};

module.exports = {
  draw: draw
};

},{"../util/svg.js":127,"./baseShapes.js":120}],124:[function(require,module,exports){
'use strict';

var svgb64Str = require('../util/svg.js');
var baseShapes = require('./baseShapes.js');

// QUAD1  |  QUAD2
// (-, -) |  (+, -)
// -------------
// QUAD4  | QUAD3
// (-, +) |  (+, +)
var quad1 = '-0.86, 0.5, -0.75, 0.65, -1, 0.95, -0.95, 1, -0.65, 0.75, -0.5, 0.86, 0, 1';

var quad2 = '0.5, 0.86, 0.71, 0.71, 0.86, 0.5, 1, 0';

var quad3 = '0.86, -0.5, 0.75, -0.65, 1, -0.95, 0.95, -1, 0.65, -0.75, 0.5, -0.86, 0, -1';

var quad4 = '-0.5, -0.86, -0.71, -0.71, -0.86, -0.5, -1, 0,';

var points = function points() {
  return quad1 + ', ' + quad2 + ', ' + quad3 + ', ' + quad4;
};

var svgUri = function svgUri(node) {
  var strokeColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'grey';
  var edgeWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var cloneMarker = '';
  var clipPath = '';

  var nodeCenterX = node.width() / 2;
  var nodeCenterY = node.height() / 2;
  var circleRadius = (node.width() - 2) / 2;

  if (node.data('clonemarker')) {
    clipPath = '\n    <defs>\n      <clipPath id="cut-off-bottom">\n        <rect x="0" y="' + 2 * node.height() / 3 + '" width="' + node.width() + '" height="' + node.width() + '" />\n      </clipPath>\n    </defs>\n    ';
    cloneMarker = '\n    <circle cx="' + nodeCenterX + '" cy="' + nodeCenterY + '" r="' + circleRadius + '" fill=\'#D2D2D2\' stroke=\'grey\' clip-path="url(#cut-off-bottom)" />\n    ';
  }

  var style = new Map().set('fill', 'none').set('stroke', strokeColor).set('stroke-width', edgeWidth);

  var sourceAndSink = '\n    ' + baseShapes.circle(nodeCenterX, nodeCenterY, circleRadius, style) + '\n    ' + clipPath + '\n    ' + cloneMarker + '\n    ' + baseShapes.line(0, node.height(), node.width(), 0, style) + '\n  ';

  return svgb64Str(sourceAndSink, node.width(), node.height(), 0, 0, node.width(), node.height());
};

module.exports = {
  svgUri: svgUri,
  points: points
};

},{"../util/svg.js":127,"./baseShapes.js":120}],125:[function(require,module,exports){
"use strict";

var pointOnNodePerimeter = function pointOnNodePerimeter(x, y, node) {
  return (x === 0 || x === node.width()) && 0 <= y <= node.height() || (y === 0 || y === node.height()) && 0 <= x <= node.width();
};

var place = function place(label, x, y, width, height, vpWidth, vpHeight) {
  return "\n  <svg prserveAspectRatio='xMidYMin meet' width='" + vpWidth + "' height='" + vpHeight + "' viewBox='0 0 " + vpWidth + " " + vpHeight + "'>\n    <rect fill='white' stroke='black' x='" + x + "' y='" + y + "' width='" + width + "' height='" + height + "' />\n    <text text-anchor='middle' x='" + (x + width / 2) + "' y='" + (y + height / 2) + "'>" + label + "</text>\n  </svg>\n  ";
};

module.exports = {
  place: place
};

},{}],126:[function(require,module,exports){
'use strict';

var elementStyle = require('./element.js');

var sourceAndSink = require('./glyph/sourceAndSink.js');
var compartment = require('./glyph/compartment.js');

var entityPoolShapes = require('./glyph/entityPoolNodeShapes.js');
var processNodeShapes = require('./glyph/processNodeShapes.js');

// A function that creates a cytoscape style sheet from a given
// cytoscape instance
var sbgnStyleSheet = function sbgnStyleSheet(cytoscape) {

  return cytoscape.stylesheet().selector('node').css({
    'content': function content(node) {
      return elementStyle.sbgnContent(node);
    },
    'font-size': function fontSize(node) {
      return elementStyle.labelTextSize(node);
    },
    'text-valign': 'center',
    'text-halign': 'center',
    'border-width': 1.5,
    'border-color': '#555',
    'background-color': '#f6f6f6',
    'background-opacity': 0.5,
    'text-opacity': 1,
    'opacity': 1,
    'text-wrap': 'wrap',
    'text-max-width': 100
  }).selector('node[class]').css({
    'shape': function shape(node) {
      return elementStyle.sbgnShape(node);
    }
  }).selector('node[class="process"]').css({
    'shape': 'square',
    'background-image': function backgroundImage(node) {
      return processNodeShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '150%',
    'background-height': '150%',
    'padding': function padding(node) {
      return Math.max(node.width(), node.height()) * 0.1;
    },
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="association"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return processNodeShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="dissociation"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return processNodeShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="phenotype"]').css({
    'shape': 'hexagon',
    'background-image': function backgroundImage(node) {
      return processNodeShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="source and sink"]').css({
    'shape-polygon-points': sourceAndSink.points(),
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="nucleic acid feature"]').css({
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="perturbing agent"]').css({
    'shape-polygon-points': '-1, -1,   -0.5, 0,  -1, 1,   1, 1,   0.5, 0, 1, -1',
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="complex"]').css({
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'padding': function padding(node) {
      return Math.min(node.height(), node.width()) * .055;
    },
    'background-opacity': 0,
    'background-fit': 'none',
    'background-width': '110%',
    'background-height': '110%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0,
    'text-valign': 'bottom',
    'text-halign': 'center',
    'min-height': function minHeight(node) {
      return node.width() * .75;
    },
    'min-height-bias-top': '50%',
    'min-height-bias-bottom': '50%'
  }).selector('node[class="macromolecule"]').css({
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="simple chemical"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="unspecified entity"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return entityPoolShapes.draw(node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="compartment"]').css({
    'shape-polygon-points': compartment.points(),
    'background-image': function backgroundImage(node) {
      return compartment.svgUri(node, 5);
    },
    'background-fit': 'none',
    'background-width': '110%',
    'background-height': '110%',
    'padding': function padding(node) {
      return Math.max(node.height(), node.width()) * .1;
    },
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 1,
    'border-color': 'green',
    'background-opacity': 0,
    'text-valign': 'bottom',
    'text-halign': 'center',
    'min-height': 100,
    'min-height-bias-top': '50%',
    'min-height-bias-bottom': '50%',
    'min-width': 175,
    'min-width-bias-right': '50%',
    'min-width-bias-left': '50%'
  }).selector('node[class="tag"]').css({
    'shape-polygon-points': '-1, -1,   0.25, -1,   1, 0,    0.25, 1,    -1, 1'
  }).selector('node[class="association"]').css({
    'background-color': '#6B6B6B'
  }).selector('node[bbox][class][class!="complex"][class!="compartment"][class!="submap"]').css({
    'width': 'data(bbox.w)',
    'height': 'data(bbox.h)'
  }).selector('node:selected').css({
    'background-color': '#d67614',
    'target-arrow-color': '#000',
    'text-outline-color': '#000'
  }).selector('node:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '14'
  }).selector('edge').css({
    'curve-style': 'bezier',
    'line-color': '#555',
    'target-arrow-fill': 'hollow',
    'source-arrow-fill': 'hollow',
    'width': 1.5,
    'target-arrow-color': '#555',
    'source-arrow-color': '#555',
    'text-border-color': function textBorderColor(edge) {
      if (edge.selected()) {
        return '#d67614';
      }
      return edge.css('line-color');
    },
    'color': function color(edge) {
      if (edge.selected()) {
        return '#d67614';
      }
      return edge.css('line-color');
    }
  }).selector('edge:selected').css({
    'line-color': '#d67614',
    'source-arrow-color': '#d67614',
    'target-arrow-color': '#d67614'
  }).selector('edge:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '8'
  }).selector('edge[cardinality > 0]').css({
    'text-rotation': 'autorotate',
    'text-background-shape': 'rectangle',
    'text-border-opacity': '1',
    'text-border-width': '1',
    'text-background-color': 'white',
    'text-background-opacity': '1'
  }).selector('edge[class="consumption"][cardinality > 0]').css({
    'source-label': function sourceLabel(edge) {
      return '' + edge.data('cardinality');
    },
    'source-text-margin-y': '-10',
    'source-text-offset': function sourceTextOffset(edge) {
      return elementStyle.cardinalitydistance(edge);
    }
  }).selector('edge[class="production"][cardinality > 0]').css({
    'target-label': function targetLabel(edge) {
      return '' + edge.data('cardinality');
    },
    'target-text-margin-y': '-10',
    'target-text-offset': function targetTextOffset(edge) {
      return elementStyle.getCardinalityDistance(edge);
    }
  }).selector('edge[class]').css({
    'target-arrow-shape': function targetArrowShape(edge) {
      return elementStyle.sbgnArrowShape(edge);
    },
    'source-arrow-shape': 'none'
  }).selector('edge[class="inhibition"]').css({
    'target-arrow-fill': 'filled'
  }).selector('edge[class="production"]').css({
    'target-arrow-fill': 'filled'
  }).selector('core').css({
    'selection-box-color': '#d67614',
    'selection-box-opacity': '0.2', 'selection-box-border-color': '#d67614'
  });
};

module.exports = sbgnStyleSheet;

},{"./element.js":119,"./glyph/compartment.js":121,"./glyph/entityPoolNodeShapes.js":122,"./glyph/processNodeShapes.js":123,"./glyph/sourceAndSink.js":124}],127:[function(require,module,exports){
'use strict';

var parser = new DOMParser();

var svg = function svg(svgStr) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var vbX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var vbY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var vbWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
  var vbHeight = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 100;

  var svgText = '\n    <svg xmlns=\'http://www.w3.org/2000/svg\' version=\'1.1\' width=\'' + width + '\' height=\'' + height + '\' viewBox=\'' + vbX + ' ' + vbY + ' ' + vbWidth + ' ' + vbHeight + '\'>\n    ' + svgStr + '\n    </svg>\n  ';
  return parser.parseFromString(svgText, 'text/xml').documentElement;
};

var svgb64Str = function svgb64Str(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight) {
  var svgEl = svg(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight);
  var b64Data = 'data:image/svg+xml;base64,' + btoa(svgEl.outerHTML);

  return b64Data;
};

module.exports = svgb64Str;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vL2Jyb3dzZXJpZnktZW50cnkuanMiLCJkZW1vL3Rlc3QtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy8tcHJlYW1ibGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvYS1zdGFyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2JlbGxtYW4tZm9yZC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vYWxnb3JpdGhtcy9iZXR3ZWVubmVzcy1jZW50cmFsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2Jmcy1kZnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvY2xvc2VuZXNzLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGVncmVlLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGlqa3N0cmEuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZmxveWQtd2Fyc2hhbGwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMva2VyZ2VyLXN0ZWluLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2tydXNrYWwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvcGFnZS1yYW5rLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9jb21wYXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vY29tcG91bmRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kZWdyZWUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2RpbWVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2VsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9ncm91cC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2l0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vbGF5b3V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9zdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vc3dpdGNoLWZ1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vdHJhdmVyc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24venNvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FkZC1yZW1vdmUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FuaW1hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9sYXlvdXQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL25vdGlmaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3NlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3ZpZXdwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXZlbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvYnJlYWR0aGZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY29uY2VudHJpYy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvbGF5b3V0L2Nvc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9ncmlkLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcHJlc2V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9iYXNlL2Fycm93LXNoYXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9jb29yZC1lbGUtbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9pbWFnZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvbG9hZC1saXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2Uvbm9kZS1zaGFwZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvcmVkcmF3LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvYXJyb3ctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1lZGdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctZWxlbWVudHMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLWltYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbGFiZWwtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbm9kZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLXJlZHJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZWxlLXRleHR1cmUtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9leHBvcnQtaW1hZ2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2xheWVyZWQtdGV4dHVyZS1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL25vZGUtc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvdGV4dHVyZS1jYWNoZS1kZWZzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvbnVsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2ZhYnJpYy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2hlYXAuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2lzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvanF1ZXJ5LXBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL21hdGguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2J5cGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2dldC1mb3ItZWxlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvc3RyaW5nLXNoZWV0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGVzaGVldC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3RocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvbWFwcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvcmVnZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy91dGlsL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy91dGlsL3RpbWluZy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvZmlsZS1zYXZlci9GaWxlU2F2ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmRlZmF1bHRzZGVlcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL3NyYy9zYmdubWxDb252ZXJ0ZXIuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvc2JnblN0eWxlL2VsZW1lbnQuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2Jhc2VTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2NvbXBhcnRtZW50LmpzIiwic3JjL3NiZ25TdHlsZS9nbHlwaC9lbnRpdHlQb29sTm9kZVNoYXBlcy5qcyIsInNyYy9zYmduU3R5bGUvZ2x5cGgvcHJvY2Vzc05vZGVTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL3NvdXJjZUFuZFNpbmsuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL3VuaXRPZkluZm9ybWF0aW9uLmpzIiwic3JjL3NiZ25TdHlsZS9ncmFwaC5qcyIsInNyYy9zYmduU3R5bGUvdXRpbC9zdmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0VBOzs7Ozs7QUFFQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCLEMsQ0FKQTs7QUFLQSxJQUFJLFNBQVMsUUFBUSxZQUFSLEVBQXNCLE1BQW5DOztBQUVBLElBQUksY0FBYyxRQUFRLGFBQVIsQ0FBbEI7O0FBRUEsSUFBSSxlQUFlLFNBQWYsWUFBZSxDQUFVLFdBQVYsRUFBdUI7QUFDeEMsTUFBSSxLQUFKO0FBQ0EsTUFBSSxPQUFPLGNBQVgsRUFBMkI7QUFDekIsWUFBUSxJQUFJLGNBQUosRUFBUjtBQUNELEdBRkQsTUFHSztBQUNILFlBQVEsSUFBSSxhQUFKLENBQWtCLG1CQUFsQixDQUFSO0FBQ0Q7QUFDRCxRQUFNLElBQU4sQ0FBVyxLQUFYLEVBQWtCLFdBQWxCLEVBQStCLEtBQS9CO0FBQ0EsUUFBTSxJQUFOO0FBQ0EsU0FBTyxNQUFNLFlBQWI7QUFDRCxDQVhEOztBQWFBLElBQUksV0FBVyxTQUFYLFFBQVcsQ0FBVSxRQUFWLEVBQW9CLElBQXBCLEVBQTBCO0FBQ3ZDLE1BQUksU0FBUyxJQUFJLFVBQUosRUFBYjs7QUFFQSxTQUFPLE1BQVAsR0FBZ0IsVUFBVSxDQUFWLEVBQWE7QUFDM0IsUUFBSSxRQUFRLGNBQWMsRUFBRSxNQUFGLENBQVMsTUFBdkIsQ0FBWjtBQUNBLGdCQUFZLFFBQVosRUFBc0IsS0FBdEI7QUFFRCxHQUpEOztBQU1BLFNBQU8sVUFBUCxDQUFrQixJQUFsQjtBQUNELENBVkQ7O0FBWUEsSUFBSSxjQUFjLFNBQWQsV0FBYyxDQUFVLEVBQVYsRUFBYyxPQUFkLEVBQXVCO0FBQ3ZDLEtBQUcsVUFBSDtBQUNBLEtBQUcsTUFBSCxDQUFVLEdBQVY7QUFDQSxLQUFHLEdBQUgsQ0FBTyxPQUFQOztBQUVBLE1BQUksZ0JBQWdCLEVBQXBCO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsS0FBUixDQUFjLE1BQWxDLEVBQTBDLEdBQTFDLEVBQStDO0FBQzdDLFFBQUksT0FBTyxRQUFRLEtBQVIsQ0FBYyxDQUFkLEVBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQTJCLENBQXRDO0FBQ0EsUUFBSSxPQUFPLFFBQVEsS0FBUixDQUFjLENBQWQsRUFBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBMkIsQ0FBdEM7QUFDQSxrQkFBYyxRQUFRLEtBQVIsQ0FBYyxDQUFkLEVBQWlCLElBQWpCLENBQXNCLEVBQXBDLElBQTBDLEVBQUMsS0FBSyxJQUFOLEVBQVksS0FBSyxJQUFqQixFQUExQztBQUNEOztBQUVELEtBQUcsTUFBSCxDQUFVO0FBQ1IsVUFBTSxRQURFO0FBRVIsZUFBVyxhQUZIO0FBR1IsU0FBSyxJQUhHO0FBSVIsYUFBUztBQUpELEdBQVY7O0FBT0EsS0FBRyxRQUFIO0FBQ0EsS0FBRyxLQUFILEdBQVcsTUFBWDtBQUNELENBckJEOztBQXVCQSxJQUFJLFlBQVksU0FBWixTQUFZLENBQVUsT0FBVixFQUFtQixXQUFuQixFQUFnQyxTQUFoQyxFQUEyQztBQUN6RCxnQkFBYyxlQUFlLEVBQTdCO0FBQ0EsY0FBWSxhQUFhLEdBQXpCOztBQUVBLE1BQUksaUJBQWlCLEtBQUssT0FBTCxDQUFyQjtBQUNBLE1BQUksYUFBYSxFQUFqQjs7QUFFQSxPQUFLLElBQUksU0FBUyxDQUFsQixFQUFxQixTQUFTLGVBQWUsTUFBN0MsRUFBcUQsVUFBVSxTQUEvRCxFQUEwRTtBQUN4RSxRQUFJLFFBQVEsZUFBZSxLQUFmLENBQXFCLE1BQXJCLEVBQTZCLFNBQVMsU0FBdEMsQ0FBWjs7QUFFQSxRQUFJLGNBQWMsSUFBSSxLQUFKLENBQVUsTUFBTSxNQUFoQixDQUFsQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLGtCQUFZLENBQVosSUFBaUIsTUFBTSxVQUFOLENBQWlCLENBQWpCLENBQWpCO0FBQ0Q7O0FBRUQsUUFBSSxZQUFZLElBQUksVUFBSixDQUFlLFdBQWYsQ0FBaEI7O0FBRUEsZUFBVyxJQUFYLENBQWdCLFNBQWhCO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPLElBQUksSUFBSixDQUFTLFVBQVQsRUFBcUIsRUFBQyxNQUFNLFdBQVAsRUFBckIsQ0FBWDtBQUNBLFNBQU8sSUFBUDtBQUNELENBdEJEOztBQXdCQSxJQUFJLE9BQU8sU0FBUCxJQUFPLENBQVUsUUFBVixFQUFvQixRQUFwQixFQUE4QjtBQUN2QyxNQUFJLGtCQUFrQixTQUFTLEdBQVQsQ0FBYSxFQUFDLE9BQU8sQ0FBUixFQUFXLE1BQU0sSUFBakIsRUFBYixDQUF0Qjs7QUFFQSxNQUFJLFVBQVUsZ0JBQWdCLE1BQWhCLENBQXVCLGdCQUFnQixPQUFoQixDQUF3QixHQUF4QixJQUErQixDQUF0RCxDQUFkO0FBQ0EsU0FBTyxVQUFVLE9BQVYsRUFBbUIsV0FBbkIsQ0FBUCxFQUF3QyxRQUF4QztBQUNELENBTEQ7O0FBT0EsRUFBRSxRQUFGLEVBQVksS0FBWixDQUFrQixZQUFZOztBQUU1QixNQUFJLFlBQVksRUFBRSx5QkFBRixDQUFoQjs7QUFFQSxNQUFJLFdBQVcsb0JBQWlCO0FBQzlCLGVBQVc7QUFEbUIsR0FBakIsQ0FBZjs7QUFJQSxTQUFPLENBQVAsR0FBVyxPQUFPLEVBQVAsR0FBWSxRQUF2QjtBQUNBLGNBQVksUUFBWixFQUFzQixXQUF0Qjs7QUFFQSxJQUFFLGFBQUYsRUFBaUIsS0FBakIsQ0FBdUIsWUFBWTtBQUNqQyxNQUFFLGNBQUYsRUFBa0IsT0FBbEIsQ0FBMEIsT0FBMUI7QUFDRCxHQUZEOztBQUlBLElBQUUsY0FBRixFQUFrQixNQUFsQixDQUF5QixZQUFZO0FBQ25DLFFBQUksRUFBRSxJQUFGLEVBQVEsR0FBUixNQUFpQixFQUFyQixFQUF5QjtBQUN2QixVQUFJLE9BQU8sS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUFYOztBQUVBLGVBQVMsUUFBVCxFQUFtQixJQUFuQjtBQUNEO0FBQ0YsR0FORDs7QUFRQSxJQUFFLGFBQUYsRUFBaUIsS0FBakIsQ0FBdUIsWUFBWTtBQUNqQyxTQUFLLFFBQUwsRUFBZSxPQUFmO0FBQ0QsR0FGRDs7QUFJQSxJQUFFLGNBQUYsRUFBa0IsS0FBbEIsQ0FBd0IsWUFBWTtBQUNsQyxRQUFJLFdBQVcsYUFBYSxhQUFhLEVBQUUsSUFBRixFQUFRLENBQVIsRUFBVyxTQUF4QixHQUFvQyxNQUFqRCxDQUFmO0FBQ0EsUUFBSSxZQUFZLGNBQWMsUUFBZCxDQUFoQjtBQUNBLGdCQUFZLFFBQVosRUFBc0IsU0FBdEI7QUFDRCxHQUpEO0FBTUQsQ0FqQ0Q7Ozs7O0FDeEZBLElBQUksa0JBQWtCO0FBQ3RCLGFBQVMsQ0FDTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBREssRUFrQkw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsaUJBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUosMkJBQWUsSUFaWDtBQWFKLHFCQUFTO0FBYkw7QUFEWixLQWxCSyxFQW1DTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBbkNLLEVBb0RMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGlCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0FwREssRUFxRUw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGdCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsaUJBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUosMkJBQWUsSUFaWDtBQWFKLHFCQUFTO0FBYkw7QUFEWixLQXJFSyxFQXNGTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBdEZLLEVBdUdMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxrQkFERDtBQUVKLHFCQUFLLGlCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGVBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLENBQ2Q7QUFDSSxzQkFBTSxTQURWO0FBRUkseUJBQVMsZ0JBRmI7QUFHSSx5QkFBUztBQUNMLDZCQUFTO0FBREosaUJBSGI7QUFNSSx3QkFBUTtBQUNKLHlCQUFLLENBREQ7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQXZHSyxFQXFJTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssZ0JBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBcklLLEVBc0pMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0F0SkssRUF1S0w7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsaUJBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUosMkJBQWUsSUFaWDtBQWFKLHFCQUFTO0FBYkw7QUFEWixLQXZLSyxFQXdMTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBeExLLEVBeU1MO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGdCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGVBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLENBQ2Q7QUFDSSxzQkFBTSxVQURWO0FBRUkseUJBQVMsZ0JBRmI7QUFHSSx5QkFBUztBQUNMLDZCQUFTO0FBREosaUJBSGI7QUFNSSx3QkFBUTtBQUNKLHlCQUFLLENBREQ7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQXpNSyxFQXVPTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVM7QUFDTCw2QkFBUztBQURKLGlCQUhiO0FBTUksd0JBQVE7QUFDSix5QkFBSyxDQUFDLEVBREY7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQXZPSyxFQXFRTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxnQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxLQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLHFCQUFTO0FBWkw7QUFEWixLQXJRSyxFQXFSTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssa0JBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sU0FEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVM7QUFDTCw2QkFBUztBQURKLGlCQUhiO0FBTUksd0JBQVE7QUFDSix5QkFBSyxDQUREO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBTlosYUFEYyxDQVZkO0FBeUJKLHNCQUFVLEVBekJOO0FBMEJKLHFCQUFTO0FBMUJMO0FBRFosS0FyUkssRUFtVEw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGtCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsS0FSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSixxQkFBUztBQVpMO0FBRFosS0FuVEssRUFtVUw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFVBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTO0FBQ0wsNkJBQVM7QUFESixpQkFIYjtBQU1JLHdCQUFRO0FBQ0oseUJBQUssQ0FBQyxFQURGO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBTlosYUFEYyxDQVZkO0FBeUJKLHNCQUFVLEVBekJOO0FBMEJKLHFCQUFTO0FBMUJMO0FBRFosS0FuVUssRUFpV0w7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsU0FSTDtBQVNKLDhCQUFrQixFQVRkO0FBVUosc0JBQVUsRUFWTjtBQVdKLHFCQUFTO0FBWEw7QUFEWixLQWpXSyxFQWdYTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVMsRUFIYjtBQUlJLHdCQUFRO0FBQ0oseUJBQUssQ0FERDtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQUpaLGFBRGMsQ0FWZDtBQXVCSixzQkFBVSxFQXZCTjtBQXdCSixxQkFBUztBQXhCTDtBQURaLEtBaFhLLEVBNFlMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxrQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLFNBUkw7QUFTSiw4QkFBa0IsRUFUZDtBQVVKLHNCQUFVLEVBVk47QUFXSixxQkFBUztBQVhMO0FBRFosS0E1WUssRUEyWkw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFVBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTLEVBSGI7QUFJSSx3QkFBUTtBQUNKLHlCQUFLLENBQUMsRUFERjtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQUpaLGFBRGMsQ0FWZDtBQXVCSixzQkFBVSxFQXZCTjtBQXdCSixxQkFBUztBQXhCTDtBQURaLEtBM1pLLEVBdWJMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLFNBUkw7QUFTSiw4QkFBa0IsRUFUZDtBQVVKLHNCQUFVLEVBVk47QUFXSixxQkFBUztBQVhMO0FBRFosS0F2YkssRUFzY0w7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFVBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTLEVBSGI7QUFJSSx3QkFBUTtBQUNKLHlCQUFLLENBQUMsRUFERjtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQUpaLGFBRGMsQ0FWZDtBQXVCSixzQkFBVSxFQXZCTjtBQXdCSixxQkFBUztBQXhCTDtBQURaLEtBdGNLLEVBa2VMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLFNBUkw7QUFTSiw4QkFBa0IsRUFUZDtBQVVKLHNCQUFVLEVBVk47QUFXSixxQkFBUztBQVhMO0FBRFosS0FsZUssRUFpZkw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsU0FSTDtBQVNKLDhCQUFrQixFQVRkO0FBVUosc0JBQVUsRUFWTjtBQVdKLHFCQUFTO0FBWEw7QUFEWixLQWpmSyxFQWdnQkw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFVBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTO0FBQ0wsNkJBQVM7QUFESixpQkFIYjtBQU1JLHdCQUFRO0FBQ0oseUJBQUssQ0FBQyxFQURGO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBTlosYUFEYyxDQVZkO0FBeUJKLHNCQUFVLEVBekJOO0FBMEJKLHFCQUFTO0FBMUJMO0FBRFosS0FoZ0JLLENBRGE7QUFnaUJ0QixhQUFTLENBQ0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBREssRUFZTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FaSyxFQXVCTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F2QkssRUFrQ0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFdBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBbENLLEVBNkNMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTdDSyxFQXdETDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F4REssRUFtRUw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBbkVLLEVBOEVMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTlFSyxFQXlGTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F6RkssRUFvR0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFdBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBcEdLLEVBK0dMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxXQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQS9HSyxFQTBITDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0ExSEssRUFxSUw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBcklLLEVBZ0pMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQWhKSyxFQTJKTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0EzSkssRUFzS0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBdEtLLEVBaUxMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxXQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQWpMSyxFQTRMTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsV0FETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0E1TEssRUF1TUw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGlCQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXZNSyxFQWtOTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsaUJBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBbE5LLEVBNk5MO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTdOSyxFQXdPTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F4T0ssRUFtUEw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBblBLLEVBOFBMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTlQSyxFQXlRTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F6UUssRUFvUkw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBcFJLLEVBK1JMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQS9SSztBQWhpQmEsQ0FBdEI7O0FBNjBCQSxPQUFPLE9BQVAsR0FBaUIsZUFBakI7OztBQzcwQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeC9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNockJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8vQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5c0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNyY0EsSUFBSSxZQUFZLFFBQVEsV0FBUixDQUFoQjtBQUNBLElBQUksZUFBZSxRQUFRLHFCQUFSLENBQW5COztBQUVBLElBQUksaUJBQWlCLFFBQVEsbUJBQVIsQ0FBckI7O0FBRUEsSUFBSSxpQkFBaUI7QUFDbkIsU0FBTyxlQUFlLFNBQWYsQ0FEWTtBQUVuQix1QkFBcUIsSUFGRjtBQUduQixlQUFhLEtBSE07QUFJbkIsV0FBUyxLQUpVO0FBS25CLFdBQVMsS0FMVTtBQU1uQixjQUFZLEtBTk87QUFPbkIsb0JBQWtCO0FBUEMsQ0FBckI7O0lBVU0sWTs7O0FBQ0osd0JBQWEsT0FBYixFQUFzQjtBQUFBOztBQUFBLHVIQUNiLGFBQWMsRUFBZCxFQUFrQixjQUFsQixFQUFrQyxPQUFsQyxDQURhO0FBRXJCO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0VBVDJCLFM7O0FBWTNCLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7Ozs7QUMzQkEsSUFBSSxlQUFlLEVBQW5COztBQUVBLGFBQWEsU0FBYixHQUF5QixVQUFDLElBQUQsRUFBVTtBQUNqQyxNQUFJLFlBQVksS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQjtBQUNBLE1BQUksVUFBVSxRQUFWLENBQW1CLFdBQW5CLENBQUosRUFBcUM7QUFDbkMsZ0JBQVksVUFBVSxPQUFWLENBQWtCLFdBQWxCLEVBQStCLEVBQS9CLENBQVo7QUFDRDs7QUFFRCxNQUFJLGFBQWEsV0FBakIsRUFBOEI7QUFDNUIsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLFNBQWpCLEVBQTRCO0FBQzFCLFdBQU8sUUFBUDtBQUNEOztBQUVELE1BQUksYUFBYSxrQkFBYixJQUFtQyxhQUFhLEtBQWhELElBQ0MsYUFBYSxpQkFEZCxJQUNtQyxhQUFhLGFBRGhELElBQ2lFLGFBQWEsU0FEbEYsRUFDNkY7QUFDM0YsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLGNBQWpCLEVBQWlDO0FBQy9CLFdBQU8sU0FBUDtBQUNEOztBQUVELE1BQUssYUFBYSxzQkFBYixJQUNFLGFBQWEsZUFEZixJQUNrQyxhQUFhLGlCQUQvQyxJQUVFLGFBQWEsaUJBRmYsSUFHRSxhQUFhLG1CQUhmLElBR3NDLGFBQWEsYUFIeEQsRUFJSTtBQUNGLFdBQU8sZ0JBQVA7QUFDRDtBQUNELFNBQU8sU0FBUDtBQUNELENBL0JEOztBQWlDQSxhQUFhLGNBQWIsR0FBOEIsVUFBQyxJQUFELEVBQVU7QUFDdEMsTUFBSSxZQUFZLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEI7QUFDQSxNQUFJLGFBQWEsdUJBQWpCLEVBQTBDO0FBQ3hDLFdBQU8sZ0JBQVA7QUFDRDtBQUNELE1BQUksYUFBYSxZQUFqQixFQUErQjtBQUM3QixXQUFPLEtBQVA7QUFDRDtBQUNELE1BQUksYUFBYSxXQUFqQixFQUE4QjtBQUM1QixXQUFPLFFBQVA7QUFDRDtBQUNELE1BQUksYUFBYSxhQUFiLElBQThCLGFBQWEsWUFBL0MsRUFBNkQ7QUFDM0QsV0FBTyxVQUFQO0FBQ0Q7QUFDRCxNQUFJLGFBQWEsWUFBakIsRUFBK0I7QUFDN0IsV0FBTyxTQUFQO0FBQ0Q7QUFDRCxTQUFPLE1BQVA7QUFDRCxDQWxCRDs7QUFvQkEsYUFBYSxXQUFiLEdBQTJCLFVBQUMsSUFBRCxFQUFVO0FBQ25DLE1BQUksWUFBWSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCO0FBQ0EsTUFBSSxVQUFVLEVBQWQ7O0FBRUEsTUFBSSxVQUFVLFFBQVYsQ0FBbUIsV0FBbkIsQ0FBSixFQUFxQztBQUNuQyxnQkFBWSxVQUFVLE9BQVYsQ0FBa0IsV0FBbEIsRUFBK0IsRUFBL0IsQ0FBWjtBQUNEOztBQUVELE1BQUksYUFBYSxlQUFiLElBQWdDLGFBQWEsaUJBQTdDLElBQ0csYUFBYSxXQURoQixJQUVHLGFBQWEsb0JBRmhCLElBRXdDLGFBQWEsc0JBRnJELElBR0csYUFBYSxrQkFIaEIsSUFHc0MsYUFBYSxLQUh2RCxFQUc4RDtBQUM1RCxjQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsSUFBcUIsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFyQixHQUEwQyxFQUFwRDtBQUNELEdBTEQsTUFNSyxJQUFHLGFBQWEsYUFBaEIsRUFBOEI7QUFDakMsY0FBVSxLQUFLLElBQUwsQ0FBVSxPQUFWLElBQXFCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBckIsR0FBMEMsRUFBcEQ7QUFDRCxHQUZJLE1BR0EsSUFBRyxhQUFhLFNBQWhCLEVBQTBCO0FBQzdCLFFBQUcsS0FBSyxRQUFMLEdBQWdCLE1BQWhCLElBQTBCLENBQTdCLEVBQStCO0FBQzdCLFVBQUcsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFILEVBQXNCO0FBQ3BCLGtCQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBVjtBQUNELE9BRkQsTUFHSyxJQUFHLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBSCxFQUEwQjtBQUM3QixrQkFBVSxLQUFLLElBQUwsQ0FBVSxXQUFWLENBQVY7QUFDRCxPQUZJLE1BR0Q7QUFDRixrQkFBVSxFQUFWO0FBQ0Q7QUFDRixLQVZELE1BV0k7QUFDRixnQkFBVSxFQUFWO0FBQ0Q7QUFDRixHQWZJLE1BZ0JBLElBQUksYUFBYSxLQUFqQixFQUF3QjtBQUMzQixjQUFVLEtBQVY7QUFDRCxHQUZJLE1BR0EsSUFBSSxhQUFhLElBQWpCLEVBQXVCO0FBQzFCLGNBQVUsSUFBVjtBQUNELEdBRkksTUFHQSxJQUFJLGFBQWEsS0FBakIsRUFBd0I7QUFDM0IsY0FBVSxLQUFWO0FBQ0QsR0FGSSxNQUdBLElBQUksYUFBYSxpQkFBakIsRUFBb0M7QUFDdkMsY0FBVSxNQUFWO0FBQ0QsR0FGSSxNQUdBLElBQUksYUFBYSxtQkFBakIsRUFBc0M7QUFDekMsY0FBVSxHQUFWO0FBQ0Q7O0FBRUQsU0FBTyxPQUFQO0FBQ0QsQ0FsREQ7O0FBb0RBLElBQU0sdUJBQXVCLFNBQXZCLG9CQUF1QixDQUFDLFVBQUQsRUFBcUM7QUFBQSxNQUF4QixlQUF3Qix1RUFBTixDQUFNOztBQUNoRSxTQUFRLGFBQWEsSUFBZCxHQUFzQixlQUE3QjtBQUNELENBRkQ7O0FBSUEsYUFBYSxhQUFiLEdBQTZCLFVBQUMsSUFBRCxFQUFVO0FBQ3JDLE1BQU0sWUFBWSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWxCO0FBQ0EsTUFBTSxLQUFLLEtBQUssTUFBTCxFQUFYOztBQUVBO0FBQ0E7QUFDQSxNQUFJLGNBQWMsYUFBZCxJQUErQixjQUFjLGNBQWpELEVBQWlFO0FBQy9ELFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQUksY0FBYyxLQUFkLElBQXVCLGNBQWMsSUFBckMsSUFBNkMsY0FBYyxLQUEvRCxFQUFzRTtBQUNwRSxXQUFPLHFCQUFxQixFQUFyQixFQUF5QixDQUF6QixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxVQUFVLFFBQVYsQ0FBbUIsU0FBbkIsQ0FBSixFQUFtQztBQUNqQyxXQUFPLHFCQUFxQixFQUFyQixFQUF5QixHQUF6QixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxjQUFjLFNBQWQsSUFBMkIsY0FBYyxhQUE3QyxFQUE0RDtBQUMxRCxXQUFPLEVBQVA7QUFDRDs7QUFFRCxTQUFPLHFCQUFxQixFQUFyQixDQUFQO0FBQ0QsQ0F2QkQ7O0FBeUJBLGFBQWEsbUJBQWIsR0FBbUMsVUFBQyxJQUFELEVBQVU7QUFDM0MsTUFBTSxTQUFTLEtBQUssTUFBTCxHQUFjLFFBQWQsRUFBZjtBQUNBLE1BQU0sU0FBUyxLQUFLLE1BQUwsR0FBYyxRQUFkLEVBQWY7O0FBRUEsTUFBTSxXQUFXLEtBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxDQUFVLE9BQU8sQ0FBUCxHQUFXLE9BQU8sQ0FBNUIsRUFBZ0MsQ0FBaEMsSUFBcUMsS0FBSyxHQUFMLENBQVUsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUE1QixFQUFnQyxDQUFoQyxDQUEvQyxDQUFqQjtBQUNBLFNBQU8sV0FBVyxJQUFsQjtBQUNELENBTkQ7O0FBUUEsT0FBTyxPQUFQLEdBQWlCLFlBQWpCOzs7Ozs7Ozs7QUNoSkEsSUFBTSxhQUFhO0FBQ2pCLGNBRGlCLHdCQUNILFFBREcsRUFDTztBQUN0QixnQkFBVSw2QkFBSSxRQUFKLEdBQWMsR0FBZCxDQUFrQjtBQUFBO0FBQUEsVUFBRSxDQUFGO0FBQUEsVUFBSyxDQUFMOztBQUFBLGFBQWUsQ0FBZixVQUFxQixDQUFyQjtBQUFBLEtBQWxCLEVBQTZDLElBQTdDLENBQWtELEdBQWxELENBQVY7QUFDRCxHQUhnQjtBQUtqQixlQUxpQix5QkFLSCxDQUxHLEVBS0EsQ0FMQSxFQUtHLENBTEgsRUFLTSxDQUxOLEVBS1MsRUFMVCxFQUthLEVBTGIsRUFLaUIsRUFMakIsRUFLcUIsRUFMckIsRUFLeUIsUUFMekIsRUFLbUM7QUFDbEQsb0NBQ2UsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGYsMEJBRU0sSUFBSSxFQUZWLFVBRWdCLENBRmhCLG1CQUdNLElBQUksQ0FBSixHQUFRLEVBSGQsVUFHb0IsQ0FIcEIsWUFHMkIsSUFBSSxDQUgvQixVQUdvQyxDQUhwQyxVQUd5QyxJQUFJLENBSDdDLFdBR2tELElBQUksRUFIdEQsb0JBSU0sSUFBSSxDQUpWLFdBSWdCLElBQUksQ0FBSixHQUFRLEVBSnhCLGFBSWdDLElBQUksQ0FKcEMsV0FJeUMsSUFBSSxDQUo3QyxXQUlrRCxJQUFJLENBQUosR0FBUSxFQUoxRCxXQUlnRSxJQUFJLENBSnBFLG9CQUtNLElBQUksRUFMVixXQUtnQixJQUFJLENBTHBCLFlBSzJCLENBTDNCLFVBS2dDLElBQUksQ0FMcEMsVUFLeUMsQ0FMekMsVUFLOEMsSUFBSSxDQUFKLEdBQVEsRUFMdEQsbUJBTU0sQ0FOTixVQU1XLElBQUksRUFOZixZQU11QixDQU52QixTQU00QixDQU41QixVQU1pQyxJQUFJLEVBTnJDLFVBTTJDLENBTjNDO0FBVUQsR0FoQmdCO0FBa0JqQixRQWxCaUIsa0JBa0JWLEtBbEJVLEVBa0JILE1BbEJHLEVBa0JLLFFBbEJMLEVBa0JlO0FBQzlCLGtDQUVZLEtBQUssWUFBTCxDQUFrQixRQUFsQixDQUZaLDZCQUdlLElBQUUsS0FIakIsU0FHMEIsTUFBSSxNQUg5QixXQUcwQyxJQUFFLEtBSDVDLFNBR3FELE1BQUksTUFIekQsV0FHcUUsT0FBSyxLQUgxRSxTQUdtRixNQUhuRixTQUc2RixPQUFLLEtBSGxHLFNBRzJHLE1BSDNHLGdDQUtlLE9BQUssS0FMcEIsU0FLNkIsTUFMN0IsV0FLeUMsT0FBSyxLQUw5QyxTQUt1RCxNQUx2RCxXQUttRSxPQUFLLEtBTHhFLFNBS2lGLE1BTGpGLFNBSzJGLEtBTDNGLFNBS29HLE9BQUssTUFMekcsZ0NBT2UsS0FQZixTQU93QixNQUFJLE1BUDVCLFdBT3dDLEtBUHhDLFNBT2lELE9BQUssTUFQdEQsV0FPa0UsS0FQbEUsU0FPMkUsSUFBRSxNQVA3RSxTQU91RixPQUFLLEtBUDVGLFNBT3FHLElBQUUsTUFQdkcsZ0NBU2UsT0FBSyxLQVRwQixTQVM2QixJQUFFLE1BVC9CLFdBUzJDLE9BQUssS0FUaEQsU0FTeUQsSUFBRSxNQVQzRCxXQVN1RSxPQUFLLEtBVDVFLFNBU3FGLElBQUUsTUFUdkYsU0FTaUcsSUFBRSxLQVRuRyxTQVM0RyxPQUFLLE1BVGpIO0FBYUQsR0FoQ2dCO0FBa0NqQixRQWxDaUIsa0JBa0NWLEVBbENVLEVBa0NOLEVBbENNLEVBa0NGLENBbENFLEVBa0NDLFFBbENELEVBa0NXO0FBQzFCLDZCQUFzQixFQUF0QixnQkFBaUMsRUFBakMsZUFBMkMsQ0FBM0MsbUJBQXdELEtBQUssWUFBTCxDQUFrQixRQUFsQixDQUF4RDtBQUNELEdBcENnQjtBQXNDakIsZ0JBdENpQiwwQkFzQ0YsS0F0Q0UsRUFzQ0ssTUF0Q0wsRUFzQ2EsUUF0Q2IsRUFzQ3VCO0FBQ3RDLHVDQUNrQixLQUFLLFlBQUwsQ0FBa0IsUUFBbEIsQ0FEbEIsMkJBRVksQ0FGWixVQUVrQixDQUZsQixVQUV3QixLQUZ4QixVQUVrQyxDQUZsQyxVQUV3QyxPQUFLLEtBRjdDLFVBRXVELE1BQUksTUFGM0QsVUFFc0UsS0FGdEUsVUFFZ0YsTUFGaEYsVUFFMkYsQ0FGM0YsVUFFaUcsTUFGakcsVUFFNEcsT0FBSyxLQUZqSCxVQUUySCxNQUFJLE1BRi9IO0FBSUQsR0EzQ2dCO0FBNkNqQixjQTdDaUIsd0JBNkNKLEtBN0NJLEVBNkNHLE1BN0NILEVBNkNXLFFBN0NYLEVBNkNxQjtBQUNwQyx1Q0FDa0IsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGxCLG1DQUdJLElBQUUsS0FITixTQUdlLE9BQUssTUFIcEIsU0FHOEIsT0FBSyxLQUhuQyxTQUc0QyxJQUFFLE1BSDlDLFNBR3dELE9BQUssS0FIN0QsU0FHc0UsSUFBRSxNQUh4RSxTQUdrRixLQUhsRixTQUcyRixPQUFLLE1BSGhHLGdCQUlJLEtBSkosU0FJYSxPQUFLLE1BSmxCLFNBSTRCLE9BQUssS0FKakMsU0FJMEMsTUFKMUMsU0FJb0QsT0FBSyxLQUp6RCxTQUlrRSxNQUpsRSxTQUk0RSxJQUFFLEtBSjlFLFNBSXVGLE9BQUssTUFKNUY7QUFRRCxHQXREZ0I7QUF3RGpCLFNBeERpQixtQkF3RFQsRUF4RFMsRUF3REwsRUF4REssRUF3REQsRUF4REMsRUF3REcsRUF4REgsRUF3RE8sUUF4RFAsRUF3RGlCO0FBQ2hDLHNDQUNpQixFQURqQixnQkFDNEIsRUFENUIsZ0JBQ3VDLEVBRHZDLGdCQUNrRCxFQURsRCxtQkFDZ0UsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGhFO0FBR0QsR0E1RGdCO0FBOERqQixTQTlEaUIsbUJBOERULEtBOURTLEVBOERGLE1BOURFLEVBOERNLFFBOUROLEVBOERnQjtBQUMvQix1Q0FDa0IsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGxCLDJCQUVZLENBRlosVUFFa0IsTUFBSSxNQUZ0QixVQUVpQyxPQUFLLEtBRnRDLFVBRWdELElBQUUsTUFGbEQsVUFFNkQsT0FBSyxLQUZsRSxVQUU0RSxJQUFFLE1BRjlFLFVBRXlGLEtBRnpGLFVBRW1HLE1BQUksTUFGdkcsVUFFa0gsT0FBSyxLQUZ2SCxVQUVpSSxNQUZqSSxVQUU0SSxPQUFLLEtBRmpKLFVBRTJKLE1BRjNKO0FBSUQsR0FuRWdCO0FBcUVqQixNQXJFaUIsZ0JBcUVaLEVBckVZLEVBcUVSLEVBckVRLEVBcUVKLEVBckVJLEVBcUVBLEVBckVBLEVBcUVJLFFBckVKLEVBcUVjO0FBQzdCLDJCQUFvQixFQUFwQixnQkFBK0IsRUFBL0IsZ0JBQTBDLEVBQTFDLGdCQUFxRCxFQUFyRCxtQkFBbUUsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBQW5FO0FBQ0QsR0F2RWdCO0FBeUVqQixXQXpFaUIscUJBeUVQLENBekVPLEVBeUVKLENBekVJLEVBeUVELEtBekVDLEVBeUVNLE1BekVOLEVBeUVjLFFBekVkLEVBeUV3QjtBQUN2QyxXQUFPLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRCxFQUFvRCxRQUFwRCxDQUFQO0FBQ0QsR0EzRWdCO0FBNkVqQixzQkE3RWlCLGdDQTZFSSxDQTdFSixFQTZFTyxDQTdFUCxFQTZFVSxLQTdFVixFQTZFaUIsTUE3RWpCLEVBNkV5QixRQTdFekIsRUE2RW1DO0FBQ2xELFdBQU8sS0FBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLEtBQXpCLEVBQWdDLE1BQWhDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLEtBQUcsTUFBakQsRUFBeUQsS0FBRyxNQUE1RCxFQUFvRSxRQUFwRSxDQUFQO0FBQ0QsR0EvRWdCO0FBaUZqQixnQkFqRmlCLDBCQWlGRixDQWpGRSxFQWlGQyxDQWpGRCxFQWlGSSxLQWpGSixFQWlGVyxNQWpGWCxFQWlGbUIsUUFqRm5CLEVBaUY2QjtBQUM1QyxXQUFPLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxFQUF3QyxLQUFHLE1BQTNDLEVBQW1ELEtBQUcsTUFBdEQsRUFBOEQsS0FBRyxNQUFqRSxFQUF5RSxLQUFHLE1BQTVFLEVBQW9GLFFBQXBGLENBQVA7QUFDRCxHQW5GZ0I7QUFxRmpCLFFBckZpQixrQkFxRlYsQ0FyRlUsRUFxRlAsQ0FyRk8sRUFxRkosTUFyRkksRUFxRkksUUFyRkosRUFxRmM7QUFDN0IsV0FBTyxLQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsRUFBaUMsTUFBakMsRUFBeUMsQ0FBekMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QsQ0FBbEQsRUFBcUQsUUFBckQsQ0FBUDtBQUNELEdBdkZnQjtBQXlGakIsTUF6RmlCLGdCQXlGWixDQXpGWSxFQXlGVCxDQXpGUyxFQXlGTixDQXpGTSxFQXlGSCxVQXpGRyxFQXlGUyxRQXpGVCxFQXlGbUI7QUFDbEMsMEJBQW1CLENBQW5CLGVBQTRCLENBQTVCLHdCQUE4QyxVQUE5QyxtQkFBb0UsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBQXBFLFdBQW9HLENBQXBHO0FBQ0Q7QUEzRmdCLENBQW5COztBQWdHQSxPQUFPLE9BQVAsR0FBaUIsVUFBakI7Ozs7O0FDaEdBLElBQUksYUFBYSxRQUFRLGlCQUFSLENBQWpCOztBQUVBLElBQUksWUFBWSxRQUFRLGdCQUFSLENBQWhCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsd0JBQVIsQ0FBakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTSxRQUFRLG1DQUFkOztBQUVBLElBQU0sUUFBUSwrQkFBZDs7QUFFQSxJQUFNLFFBQVEsNkJBQWQ7O0FBRUEsSUFBTSxRQUFRLGdDQUFkOztBQUVBLElBQU0sU0FBUyxTQUFULE1BQVMsR0FBTTtBQUNuQixTQUFVLEtBQVYsVUFBb0IsS0FBcEIsVUFBOEIsS0FBOUIsVUFBd0MsS0FBeEM7QUFDRCxDQUZEOztBQUlBLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxJQUFELEVBQThCO0FBQUEsTUFBdkIsV0FBdUIsdUVBQVQsSUFBUzs7O0FBRTNDLE1BQUksS0FBSyxLQUFLLFdBQUwsRUFBVDtBQUNBLE1BQUksS0FBSyxLQUFLLFVBQUwsRUFBVDs7QUFFQSxNQUFJLFFBQVEsRUFBWjs7QUFFQSxNQUFJLEtBQUssSUFBTCxDQUFVLGdCQUFWLEVBQTRCLE1BQTVCLEdBQXFDLENBQXpDLEVBQTRDO0FBQzFDLFFBQU0sT0FBTyxLQUFLLElBQUwsQ0FBVSxnQkFBVixFQUE0QixDQUE1QixFQUErQixLQUEvQixDQUFxQyxJQUFsRCxDQUQwQyxDQUNjO0FBQ3hELFlBQVEsV0FBVyxLQUFYLENBQWlCLElBQWpCLEVBQXVCLENBQXZCLEVBQTBCLEtBQUssQ0FBL0IsRUFBa0MsS0FBRyxFQUFyQyxFQUF5QyxPQUFLLEVBQTlDLEVBQWtELEVBQWxELEVBQXNELEVBQXRELENBQVI7QUFDRDs7QUFFRCxNQUFJLFFBQVEsSUFBSSxHQUFKLEdBQ1QsR0FEUyxDQUNMLGNBREssRUFDVyxXQURYLEVBRVQsR0FGUyxDQUVMLE1BRkssRUFFRyxNQUZILEVBR1QsR0FIUyxDQUdMLFFBSEssRUFHSyxTQUhMLENBQVo7O0FBS0EsTUFBTSx1QkFFSixXQUFXLE1BQVgsQ0FBa0IsRUFBbEIsRUFBc0IsRUFBdEIsRUFBMEIsS0FBMUIsQ0FGSSxZQUdKLEtBSEksU0FBTjs7QUFNQSxTQUFPLFVBQVUsV0FBVixFQUF1QixFQUF2QixFQUEyQixFQUEzQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxDQUFQO0FBQ0QsQ0F4QkQ7O0FBMEJBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFVBQVEsTUFETztBQUVmLFVBQVE7QUFGTyxDQUFqQjs7Ozs7QUMvQ0EsSUFBTSxhQUFhLFFBQVEsaUJBQVIsQ0FBbkI7QUFDQSxJQUFNLFNBQVMsUUFBUSxnQkFBUixDQUFmOztBQUVBLElBQU0sa0JBQWtCO0FBRXRCLG1CQUZzQiw2QkFFSixJQUZJLEVBRUU7QUFDdEIsUUFBSSxLQUFLLEtBQUssS0FBTCxFQUFUO0FBQ0EsUUFBSSxLQUFLLEtBQUssTUFBTCxFQUFUOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsY0FGVSxFQUVNLEdBRk4sRUFHZCxHQUhjLENBR1YsTUFIVSxFQUdGLE1BSEUsQ0FBZjs7QUFLQSxRQUFJLCtCQUVBLFdBQVcsT0FBWCxDQUFtQixLQUFLLENBQXhCLEVBQTJCLEtBQUssQ0FBaEMsRUFBbUMsQ0FBRSxLQUFLLENBQVAsSUFBYSxDQUFoRCxFQUFtRCxDQUFFLEtBQUssQ0FBUCxJQUFhLENBQWhFLEVBQW1FLFFBQW5FLENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxlQUFQLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLEVBQXRDLEVBQTBDLEVBQTFDLENBQVA7QUFDRCxHQWhCcUI7QUFpQnRCLGdCQWpCc0IsMEJBaUJQLElBakJPLEVBaUJEO0FBQ25CLFFBQUksS0FBSyxLQUFLLEtBQUwsRUFBVDtBQUNBLFFBQUksS0FBSyxLQUFLLE1BQUwsRUFBVDs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGNBRlUsRUFFTSxHQUZOLEVBR2QsR0FIYyxDQUdWLE1BSFUsRUFHRixNQUhFLENBQWY7O0FBS0EsUUFBSSxpQ0FFQSxXQUFXLE1BQVgsQ0FBa0IsS0FBSyxDQUF2QixFQUEwQixLQUFLLENBQS9CLEVBQWtDLENBQUMsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBcEIsSUFBeUIsQ0FBM0QsRUFBOEQsUUFBOUQsQ0FGQSxXQUFKO0FBSUEsV0FBTyxPQUFPLGlCQUFQLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLEVBQXhDLEVBQTRDLEVBQTVDLENBQVA7QUFDRCxHQS9CcUI7QUFnQ3RCLGVBaENzQix5QkFnQ1IsSUFoQ1EsRUFnQ0Y7QUFDbEIsUUFBSSxLQUFLLEtBQUssS0FBTCxFQUFUO0FBQ0EsUUFBSSxLQUFLLEtBQUssTUFBTCxFQUFUOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsY0FGVSxFQUVNLEdBRk4sRUFHZCxHQUhjLENBR1YsTUFIVSxFQUdGLE1BSEUsQ0FBZjs7QUFLQSxRQUFJLGdDQUVBLFdBQVcsY0FBWCxDQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxFQUFoQyxFQUFvQyxFQUFwQyxFQUF3QyxRQUF4QyxDQUZBLFdBQUo7QUFJQSxXQUFPLE9BQU8sZ0JBQVAsRUFBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsRUFBdkMsRUFBMkMsRUFBM0MsQ0FBUDtBQUNELEdBOUNxQjtBQStDdEIsb0JBL0NzQiw4QkErQ0gsSUEvQ0csRUErQ0c7QUFDdkIsUUFBSSxLQUFLLEtBQUssS0FBTCxFQUFUO0FBQ0EsUUFBSSxLQUFLLEtBQUssTUFBTCxFQUFUOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsY0FGVSxFQUVNLEdBRk4sRUFHZCxHQUhjLENBR1YsTUFIVSxFQUdGLE1BSEUsQ0FBZjs7QUFLQSxRQUFJLHFDQUVBLFdBQVcsb0JBQVgsQ0FBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0MsRUFBdEMsRUFBMEMsRUFBMUMsRUFBOEMsUUFBOUMsQ0FGQSxXQUFKO0FBSUEsV0FBTyxPQUFPLHFCQUFQLEVBQThCLEVBQTlCLEVBQWtDLEVBQWxDLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDLEVBQTRDLEVBQTVDLEVBQWdELEVBQWhELENBQVA7QUFDRCxHQTdEcUI7QUE4RHRCLFNBOURzQixtQkE4RGQsSUE5RGMsRUE4RFI7QUFDWixRQUFJLEtBQUssS0FBSyxVQUFMLEVBQVQ7QUFDQSxRQUFJLEtBQUssS0FBSyxXQUFMLEVBQVQ7O0FBRUEsUUFBSSxXQUFXLElBQUksR0FBSixHQUNkLEdBRGMsQ0FDVixRQURVLEVBQ0EsU0FEQSxFQUVkLEdBRmMsQ0FFVixjQUZVLEVBRU0sR0FGTixFQUdkLEdBSGMsQ0FHVixNQUhVLEVBR0YsTUFIRSxDQUFmOztBQUtBLFFBQUksMEJBRUEsV0FBVyxZQUFYLENBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLFFBQWhDLENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxVQUFQLEVBQW1CLEVBQW5CLEVBQXVCLEVBQXZCLEVBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLENBQVA7QUFDRCxHQTVFcUI7QUE2RXRCLGVBN0VzQix5QkE2RVIsSUE3RVEsRUE2RUY7QUFDbEIsUUFBSSxjQUFjLEtBQUssS0FBTCxLQUFlLENBQWpDO0FBQ0EsUUFBSSxjQUFjLEtBQUssTUFBTCxLQUFnQixDQUFsQztBQUNBLFFBQUksZUFBZSxDQUFDLEtBQUssS0FBTCxLQUFlLENBQWhCLElBQXFCLENBQXhDOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsZ0JBRlUsRUFFUSxRQUZSLEVBR2QsR0FIYyxDQUdWLGNBSFUsRUFHTSxLQUhOLEVBSWQsR0FKYyxDQUlWLE1BSlUsRUFJRixNQUpFLENBQWY7O0FBTUEsUUFBTSxnQ0FFRixXQUFXLE1BQVgsQ0FBa0IsV0FBbEIsRUFBK0IsV0FBL0IsRUFBNEMsWUFBNUMsRUFBMEQsUUFBMUQsQ0FGRSxnQkFHRixXQUFXLElBQVgsQ0FBZ0IsQ0FBaEIsRUFBbUIsS0FBSyxNQUFMLEVBQW5CLEVBQWtDLEtBQUssS0FBTCxFQUFsQyxFQUFnRCxDQUFoRCxFQUFtRCxRQUFuRCxDQUhFLFdBQU47QUFLQSxXQUFPLE9BQU8sZ0JBQVAsRUFBeUIsS0FBSyxLQUFMLEVBQXpCLEVBQXVDLEtBQUssTUFBTCxFQUF2QyxFQUFzRCxDQUF0RCxFQUF5RCxDQUF6RCxFQUE0RCxLQUFLLEtBQUwsRUFBNUQsRUFBMEUsS0FBSyxNQUFMLEVBQTFFLENBQVA7QUFDRCxHQTlGcUI7QUErRnRCLGlCQS9Gc0IsMkJBK0ZOLElBL0ZNLEVBK0ZBO0FBQ3BCLFFBQUksS0FBSyxLQUFLLEtBQUwsRUFBVDtBQUNBLFFBQUksS0FBSyxLQUFLLE1BQUwsRUFBVDs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGNBRlUsRUFFTSxHQUZOLEVBR2QsR0FIYyxDQUdWLE1BSFUsRUFHRixNQUhFLENBQWY7O0FBS0EsUUFBSSxrQ0FFQSxXQUFXLGNBQVgsQ0FBMEIsRUFBMUIsRUFBOEIsRUFBOUIsRUFBa0MsUUFBbEMsQ0FGQSxXQUFKO0FBSUEsV0FBTyxPQUFPLGtCQUFQLEVBQTJCLEVBQTNCLEVBQStCLEVBQS9CLEVBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLENBQVA7QUFDRDtBQTdHcUIsQ0FBeEI7O0FBZ0hBLElBQU0sU0FBUyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsaUJBRFUsRUFDUyxnQkFBZ0IsYUFEekIsRUFFZCxHQUZjLENBRVYsb0JBRlUsRUFFWSxnQkFBZ0IsaUJBRjVCLEVBR2QsR0FIYyxDQUdWLGlCQUhVLEVBR1MsZ0JBQWdCLGNBSHpCLEVBSWQsR0FKYyxDQUlWLGVBSlUsRUFJTyxnQkFBZ0IsYUFKdkIsRUFLZCxHQUxjLENBS1Ysc0JBTFUsRUFLYyxnQkFBZ0Isa0JBTDlCLEVBTWQsR0FOYyxDQU1WLFNBTlUsRUFNQyxnQkFBZ0IsT0FOakIsRUFPZCxHQVBjLENBT1Ysa0JBUFUsRUFPVSxnQkFBZ0IsZUFQMUIsQ0FBZjs7QUFTQSxJQUFNLE9BQU8sU0FBUCxJQUFPLENBQUMsSUFBRCxFQUFVO0FBQ3JCLFNBQU8sT0FBTyxHQUFQLENBQVcsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFYLEVBQStCLElBQS9CLEtBQXdDLEVBQS9DO0FBQ0QsQ0FGRDs7QUFJQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixRQUFNO0FBRFMsQ0FBakI7Ozs7O0FDaElBLElBQU0sYUFBYSxRQUFRLGlCQUFSLENBQW5CO0FBQ0EsSUFBTSxTQUFTLFFBQVEsZ0JBQVIsQ0FBZjs7QUFFQSxJQUFNLGVBQWU7QUFFbkIsU0FGbUIsbUJBRVgsSUFGVyxFQUVMO0FBQ1osUUFBTSxLQUFLLEtBQUssS0FBTCxFQUFYO0FBQ0EsUUFBTSxLQUFLLEtBQUssTUFBTCxFQUFYOztBQUVBLFFBQU0sWUFBWSxJQUFJLEdBQUosR0FDakIsR0FEaUIsQ0FDYixRQURhLEVBQ0gsU0FERyxFQUVqQixHQUZpQixDQUViLGNBRmEsRUFFRyxHQUZILEVBR2pCLEdBSGlCLENBR2IsTUFIYSxFQUdMLE1BSEssQ0FBbEI7O0FBS0EsUUFBTSxjQUFjLElBQUksR0FBSixHQUNuQixHQURtQixDQUNmLFFBRGUsRUFDTCxTQURLLEVBRW5CLEdBRm1CLENBRWYsY0FGZSxFQUVDLEdBRkQsRUFHbkIsR0FIbUIsQ0FHZixNQUhlLEVBR1AsT0FITyxFQUluQixHQUptQixDQUlmLGNBSmUsRUFJQyxHQUpELENBQXBCOztBQU1BLFFBQU0sT0FBTyxXQUFXLElBQVgsQ0FBZ0IsQ0FBaEIsRUFBbUIsS0FBSyxDQUF4QixFQUEyQixFQUEzQixFQUErQixLQUFLLENBQXBDLEVBQXVDLFNBQXZDLENBQWI7O0FBRUEsUUFBTSwwQkFFRixXQUFXLE1BQVgsQ0FBa0IsTUFBSSxFQUF0QixFQUEwQixNQUFJLEVBQTlCLEVBQWtDLE1BQUksS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBdEMsRUFBd0QsV0FBeEQsQ0FGRSxXQUFOO0FBSUEsV0FBTyxPQUFPLFVBQVAsRUFBbUIsRUFBbkIsRUFBdUIsRUFBdkIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsQ0FBUDtBQUNELEdBeEJrQjtBQTBCbkIsYUExQm1CLHVCQTBCUCxJQTFCTyxFQTBCRDtBQUNoQixRQUFNLEtBQUssS0FBSyxLQUFMLEVBQVg7QUFDQSxRQUFNLEtBQUssS0FBSyxNQUFMLEVBQVg7O0FBRUEsUUFBTSxVQUFVLEtBQUssQ0FBckI7QUFDQSxRQUFNLFVBQVUsS0FBSyxDQUFyQjtBQUNBLFFBQU0sU0FBUyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQXhDOztBQUVBLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLFNBSEksQ0FBakI7O0FBS0EsUUFBTSxPQUFPLFdBQVcsSUFBWCxDQUFnQixDQUFoQixFQUFtQixLQUFLLENBQXhCLEVBQTJCLEVBQTNCLEVBQStCLEtBQUssQ0FBcEMsRUFBdUMsUUFBdkMsQ0FBYjs7QUFFQSxRQUFNLDhCQUVGLFdBQVcsTUFBWCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxNQUFwQyxFQUE0QyxRQUE1QyxDQUZFLFdBQU47QUFJQSxXQUFPLE9BQU8sY0FBUCxFQUF1QixFQUF2QixFQUEyQixFQUEzQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxDQUFQO0FBQ0QsR0E5Q2tCO0FBZ0RuQixjQWhEbUIsd0JBZ0ROLElBaERNLEVBZ0RBO0FBQ2pCLFFBQU0sS0FBSyxLQUFLLEtBQUwsRUFBWDtBQUNBLFFBQU0sS0FBSyxLQUFLLE1BQUwsRUFBWDs7QUFFQSxRQUFNLFVBQVUsS0FBSyxLQUFMLEtBQWUsQ0FBL0I7QUFDQSxRQUFNLFVBQVUsS0FBSyxNQUFMLEtBQWdCLENBQWhDO0FBQ0EsUUFBTSxjQUFjLENBQUMsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsQ0FBcEIsSUFBeUIsQ0FBN0M7QUFDQSxRQUFNLGNBQWMsQ0FBQyxLQUFLLEdBQUwsQ0FBUyxFQUFULEVBQWEsRUFBYixJQUFtQixDQUFwQixJQUF5QixDQUE3Qzs7QUFFQSxRQUFNLFdBQVcsSUFBSSxHQUFKLEdBQ2hCLEdBRGdCLENBQ1osUUFEWSxFQUNGLFNBREUsRUFFaEIsR0FGZ0IsQ0FFWixjQUZZLEVBRUksR0FGSixFQUdoQixHQUhnQixDQUdaLE1BSFksRUFHSixNQUhJLENBQWpCOztBQUtBLFFBQU0sK0JBRUYsV0FBVyxNQUFYLENBQWtCLE9BQWxCLEVBQTJCLE9BQTNCLEVBQW9DLFdBQXBDLEVBQWlELFFBQWpELENBRkUsZ0JBR0YsV0FBVyxNQUFYLENBQWtCLE9BQWxCLEVBQTJCLE9BQTNCLEVBQW9DLFdBQXBDLEVBQWlELFFBQWpELENBSEUsV0FBTjtBQUtBLFdBQU8sT0FBTyxlQUFQLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLEVBQXRDLEVBQTBDLEVBQTFDLENBQVA7QUFDRCxHQXBFa0I7QUFzRW5CLFdBdEVtQixxQkFzRVQsSUF0RVMsRUFzRUg7QUFDZCxRQUFNLEtBQUssS0FBSyxLQUFMLEVBQVg7QUFDQSxRQUFNLEtBQUssS0FBSyxNQUFMLEVBQVg7O0FBRUEsUUFBTSxXQUFXLElBQUksR0FBSixHQUNoQixHQURnQixDQUNaLFFBRFksRUFDRixTQURFLEVBRWhCLEdBRmdCLENBRVosY0FGWSxFQUVJLEdBRkosRUFHaEIsR0FIZ0IsQ0FHWixNQUhZLEVBR0osTUFISSxDQUFqQjs7QUFLQSxRQUFJLDRCQUVBLFdBQVcsT0FBWCxDQUFtQixFQUFuQixFQUF1QixFQUF2QixFQUEyQixRQUEzQixDQUZBLFdBQUo7QUFJQSxXQUFPLE9BQU8sWUFBUCxFQUFxQixFQUFyQixFQUF5QixFQUF6QixFQUE2QixDQUE3QixFQUFnQyxDQUFoQyxFQUFtQyxFQUFuQyxFQUF1QyxFQUF2QyxDQUFQO0FBQ0Q7QUFwRmtCLENBQXJCOztBQXVGQSxJQUFNLGFBQWEsSUFBSSxHQUFKLEdBQ2xCLEdBRGtCLENBQ2QsU0FEYyxFQUNILGFBQWEsT0FEVixFQUVsQixHQUZrQixDQUVkLGlCQUZjLEVBRUssYUFBYSxPQUZsQixFQUdsQixHQUhrQixDQUdkLG1CQUhjLEVBR08sYUFBYSxPQUhwQixFQUlsQixHQUprQixDQUlkLGFBSmMsRUFJQyxhQUFhLFdBSmQsRUFLbEIsR0FMa0IsQ0FLZCxjQUxjLEVBS0UsYUFBYSxZQUxmLEVBTWxCLEdBTmtCLENBTWQsV0FOYyxFQU1ELGFBQWEsU0FOWixDQUFuQjs7QUFRQSxJQUFNLE9BQU8sU0FBUCxJQUFPLENBQUMsSUFBRCxFQUFVO0FBQ3JCLFNBQU8sV0FBVyxHQUFYLENBQWUsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFmLEVBQW1DLElBQW5DLEtBQTRDLEVBQW5EO0FBQ0QsQ0FGRDs7QUFJQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixRQUFNO0FBRFMsQ0FBakI7Ozs7O0FDdEdBLElBQUksWUFBWSxRQUFRLGdCQUFSLENBQWhCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsaUJBQVIsQ0FBakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU0sUUFBUSw0RUFBZDs7QUFFQSxJQUFNLFFBQVEsd0NBQWQ7O0FBRUEsSUFBTSxRQUFRLDZFQUFkOztBQUVBLElBQU0sUUFBUSxnREFBZDs7QUFFQSxJQUFNLFNBQVMsU0FBVCxNQUFTLEdBQU07QUFDbkIsU0FBVSxLQUFWLFVBQW9CLEtBQXBCLFVBQThCLEtBQTlCLFVBQXdDLEtBQXhDO0FBQ0QsQ0FGRDs7QUFJQSxJQUFNLFNBQVMsU0FBVCxNQUFTLENBQUMsSUFBRCxFQUFnRDtBQUFBLE1BQXpDLFdBQXlDLHVFQUEzQixNQUEyQjtBQUFBLE1BQWxCLFNBQWtCLHVFQUFOLENBQU07O0FBQzdELE1BQUksY0FBYyxFQUFsQjtBQUNBLE1BQUksV0FBVyxFQUFmOztBQUVBLE1BQUksY0FBYyxLQUFLLEtBQUwsS0FBZSxDQUFqQztBQUNBLE1BQUksY0FBYyxLQUFLLE1BQUwsS0FBZ0IsQ0FBbEM7QUFDQSxNQUFJLGVBQWUsQ0FBQyxLQUFLLEtBQUwsS0FBZSxDQUFoQixJQUFxQixDQUF4Qzs7QUFFQSxNQUFJLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBSixFQUE4QjtBQUM1QiwrRkFHcUIsSUFBSSxLQUFLLE1BQUwsRUFBSixHQUFvQixDQUh6QyxpQkFHc0QsS0FBSyxLQUFMLEVBSHRELGtCQUcrRSxLQUFLLEtBQUwsRUFIL0U7QUFPQSx5Q0FDYyxXQURkLGNBQ2tDLFdBRGxDLGFBQ3FELFlBRHJEO0FBR0Q7O0FBRUQsTUFBSSxRQUFRLElBQUksR0FBSixHQUNYLEdBRFcsQ0FDUCxNQURPLEVBQ0MsTUFERCxFQUVYLEdBRlcsQ0FFUCxRQUZPLEVBRUcsV0FGSCxFQUdYLEdBSFcsQ0FHUCxjQUhPLEVBR1MsU0FIVCxDQUFaOztBQUtBLE1BQU0sMkJBRUYsV0FBVyxNQUFYLENBQWtCLFdBQWxCLEVBQStCLFdBQS9CLEVBQTRDLFlBQTVDLEVBQTBELEtBQTFELENBRkUsY0FHRixRQUhFLGNBSUYsV0FKRSxjQUtGLFdBQVcsSUFBWCxDQUFnQixDQUFoQixFQUFtQixLQUFLLE1BQUwsRUFBbkIsRUFBa0MsS0FBSyxLQUFMLEVBQWxDLEVBQWdELENBQWhELEVBQW1ELEtBQW5ELENBTEUsU0FBTjs7QUFRQSxTQUFPLFVBQVUsYUFBVixFQUF5QixLQUFLLEtBQUwsRUFBekIsRUFBdUMsS0FBSyxNQUFMLEVBQXZDLEVBQXNELENBQXRELEVBQXlELENBQXpELEVBQTRELEtBQUssS0FBTCxFQUE1RCxFQUEwRSxLQUFLLE1BQUwsRUFBMUUsQ0FBUDtBQUNELENBbkNEOztBQXFDQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixVQUFRLE1BRE87QUFFZixVQUFRO0FBRk8sQ0FBakI7Ozs7O0FDekRBLElBQU0sdUJBQXVCLFNBQXZCLG9CQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sSUFBUCxFQUFnQjtBQUMzQyxTQUFTLENBQUUsTUFBTSxDQUFOLElBQVcsTUFBTSxLQUFLLEtBQUwsRUFBbkIsS0FBdUMsS0FBSyxDQUFMLElBQVUsS0FBSyxNQUFMLEVBQW5ELElBQ0QsQ0FBRSxNQUFNLENBQU4sSUFBVyxNQUFNLEtBQUssTUFBTCxFQUFuQixLQUF3QyxLQUFLLENBQUwsSUFBVSxLQUFLLEtBQUwsRUFEeEQ7QUFFRCxDQUhEOztBQUtBLElBQU0sUUFBUSxTQUFSLEtBQVEsQ0FBQyxLQUFELEVBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxLQUFkLEVBQXFCLE1BQXJCLEVBQTZCLE9BQTdCLEVBQXNDLFFBQXRDLEVBQW1EO0FBQy9ELGlFQUNpRCxPQURqRCxrQkFDcUUsUUFEckUsdUJBQytGLE9BRC9GLFNBQzBHLFFBRDFHLHFEQUV5QyxDQUZ6QyxhQUVrRCxDQUZsRCxpQkFFK0QsS0FGL0Qsa0JBRWlGLE1BRmpGLGlEQUdrQyxJQUFLLFFBQU0sQ0FIN0MsZUFHdUQsSUFBSyxTQUFPLENBSG5FLFdBRzBFLEtBSDFFO0FBTUQsQ0FQRDs7QUFTQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixTQUFPO0FBRFEsQ0FBakI7Ozs7O0FDZEEsSUFBTSxlQUFlLFFBQVEsY0FBUixDQUFyQjs7QUFFQSxJQUFNLGdCQUFnQixRQUFRLDBCQUFSLENBQXRCO0FBQ0EsSUFBTSxjQUFjLFFBQVEsd0JBQVIsQ0FBcEI7O0FBRUEsSUFBTSxtQkFBbUIsUUFBUSxpQ0FBUixDQUF6QjtBQUNBLElBQU0sb0JBQW9CLFFBQVEsOEJBQVIsQ0FBMUI7O0FBRUE7QUFDQTtBQUNBLElBQUksaUJBQWlCLFNBQWpCLGNBQWlCLENBQVUsU0FBVixFQUFxQjs7QUFFeEMsU0FBTyxVQUFVLFVBQVYsR0FDQSxRQURBLENBQ1MsTUFEVCxFQUVBLEdBRkEsQ0FFSTtBQUNILGVBQVcsaUJBQUMsSUFBRCxFQUFVO0FBQ25CLGFBQU8sYUFBYSxXQUFiLENBQXlCLElBQXpCLENBQVA7QUFDRCxLQUhFO0FBSUgsaUJBQWEsa0JBQUMsSUFBRCxFQUFVO0FBQ3JCLGFBQU8sYUFBYSxhQUFiLENBQTJCLElBQTNCLENBQVA7QUFDRCxLQU5FO0FBT0gsbUJBQWUsUUFQWjtBQVFILG1CQUFlLFFBUlo7QUFTSCxvQkFBZ0IsR0FUYjtBQVVILG9CQUFnQixNQVZiO0FBV0gsd0JBQW9CLFNBWGpCO0FBWUgsMEJBQXNCLEdBWm5CO0FBYUgsb0JBQWdCLENBYmI7QUFjSCxlQUFXLENBZFI7QUFlSCxpQkFBYSxNQWZWO0FBZ0JILHNCQUFrQjtBQWhCZixHQUZKLEVBb0JBLFFBcEJBLENBb0JTLGFBcEJULEVBcUJBLEdBckJBLENBcUJJO0FBQ0gsYUFBUyxlQUFVLElBQVYsRUFBZ0I7QUFDdkIsYUFBTyxhQUFhLFNBQWIsQ0FBdUIsSUFBdkIsQ0FBUDtBQUNEO0FBSEUsR0FyQkosRUEwQkEsUUExQkEsQ0EwQlMsdUJBMUJULEVBMkJBLEdBM0JBLENBMkJJO0FBQ0gsYUFBUyxRQUROO0FBRUgsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLGtCQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFWO0FBQUEsS0FGakI7QUFHSCxzQkFBa0IsTUFIZjtBQUlILHdCQUFvQixNQUpqQjtBQUtILHlCQUFxQixNQUxsQjtBQU1ILGVBQVcsaUJBQUMsSUFBRDtBQUFBLGFBQVUsS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLEVBQVQsRUFBdUIsS0FBSyxNQUFMLEVBQXZCLElBQXdDLEdBQWxEO0FBQUEsS0FOUjtBQU9ILHVCQUFtQixNQVBoQjtBQVFILHlCQUFxQixXQVJsQjtBQVNILG9CQUFnQjtBQVRiLEdBM0JKLEVBc0NBLFFBdENBLENBc0NTLDJCQXRDVCxFQXVDQSxHQXZDQSxDQXVDSTtBQUNILGFBQVMsU0FETjtBQUVILHdCQUFvQix5QkFBQyxJQUFEO0FBQUEsYUFBVSxrQkFBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBVjtBQUFBLEtBRmpCO0FBR0gsc0JBQWtCLE1BSGY7QUFJSCx3QkFBb0IsTUFKakI7QUFLSCx5QkFBcUIsTUFMbEI7QUFNSCx1QkFBbUIsTUFOaEI7QUFPSCx5QkFBcUIsV0FQbEI7QUFRSCxvQkFBZ0I7QUFSYixHQXZDSixFQWlEQSxRQWpEQSxDQWlEUyw0QkFqRFQsRUFrREEsR0FsREEsQ0FrREk7QUFDSCxhQUFTLFNBRE47QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsa0JBQWtCLElBQWxCLENBQXVCLElBQXZCLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0FsREosRUE0REEsUUE1REEsQ0E0RFMseUJBNURULEVBNkRBLEdBN0RBLENBNkRJO0FBQ0gsYUFBUyxTQUROO0FBRUgsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLGtCQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFWO0FBQUEsS0FGakI7QUFHSCxzQkFBa0IsTUFIZjtBQUlILHdCQUFvQixNQUpqQjtBQUtILHlCQUFxQixNQUxsQjtBQU1ILHVCQUFtQixNQU5oQjtBQU9ILHlCQUFxQixXQVBsQjtBQVFILG9CQUFnQjtBQVJiLEdBN0RKLEVBdUVBLFFBdkVBLENBdUVTLCtCQXZFVCxFQXdFQSxHQXhFQSxDQXdFSTtBQUNILDRCQUF3QixjQUFjLE1BQWQsRUFEckI7QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsaUJBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0F4RUosRUFrRkEsUUFsRkEsQ0FrRlMsb0NBbEZULEVBbUZBLEdBbkZBLENBbUZJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLGlCQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFWO0FBQUEsS0FEakI7QUFFSCxzQkFBa0IsTUFGZjtBQUdILHdCQUFvQixNQUhqQjtBQUlILHlCQUFxQixNQUpsQjtBQUtILHVCQUFtQixNQUxoQjtBQU1ILHlCQUFxQixXQU5sQjtBQU9ILG9CQUFnQjtBQVBiLEdBbkZKLEVBNEZBLFFBNUZBLENBNEZTLGdDQTVGVCxFQTZGQSxHQTdGQSxDQTZGSTtBQUNILDRCQUF3QixvREFEckI7QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsaUJBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0E3RkosRUF1R0EsUUF2R0EsQ0F1R1MsdUJBdkdULEVBd0dBLEdBeEdBLENBd0dJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLGlCQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFWO0FBQUEsS0FEakI7QUFFSCxlQUFXLGlCQUFDLElBQUQ7QUFBQSxhQUFVLEtBQUssR0FBTCxDQUFTLEtBQUssTUFBTCxFQUFULEVBQXdCLEtBQUssS0FBTCxFQUF4QixJQUF3QyxJQUFsRDtBQUFBLEtBRlI7QUFHSCwwQkFBc0IsQ0FIbkI7QUFJSCxzQkFBa0IsTUFKZjtBQUtILHdCQUFvQixNQUxqQjtBQU1ILHlCQUFxQixNQU5sQjtBQU9ILHVCQUFtQixNQVBoQjtBQVFILHlCQUFxQixXQVJsQjtBQVNILG9CQUFnQixDQVRiO0FBVUgsbUJBQWUsUUFWWjtBQVdILG1CQUFlLFFBWFo7QUFZSCxrQkFBYyxtQkFBQyxJQUFEO0FBQUEsYUFBVSxLQUFLLEtBQUwsS0FBZSxHQUF6QjtBQUFBLEtBWlg7QUFhSCwyQkFBdUIsS0FicEI7QUFjSCw4QkFBMEI7QUFkdkIsR0F4R0osRUF3SEEsUUF4SEEsQ0F3SFMsNkJBeEhULEVBeUhBLEdBekhBLENBeUhJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLGlCQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFWO0FBQUEsS0FEakI7QUFFSCxzQkFBa0IsTUFGZjtBQUdILHdCQUFvQixNQUhqQjtBQUlILHlCQUFxQixNQUpsQjtBQUtILHVCQUFtQixNQUxoQjtBQU1ILHlCQUFxQixXQU5sQjtBQU9ILG9CQUFnQjtBQVBiLEdBekhKLEVBa0lBLFFBbElBLENBa0lTLCtCQWxJVCxFQW1JQSxHQW5JQSxDQW1JSTtBQUNILGFBQVMsU0FETjtBQUVILHdCQUFvQix5QkFBQyxJQUFEO0FBQUEsYUFBVSxpQkFBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBVjtBQUFBLEtBRmpCO0FBR0gsc0JBQWtCLE1BSGY7QUFJSCx3QkFBb0IsTUFKakI7QUFLSCx5QkFBcUIsTUFMbEI7QUFNSCx1QkFBbUIsTUFOaEI7QUFPSCx5QkFBcUIsV0FQbEI7QUFRSCxvQkFBZ0I7QUFSYixHQW5JSixFQTZJQSxRQTdJQSxDQTZJUyxrQ0E3SVQsRUE4SUEsR0E5SUEsQ0E4SUk7QUFDSCxhQUFTLFNBRE47QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsaUJBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0E5SUosRUF3SkEsUUF4SkEsQ0F3SlMsMkJBeEpULEVBeUpBLEdBekpBLENBeUpJO0FBQ0gsNEJBQXdCLFlBQVksTUFBWixFQURyQjtBQUVILHdCQUFvQix5QkFBQyxJQUFELEVBQVU7QUFDNUIsYUFBTyxZQUFZLE1BQVosQ0FBbUIsSUFBbkIsRUFBeUIsQ0FBekIsQ0FBUDtBQUNELEtBSkU7QUFLSCxzQkFBa0IsTUFMZjtBQU1ILHdCQUFvQixNQU5qQjtBQU9ILHlCQUFxQixNQVBsQjtBQVFILGVBQVcsaUJBQUMsSUFBRDtBQUFBLGFBQVUsS0FBSyxHQUFMLENBQVMsS0FBSyxNQUFMLEVBQVQsRUFBd0IsS0FBSyxLQUFMLEVBQXhCLElBQXdDLEVBQWxEO0FBQUEsS0FSUjtBQVNILHVCQUFtQixNQVRoQjtBQVVILHlCQUFxQixXQVZsQjtBQVdILG9CQUFnQixDQVhiO0FBWUgsb0JBQWdCLE9BWmI7QUFhSCwwQkFBc0IsQ0FibkI7QUFjSCxtQkFBZSxRQWRaO0FBZUgsbUJBQWUsUUFmWjtBQWdCSCxrQkFBYyxHQWhCWDtBQWlCSCwyQkFBdUIsS0FqQnBCO0FBa0JILDhCQUEwQixLQWxCdkI7QUFtQkgsaUJBQWEsR0FuQlY7QUFvQkgsNEJBQXdCLEtBcEJyQjtBQXFCSCwyQkFBdUI7QUFyQnBCLEdBekpKLEVBZ0xBLFFBaExBLENBZ0xTLG1CQWhMVCxFQWlMQSxHQWpMQSxDQWlMSTtBQUNILDRCQUF3QjtBQURyQixHQWpMSixFQW9MQSxRQXBMQSxDQW9MUywyQkFwTFQsRUFxTEEsR0FyTEEsQ0FxTEk7QUFDSCx3QkFBb0I7QUFEakIsR0FyTEosRUF3TEEsUUF4TEEsQ0F3TFMsNEVBeExULEVBeUxBLEdBekxBLENBeUxJO0FBQ0gsYUFBUyxjQUROO0FBRUgsY0FBVTtBQUZQLEdBekxKLEVBNkxBLFFBN0xBLENBNkxTLGVBN0xULEVBOExBLEdBOUxBLENBOExJO0FBQ0gsd0JBQW9CLFNBRGpCO0FBRUgsMEJBQXNCLE1BRm5CO0FBR0gsMEJBQXNCO0FBSG5CLEdBOUxKLEVBbU1BLFFBbk1BLENBbU1TLGFBbk1ULEVBb01BLEdBcE1BLENBb01JO0FBQ0gsMEJBQXNCLEdBRG5CLEVBQ3dCLGlCQUFpQixTQUR6QztBQUVILHVCQUFtQjtBQUZoQixHQXBNSixFQXdNQSxRQXhNQSxDQXdNUyxNQXhNVCxFQXlNQSxHQXpNQSxDQXlNSTtBQUNILG1CQUFlLFFBRFo7QUFFSCxrQkFBYyxNQUZYO0FBR0gseUJBQXFCLFFBSGxCO0FBSUgseUJBQXFCLFFBSmxCO0FBS0gsYUFBUyxHQUxOO0FBTUgsMEJBQXNCLE1BTm5CO0FBT0gsMEJBQXNCLE1BUG5CO0FBUUgseUJBQXFCLHlCQUFDLElBQUQsRUFBVTtBQUM3QixVQUFJLEtBQUssUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGVBQU8sU0FBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLEdBQUwsQ0FBUyxZQUFULENBQVA7QUFDRCxLQWJFO0FBY0gsYUFBUyxlQUFDLElBQUQsRUFBVTtBQUNqQixVQUFJLEtBQUssUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGVBQU8sU0FBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLEdBQUwsQ0FBUyxZQUFULENBQVA7QUFDRDtBQW5CRSxHQXpNSixFQThOQSxRQTlOQSxDQThOUyxlQTlOVCxFQStOQSxHQS9OQSxDQStOSTtBQUNILGtCQUFjLFNBRFg7QUFFSCwwQkFBc0IsU0FGbkI7QUFHSCwwQkFBc0I7QUFIbkIsR0EvTkosRUFvT0EsUUFwT0EsQ0FvT1MsYUFwT1QsRUFxT0EsR0FyT0EsQ0FxT0k7QUFDSCwwQkFBc0IsR0FEbkIsRUFDd0IsaUJBQWlCLFNBRHpDO0FBRUgsdUJBQW1CO0FBRmhCLEdBck9KLEVBeU9BLFFBek9BLENBeU9TLHVCQXpPVCxFQTBPQSxHQTFPQSxDQTBPSTtBQUNILHFCQUFpQixZQURkO0FBRUgsNkJBQXlCLFdBRnRCO0FBR0gsMkJBQXVCLEdBSHBCO0FBSUgseUJBQXFCLEdBSmxCO0FBS0gsNkJBQXlCLE9BTHRCO0FBTUgsK0JBQTJCO0FBTnhCLEdBMU9KLEVBa1BBLFFBbFBBLENBa1BTLDRDQWxQVCxFQW1QQSxHQW5QQSxDQW1QSTtBQUNILG9CQUFnQixxQkFBQyxJQUFELEVBQVU7QUFDeEIsYUFBTyxLQUFLLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBWjtBQUNELEtBSEU7QUFJSCw0QkFBd0IsS0FKckI7QUFLSCwwQkFBc0IsMEJBQUMsSUFBRCxFQUFVO0FBQzlCLGFBQU8sYUFBYSxtQkFBYixDQUFpQyxJQUFqQyxDQUFQO0FBQ0Q7QUFQRSxHQW5QSixFQTRQQSxRQTVQQSxDQTRQUywyQ0E1UFQsRUE2UEEsR0E3UEEsQ0E2UEk7QUFDSCxvQkFBZ0IscUJBQUMsSUFBRCxFQUFVO0FBQ3hCLGFBQU8sS0FBSyxLQUFLLElBQUwsQ0FBVSxhQUFWLENBQVo7QUFDRCxLQUhFO0FBSUgsNEJBQXdCLEtBSnJCO0FBS0gsMEJBQXNCLDBCQUFDLElBQUQsRUFBVTtBQUM5QixhQUFPLGFBQWEsc0JBQWIsQ0FBb0MsSUFBcEMsQ0FBUDtBQUNEO0FBUEUsR0E3UEosRUFzUUEsUUF0UUEsQ0FzUVMsYUF0UVQsRUF1UUEsR0F2UUEsQ0F1UUk7QUFDSCwwQkFBc0IsMEJBQUMsSUFBRCxFQUFVO0FBQzlCLGFBQU8sYUFBYSxjQUFiLENBQTRCLElBQTVCLENBQVA7QUFDRCxLQUhFO0FBSUgsMEJBQXNCO0FBSm5CLEdBdlFKLEVBNlFBLFFBN1FBLENBNlFTLDBCQTdRVCxFQThRQSxHQTlRQSxDQThRSTtBQUNILHlCQUFxQjtBQURsQixHQTlRSixFQWlSQSxRQWpSQSxDQWlSUywwQkFqUlQsRUFrUkEsR0FsUkEsQ0FrUkk7QUFDSCx5QkFBcUI7QUFEbEIsR0FsUkosRUFxUkEsUUFyUkEsQ0FxUlMsTUFyUlQsRUFzUkEsR0F0UkEsQ0FzUkk7QUFDSCwyQkFBdUIsU0FEcEI7QUFFSCw2QkFBeUIsS0FGdEIsRUFFNkIsOEJBQThCO0FBRjNELEdBdFJKLENBQVA7QUEwUkQsQ0E1UkQ7O0FBOFJBLE9BQU8sT0FBUCxHQUFpQixjQUFqQjs7Ozs7QUN4U0EsSUFBTSxTQUFTLElBQUksU0FBSixFQUFmOztBQUdBLElBQU0sTUFBTSxTQUFOLEdBQU0sQ0FBQyxNQUFELEVBQXdGO0FBQUEsTUFBL0UsS0FBK0UsdUVBQXZFLEdBQXVFO0FBQUEsTUFBbEUsTUFBa0UsdUVBQXpELEdBQXlEO0FBQUEsTUFBcEQsR0FBb0QsdUVBQTlDLENBQThDO0FBQUEsTUFBM0MsR0FBMkMsdUVBQXJDLENBQXFDO0FBQUEsTUFBbEMsT0FBa0MsdUVBQXhCLEdBQXdCO0FBQUEsTUFBbkIsUUFBbUIsdUVBQVIsR0FBUTs7QUFDbEcsTUFBSSx1RkFFNkQsS0FGN0Qsb0JBRStFLE1BRi9FLHFCQUVtRyxHQUZuRyxTQUUwRyxHQUYxRyxTQUVpSCxPQUZqSCxTQUU0SCxRQUY1SCxpQkFHQSxNQUhBLHFCQUFKO0FBTUEsU0FBTyxPQUFPLGVBQVAsQ0FBdUIsT0FBdkIsRUFBZ0MsVUFBaEMsRUFBNEMsZUFBbkQ7QUFDRCxDQVJEOztBQVVBLElBQU0sWUFBWSxTQUFaLFNBQVksQ0FBQyxPQUFELEVBQVUsYUFBVixFQUF5QixjQUF6QixFQUF5QyxRQUF6QyxFQUFtRCxRQUFuRCxFQUE2RCxZQUE3RCxFQUEyRSxhQUEzRSxFQUE2RjtBQUM3RyxNQUFJLFFBQVEsSUFBSSxPQUFKLEVBQWEsYUFBYixFQUE0QixjQUE1QixFQUE0QyxRQUE1QyxFQUFzRCxRQUF0RCxFQUFnRSxZQUFoRSxFQUE4RSxhQUE5RSxDQUFaO0FBQ0EsTUFBSSx5Q0FBdUMsS0FBSyxNQUFNLFNBQVgsQ0FBM0M7O0FBRUEsU0FBTyxPQUFQO0FBQ0QsQ0FMRDs7QUFPQSxPQUFPLE9BQVAsR0FBaUIsU0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogZ2xvYmFsICQgKi9cblxuaW1wb3J0IFNCR05SZW5kZXJlciBmcm9tICcuLi9zcmMvaW5kZXgnO1xuXG52YXIgY29udmVydFNiZ25tbCA9IHJlcXVpcmUoJ3NiZ25tbC10by1jeXRvc2NhcGUnKTtcbnZhciBzYXZlQXMgPSByZXF1aXJlKCdmaWxlLXNhdmVyJykuc2F2ZUFzO1xuXG52YXIgZGVmYXVsdERhdGEgPSByZXF1aXJlKCcuL3Rlc3QtZGF0YScpO1xuXG52YXIgbG9hZEZpbGVUZXh0ID0gZnVuY3Rpb24gKGFic0ZpbGVQYXRoKSB7XG4gIHZhciB4aHR0cDtcbiAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgIHhodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgeGh0dHAgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgfVxuICB4aHR0cC5vcGVuKCdHRVQnLCBhYnNGaWxlUGF0aCwgZmFsc2UpO1xuICB4aHR0cC5zZW5kKCk7XG4gIHJldHVybiB4aHR0cC5yZXNwb25zZVRleHQ7XG59O1xuXG52YXIgcmVhZEZpbGUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGZpbGUpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGdyYXBoID0gY29udmVydFNiZ25tbChlLnRhcmdldC5yZXN1bHQpO1xuICAgIHJlbmRlckdyYXBoKHJlbmRlcmVyLCBncmFwaCk7XG5cbiAgfTtcblxuICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbn07XG5cbnZhciByZW5kZXJHcmFwaCA9IGZ1bmN0aW9uIChjeSwgY3lHcmFwaCkge1xuICBjeS5zdGFydEJhdGNoKCk7XG4gIGN5LnJlbW92ZSgnKicpO1xuICBjeS5hZGQoY3lHcmFwaCk7XG5cbiAgdmFyIG5vZGVQb3NpdGlvbnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjeUdyYXBoLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHhQb3MgPSBjeUdyYXBoLm5vZGVzW2ldLmRhdGEuYmJveC54O1xuICAgIHZhciB5UG9zID0gY3lHcmFwaC5ub2Rlc1tpXS5kYXRhLmJib3gueTtcbiAgICBub2RlUG9zaXRpb25zW2N5R3JhcGgubm9kZXNbaV0uZGF0YS5pZF0gPSB7J3gnOiB4UG9zLCAneSc6IHlQb3N9O1xuICB9XG5cbiAgY3kubGF5b3V0KHtcbiAgICBuYW1lOiAncHJlc2V0JyxcbiAgICBwb3NpdGlvbnM6IG5vZGVQb3NpdGlvbnMsXG4gICAgZml0OiB0cnVlLFxuICAgIHBhZGRpbmc6IDUwXG4gIH0pO1xuXG4gIGN5LmVuZEJhdGNoKCk7XG4gIGN5LnN0eWxlKCkudXBkYXRlKCk7XG59O1xuXG52YXIgYjY0dG9CbG9iID0gZnVuY3Rpb24gKGI2NERhdGEsIGNvbnRlbnRUeXBlLCBzbGljZVNpemUpIHtcbiAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCAnJztcbiAgc2xpY2VTaXplID0gc2xpY2VTaXplIHx8IDUxMjtcblxuICB2YXIgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGI2NERhdGEpO1xuICB2YXIgYnl0ZUFycmF5cyA9IFtdO1xuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IHNsaWNlU2l6ZSkge1xuICAgIHZhciBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2xpY2VTaXplKTtcblxuICAgIHZhciBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuXG4gICAgYnl0ZUFycmF5cy5wdXNoKGJ5dGVBcnJheSk7XG4gIH1cblxuICB2YXIgYmxvYiA9IG5ldyBCbG9iKGJ5dGVBcnJheXMsIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuICByZXR1cm4gYmxvYjtcbn07XG5cbnZhciBzYXZlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBmaWxlbmFtZSkge1xuICB2YXIgZ3JhcGhGaWxlU3RyaW5nID0gcmVuZGVyZXIucG5nKHtzY2FsZTogMywgZnVsbDogdHJ1ZX0pO1xuXG4gIHZhciBiNjREYXRhID0gZ3JhcGhGaWxlU3RyaW5nLnN1YnN0cihncmFwaEZpbGVTdHJpbmcuaW5kZXhPZignLCcpICsgMSk7XG4gIHNhdmVBcyhiNjR0b0Jsb2IoYjY0RGF0YSwgJ2ltYWdlL3BuZycpLCBmaWxlbmFtZSk7XG59O1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGNvbnRhaW5lciA9ICQoJyNzYmduLW5ldHdvcmstY29udGFpbmVyJyk7XG5cbiAgdmFyIHJlbmRlcmVyID0gbmV3IFNCR05SZW5kZXJlcih7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfSk7XG5cbiAgd2luZG93LnIgPSB3aW5kb3cuY3kgPSByZW5kZXJlcjtcbiAgcmVuZGVyR3JhcGgocmVuZGVyZXIsIGRlZmF1bHREYXRhKTtcblxuICAkKCcjZ3JhcGgtbG9hZCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAkKCcjZ3JhcGgtaW5wdXQnKS50cmlnZ2VyKCdjbGljaycpO1xuICB9KTtcblxuICAkKCcjZ3JhcGgtaW5wdXQnKS5jaGFuZ2UoZnVuY3Rpb24gKCkge1xuICAgIGlmICgkKHRoaXMpLnZhbCgpICE9ICcnKSB7XG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbMF07XG5cbiAgICAgIHJlYWRGaWxlKHJlbmRlcmVyLCBmaWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gICQoJyNncmFwaC1zYXZlJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgIHNhdmUocmVuZGVyZXIsICdncmFwaCcpO1xuICB9KTtcblxuICAkKCcuc2FtcGxlLWZpbGUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGVUZXh0ID0gbG9hZEZpbGVUZXh0KCdzYW1wbGVzLycgKyAkKHRoaXMpWzBdLmlubmVyVGV4dCArICcueG1sJyk7XG4gICAgdmFyIGdyYXBoSnNvbiA9IGNvbnZlcnRTYmdubWwoZmlsZVRleHQpO1xuICAgIHJlbmRlckdyYXBoKHJlbmRlcmVyLCBncmFwaEpzb24pO1xuICB9KTtcblxufSk7XG4iLCJ2YXIgbWFwa0Nhc2NhZGVEYXRhID0ge1xuXCJub2Rlc1wiOiBbXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoNFwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogMzE4LjE1ODkxNjU4ODUwNjcsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDE2Mi41OTg5ODY3OTk3MzMzMixcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFUUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDVcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDM2OC43MTUwNjk4MDMyNzY1LFxuICAgICAgICAgICAgICAgIFwieVwiOiAzNTMuMzQyNTMxMTMzMjE0NyxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFEUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDdcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDQyMy40NjAxMjQ3MDg2OTIxLFxuICAgICAgICAgICAgICAgIFwieVwiOiAxMDMuNjgxNDQ2OTk3MzcwNTksXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBVFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGg2XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA1MTQuODI4NjU2NDgwNDE2MixcbiAgICAgICAgICAgICAgICBcInlcIjogNDAuMTYxNjk3MTg2NDY3NTYsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBRFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxMFwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNTg4Ljc3NTY5MzI3MzAzNyxcbiAgICAgICAgICAgICAgICBcInlcIjogNDEwLjUzMTgwODc5MDYxNDQsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBVFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGg5XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA0OTcuNjg1OTQyODAzNzIzNyxcbiAgICAgICAgICAgICAgICBcInlcIjogMzUyLjIyNDE2NDYxMzc2OTIsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBRFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA0NjcuMTgzMDIyMTMyMDkyNDUsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDI0MC4yODczMDY0ODczOTAzLFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJSQUZcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMmFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjbGF6elwiOiBcInN0YXRlIHZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyNS4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxOFwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogOTQ0LjA0MDk0OTE3NjM2MSxcbiAgICAgICAgICAgICAgICBcInlcIjogMjg0LjA2NTc0NDY4Njg0MDYsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBRFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxNlwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNjg5LjEzMTQ1ODUzMDM3NjcsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDQ4Mi40NDQ2NzEwMDU4NDc0NSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFEUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE1XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA4ODIuODQ0MzMyNjI5NDU0NixcbiAgICAgICAgICAgICAgICBcInlcIjogNDgyLjUyNDYyNjgxMjgwNDMsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiNjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJzaW1wbGUgY2hlbWljYWxcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJBVFBcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjbG9uZW1hcmtlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxN1wiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNzU5Ljk4MTA0MDg5MDIxMjksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDIyMC41ODU0MDQ0MTAxNDU3NyxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFUUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDEyXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA3MjIuNTI0MDA4ODc2MjcyMSxcbiAgICAgICAgICAgICAgICBcInlcIjogMzUyLjc3MDA2OTM2NTQ3OCxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiTUVLXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDEyYVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiMlBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIzMi4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxOVwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogODg3LjAzMTI5NTU5Mjk2OTksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDE4OC4wMTEwNDMyMDg5OTkyNCxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiRVJLXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE5YVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiMlBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IC0yNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjMyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIyLjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDIwXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA5NzEuMDU2NzE3NjUwNzE5MSxcbiAgICAgICAgICAgICAgICBcInlcIjogODQuNjY4NTI3MjczOTcxOSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJ0YWdcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJFUktcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiAyMTMuNTUwNTYxMzI3MDY4NjQsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDIzNi4xODkzMzIxMzMwNjYwNSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiUkFTXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDFhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJhY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCI1MC4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyNi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgwXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA2MC4xMzQzODk1MTIyODg2MzUsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDIwMC4wMjU4NzIyNDU0MTYwNSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJ0YWdcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJSQVNcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyNFwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNjA3LjU1ODQ4NjI5NTM3ODgsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDIxNi4zNjQ2NjQ4OTE4NDcxNixcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiTUVLXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDI0YVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiUFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogLTI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjUuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoXCI6IFwiMjIuMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTFcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDU5Mi42MTg1MjMwNjU2NjUyLFxuICAgICAgICAgICAgICAgIFwieVwiOiAzMTMuNDUwMjA4NTIyNTkyOSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiMjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2Nlc3NcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyNVwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogMjQ3LjQ0MzE5NjUzMTkyMzYsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDMzOC4yOTU2NTIzNjU1ODQ4MyxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiUkFGXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDI1YVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjAuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoXCI6IFwiMjIuMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoM1wiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogMzM3Ljc3OTE4MDI1MTEyOTMzLFxuICAgICAgICAgICAgICAgIFwieVwiOiAyNTkuMTM0NTQ1MzI4NDY5MjQsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9jZXNzXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjNcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDYzMS4zNjY1ODEwNzk2MjQ3LFxuICAgICAgICAgICAgICAgIFwieVwiOiA5My42MTQ0NTc1MDMwNTMzNixcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiTUVLXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDIzYVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiAtMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA1MTYuOTI1MjMxNTg0MjI4MixcbiAgICAgICAgICAgICAgICBcInlcIjogMTQyLjAxMjkwODQwNDI5NjEzLFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjIwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCIyMC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvY2Vzc1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDIyXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA3ODYuMTYwMjc2ODU3MzU3MyxcbiAgICAgICAgICAgICAgICBcInlcIjogNTU3LjQ1MzQ5MDQzMjg5OTEsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMTAwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwibWFjcm9tb2xlY3VsZVwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkVSS1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyMmFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjbGF6elwiOiBcInN0YXRlIHZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RhdGVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogLTI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjAuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoXCI6IFwiMjIuMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDg0NC40MzAwMjg4OTM5MDk2LFxuICAgICAgICAgICAgICAgIFwieVwiOiAyODQuODcxNjU4MjM3NTAzNTQsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9jZXNzXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDc4My43NDAyMDQ2ODA4NDQzLFxuICAgICAgICAgICAgICAgIFwieVwiOiA0NTMuMTUwMTUwNTUwMTU5MSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiMjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2Nlc3NcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyMVwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogODcyLjE1MTczMzQxNjI1MzEsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDM3OC41NjgwOTcyNzMyMDM5LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJFUktcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjFhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJQXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiAtMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyNS4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfVxuXSxcblwiZWRnZXNcIjogW1xuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMlwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDJcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDRcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDRcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoM1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoNVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2F0YWx5c2lzXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoM1wiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDNcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDdcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDdcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoOFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoNlwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDZcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDEwXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTFcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTBcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTFcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxMlwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxMlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDlcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTFcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoOVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjYXRhbHlzaXNcIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDJcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgyXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDExXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNhdGFseXNpc1wiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMlwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMlwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGg4XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDEzXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTlcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTlcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxOFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxOFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDE2XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDE0XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDE2XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNvbnN1bXB0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxNVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDE0XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDE1XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDE0XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNvbnN1bXB0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxN1wiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDEzXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDE3XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDEzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNhdGFseXNpc1wiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTJcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxMlwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxM1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjYXRhbHlzaXNcIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDEyXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTJcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTRcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiZXF1aXZhbGVuY2UgYXJjXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxOVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDIwXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDE5XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDIwXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImVxdWl2YWxlbmNlIGFyY1wiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDBcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMVwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgwXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgyNFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDI0XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNvbnN1bXB0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgyNFwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDExXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDI0XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDExXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNvbnN1bXB0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgyNVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMjVcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoM1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMjNcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGg4XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDIzXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDhcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDIyXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMjJcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTRcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDIxXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMjFcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTNcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgyMVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgyMVwiXG4gICAgICAgIH1cbiAgICB9XG5dXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcGtDYXNjYWRlRGF0YTtcbiIsIiIsIlxuLyohXG5cbkN5dG9zY2FwZS5qcyB7e1ZFUlNJT059fSAoTUlUIGxpY2Vuc2VkKVxuXG5Db3B5cmlnaHQgKGMpIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG50aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbnRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbnVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG5vZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbnNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCAnLi9wcm9taXNlJyApO1xuXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24oIHRhcmdldCwgb3B0cywgb3B0czIgKXtcbiAgaWYoICEodGhpcyBpbnN0YW5jZW9mIEFuaW1hdGlvbikgKXtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvbiggdGFyZ2V0LCBvcHRzLCBvcHRzMiApO1xuICB9XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHV0aWwuZXh0ZW5kKCB7XG4gICAgZHVyYXRpb246IDEwMDBcbiAgfSwgb3B0cywgb3B0czIgKTtcblxuICBfcC50YXJnZXQgPSB0YXJnZXQ7XG4gIF9wLnN0eWxlID0gX3Auc3R5bGUgfHwgX3AuY3NzO1xuICBfcC5zdGFydGVkID0gZmFsc2U7XG4gIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgX3AuaG9va2VkID0gZmFsc2U7XG4gIF9wLmFwcGx5aW5nID0gZmFsc2U7XG4gIF9wLnByb2dyZXNzID0gMDtcbiAgX3AuY29tcGxldGVzID0gW107XG4gIF9wLmZyYW1lcyA9IFtdO1xuXG4gIGlmKCBfcC5jb21wbGV0ZSAmJiBpcy5mbiggX3AuY29tcGxldGUgKSApe1xuICAgIF9wLmNvbXBsZXRlcy5wdXNoKCBfcC5jb21wbGV0ZSApO1xuICB9XG5cbiAgLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcbn07XG5cbnZhciBhbmlmbiA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cbnV0aWwuZXh0ZW5kKCBhbmlmbiwge1xuXG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gJ2FuaW1hdGlvbic7IH0sXG5cbiAgaG9vazogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoICFfcC5ob29rZWQgKXtcbiAgICAgIC8vIGFkZCB0byB0YXJnZXQncyBhbmltYXRpb24gcXVldWVcbiAgICAgIHZhciBxO1xuICAgICAgdmFyIHRBbmkgPSBfcC50YXJnZXQuX3ByaXZhdGUuYW5pbWF0aW9uO1xuICAgICAgaWYoIF9wLnF1ZXVlICl7XG4gICAgICAgIHEgPSB0QW5pLnF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IHRBbmkuY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHEucHVzaCggdGhpcyApO1xuXG4gICAgICAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcbiAgICAgIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBfcC50YXJnZXQgKSApe1xuICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woIF9wLnRhcmdldCApO1xuICAgICAgfVxuXG4gICAgICBfcC5ob29rZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBsYXk6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIC8vIGF1dG9yZXdpbmRcbiAgICBpZiggX3AucHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmhvb2soKTtcblxuICAgIC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIHN0YXJ0IHRoZSBhbmltYXRpb24uLi5cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBsYXlpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGxheWluZztcbiAgfSxcblxuICBhcHBseTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AuYXBwbHlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgYXBwbHkgdGhlIGFuaW1hdGlvbiBhdCB0aGlzIHByb2dyZXNzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhcHBseWluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hcHBseWluZztcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgX3Auc3RvcHBlZCA9IHRydWU7IC8vIHRvIGJlIHJlbW92ZWQgZnJvbSBhbmltYXRpb24gcXVldWVzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZXdpbmQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoIDAgKTtcbiAgfSxcblxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyggMSApO1xuICB9LFxuXG4gIHRpbWU6IGZ1bmN0aW9uKCB0ICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCB0ID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcyAqIF9wLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyggdCAvIF9wLmR1cmF0aW9uICk7XG4gICAgfVxuICB9LFxuXG4gIHByb2dyZXNzOiBmdW5jdGlvbiggcCApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgaWYoIHAgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiggd2FzUGxheWluZyApe1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIF9wLnByb2dyZXNzID0gcDtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYoIHdhc1BsYXlpbmcgKXtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29tcGxldGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnByb2dyZXNzID09PSAxO1xuICB9LFxuXG4gIHJldmVyc2U6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiggd2FzUGxheWluZyApe1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHZhciBzd2FwID0gZnVuY3Rpb24oIGEsIGIgKXtcbiAgICAgIHZhciBfcGEgPSBfcFsgYSBdO1xuXG4gICAgICBfcFsgYSBdID0gX3BbIGIgXTtcbiAgICAgIF9wWyBiIF0gPSBfcGE7XG4gICAgfTtcblxuICAgIHN3YXAoICd6b29tJywgJ3N0YXJ0Wm9vbScgKTtcbiAgICBzd2FwKCAncGFuJywgJ3N0YXJ0UGFuJyApO1xuICAgIHN3YXAoICdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyApO1xuXG4gICAgLy8gc3dhcCBzdHlsZXNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IF9wLnN0eWxlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlWyBpIF07XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbIG5hbWUgXTtcblxuICAgICAgX3Auc3RhcnRTdHlsZVsgbmFtZSBdID0gcHJvcDtcbiAgICAgIF9wLnN0eWxlWyBpIF0gPSBzdGFydFN0eWxlUHJvcDtcbiAgICB9XG5cbiAgICBpZiggd2FzUGxheWluZyApe1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24oIHR5cGUgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgdmFyIGFycjtcblxuICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICBhcnIgPSBfcC5mcmFtZXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIGFyciA9IF9wLmNvbXBsZXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcbiAgICAgIGFyci5wdXNoKCBmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9ICk7XG4gICAgfSApO1xuICB9XG5cbn0gKTtcblxuYW5pZm4uY29tcGxldGUgPSBhbmlmbi5jb21wbGV0ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFJlY29uc3RydWN0cyB0aGUgcGF0aCBmcm9tIFN0YXJ0IHRvIEVuZCwgYWN1bXVsYXRpbmcgdGhlIHJlc3VsdCBpbiBwYXRoQWN1bVxuICAgIHZhciByZWNvbnN0cnVjdFBhdGggPSBmdW5jdGlvbiggc3RhcnQsIGVuZCwgY2FtZUZyb21NYXAsIHBhdGhBY3VtICl7XG4gICAgICAvLyBCYXNlIGNhc2VcbiAgICAgIGlmKCBzdGFydCA9PSBlbmQgKXtcbiAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoIGVuZCApICk7XG4gICAgICAgIHJldHVybiBwYXRoQWN1bTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVuZCBpbiBjYW1lRnJvbU1hcCApe1xuICAgICAgICAvLyBXZSBrbm93IHdoaWNoIG5vZGUgaXMgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjYW1lRnJvbU1hcFsgZW5kIF07XG4gICAgICAgIHZhciBwcmV2aW91c0VkZ2UgPSBjYW1lRnJvbUVkZ2VbIGVuZCBdO1xuXG4gICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKCBlbmQgKSApO1xuICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZCggcHJldmlvdXNFZGdlICkgKTtcblxuXG4gICAgICAgIHJldHVybiByZWNvbnN0cnVjdFBhdGgoIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsXG4gICAgICAgICAgICAgICAgICAgICBjYW1lRnJvbU1hcCxcbiAgICAgICAgICAgICAgICAgICAgIHBhdGhBY3VtICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIG9wZW5TZXQgd2hpY2ggaGFzIG1pbmltdW0gZlNjb3JlXG4gICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbiggb3BlblNldCwgZlNjb3JlICl7XG4gICAgICBpZiggb3BlblNldC5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciB0ZW1wU2NvcmUgPSBmU2NvcmVbIG9wZW5TZXRbMF0gXTtcbiAgICAgIGZvciggdmFyIGkgPSAxOyBpIDwgb3BlblNldC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcyA9IGZTY29yZVsgb3BlblNldFsgaSBdIF07XG4gICAgICAgIGlmKCBzIDwgdGVtcFNjb3JlICl7XG4gICAgICAgICAgdGVtcFNjb3JlID0gcztcbiAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUG9zO1xuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiggb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICB2YXIgc291cmNlID0gaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSA/XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB0aGlzLmZpbHRlciggb3B0aW9ucy5yb290IClbMF0gOlxuICAgICAgICBvcHRpb25zLnJvb3RbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZ29hbCAtIG1hbmRhdG9yeSFcbiAgICBpZiggb3B0aW9ucy5nb2FsICE9IG51bGwgKXtcbiAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcoIG9wdGlvbnMuZ29hbCApID9cbiAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgIHRoaXMuZmlsdGVyKCBvcHRpb25zLmdvYWwgKVswXSA6XG4gICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBIZXVyaXN0aWMgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmhldXJpc3RpYyAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLmhldXJpc3RpYyApICl7XG4gICAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgfVxuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKCBlICl7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlZFNldCA9IFtdO1xuICAgIHZhciBvcGVuU2V0ID0gWyBzb3VyY2UuaWQoKSBdO1xuICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgdmFyIGZTY29yZSA9IHt9O1xuXG4gICAgZ1Njb3JlWyBzb3VyY2UuaWQoKSBdID0gMDtcbiAgICBmU2NvcmVbIHNvdXJjZS5pZCgpIF0gPSBoZXVyaXN0aWMoIHNvdXJjZSApO1xuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlciggZnVuY3Rpb24oIGUgKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9ICk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgLy8gQ291bnRlclxuICAgIHZhciBzdGVwcyA9IDA7XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICB3aGlsZSggb3BlblNldC5sZW5ndGggPiAwICl7XG4gICAgICB2YXIgbWluUG9zID0gZmluZE1pbiggb3BlblNldCwgZlNjb3JlICk7XG4gICAgICB2YXIgY01pbiA9IGN5LmdldEVsZW1lbnRCeUlkKCBvcGVuU2V0WyBtaW5Qb3MgXSApO1xuICAgICAgc3RlcHMrKztcblxuICAgICAgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgIGlmKCBjTWluLmlkKCkgPT0gdGFyZ2V0LmlkKCkgKXtcbiAgICAgICAgdmFyIHJQYXRoID0gcmVjb25zdHJ1Y3RQYXRoKCBzb3VyY2UuaWQoKSwgdGFyZ2V0LmlkKCksIGNhbWVGcm9tLCBbXSApO1xuICAgICAgICByUGF0aC5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVsgY01pbi5pZCgpIF0sXG4gICAgICAgICAgcGF0aDogZWxlcy5zcGF3biggclBhdGggKSxcbiAgICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG4gICAgICBjbG9zZWRTZXQucHVzaCggY01pbi5pZCgpICk7XG4gICAgICAvLyBSZW1vdmUgY01pbiBmcm9tIGJvdW5kYXJ5IG5vZGVzXG4gICAgICBvcGVuU2V0LnNwbGljZSggbWluUG9zLCAxICk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzY29yZXMgZm9yIG5laWdoYm9ycyBvZiBjTWluXG4gICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgaWYoIGRpcmVjdGVkICl7IHZ3RWRnZXMgPSB2d0VkZ2VzLnN0ZEZpbHRlciggZnVuY3Rpb24oIGVsZSApeyByZXR1cm4gZWxlLmRhdGEoICdzb3VyY2UnICkgPT09IGNNaW4uaWQoKTsgfSApOyB9XG4gICAgICB2d0VkZ2VzID0gdndFZGdlcy5pbnRlcnNlY3QoIGVkZ2VzICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbIGkgXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggbiApeyByZXR1cm4gbi5pZCgpICE9PSBjTWluLmlkKCk7IH0gKS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuICAgICAgICBpZiggY2xvc2VkU2V0LmluZGV4T2YoIHcuaWQoKSApICE9IC0xICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVsgY01pbi5pZCgpIF0gKyB3ZWlnaHRGbi5hcHBseSggZSwgWyBlIF0gKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgIGlmKCBvcGVuU2V0LmluZGV4T2YoIHcuaWQoKSApID09IC0xICl7XG4gICAgICAgICAgZ1Njb3JlWyB3LmlkKCkgXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbIHcuaWQoKSBdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKCB3ICk7XG4gICAgICAgICAgb3BlblNldC5wdXNoKCB3LmlkKCkgKTsgLy8gQWRkIG5vZGUgdG8gb3BlblNldFxuICAgICAgICAgIGNhbWVGcm9tWyB3LmlkKCkgXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2VbIHcuaWQoKSBdID0gZS5pZCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuICAgICAgICBpZiggdGVtcFNjb3JlIDwgZ1Njb3JlWyB3LmlkKCkgXSApe1xuICAgICAgICAgIGdTY29yZVsgdy5pZCgpIF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlWyB3LmlkKCkgXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyggdyApO1xuICAgICAgICAgIGNhbWVGcm9tWyB3LmlkKCkgXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICBkaXN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gZWxlc2ZuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgKXtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSApe1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsdGVyKCBvcHRpb25zLnJvb3QgKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgaWQycG9zaXRpb25bIG5vZGVzWyBpIF0uaWQoKSBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICB2YXIgY29zdCA9IFtdO1xuICAgIHZhciBwcmVkZWNlc3NvciA9IFtdO1xuICAgIHZhciBwcmVkRWRnZSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZiggbm9kZXNbIGkgXS5pZCgpID09PSBzb3VyY2UuaWQoKSApe1xuICAgICAgICBjb3N0WyBpIF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29zdFsgaSBdID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBwcmVkZWNlc3NvclsgaSBdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEVkZ2VzIHJlbGF4YXRpb25cbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGUgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgZSBdLnRhcmdldCgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlc1sgZSBdLCBbIGVkZ2VzWyBlIF0gXSApO1xuXG4gICAgICAgIHZhciB0ZW1wID0gY29zdFsgc291cmNlSW5kZXggXSArIHdlaWdodDtcbiAgICAgICAgaWYoIHRlbXAgPCBjb3N0WyB0YXJnZXRJbmRleCBdICl7XG4gICAgICAgICAgY29zdFsgdGFyZ2V0SW5kZXggXSA9IHRlbXA7XG4gICAgICAgICAgcHJlZGVjZXNzb3JbIHRhcmdldEluZGV4IF0gPSBzb3VyY2VJbmRleDtcbiAgICAgICAgICBwcmVkRWRnZVsgdGFyZ2V0SW5kZXggXSA9IGVkZ2VzWyBlIF07XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICBpZiggIWRpcmVjdGVkICl7XG4gICAgICAgICAgdmFyIHRlbXAgPSBjb3N0WyB0YXJnZXRJbmRleCBdICsgd2VpZ2h0O1xuICAgICAgICAgIGlmKCB0ZW1wIDwgY29zdFsgc291cmNlSW5kZXggXSApe1xuICAgICAgICAgICAgY29zdFsgc291cmNlSW5kZXggXSA9IHRlbXA7XG4gICAgICAgICAgICBwcmVkZWNlc3Nvclsgc291cmNlSW5kZXggXSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgICAgcHJlZEVkZ2VbIHNvdXJjZUluZGV4IF0gPSBlZGdlc1sgZSBdO1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhZyApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZmxhZyApe1xuICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKysgKXtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBlIF0uc291cmNlKCkuaWQoKSBdO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGUgXS50YXJnZXQoKS5pZCgpIF07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseSggZWRnZXNbIGUgXSwgWyBlZGdlc1sgZSBdIF0gKTtcblxuICAgICAgICBpZiggY29zdFsgc291cmNlSW5kZXggXSArIHdlaWdodCA8IGNvc3RbIHRhcmdldEluZGV4IF0gKXtcbiAgICAgICAgICB1dGlsLmVycm9yKCAnR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZCcgKTtcbiAgICAgICAgICByZXR1cm4geyBwYXRoVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIGRpc3RhbmNlVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdFxuICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgcG9zaXRpb24yaWQucHVzaCggbm9kZXNbIGkgXS5pZCgpICk7XG4gICAgfVxuXG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIHRvICl7XG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIHRvICkgKXtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlciggdG8gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29zdFsgaWQycG9zaXRpb25bIHRvSWQgXSBdO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiggdG8gKXtcblxuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oIHByZWRlY2Vzc29yLCBmcm9tUG9zLCB0b1BvcywgcG9zaXRpb24yaWQsIGFjdW1QYXRoLCBwcmVkRWRnZSApe1xuICAgICAgICAgIGZvciggOzsgKXtcbiAgICAgICAgICAgIC8vIEFkZCB0b0lkIHRvIHBhdGhcbiAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFsgdG9Qb3MgXSApICk7XG4gICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBwcmVkRWRnZVsgdG9Qb3MgXSApO1xuXG4gICAgICAgICAgICBpZiggZnJvbVBvcyA9PT0gdG9Qb3MgKXtcbiAgICAgICAgICAgICAgLy8gcmVhY2hlZCBzdGFydGluZyBub2RlXG4gICAgICAgICAgICAgIHJldHVybiBhY3VtUGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gcGF0aCBleGlzdHMsIGRpc2NhcnQgYWN1bXVsYXRlZCBwYXRoIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICB2YXIgcHJlZFBvcyA9IHByZWRlY2Vzc29yWyB0b1BvcyBdO1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBwcmVkUG9zID09PSAndW5kZWZpbmVkJyApe1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1BvcyA9IHByZWRQb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzLnN0cmluZyggdG8gKSApe1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKCB0byApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIFRoaXMgcmV0dXJucyBhIHJldmVyc2VkIHBhdGhcbiAgICAgICAgdmFyIHJlcyA9ICByZWNvbnN0cnVjdFBhdGhBdXgoIHByZWRlY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uWyBzb3VyY2UuaWQoKSBdLFxuICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uWyB0b0lkIF0sXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVkRWRnZSApO1xuXG4gICAgICAgIC8vIEdldCBpdCBpbiB0aGUgY29ycmVjdCBvcmRlciBhbmQgcmV0dXJuIGl0XG4gICAgICAgIGlmKCByZXMgIT0gbnVsbCApe1xuICAgICAgICAgIHJlcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3biggcmVzICk7XG4gICAgICB9LFxuXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBmYWxzZVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gIH0gLy8gYmVsbG1hbkZvcmRcblxufSk7IC8vIGVsZXNmblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xudmFyIEhlYXAgPSByZXF1aXJlKCAnLi4vLi4vaGVhcCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICB2YXIgd2VpZ2h0ZWQsIHdlaWdodEZuO1xuICAgIGlmKCBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIHdlaWdodGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2VpZ2h0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEaXJlY3RlZCAtIGRlZmF1bHQgZmFsc2VcbiAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgPyBvcHRpb25zLmRpcmVjdGVkIDogZmFsc2U7XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gc3RhcnRpbmdcbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBfQyA9IHt9O1xuICAgIHZhciBtYXggPSAwO1xuICAgIHZhciBDID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbigga2V5LCB2YWwgKXtcbiAgICAgICAgX0NbIGtleSBdID0gdmFsO1xuXG4gICAgICAgIGlmKCB2YWwgPiBtYXggKXsgbWF4ID0gdmFsOyB9XG4gICAgICB9LFxuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCBrZXkgKXsgcmV0dXJuIF9DWyBrZXkgXTsgfVxuICAgIH07XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB2ID0gVlsgaSBdO1xuICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcblxuICAgICAgaWYoIGRpcmVjdGVkICl7XG4gICAgICAgIEFbIHZpZCBdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBWyB2aWQgXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuXG4gICAgICBDLnNldCggdmlkLCAwICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrICl7XG4gICAgICB2YXIgc2lkID0gVltzXS5pZCgpO1xuICAgICAgdmFyIFMgPSBbXTsgLy8gc3RhY2tcbiAgICAgIHZhciBQID0ge307XG4gICAgICB2YXIgZyA9IHt9O1xuICAgICAgdmFyIGQgPSB7fTtcbiAgICAgIHZhciBRID0gbmV3IEhlYXAoZnVuY3Rpb24oIGEsIGIgKXtcbiAgICAgICAgcmV0dXJuIGRbYV0gLSBkW2JdO1xuICAgICAgfSk7IC8vIHF1ZXVlXG5cbiAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHZpZCA9IFZbIGkgXS5pZCgpO1xuXG4gICAgICAgIFBbIHZpZCBdID0gW107XG4gICAgICAgIGdbIHZpZCBdID0gMDtcbiAgICAgICAgZFsgdmlkIF0gPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgZ1sgc2lkIF0gPSAxOyAvLyBzaWdtYVxuICAgICAgZFsgc2lkIF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEucHVzaCggc2lkICk7XG5cbiAgICAgIHdoaWxlKCAhUS5lbXB0eSgpICl7XG4gICAgICAgIHZhciB2ID0gUS5wb3AoKTtcblxuICAgICAgICBTLnB1c2goIHYgKTtcblxuICAgICAgICBpZiggd2VpZ2h0ZWQgKXtcbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IEFbdl0ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciB3ID0gQVt2XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHYgKTtcblxuICAgICAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgICAgICBpZiggdkVsZS5lZGdlc1RvKCB3ICkubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKCB3IClbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGdlID0gdy5lZGdlc1RvKCB2RWxlIClbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFsgZWRnZSBdICk7XG5cbiAgICAgICAgICAgIHcgPSB3LmlkKCk7XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID4gZFt2XSArIGVkZ2VXZWlnaHQgKXtcbiAgICAgICAgICAgICAgZFt3XSA9IGRbdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmKCBRLm5vZGVzLmluZGV4T2YoIHcgKSA8IDAgKXsgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKCB3ICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0oIHcgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdbd10gPSAwO1xuICAgICAgICAgICAgICBQW3ddID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID09IGRbdl0gKyBlZGdlV2VpZ2h0ICl7XG4gICAgICAgICAgICAgIGdbd10gPSBnW3ddICsgZ1t2XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKCB2ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgQVt2XS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHcgPSBBW3ZdW2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmKCBkW3ddID09IEluZmluaXR5ICl7XG4gICAgICAgICAgICAgIFEucHVzaCggdyApO1xuXG4gICAgICAgICAgICAgIGRbd10gPSBkW3ZdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRbd10gPT0gZFt2XSArIDEgKXtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goIHYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSB7fTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBlWyBWWyBpIF0uaWQoKSBdID0gMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFMubGVuZ3RoID4gMCApe1xuICAgICAgICB2YXIgdyA9IFMucG9wKCk7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBQW3ddLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHYgPSBQW3ddW2pdO1xuXG4gICAgICAgICAgZVt2XSA9IGVbdl0gKyAoZ1t2XSAvIGdbd10pICogKDEgKyBlW3ddKTtcblxuICAgICAgICAgIGlmKCB3ICE9IFZbc10uaWQoKSApe1xuICAgICAgICAgICAgQy5zZXQoIHcsIEMuZ2V0KCB3ICkgKyBlW3ddICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IGN5LmZpbHRlciggbm9kZSApLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQy5nZXQoIG5vZGUgKTtcbiAgICAgIH0sXG5cbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgaWYgKCBtYXggPT0gMCApXG4gICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgaWYoIGlzLnN0cmluZyggbm9kZSApICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIoIG5vZGUgKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEMuZ2V0KCBub2RlICkgLyBtYXg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsaWFzXG4gICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG59KTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5iYyA9IGVsZXNmbi5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gIHBhcmFtcyA9IHtcbiAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gIH07XG5cbiAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgc3RkO1xuICAgIHZhciB0aGlzQXJnO1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggcm9vdHMgKSAmJiAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggcm9vdHMgKSApe1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIHN0ZCA9IG9wdGlvbnMuc3RkO1xuICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICB9XG5cbiAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWlzLmZuKCBmbiApID8gZm4gOiBkaXJlY3RlZDtcbiAgICBmbiA9IGlzLmZuKCBmbiApID8gZm4gOiBmdW5jdGlvbigpe307XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciB2ID0gcm9vdHMgPSBpcy5zdHJpbmcoIHJvb3RzICkgPyB0aGlzLmZpbHRlciggcm9vdHMgKSA6IHJvb3RzO1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIFYgPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGZvdW5kO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG5cbiAgICAvLyBlbnF1ZXVlIHZcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKysgKXtcbiAgICAgIGlmKCB2WyBpIF0uaXNOb2RlKCkgKXtcbiAgICAgICAgUS51bnNoaWZ0KCB2WyBpIF0gKTtcblxuICAgICAgICBpZiggcGFyYW1zLmJmcyApe1xuICAgICAgICAgIFZbIHZbIGkgXS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdlsgaSBdICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZDJkZXB0aFsgdlsgaSBdLmlkKCkgXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUoIFEubGVuZ3RoICE9PSAwICl7XG4gICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuXG4gICAgICBpZiggcGFyYW1zLmRmcyApe1xuICAgICAgICBpZiggVlsgdi5pZCgpIF0gKXsgY29udGludWU7IH1cblxuICAgICAgICBWWyB2LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdiApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgdi5pZCgpIF07XG4gICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3QoIHYgKVswXTtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgcmV0ID0gZm4uY2FsbCggdGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmbi5jYWxsKCB2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCBkaXJlY3RlZCA/IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGEoICdzb3VyY2UnICkgPT09IHYuaWQoKTsgfSA6IHVuZGVmaW5lZCApLmludGVyc2VjdCggZWRnZXMgKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbIGkgXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pZCgpICE9PSB2LmlkKCk7IH0gKS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgaWYoIHcubGVuZ3RoICE9PSAwICYmICFWWyB3LmlkKCkgXSApe1xuICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgUS5wdXNoKCB3ICk7XG5cbiAgICAgICAgICBpZiggcGFyYW1zLmJmcyApe1xuICAgICAgICAgICAgVlsgdy5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB3ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcblxuICAgICAgICAgIGlkMmRlcHRoWyB3LmlkKCkgXSA9IGlkMmRlcHRoWyB2LmlkKCkgXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzWyBpIF07XG4gICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5WyBub2RlLmlkKCkgXTtcblxuICAgICAgaWYoIGVkZ2UgKXtcbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggbm9kZSApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBjeS5jb2xsZWN0aW9uKCBjb25uZWN0ZWRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICBmb3VuZDogY3kuY29sbGVjdGlvbiggZm91bmQgKVxuICAgIH07XG4gIH07XG59O1xuXG4vLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcbnZhciBlbGVzZm4gPSAoe1xuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCggeyBiZnM6IHRydWUgfSApLFxuICBkZXB0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goIHsgZGZzOiB0cnVlIH0gKVxufSk7XG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5iZnMgPSBlbGVzZm4uYnJlYWR0aEZpcnN0U2VhcmNoO1xuZWxlc2ZuLmRmcyA9IGVsZXNmbi5kZXB0aEZpcnN0U2VhcmNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBoYXJtb25pYyA9IG9wdGlvbnMuaGFybW9uaWM7XG4gICAgaWYoIGhhcm1vbmljID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKCB7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkIH0gKTtcblxuICAgIC8vIENvbXB1dGUgY2xvc2VuZXNzIGZvciBldmVyeSBub2RlIGFuZCBmaW5kIHRoZSBtYXhpbXVtIGNsb3NlbmVzc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgaWYoIGkgIT0gaiApe1xuICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2UoIG5vZGVzWyBpIF0sIG5vZGVzWyBqIF0gKTtcblxuICAgICAgICAgIGlmKCBoYXJtb25pYyApe1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIWhhcm1vbmljICl7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgaWYoIG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3MgKXtcbiAgICAgICAgbWF4Q2xvc2VuZXNzID0gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgY2xvc2VuZXNzZXNbIG5vZGVzWyBpIF0uaWQoKSBdID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICBpZiggbWF4Q2xvc2VuZXNzID09IDAgKXsgcmV0dXJuIDA7IH1cblxuICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1sgbm9kZSBdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmKCBvcHRpb25zLnJvb3QgIT0gbnVsbCApe1xuICAgICAgaWYoIGlzLnN0cmluZyggb3B0aW9ucy5yb290ICkgKXtcbiAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICAgIHZhciByb290ID0gdGhpcy5maWx0ZXIoIG9wdGlvbnMucm9vdCApWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgdmFyIHdlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd2VpZ2h0ID0gZnVuY3Rpb24oKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICYmIGlzLmJvb2woIG9wdGlvbnMuZGlyZWN0ZWQgKSApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICBpZiggaGFybW9uaWMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgaGFybW9uaWMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gZXZlcnkgb3RoZXIgbm9kZVxuICAgIHZhciBkaWprc3RyYSA9IHRoaXMuZGlqa3N0cmEoIHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0gKTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG5cbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgaWYoIG5vZGVzWyBpIF0uaWQoKSAhPSByb290LmlkKCkgKXtcbiAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKCBub2Rlc1sgaSBdICk7XG5cbiAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSAxIC8gZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gIH0gLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG59KTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5jYyA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5O1xuZWxlc2ZuLmNjbiA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgKXtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiggIWRpcmVjdGVkICl7XG4gICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSggdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7cm9vdDogbm9kZX0gKSApO1xuICAgICAgICBpZiggbWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUgKVxuICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuXG4gICAgICAgIGRlZ3JlZXNbIG5vZGUuaWQoKSBdID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgICBpZiggbWF4RGVncmVlID09IDAgKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlciggbm9kZSApWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbIG5vZGUgXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtyb290OiBub2RlfSApICk7XG5cbiAgICAgICAgaWYoIG1heEluZGVncmVlIDwgY3VyckRlZ3JlZS5pbmRlZ3JlZSApXG4gICAgICAgICAgbWF4SW5kZWdyZWUgPSBjdXJyRGVncmVlLmluZGVncmVlO1xuXG4gICAgICAgIGlmKCBtYXhPdXRkZWdyZWUgPCBjdXJyRGVncmVlLm91dGRlZ3JlZSApXG4gICAgICAgICAgbWF4T3V0ZGVncmVlID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG5cbiAgICAgICAgaW5kZWdyZWVzWyBub2RlLmlkKCkgXSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIG91dGRlZ3JlZXNbIG5vZGUuaWQoKSBdID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIGlmICggbWF4SW5kZWdyZWUgPT0gMCApXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzWyBub2RlIF0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIGlmICggbWF4T3V0ZGVncmVlID09IDAgKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlciggbm9kZSApWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbIG5vZGUgXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxuICB9LCAvLyBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZFxuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmKCBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwgKXtcbiAgICAgIHZhciByb290ID0gaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSA/IHRoaXMuZmlsdGVyKCBvcHRpb25zLnJvb3QgKVswXSA6IG9wdGlvbnMucm9vdFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyB3ZWlnaHQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhbHBoYSAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuYWxwaGEgIT0gbnVsbCAmJiBpcy5udW1iZXIoIG9wdGlvbnMuYWxwaGEgKSApe1xuICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cblxuXG4gICAgaWYoICFkaXJlY3RlZCApe1xuICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uRWRnZXNbIGkgXTtcbiAgICAgICAgcyArPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyggaywgMSAtIGFscGhhICkgKiBNYXRoLnBvdyggcywgYWxwaGEgKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluY29taW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcyggJ2VkZ2VbdGFyZ2V0ID0gXCInICsgcm9vdC5pZCgpICsgJ1wiXScgKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCAnZWRnZVtzb3VyY2UgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJyApLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGluY29taW5nLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gaW5jb21pbmdbIGkgXTtcbiAgICAgICAgc19pbiArPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG91dGdvaW5nLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gb3V0Z29pbmdbIGkgXTtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFsgZWRnZSBdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBNYXRoLnBvdygga19pbiwgMSAtIGFscGhhICkgKiBNYXRoLnBvdyggc19pbiwgYWxwaGEgKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdygga19vdXQsIDEgLSBhbHBoYSApICogTWF0aC5wb3coIHNfb3V0LCBhbHBoYSApXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBkZWdyZWVDZW50cmFsaXR5XG5cbn0pOyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmRjID0gZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHk7XG5lbGVzZm4uZGNuID0gZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xudmFyIEhlYXAgPSByZXF1aXJlKCAnLi4vLi4vaGVhcCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgZGlqa3N0cmE6IGZ1bmN0aW9uKCByb290LCB3ZWlnaHRGbiwgZGlyZWN0ZWQgKXtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiggaXMucGxhaW5PYmplY3QoIHJvb3QgKSAmJiAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggcm9vdCApICl7XG4gICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgIHJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gICAgICB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgd2VpZ2h0Rm4gPSBpcy5mbiggd2VpZ2h0Rm4gKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgIHZhciBzb3VyY2UgPSBpcy5zdHJpbmcoIHJvb3QgKSA/IHRoaXMuZmlsdGVyKCByb290IClbMF0gOiByb290WzBdO1xuICAgIHZhciBkaXN0ID0ge307XG4gICAgdmFyIHByZXYgPSB7fTtcbiAgICB2YXIga25vd25EaXN0ID0ge307XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuZmlsdGVyKCBmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICByZXR1cm4gZGlzdFsgbm9kZS5pZCgpIF07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24oIG5vZGUsIGQgKXtcbiAgICAgIGRpc3RbIG5vZGUuaWQoKSBdID0gZDtcblxuICAgICAgUS51cGRhdGVJdGVtKCBub2RlICk7XG4gICAgfTtcblxuICAgIHZhciBRID0gbmV3IEhlYXAoIGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICByZXR1cm4gZ2V0RGlzdCggYSApIC0gZ2V0RGlzdCggYiApO1xuICAgIH0gKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcblxuICAgICAgZGlzdFsgbm9kZS5pZCgpIF0gPSBub2RlLnNhbWUoIHNvdXJjZSApID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24oIHUsIHYgKXtcbiAgICAgIHZhciB1dnMgPSAoIGRpcmVjdGVkID8gdS5lZGdlc1RvKCB2ICkgOiB1LmVkZ2VzV2l0aCggdiApICkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gdXZzWyBpIF07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcblxuICAgICAgICBpZiggd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlICl7XG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHdlaWdodDtcbiAgICAgICAgICBzbWFsbGVzdEVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgd2hpbGUoIFEuc2l6ZSgpID4gMCApe1xuICAgICAgdmFyIHUgPSBRLnBvcCgpO1xuICAgICAgdmFyIHNtYWxsZXRzRGlzdCA9IGdldERpc3QoIHUgKTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG5cbiAgICAgIGtub3duRGlzdFsgdWlkIF0gPSBzbWFsbGV0c0Rpc3Q7XG5cbiAgICAgIGlmKCBzbWFsbGV0c0Rpc3QgPT09IE1hdGguSW5maW5pdGUgKXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdCggbm9kZXMgKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzWyBpIF07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKCB1LCB2ICk7XG5cbiAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG5cbiAgICAgICAgaWYoIGFsdCA8IGdldERpc3QoIHYgKSApe1xuICAgICAgICAgIHNldERpc3QoIHYsIGFsdCApO1xuXG4gICAgICAgICAgcHJldlsgdmlkIF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG4gICAgfSAvLyB3aGlsZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcoIG5vZGUgKSA/IG5vZGVzLmZpbHRlciggbm9kZSApWzBdIDogbm9kZVswXTtcblxuICAgICAgICByZXR1cm4ga25vd25EaXN0WyB0YXJnZXQuaWQoKSBdO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICB2YXIgdGFyZ2V0ID0gaXMuc3RyaW5nKCBub2RlICkgPyBub2Rlcy5maWx0ZXIoIG5vZGUgKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuXG4gICAgICAgIGlmKCB0YXJnZXQubGVuZ3RoID4gMCApe1xuICAgICAgICAgIFMudW5zaGlmdCggdGFyZ2V0ICk7XG5cbiAgICAgICAgICB3aGlsZSggcHJldlsgdS5pZCgpIF0gKXtcbiAgICAgICAgICAgIHZhciBwID0gcHJldlsgdS5pZCgpIF07XG5cbiAgICAgICAgICAgIFMudW5zaGlmdCggcC5lZGdlICk7XG4gICAgICAgICAgICBTLnVuc2hpZnQoIHAubm9kZSApO1xuXG4gICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCBTICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKCBlICl7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlciggZnVuY3Rpb24oIGUgKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9ICk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIGlkMnBvc2l0aW9uWyBub2Rlc1sgaSBdLmlkKCkgXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgZGlzdCA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheSggbnVtTm9kZXMgKTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICBpZiggaSA9PSBqICl7XG4gICAgICAgICAgbmV3Um93WyBqIF0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jvd1sgaiBdID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRpc3QucHVzaCggbmV3Um93ICk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIG5leHQgPSBbXTtcbiAgICB2YXIgZWRnZU5leHQgPSBbXTtcblxuICAgIHZhciBpbml0TWF0cml4ID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KCBudW1Ob2RlcyApO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICBuZXdSb3dbIGogXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LnB1c2goIG5ld1JvdyApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0TWF0cml4KCBuZXh0ICk7XG4gICAgaW5pdE1hdHJpeCggZWRnZU5leHQgKTtcblxuICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKyApe1xuICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBpIF0uc291cmNlKCkuaWQoKSBdO1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBpIF0udGFyZ2V0KCkuaWQoKSBdO1xuICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlc1sgaSBdLCBbIGVkZ2VzWyBpIF0gXSApO1xuXG4gICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICBpZiggZGlzdFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA+IHdlaWdodCApe1xuICAgICAgICBkaXN0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gd2VpZ2h0O1xuICAgICAgICBuZXh0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgIGVkZ2VOZXh0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gZWRnZXNbIGkgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZXNcbiAgICBpZiggIWRpcmVjdGVkICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKyApe1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS50YXJnZXQoKS5pZCgpIF07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgaSBdLnNvdXJjZSgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlc1sgaSBdLCBbIGVkZ2VzWyBpIF0gXSApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYoIGRpc3RbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPiB3ZWlnaHQgKXtcbiAgICAgICAgICBkaXN0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gd2VpZ2h0O1xuICAgICAgICAgIG5leHRbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IGVkZ2VzWyBpIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IoIHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKysgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICBpZiggZGlzdFsgaSBdWyBrIF0gKyBkaXN0WyBrIF1bIGogXSA8IGRpc3RbIGkgXVsgaiBdICl7XG4gICAgICAgICAgICBkaXN0WyBpIF1bIGogXSA9IGRpc3RbIGkgXVsgayBdICsgZGlzdFsgayBdWyBqIF07XG4gICAgICAgICAgICBuZXh0WyBpIF1bIGogXSA9IG5leHRbIGkgXVsgayBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3RcbiAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIHBvc2l0aW9uMmlkLnB1c2goIG5vZGVzWyBpIF0uaWQoKSApO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24oIGZyb20sIHRvICl7XG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIGZyb20gKSApe1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlciggZnJvbSApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIHRvICkgKXtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlciggdG8gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdFsgaWQycG9zaXRpb25bIGZyb21JZCBdIF1bIGlkMnBvc2l0aW9uWyB0b0lkIF0gXTtcbiAgICAgIH0sXG5cbiAgICAgIHBhdGg6IGZ1bmN0aW9uKCBmcm9tLCB0byApe1xuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oIGZyb20sIHRvLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQgKXtcbiAgICAgICAgICBpZiggZnJvbSA9PT0gdG8gKXtcbiAgICAgICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbIGZyb20gXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggbmV4dFsgZnJvbSBdWyB0byBdID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGggPSBbIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFsgZnJvbSBdICkgXTtcbiAgICAgICAgICB2YXIgcHJldiA9IGZyb207XG4gICAgICAgICAgd2hpbGUoIGZyb20gIT09IHRvICl7XG4gICAgICAgICAgICBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgIGZyb20gPSBuZXh0WyBmcm9tIF1bIHRvIF07XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZU5leHRbIHByZXYgXVsgZnJvbSBdO1xuICAgICAgICAgICAgcGF0aC5wdXNoKCBlZGdlICk7XG5cbiAgICAgICAgICAgIHBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkWyBmcm9tIF0gKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXMuc3RyaW5nKCBmcm9tICkgKXtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoIGZyb20gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXMuc3RyaW5nKCB0byApICl7XG4gICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIoIHRvIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhBcnIgPSByZWNvbnN0cnVjdFBhdGhBdXgoIGlkMnBvc2l0aW9uWyBmcm9tSWQgXSxcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblsgdG9JZCBdLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgZWRnZU5leHQgKTtcblxuICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbiggcGF0aEFyciApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gIH0gLy8gZmxveWRXYXJzaGFsbFxuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbltcbiAgcmVxdWlyZSggJy4vYmZzLWRmcycgKSxcbiAgcmVxdWlyZSggJy4vZGlqa3N0cmEnICksXG4gIHJlcXVpcmUoICcuL2tydXNrYWwnICksXG4gIHJlcXVpcmUoICcuL2Etc3RhcicgKSxcbiAgcmVxdWlyZSggJy4vZmxveWQtd2Fyc2hhbGwnICksXG4gIHJlcXVpcmUoICcuL2JlbGxtYW4tZm9yZCcgKSxcbiAgcmVxdWlyZSggJy4va2VyZ2VyLXN0ZWluJyApLFxuICByZXF1aXJlKCAnLi9wYWdlLXJhbmsnICksXG4gIHJlcXVpcmUoICcuL2RlZ3JlZS1jZW50cmFsaXR5JyApLFxuICByZXF1aXJlKCAnLi9jbG9zZW5lc3MtY2VudHJhbGl0eScgKSxcbiAgcmVxdWlyZSggJy4vYmV0d2Vlbm5lc3MtY2VudHJhbGl0eScgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gIC8vIFJldHVybnMgdGhlIGNvcnJlY3QgYW5zd2VyIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuICBrYXJnZXJTdGVpbjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4gICAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG4gICAgdmFyIGNvbGFwc2UgPSBmdW5jdGlvbiggZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcyApe1xuICAgICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbIGVkZ2VJbmRleCBdO1xuICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFsgc291cmNlSW4gXTtcbiAgICAgIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFsgdGFyZ2V0SW4gXTtcblxuICAgICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzLmZpbHRlciggZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgaWYoIG5vZGVNYXBbIGVkZ2VbMV0gXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwWyBlZGdlWzJdIF0gPT09IHBhcnRpdGlvbjIgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIG5vZGVNYXBbIGVkZ2VbMV0gXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwWyBlZGdlWzJdIF0gPT09IHBhcnRpdGlvbjEgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9ICk7XG5cbiAgICAgIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZXdFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzWyBpIF07XG4gICAgICAgIGlmKCBlZGdlWzFdID09PSBwYXJ0aXRpb24yICl7IC8vIENoZWNrIHNvdXJjZVxuICAgICAgICAgIG5ld0VkZ2VzWyBpIF0gPSBlZGdlLnNsaWNlKCAwICk7XG4gICAgICAgICAgbmV3RWRnZXNbIGkgXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH0gZWxzZSBpZiggZWRnZVsyXSA9PT0gcGFydGl0aW9uMiApeyAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgICBuZXdFZGdlc1sgaSBdID0gZWRnZS5zbGljZSggMCApO1xuICAgICAgICAgIG5ld0VkZ2VzWyBpIF1bMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVNYXAubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIG5vZGVNYXBbIGkgXSA9PT0gcGFydGl0aW9uMiApe1xuICAgICAgICAgIG5vZGVNYXBbIGkgXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xuICAgIH07XG5cblxuICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24oIG1ldGFOb2RlTWFwLFxuICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzLFxuICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0ICl7XG4gICAgICAvLyBTdG9wIGNvbmRpdGlvblxuICAgICAgaWYoIHNpemUgPD0gc2l6ZUxpbWl0ICl7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKCAoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCkgKTtcblxuICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICB2YXIgbmV3RWRnZXMgPSBjb2xhcHNlKCBlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyApO1xuXG4gICAgICByZXR1cm4gY29udHJhY3RVbnRpbCggbWV0YU5vZGVNYXAsXG4gICAgICAgICAgICAgICAgIG5ld0VkZ2VzLFxuICAgICAgICAgICAgICAgICBzaXplIC0gMSxcbiAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0ICk7XG4gICAgfTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlciggZnVuY3Rpb24oIGUgKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9ICk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoIE1hdGgucG93KCBNYXRoLmxvZyggbnVtTm9kZXMgKSAvIE1hdGguTE4yLCAyICkgKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKCBudW1Ob2RlcyAvIE1hdGguc3FydCggMiApICk7XG5cbiAgICBpZiggbnVtTm9kZXMgPCAyICl7XG4gICAgICB1dGlsLmVycm9yKCAnQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nICk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZDJwb3NpdGlvblsgbm9kZXNbIGkgXS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKyApe1xuICAgICAgdmFyIGUgPSBlZGdlc1sgaSBdO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaCggWyBpLCBpZDJwb3NpdGlvblsgZS5zb3VyY2UoKS5pZCgpIF0sIGlkMnBvc2l0aW9uWyBlLnRhcmdldCgpLmlkKCkgXSBdICk7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dDtcblxuICAgIC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgIHZhciBvcmlnaW5hbE1ldGFOb2RlID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBvcmlnaW5hbE1ldGFOb2RlLnB1c2goIGkgKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IoIHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKysgKXtcbiAgICAgIC8vIENyZWF0ZSBuZXcgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgdmFyIG1ldGFOb2RlTWFwID0gb3JpZ2luYWxNZXRhTm9kZS5zbGljZSggMCApO1xuXG4gICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbCggbWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLCBudW1Ob2Rlcywgc3RvcFNpemUgKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgIHZhciBtZXRhTm9kZU1hcDIgPSBtZXRhTm9kZU1hcC5zbGljZSggMCApO1xuXG4gICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwoIG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMiApO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKCBtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyICk7XG5cbiAgICAgIC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG4gICAgICBpZiggcmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplICl7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0ID0gWyByZXMxLCBtZXRhTm9kZU1hcCBdO1xuICAgICAgfSBlbHNlIGlmKCByZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUgKXtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXQgPSBbIHJlczIsIG1ldGFOb2RlTWFwMiBdO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlc0VkZ2VzID0gKG1pbkN1dFswXSkubWFwKCBmdW5jdGlvbiggZSApeyByZXR1cm4gZWRnZXNbIGVbMF0gXTsgfSApO1xuICAgIHZhciBwYXJ0aXRpb24xID0gW107XG4gICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dFsxXVswXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdWyBpIF07XG4gICAgICBpZiggcGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uICl7XG4gICAgICAgIHBhcnRpdGlvbjEucHVzaCggbm9kZXNbIGkgXSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5wdXNoKCBub2Rlc1sgaSBdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGN1dDogZWxlcy5zcGF3biggY3ksIHJlc0VkZ2VzICksXG4gICAgICBwYXJ0aXRpb24xOiBlbGVzLnNwYXduKCBwYXJ0aXRpb24xICksXG4gICAgICBwYXJ0aXRpb24yOiBlbGVzLnNwYXduKCBwYXJ0aXRpb24yIClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufSk7IC8vIGVsZXNmblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBrcnVza2FsOiBmdW5jdGlvbiggd2VpZ2h0Rm4gKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB3ZWlnaHRGbiA9IGlzLmZuKCB3ZWlnaHRGbiApID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgZnVuY3Rpb24gZmluZFNldCggZWxlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFsgaSBdO1xuXG4gICAgICAgIGlmKCBlbGVzLmFueVNhbWUoIGVsZSApICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQSA9IGN5LmNvbGxlY3Rpb24oIGN5LCBbXSApO1xuICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBmb3Jlc3QucHVzaCggbm9kZXNbIGkgXS5jb2xsZWN0aW9uKCkgKTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgdmFyIFMgPSBlZGdlcy50b0FycmF5KCkuc29ydCggZnVuY3Rpb24oIGEsIGIgKXtcbiAgICAgIHZhciB3ZWlnaHRBID0gd2VpZ2h0Rm4uY2FsbCggYSwgYSApO1xuICAgICAgdmFyIHdlaWdodEIgPSB3ZWlnaHRGbi5jYWxsKCBiLCBiICk7XG5cbiAgICAgIHJldHVybiB3ZWlnaHRBIC0gd2VpZ2h0QjtcbiAgICB9ICk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IFMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gU1sgaSBdO1xuICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHNldFUgPSBmaW5kU2V0KCB1ICk7XG4gICAgICB2YXIgc2V0ViA9IGZpbmRTZXQoIHYgKTtcblxuICAgICAgaWYoIHNldFUuaW5kZXggIT09IHNldFYuaW5kZXggKXtcbiAgICAgICAgQSA9IEEuYWRkKCBlZGdlICk7XG5cbiAgICAgICAgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG4gICAgICAgIGZvcmVzdFsgc2V0VS5pbmRleCBdID0gc2V0VS5lbGVzLmFkZCggc2V0Vi5lbGVzICk7XG4gICAgICAgIGZvcmVzdC5zcGxpY2UoIHNldFYuaW5kZXgsIDEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXMuYWRkKCBBICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICBwYWdlUmFuazogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBub3JtYWxpemVWZWN0b3IgPSBmdW5jdGlvbiggdmVjdG9yICl7XG4gICAgICB2YXIgbGVuZ3RoID0gdmVjdG9yLmxlbmd0aDtcblxuICAgICAgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApe1xuICAgICAgICB0b3RhbCArPSB2ZWN0b3JbIGkgXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApe1xuICAgICAgICB2ZWN0b3JbIGkgXSA9IHZlY3RvclsgaSBdIC8gdG90YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGRhbXBpbmdGYWN0b3IgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMuZGFtcGluZ0ZhY3RvciAhPSBudWxsICl7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IG9wdGlvbnMuZGFtcGluZ0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSAwLjg7IC8vIERlZmF1bHQgZGFtcGluZyBmYWN0b3JcbiAgICB9XG5cbiAgICAvLyBkZXNpcmVkIHByZWNpc2lvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5wcmVjaXNpb24gIT0gbnVsbCApe1xuICAgICAgdmFyIGVwc2lsb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDAwMTsgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICB9XG5cbiAgICAvLyBNYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyAhPSBudWxsICl7XG4gICAgICB2YXIgbnVtSXRlciA9IG9wdGlvbnMuaXRlcmF0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG51bUl0ZXIgPSAyMDA7IC8vIERlZmF1bHQgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICB9XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiZcbiAgICAgIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oIGUgKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlciggZnVuY3Rpb24oIGUgKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9ICk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgaWQycG9zaXRpb25bIG5vZGVzWyBpIF0uaWQoKSBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIHZhciBjb2x1bW5TdW0gPSBbXTtcbiAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7XG5cbiAgICAvLyBDcmVhdGUgbnVsbCBtYXRyaWNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIHZhciBuZXdSb3cgPSBbXTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICBuZXdSb3cucHVzaCggMC4wICk7XG4gICAgICB9XG4gICAgICBtYXRyaXgucHVzaCggbmV3Um93ICk7XG4gICAgICBjb2x1bW5TdW0ucHVzaCggMC4wICk7XG4gICAgfVxuXG4gICAgLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrICl7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzWyBpIF07XG4gICAgICB2YXIgcyA9IGlkMnBvc2l0aW9uWyBlZGdlLnNvdXJjZSgpLmlkKCkgXTtcbiAgICAgIHZhciB0ID0gaWQycG9zaXRpb25bIGVkZ2UudGFyZ2V0KCkuaWQoKSBdO1xuICAgICAgdmFyIHcgPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcblxuICAgICAgLy8gVXBkYXRlIG1hdHJpeFxuICAgICAgbWF0cml4WyB0IF1bIHMgXSArPSB3O1xuXG4gICAgICAvLyBVcGRhdGUgY29sdW1uIHN1bVxuICAgICAgY29sdW1uU3VtWyBzIF0gKz0gdztcbiAgICB9XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcbiAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgaWYoIGNvbHVtblN1bVsgaiBdID09PSAwICl7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICAgIG1hdHJpeFsgaSBdWyBqIF0gPSBwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgICAgbWF0cml4WyBpIF1bIGogXSA9IG1hdHJpeFsgaSBdWyBqIF0gLyBjb2x1bW5TdW1bIGogXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcbiAgICB2YXIgZWlnZW52ZWN0b3IgPSBbXTtcbiAgICB2YXIgbnVsbFZlY3RvciA9IFtdO1xuICAgIHZhciBwcmV2aW91cztcblxuICAgIC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBlaWdlbnZlY3Rvci5wdXNoKCAxLjAgKTtcbiAgICAgIG51bGxWZWN0b3IucHVzaCggMC4wICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaXRlciA9IDA7IGl0ZXIgPCBudW1JdGVyOyBpdGVyKysgKXtcbiAgICAgIC8vIE5ldyBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgIHZhciB0ZW1wID0gbnVsbFZlY3Rvci5zbGljZSggMCApO1xuXG4gICAgICAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICB0ZW1wWyBpIF0gKz0gbWF0cml4WyBpIF1bIGogXSAqIGVpZ2VudmVjdG9yWyBqIF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9ybWFsaXplVmVjdG9yKCB0ZW1wICk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuXG4gICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgICBkaWZmICs9IE1hdGgucG93KCBwcmV2aW91c1sgaSBdIC0gZWlnZW52ZWN0b3JbIGkgXSwgMiApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG4gICAgICBpZiggZGlmZiA8IGVwc2lsb24gKXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICAvLyBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciBub2RlSWQgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBub2RlIG9iamVjdFxuICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yWyBpZDJwb3NpdGlvblsgbm9kZUlkIF0gXTtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIHBhZ2VSYW5rXG5cbn0pOyAvLyBlbGVzZm5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKClcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uKCBjbGFzc2VzICl7XG4gICAgY2xhc3NlcyA9ICggY2xhc3NlcyB8fCAnJyApLm1hdGNoKCAvXFxTKy9nICkgfHwgW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgdmFyIGNsYXNzZXNNYXAgPSB7fTtcblxuICAgIC8vIGZpbGwgaW4gY2xhc3NlcyBtYXBcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzWyBpIF07XG5cbiAgICAgIGNsYXNzZXNNYXBbIGNscyBdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZlsgaiBdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBfcC5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBhbGwgb2YgdGhlIHBhc3NlZCBjbGFzc2VzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbIGkgXTtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlc1sgY2xzIF07XG5cbiAgICAgICAgaWYoICFlbGVIYXNDbGFzcyApe1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgY2xhc3NlcyBvdXRzaWRlIG9mIHRob3NlIHBhc3NlZFxuICAgICAgaWYoICFjaGFuZ2VkRWxlICl7XG4gICAgICAgIHZhciBjbGFzc2VzID0gT2JqZWN0LmtleXMoIGVsZUNsYXNzZXMgKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlQ2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzWyBlbGVDbHMgXTtcbiAgICAgICAgICB2YXIgc3BlY2RDbGFzcyA9IGNsYXNzZXNNYXBbIGVsZUNscyBdOyAvLyBpLmUuIHRoaXMgY2xhc3MgaXMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuXG4gICAgICAgICAgaWYoIGVsZUhhc0NsYXNzICYmICFzcGVjZENsYXNzICl7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggY2hhbmdlZEVsZSApe1xuICAgICAgICBfcC5jbGFzc2VzID0gdXRpbC5jb3B5KCBjbGFzc2VzTWFwICk7XG5cbiAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICB0aGlzLnNwYXduKCBjaGFuZ2VkIClcbiAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgLnRyaWdnZXIoICdjbGFzcycgKVxuICAgICAgO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIGFkZENsYXNzOiBmdW5jdGlvbiggY2xhc3NlcyApe1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKCBjbGFzc2VzLCB0cnVlICk7XG4gIH0sXG5cbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gKCBlbGUgIT0gbnVsbCAmJiBlbGUuX3ByaXZhdGUuY2xhc3Nlc1sgY2xhc3NOYW1lIF0gKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIGNsYXNzZXNTdHIsIHRvZ2dsZSApe1xuICAgIHZhciBjbGFzc2VzID0gY2xhc3Nlc1N0ci5tYXRjaCggL1xcUysvZyApIHx8IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG5cbiAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmWyBpIF07XG4gICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbIGogXTtcbiAgICAgICAgdmFyIGVsZUNsYXNzZXMgPSBlbGUuX3ByaXZhdGUuY2xhc3NlcztcbiAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlQ2xhc3Nlc1sgY2xzIF07XG4gICAgICAgIHZhciBzaG91bGRBZGQgPSB0b2dnbGUgfHwgKHRvZ2dsZSA9PT0gdW5kZWZpbmVkICYmICFoYXNDbGFzcyk7XG5cbiAgICAgICAgaWYoIHNob3VsZEFkZCApe1xuICAgICAgICAgIGVsZUNsYXNzZXNbIGNscyBdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCAhaGFzQ2xhc3MgJiYgIWNoYW5nZWRFbGUgKXtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgZWxlQ2xhc3Nlc1sgY2xzIF0gPSBmYWxzZTtcblxuICAgICAgICAgIGlmKCBoYXNDbGFzcyAmJiAhY2hhbmdlZEVsZSApe1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGZvciBqIGNsYXNzZXNcbiAgICB9IC8vIGZvciBpIGVsZXNcblxuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgIHRoaXMuc3Bhd24oIGNoYW5nZWQgKVxuICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAudHJpZ2dlciggJ2NsYXNzJyApXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzICl7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoIGNsYXNzZXMsIGZhbHNlICk7XG4gIH0sXG5cbiAgZmxhc2hDbGFzczogZnVuY3Rpb24oIGNsYXNzZXMsIGR1cmF0aW9uICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIGR1cmF0aW9uID09IG51bGwgKXtcbiAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgIH0gZWxzZSBpZiggZHVyYXRpb24gPT09IDAgKXtcbiAgICAgIHJldHVybiBzZWxmOyAvLyBub3RoaW5nIHRvIGRvIHJlYWxseVxuICAgIH1cblxuICAgIHNlbGYuYWRkQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NlcyApO1xuICAgIH0sIGR1cmF0aW9uICk7XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgYWxsQXJlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID09PSB0aGlzLmxlbmd0aDtcbiAgfSxcblxuICBpczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBzZWxlY3RvciApLmxlbmd0aCA+IDA7XG4gIH0sXG5cbiAgc29tZTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbiggdGhpc1sgaSBdLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzWyBpIF0sIGksIHRoaXMgXSApO1xuXG4gICAgICBpZiggcmV0ICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBldmVyeTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbiggdGhpc1sgaSBdLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzWyBpIF0sIGksIHRoaXMgXSApO1xuXG4gICAgICBpZiggIXJldCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIC8vIGNoZWFwIGV4dHJhIGNoZWNrXG4gICAgaWYoIHRoaXMubGVuZ3RoICE9PSBjb2xsZWN0aW9uLmxlbmd0aCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gIH0sXG5cbiAgYW55U2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA+IDA7XG4gIH0sXG5cbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbn0pO1xuXG5lbGVzZm4uYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbi5hbGxBcmVOZWlnaGJvcnM7XG5lbGVzZm4uaGFzID0gZWxlc2ZuLmNvbnRhaW5zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZXNmbiA9ICh7XG4gIHBhcmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgKTtcblxuICAgICAgaWYoIHBhcmVudC5zaXplKCkgPiAwICl7XG4gICAgICAgIHBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgcGFyZW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgICAgcGFyZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cblxuICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuXG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMgfHwgcGFyZW50cztcblxuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdCggcGFyZW50cyApOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlciggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkuZW1wdHkoKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlciggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkubm9uZW1wdHkoKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCBlbGUuX3ByaXZhdGUuY2hpbGRyZW4gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggY2hpbGRyZW4sIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgc2libGluZ3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGlzUGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgfVxuICB9LFxuXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlLnBhcmVudCgpLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG5cbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKCBlbGVzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcblxuICAgICAgICBpZiggZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSApe1xuICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFkZCggdGhpcy5jaGlsZHJlbigpICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4uYW5jZXN0b3JzID0gZWxlc2ZuLnBhcmVudHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4uL2RlZmluZScgKTtcbnZhciBmbiwgZWxlc2ZuO1xuXG5mbiA9IGVsZXNmbiA9ICh7XG5cbiAgZGF0YTogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9ICksXG5cbiAgcnNjcmF0Y2g6IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9ICksXG5cbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKCB7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9ICksXG5cbiAgaWQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG5cbn0pO1xuXG4vLyBhbGlhc2VzXG5mbi5hdHRyID0gZm4uZGF0YTtcbmZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgaWYoIHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpICl7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1sgaSBdO1xuXG4gICAgICAgIGlmKCAhaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayggbm9kZSwgZWRnZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVncmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oIGZ1bmN0aW9uKCBub2RlLCBlZGdlICl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggZWRnZS50YXJnZXQoKSApICl7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9ICksXG5cbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKCBmdW5jdGlvbiggbm9kZSwgZWRnZSApe1xuICAgIGlmKCBlZGdlLnRhcmdldCgpLnNhbWUoIG5vZGUgKSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSApLFxuXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oIGZ1bmN0aW9uKCBub2RlLCBlZGdlICl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggbm9kZSApICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9IClcbn0gKTtcblxuZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oIGRlZ3JlZUZuLCBjYWxsYmFjayApe1xuICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgZGVncmVlID0gZWxlWyBkZWdyZWVGbiBdKCBpbmNsdWRlTG9vcHMgKTtcbiAgICAgIGlmKCBkZWdyZWUgIT09IHVuZGVmaW5lZCAmJiAocmV0ID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2soIGRlZ3JlZSwgcmV0ICkpICl7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdkZWdyZWUnLCBmdW5jdGlvbiggZGVncmVlLCBtaW4gKXtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9ICksXG5cbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ2RlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1heCApe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0gKSxcblxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdpbmRlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1pbiApe1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0gKSxcblxuICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdpbmRlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1heCApe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0gKSxcblxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCAnb3V0ZGVncmVlJywgZnVuY3Rpb24oIGRlZ3JlZSwgbWluICl7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSApLFxuXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdvdXRkZWdyZWUnLCBmdW5jdGlvbiggZGVncmVlLCBtYXggKXtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9IClcbn0gKTtcblxudXRpbC5leHRlbmQoIGVsZXNmbiwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdG90YWwgKz0gbm9kZXNbIGkgXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vbWF0aCcgKTtcbnZhciBmbiwgZWxlc2ZuO1xuXG5mbiA9IGVsZXNmbiA9ICh7XG5cbiAgcG9zaXRpb246IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICdydHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyAneCcsICd5JyBdLFxuICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gZWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdXBkYXRlZEVsZXMucnRyaWdnZXIoICdwb3NpdGlvbicgKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCkgJiYgIWVsZS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfSApLFxuXG4gIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgc2lsZW50UG9zaXRpb246IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB2YWxpZEtleXM6IFsgJ3gnLCAneScgXSxcbiAgICBvblNldDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCkgJiYgIWVsZS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfSApLFxuXG4gIHBvc2l0aW9uczogZnVuY3Rpb24oIHBvcywgc2lsZW50ICl7XG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KCBwb3MgKSApe1xuICAgICAgdGhpcy5wb3NpdGlvbiggcG9zICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmZuKCBwb3MgKSApe1xuICAgICAgdmFyIGZuID0gcG9zO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcblxuICAgICAgICB2YXIgcG9zID0gZm4uYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApO1xuXG4gICAgICAgIGlmKCBwb3MgJiYgIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICB2YXIgZWxlUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIGVsZVBvcy54ID0gcG9zLng7XG4gICAgICAgICAgZWxlUG9zLnkgPSBwb3MueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9UcmlnZ2VyID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkRWxlcyApIDogdGhpcztcblxuICAgICAgaWYoIHNpbGVudCApe1xuICAgICAgICB0b1RyaWdnZXIudHJpZ2dlciggJ3Bvc2l0aW9uJyApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9UcmlnZ2VyLnJ0cmlnZ2VyKCAncG9zaXRpb24nICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiggcG9zICl7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKCBwb3MsIHRydWUgKTtcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcnBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyggZGltICkgKTtcblxuICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG5cbiAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvblsgZGltIF0gPSAoIHZhbCAtIHBhblsgZGltIF0gKSAvIHpvb207XG4gICAgICAgICAgfSBlbHNlIGlmKCBycG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvIHpvb20sXG4gICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvIHpvb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydHJpZ2dlciggJ3Bvc2l0aW9uJyApO1xuICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICBycG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBycG9zWyBkaW0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyggZGltICkgKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uWyBkaW0gXSA9IHZhbCArIG9yaWdpblsgZGltIF07XG4gICAgICAgICAgfSBlbHNlIGlmKCBwcG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ0cmlnZ2VyKCAncG9zaXRpb24nICk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICBwcG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54IC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBvcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1sgZGltIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KCBvcHRpb25zICk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkxOiB5MSxcbiAgICAgIHkyOiB5MixcbiAgICAgIHc6IHgyIC0geDEsXG4gICAgICBoOiB5MiAtIHkxXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVDb21wb3VuZEJvdW5kczogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7IHJldHVybiBjeS5jb2xsZWN0aW9uKCk7IH1cblxuICAgIHZhciB1cGRhdGVkID0gW107XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoIHBhcmVudCApe1xuICAgICAgaWYoICFwYXJlbnQuaXNQYXJlbnQoKSApeyByZXR1cm47IH1cblxuICAgICAgdmFyIF9wID0gcGFyZW50Ll9wcml2YXRlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgICB2YXIgaW5jbHVkZUxhYmVscyA9IHBhcmVudC5wc3R5bGUoICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycgKS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuXG4gICAgICB2YXIgbWluID0ge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSggJ21pbi13aWR0aCcgKS5wZlZhbHVlLFxuICAgICAgICAgIGxlZnQ6IHBhcmVudC5wc3R5bGUoICdtaW4td2lkdGgtYmlhcy1sZWZ0JyApLFxuICAgICAgICAgIHJpZ2h0OiBwYXJlbnQucHN0eWxlKCAnbWluLXdpZHRoLWJpYXMtcmlnaHQnIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCAnbWluLWhlaWdodCcgKS5wZlZhbHVlLFxuICAgICAgICAgIHRvcDogcGFyZW50LnBzdHlsZSggJ21pbi1oZWlnaHQtYmlhcy10b3AnICksXG4gICAgICAgICAgYm90dG9tOiBwYXJlbnQucHN0eWxlKCAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScgKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCgge1xuICAgICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgICBpbmNsdWRlU2hhZG93czogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVPdmVybGF5czogZmFsc2UsXG5cbiAgICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgICAgLy8gY2FjaGUgY3ljbGUgKGkuZS4gYmVmb3JlIGZpcmVkIGV2ZW50cylcbiAgICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgICB9ICk7XG4gICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVCaWFzVmFsdWVzKCBwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCApe1xuICAgICAgICB2YXIgYmlhc0RpZmYgPSAwO1xuICAgICAgICB2YXIgYmlhc0NvbXBsZW1lbnREaWZmID0gMDtcbiAgICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuXG4gICAgICAgIGlmKCBwcm9wRGlmZiA+IDAgJiYgYmlhc1RvdGFsID4gMCApe1xuICAgICAgICAgIGJpYXNEaWZmID0gKCBwcm9wQmlhcyAvIGJpYXNUb3RhbCApICogcHJvcERpZmY7XG4gICAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmID0gKCBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKSAqIHByb3BEaWZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmlhc0RpZmY6IGJpYXNEaWZmLFxuICAgICAgICAgIGJpYXNDb21wbGVtZW50RGlmZjogYmlhc0NvbXBsZW1lbnREaWZmXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG4gICAgICBpZiggbWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDAgKXtcbiAgICAgICAgbGVmdFZhbCA9ICggbGVmdFZhbCAqIDEwMCApIC8gbWluLndpZHRoLnZhbDtcbiAgICAgIH1cbiAgICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcbiAgICAgIGlmKCBtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDAgKXtcbiAgICAgICAgcmlnaHRWYWwgPSAoIHJpZ2h0VmFsICogMTAwICkgLyBtaW4ud2lkdGgudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG4gICAgICBpZiggbWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwICl7XG4gICAgICAgIHRvcFZhbCA9ICggdG9wVmFsICogMTAwICkgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuICAgICAgaWYoIG1pbi5oZWlnaHQuYm90dG9tLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCApe1xuICAgICAgICBib3R0b21WYWwgPSAoIGJvdHRvbVZhbCAqIDEwMCApIC8gbWluLmhlaWdodC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKCBtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwgKTtcbiAgICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcblxuICAgICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKCBtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsICk7XG4gICAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcblxuICAgICAgX3AuYXV0b1dpZHRoID0gTWF0aC5tYXgoYmIudywgbWluLndpZHRoLnZhbCk7XG4gICAgICBwb3MueCA9ICgtIGRpZmZMZWZ0ICsgYmIueDEgKyBiYi54MiArIGRpZmZSaWdodCkgLyAyO1xuXG4gICAgICBfcC5hdXRvSGVpZ2h0ID0gTWF0aC5tYXgoYmIuaCwgbWluLmhlaWdodC52YWwpO1xuICAgICAgcG9zLnkgPSAoLSBkaWZmQm90dG9tICsgYmIueTEgKyBiYi55MiArIGRpZmZUb3ApIC8gMjtcblxuICAgICAgdXBkYXRlZC5wdXNoKCBwYXJlbnQgKTtcbiAgICB9XG5cbiAgICAvLyBnbyB1cCwgbGV2ZWwgYnkgbGV2ZWxcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuXG4gICAgICAvLyB1cGRhdGUgZWFjaCBwYXJlbnQgbm9kZSBpbiB0aGlzIGxldmVsXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgICB1cGRhdGUoIGVsZSApO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXh0IGxldmVsXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gY2hhbmdlZFxuICAgIHJldHVybiB0aGlzLnNwYXduKCB1cGRhdGVkICk7XG4gIH1cbn0pO1xuXG52YXIgbm9uaW5mID0gZnVuY3Rpb24oIHggKXtcbiAgaWYoIHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSApe1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24oIGIsIHgxLCB5MSwgeDIsIHkyICl7XG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICBpZiggeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwICl7IHJldHVybjsgfVxuXG4gIGIueDEgPSB4MSA8IGIueDEgPyB4MSA6IGIueDE7XG4gIGIueDIgPSB4MiA+IGIueDIgPyB4MiA6IGIueDI7XG4gIGIueTEgPSB5MSA8IGIueTEgPyB5MSA6IGIueTE7XG4gIGIueTIgPSB5MiA+IGIueTIgPyB5MiA6IGIueTI7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUJveCA9IGZ1bmN0aW9uKCBiLCBiMiApe1xuICByZXR1cm4gdXBkYXRlQm91bmRzKCBiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55MiApO1xufTtcblxudmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiggb2JqLCBmaWVsZCwgcHJlZml4ICl7XG4gIHJldHVybiB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIG9iaiwgZmllbGQsIHByZWZpeCApO1xufTtcblxudmFyIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyA9IGZ1bmN0aW9uKCBib3VuZHMsIGVsZSwgcHJlZml4LCBvcHRpb25zICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGhhbGZBclcgPSByc3R5bGUuYXJyb3dXaWR0aCAvIDI7XG4gIHZhciBhcnJvd1R5cGUgPSBlbGUucHN0eWxlKCBwcmVmaXggKyAnLWFycm93LXNoYXBlJyApLnZhbHVlO1xuICB2YXIgeDtcbiAgdmFyIHk7XG5cbiAgaWYoIGFycm93VHlwZSAhPT0gJ25vbmUnICl7XG4gICAgaWYoIHByZWZpeCA9PT0gJ3NvdXJjZScgKXtcbiAgICAgIHggPSByc3R5bGUuc3JjWDtcbiAgICAgIHkgPSByc3R5bGUuc3JjWTtcbiAgICB9IGVsc2UgaWYoIHByZWZpeCA9PT0gJ3RhcmdldCcgKXtcbiAgICAgIHggPSByc3R5bGUudGd0WDtcbiAgICAgIHkgPSByc3R5bGUudGd0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJzdHlsZS5taWRYO1xuICAgICAgeSA9IHJzdHlsZS5taWRZO1xuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCB4IC0gaGFsZkFyVywgeSAtIGhhbGZBclcsIHggKyBoYWxmQXJXLCB5ICsgaGFsZkFyVyApO1xuICB9XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24oIGJvdW5kcywgZWxlLCBwcmVmaXgsIG9wdGlvbnMgKXtcbiAgdmFyIHByZWZpeERhc2g7XG5cbiAgaWYoIHByZWZpeCApe1xuICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4RGFzaCA9ICcnO1xuICB9XG5cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCBwcmVmaXhEYXNoICsgJ2xhYmVsJyApLnN0clZhbHVlO1xuXG4gIGlmKCBsYWJlbCApe1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC1oYWxpZ24nICk7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKTtcbiAgICB2YXIgbGFiZWxXaWR0aCA9IHByZWZpeGVkUHJvcGVydHkoIHJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXggKTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KCByc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCApO1xuICAgIHZhciBsYWJlbFggPSBwcmVmaXhlZFByb3BlcnR5KCByc3R5bGUsICdsYWJlbFgnLCBwcmVmaXggKTtcbiAgICB2YXIgbGFiZWxZID0gcHJlZml4ZWRQcm9wZXJ0eSggcnN0eWxlLCAnbGFiZWxZJywgcHJlZml4ICk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKCBwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnICkucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScgKS5wZlZhbHVlO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZSggcHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyApO1xuICAgIHZhciBzaGFkb3dSID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LWJsdXInICkucGZWYWx1ZSAvIDI7XG4gICAgdmFyIHNoYWRvd1ggPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnICkucGZWYWx1ZTtcbiAgICB2YXIgc2hhZG93WSA9IGVsZS5wc3R5bGUoICd0ZXh0LXNoYWRvdy1vZmZzZXQteScgKS5wZlZhbHVlO1xuICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LW9wYWNpdHknICkudmFsdWU7XG4gICAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyApLnBmVmFsdWU7XG5cbiAgICB2YXIgbGggPSBsYWJlbEhlaWdodCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGggKyAyICogcGFkZGluZztcbiAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgaWYoIGlzRWRnZSApe1xuICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoKCBoYWxpZ24udmFsdWUgKXtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCggdmFsaWduLnZhbHVlICl7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0F1dG9yb3RhdGUgPSAoIGlzRWRnZSAmJiByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnICk7XG4gICAgdmFyIGlzUGZWYWx1ZSA9ICggcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDAgKTtcblxuICAgIGlmKCBpc0F1dG9yb3RhdGUgfHwgaXNQZlZhbHVlICl7XG4gICAgICB2YXIgdGhldGEgPSBpc0F1dG9yb3RhdGUgPyBwcmVmaXhlZFByb3BlcnR5KCBfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4ICkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24oIHgsIHkgKXtcbiAgICAgICAgeCA9IHggLSBsYWJlbFg7XG4gICAgICAgIHkgPSB5IC0gbGFiZWxZO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBsYWJlbFgsXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBsYWJlbFlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZSggbHgxLCBseTEgKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZSggbHgxLCBseTIgKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZSggbHgyLCBseTEgKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZSggbHgyLCBseTIgKTtcblxuICAgICAgbHgxID0gTWF0aC5taW4oIHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLnggKTtcbiAgICAgIGx4MiA9IE1hdGgubWF4KCBweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54ICk7XG4gICAgICBseTEgPSBNYXRoLm1pbiggcHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSApO1xuICAgICAgbHkyID0gTWF0aC5tYXgoIHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkgKTtcbiAgICB9XG5cbiAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KCBvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCApO1xuICAgIGx4MiArPSBtYXJnaW5YICsgTWF0aC5tYXgoIG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoICk7XG4gICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heCggb3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGggKTtcbiAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KCBvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCApO1xuXG4gICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5MiApO1xuXG4gICAgaWYoIG9wdGlvbnMuaW5jbHVkZVNoYWRvd3MgJiYgc2hhZG93T3BhY2l0eSA+IDAgKXtcbiAgICAgIGx4MSArPSAtIHNoYWRvd1IgKyBzaGFkb3dYO1xuICAgICAgbHgyICs9ICsgc2hhZG93UiArIHNoYWRvd1g7XG4gICAgICBseTEgKz0gLSBzaGFkb3dSICsgc2hhZG93WTtcbiAgICAgIGx5MiArPSArIHNoYWRvd1IgKyBzaGFkb3dZO1xuXG4gICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgbHgxLCBseTEsIGx4MiwgbHkyICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uKCBlbGUsIG9wdGlvbnMgKXtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3lfcC5zdHlsZUVuYWJsZWQ7XG5cbiAgdmFyIGJvdW5kcyA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeTE6IEluZmluaXR5LFxuICAgIHgyOiAtSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCAnZGlzcGxheScgKS52YWx1ZSA6ICdlbGVtZW50JztcbiAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MiwgeCwgeTtcbiAgdmFyIGRpc3BsYXllZCA9IGRpc3BsYXkgIT09ICdub25lJztcblxuICBpZiggZGlzcGxheWVkICl7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gMDtcbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdmVybGF5cyApe1xuICAgICAgb3ZlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCAnb3ZlcmxheS1vcGFjaXR5JyApLnZhbHVlO1xuXG4gICAgICBpZiggb3ZlcmxheU9wYWNpdHkgIT09IDAgKXtcbiAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCAnb3ZlcmxheS1wYWRkaW5nJyApLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgd0hhbGYgPSAwO1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgdyA9IGVsZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlO1xuICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICB9XG5cbiAgICBpZiggaXNOb2RlICYmIG9wdGlvbnMuaW5jbHVkZU5vZGVzICl7XG4gICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICB4ID0gcG9zLng7XG4gICAgICB5ID0gcG9zLnk7XG4gICAgICB2YXIgdyA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaGFsZlcgPSB3IC8gMjtcbiAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgaGFsZkggPSBoIC8gMjtcblxuICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICBleDEgPSB4IC0gaGFsZlcgLSBvdmVybGF5UGFkZGluZztcbiAgICAgIGV4MiA9IHggKyBoYWxmVyArIG92ZXJsYXlQYWRkaW5nO1xuICAgICAgZXkxID0geSAtIGhhbGZIIC0gb3ZlcmxheVBhZGRpbmc7XG4gICAgICBleTIgPSB5ICsgaGFsZkggKyBvdmVybGF5UGFkZGluZztcblxuICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5MiApO1xuXG4gICAgfSBlbHNlIGlmKCBpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgKXtcbiAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGUgfHwge307XG5cbiAgICAgIC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgZXgxID0gTWF0aC5taW4oIHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFggKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgoIHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFggKTtcbiAgICAgICAgZXkxID0gTWF0aC5taW4oIHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkgKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgoIHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkgKTtcblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcblxuICAgICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZWNpc2UgaGF5c3RhY2tzXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBlbGUucHN0eWxlKCAnY3VydmUtc3R5bGUnICkuc3RyVmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgIGV4MiA9IGhwdHNbMV0ueDtcbiAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgIGlmKCBleDEgPiBleDIgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGV5MTtcbiAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZiApO1xuXG4gICAgICAvLyBoYW5kbGUgcG9pbnRzIGFsb25nIGVkZ2VcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB0cyA9IHJzdHlsZS5iZXppZXJQdHMgfHwgcnN0eWxlLmxpbmVQdHMgfHwgW107XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgcHQgPSBwdHNbIGogXTtcblxuICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgZXkxID0gcHQueSAtIHdIYWxmO1xuICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgaWYoIHB0cy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICB2YXIgbjEgPSBfcC5zb3VyY2U7XG4gICAgICAgICAgdmFyIG4xX3AgPSBuMS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgbjFwb3MgPSBuMV9wLnBvc2l0aW9uO1xuXG4gICAgICAgICAgdmFyIG4yID0gX3AudGFyZ2V0O1xuICAgICAgICAgIHZhciBuMl9wID0gbjIuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIG4ycG9zID0gbjJfcC5wb3NpdGlvbjtcblxuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG5cbiAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcbiAgICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgICBleTIgKz0gd0hhbGY7XG5cbiAgICAgICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gLy8gZWRnZXNcblxuICAgIC8vIHNoYWRvdyBhbmQgb3ZlcmxheVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuXG4gICAgICBleDEgPSBib3VuZHMueDE7XG4gICAgICBleDIgPSBib3VuZHMueDI7XG4gICAgICBleTEgPSBib3VuZHMueTE7XG4gICAgICBleTIgPSBib3VuZHMueTI7XG5cbiAgICAgIGlmKCBvcHRpb25zLmluY2x1ZGVTaGFkb3dzICYmIGVsZS5wc3R5bGUoJ3NoYWRvdy1vcGFjaXR5JykudmFsdWUgPiAwICl7XG4gICAgICAgIHZhciByID0gZWxlLnBzdHlsZSgnc2hhZG93LWJsdXInKS5wZlZhbHVlIC8gMjtcbiAgICAgICAgdmFyIG94ID0gZWxlLnBzdHlsZSgnc2hhZG93LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgICAgdmFyIG95ID0gZWxlLnBzdHlsZSgnc2hhZG93LW9mZnNldC15JykucGZWYWx1ZTtcblxuICAgICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxIC0gciArIG94LCBleTEgLSByICsgb3ksIGV4MiArIHIgKyBveCwgZXkyICsgciArIG95ICk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEgLSBvdmVybGF5UGFkZGluZywgZXkxIC0gb3ZlcmxheVBhZGRpbmcsIGV4MiArIG92ZXJsYXlQYWRkaW5nLCBleTIgKyBvdmVybGF5UGFkZGluZyApO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlZGdlIGFycm93IHNpemVcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBpZiggc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzICYmIGlzRWRnZSApe1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KCBib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnLCBvcHRpb25zICk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coIGJvdW5kcywgZWxlLCAnbWlkLXRhcmdldCcsIG9wdGlvbnMgKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyggYm91bmRzLCBlbGUsICdzb3VyY2UnLCBvcHRpb25zICk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coIGJvdW5kcywgZWxlLCAndGFyZ2V0Jywgb3B0aW9ucyApO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzICl7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoIGJvdW5kcywgZWxlLCBudWxsLCBvcHRpb25zICk7XG5cbiAgICAgIGlmKCBpc0VkZ2UgKXtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKCBib3VuZHMsIGVsZSwgJ3NvdXJjZScsIG9wdGlvbnMgKTtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKCBib3VuZHMsIGVsZSwgJ3RhcmdldCcsIG9wdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuICB9IC8vIGlmIGRpc3BsYXllZFxuXG4gIGJvdW5kcy54MSA9IG5vbmluZiggYm91bmRzLngxICk7XG4gIGJvdW5kcy55MSA9IG5vbmluZiggYm91bmRzLnkxICk7XG4gIGJvdW5kcy54MiA9IG5vbmluZiggYm91bmRzLngyICk7XG4gIGJvdW5kcy55MiA9IG5vbmluZiggYm91bmRzLnkyICk7XG4gIGJvdW5kcy53ID0gbm9uaW5mKCBib3VuZHMueDIgLSBib3VuZHMueDEgKTtcbiAgYm91bmRzLmggPSBub25pbmYoIGJvdW5kcy55MiAtIGJvdW5kcy55MSApO1xuXG4gIC8vIGV4cGFuZCBib3VuZHMgYnkgMSBiZWNhdXNlIGFudGlhbGlhc2luZyBjYW4gaW5jcmVhc2UgdGhlIHZpc3VhbC9lZmZlY3RpdmUgc2l6ZSBieSAxIG9uIGFsbCBzaWRlc1xuICBpZiggYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQgKXtcbiAgICBtYXRoLmV4cGFuZEJvdW5kaW5nQm94KCBib3VuZHMsIDEgKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59O1xuXG52YXIgdGYgPSBmdW5jdGlvbiggdmFsICl7XG4gIGlmKCB2YWwgKXtcbiAgICByZXR1cm4gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnZic7XG4gIH1cbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiggb3B0cyApe1xuICB2YXIga2V5ID0gJyc7XG5cbiAga2V5ICs9IHRmKCBvcHRzLmluY3VkZU5vZGVzICk7XG4gIGtleSArPSB0Ziggb3B0cy5pbmNsdWRlRWRnZXMgKTtcbiAga2V5ICs9IHRmKCBvcHRzLmluY2x1ZGVMYWJlbHMgKTtcbiAga2V5ICs9IHRmKCBvcHRzLmluY2x1ZGVTaGFkb3dzICk7XG4gIGtleSArPSB0Ziggb3B0cy5pbmNsdWRlT3ZlcmxheXMgKTtcblxuICByZXR1cm4ga2V5O1xufTtcblxudmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uKCBlbGUsIG9wdHMgKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgYmI7XG4gIHZhciBoZWFkbGVzcyA9IGVsZS5jeSgpLmhlYWRsZXNzKCk7XG4gIHZhciBrZXkgPSBvcHRzID09PSBkZWZCYk9wdHMgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkoIG9wdHMgKTtcblxuICBpZiggIW9wdHMudXNlQ2FjaGUgfHwgaGVhZGxlc3MgfHwgIV9wLmJiQ2FjaGUgfHwgIV9wLmJiQ2FjaGVba2V5XSApe1xuICAgIGJiID0gYm91bmRpbmdCb3hJbXBsKCBlbGUsIG9wdHMgKTtcblxuICAgIGlmKCAhaGVhZGxlc3MgKXtcbiAgICAgIF9wLmJiQ2FjaGUgPSBfcC5iYkNhY2hlIHx8IHt9O1xuICAgICAgX3AuYmJDYWNoZVtrZXldID0gYmI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJiID0gX3AuYmJDYWNoZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIGJiO1xufTtcblxudmFyIGRlZkJiT3B0cyA9IHtcbiAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICBpbmNsdWRlRWRnZXM6IHRydWUsXG4gIGluY2x1ZGVMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVTaGFkb3dzOiB0cnVlLFxuICBpbmNsdWRlT3ZlcmxheXM6IHRydWUsXG4gIHVzZUNhY2hlOiB0cnVlXG59O1xuXG52YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KCBkZWZCYk9wdHMgKTtcblxuZWxlc2ZuLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCB1c2VDYWNoZSApe1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICBpZiggcmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkICl7XG4gICAgcmVuZGVyZXIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCB0aGlzLCB1c2VDYWNoZSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmaWxsZWRCYk9wdHMoIG9wdGlvbnMgKXtcbiAgcmV0dXJuIHtcbiAgICBpbmNsdWRlTm9kZXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlTm9kZXMsIGRlZkJiT3B0cy5pbmNsdWRlTm9kZXMgKSxcbiAgICBpbmNsdWRlRWRnZXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlRWRnZXMsIGRlZkJiT3B0cy5pbmNsdWRlRWRnZXMgKSxcbiAgICBpbmNsdWRlTGFiZWxzOiB1dGlsLmRlZmF1bHQoIG9wdGlvbnMuaW5jbHVkZUxhYmVscywgZGVmQmJPcHRzLmluY2x1ZGVMYWJlbHMgKSxcbiAgICBpbmNsdWRlU2hhZG93czogdXRpbC5kZWZhdWx0KCBvcHRpb25zLmluY2x1ZGVTaGFkb3dzLCBkZWZCYk9wdHMuaW5jbHVkZVNoYWRvd3MgKSxcbiAgICBpbmNsdWRlT3ZlcmxheXM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMsIGRlZkJiT3B0cy5pbmNsdWRlT3ZlcmxheXMgKSxcbiAgICB1c2VDYWNoZTogdXRpbC5kZWZhdWx0KCBvcHRpb25zLnVzZUNhY2hlLCBkZWZCYk9wdHMudXNlQ2FjaGUgKVxuICB9O1xufVxuXG5lbGVzZm4uYm91bmRpbmdCb3ggPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuICBpZiggdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5fcHJpdmF0ZS5iYkNhY2hlICYmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHRydWUpICl7XG4gICAgaWYoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgb3B0aW9ucyA9IGRlZkJiT3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZpbGxlZEJiT3B0cyggb3B0aW9ucyApO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZWRCb3VuZGluZ0JveEltcGwoIHRoaXNbMF0sIG9wdGlvbnMgKTtcbiAgfVxuXG4gIHZhciBib3VuZHMgPSB7XG4gICAgeDE6IEluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkyOiAtSW5maW5pdHlcbiAgfTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMoIG9wdGlvbnMgKTtcblxuICB2YXIgZWxlcyA9IHRoaXM7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggb3B0cy51c2VDYWNoZSApO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiggc3R5bGVFbmFibGVkICYmIGVsZS5pc0VkZ2UoKSAmJiBlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnN0clZhbHVlID09PSAnYmV6aWVyJyApe1xuICAgICAgZWxlLnBhcmFsbGVsRWRnZXMoKS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIG9wdHMudXNlQ2FjaGUgKTsgLy8gbi5iLiBlbGUucGFyYWxsZWxFZGdlcygpIHNpbmdsZSBpcyBjYWNoZWRcbiAgICB9XG5cbiAgICB1cGRhdGVCb3VuZHNGcm9tQm94KCBib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbCggZWxlLCBvcHRzICkgKTtcbiAgfVxuXG4gIGJvdW5kcy54MSA9IG5vbmluZiggYm91bmRzLngxICk7XG4gIGJvdW5kcy55MSA9IG5vbmluZiggYm91bmRzLnkxICk7XG4gIGJvdW5kcy54MiA9IG5vbmluZiggYm91bmRzLngyICk7XG4gIGJvdW5kcy55MiA9IG5vbmluZiggYm91bmRzLnkyICk7XG4gIGJvdW5kcy53ID0gbm9uaW5mKCBib3VuZHMueDIgLSBib3VuZHMueDEgKTtcbiAgYm91bmRzLmggPSBub25pbmYoIGJvdW5kcy55MiAtIGJvdW5kcy55MSApO1xuXG4gIHJldHVybiBib3VuZHM7XG59O1xuXG52YXIgZGVmaW5lRGltRm5zID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgb3B0cy51cHBlcmNhc2VOYW1lID0gdXRpbC5jYXBpdGFsaXplKCBvcHRzLm5hbWUgKTtcbiAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gdXRpbC5jYXBpdGFsaXplKCBvcHRzLm91dGVyTmFtZSApO1xuXG4gIGZuWyBvcHRzLm5hbWUgXSA9IGZ1bmN0aW9uIGRpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgICAgcmV0dXJuIF9wWyBvcHRzLmF1dG9OYW1lIF0gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkID0gZWxlLnBzdHlsZSggb3B0cy5uYW1lICk7XG5cbiAgICAgICAgc3dpdGNoKCBkLnN0clZhbHVlICl7XG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgcmV0dXJuIF9wLnJzdHlsZVsgb3B0cy5sYWJlbE5hbWUgXSB8fCAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZC5wZlZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm5bICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWUgXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICB2YXIgZGltID0gZWxlWyBvcHRzLm5hbWUgXSgpO1xuICAgICAgICB2YXIgYm9yZGVyID0gZWxlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlOyAvLyBuLmIuIDEvMiBlYWNoIHNpZGVcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBzdHlsZSggJ3BhZGRpbmcnICkucGZWYWx1ZTtcblxuICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsgJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgZCA9IGVsZVsgb3B0cy5uYW1lIF0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG5cbiAgZm5bICdyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBvZCA9IGVsZVsgb3B0cy5vdXRlck5hbWUgXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoIHtcbiAgbmFtZTogJ3dpZHRoJ1xufSApO1xuXG5kZWZpbmVEaW1GbnMoIHtcbiAgbmFtZTogJ2hlaWdodCdcbn0gKTtcblxuLy8gYWxpYXNlc1xuZm4ubW9kZWxQb3NpdGlvbiA9IGZuLnBvaW50ID0gZm4ucG9zaXRpb247XG5mbi5tb2RlbFBvc2l0aW9ucyA9IGZuLnBvaW50cyA9IGZuLnBvc2l0aW9ucztcbmZuLnJlbmRlcmVkUG9pbnQgPSBmbi5yZW5kZXJlZFBvc2l0aW9uO1xuZm4ucmVsYXRpdmVQb2ludCA9IGZuLnJlbGF0aXZlUG9zaXRpb247XG5mbi5ib3VuZGluZ2JveCA9IGZuLmJvdW5kaW5nQm94O1xuZm4ucmVuZGVyZWRCb3VuZGluZ2JveCA9IGZuLnJlbmRlcmVkQm91bmRpbmdCb3g7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG4vLyByZXByZXNlbnRzIGEgbm9kZSBvciBhbiBlZGdlXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBjeSwgcGFyYW1zLCByZXN0b3JlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVzdG9yZSA9IChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSA/IHRydWUgOiBmYWxzZSk7XG5cbiAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoIGN5ICkgKXtcbiAgICB1dGlsLmVycm9yKCAnQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwO1xuXG4gIC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuICBpZiggZ3JvdXAgPT0gbnVsbCApe1xuICAgIGlmKCBwYXJhbXMuZGF0YSAmJiBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCApe1xuICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgfVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgaWYoIGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnICl7XG4gICAgdXRpbC5lcnJvciggJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG5cbiAgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBzaW5nbGU6IHRydWUsIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSwgLy8gZGF0YSBvYmplY3RcbiAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHt9LCAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLFxuICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgIGdyb3VwOiBncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHJlbW92ZWQ6IHRydWUsIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIGFjdGl2ZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IHt9LCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSwgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9IC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gIH07XG5cbiAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgdGhpcy5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9XG5cbiAgaWYoIGlzLnN0cmluZyggcGFyYW1zLmNsYXNzZXMgKSApe1xuICAgIHZhciBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoIC9cXHMrLyApO1xuICAgIGZvciggdmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzWyBpIF07XG4gICAgICBpZiggIWNscyB8fCBjbHMgPT09ICcnICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHNlbGYuX3ByaXZhdGUuY2xhc3Nlc1sgY2xzIF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBwYXJhbXMuc3R5bGUgfHwgcGFyYW1zLmNzcyApe1xuICAgIGN5LnN0eWxlKCkuYXBwbHlCeXBhc3MoIHRoaXMsIHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzICk7XG4gIH1cblxuICBpZiggcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgb246IGRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gIG9uZTogZGVmaW5lLm9uKCB7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSApLFxuICBvbmNlOiBkZWZpbmUub24oIHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9mZjogZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKSwgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuXG4gIHJ0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGV4dHJhUGFyYW1zICl7IC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmKCB0aGlzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcblxuICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgIHRoaXMuY3koKS5ub3RpZnkoIHtcbiAgICAgIHR5cGU6IGV2ZW50LFxuICAgICAgZWxlczogdGhpc1xuICAgIH0gKTtcblxuICAgIHRoaXMudHJpZ2dlciggZXZlbnQsIGV4dHJhUGFyYW1zICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzOlxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBlbGVzZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoICcuLi9zZWxlY3RvcicgKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCBpLCBlbGVtZW50ICl7XG4gICAgICByZXR1cm4gZWxlbWVudC5pc05vZGUoKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCBpLCBlbGVtZW50ICl7XG4gICAgICByZXR1cm4gZWxlbWVudC5pc0VkZ2UoKTtcbiAgICB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGZpbHRlcjogZnVuY3Rpb24oIGZpbHRlciApe1xuICAgIGlmKCBmaWx0ZXIgPT09IHVuZGVmaW5lZCApeyAvLyBjaGVjayB0aGlzIGZpcnN0IGIvYyBpdCdzIHRoZSBtb3N0IGNvbW1vbi9wZXJmb3JtYW50IGNhc2VcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBmaWx0ZXIgKSB8fCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBmaWx0ZXIgKSApe1xuICAgICAgcmV0dXJuIFNlbGVjdG9yKCBmaWx0ZXIgKS5maWx0ZXIoIHRoaXMgKTtcbiAgICB9IGVsc2UgaWYoIGlzLmZuKCBmaWx0ZXIgKSApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuXG4gICAgICAgIGlmKCBmaWx0ZXIuYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcblxuICBub3Q6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmKCBpcy5zdHJpbmcoIHRvUmVtb3ZlICkgKXtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlciggdG9SZW1vdmUgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbIGkgXTtcblxuICAgICAgICB2YXIgcmVtb3ZlID0gdG9SZW1vdmUuX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXTtcbiAgICAgICAgaWYoICFyZW1vdmUgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGVtZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gICAgfVxuXG4gIH0sXG5cbiAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICByZXR1cm4gY3kubXV0YWJsZUVsZW1lbnRzKCkubm90KCB0aGlzICk7XG4gIH0sXG5cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmKCBpcy5zdHJpbmcoIG90aGVyICkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgIC8vIHZhciBpZHMxID0gY29sMVNtYWxsZXIgPyBjb2wxLl9wcml2YXRlLmlkcyA6IGNvbDIuX3ByaXZhdGUuaWRzO1xuICAgIHZhciBpZHMyID0gY29sMVNtYWxsZXIgPyBjb2wyLl9wcml2YXRlLmlkcyA6IGNvbDEuX3ByaXZhdGUuaWRzO1xuICAgIHZhciBjb2wgPSBjb2wxU21hbGxlciA/IGNvbDEgOiBjb2wyO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBpZCA9IGNvbFsgaSBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgZWxlID0gaWRzMlsgaWQgXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgfSxcblxuICB4b3I6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBvdGhlciApICl7XG4gICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIgKXtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFsgaSBdO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5fcHJpdmF0ZS5pZHNbIGlkIF07XG5cbiAgICAgICAgaWYoICFpbk90aGVyICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBhZGQoIGNvbDEsIGNvbDIgKTtcbiAgICBhZGQoIGNvbDIsIGNvbDEgKTtcblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cyApO1xuICB9LFxuXG4gIGRpZmY6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBvdGhlciApICl7XG4gICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSBbXTtcbiAgICB2YXIgcmlnaHQgPSBbXTtcbiAgICB2YXIgYm90aCA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyLCByZXRFbGVzICl7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbIGkgXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuX3ByaXZhdGUuaWRzWyBpZCBdO1xuXG4gICAgICAgIGlmKCBpbk90aGVyICl7XG4gICAgICAgICAgYm90aC5wdXNoKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgYWRkKCBjb2wxLCBjb2wyLCBsZWZ0ICk7XG4gICAgYWRkKCBjb2wyLCBjb2wxLCByaWdodCApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc3Bhd24oIGxlZnQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIHJpZ2h0OiB0aGlzLnNwYXduKCByaWdodCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgYm90aDogdGhpcy5zcGF3biggYm90aCwgeyB1bmlxdWU6IHRydWUgfSApXG4gICAgfTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggIXRvQWRkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggaXMuc3RyaW5nKCB0b0FkZCApICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICBlbGVtZW50cy5wdXNoKCB0aGlzWyBpIF0gKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG5cbiAgICAgIHZhciBhZGQgPSAhdGhpcy5fcHJpdmF0ZS5pZHNbIHRvQWRkWyBpIF0uaWQoKSBdO1xuICAgICAgaWYoIGFkZCApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCB0b0FkZFsgaSBdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gIH0sXG5cbiAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIG1lcmdlOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgaWYoICF0b0FkZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIHRvQWRkICYmIGlzLnN0cmluZyggdG9BZGQgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFsgaSBdO1xuICAgICAgdmFyIGlkID0gdG9BZGRFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBhZGQgPSAhX3AuaWRzWyBpZCBdO1xuXG4gICAgICBpZiggYWRkICl7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG5cbiAgICAgICAgdGhpc1sgaW5kZXggXSA9IHRvQWRkRWxlO1xuICAgICAgICBfcC5pZHNbIGlkIF0gPSB0b0FkZEVsZTtcbiAgICAgICAgX3AuaW5kZXhlc1sgaWQgXSA9IGluZGV4O1xuICAgICAgfSBlbHNlIHsgLy8gcmVwbGFjZVxuICAgICAgICB2YXIgaW5kZXggPSBfcC5pbmRleGVzWyBpZCBdO1xuXG4gICAgICAgIHRoaXNbIGluZGV4IF0gPSB0b0FkZEVsZTtcbiAgICAgICAgX3AuaWRzWyBpZCBdID0gdG9BZGRFbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGUgPSBlbGVbMF07XG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIHZhciBpID0gX3AuaW5kZXhlc1sgaWQgXTtcblxuICAgIGlmKCBpID09IG51bGwgKXtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlbGVcbiAgICB0aGlzWyBpIF0gPSB1bmRlZmluZWQ7XG4gICAgX3AuaWRzWyBpZCBdID0gdW5kZWZpbmVkO1xuICAgIF9wLmluZGV4ZXNbIGlkIF0gPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSApe1xuICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzWyBsYXN0RWxlSSBdO1xuICAgICAgdmFyIGxhc3RFbGVJZCA9IGxhc3RFbGUuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgICAgdGhpc1sgbGFzdEVsZUkgXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbIGkgXSA9IGxhc3RFbGU7XG4gICAgICBfcC5pbmRleGVzWyBsYXN0RWxlSWQgXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcbiAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2U6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggdG9SZW1vdmUgJiYgaXMuc3RyaW5nKCB0b1JlbW92ZSApICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXMudW5tZXJnZU9uZSggdG9SZW1vdmVbIGkgXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24oIG1hcEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IG1hcEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgYXJyLnB1c2goIHJldCApO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH0sXG5cbiAgcmVkdWNlOiBmdW5jdGlvbiggZm4sIGluaXRpYWxWYWx1ZSApe1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YWwgPSBmbiggdmFsLCBlbGVzW2ldLCBpLCBlbGVzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcblxuICBzdGRGaWx0ZXI6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIHZhciBmaWx0ZXJFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gZm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IGZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgaWYoIGluY2x1ZGUgKXtcbiAgICAgICAgZmlsdGVyRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZmlsdGVyRWxlcyApO1xuICB9LFxuXG4gIG1heDogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4RWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IHZhbEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgaWYoIHZhbCA+IG1heCApe1xuICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1heCxcbiAgICAgIGVsZTogbWF4RWxlXG4gICAgfTtcbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IHZhbEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgaWYoIHZhbCA8IG1pbiApe1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IGVsZXNmbjtcbmZuWyAndScgXSA9IGZuWyAnfCcgXSA9IGZuWyAnKycgXSA9IGZuLnVuaW9uID0gZm4ub3IgPSBmbi5hZGQ7XG5mblsgJ1xcXFwnIF0gPSBmblsgJyEnIF0gPSBmblsgJy0nIF0gPSBmbi5kaWZmZXJlbmNlID0gZm4ucmVsYXRpdmVDb21wbGVtZW50ID0gZm4uc3VidHJhY3QgPSBmbi5ub3Q7XG5mblsgJ24nIF0gPSBmblsgJyYnIF0gPSBmblsgJy4nIF0gPSBmbi5hbmQgPSBmbi5pbnRlcnNlY3Rpb24gPSBmbi5pbnRlcnNlY3Q7XG5mblsgJ14nIF0gPSBmblsgJygrKScgXSA9IGZuWyAnKC0pJyBdID0gZm4uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuLnN5bWRpZmYgPSBmbi54b3I7XG5mbi5mbkZpbHRlciA9IGZuLmZpbHRlckZuID0gZm4uc3RkRmlsdGVyO1xuZm4uY29tcGxlbWVudCA9IGZuLmFic2NvbXAgPSBmbi5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgaXNOb2RlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gIH0sXG5cbiAgaXNFZGdlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gIH0sXG5cbiAgaXNMb29wOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSA9PT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICB9LFxuXG4gIGlzU2ltcGxlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSAhPT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICB9LFxuXG4gIGdyb3VwOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICcuL2VsZW1lbnQnICk7XG5cbi8vIGZhY3RvcnkgZm9yIGdlbmVyYXRpbmcgZWRnZSBpZHMgd2hlbiBubyBpZCBpcyBzcGVjaWZpZWQgZm9yIGEgbmV3IGVsZW1lbnRcbnZhciBpZEZhY3RvcnkgPSB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbiggY3ksIGVsZW1lbnQsIHRyeVRoaXNJZCApe1xuICAgIHZhciBpZCA9IHRyeVRoaXNJZCAhPSBudWxsID8gdHJ5VGhpc0lkIDogdXRpbC51dWlkKCk7XG5cbiAgICB3aGlsZSggY3kuaGFzRWxlbWVudFdpdGhJZCggaWQgKSApe1xuICAgICAgaWQgPSB1dGlsLnV1aWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cbn07XG5cbi8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCBjeSwgZWxlbWVudHMsIG9wdGlvbnMgKXtcbiAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoIGN5ICkgKXtcbiAgICB1dGlsLmVycm9yKCAnQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWRzID0ge307XG4gIHZhciBpbmRleGVzID0ge307XG4gIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcblxuICBpZiggIWVsZW1lbnRzICl7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgfSBlbHNlIGlmKCBlbGVtZW50cy5sZW5ndGggPiAwICYmIGlzLnBsYWluT2JqZWN0KCBlbGVtZW50c1swXSApICYmICFpcy5lbGVtZW50KCBlbGVtZW50c1swXSApICl7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgdmFyIGVsZXMgPSBbXTtcbiAgICB2YXIgZWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBqc29uID0gZWxlbWVudHNbIGkgXTtcblxuICAgICAgaWYoIGpzb24uZGF0YSA9PSBudWxsICl7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgIGlmKCBkYXRhLmlkID09IG51bGwgKXtcbiAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGpzb24gKTtcbiAgICAgIH0gZWxzZSBpZiggY3kuaGFzRWxlbWVudFdpdGhJZCggZGF0YS5pZCApIHx8IGVsZXNJZHNbIGRhdGEuaWQgXSApe1xuICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IG5ldyBFbGVtZW50KCBjeSwganNvbiwgZmFsc2UgKTtcbiAgICAgIGVsZXMucHVzaCggZWxlICk7XG4gICAgICBlbGVzSWRzWyBkYXRhLmlkIF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGVsZW1lbnRzID0gZWxlcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbIGkgXTtcbiAgICBpZiggIWVsZW1lbnQgKXsgIGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBpZiggIW9wdGlvbnMgfHwgKG9wdGlvbnMudW5pcXVlICYmICFpZHNbIGlkIF0gKSApe1xuICAgICAgaWRzWyBpZCBdID0gZWxlbWVudDtcbiAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgdGhpc1sgdGhpcy5sZW5ndGggXSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGlkczogaWRzLFxuICAgIGluZGV4ZXM6IGluZGV4ZXNcbiAgfTtcblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmKCBjcmVhdGVkRWxlbWVudHMgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdjb2xsZWN0aW9uJztcbn07XG5cbmVsZXNmbi5zcGF3biA9IGZ1bmN0aW9uKCBjeSwgZWxlcywgb3B0cyApe1xuICBpZiggIWlzLmNvcmUoIGN5ICkgKXsgLy8gY3kgaXMgb3B0aW9uYWxcbiAgICBvcHRzID0gZWxlcztcbiAgICBlbGVzID0gY3k7XG4gICAgY3kgPSB0aGlzLmN5KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oIGN5LCBlbGVzLCBvcHRzICk7XG59O1xuXG5lbGVzZm4uc3Bhd25TZWxmID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuc3Bhd24oIHRoaXMgKTtcbn07XG5cbmVsZXNmbi5jeSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xufTtcblxuZWxlc2ZuLmVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpc1swXTtcbn07XG5cbmVsZXNmbi5jb2xsZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgaWYoIGlzLmNvbGxlY3Rpb24oIHRoaXMgKSApe1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBbIHRoaXMgXSApO1xuICB9XG59O1xuXG5lbGVzZm4udW5pcXVlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG59O1xuXG5lbGVzZm4uaGFzRWxlbWVudFdpdGhJZCA9IGZ1bmN0aW9uKCBpZCApe1xuICByZXR1cm4gISF0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcbn07XG5cbmVsZXNmbi5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uKCBpZCApe1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlID0gdGhpcy5fcHJpdmF0ZS5pZHNbIGlkIF07XG5cbiAgcmV0dXJuIGVsZSA/IGVsZSA6IG5ldyBDb2xsZWN0aW9uKCBjeSApOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbi5wb29sSW5kZXggPSBmdW5jdGlvbigpe1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICB2YXIgaWQgPSB0aGlzLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgcmV0dXJuIGVsZXMuX3ByaXZhdGUuaW5kZXhlc1sgaWQgXTtcbn07XG5cbmVsZXNmbi5qc29uID0gZnVuY3Rpb24oIG9iaiApe1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiggZWxlID09IG51bGwgJiYgb2JqICl7IHJldHVybiB0aGlzOyB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cbiAgaWYoIGVsZSA9PSBudWxsICl7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmKCBpcy5wbGFpbk9iamVjdCggb2JqICkgKXsgLy8gc2V0XG5cbiAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICBpZiggb2JqLmRhdGEgKXtcbiAgICAgIGVsZS5kYXRhKCBvYmouZGF0YSApO1xuICAgIH1cblxuICAgIGlmKCBvYmoucG9zaXRpb24gKXtcbiAgICAgIGVsZS5wb3NpdGlvbiggb2JqLnBvc2l0aW9uICk7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG4gICAgdmFyIGNoZWNrU3dpdGNoID0gZnVuY3Rpb24oIGssIHRydWVGbk5hbWUsIGZhbHNlRm5OYW1lICl7XG4gICAgICB2YXIgb2JqX2sgPSBvYmpbIGsgXTtcblxuICAgICAgaWYoIG9ial9rICE9IG51bGwgJiYgb2JqX2sgIT09IHBbIGsgXSApe1xuICAgICAgICBpZiggb2JqX2sgKXtcbiAgICAgICAgICBlbGVbIHRydWVGbk5hbWUgXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVsgZmFsc2VGbk5hbWUgXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrU3dpdGNoKCAncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0JyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdzZWxlY3RhYmxlJywgJ3NlbGVjdGlmeScsICd1bnNlbGVjdGlmeScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknICk7XG5cbiAgICBpZiggb2JqLmNsYXNzZXMgIT0gbnVsbCApe1xuICAgICAgZWxlLmNsYXNzZXMoIG9iai5jbGFzc2VzICk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG5cbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IHV0aWwuY29weSggcC5kYXRhICksXG4gICAgICBwb3NpdGlvbjogdXRpbC5jb3B5KCBwLnBvc2l0aW9uICksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcblxuICAgIGpzb24uY2xhc3NlcyA9IE9iamVjdC5rZXlzKCBwLmNsYXNzZXMgKS5maWx0ZXIoZnVuY3Rpb24oIGNscyApe1xuICAgICAgcmV0dXJuIHAuY2xhc3Nlc1tjbHNdO1xuICAgIH0pLmpvaW4oJyAnKTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuXG5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcblxuICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgfVxuXG4gIHJldHVybiBqc29ucztcbn07XG5cbmVsZXNmbi5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGVsZXNBcnIgPSBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICB2YXIgY2xvbmUgPSBuZXcgRWxlbWVudCggY3ksIGpzb24sIGZhbHNlICk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaCggY2xvbmUgKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbn07XG5lbGVzZm4uY29weSA9IGVsZXNmbi5jbG9uZTtcblxuZWxlc2ZuLnJlc3RvcmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG5cbiAgaWYoIG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgKXtcbiAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gIH1cblxuICAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBlbGVtZW50cztcbiAgZm9yKCB2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgIHZhciBlbGUgPSBzZWxmWyBpIF07XG5cbiAgICBpZiggIWVsZS5yZW1vdmVkKCkgKXtcbiAgICAgIC8vIGRvbid0IG5lZWQgdG8gaGFuZGxlIHRoaXMgZWxlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICB9IGVsc2UgeyAvLyBwdXQgdG8gZW5kIG9mIGFycmF5IGlmIGVkZ2VcbiAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KCBlZGdlcyApO1xuXG4gIHZhciBpO1xuICB2YXIgcmVtb3ZlRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24oKXtcbiAgICBlbGVtZW50cy5zcGxpY2UoIGksIDEgKTtcbiAgICBpLS07XG4gIH07XG5cbiAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICBmb3IoIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlbWVudHNbIGkgXTtcblxuICAgIHZhciBfcHJpdmF0ZSA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZGF0YSA9IF9wcml2YXRlLmRhdGE7XG5cbiAgICAvLyB0aGUgdHJhdmVyc2FsIGNhY2hlIHNob3VsZCBzdGFydCBmcmVzaCB3aGVuIGVsZSBpcyBhZGRlZFxuICAgIF9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcblxuICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICBpZiggZGF0YS5pZCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwgZWxlICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggZGF0YS5pZCApICl7XG4gICAgICBkYXRhLmlkID0gJycgKyBkYXRhLmlkOyAvLyBub3cgaXQncyBhIHN0cmluZ1xuXG4gICAgfSBlbHNlIGlmKCBpcy5lbXB0eVN0cmluZyggZGF0YS5pZCApIHx8ICFpcy5zdHJpbmcoIGRhdGEuaWQgKSApe1xuICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIGRhdGEuaWQgKyAnYCcgKTtcblxuICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG4gICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiggY3kuaGFzRWxlbWVudFdpdGhJZCggZGF0YS5pZCApICl7XG4gICAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIGRhdGEuaWQgKyAnYCcgKTtcblxuICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gZGF0YS5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApeyAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IGVsZTtcbiAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICBpZiggcG9zLnggPT0gbnVsbCApe1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3MueSA9PSBudWxsICl7XG4gICAgICAgIHBvcy55ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgZmllbGRzID0gWyAnc291cmNlJywgJ3RhcmdldCcgXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrICl7XG5cbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzWyBqIF07XG4gICAgICAgIHZhciB2YWwgPSBkYXRhWyBmaWVsZCBdO1xuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoIHZhbCApICl7XG4gICAgICAgICAgdmFsID0gZGF0YVsgZmllbGQgXSA9ICcnICsgZGF0YVsgZmllbGQgXTsgLy8gbm93IHN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycgKXtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCApO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmKCAhY3kuaGFzRWxlbWVudFdpdGhJZCggdmFsICkgKXtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCBub25leGlzdGFudCAnICsgZmllbGQgKyAnIGAnICsgdmFsICsgJ2AnICk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBiYWRTb3VyY2VPclRhcmdldCApeyByZW1vdmVGcm9tRWxlbWVudHMoKTsgY29udGludWU7IH0gLy8gY2FuJ3QgY3JlYXRlIHRoaXNcblxuICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLnNvdXJjZSApO1xuICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLnRhcmdldCApO1xuXG4gICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgdGd0Ll9wcml2YXRlLmVkZ2VzLnB1c2goIGVkZ2UgKTtcblxuICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICB9IC8vIGlmIGlzIGVkZ2VcblxuICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG4gICAgX3ByaXZhdGUuaWRzID0ge307XG4gICAgX3ByaXZhdGUuaWRzWyBpZCBdID0gZWxlO1xuICAgIF9wcml2YXRlLmluZGV4ZXMgPSB7fTtcbiAgICBfcHJpdmF0ZS5pbmRleGVzWyBpZCBdID0gZWxlO1xuXG4gICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgIGN5LmFkZFRvUG9vbCggZWxlICk7XG4gIH0gLy8gZm9yIGVhY2ggZWxlbWVudFxuXG4gIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7IC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICB2YXIgZGF0YSA9IG5vZGUuX3ByaXZhdGUuZGF0YTtcblxuICAgIGlmKCBpcy5udW1iZXIoIGRhdGEucGFyZW50ICkgKXsgLy8gdGhlbiBhdXRvbWFrZSBzdHJpbmdcbiAgICAgIGRhdGEucGFyZW50ID0gJycgKyBkYXRhLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50SWQgPSBkYXRhLnBhcmVudDtcblxuICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgaWYoIHNwZWNpZmllZFBhcmVudCApe1xuICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApO1xuXG4gICAgICBpZiggcGFyZW50LmVtcHR5KCkgKXtcbiAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUoICFhbmNlc3Rvci5lbXB0eSgpICl7XG4gICAgICAgICAgaWYoIG5vZGUuc2FtZSggYW5jZXN0b3IgKSApe1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhc2VsZkFzUGFyZW50ICl7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTtcblxuICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgIGN5X3AuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZWxzZVxuICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuICB9IC8vIGZvciBlYWNoIG5vZGVcblxuICBpZiggZWxlbWVudHMubGVuZ3RoID4gMCApe1xuICAgIHZhciByZXN0b3JlZCA9IG5ldyBDb2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVzdG9yZWQubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSByZXN0b3JlZFtpXTtcblxuICAgICAgaWYoIGVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgICB2YXIgcGVkZ2VzID0gZWxlLnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHBlZGdlc1tqXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIHRoZSBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIGVsZS5zb3VyY2UoKVswXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gICAgICBlbGUudGFyZ2V0KClbMF0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB0b1VwZGF0ZVN0eWxlO1xuXG4gICAgaWYoIGN5X3AuaGFzQ29tcG91bmROb2RlcyApe1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkLmFkZCggcmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSApLmFkZCggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkO1xuICAgIH1cblxuICAgIHRvVXBkYXRlU3R5bGUudXBkYXRlU3R5bGUoIG5vdGlmeVJlbmRlcmVyICk7XG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHJlc3RvcmVkLnJ0cmlnZ2VyKCAnYWRkJyApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlZC50cmlnZ2VyKCAnYWRkJyApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1vdmVkID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyggbm9kZSApe1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgYWRkKCBlZGdlc1sgaSBdICk7XG4gICAgfVxuICB9XG5cblxuICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICBmdW5jdGlvbiBhZGRDaGlsZHJlbiggbm9kZSApe1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICBhZGQoIGNoaWxkcmVuWyBpIF0gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGQoIGVsZSApe1xuICAgIHZhciBhbHJlYWR5QWRkZWQgPSAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdO1xuICAgIGlmKCBhbHJlYWR5QWRkZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaCggZWxlICk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoIGVsZSApO1xuICAgICAgYWRkQ2hpbGRyZW4oIGVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdCggZWxlICk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgLy8gKG1heSBiZSByZW1vdmluZyBtb3JlIHRoYW4gc3BlY2lmaWVkIGR1ZSB0byBjb25uZWN0ZWQgZWRnZXMgZXRjKVxuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICB2YXIgZWxlID0gc2VsZlsgaSBdO1xuXG4gICAgYWRkKCBlbGUgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYoIG5vZGUsIGVkZ2UgKXtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIGNvbm5lY3RlZEVkZ2VzLCBlZGdlICk7XG5cbiAgICAvLyByZW1vdmluZyBhbiBlZGdlcyBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciBpdHMgbm9kZXNcbiAgICBub2RlLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmcyggZWRnZSApe1xuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgIHZhciBwZWRnZXMgPSBlZGdlLnBhcmFsbGVsRWRnZXMoKTtcbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgcGVkZ2VzW2pdLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYoIHBhcmVudCwgZWxlICl7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG5cbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheSggY2hpbGRyZW4sIGVsZSApO1xuXG4gICAgaWYoICFhbHRlcmVkUGFyZW50cy5pZHNbIHBpZCBdICl7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbIHBpZCBdID0gdHJ1ZTtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLnB1c2goIHBhcmVudCApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICBjeS5yZW1vdmVGcm9tUG9vbCggZWxlc1RvUmVtb3ZlICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1RvUmVtb3ZlWyBpIF07XG5cbiAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICBlbGUuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG5cbiAgICAvLyBhZGQgdG8gbGlzdCBvZiByZW1vdmVkIGVsZW1lbnRzXG4gICAgcmVtb3ZlZC5wdXNoKCBlbGUgKTtcblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhpcyBlZGdlIGluIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIHZhciBzcmMgPSBlbGUuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpWzBdO1xuXG4gICAgICByZW1vdmVFZGdlUmVmKCBzcmMsIGVsZSApO1xuICAgICAgcmVtb3ZlRWRnZVJlZiggdGd0LCBlbGUgKTtcbiAgICAgIHJlbW92ZVBhcmFsbGVsUmVmcyggZWxlICk7XG5cbiAgICB9IGVsc2UgeyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKTtcblxuICAgICAgaWYoIHBhcmVudC5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYoIHBhcmVudCwgZWxlICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaCBvciBub3RcbiAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNTdGlsbEluc2lkZVsgaSBdO1xuXG4gICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggdGhpcy5jeSgpLCByZW1vdmVkICk7XG4gIGlmKCByZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCApe1xuICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB0aGlzLmN5KCkubm90aWZ5KCB7XG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICBlbGVzOiByZW1vdmVkRWxlbWVudHNcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZW1vdmVkRWxlbWVudHMudHJpZ2dlciggJ3JlbW92ZScgKTtcbiAgfVxuXG4gIC8vIHRoZSBwYXJlbnRzIHdobyB3ZXJlIG1vZGlmaWVkIGJ5IHRoZSByZW1vdmFsIG5lZWQgdGhlaXIgc3R5bGUgdXBkYXRlZFxuICBmb3IoIHZhciBpID0gMDsgaSA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGFsdGVyZWRQYXJlbnRzWyBpIF07XG5cbiAgICBpZiggIWVsZS5yZW1vdmVkKCkgKXtcbiAgICAgIGVsZS51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggY3ksIHJlbW92ZWQgKTtcbn07XG5cbmVsZXNmbi5tb3ZlID0gZnVuY3Rpb24oIHN0cnVjdCApe1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gIGlmKCBzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkICl7XG4gICAgdmFyIHNyY0lkID0gc3RydWN0LnNvdXJjZTtcbiAgICB2YXIgdGd0SWQgPSBzdHJ1Y3QudGFyZ2V0O1xuICAgIHZhciBzcmNFeGlzdHMgPSBjeS5oYXNFbGVtZW50V2l0aElkKCBzcmNJZCApO1xuICAgIHZhciB0Z3RFeGlzdHMgPSBjeS5oYXNFbGVtZW50V2l0aElkKCB0Z3RJZCApO1xuXG4gICAgaWYoIHNyY0V4aXN0cyB8fCB0Z3RFeGlzdHMgKXtcbiAgICAgIHZhciBqc29ucyA9IHRoaXMuanNvbnMoKTtcblxuICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICAgIGlmKCBzcmNFeGlzdHMgKXsganNvbi5kYXRhLnNvdXJjZSA9IHNyY0lkOyB9XG5cbiAgICAgICAgICBpZiggdGd0RXhpc3RzICl7IGpzb24uZGF0YS50YXJnZXQgPSB0Z3RJZDsgfVxuXG4gICAgICAgICAganNvbi5zY3JhdGNoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQgKXsgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5oYXNFbGVtZW50V2l0aElkKCBwYXJlbnRJZCApO1xuXG4gICAgaWYoIHBhcmVudEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuICAgICAgdmFyIGRlc2NzID0gdGhpcy5kZXNjZW5kYW50cygpO1xuICAgICAgdmFyIGRlc2NzRXRjSnNvbnMgPSBkZXNjcy51bmlvbiggZGVzY3MudW5pb24oIHRoaXMgKS5jb25uZWN0ZWRFZGdlcygpICkuanNvbnMoKTtcblxuICAgICAgdGhpcy5yZW1vdmUoKTsgLy8gTkI6IGFsc28gcmVtb3ZlcyBkZXNjZW5kYW50cyBhbmQgdGhlaXIgY29ubmVjdGVkIGVkZ2VzXG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgICBqc29uLmRhdGEucGFyZW50ID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcblxuICAgICAgICAgIGpzb24uc2NyYXRjaCA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjeS5hZGQoIGpzb25zLmNvbmNhdCggZGVzY3NFdGNKc29ucyApICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGlmIG5vdGhpbmcgZG9uZVxufTtcblxuW1xuICByZXF1aXJlKCAnLi9hbGdvcml0aG1zJyApLFxuICByZXF1aXJlKCAnLi9hbmltYXRpb24nICksXG4gIHJlcXVpcmUoICcuL2NsYXNzJyApLFxuICByZXF1aXJlKCAnLi9jb21wYXJhdG9ycycgKSxcbiAgcmVxdWlyZSggJy4vY29tcG91bmRzJyApLFxuICByZXF1aXJlKCAnLi9kYXRhJyApLFxuICByZXF1aXJlKCAnLi9kZWdyZWUnICksXG4gIHJlcXVpcmUoICcuL2RpbWVuc2lvbnMnICksXG4gIHJlcXVpcmUoICcuL2V2ZW50cycgKSxcbiAgcmVxdWlyZSggJy4vZmlsdGVyJyApLFxuICByZXF1aXJlKCAnLi9ncm91cCcgKSxcbiAgcmVxdWlyZSggJy4vaW5kZXgnICksXG4gIHJlcXVpcmUoICcuL2l0ZXJhdGlvbicgKSxcbiAgcmVxdWlyZSggJy4vbGF5b3V0JyApLFxuICByZXF1aXJlKCAnLi9zdHlsZScgKSxcbiAgcmVxdWlyZSggJy4vc3dpdGNoLWZ1bmN0aW9ucycgKSxcbiAgcmVxdWlyZSggJy4vdHJhdmVyc2luZycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgekluZGV4U29ydCA9IHJlcXVpcmUoICcuL3pzb3J0JyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgZWFjaDogZnVuY3Rpb24oIGZuICl7XG4gICAgaWYoIGlzLmZuKCBmbiApICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KCBlbGUsIFsgaSwgZWxlIF0gKTtcblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIGlmKCBpcy5mbiggZm4gKSApe1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIHRoaXMgXSApIDogZm4oIGVsZSwgaSwgdGhpcyApO1xuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbigpe1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICBhcnJheS5wdXNoKCB0aGlzWyBpIF0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG5cbiAgc2xpY2U6IGZ1bmN0aW9uKCBzdGFydCwgZW5kICl7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiggZW5kID09IG51bGwgKXtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cblxuICAgIGlmKCBzdGFydCA9PSBudWxsICl7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYoIHN0YXJ0IDwgMCApe1xuICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgIH1cblxuICAgIGlmKCBlbmQgPCAwICl7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrICl7XG4gICAgICBhcnJheS5wdXNoKCB0aGlzWyBpIF0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggYXJyYXkgKTtcbiAgfSxcblxuICBzaXplOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfSxcblxuICBlcTogZnVuY3Rpb24oIGkgKXtcbiAgICByZXR1cm4gdGhpc1sgaSBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBmaXJzdDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpc1swXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgbGFzdDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpc1sgdGhpcy5sZW5ndGggLSAxIF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICBub25lbXB0eTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgfSxcblxuICBzb3J0OiBmdW5jdGlvbiggc29ydEZuICl7XG4gICAgaWYoICFpcy5mbiggc29ydEZuICkgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KCBzb3J0Rm4gKTtcblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBzb3J0ZWQgKTtcbiAgfSxcblxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuc29ydCggekluZGV4U29ydCApO1xuICB9LFxuXG4gIHpEZXB0aDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiggIWVsZSApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAvLyB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICBpZiggZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgIHZhciBkZXB0aCA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuXG4gICAgICBpZiggIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIDE7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1heCggc3JjRGVwdGgsIHRndERlcHRoLCAwICk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gdXNpbmcgc3RhbmRhcmQgbGF5b3V0IG9wdGlvbnMsIGFwcGx5IHBvc2l0aW9uIGZ1bmN0aW9uICh3LyBvciB3L28gYW5pbWF0aW9uKVxuICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBsYXlvdXQsIG9wdGlvbnMsIGZuICl7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0gKTtcblxuICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG5cbiAgICB2YXIgY2FsY3VsYXRlU3BhY2luZyA9IGZ1bmN0aW9uKCBzcGFjaW5nLCBub2Rlc0JiLCBwb3MgKXtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0geyAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgIHZhciBub2Rlc0JiID0gbm9kZXMuYm91bmRpbmdCb3goKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXG4gICAgICAgIHZhciBuZXdQb3MgPSBmbi5jYWxsKCBub2RlLCBpLCBub2RlICk7XG4gICAgICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYoICFpcy5udW1iZXIoIHBvcy54ICkgfHwgIWlzLm51bWJlciggcG9zLnkgKSApe1xuICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oIHsgeDogMCwgeTogMCB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDEpe1xuICAgICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMob3B0aW9ucy5zcGFjaW5nRmFjdG9yKTtcbiAgICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIG5vZGVzQmIsIG5ld1Bvcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pID0gbm9kZS5hbmltYXRpb24oIHtcbiAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goIGFuaSApO1xuXG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvblN0ZXA7XG4gICAgICBjeS5vbiggJ3N0ZXAuKicsICggb25TdGVwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG4gICAgICB9KSApO1xuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24oKXtcbiAgICAgICAgY3kub2ZmKCdzdGVwLionLCBvblN0ZXApO1xuICAgICAgfSk7XG5cbiAgICAgIGxheW91dC5vbmUoICdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkgKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0gKTtcblxuICAgICAgUHJvbWlzZS5hbGwoIGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiggYW5pICl7XG4gICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgfSkgKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgIGN5Lm9mZignc3RlcC4qJywgb25TdGVwKTtcblxuICAgICAgICBpZiggb3B0aW9ucy56b29tICE9IG51bGwgKXtcbiAgICAgICAgICBjeS56b29tKCBvcHRpb25zLnpvb20gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLnBhbiApe1xuICAgICAgICAgIGN5LnBhbiggb3B0aW9ucy5wYW4gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoICdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wICk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBvcHRpb25zLnNwYWNpbmdGYWN0b3IgJiYgb3B0aW9ucy5zcGFjaW5nRmFjdG9yICE9PSAxICl7XG4gICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMoIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciApO1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgICAgICAgdmFyIHBvcyA9IGZuKCBpLCBub2RlICk7XG4gICAgICAgICAgdmFyIG5vZGVzQmIgPSBub2Rlcy5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVTcGFjaW5nKCBzcGFjaW5nLCBub2Rlc0JiLCBwb3MgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIGZuICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICBjeS5maXQoIG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICBjeS56b29tKCBvcHRpb25zLnpvb20gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgIGN5LnBhbiggb3B0aW9ucy5wYW4gKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gICAgICBsYXlvdXQub25lKCAnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCApO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgbGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGN5LmxheW91dCggdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSApICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYWtlTGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9ICkgKTtcbiAgfVxuXG59KTtcblxuLy8gYWxpYXNlczpcbmVsZXNmbi5jcmVhdGVMYXlvdXQgPSBlbGVzZm4ubWFrZUxheW91dDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICB1cGRhdGVTdHlsZTogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIGlmKCBjeS5fcHJpdmF0ZS5iYXRjaGluZ1N0eWxlICl7XG4gICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcblxuICAgICAgYkVsZXMubWVyZ2UoIHRoaXMgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcztcblxuICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGlmKCBoYXNDb21wb3VuZHMgKXsgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UoIHRoaXMuZGVzY2VuZGFudHMoKSApLm1lcmdlKCB0aGlzLnBhcmVudHMoKSApO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGx5KCB1cGRhdGVkRWxlcyApO1xuXG4gICAgaWYoIGhhc0NvbXBvdW5kcyApe1xuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB1cGRhdGVkRWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgICAvLyBkaXNhYmxlIGZvciBwZXJmb3JtYW5jZSBmb3Igbm93XG4gICAgICAvLyAoYXMgdXBkYXRlZENvbXBvdW5kcyB3b3VsZCBiZSBhIHN1YnNldCBvZiB1cGRhdGVkRWxlcyBheXdheSBiL2Mgb2Ygc2VsZWN0b3JzIGNoZWNrKVxuICAgICAgLy8gaWYoIHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCApe1xuICAgICAgLy8gICB1cGRhdGVkRWxlcy5tZXJnZSggdXBkYXRlZENvbXBvdW5kcyApO1xuICAgICAgLy8gfVxuICAgIH1cblxuICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdXBkYXRlZEVsZXMucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkRWxlcy50cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBqdXN0IHVwZGF0ZSB0aGUgbWFwcGVycyBpbiB0aGUgZWxlbWVudHMnIHN0eWxlczsgY2hlYXBlciB0aGFuIGVsZXMudXBkYXRlU3R5bGUoKVxuICB1cGRhdGVNYXBwZXJzOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgc3R5bGUudXBkYXRlTWFwcGVycyggdGhpcyApO1xuXG4gICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Ob3RpZnkudHJpZ2dlciggJ3N0eWxlJyApOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGdldCB0aGUgaW50ZXJuYWwgcGFyc2VkIHN0eWxlIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICBwYXJzZWRTdHlsZTogZnVuY3Rpb24oIHByb3BlcnR5ICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfVxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZVsgcHJvcGVydHkgXSB8fCBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eSggcHJvcGVydHkgKTtcbiAgICB9XG4gIH0sXG5cbiAgbnVtZXJpY1N0eWxlOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCAhZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZSggcHJvcGVydHkgKTtcblxuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgbnVtZXJpY1N0eWxlVW5pdHM6IGZ1bmN0aW9uKCBwcm9wZXJ0eSApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoICFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH1cblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCBwcm9wZXJ0eSApLnVuaXRzO1xuICAgIH1cbiAgfSxcblxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gIHJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uKCBwcm9wZXJ0eSApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoIGVsZSwgcHJvcGVydHkgKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gIHN0eWxlOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KCBuYW1lICkgKXsgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyggbmFtZSApICl7XG5cbiAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBzdHlsZVxuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBuYW1lICk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uKCBuYW1lcyApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKCBlbGUsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoIC9cXHMrLyApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyggZWxlLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICB0b05vdGlmeS5ydHJpZ2dlciggJ3N0eWxlJyApOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNzcyggJ2Rpc3BsYXknLCAnZWxlbWVudCcgKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCAnZGlzcGxheScsICdub25lJyApO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHZpc2libGU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoXG4gICAgICAgIGVsZS5wc3R5bGUoICd2aXNpYmlsaXR5JyApLnZhbHVlICE9PSAndmlzaWJsZSdcbiAgICAgICAgfHwgZWxlLnBzdHlsZSggJ2Rpc3BsYXknICkudmFsdWUgIT09ICdlbGVtZW50J1xuICAgICAgICB8fCBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgPT09IDBcbiAgICAgICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggZWxlLnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZSA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1sgaSBdO1xuICAgICAgICAgICAgdmFyIHBWaXMgPSBwYXJlbnQucHN0eWxlKCAndmlzaWJpbGl0eScgKS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwRGlzID0gcGFyZW50LnBzdHlsZSggJ2Rpc3BsYXknICkudmFsdWU7XG5cbiAgICAgICAgICAgIGlmKCBwVmlzICE9PSAndmlzaWJsZScgfHwgcERpcyAhPT0gJ2VsZW1lbnQnICl7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldDtcblxuICAgICAgICByZXR1cm4gc3JjLnZpc2libGUoKSAmJiB0Z3QudmlzaWJsZSgpO1xuICAgICAgfVxuXG4gICAgfVxuICB9LFxuXG4gIGhpZGRlbjogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gMTsgfVxuXG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlO1xuXG4gICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHBhcmVudE9wYWNpdHk7IH1cblxuICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcblxuICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbIGkgXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcmVudC5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlO1xuXG4gICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgIH1cbiAgfSxcblxuICB0cmFuc3BhcmVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICAgIHJldHVybiBlbGUucHN0eWxlKCAnb3BhY2l0eScgKS52YWx1ZSA9PT0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiYWNrZ3JvdW5kaW5nOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gIH1cblxufSk7XG5cblxuZWxlc2ZuLmJ5cGFzcyA9IGVsZXNmbi5jc3MgPSBlbGVzZm4uc3R5bGU7XG5lbGVzZm4ucmVuZGVyZWRDc3MgPSBlbGVzZm4ucmVuZGVyZWRTdHlsZTtcbmVsZXNmbi5yZW1vdmVCeXBhc3MgPSBlbGVzZm4ucmVtb3ZlQ3NzID0gZWxlc2ZuLnJlbW92ZVN0eWxlO1xuZWxlc2ZuLnBzdHlsZSA9IGVsZXNmbi5wYXJzZWRTdHlsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgIGlmKCBhcmdzLmxlbmd0aCA9PT0gMiApe1xuICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgdGhpcy5vbiggcGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyICk7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDEgKXtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgIHRoaXMub24oIHBhcmFtcy5ldmVudCwgaGFuZGxlciApO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAwICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbIHBhcmFtcy5hYmxlRmllbGQgXTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbIHBhcmFtcy5maWVsZCBdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICBpZiggcGFyYW1zLm92ZXJyaWRlQWJsZSApe1xuICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKCBlbGUgKTtcblxuICAgICAgICAgIGlmKCBvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgaWYoICFvdmVycmlkZUFibGUgKXsgcmV0dXJuIHRoaXM7IH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYWJsZSApe1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICBpZiggY2hhbmdlZCApe1xuICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VkQ29sbCA9IHRoaXMuc3Bhd24oIGNoYW5nZWRFbGVzICk7XG4gICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICBjaGFuZ2VkQ29sbC50cmlnZ2VyKCBwYXJhbXMuZXZlbnQgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoU2V0KCBwYXJhbXMgKXtcbiAgZWxlc2ZuWyBwYXJhbXMuZmllbGQgXSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggcGFyYW1zLm92ZXJyaWRlRmllbGQgKXtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKCBlbGUgKTtcblxuICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbIHBhcmFtcy5maWVsZCBdO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm5bIHBhcmFtcy5vbiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oIHtcbiAgICBldmVudDogcGFyYW1zLm9uLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9ICk7XG5cbiAgZWxlc2ZuWyBwYXJhbXMub2ZmIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbigge1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSApO1xufVxuXG5kZWZpbmVTd2l0Y2hTZXQoIHtcbiAgZmllbGQ6ICdsb2NrZWQnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiggZWxlICl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG9sb2NrKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2xvY2snLFxuICBvZmY6ICd1bmxvY2snXG59ICk7XG5cbmRlZmluZVN3aXRjaFNldCgge1xuICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnZ3JhYmlmeScsXG4gIG9mZjogJ3VuZ3JhYmlmeSdcbn0gKTtcblxuZGVmaW5lU3dpdGNoU2V0KCB7XG4gIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICBhYmxlRmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVBYmxlOiBmdW5jdGlvbiggZWxlICl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0JyxcbiAgb2ZmOiAndW5zZWxlY3QnXG59ICk7XG5cbmRlZmluZVN3aXRjaFNldCgge1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiggZWxlICl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0aWZ5JyxcbiAgb2ZmOiAndW5zZWxlY3RpZnknXG59ICk7XG5cbmVsZXNmbi5kZXNlbGVjdCA9IGVsZXNmbi51bnNlbGVjdDtcblxuZWxlc2ZuLmdyYWJiZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYoIGVsZSApe1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgfVxufTtcblxuZGVmaW5lU3dpdGNoU2V0KCB7XG4gIGZpZWxkOiAnYWN0aXZlJyxcbiAgb246ICdhY3RpdmF0ZScsXG4gIG9mZjogJ3VuYWN0aXZhdGUnXG59ICk7XG5cbmVsZXNmbi5pbmFjdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiggZWxlICl7XG4gICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIGVsZXNmbiA9IHt9O1xuXG52YXIgY2FjaGUgPSBmdW5jdGlvbiggZm4sIG5hbWUgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyYXZlcnNhbENhY2hlKCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0ICl7XG4gICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGtleTtcblxuICAgIGlmKCBzZWxlY3Rvck9yRWxlcyA9PSBudWxsICl7XG4gICAgICBrZXkgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBzZWxlY3Rvck9yRWxlcyApICYmIHNlbGVjdG9yT3JFbGVzLmxlbmd0aCA9PT0gMSApe1xuICAgICAga2V5ID0gJyMnICsgc2VsZWN0b3JPckVsZXMuaWQoKTtcbiAgICB9XG5cbiAgICBpZiggZWxlcy5sZW5ndGggPT09IDEgJiYga2V5ICl7XG4gICAgICB2YXIgX3AgPSBlbGVzWzBdLl9wcml2YXRlO1xuICAgICAgdmFyIHRjaCA9IF9wLnRyYXZlcnNhbENhY2hlID0gX3AudHJhdmVyc2FsQ2FjaGUgfHwge307XG4gICAgICB2YXIgY2ggPSB0Y2hbIG5hbWUgXSA9IHRjaFsgbmFtZSBdIHx8IHt9O1xuICAgICAgdmFyIGNhY2hlSGl0ID0gY2hbIGtleSBdO1xuXG4gICAgICBpZiggY2FjaGVIaXQgKXtcbiAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICggY2hbIGtleSBdID0gZm4uY2FsbCggZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCApICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKCBlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0ICk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gREFHIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmaW5lRGFnRXh0cmVtaXR5ID0gZnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24gZGFnRXh0cmVtaXR5SW1wbCggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICBpZihcbiAgICAgICAgICAgICAoIHBhcmFtcy5ub0luY29taW5nRWRnZXMgJiYgdGd0ID09PSBlbGUgJiYgc3JjICE9PSBlbGUgKVxuICAgICAgICAgIHx8ICggcGFyYW1zLm5vT3V0Z29pbmdFZGdlcyAmJiBzcmMgPT09IGVsZSAmJiB0Z3QgIT09IGVsZSApXG4gICAgICAgICl7XG4gICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIWRpc3F1YWxpZmllZCApe1xuICAgICAgICByZXQucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHJldCwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcbn07XG5cbnZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzWyBqIF07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICBpZiggcGFyYW1zLm91dGdvaW5nICYmIHNyYyA9PT0gZWxlICl7XG4gICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgIG9FbGVzLnB1c2goIHRndCApO1xuICAgICAgICB9IGVsc2UgaWYoIHBhcmFtcy5pbmNvbWluZyAmJiB0Z3QgPT09IGVsZSApe1xuICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBzcmMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBvRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcbn07XG5cbnZhciBkZWZpbmVEYWdBbGxIb3BzID0gZnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yKCA7OyApe1xuICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgIGlmKCBuZXh0Lmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBuID0gbmV4dFsgaSBdO1xuICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuXG4gICAgICAgIGlmKCAhc0VsZXNJZHNbIG5pZCBdICl7XG4gICAgICAgICAgc0VsZXNJZHNbIG5pZCBdID0gdHJ1ZTtcbiAgICAgICAgICBzRWxlcy5wdXNoKCBuICk7XG4gICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFuZXdOZXh0ICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG4gICAgICBlbGVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggc0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59O1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gIHJvb3RzOiBkZWZpbmVEYWdFeHRyZW1pdHkoeyBub0luY29taW5nRWRnZXM6IHRydWUgfSksXG5cbiAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgbGVhdmVzOiBkZWZpbmVEYWdFeHRyZW1pdHkoeyBub091dGdvaW5nRWRnZXM6IHRydWUgfSksXG5cbiAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICBvdXRnb2VyczogY2FjaGUoIGRlZmluZURhZ09uZUhvcCh7IG91dGdvaW5nOiB0cnVlIH0pICwgJ291dGdvZXJzJyApLFxuXG4gIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgc3VjY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7IG91dGdvaW5nOiB0cnVlIH0pLFxuXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICBpbmNvbWVyczogY2FjaGUoIGRlZmluZURhZ09uZUhvcCh7IGluY29taW5nOiB0cnVlIH0pLCAnaW5jb21lcnMnICksXG5cbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHsgaW5jb21pbmc6IHRydWUgfSlcbn0gKTtcblxuXG4vLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoIGVsZXNmbiwge1xuICBuZWlnaGJvcmhvb2Q6IGNhY2hlKGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzWyBqIF07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYztcblxuICAgICAgICAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuICAgICAgICBpZiggb3RoZXJOb2RlLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBvdGhlck5vZGVbMF0gKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG4gICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2VbMF0gKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAoIHRoaXMuc3Bhd24oIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcblxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoIHNlbGVjdG9yICk7XG4gIH1cbn0gKTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuLm5laWdoYm91cmhvb2QgPSBlbGVzZm4ubmVpZ2hib3Job29kO1xuZWxlc2ZuLmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4uY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuLm9wZW5OZWlnaGJvdXJob29kID0gZWxlc2ZuLm9wZW5OZWlnaGJvcmhvb2Q7XG5cbi8vIEVkZ2UgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbCggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgc3JjO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZSB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoIHNlbGVjdG9yICkgOiBzcmM7XG4gIH0sICdzb3VyY2UnKSxcblxuICB0YXJnZXQ6IGNhY2hlKGZ1bmN0aW9uIHRhcmdldEltcGwoIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHRndDtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKCBzZWxlY3RvciApIDogdGd0O1xuICB9LCAndGFyZ2V0JyksXG5cbiAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oIHtcbiAgICBhdHRyOiAnc291cmNlJ1xuICB9ICksXG5cbiAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oIHtcbiAgICBhdHRyOiAndGFyZ2V0J1xuICB9IClcbn0gKTtcblxuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbCggc2VsZWN0b3IgKXtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmF0dHIgXTtcblxuICAgICAgaWYoIHNyYyApe1xuICAgICAgICBzb3VyY2VzLnB1c2goIHNyYyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBzb3VyY2VzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9O1xufVxuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksICdlZGdlc1dpdGgnLCB0cnVlICksXG5cbiAgZWRnZXNUbzogY2FjaGUoIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCB7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0gKSwgJ2VkZ2VzVG8nLCB0cnVlIClcbn0gKTtcblxuZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oIHBhcmFtcyApe1xuXG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKCBvdGhlck5vZGVzICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgcCA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuICAgIGlmKCBpcy5zdHJpbmcoIG90aGVyTm9kZXMgKSApe1xuICAgICAgb3RoZXJOb2RlcyA9IGN5LiQoIG90aGVyTm9kZXMgKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0lkcyA9IHRoaXMuX3ByaXZhdGUuaWRzO1xuICAgIHZhciBvdGhlcklkcyA9IG90aGVyTm9kZXMuX3ByaXZhdGUuaWRzO1xuXG4gICAgZm9yKCB2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrICl7XG4gICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzWyBoIF0uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1sgaSBdO1xuICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXNJZHNbIGVkZ2VEYXRhLnNvdXJjZSBdICYmIG90aGVySWRzWyBlZGdlRGF0YS50YXJnZXQgXTtcbiAgICAgICAgdmFyIG90aGVyVG9UaGlzID0gb3RoZXJJZHNbIGVkZ2VEYXRhLnNvdXJjZSBdICYmIHRoaXNJZHNbIGVkZ2VEYXRhLnRhcmdldCBdO1xuICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG5cbiAgICAgICAgaWYoICFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgKXsgY29udGludWU7IH1cblxuICAgICAgICBpZiggcC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QgKXtcbiAgICAgICAgICBpZiggcC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBpZiggcC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzICl7IGNvbnRpbnVlOyB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciByZXRFbGVzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IGVsZXNbIGkgXTtcbiAgICAgIGlmKCAhbm9kZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbIGogXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuXG4gIGNvbm5lY3RlZE5vZGVzOiBjYWNoZShmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzWyBpIF07XG4gICAgICBpZiggIWVkZ2UuaXNFZGdlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnNvdXJjZSgpWzBdICk7XG4gICAgICByZXRFbGVzLnB1c2goIGVkZ2UudGFyZ2V0KClbMF0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG5cbiAgcGFyYWxsZWxFZGdlczogY2FjaGUoIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycgKSxcblxuICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKCBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oIHtcbiAgICBjb2RpcmVjdGVkOiB0cnVlXG4gIH0gKSwgJ2NvZGlyZWN0ZWRFZGdlcycgKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oIHBhcmFtcyApe1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKCBzZWxlY3RvciApeyAvLyBtaWNyby1vcHRpbWlzZWQgZm9yIHJlbmRlcmVyXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbIGkgXTtcbiAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlMiA9IHNyY0VkZ2VzMVsgaiBdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuXG4gICAgICAgIHZhciBjb2RpcmVjdGVkID0gdGd0aWQyID09PSB0Z3RpZDEgJiYgc3JjaWQyID09PSBzcmNpZDE7XG4gICAgICAgIHZhciBvcHBkaXJlY3RlZCA9IHNyY2lkMSA9PT0gdGd0aWQyICYmIHRndGlkMSA9PT0gc3JjaWQyO1xuXG4gICAgICAgIGlmKCAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQpIHx8ICghcC5jb2RpcmVjdGVkICYmIChjb2RpcmVjdGVkIHx8IG9wcGRpcmVjdGVkKSkgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlMiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9O1xuXG59XG5cbi8vIE1pc2MgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIGNvbXBvbmVudHM6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IHNlbGYuc3Bhd24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gc2VsZi5ub2RlcygpLnNwYXduU2VsZigpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uKCBub2RlLCBjb21wb25lbnQgKXtcbiAgICAgIHZpc2l0ZWQubWVyZ2UoIG5vZGUgKTtcbiAgICAgIHVudmlzaXRlZC51bm1lcmdlKCBub2RlICk7XG4gICAgICBjb21wb25lbnQubWVyZ2UoIG5vZGUgKTtcbiAgICB9O1xuXG4gICAgaWYoIHVudmlzaXRlZC5lbXB0eSgpICl7IHJldHVybiBzZWxmLnNwYXduKCk7IH1cblxuICAgIGRvIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goIGNvbXBvbmVudCApO1xuXG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQoIHJvb3QsIGNvbXBvbmVudCApO1xuXG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiggaSwgZGVwdGgsIHYsIGUsIHUgKXtcbiAgICAgICAgICB2aXNpdEluQ29tcG9uZW50KCB2LCBjb21wb25lbnQgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuXG4gICAgfSB3aGlsZSggdW52aXNpdGVkLmxlbmd0aCA+IDAgKTtcblxuICAgIHJldHVybiBjb21wb25lbnRzLm1hcChmdW5jdGlvbiggY29tcG9uZW50ICl7XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBjb21wb25lbnQuY29ubmVjdGVkRWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5hbnlTYW1lKCBlZGdlLnNvdXJjZSgpICkgJiYgY29tcG9uZW50LmFueVNhbWUoIGVkZ2UudGFyZ2V0KCkgKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY29tcG9uZW50LnVuaW9uKCBjb25uZWN0ZWRFZGdlcyApO1xuICAgIH0pO1xuICB9XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xudmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiggYSwgYiApe1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoKGVsZSl7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSggJ3otY29tcG91bmQtZGVwdGgnICk7XG4gICAgaWYgKCBzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nICl7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDBcbiAgICB9IGVsc2UgaWYgKCBzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScgKXtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoIHN0eWxlLnZhbHVlID09PSAndG9wJyApe1xuICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgfVxuICAgIC8vICdvcnBoYW4nXG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgZGVwdGhEaWZmID0gZ2V0RGVwdGgoYSkgLSBnZXREZXB0aChiKTtcbiAgaWYgKCBkZXB0aERpZmYgIT09IDAgKXtcbiAgICByZXR1cm4gZGVwdGhEaWZmXG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpe1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoICd6LWluZGV4LWNvbXBhcmUnICk7XG4gICAgaWYgKCBzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpID8gMSA6IDBcbiAgICB9XG4gICAgLy8gJ21hbnVhbCdcbiAgICByZXR1cm4gMFxuICB9XG4gIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcbiAgaWYgKCBlbGVEaWZmICE9PSAwICl7XG4gICAgcmV0dXJuIGVsZURpZmZcbiAgfVxuXG4gIHZhciB6RGlmZiA9IGEucHN0eWxlKCAnei1pbmRleCcgKS52YWx1ZSAtIGIucHN0eWxlKCAnei1pbmRleCcgKS52YWx1ZTtcbiAgaWYgKCB6RGlmZiAhPT0gMCApe1xuICAgIHJldHVybiB6RGlmZlxuICB9XG4gIC8vIGNvbXBhcmUgaW5kaWNlcyBpbiB0aGUgY29yZSAob3JkZXIgYWRkZWQgdG8gZ3JhcGggdy8gbGFzdCBvbiB0b3ApXG4gIHJldHVybiBhLnBvb2xJbmRleCgpIC0gYi5wb29sSW5kZXgoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gekluZGV4U29ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4uL2NvbGxlY3Rpb24nICk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICcuLi9jb2xsZWN0aW9uL2VsZW1lbnQnICk7XG5cbnZhciBjb3JlZm4gPSB7XG4gIGFkZDogZnVuY3Rpb24oIG9wdHMgKXtcblxuICAgIHZhciBlbGVtZW50cztcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBvcHRzICkgKXtcbiAgICAgIHZhciBlbGVzID0gb3B0cztcblxuICAgICAgaWYoIGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5ICl7IC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgY29weSBmcm9tIGpzb25cbiAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcbiAgICAgICAgICBqc29ucy5wdXNoKCBlbGUuanNvbigpICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICBlbHNlIGlmKCBpcy5hcnJheSggb3B0cyApICl7XG4gICAgICB2YXIganNvbnMgPSBvcHRzO1xuXG4gICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIG9wdHMgKSAmJiAoaXMuYXJyYXkoIG9wdHMubm9kZXMgKSB8fCBpcy5hcnJheSggb3B0cy5lZGdlcyApKSApe1xuICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICB2YXIgZ3JzID0gWyAnbm9kZXMnLCAnZWRnZXMnIF07XG4gICAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBncnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApe1xuICAgICAgICB2YXIgZ3JvdXAgPSBncnNbIGkgXTtcbiAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwWyBncm91cCBdO1xuXG4gICAgICAgIGlmKCBpcy5hcnJheSggZWxlc0FycmF5ICkgKXtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrICl7XG4gICAgICAgICAgICB2YXIganNvbiA9IHV0aWwuZXh0ZW5kKCB7IGdyb3VwOiBncm91cCB9LCBlbGVzQXJyYXlbIGogXSApO1xuXG4gICAgICAgICAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oIGN5LCBqc29ucyApO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICBlbHNlIHtcbiAgICAgIHZhciBqc29uID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gKG5ldyBFbGVtZW50KCBjeSwganNvbiApKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggY29sbGVjdGlvbiApICl7XG4gICAgICAvLyBhbHJlYWR5IGhhdmUgcmlnaHQgcmVmXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoIGNvbGxlY3Rpb24gKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKCk7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oIGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBjeS5ub3RpZmljYXRpb25zKCBmYWxzZSApO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgaWYoIG9sZEVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBlbGVtZW50cyApIHx8IGlzLmFycmF5KCBlbGVtZW50cyApICl7XG4gICAgICAgIGN5LmFkZCggZWxlbWVudHMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5vbmUoICdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKCB0cnVlICk7XG4gICAgICBjeS50cmlnZ2VyKCBlICk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgY3kubm90aWZ5KCB7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgZWxlczogY3kubXV0YWJsZUVsZW1lbnRzKClcbiAgICAgIH0gKTtcblxuICAgICAgY3kub25lKCAnbG9hZCcsIG9ubG9hZCApO1xuICAgICAgY3kudHJpZ2dlciggJ2xvYWQnICk7XG4gICAgfSApLm9uZSggJ2xheW91dHN0b3AnLCBmdW5jdGlvbigpe1xuICAgICAgY3kub25lKCAnZG9uZScsIG9uZG9uZSApO1xuICAgICAgY3kudHJpZ2dlciggJ2RvbmUnICk7XG4gICAgfSApO1xuXG4gICAgdmFyIGxheW91dE9wdHMgPSB1dGlsLmV4dGVuZCgge30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0ICk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGN5LmxheW91dCggbGF5b3V0T3B0cyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4uL2RlZmluZScgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lLnN0b3AoKSxcblxuICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZSggZWxlcyApO1xuICB9LFxuXG4gIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcblxuICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuICAgIGZ1bmN0aW9uIGdsb2JhbEFuaW1hdGlvblN0ZXAoKXtcbiAgICAgIGlmKCAhY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgKXsgcmV0dXJuOyB9XG5cbiAgICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbiBhbmltYXRpb25TdGVwKCBub3cgKXtcbiAgICAgICAgaGFuZGxlRWxlbWVudHMoIG5vdyApO1xuICAgICAgICBnbG9iYWxBbmltYXRpb25TdGVwKCk7XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcblxuICAgIGlmKCByZW5kZXJlciAmJiByZW5kZXJlci5iZWZvcmVSZW5kZXIgKXsgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoIGZ1bmN0aW9uIHJlbmRlcmVyQW5pbWF0aW9uU3RlcCggd2lsbERyYXcsIG5vdyApe1xuICAgICAgICBoYW5kbGVFbGVtZW50cyggbm93ICk7XG4gICAgICB9LCByZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmFuaW1hdGlvbnMgKTtcbiAgICB9IGVsc2UgeyAvLyBtYW5hZ2UgdGhlIGFuaW1hdGlvbiBsb29wIG91cnNlbHZlc1xuICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudHMoIG5vdyApe1xuICAgICAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICAgICAgdmFyIGRvbmVFbGVzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGVsZSwgaXNDb3JlICl7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgICB2YXIgcmFuQW5pcyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNhbmNlbCBhbGwgYW5pbWF0aW9ucyBvbiBkaXNwbGF5Om5vbmUgZWxlXG4gICAgICAgIGlmKCAhaXNDb3JlICYmIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICAgICAgLy8gcHV0IGFsbCBjdXJyZW50IGFuZCBxdWV1ZSBhbmltYXRpb25zIGluIHRoaXMgdGljaydzIGN1cnJlbnQgbGlzdFxuICAgICAgICAgIC8vIGFuZCBlbXB0eSB0aGUgbGlzdHMgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3BsaWNlKCAwLCBjdXJyZW50Lmxlbmd0aCApLmNvbmNhdCggcXVldWUuc3BsaWNlKCAwLCBxdWV1ZS5sZW5ndGggKSApO1xuXG4gICAgICAgICAgLy8gc3RvcCBhbGwgYW5pbWF0aW9uc1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKyApeyBjdXJyZW50W2ldLnN0b3AoKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIGlmKCBjdXJyZW50Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIGlmKCBuZXh0ICl7XG4gICAgICAgICAgICBjdXJyZW50LnB1c2goIG5leHQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24oIGNhbGxiYWNrcyApe1xuICAgICAgICAgIGZvciggdmFyIGogPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0gKXtcbiAgICAgICAgICAgIHZhciBjYiA9IGNhbGxiYWNrc1sgaiBdO1xuXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoIDAsIGNhbGxiYWNrcy5sZW5ndGggKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuICAgICAgICBmb3IoIHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSApe1xuICAgICAgICAgIHZhciBhbmkgPSBjdXJyZW50WyBpIF07XG4gICAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICAgICAgaWYoIGFuaV9wLnN0b3BwZWQgKXtcbiAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmZyYW1lcyApO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgaWYoIGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhbmlfcC5zdGFydGVkICl7XG4gICAgICAgICAgICBzdGFydEFuaW1hdGlvbiggZWxlLCBhbmksIG5vdyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ZXAoIGVsZSwgYW5pLCBub3csIGlzQ29yZSApO1xuXG4gICAgICAgICAgaWYoIGlzLmZuKCBhbmlfcC5zdGVwICkgKXtcbiAgICAgICAgICAgIGFuaV9wLnN0ZXAuY2FsbCggZWxlLCBub3cgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FsbGJhY2tzKCBhbmlfcC5mcmFtZXMgKTtcblxuICAgICAgICAgIGlmKCBhbmkuY29tcGxldGVkKCkgKXtcbiAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmNvbXBsZXRlcyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFpc0NvcmUgJiYgY3VycmVudC5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgZG9uZUVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuQW5pcztcbiAgICAgIH0gLy8gaGFuZGxlRWxlbWVudFxuXG4gICAgICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgICAgIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgZSBdO1xuICAgICAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBoYW5kbGVFbGVtZW50KCBlbGUgKTtcblxuICAgICAgICByYW5FbGVBbmkgPSByYW5FbGVBbmkgfHwgaGFuZGxlZFRoaXNFbGU7XG4gICAgICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gICAgICB2YXIgcmFuQ29yZUFuaSA9IGhhbmRsZUVsZW1lbnQoIGN5LCB0cnVlICk7XG5cbiAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgICAgaWYoIHJhbkVsZUFuaSB8fCByYW5Db3JlQW5pICl7XG4gICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCkuc3Bhd25TZWxmKCkubWVyZ2UoIGVsZXMgKTtcblxuICAgICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiAnZHJhdycsXG4gICAgICAgICAgICBlbGVzOiB1cGRhdGVkRWxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgICAgIGVsZXMudW5tZXJnZSggZG9uZUVsZXMgKTtcblxuICAgICAgY3kudHJpZ2dlcignc3RlcCcpO1xuXG4gICAgfSAvLyBoYW5kbGVFbGVtZW50c1xuXG4gICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oIHNlbGYsIGFuaSwgbm93ICl7XG4gICAgICB2YXIgaXNDb3JlID0gaXMuY29yZSggc2VsZiApO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICB2YXIgZWxlID0gc2VsZjtcbiAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgYW5pX3Auc3RhcnRQb3NpdGlvbiA9IGFuaV9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgIHk6IHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pX3Auc3RhcnRTdHlsZSA9IGFuaV9wLnN0YXJ0U3R5bGUgfHwgc3R5bGUuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSggZWxlLCBhbmlfcC5zdHlsZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggaXNDb3JlICl7XG4gICAgICAgIHZhciBwYW4gPSBjeS5fcHJpdmF0ZS5wYW47XG5cbiAgICAgICAgYW5pX3Auc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbiB8fCB7XG4gICAgICAgICAgeDogcGFuLngsXG4gICAgICAgICAgeTogcGFuLnlcbiAgICAgICAgfTtcblxuICAgICAgICBhbmlfcC5zdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb20gIT0gbnVsbCA/IGFuaV9wLnN0YXJ0Wm9vbSA6IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICB9XG5cbiAgICAgIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCBzZWxmLCBhbmksIG5vdywgaXNDb3JlICl7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcblxuICAgICAgaWYoICFhbmlfcC5lYXNpbmdJbXBsICl7XG5cbiAgICAgICAgaWYoIHBFYXNpbmcgPT0gbnVsbCApeyAvLyB1c2UgZGVmYXVsdFxuICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyAnbGluZWFyJyBdO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIHBFYXNpbmcgKSApe1xuICAgICAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSggJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgcEVhc2luZyApO1xuXG4gICAgICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgICBpZiggaXMuc3RyaW5nKCBlYXNpbmdWYWxzICkgKXtcbiAgICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKCAyICkubWFwKCBmdW5jdGlvbiggbiApeyByZXR1cm4gK247IH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYXJncy5sZW5ndGggPiAwICl7IC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgICAgIGlmKCBuYW1lID09PSAnc3ByaW5nJyApe1xuICAgICAgICAgICAgICBhcmdzLnB1c2goIGFuaV9wLmR1cmF0aW9uICk7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyBuYW1lIF0uYXBwbHkoIG51bGwsIGFyZ3MgKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1sgbmFtZSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICAgICAgdmFyIHBlcmNlbnQ7XG5cbiAgICAgIGlmKCBhbmlfcC5kdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuZGVsYXkgPT0gbnVsbCApeyAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICBpZiggZW5kUG9zICYmIGlzRWxlcyApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueCwgZW5kUG9zLnggKSApe1xuICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBvcy55LCBlbmRQb3MueSApICl7XG4gICAgICAgICAgICBwb3MueSA9IGVhc2UoIHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICAgICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICAgICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQYW4ueCwgZW5kUGFuLnggKSApe1xuICAgICAgICAgICAgcGFuLnggPSBlYXNlKCBzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICBwYW4ueSA9IGVhc2UoIHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoICdwYW4nICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgICAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgaWYoIGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0Wm9vbSwgZW5kWm9vbSApICl7XG4gICAgICAgICAgICBfcC56b29tID0gZWFzZSggc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoICd6b29tJyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCAndmlld3BvcnQnICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcbiAgICAgICAgaWYoIHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgICB2YXIgZW5kID0gcHJvcDtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pX3Auc3RhcnRTdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZSggc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nICk7XG5cbiAgICAgICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKCBzZWxmLCBuYW1lLCBlYXNlZFZhbCApO1xuICAgICAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3N0eWxlJyk7XG5cbiAgICAgICAgfSAvLyBpZlxuXG4gICAgICB9XG5cbiAgICAgIGFuaV9wLnByb2dyZXNzID0gcGVyY2VudDtcblxuICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWQoIHN0YXJ0LCBlbmQgKXtcbiAgICAgIGlmKCBzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlciggc3RhcnQgKSAmJiBpcy5udW1iZXIoIGVuZCApICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmKCAoc3RhcnQpICYmIChlbmQpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lcyBwMCA9IDAsIHAzID0gMVxuICAgIGZ1bmN0aW9uIGV2YWxDdWJpY0JlemllciggcDEsIHAyLCB0ICl7XG4gICAgICB2YXIgb25lX3QgPSAxIC0gdDtcbiAgICAgIHZhciB0c3EgPSB0ICogdDtcblxuICAgICAgcmV0dXJuICggMyAqIG9uZV90ICogb25lX3QgKiB0ICogcDEgKSArICggMyAqIG9uZV90ICogdHNxICogcDIgKSArIHRzcSAqIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3ViaWNCZXppZXIoIHAxLCBwMiApe1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwZXJjZW50ICl7XG4gICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBldmFsQ3ViaWNCZXppZXIoIHAxLCBwMiwgcGVyY2VudCApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4gICAgLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgICAgICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbiAgICB2YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSAoZnVuY3Rpb24oKXtcbiAgICAgIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKCBzdGF0ZSApe1xuICAgICAgICByZXR1cm4gKC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCkgLSAoc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKCBpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlICl7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHsgZHg6IHN0YXRlLnYsIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZSggc3RhdGUgKSB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcHJpbmdJbnRlZ3JhdGVTdGF0ZSggc3RhdGUsIGR0ICl7XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZSggc3RhdGUgKVxuICAgICAgICB9LFxuICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKCBzdGF0ZSwgZHQgKiAwLjUsIGEgKSxcbiAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZSggc3RhdGUsIGR0ICogMC41LCBiICksXG4gICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoIHN0YXRlLCBkdCwgYyApLFxuICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcblxuICAgICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgICAgc3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSggdGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uICl7XG5cbiAgICAgICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICB2OiAwLFxuICAgICAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICAgICAgZnJpY3Rpb246IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICBoYXZlX2R1cmF0aW9uLCBkdCwgbGFzdF9zdGF0ZTtcblxuICAgICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCggdGVuc2lvbiApIHx8IDUwMDtcbiAgICAgICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KCBmcmljdGlvbiApIHx8IDIwO1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG5cbiAgICAgICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgICAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgICAgICBoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG5cbiAgICAgICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cbiAgICAgICAgaWYoIGhhdmVfZHVyYXRpb24gKXtcbiAgICAgICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSggdGVuc2lvbiwgZnJpY3Rpb24gKTtcbiAgICAgICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuICAgICAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR0ID0gRFQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSggdHJ1ZSApe1xuICAgICAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgICAgICBsYXN0X3N0YXRlID0gc3ByaW5nSW50ZWdyYXRlU3RhdGUoIGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCApO1xuICAgICAgICAgIC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cbiAgICAgICAgICBwYXRoLnB1c2goIDEgKyBsYXN0X3N0YXRlLnggKTtcbiAgICAgICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgICAgICBpZiggIShNYXRoLmFicyggbGFzdF9zdGF0ZS54ICkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMoIGxhc3Rfc3RhdGUudiApID4gdG9sZXJhbmNlKSApe1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cbiAgICAgICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiggcGVyY2VudENvbXBsZXRlICl7IHJldHVybiBwYXRoWyAocGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkpIHwgMCBdOyB9O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGVhc2luZ3MgPSB7XG4gICAgICAnbGluZWFyJzogZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgICAgICdlYXNlJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuMSwgMC4yNSwgMSApLFxuICAgICAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllciggMC40MiwgMCwgMSwgMSApLFxuICAgICAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoIDAsIDAsIDAuNTgsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKCAwLjQyLCAwLCAwLjU4LCAxICksXG5cbiAgICAgIC8vIHNpbmVcbiAgICAgICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllciggMC40NywgMCwgMC43NDUsIDAuNzE1ICksXG4gICAgICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKCAwLjM5LCAwLjU3NSwgMC41NjUsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoIDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1ICksXG5cbiAgICAgIC8vIHF1YWRcbiAgICAgICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllciggMC41NSwgMC4wODUsIDAuNjgsIDAuNTMgKSxcbiAgICAgICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUgKSxcblxuICAgICAgLy8gY3ViaWNcbiAgICAgICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoIDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSApLFxuICAgICAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuMjE1LCAwLjYxLCAwLjM1NSwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEgKSxcblxuICAgICAgLy8gcXVhcnRcbiAgICAgICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuMTY1LCAwLjg0LCAwLjQ0LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllciggMC43NywgMCwgMC4xNzUsIDEgKSxcblxuICAgICAgLy8gcXVpbnRcbiAgICAgICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoIDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoIDAuMjMsIDEsIDAuMzIsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKCAwLjg2LCAwLCAwLjA3LCAxICksXG5cbiAgICAgIC8vIGV4cG9cbiAgICAgICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllciggMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1ICksXG4gICAgICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAwLjE5LCAxLCAwLjIyLCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAxLCAwLCAwLCAxICksXG5cbiAgICAgIC8vIGNpcmNcbiAgICAgICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllciggMC42LCAwLjA0LCAwLjk4LCAwLjMzNSApLFxuICAgICAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllciggMC4wNzUsIDAuODIsIDAuMTY1LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKCAwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYgKSxcblxuXG4gICAgICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAgICAgJ3NwcmluZyc6IGZ1bmN0aW9uKCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKXtcbiAgICAgICAgaWYoIGR1cmF0aW9uID09PSAwICl7IC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICAgICAgcmV0dXJuIGVhc2luZ3MubGluZWFyOyAvLyBkdXJhdGlvbiAwID0+IGp1bXAgdG8gZW5kIHNvIGltcGwgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCggdGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwZXJjZW50ICl7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyggcGVyY2VudCApO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgJ2N1YmljLWJlemllcic6IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXIoIHgxLCB5MSwgeDIsIHkyICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVhc2UoIHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4gKXtcbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCwgZW5kO1xuXG4gICAgICBpZiggc3RhcnRQcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBzdGFydFByb3AudmFsdWUgIT0gbnVsbCApe1xuICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcC5wZlZhbHVlICE9IG51bGwgPyBzdGFydFByb3AucGZWYWx1ZSA6IHN0YXJ0UHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wO1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kUHJvcC5wZlZhbHVlICE9IG51bGwgfHwgZW5kUHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgIGVuZCA9IGVuZFByb3AucGZWYWx1ZSAhPSBudWxsID8gZW5kUHJvcC5wZlZhbHVlIDogZW5kUHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IGVuZFByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5udW1iZXIoIHN0YXJ0ICkgJiYgaXMubnVtYmVyKCBlbmQgKSApe1xuICAgICAgICByZXR1cm4gZWFzaW5nRm4oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKTtcblxuICAgICAgfSBlbHNlIGlmKCBpcy5hcnJheSggc3RhcnQgKSAmJiBpcy5hcnJheSggZW5kICkgKXtcbiAgICAgICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgc2kgPSBzdGFydFsgaSBdO1xuICAgICAgICAgIHZhciBlaSA9IGVuZFsgaSBdO1xuXG4gICAgICAgICAgaWYoIHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCApe1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVhc2luZ0ZuKCBzaSwgZWksIHBlcmNlbnQgKTtcblxuICAgICAgICAgICAgaWYoIHN0YXJ0UHJvcC5yb3VuZFZhbHVlICl7IHZhbCA9IE1hdGgucm91bmQoIHZhbCApOyB9XG5cbiAgICAgICAgICAgIGVhc2VkQXJyLnB1c2goIHZhbCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNlZEFyci5wdXNoKCBlaSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlYXNlZEFycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgY29yZWZuID0gKHtcbiAgb246IGRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gIG9uZTogZGVmaW5lLm9uKCB7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSApLFxuICBvbmNlOiBkZWZpbmUub24oIHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9mZjogZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKSAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBjb3JlZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIHBuZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyggb3B0aW9ucyApO1xuICB9LFxuXG4gIGpwZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyggb3B0aW9ucyApO1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uanBlZyA9IGNvcmVmbi5qcGc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uL3dpbmRvdycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoICcuLi9jb2xsZWN0aW9uJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCAnLi4vcHJvbWlzZScgKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xuXG52YXIgQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIHZhciBjeSA9IHRoaXM7XG5cbiAgb3B0cyA9IHV0aWwuZXh0ZW5kKCB7fSwgb3B0cyApO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcblxuICAvLyBhbGxvdyBmb3IgcGFzc2luZyBhIHdyYXBwZWQganF1ZXJ5IG9iamVjdFxuICAvLyBlLmcuIGN5dG9zY2FwZSh7IGNvbnRhaW5lcjogJCgnI2N5JykgfSlcbiAgaWYoIGNvbnRhaW5lciAmJiAhaXMuaHRtbEVsZW1lbnQoIGNvbnRhaW5lciApICYmIGlzLmh0bWxFbGVtZW50KCBjb250YWluZXJbMF0gKSApe1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuXG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgcmVnID0gcmVnIHx8IHt9O1xuXG4gIGlmKCByZWcgJiYgcmVnLmN5ICl7XG4gICAgcmVnLmN5LmRlc3Ryb3koKTtcblxuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gIGlmKCBjb250YWluZXIgKXsgY29udGFpbmVyLl9jeXJlZyA9IHJlZzsgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gIHJlZy5jeSA9IGN5O1xuXG4gIHZhciBoZWFkID0gd2luZG93ICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gIHZhciBvcHRpb25zID0gb3B0cztcbiAgb3B0aW9ucy5sYXlvdXQgPSB1dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnIH0sIG9wdGlvbnMubGF5b3V0ICk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSB1dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCcgfSwgb3B0aW9ucy5yZW5kZXJlciApO1xuXG4gIHZhciBkZWZWYWwgPSBmdW5jdGlvbiggZGVmLCB2YWwsIGFsdFZhbCApe1xuICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYoIGFsdFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gYWx0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLCAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLCAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIGluaXRyZW5kZXI6IGZhbHNlLCAvLyBoYXMgaW5pdHJlbmRlciBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICBvcHRpb25zOiBvcHRpb25zLCAvLyBjYWNoZWQgb3B0aW9uc1xuICAgIGVsZW1lbnRzOiBuZXcgQ29sbGVjdGlvbiggdGhpcyApLCAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICBsaXN0ZW5lcnM6IFtdLCAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKCB0aGlzICksIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsIC8vIHdoZXRoZXIgbm90aWZpY2F0aW9ucyBhcmUgc2VudCB0byB0aGUgcmVuZGVyZXJcbiAgICBtaW5ab29tOiAxZS01MCxcbiAgICBtYXhab29tOiAxZTUwLFxuICAgIHpvb21pbmdFbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQgKSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCggdHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQgKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKCB0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkICksXG4gICAgdXNlclBhbm5pbmdFbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkICksXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKCB0cnVlLCBvcHRpb25zLmJveFNlbGVjdGlvbkVuYWJsZWQgKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKCBmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzICksXG4gICAgYXV0b3VuZ3JhYmlmeTogZGVmVmFsKCBmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyApLFxuICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKCBmYWxzZSwgb3B0aW9ucy5hdXRvdW5zZWxlY3RpZnkgKSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogaXMubnVtYmVyKCBvcHRpb25zLnpvb20gKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgcGFuOiB7XG4gICAgICB4OiBpcy5wbGFpbk9iamVjdCggb3B0aW9ucy5wYW4gKSAmJiBpcy5udW1iZXIoIG9wdGlvbnMucGFuLnggKSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogaXMucGxhaW5PYmplY3QoIG9wdGlvbnMucGFuICkgJiYgaXMubnVtYmVyKCBvcHRpb25zLnBhbi55ICkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlXG4gIH07XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG4gIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICBpZiggc2VsVHlwZSA9PT0gdW5kZWZpbmVkIHx8IChzZWxUeXBlICE9PSAnYWRkaXRpdmUnICYmIHNlbFR5cGUgIT09ICdzaW5nbGUnKSApe1xuICAgIC8vIHRoZW4gc2V0IGRlZmF1bHRcblxuICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgfSBlbHNlIHtcbiAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgfVxuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgaWYoIGlzLm51bWJlciggb3B0aW9ucy5taW5ab29tICkgJiYgaXMubnVtYmVyKCBvcHRpb25zLm1heFpvb20gKSAmJiBvcHRpb25zLm1pblpvb20gPCBvcHRpb25zLm1heFpvb20gKXtcbiAgICBfcC5taW5ab29tID0gb3B0aW9ucy5taW5ab29tO1xuICAgIF9wLm1heFpvb20gPSBvcHRpb25zLm1heFpvb207XG4gIH0gZWxzZSBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1pblpvb20gKSAmJiBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gIH0gZWxzZSBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1heFpvb20gKSAmJiBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgIF9wLm1heFpvb20gPSBvcHRpb25zLm1heFpvb207XG4gIH1cblxuICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiggZXh0RGF0YSwgbmV4dCApe1xuICAgIHZhciBhbnlJc1Byb21pc2UgPSBleHREYXRhLnNvbWUoIGlzLnByb21pc2UgKTtcblxuICAgIGlmKCBhbnlJc1Byb21pc2UgKXtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCggZXh0RGF0YSApLnRoZW4oIG5leHQgKTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KCBleHREYXRhICk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICB9XG4gIH07XG5cbiAgLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuICBjeS5pbml0UmVuZGVyZXIoIHV0aWwuZXh0ZW5kKCB7XG4gICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0LFxuICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgIHdoZWVsU2Vuc2l0aXZpdHk6IGlzLm51bWJlciggb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5ICkgJiYgb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5ID4gMCA/IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA6IDEsXG4gICAgbW90aW9uQmx1cjogb3B0aW9ucy5tb3Rpb25CbHVyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMubW90aW9uQmx1ciwgLy8gb2ZmIGJ5IGRlZmF1bHRcbiAgICBtb3Rpb25CbHVyT3BhY2l0eTogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSA9PT0gdW5kZWZpbmVkID8gMC4wNSA6IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHksXG4gICAgcGl4ZWxSYXRpbzogaXMubnVtYmVyKCBvcHRpb25zLnBpeGVsUmF0aW8gKSAmJiBvcHRpb25zLnBpeGVsUmF0aW8gPiAwID8gb3B0aW9ucy5waXhlbFJhdGlvIDogdW5kZWZpbmVkLFxuICAgIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gNCA6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCxcbiAgICB0b3VjaFRhcFRocmVzaG9sZDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gOCA6IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGRcbiAgfSwgb3B0aW9ucy5yZW5kZXJlciApICk7XG5cbiAgbG9hZEV4dERhdGEoWyBvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzIF0sIGZ1bmN0aW9uKCB0aGVucyApe1xuICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTtcblxuICAgIC8vIGluaXQgc3R5bGVcbiAgICBpZiggX3Auc3R5bGVFbmFibGVkICl7XG4gICAgICBjeS5zZXRTdHlsZSggaW5pdFN0eWxlICk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB0aGUgcGFzc2VkIGZ1bmN0aW9uIGZvciB0aGUgYGluaXRyZW5kZXJgIGV2ZW50XG4gICAgaWYoIG9wdGlvbnMuaW5pdHJlbmRlciApe1xuICAgICAgY3kub24oICdpbml0cmVuZGVyJywgb3B0aW9ucy5pbml0cmVuZGVyICk7XG4gICAgICBjeS5vbiggJ2luaXRyZW5kZXInLCBmdW5jdGlvbigpe1xuICAgICAgICBfcC5pbml0cmVuZGVyID0gdHJ1ZTtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsIGxvYWRcbiAgICBjeS5sb2FkKCBpbml0RWxlcywgZnVuY3Rpb24oKXsgLy8gb25yZWFkeVxuICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICBfcC5yZWFkeSA9IHRydWU7XG5cbiAgICAgIC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcbiAgICAgIGlmKCBpcy5mbiggb3B0aW9ucy5yZWFkeSApICl7XG4gICAgICAgIGN5Lm9uKCAncmVhZHknLCBvcHRpb25zLnJlYWR5ICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1sgaSBdO1xuICAgICAgICBjeS5vbiggJ3JlYWR5JywgZm4gKTtcbiAgICAgIH1cbiAgICAgIGlmKCByZWcgKXsgcmVnLnJlYWRpZXMgPSBbXTsgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuXG4gICAgICBjeS50cmlnZ2VyKCAncmVhZHknICk7XG4gICAgfSwgb3B0aW9ucy5kb25lICk7XG5cbiAgfSApO1xufTtcblxudmFyIGNvcmVmbiA9IENvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG51dGlsLmV4dGVuZCggY29yZWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG5cbiAgaXNSZWFkeTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcblxuICBpc0Rlc3Ryb3llZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCBmbiApe1xuICAgIGlmKCB0aGlzLmlzUmVhZHkoKSApe1xuICAgICAgdGhpcy50cmlnZ2VyKCAncmVhZHknLCBbXSwgZm4gKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCAncmVhZHknLCBmbiApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRyZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaW5pdHJlbmRlcjtcbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYoIGN5LmlzRGVzdHJveWVkKCkgKSByZXR1cm47XG5cbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuXG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoICdkZXN0cm95JyApO1xuXG4gICAgY3kuX3ByaXZhdGUuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBjeTtcbiAgfSxcblxuICBoYXNFbGVtZW50V2l0aElkOiBmdW5jdGlvbiggaWQgKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKCBpZCApO1xuICB9LFxuXG4gIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiggaWQgKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgfSxcblxuICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnNlbGVjdGlvblR5cGU7XG4gIH0sXG5cbiAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzO1xuICB9LFxuXG4gIGhlYWRsZXNzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm9wdGlvbnMucmVuZGVyZXIubmFtZSA9PT0gJ251bGwnO1xuICB9LFxuXG4gIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gIH0sXG5cbiAgYWRkVG9Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMubWVyZ2UoIGVsZXMgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHJlbW92ZUZyb21Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZSggZWxlcyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcbiAgfSxcblxuICBvcHRpb25zOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB1dGlsLmNvcHkoIHRoaXMuX3ByaXZhdGUub3B0aW9ucyApO1xuICB9LFxuXG4gIGpzb246IGZ1bmN0aW9uKCBvYmogKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3QoIG9iaiApICl7IC8vIHNldFxuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmKCBvYmouZWxlbWVudHMgKXtcbiAgICAgICAgdmFyIGlkSW5Kc29uID0ge307XG5cbiAgICAgICAgdmFyIHVwZGF0ZUVsZXMgPSBmdW5jdGlvbigganNvbnMsIGdyICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGpzb24gPSBqc29uc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGlkID0ganNvbi5kYXRhLmlkO1xuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG4gICAgICAgICAgICBpZEluSnNvblsgaWQgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCBlbGUubGVuZ3RoICE9PSAwICl7IC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgZWxlLmpzb24oIGpzb24gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYoIGdyICl7XG4gICAgICAgICAgICAgICAgY3kuYWRkKCB1dGlsLmV4dGVuZCggeyBncm91cDogZ3IgfSwganNvbiApICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3kuYWRkKCBqc29uICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzLmFycmF5KCBvYmouZWxlbWVudHMgKSApeyAvLyBlbGVtZW50czogW11cbiAgICAgICAgICB1cGRhdGVFbGVzKCBvYmouZWxlbWVudHMgKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBlbGVtZW50czogeyBub2RlczogW10sIGVkZ2VzOiBbXSB9XG4gICAgICAgICAgdmFyIGdycyA9IFsgJ25vZGVzJywgJ2VkZ2VzJyBdO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZ3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZ3IgPSBncnNbIGkgXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1sgZ3IgXTtcblxuICAgICAgICAgICAgaWYoIGlzLmFycmF5KCBlbGVtZW50cyApICl7XG4gICAgICAgICAgICAgIHVwZGF0ZUVsZXMoIGVsZW1lbnRzLCBnciApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsZW1lbnRzIG5vdCBzcGVjaWZpZWQgaW4ganNvbiBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAgICBlbGVzLnN0ZEZpbHRlciggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bIGVsZS5pZCgpIF07XG4gICAgICAgIH0gKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai5zdHlsZSApe1xuICAgICAgICBjeS5zdHlsZSggb2JqLnN0eWxlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvYmouem9vbSAhPSBudWxsICYmIG9iai56b29tICE9PSBfcC56b29tICl7XG4gICAgICAgIGN5Lnpvb20oIG9iai56b29tICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvYmoucGFuICl7XG4gICAgICAgIGlmKCBvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkgKXtcbiAgICAgICAgICBjeS5wYW4oIG9iai5wYW4gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICAnbWluWm9vbScsICdtYXhab29tJywgJ3pvb21pbmdFbmFibGVkJywgJ3VzZXJab29taW5nRW5hYmxlZCcsXG4gICAgICAgICdwYW5uaW5nRW5hYmxlZCcsICd1c2VyUGFubmluZ0VuYWJsZWQnLFxuICAgICAgICAnYm94U2VsZWN0aW9uRW5hYmxlZCcsXG4gICAgICAgICdhdXRvbG9jaycsICdhdXRvdW5ncmFiaWZ5JywgJ2F1dG91bnNlbGVjdGlmeSdcbiAgICAgIF07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmID0gZmllbGRzWyBpIF07XG5cbiAgICAgICAgaWYoIG9ialsgZiBdICE9IG51bGwgKXtcbiAgICAgICAgICBjeVsgZiBdKCBvYmpbIGYgXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG4gICAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBlbGVzLmZvckVhY2goIGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzWyBncm91cCBdICl7XG4gICAgICAgICAganNvbi5lbGVtZW50c1sgZ3JvdXAgXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAganNvbi5lbGVtZW50c1sgZ3JvdXAgXS5wdXNoKCBlbGUuanNvbigpICk7XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKCB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCApe1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG5cbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gY3kuX3ByaXZhdGUuem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IGN5Ll9wcml2YXRlLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBjeS5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IHV0aWwuY29weSggY3kuX3ByaXZhdGUucGFuICk7XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5yZW5kZXJlciA9IHV0aWwuY29weSggY3kuX3ByaXZhdGUub3B0aW9ucy5yZW5kZXJlciApO1xuICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAganNvbi50ZXh0dXJlT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgICBqc29uLndoZWVsU2Vuc2l0aXZpdHkgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICBqc29uLm1vdGlvbkJsdXIgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLm1vdGlvbkJsdXI7XG5cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfSxcblxuICBzY3JhdGNoOiBkZWZpbmUuZGF0YSgge1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0gKSxcblxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSgge1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlXG4gIH0gKVxuXG59ICk7XG5cbltcbiAgcmVxdWlyZSggJy4vYWRkLXJlbW92ZScgKSxcbiAgcmVxdWlyZSggJy4vYW5pbWF0aW9uJyApLFxuICByZXF1aXJlKCAnLi9ldmVudHMnICksXG4gIHJlcXVpcmUoICcuL2V4cG9ydCcgKSxcbiAgcmVxdWlyZSggJy4vbGF5b3V0JyApLFxuICByZXF1aXJlKCAnLi9ub3RpZmljYXRpb24nICksXG4gIHJlcXVpcmUoICcuL3JlbmRlcmVyJyApLFxuICByZXF1aXJlKCAnLi9zZWFyY2gnICksXG4gIHJlcXVpcmUoICcuL3N0eWxlJyApLFxuICByZXF1aXJlKCAnLi92aWV3cG9ydCcgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGNvcmVmbiwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBsYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5fcHJpdmF0ZS5wcmV2TGF5b3V0ID0gKCBwYXJhbXMgPT0gbnVsbCA/IHRoaXMuX3ByaXZhdGUucHJldkxheW91dCA6IHRoaXMubWFrZUxheW91dCggcGFyYW1zICkgKTtcblxuICAgIGxheW91dC5ydW4oKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0JyApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBvcHRpb25zLm5hbWUgPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvciggJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdmFyIExheW91dCA9IGN5LmV4dGVuc2lvbiggJ2xheW91dCcsIG5hbWUgKTtcblxuICAgIGlmKCBMYXlvdXQgPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgYXBwbHkgbGF5b3V0OiBObyBzdWNoIGxheW91dCBgJyArIG5hbWUgKyAnYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlcztcbiAgICBpZiggaXMuc3RyaW5nKCBvcHRpb25zLmVsZXMgKSApe1xuICAgICAgZWxlcyA9IGN5LiQoIG9wdGlvbnMuZWxlcyApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gb3B0aW9ucy5lbGVzICE9IG51bGwgPyBvcHRpb25zLmVsZXMgOiBjeS4kKCk7XG4gICAgfVxuXG4gICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXQoIHV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0gKSApO1xuXG4gICAgcmV0dXJuIGxheW91dDtcbiAgfVxuXG59KTtcblxuY29yZWZuLmNyZWF0ZUxheW91dCA9IGNvcmVmbi5tYWtlTGF5b3V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmVmbiA9ICh7XG4gIG5vdGlmeTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggX3AuYmF0Y2hpbmdOb3RpZnkgKXtcbiAgICAgIHZhciBiRWxlcyA9IF9wLmJhdGNoTm90aWZ5RWxlcztcbiAgICAgIHZhciBiVHlwZXMgPSBfcC5iYXRjaE5vdGlmeVR5cGVzO1xuXG4gICAgICBpZiggcGFyYW1zLmVsZXMgKXtcbiAgICAgICAgYkVsZXMubWVyZ2UoIHBhcmFtcy5lbGVzICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhYlR5cGVzLmlkc1sgcGFyYW1zLnR5cGUgXSApe1xuICAgICAgICBiVHlwZXMucHVzaCggcGFyYW1zLnR5cGUgKTtcbiAgICAgICAgYlR5cGVzLmlkc1sgcGFyYW1zLnR5cGUgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYoICFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCApeyByZXR1cm47IH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgLy8gZXhpdCBpZiBkZXN0cm95KCkgY2FsbGVkIG9uIGNvcmUgb3IgcmVuZGVyZXIgaW4gYmV0d2VlbiBmcmFtZXMgIzE0OTkgIzE1MjhcbiAgICBpZiggdGhpcy5pc0Rlc3Ryb3llZCgpIHx8ICFyZW5kZXJlciApeyByZXR1cm47IH1cblxuICAgIHJlbmRlcmVyLm5vdGlmeSggcGFyYW1zICk7XG4gIH0sXG5cbiAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggYm9vbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGNhbGxiYWNrICl7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKCBmYWxzZSApO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKCB0cnVlICk7XG4gIH0sXG5cbiAgc3RhcnRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLmJhdGNoQ291bnQgPT0gbnVsbCApe1xuICAgICAgX3AuYmF0Y2hDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgaWYoIF9wLmJhdGNoQ291bnQgPT09IDAgKXtcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBfcC5iYXRjaGluZ05vdGlmeSA9IHRydWU7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgX3AuYmF0Y2hOb3RpZnlFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzID0gW107XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzLmlkcyA9IHt9O1xuICAgIH1cblxuICAgIF9wLmJhdGNoQ291bnQrKztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVuZEJhdGNoOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5iYXRjaENvdW50LS07XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PT0gMCApe1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaGluZ1N0eWxlID0gZmFsc2U7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgX3AuYmF0Y2hpbmdOb3RpZnkgPSBmYWxzZTtcbiAgICAgIHRoaXMubm90aWZ5KCB7XG4gICAgICAgIHR5cGU6IF9wLmJhdGNoTm90aWZ5VHlwZXMsXG4gICAgICAgIGVsZXM6IF9wLmJhdGNoTm90aWZ5RWxlc1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGJhdGNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBiYXRjaERhdGE6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuYmF0Y2goIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoIG1hcCApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gbWFwWyBpZCBdO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgZWxlLmRhdGEoIGRhdGEgKTtcbiAgICAgIH1cbiAgICB9ICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgcmVuZGVyVG86IGZ1bmN0aW9uKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG5cbiAgICByLnJlbmRlclRvKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJlcjogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcblxuICBmb3JjZVJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICB0aGlzLm5vdGlmeSgge1xuICAgICAgdHlwZTogJ2RyYXcnXG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVzaXplOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcblxuICAgIHRoaXMubm90aWZ5KCB7XG4gICAgICB0eXBlOiAncmVzaXplJ1xuICAgIH0gKTtcblxuICAgIHRoaXMudHJpZ2dlciggJ3Jlc2l6ZScgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgdmFyIFJlbmRlcmVyUHJvdG8gPSBjeS5leHRlbnNpb24oICdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSApO1xuICAgIGlmKCBSZW5kZXJlclByb3RvID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYCVzYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycsIG9wdGlvbnMubmFtZSApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByT3B0cyA9IHV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5XG4gICAgfSApO1xuXG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byggck9wdHMgKTtcbiAgfSxcblxuICBkZXN0cm95UmVuZGVyZXI6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGN5Lm5vdGlmeSggeyB0eXBlOiAnZGVzdHJveScgfSApOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgdmFyIGRvbUVsZSA9IGN5LmNvbnRhaW5lcigpO1xuICAgIGlmKCBkb21FbGUgKXtcbiAgICAgIGRvbUVsZS5fY3lyZWcgPSBudWxsO1xuXG4gICAgICB3aGlsZSggZG9tRWxlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCApe1xuICAgICAgICBkb21FbGUucmVtb3ZlQ2hpbGQoIGRvbUVsZS5jaGlsZE5vZGVzWzBdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuICB9LFxuXG4gIG9uUmVuZGVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICByZXR1cm4gdGhpcy5vbigncmVuZGVyJywgZm4pO1xuICB9LFxuXG4gIG9mZlJlbmRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgcmV0dXJuIHRoaXMub2ZmKCdyZW5kZXInLCBmbik7XG4gIH1cblxufSk7XG5cbmNvcmVmbi5pbnZhbGlkYXRlRGltZW5zaW9ucyA9IGNvcmVmbi5yZXNpemU7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoICcuLi9jb2xsZWN0aW9uJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uKCBlbGVzLCBvcHRzICl7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBlbGVzICkgKXtcbiAgICAgIHJldHVybiB0aGlzLiQoIGVsZXMgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlcyApICl7XG4gICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCBlbGVzICkgKXtcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbiggdGhpcywgZWxlcywgb3B0cyApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbiggdGhpcyApO1xuICB9LFxuXG4gIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLiQoIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc05vZGUoKTtcbiAgICB9ICk7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuXG4gIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLiQoIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKTtcbiAgICB9ICk7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9LFxuXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuXG4gICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVzLnNwYXduU2VsZigpO1xuICAgIH1cbiAgfSxcblxuICBtdXRhYmxlRWxlbWVudHM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gIH1cblxufSk7XG5cbi8vIGFsaWFzZXNcbmNvcmVmbi5lbGVtZW50cyA9IGNvcmVmbi5maWx0ZXIgPSBjb3JlZm4uJDtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoICcuLi9zdHlsZScgKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgc3R5bGU6IGZ1bmN0aW9uKCBuZXdTdHlsZSApe1xuICAgIGlmKCBuZXdTdHlsZSApe1xuICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKCBuZXdTdHlsZSApO1xuXG4gICAgICBzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICB9LFxuXG4gIHNldFN0eWxlOiBmdW5jdGlvbiggc3R5bGUgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIGlzLnN0eWxlc2hlZXQoIHN0eWxlICkgKXtcbiAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSggdGhpcyApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5hcnJheSggc3R5bGUgKSApe1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tSnNvbiggdGhpcywgc3R5bGUgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBzdHlsZSApICl7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21TdHJpbmcoIHRoaXMsIHN0eWxlICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZSggdGhpcyApO1xuICAgIH1cblxuICAgIHJldHVybiBfcC5zdHlsZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uL3dpbmRvdycgKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgYXV0b2xvY2s6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvbG9jayA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBhdXRvdW5zZWxlY3RpZnk6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW46IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICBjYXNlIDA6IC8vIC5wYW4oKVxuICAgICAgcmV0dXJuIHBhbjtcblxuICAgIGNhc2UgMTpcblxuICAgICAgaWYoIGlzLnN0cmluZyggYXJnc1swXSApICl7IC8vIC5wYW4oJ3gnKVxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gcGFuWyBkaW0gXTtcblxuICAgICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggYXJnc1swXSApICl7IC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKCB4ICkgKXtcbiAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXMubnVtYmVyKCB5ICkgKXtcbiAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoICdwYW4gdmlld3BvcnQnICk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjogLy8gLnBhbigneCcsIDEwMClcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIGlzLm51bWJlciggdmFsICkgKXtcbiAgICAgICAgcGFuWyBkaW0gXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHZpZXdwb3J0JyApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSggeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW5CeTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICBjYXNlIDE6XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCggYXJnc1swXSApICl7IC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKCB4ICkgKXtcbiAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggeSApICl7XG4gICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB2aWV3cG9ydCcgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOiAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgaXMubnVtYmVyKCB2YWwgKSApe1xuICAgICAgICBwYW5bIGRpbSBdICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHZpZXdwb3J0JyApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSggeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBmaXQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydCggZWxlbWVudHMsIHBhZGRpbmcgKTtcblxuICAgIGlmKCB2aWV3cG9ydFN0YXRlICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoICdwYW4gem9vbSB2aWV3cG9ydCcgKTtcblxuICAgICAgdGhpcy5ub3RpZnkoIHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRGaXRWaWV3cG9ydDogZnVuY3Rpb24oIGVsZW1lbnRzLCBwYWRkaW5nICl7XG4gICAgaWYoIGlzLm51bWJlciggZWxlbWVudHMgKSAmJiBwYWRkaW5nID09PSB1bmRlZmluZWQgKXsgLy8gZWxlbWVudHMgaXMgb3B0aW9uYWxcbiAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYjtcblxuICAgIGlmKCBpcy5zdHJpbmcoIGVsZW1lbnRzICkgKXtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKCBzZWwgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYm91bmRpbmdCb3goIGVsZW1lbnRzICkgKXsgLy8gYXNzdW1lIGJiXG4gICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICBiYiA9IHtcbiAgICAgICAgeDE6IGJiZS54MSxcbiAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgeTI6IGJiZS55MlxuICAgICAgfTtcblxuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcblxuICAgIH0gZWxzZSBpZiggIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGVsZW1lbnRzICkgKXtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgdmFyIHpvb207XG4gICAgcGFkZGluZyA9IGlzLm51bWJlciggcGFkZGluZyApID8gcGFkZGluZyA6IDA7XG5cbiAgICBpZiggIWlzTmFOKCB3ICkgJiYgIWlzTmFOKCBoICkgJiYgdyA+IDAgJiYgaCA+IDAgJiYgIWlzTmFOKCBiYi53ICkgJiYgIWlzTmFOKCBiYi5oICkgJiYgIGJiLncgPiAwICYmIGJiLmggPiAwICl7XG4gICAgICB6b29tID0gTWF0aC5taW4oICh3IC0gMiAqIHBhZGRpbmcpIC8gYmIudywgKGggLSAyICogcGFkZGluZykgLyBiYi5oICk7XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICB2YXIgcGFuID0geyAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20gKiAoIGJiLngxICsgYmIueDIgKSkgLyAyLFxuICAgICAgICB5OiAoaCAtIHpvb20gKiAoIGJiLnkxICsgYmIueTIgKSkgLyAyXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHBhblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgbWluWm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5taW5ab29tO1xuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCB6b29tICkgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUubWluWm9vbSA9IHpvb207XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbWF4Wm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCB6b29tICkgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA9IHpvb207XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgem9vbTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG4gICAgdmFyIHpvb207XG5cbiAgICBpZiggcGFyYW1zID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggcGFyYW1zICkgKXsgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgIHpvb20gPSBwYXJhbXM7XG5cbiAgICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBwYXJhbXMgKSApeyAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcblxuICAgICAgaWYoIHBhcmFtcy5wb3NpdGlvbiApe1xuICAgICAgICB2YXIgcCA9IHBhcmFtcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgICB2YXIgeiA9IHRoaXMuX3ByaXZhdGUuem9vbTtcblxuICAgICAgICBwb3MgPSB7IC8vIGNvbnZlcnQgdG8gcmVuZGVyZWQgcHhcbiAgICAgICAgICB4OiBwLnggKiB6ICsgcGFuLngsXG4gICAgICAgICAgeTogcC55ICogeiArIHBhbi55XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiggcG9zICYmICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm4gdGhpczsgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgIH1cblxuICAgIGlmKCAhaXMubnVtYmVyKCB6b29tICkgfHwgKCBwb3MgJiYgKCFpcy5udW1iZXIoIHBvcy54ICkgfHwgIWlzLm51bWJlciggcG9zLnkgKSkgKSApe1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgIH1cblxuICAgIC8vIGNyb3Agem9vbVxuICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG5cbiAgICBpZiggcG9zICl7IC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIHpvb20xID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcblxuICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKHBvcy54IC0gcGFuMS54KSArIHBvcy54LFxuICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChwb3MueSAtIHBhbjEueSkgKyBwb3MueVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuMjtcblxuICAgICAgdmFyIHBvc0NoYW5nZWQgPSBwYW4xLnggIT09IHBhbjIueCB8fCBwYW4xLnkgIT09IHBhbjIueTtcbiAgICAgIHRoaXMudHJpZ2dlciggJyB6b29tICcgKyAocG9zQ2hhbmdlZCA/ICcgcGFuICcgOiAnJykgKyAnIHZpZXdwb3J0ICcgKTtcblxuICAgIH0gZWxzZSB7IC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgdGhpcy50cmlnZ2VyKCAnem9vbSB2aWV3cG9ydCcgKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSggeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB2aWV3cG9ydDogZnVuY3Rpb24oIG9wdHMgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgIHZhciB6b29tRmFpbGVkID0gZmFsc2U7XG4gICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgaWYoICFvcHRzICl7IHJldHVybiB0aGlzOyB9XG4gICAgaWYoICFpcy5udW1iZXIoIG9wdHMuem9vbSApICl7IHpvb21EZWZkID0gZmFsc2U7IH1cbiAgICBpZiggIWlzLnBsYWluT2JqZWN0KCBvcHRzLnBhbiApICl7IHBhbkRlZmQgPSBmYWxzZTsgfVxuICAgIGlmKCAhem9vbURlZmQgJiYgIXBhbkRlZmQgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIGlmKCB6b29tRGVmZCApe1xuICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgIGlmKCB6IDwgX3AubWluWm9vbSB8fCB6ID4gX3AubWF4Wm9vbSB8fCAhX3Auem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnpvb20gPSB6O1xuXG4gICAgICAgIGV2ZW50cy5wdXNoKCAnem9vbScgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGFuRGVmZCAmJiAoIXpvb21GYWlsZWQgfHwgIW9wdHMuY2FuY2VsT25GYWlsZWRab29tKSAmJiBfcC5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgaWYoIGlzLm51bWJlciggcC54ICkgKXtcbiAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggaXMubnVtYmVyKCBwLnkgKSApe1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhcGFuRmFpbGVkICl7XG4gICAgICAgIGV2ZW50cy5wdXNoKCAncGFuJyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBldmVudHMubGVuZ3RoID4gMCApe1xuICAgICAgZXZlbnRzLnB1c2goICd2aWV3cG9ydCcgKTtcbiAgICAgIHRoaXMudHJpZ2dlciggZXZlbnRzLmpvaW4oICcgJyApICk7XG5cbiAgICAgIHRoaXMubm90aWZ5KCB7XG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uKCBlbGVtZW50cyApe1xuICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbiggZWxlbWVudHMgKTtcblxuICAgIGlmKCBwYW4gKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoICdwYW4gdmlld3BvcnQnICk7XG5cbiAgICAgIHRoaXMubm90aWZ5KCB7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZ2V0Q2VudGVyUGFuOiBmdW5jdGlvbiggZWxlbWVudHMsIHpvb20gKXtcbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggaXMuc3RyaW5nKCBlbGVtZW50cyApICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSBlbHNlIGlmKCAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlbWVudHMgKSApe1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cblxuICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuXG4gICAgdmFyIHBhbiA9IHsgLy8gbWlkZGxlXG4gICAgICB4OiAodyAtIHpvb20gKiAoIGJiLngxICsgYmIueDIgKSkgLyAyLFxuICAgICAgeTogKGggLSB6b29tICogKCBiYi55MSArIGJiLnkyICkpIC8gMlxuICAgIH07XG5cbiAgICByZXR1cm4gcGFuO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3cG9ydCgge1xuICAgICAgcGFuOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHpvb206IDFcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG5cbiAgICByZXR1cm4gKCBfcC5zaXplQ2FjaGUgPSBfcC5zaXplQ2FjaGUgfHwgKCBjb250YWluZXIgPyAoZnVuY3Rpb24oKXtcbiAgICAgIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGNvbnRhaW5lciApO1xuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uKCBuYW1lICl7IHJldHVybiBwYXJzZUZsb2F0KCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgKTsgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLSB2YWwoJ3BhZGRpbmctbGVmdCcpIC0gdmFsKCdwYWRkaW5nLXJpZ2h0JykgLSB2YWwoJ2JvcmRlci1sZWZ0LXdpZHRoJykgLSB2YWwoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpIC0gdmFsKCdib3JkZXItdG9wLXdpZHRoJykgLSB2YWwoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICAgICAgfTtcbiAgICB9KSgpIDogeyAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9ICkgKTtcbiAgfSxcblxuICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkud2lkdGg7XG4gIH0sXG5cbiAgaGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnNpemUoKS5oZWlnaHQ7XG4gIH0sXG5cbiAgZXh0ZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG5cbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAoIHJiLngxIC0gcGFuLnggKSAvIHpvb20sXG4gICAgICB4MjogKCByYi54MiAtIHBhbi54ICkgLyB6b29tLFxuICAgICAgeTE6ICggcmIueTEgLSBwYW4ueSApIC8gem9vbSxcbiAgICAgIHkyOiAoIHJiLnkyIC0gcGFuLnkgKSAvIHpvb21cbiAgICB9O1xuXG4gICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgYi5oID0gYi55MiAtIGIueTE7XG5cbiAgICByZXR1cm4gYjtcbiAgfSxcblxuICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiB3aWR0aCxcbiAgICAgIHkyOiBoZWlnaHQsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4uY2VudHJlID0gY29yZWZuLmNlbnRlcjtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvcmVmbi5hdXRvbG9ja05vZGVzID0gY29yZWZuLmF1dG9sb2NrO1xuY29yZWZuLmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbi5hdXRvdW5ncmFiaWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4vLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxuLy8gZS5nLlxuLy8gdmFyIGZvbyA9IGRlZmluZS5mb28oeyAvKiBwYXJhbXMuLi4gKi8gfSlcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKCAnLi9zZWxlY3RvcicgKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSggJy4vcHJvbWlzZScgKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoICcuL2V2ZW50JyApO1xudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoICcuL2FuaW1hdGlvbicgKTtcblxudmFyIGRlZmluZSA9IHtcblxuICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICBkYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBvblNldDogZnVuY3Rpb24oIHNlbGYgKXt9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiggc2VsZiApeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwoIG5hbWUsIHZhbHVlICl7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7XG5cbiAgICAgIC8vIC5kYXRhKCdmb28nLCAuLi4pXG4gICAgICBpZiggaXMuc3RyaW5nKCBuYW1lICkgKXsgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiggcC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApeyAvLyBzZXRcbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzWyBuYW1lIF07XG4gICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBhbGxbIGkgXSApICl7XG4gICAgICAgICAgICAgICAgYWxsWyBpIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICAgIGlmKCBwLnVwZGF0ZVN0eWxlICl7IHNlbGYudXBkYXRlU3R5bGUoKTsgfVxuXG4gICAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgICBwLm9uU2V0KCBzZWxmICk7XG5cbiAgICAgICAgICAgIGlmKCBwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50ICl7XG4gICAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyAuZGF0YSh7ICdmb28nOiAnYmFyJyB9KVxuICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiBpcy5wbGFpbk9iamVjdCggbmFtZSApICl7IC8vIGV4dGVuZFxuICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgdmFyIGssIHY7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIG9iaiApO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIGsgPSBrZXlzWyBpIF07XG4gICAgICAgICAgdiA9IG9ialsgayBdO1xuXG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1sgayBdO1xuICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIGVsZSA9IGFsbFtqXTtcblxuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGVsZSApICl7XG4gICAgICAgICAgICAgICAgZWxlLl9wcml2YXRlWyBwLmZpZWxkIF1bIGsgXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICB9XG5cbiAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgfSBlbHNlIGlmKCBwLmFsbG93QmluZGluZyAmJiBpcy5mbiggbmFtZSApICl7IC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbiggcC5iaW5kaW5nRXZlbnQsIGZuICk7XG5cbiAgICAgIC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBkYXRhXG5cbiAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwoIG5hbWVzICl7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcbiAgICAgIGlmKCBpcy5zdHJpbmcoIG5hbWVzICkgKXsgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoIC9cXHMrLyApO1xuICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbDsgaSsrICl7IC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1sgaSBdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZygga2V5ICkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICAgIGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICB9IGVsc2UgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIF9wcml2YXRlRmllbGRzICk7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgaWYoIHZhbGlkS2V5VG9EZWxldGUgKXtcbiAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwLnRyaWdnZXJFdmVudCApe1xuICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLmV2ZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gcmVtb3ZlRGF0YVxuXG4gIC8vIGV2ZW50IGZ1bmN0aW9uIHJldXNhYmxlIHN0dWZmXG4gIGV2ZW50OiB7XG4gICAgcmVnZXg6IC8oXFx3KykoXFwuKD86XFx3K3xcXCopKT8vLCAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuICAgIHVuaXZlcnNhbE5hbWVzcGFjZTogJy4qJywgLy8gbWF0Y2hlcyBhcyBpZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkIGFuZCBwcmV2ZW50cyB1c2VycyBmcm9tIHVuYmluZGluZyBhY2NpZGVudGFsbHlcbiAgICBvcHRpb25hbFR5cGVSZWdleDogLyhcXHcrKT8oXFwuKD86XFx3K3xcXCopKT8vLFxuICAgIGZhbHNlQ2FsbGJhY2s6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfVxuICB9LFxuXG4gIC8vIGV2ZW50IGJpbmRpbmdcbiAgb246IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBmYWxzZSxcbiAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBvbkltcGwoIGV2ZW50cywgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKCBldmVudHMgKTtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgZGF0YVxuICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYoIGlzLmZuKCBzZWxlY3RvciApIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLmZuKCBkYXRhICkgfHwgZGF0YSA9PT0gZmFsc2UgKXsgLy8gZGF0YSBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzbid0IGEgY2FsbGJhY2ssIHdlIGNhbid0IHJlYWxseSBkbyBhbnl0aGluZ1xuICAgICAgLy8gKGNhbid0IHNwZWFrIGZvciBtYXBwZWQgZXZlbnRzIGFyZyB2ZXJzaW9uKVxuICAgICAgaWYoICEoaXMuZm4oIGNhbGxiYWNrICkgfHwgY2FsbGJhY2sgPT09IGZhbHNlKSAmJiBldmVudHNJc1N0cmluZyApe1xuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH1cblxuICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBtYXBbIGV2ZW50cyBdID0gY2FsbGJhY2s7XG4gICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZXZlbnRzICk7XG5cbiAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKyApe1xuICAgICAgICB2YXIgZXZ0cyA9IGtleXNba107XG5cbiAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbIGV2dHMgXTtcbiAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzLmZuKCBjYWxsYmFjayApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoIC9cXHMrLyApO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1sgaSBdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyggZXZ0ICkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggZGVmaW5lLmV2ZW50LnJlZ2V4ICk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjaywgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsIC8vIGV4dHJhIGRhdGEgaW4gZXZlbnRPYmouZGF0YVxuICAgICAgICAgICAgICBkZWxlZ2F0ZWQ6IHNlbGVjdG9yID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBldnQgaXMgZGVsZWdhdGVkXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvciwgLy8gdGhlIHNlbGVjdG9yIHRvIG1hdGNoIGZvciBkZWxlZ2F0ZWQgZXZlbnRzXG4gICAgICAgICAgICAgIHNlbE9iajogbmV3IFNlbGVjdG9yKCBzZWxlY3RvciApLCAvLyBjYWNoZWQgc2VsZWN0b3Igb2JqZWN0IHRvIHNhdmUgcmVidWlsZGluZ1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLCAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgLy8gdGhlIGV2ZW50IG5hbWVzcGFjZSAoZS5nLiBcIi5mb29cIilcbiAgICAgICAgICAgICAgdW5iaW5kU2VsZk9uVHJpZ2dlcjogcC51bmJpbmRTZWxmT25UcmlnZ2VyLFxuICAgICAgICAgICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBwLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIsXG4gICAgICAgICAgICAgIGJpbmRlcnM6IGFsbCAvLyB3aG8gYm91bmQgdG9nZXRoZXJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgIHZhciBfcCA9IGFsbFsgaiBdLl9wcml2YXRlID0gYWxsWyBqIF0uX3ByaXZhdGUgfHwge307XG5cbiAgICAgICAgICAgICAgX3AubGlzdGVuZXJzID0gX3AubGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICAgICAgICBfcC5saXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBvblxuXG4gIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiggcHJvdG8gKXtcbiAgICB2YXIgcCA9IHByb3RvO1xuXG4gICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICBwLnJlbW92ZUxpc3RlbmVyID0gcC51bmxpc3RlbiA9IHAudW5iaW5kID0gcC5vZmY7XG4gICAgcC5lbWl0ID0gcC50cmlnZ2VyO1xuXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiggZXZlbnRzLCBzZWxlY3RvciApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiggZSApe1xuICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KCBzZWxmLCBvZmZBcmdzICk7XG5cbiAgICAgICAgICByZXNvbHZlKCBlICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KCBbIGNhbGxiYWNrIF0gKTtcbiAgICAgICAgdmFyIG9mZkFyZ3MgPSBvbkFyZ3MuY29uY2F0KCBbXSApO1xuXG4gICAgICAgIHNlbGYub24uYXBwbHkoIHNlbGYsIG9uQXJncyApO1xuICAgICAgfSApO1xuICAgIH07XG4gIH0sXG5cbiAgb2ZmOiBmdW5jdGlvbiBvZmZJbXBsKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiggZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2sgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSBpcy5zdHJpbmcoIGV2ZW50cyApO1xuXG4gICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApeyAvLyB0aGVuIHVuYmluZCBhbGxcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIGFsbFsgaSBdLl9wcml2YXRlID0gYWxsWyBpIF0uX3ByaXZhdGUgfHwge307XG5cbiAgICAgICAgICBfcC5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfVxuXG4gICAgICBpZiggaXMuZm4oIHNlbGVjdG9yICkgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBldmVudHMgKTtcblxuICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrICl7XG4gICAgICAgIHZhciBldnRzID0ga2V5c1trXTtcblxuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1sgZXZ0cyBdO1xuXG4gICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICBjYWxsYmFjayA9IGRlZmluZS5ldmVudC5mYWxzZUNhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoIC9cXHMrLyApO1xuICAgICAgICBmb3IoIHZhciBoID0gMDsgaCA8IGV2dHMubGVuZ3RoOyBoKysgKXtcbiAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1sgaCBdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyggZXZ0ICkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggZGVmaW5lLmV2ZW50Lm9wdGlvbmFsVHlwZVJlZ2V4ICk7IC8vIFt0eXBlXVsubmFtZXNwYWNlXVxuICAgICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXSA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7IC8vXG4gICAgICAgICAgICAgIHZhciBfcCA9IGFsbFsgaSBdLl9wcml2YXRlID0gYWxsWyBpIF0uX3ByaXZhdGUgfHwge307XG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsaXN0ZW5lcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbIGogXTtcbiAgICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSAhdHlwZSB8fCBsaXN0ZW5lci50eXBlID09PSB0eXBlO1xuICAgICAgICAgICAgICAgIHZhciBjYk1hdGNoZXMgPSAhY2FsbGJhY2sgfHwgY2FsbGJhY2sgPT09IGxpc3RlbmVyLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgY2JNYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGxpc3RlbmVyIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgICAgICAgICBpZiggbGlzdGVuZXJNYXRjaGVzICl7XG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKCBqLCAxICk7XG4gICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIGZvciBsaXN0ZW5lcnNcbiAgICAgICAgICAgIH0gLy8gZm9yIGFsbFxuICAgICAgICAgIH0gLy8gaWYgbWF0Y2hcbiAgICAgICAgfSAvLyBmb3IgZXZlbnRzIGFycmF5XG5cbiAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gb2ZmXG5cbiAgdHJpZ2dlcjogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyaWdnZXJJbXBsKCBldmVudHMsIGV4dHJhUGFyYW1zLCBmblRvVHJpZ2dlciApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBldmVudHNJc1N0cmluZyA9IGlzLnN0cmluZyggZXZlbnRzICk7XG4gICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSBpcy5wbGFpbk9iamVjdCggZXZlbnRzICk7XG4gICAgICB2YXIgZXZlbnRzSXNFdmVudCA9IGlzLmV2ZW50KCBldmVudHMgKTtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB0aGlzLl9wcml2YXRlIHx8IHt9O1xuICAgICAgdmFyIGN5ID0gX3AuY3kgfHwgKCBpcy5jb3JlKCB0aGlzICkgPyB0aGlzIDogbnVsbCApO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5ID8gY3kuaGFzQ29tcG91bmROb2RlcygpIDogZmFsc2U7XG5cbiAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIG1ha2UgYSBwbGFpbiBldmVudCBvYmplY3QgZm9yIGVhY2ggZXZlbnQgbmFtZVxuICAgICAgICB2YXIgZXZ0cyA9IGV2ZW50cy5zcGxpdCggL1xccysvICk7XG4gICAgICAgIGV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzWyBpIF07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKCBldnQgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCBkZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICB2YXIgZXZlbnRBcmdPYmogPSBldmVudHM7XG5cbiAgICAgICAgZXZlbnRzID0gWyBldmVudEFyZ09iaiBdO1xuICAgICAgfVxuXG4gICAgICBpZiggZXh0cmFQYXJhbXMgKXtcbiAgICAgICAgaWYoICFpcy5hcnJheSggZXh0cmFQYXJhbXMgKSApeyAvLyBtYWtlIHN1cmUgZXh0cmEgcGFyYW1zIGFyZSBpbiBhbiBhcnJheSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICBleHRyYVBhcmFtcyA9IFsgZXh0cmFQYXJhbXMgXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCB3ZSd2ZSBnb3Qgbm90aGluZ1xuICAgICAgICBleHRyYVBhcmFtcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKyApeyAvLyB0cmlnZ2VyIGVhY2ggZXZlbnQgaW4gb3JkZXJcbiAgICAgICAgdmFyIGV2dE9iaiA9IGV2ZW50c1sgaSBdO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoXG4gICAgICAgICAgdmFyIHRyaWdnZXJlciA9IGFsbFsgaiBdO1xuICAgICAgICAgIHZhciBfcCA9IHRyaWdnZXJlci5fcHJpdmF0ZSA9IHRyaWdnZXJlci5fcHJpdmF0ZSB8fCB7fTtcbiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gX3AubGlzdGVuZXJzID0gX3AubGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICAgIHZhciB0cmlnZ2VyZXJJc0VsZW1lbnQgPSBpcy5lbGVtZW50KCB0cmlnZ2VyZXIgKTtcbiAgICAgICAgICB2YXIgYnViYmxlVXAgPSB0cmlnZ2VyZXJJc0VsZW1lbnQgfHwgcGFyYW1zLmxheW91dDtcblxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgZXZlbnQgZm9yIHRoaXMgZWxlbWVudCBmcm9tIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgICB2YXIgZXZ0O1xuXG4gICAgICAgICAgaWYoIGV2ZW50c0lzRXZlbnQgKXsgLy8gdGhlbiBqdXN0IGdldCB0aGUgb2JqZWN0XG4gICAgICAgICAgICBldnQgPSBldnRPYmo7XG5cbiAgICAgICAgICAgIGV2dC5jeVRhcmdldCA9IGV2dC5jeVRhcmdldCB8fCB0cmlnZ2VyZXI7XG4gICAgICAgICAgICBldnQuY3kgPSBldnQuY3kgfHwgY3k7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHdlIGhhdmUgdG8gbWFrZSBvbmVcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFdmVudCggZXZ0T2JqLCB7XG4gICAgICAgICAgICAgIGN5VGFyZ2V0OiB0cmlnZ2VyZXIsXG4gICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldnRPYmoubmFtZXNwYWNlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgYSBsYXlvdXQgd2FzIHNwZWNpZmllZCwgdGhlbiBwdXQgaXQgaW4gdGhlIHR5cGVkIGV2ZW50XG4gICAgICAgICAgaWYoIGV2dE9iai5sYXlvdXQgKXtcbiAgICAgICAgICAgIGV2dC5sYXlvdXQgPSBldnRPYmoubGF5b3V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRyaWdnZXJlZCBieSBsYXlvdXQsIHB1dCBpbiBldmVudFxuICAgICAgICAgIGlmKCBwYXJhbXMubGF5b3V0ICl7XG4gICAgICAgICAgICBldnQubGF5b3V0ID0gdHJpZ2dlcmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgICAgICBpZiggZXZ0LmN5UG9zaXRpb24gKXtcbiAgICAgICAgICAgIHZhciBwb3MgPSBldnQuY3lQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgICBldnQuY3lSZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGZuVG9UcmlnZ2VyICl7IC8vIHRoZW4gb3ZlcnJpZGUgdGhlIGxpc3RlbmVycyBsaXN0IHdpdGgganVzdCB0aGUgb25lIHdlIHNwZWNpZmllZFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gWyB7XG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogZXZ0Lm5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgdHlwZTogZXZ0LnR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBmblRvVHJpZ2dlclxuICAgICAgICAgICAgfSBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgbGlzdGVuZXJzLmxlbmd0aDsgaysrICl7IC8vIGNoZWNrIGVhY2ggbGlzdGVuZXJcbiAgICAgICAgICAgIHZhciBsaXMgPSBsaXN0ZW5lcnNbIGsgXTtcbiAgICAgICAgICAgIHZhciBuc01hdGNoZXMgPSAhbGlzLm5hbWVzcGFjZSB8fCBsaXMubmFtZXNwYWNlID09PSBldnQubmFtZXNwYWNlIHx8IGxpcy5uYW1lc3BhY2UgPT09IGRlZmluZS5ldmVudC51bml2ZXJzYWxOYW1lc3BhY2U7XG4gICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSBsaXMudHlwZSA9PT0gZXZ0LnR5cGU7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWF0Y2hlcyA9IGxpcy5kZWxlZ2F0ZWQgPyAoIHRyaWdnZXJlciAhPT0gZXZ0LmN5VGFyZ2V0ICYmIGlzLmVsZW1lbnQoIGV2dC5jeVRhcmdldCApICYmIGxpcy5zZWxPYmoubWF0Y2hlcyggZXZ0LmN5VGFyZ2V0ICkgKSA6ICh0cnVlKTsgLy8gd2UncmUgbm90IGdvaW5nIHRvIHZhbGlkYXRlIHRoZSBoaWVyYXJjaHk7IHRoYXQncyB0b28gZXhwZW5zaXZlXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIHRhcmdldE1hdGNoZXM7XG5cbiAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXsgLy8gdGhlbiB0cmlnZ2VyIGl0XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gWyBldnQgXTtcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KCBleHRyYVBhcmFtcyApOyAvLyBhZGQgZXh0cmEgcGFyYW1zIHRvIGFyZ3MgbGlzdFxuXG4gICAgICAgICAgICAgIGlmKCBsaXMuZGF0YSApeyAvLyBhZGQgb24gZGF0YSBwbHVnZ2VkIGludG8gYmluZGluZ1xuICAgICAgICAgICAgICAgIGV2dC5kYXRhID0gbGlzLmRhdGE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG9yIGNsZWFyIGl0IGluIGNhc2UgdGhlIGV2ZW50IG9iaiBpcyByZXVzZWRcbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kU2VsZk9uVHJpZ2dlciB8fCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoIGssIDEgKTtcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiBkZWxldGUgdGhlIGxpc3RlbmVyIGZvciBhbGwgYmluZGVyc1xuICAgICAgICAgICAgICAgIHZhciBiaW5kZXJzID0gbGlzLmJpbmRlcnM7XG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBiaW5kZXJzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgICAgICAgICAgICB2YXIgYmluZGVyID0gYmluZGVyc1sgbCBdO1xuICAgICAgICAgICAgICAgICAgaWYoICFiaW5kZXIgfHwgYmluZGVyID09PSB0cmlnZ2VyZXIgKXsgY29udGludWU7IH0gLy8gYWxyZWFkeSBoYW5kbGVkIHRyaWdnZXJlciBvciB3ZSBjYW4ndCBoYW5kbGUgaXRcblxuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVycyA9IGJpbmRlci5fcHJpdmF0ZS5saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICBmb3IoIHZhciBtID0gMDsgbSA8IGJpbmRlckxpc3RlbmVycy5sZW5ndGg7IG0rKyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXIgPSBiaW5kZXJMaXN0ZW5lcnNbIG0gXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggYmluZGVyTGlzdGVuZXIgPT09IGxpcyApeyAvLyBkZWxldGUgbGlzdGVuZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgYmluZGVyTGlzdGVuZXJzLnNwbGljZSggbSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHJ1biB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBsaXMuZGVsZWdhdGVkID8gZXZ0LmN5VGFyZ2V0IDogdHJpZ2dlcmVyO1xuICAgICAgICAgICAgICB2YXIgcmV0ID0gbGlzLmNhbGxiYWNrLmFwcGx5KCBjb250ZXh0LCBhcmdzICk7XG5cbiAgICAgICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgfHwgZXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKXtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGRvbid0IGJ1YmJsZVxuICAgICAgICAgICAgICAgIGJ1YmJsZVVwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGlzIGEgc2hvcnRoYW5kIGZvciBzdG9wcGluZyBwcm9wYWdhdGlvbiBhbmQgcHJldmVudGluZyB0aGUgZGVmLiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG4gICAgICAgICAgfSAvLyBmb3IgZWFjaCBsaXN0ZW5lclxuXG4gICAgICAgICAgLy8gYnViYmxlIHVwIGV2ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgIGlmKCBidWJibGVVcCApe1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kcyA/IHRyaWdnZXJlci5fcHJpdmF0ZS5wYXJlbnQgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5sZW5ndGggIT09IDA7XG5cbiAgICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXsgLy8gdGhlbiBidWJibGUgdXAgdG8gcGFyZW50XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICAgICAgcGFyZW50LnRyaWdnZXIoIGV2dCApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBidWJibGUgdXAgdG8gdGhlIGNvcmVcbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggZXZ0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZm9yIGVhY2ggb2YgYWxsXG4gICAgICB9IC8vIGZvciBlYWNoIGV2ZW50XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIHRyaWdnZXJcblxuICBhbmltYXRlZDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVkSW1wbCgpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZWRcblxuICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFsgaSBdO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sIC8vIGNsZWFyUXVldWVcblxuICBkZWxheTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCB7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9ICk7XG4gICAgfTtcbiAgfSwgLy8gZGVsYXlcblxuICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oIHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0gKTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGFuaW1hdGlvbjogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwoIHByb3BlcnRpZXMsIHBhcmFtcyApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG5cbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKCBwcm9wZXJ0aWVzLmR1cmF0aW9uICl7XG4gICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyggcHJvcGVydGllcyApLmxlbmd0aCA9PT0gMDtcblxuICAgICAgaWYoIHByb3BlcnRpZXNFbXB0eSApe1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbiggYWxsWzBdLCBwcm9wZXJ0aWVzICk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZS5nZXRQcm9wc0xpc3QoIHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MgKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAmJiBpc0VsZXMgKXtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgLyB6b29tLFxuICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvIHpvb21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuICAgICAgaWYoIHByb3BlcnRpZXMucGFuQnkgJiYgaXNDb3JlICl7XG4gICAgICAgIHZhciBwYW5CeSA9IHByb3BlcnRpZXMucGFuQnk7XG4gICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG4gICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG4gICAgICBpZiggY2VudGVyICYmIGlzQ29yZSApe1xuICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKCBjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tICk7XG5cbiAgICAgICAgaWYoIGNlbnRlclBhbiApe1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgaWYoIHByb3BlcnRpZXMuZml0ICYmIGlzQ29yZSApe1xuICAgICAgICB2YXIgZml0ID0gcHJvcGVydGllcy5maXQ7XG4gICAgICAgIHZhciBmaXRWcCA9IGN5LmdldEZpdFZpZXdwb3J0KCBmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nICk7XG5cbiAgICAgICAgaWYoIGZpdFZwICl7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBmaXRWcC5wYW47XG4gICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbiggYWxsWzBdLCBwcm9wZXJ0aWVzICk7XG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZVxuXG4gIGFuaW1hdGU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgZm5QYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCBwYXJhbXMgKXtcbiAgICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsWyBpIF07XG4gICAgICAgIHZhciBxdWV1ZSA9IGVsZS5hbmltYXRlZCgpICYmIChwcm9wZXJ0aWVzLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcHJvcGVydGllcy5xdWV1ZSk7XG5cbiAgICAgICAgdmFyIGFuaSA9IGVsZS5hbmltYXRpb24oIHByb3BlcnRpZXMsIChxdWV1ZSA/IHsgcXVldWU6IHRydWUgfSA6IHVuZGVmaW5lZCkgKTtcblxuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9O1xuICB9LCAvLyBhbmltYXRlXG5cbiAgc3RvcDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKCBjbGVhclF1ZXVlLCBqdW1wVG9FbmQgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFsgaSBdO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBhbmlzID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGFuaSA9IGFuaXNbIGogXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICBpZigganVtcFRvRW5kICl7XG4gICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgYW5pX3AuZHVyYXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBxdWV1ZSBvZiBmdXR1cmUgYW5pbWF0aW9uc1xuICAgICAgICBpZiggY2xlYXJRdWV1ZSApe1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFqdW1wVG9FbmQgKXtcbiAgICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuICAgICAgY3kubm90aWZ5KCB7XG4gICAgICAgIGVsZXM6IHRoaXMsXG4gICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbkV2ZW50IG9iamVjdCBiYXNlZCBvbiBqUXVlcnkgZXZlbnRzLCBNSVQgbGljZW5zZVxuXG5odHRwczovL2pxdWVyeS5vcmcvbGljZW5zZS9cbmh0dHBzOi8vdGxkcmxlZ2FsLmNvbS9saWNlbnNlL21pdC1saWNlbnNlXG5odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiovXG5cbnZhciBFdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICl7XG4gIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICBpZiggISh0aGlzIGluc3RhbmNlb2YgRXZlbnQpICl7XG4gICAgcmV0dXJuIG5ldyBFdmVudCggc3JjLCBwcm9wcyApO1xuICB9XG5cbiAgLy8gRXZlbnQgb2JqZWN0XG4gIGlmKCBzcmMgJiYgc3JjLnR5cGUgKXtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKCBzcmMuZGVmYXVsdFByZXZlbnRlZCApID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuXG4gIC8vIEV2ZW50IHR5cGVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnR5cGUgPSBzcmM7XG4gIH1cblxuICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICBpZiggcHJvcHMgKXtcbiAgICAvLyB1dGlsLmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblxuICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgIHRoaXMuY3lUYXJnZXQgPSBwcm9wcy5jeVRhcmdldDtcbiAgICB0aGlzLmN5UG9zaXRpb24gPSBwcm9wcy5jeVBvc2l0aW9uO1xuICAgIHRoaXMuY3lSZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMuY3lSZW5kZXJlZFBvc2l0aW9uO1xuICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIHRoaXMuZGF0YSA9IHByb3BzLmRhdGE7XG4gICAgdGhpcy5tZXNzYWdlID0gcHJvcHMubWVzc2FnZTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn07XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCl7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpe1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmKCAhZSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYoIGUucHJldmVudERlZmF1bHQgKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYoICFlICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYoIGUuc3RvcFByb3BhZ2F0aW9uICl7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuL2RlZmluZScgKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4vY29sbGVjdGlvbicgKTtcbnZhciBDb3JlID0gcmVxdWlyZSggJy4vY29yZScgKTtcbnZhciBpbmNFeHRzID0gcmVxdWlyZSggJy4vZXh0ZW5zaW9ucycgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xuXG4vLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBleHRlbnNpb25zID0ge307XG5cbi8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24oIHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQgKXtcblxuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiggZmllbGQgKXtcbiAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCByZWdpc3RlciBgJyArIG5hbWUgKyAnYCBmb3IgYCcgKyB0eXBlICsgJ2Agc2luY2UgYCcgKyBmaWVsZCArICdgIGFscmVhZHkgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgYW5kIGNhbiBub3QgYmUgb3ZlcnJpZGRlbicgKTtcbiAgfTtcblxuICBpZiggdHlwZSA9PT0gJ2NvcmUnICl7XG4gICAgaWYoIENvcmUucHJvdG90eXBlWyBuYW1lIF0gKXtcbiAgICAgIHJldHVybiBvdmVycmlkZUVyciggbmFtZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb3JlLnByb3RvdHlwZVsgbmFtZSBdID0gcmVnaXN0cmFudDtcbiAgICB9XG5cbiAgfSBlbHNlIGlmKCB0eXBlID09PSAnY29sbGVjdGlvbicgKXtcbiAgICBpZiggQ29sbGVjdGlvbi5wcm90b3R5cGVbIG5hbWUgXSApe1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKCBuYW1lICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlWyBuYW1lIF0gPSByZWdpc3RyYW50O1xuICAgIH1cblxuICB9IGVsc2UgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICByZWdpc3RyYW50LmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggIWlzLnBsYWluT2JqZWN0KCB0aGlzLl9wcml2YXRlICkgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgfTtcblxuICAgIHZhciBsYXlvdXRQcm90byA9IExheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCByZWdpc3RyYW50LnByb3RvdHlwZSApO1xuXG4gICAgdmFyIG9wdExheW91dEZucyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbIGkgXTtcblxuICAgICAgbGF5b3V0UHJvdG9bIGZuTmFtZSBdID0gbGF5b3V0UHJvdG9bIGZuTmFtZSBdIHx8IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuICAgIH1cblxuICAgIC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcbiAgICBpZiggbGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1biApe1xuICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24oKXsgdGhpcy5zdGFydCgpOyByZXR1cm4gdGhpczsgfTtcbiAgICB9IGVsc2UgaWYoICFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24oKXsgdGhpcy5ydW4oKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgfVxuXG4gICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmKCBvcHRzICYmIG9wdHMuYW5pbWF0ZSApe1xuICAgICAgICB2YXIgYW5pcyA9IHRoaXMuYW5pbWF0aW9ucztcblxuICAgICAgICBpZiggYW5pcyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYW5pcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgYW5pc1sgaSBdLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHJlZ1N0b3AgKXtcbiAgICAgICAgcmVnU3RvcC5jYWxsKCB0aGlzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoICdsYXlvdXRzdG9wJyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgaWYoICFsYXlvdXRQcm90by5kZXN0cm95ICl7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGxheW91dFByb3RvLm9uID0gZGVmaW5lLm9uKCB7IGxheW91dDogdHJ1ZSB9ICk7XG4gICAgbGF5b3V0UHJvdG8ub25lID0gZGVmaW5lLm9uKCB7IGxheW91dDogdHJ1ZSwgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9ICk7XG4gICAgbGF5b3V0UHJvdG8ub25jZSA9IGRlZmluZS5vbiggeyBsYXlvdXQ6IHRydWUsIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSApO1xuICAgIGxheW91dFByb3RvLm9mZiA9IGRlZmluZS5vZmYoIHsgbGF5b3V0OiB0cnVlIH0gKTtcbiAgICBsYXlvdXRQcm90by50cmlnZ2VyID0gZGVmaW5lLnRyaWdnZXIoIHsgbGF5b3V0OiB0cnVlIH0gKTtcblxuICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbiggbGF5b3V0UHJvdG8gKTtcblxuICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuXG4gIH0gZWxzZSBpZiggdHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnICl7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuXG4gICAgdmFyIEJhc2VSZW5kZXJlciA9IGdldEV4dGVuc2lvbiggJ3JlbmRlcmVyJywgJ2Jhc2UnICk7XG4gICAgdmFyIGJQcm90byA9IEJhc2VSZW5kZXJlci5wcm90b3R5cGU7XG4gICAgdmFyIFJlZ2lzdHJhbnRSZW5kZXJlciA9IHJlZ2lzdHJhbnQ7XG4gICAgdmFyIHJQcm90byA9IHJlZ2lzdHJhbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIFJlbmRlcmVyID0gZnVuY3Rpb24oKXtcbiAgICAgIEJhc2VSZW5kZXJlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICBSZWdpc3RyYW50UmVuZGVyZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgIH07XG5cbiAgICB2YXIgcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBmb3IoIHZhciBwTmFtZSBpbiBiUHJvdG8gKXtcbiAgICAgIHZhciBwVmFsID0gYlByb3RvWyBwTmFtZSBdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1sgcE5hbWUgXSAhPSBudWxsO1xuXG4gICAgICBpZiggZXhpc3RzSW5SICl7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVyciggcE5hbWUgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9bIHBOYW1lIF0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgZm9yKCB2YXIgcE5hbWUgaW4gclByb3RvICl7XG4gICAgICBwcm90b1sgcE5hbWUgXSA9IHJQcm90b1sgcE5hbWUgXTsgLy8gdGFrZSBpbXBsIGZyb20gcmVnaXN0cmFudFxuICAgIH1cblxuICAgIGJQcm90by5jbGllbnRGdW5jdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIG5hbWUgKXtcbiAgICAgIHByb3RvWyBuYW1lIF0gPSBwcm90b1sgbmFtZSBdIHx8IGZ1bmN0aW9uKCl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdSZW5kZXJlciBkb2VzIG5vdCBpbXBsZW1lbnQgYHJlbmRlcmVyLicgKyBuYW1lICsgJygpYCBvbiBpdHMgcHJvdG90eXBlJyApO1xuICAgICAgfTtcbiAgICB9ICk7XG5cbiAgICBleHQgPSBSZW5kZXJlcjtcblxuICB9XG5cbiAgcmV0dXJuIHV0aWwuc2V0TWFwKCB7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdLFxuICAgIHZhbHVlOiBleHRcbiAgfSApO1xufVxuXG5mdW5jdGlvbiBnZXRFeHRlbnNpb24oIHR5cGUsIG5hbWUgKXtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKCB7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdXG4gIH0gKTtcbn1cblxuZnVuY3Rpb24gc2V0TW9kdWxlKCB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50ICl7XG4gIHJldHVybiB1dGlsLnNldE1hcCgge1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXSxcbiAgICB2YWx1ZTogcmVnaXN0cmFudFxuICB9ICk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSggdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSApe1xuICByZXR1cm4gdXRpbC5nZXRNYXAoIHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgfSApO1xufVxuXG52YXIgZXh0ZW5zaW9uID0gZnVuY3Rpb24oKXtcbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAyICl7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApe1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDQgKXtcbiAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSA1ICl7XG4gICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gIH1cblxuICBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCAnSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcgKTtcbiAgfVxuXG59O1xuXG4vLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcbkNvcmUucHJvdG90eXBlLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcblxuLy8gaW5jbHVkZWQgZXh0ZW5zaW9uc1xuaW5jRXh0cy5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKCBmdW5jdGlvbiggZXh0ICl7XG4gICAgc2V0RXh0ZW5zaW9uKCBncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwgKTtcbiAgfSApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuc2lvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHtcbiAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICBleHRlbnNpb25zOiByZXF1aXJlKCAnLi9sYXlvdXQnIClcbiAgfSxcblxuICB7XG4gICAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgICBleHRlbnNpb25zOiByZXF1aXJlKCAnLi9yZW5kZXJlcicgKVxuICB9XG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgZGlyZWN0ZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICBjaXJjbGU6IGZhbHNlLCAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gIHNwYWNpbmdGYWN0b3I6IDEuNzUsIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICByb290czogdW5kZWZpbmVkLCAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gIG1heGltYWxBZGp1c3RtZW50czogMCwgLy8gaG93IG1hbnkgdGltZXMgdG8gdHJ5IHRvIHBvc2l0aW9uIHRoZSBub2RlcyBpbiBhIG1heGltYWwgd2F5IChpLmUuIG5vIGJhY2t0cmFja2luZylcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKTtcbiAgdmFyIGdyYXBoID0gZWxlcztcblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIHJvb3RzO1xuICBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggb3B0aW9ucy5yb290cyApICl7XG4gICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICB9IGVsc2UgaWYoIGlzLmFycmF5KCBvcHRpb25zLnJvb3RzICkgKXtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzWyBpIF07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICByb290c0FycmF5LnB1c2goIGVsZSApO1xuICAgIH1cblxuICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbiggcm9vdHNBcnJheSApO1xuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggb3B0aW9ucy5yb290cyApICl7XG4gICAgcm9vdHMgPSBjeS4kKCBvcHRpb25zLnJvb3RzICk7XG5cbiAgfSBlbHNlIHtcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCApe1xuICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgdmFyIHVuaGFuZGxlZE5vZGVzID0gbm9kZXM7XG5cbiAgICAgIHdoaWxlKCB1bmhhbmRsZWROb2Rlcy5sZW5ndGggPiAwICl7XG4gICAgICAgIHZhciBjdXJyQ29tcCA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICBlbGVzLmJmcygge1xuICAgICAgICAgIHJvb3RzOiB1bmhhbmRsZWROb2Rlc1swXSxcbiAgICAgICAgICB2aXNpdDogZnVuY3Rpb24oIGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSApe1xuICAgICAgICAgICAgY3VyckNvbXAgPSBjdXJyQ29tcC5hZGQoIG5vZGUgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpcmVjdGVkOiBmYWxzZVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgdW5oYW5kbGVkTm9kZXMgPSB1bmhhbmRsZWROb2Rlcy5ub3QoIGN1cnJDb21wICk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCggY3VyckNvbXAgKTtcbiAgICAgIH1cblxuICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzWyBpIF07XG4gICAgICAgIHZhciBtYXhEZWdyZWUgPSBjb21wLm1heERlZ3JlZSggZmFsc2UgKTtcbiAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKCBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlZ3JlZSggZmFsc2UgKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9ICk7XG5cbiAgICAgICAgcm9vdHMgPSByb290cy5hZGQoIGNvbXBSb290cyApO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cblxuICB2YXIgZGVwdGhzID0gW107XG4gIHZhciBmb3VuZEJ5QmZzID0ge307XG4gIHZhciBpZDJkZXB0aCA9IHt9O1xuICB2YXIgcHJldk5vZGUgPSB7fTtcbiAgdmFyIHByZXZFZGdlID0ge307XG4gIHZhciBzdWNjZXNzb3JzID0ge307XG5cbiAgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuICBncmFwaC5iZnMoIHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uKCBpLCBkZXB0aCwgbm9kZSwgZWRnZSwgcE5vZGUgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgIGlmKCAhZGVwdGhzWyBkZXB0aCBdICl7XG4gICAgICAgIGRlcHRoc1sgZGVwdGggXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbIGRlcHRoIF0ucHVzaCggZWxlICk7XG4gICAgICBmb3VuZEJ5QmZzWyBpZCBdID0gdHJ1ZTtcbiAgICAgIGlkMmRlcHRoWyBpZCBdID0gZGVwdGg7XG4gICAgICBwcmV2Tm9kZVsgaWQgXSA9IHBOb2RlO1xuICAgICAgcHJldkVkZ2VbIGlkIF0gPSBlZGdlO1xuXG4gICAgICBpZiggcE5vZGUgKXtcbiAgICAgICAgdmFyIHByZXZJZCA9IHBOb2RlLmlkKCk7XG4gICAgICAgIHZhciBzdWNjID0gc3VjY2Vzc29yc1sgcHJldklkIF0gPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSB8fCBbXTtcblxuICAgICAgICBzdWNjLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gKTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1sgaSBdO1xuXG4gICAgaWYoIGZvdW5kQnlCZnNbIGVsZS5pZCgpIF0gKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBlbGUgKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIGEgZGVwdGggZnJvbSB0aGVpciBuZWlnaGJvcmhvb2RcbiAgdmFyIG1heENoZWNrcyA9IG9ycGhhbk5vZGVzLmxlbmd0aCAqIDM7XG4gIHZhciBjaGVja3MgPSAwO1xuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICYmIGNoZWNrcyA8IG1heENoZWNrcyApe1xuICAgIHZhciBub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICB2YXIgbmVpZ2hib3JzID0gbm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpO1xuICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIG5laWdoYm9yc1sgaSBdLmlkKCkgXTtcblxuICAgICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZGVwdGhzWyBkZXB0aCBdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhYXNzaWduZWREZXB0aCApe1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgIH1cblxuICAgIGNoZWNrcysrO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICl7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgIC8vICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiggIWFzc2lnbmVkRGVwdGggKXsgLy8gd29yc3QgY2FzZSBpZiB0aGUgZ3JhcGggcmVhbGx5IGlzbid0IHRyZWUgZnJpZW5kbHksIHRoZW4ganVzdCBkdW1wIGl0IGluIDBcbiAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIGRlcHRocy5wdXNoKCBbXSApO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbMF0ucHVzaCggbm9kZSApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcbiAgdmFyIGFzc2lnbkRlcHRoc1RvRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGVzID0gZGVwdGhzWyBpIF07XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaiBdO1xuXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBpbmRleDogalxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG5cblxuICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyggZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEoICd0YXJnZXQnICkgPT09IG5vZGUuaWQoKTtcbiAgICB9ICk7XG4gICAgdmFyIHRoaXNJbmZvID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICB2YXIgaGlnaGVzdERlcHRoT2ZPdGhlciA9IDA7XG4gICAgdmFyIGhpZ2hlc3RPdGhlcjtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzWyBpIF07XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciBvdGhlckluZm8gPSBvdGhlck5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGlmKCB0aGlzSW5mby5kZXB0aCA8PSBvdGhlckluZm8uZGVwdGggJiYgaGlnaGVzdERlcHRoT2ZPdGhlciA8IG90aGVySW5mby5kZXB0aCApe1xuICAgICAgICBoaWdoZXN0RGVwdGhPZk90aGVyID0gb3RoZXJJbmZvLmRlcHRoO1xuICAgICAgICBoaWdoZXN0T3RoZXIgPSBvdGhlck5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZ2hlc3RPdGhlcjtcbiAgfTtcblxuICAvLyBtYWtlIG1heGltYWwgaWYgc28gc2V0IGJ5IGFkanVzdGluZyBkZXB0aHNcbiAgZm9yKCB2YXIgYWRqID0gMDsgYWRqIDwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHM7IGFkaisrICl7XG5cbiAgICB2YXIgbkRlcHRocyA9IGRlcHRocy5sZW5ndGg7XG4gICAgdmFyIGVsZXNUb01vdmUgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5EZXB0aHM7IGkrKyApe1xuICAgICAgdmFyIGRlcHRoID0gZGVwdGhzWyBpIF07XG5cbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aC5sZW5ndGg7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5EZXB0aDsgaisrICl7XG4gICAgICAgIHZhciBlbGUgPSBkZXB0aFsgaiBdO1xuICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aCggZWxlICk7XG5cbiAgICAgICAgaWYoIGludEVsZSApe1xuICAgICAgICAgIGluZm8uaW50RWxlID0gaW50RWxlO1xuICAgICAgICAgIGVsZXNUb01vdmUucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb01vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzVG9Nb3ZlWyBpIF07XG4gICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgIHZhciBpbnRFbGUgPSBpbmZvLmludEVsZTtcbiAgICAgIHZhciBpbnRJbmZvID0gaW50RWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICBkZXB0aHNbIGluZm8uZGVwdGggXS5zcGxpY2UoIGluZm8uaW5kZXgsIDEgKTsgLy8gcmVtb3ZlIGZyb20gb2xkIGRlcHRoICYgaW5kZXhcblxuICAgICAgLy8gYWRkIHRvIGVuZCBvZiBuZXcgZGVwdGhcbiAgICAgIHZhciBuZXdEZXB0aCA9IGludEluZm8uZGVwdGggKyAxO1xuICAgICAgd2hpbGUoIG5ld0RlcHRoID4gZGVwdGhzLmxlbmd0aCAtIDEgKXtcbiAgICAgICAgZGVwdGhzLnB1c2goIFtdICk7XG4gICAgICB9XG4gICAgICBkZXB0aHNbIG5ld0RlcHRoIF0ucHVzaCggZWxlICk7XG5cbiAgICAgIGluZm8uZGVwdGggPSBuZXdEZXB0aDtcbiAgICAgIGluZm8uaW5kZXggPSBkZXB0aHNbIG5ld0RlcHRoIF0ubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcbiAgfVxuXG4gIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbiA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgbmJiID0gbi5ib3VuZGluZ0JveCgpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG5cbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgoIG1pbkRpc3RhbmNlLCB3LCBoICk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG4gIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcbiAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBpZiggY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdICl7XG4gICAgICByZXR1cm4gY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdO1xuICAgIH1cblxuICAgIHZhciBlbGVEZXB0aCA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5kZXB0aDtcbiAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKS5pbnRlcnNlY3Rpb24obm9kZXMpO1xuICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICB2YXIgc2FtcGxlcyA9IDA7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzWyBpIF07XG4gICAgICB2YXIgYmYgPSBuZWlnaGJvci5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgIHZhciBpbmRleCA9IGJmLmluZGV4O1xuICAgICAgdmFyIGRlcHRoID0gYmYuZGVwdGg7XG4gICAgICB2YXIgbkRlcHRoID0gZGVwdGhzWyBkZXB0aCBdLmxlbmd0aDtcblxuICAgICAgaWYoIGVsZURlcHRoID4gZGVwdGggfHwgZWxlRGVwdGggPT09IDAgKXsgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KCAxLCBzYW1wbGVzICk7XG4gICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuXG4gICAgaWYoIHNhbXBsZXMgPT09IDAgKXsgLy8gc28gbG9uZSBub2RlcyBoYXZlIGEgXCJkb24ndCBjYXJlXCIgc3RhdGUgaW4gc29ydGluZ1xuICAgICAgcGVyY2VudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9O1xuXG5cbiAgLy8gcmVhcnJhbmdlIHRoZSBpbmRpY2VzIGluIGVhY2ggZGVwdGggbGV2ZWwgYmFzZWQgb24gY29ubmVjdGl2aXR5XG5cbiAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoIGEgKTtcbiAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYiApO1xuXG4gICAgcmV0dXJuIGFwY3QgLSBicGN0O1xuICB9O1xuXG4gIGZvciggdmFyIHRpbWVzID0gMDsgdGltZXMgPCAzOyB0aW1lcysrICl7IC8vIGRvIGl0IGEgZmV3IHRpbWVzIGIvYyB0aGUgZGVwdGhzIGFyZSBkeW5hbWljIGFuZCB3ZSB3YW50IGEgbW9yZSBzdGFibGUgcmVzdWx0XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgZGVwdGhzWyBpIF0gPSBkZXB0aHNbIGkgXS5zb3J0KCBzb3J0Rm4gKTtcbiAgICB9XG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7IC8vIGFuZCB1cGRhdGVcblxuICB9XG5cbiAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heCggZGVwdGhzWyBpIF0ubGVuZ3RoLCBiaWdnZXN0RGVwdGhTaXplICk7XG4gIH1cblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueDEgKyBiYi5oIC8gMlxuICB9O1xuXG4gIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBlbGUsIGlzQm90dG9tRGVwdGggKXtcbiAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICB2YXIgZGVwdGggPSBpbmZvLmRlcHRoO1xuICAgIHZhciBpbmRleCA9IGluZm8uaW5kZXg7XG4gICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1sgZGVwdGggXS5sZW5ndGg7XG5cbiAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoIGJiLncgLyAoZGVwdGhTaXplICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgdmFyIGRpc3RhbmNlWSA9IE1hdGgubWF4KCBiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbiggYmIudyAvIDIgLyBkZXB0aHMubGVuZ3RoLCBiYi5oIC8gMiAvIGRlcHRocy5sZW5ndGggKTtcbiAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KCByYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UgKTtcblxuICAgIGlmKCAhb3B0aW9ucy5jaXJjbGUgKXtcblxuICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcblxuICAgICAgaWYoIGlzQm90dG9tRGVwdGggKXtcbiAgICAgICAgcmV0dXJuIGVwb3M7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhciBzdWNjcyA9IHN1Y2Nlc3NvcnNbIGVsZS5pZCgpIF07XG4gICAgICAvLyBpZiggc3VjY3MgKXtcbiAgICAgIC8vICAgZXBvcy54ID0gMDtcbiAgICAgIC8vXG4gICAgICAvLyAgIGZvciggdmFyIGkgPSAwIDsgaSA8IHN1Y2NzLmxlbmd0aDsgaSsrICl7XG4gICAgICAvLyAgICAgdmFyIHNwb3MgPSBwb3NbIHN1Y2NzW2ldLmlkKCkgXTtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgZXBvcy54ICs9IHNwb3MueDtcbiAgICAgIC8vICAgfVxuICAgICAgLy9cbiAgICAgIC8vICAgZXBvcy54IC89IHN1Y2NzLmxlbmd0aDtcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIC8vZGVidWdnZXI7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBlcG9zO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1sgZGVwdGggXS5sZW5ndGggKiBpbmRleDtcblxuICAgICAgICBpZiggZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKVxuICAgICAgICB9O1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gZ2V0IHBvc2l0aW9ucyBpbiByZXZlcnNlIGRlcHRoIG9yZGVyXG4gIHZhciBwb3MgPSB7fTtcbiAgZm9yKCB2YXIgaSA9IGRlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApe1xuICAgIHZhciBkZXB0aCA9IGRlcHRoc1sgaSBdO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBkZXB0aC5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG5vZGUgPSBkZXB0aFsgaiBdO1xuXG4gICAgICBwb3NbIG5vZGUuaWQoKSBdID0gZ2V0UG9zaXRpb24oIG5vZGUsIGkgPT09IGRlcHRocy5sZW5ndGggLSAxICk7XG4gICAgfVxuICB9XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBwb3NbIHRoaXMuaWQoKSBdO1xuICB9ICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyZWFkdGhGaXJzdExheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uL21hdGgnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCwgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgcmFkaXVzOiB1bmRlZmluZWQsIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKTtcblxuICBpZiggb3B0aW9ucy5zb3J0ICl7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KCBvcHRpb25zLnNvcnQgKTtcbiAgfVxuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuXG4gIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuXG4gIHZhciBkVGhldGEgPSBzd2VlcCAvICggTWF0aC5tYXgoIDEsIG5vZGVzLmxlbmd0aCAtIDEgKSApO1xuICB2YXIgcjtcblxuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG4gPSBub2Rlc1sgaSBdO1xuICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSBuYmIudztcbiAgICB2YXIgaCA9IG5iYi5oO1xuXG4gICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heCggbWluRGlzdGFuY2UsIHcsIGggKTtcbiAgfVxuXG4gIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMucmFkaXVzICkgKXtcbiAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gIH0gZWxzZSBpZiggbm9kZXMubGVuZ3RoIDw9IDEgKXtcbiAgICByID0gMDtcbiAgfSBlbHNlIHtcbiAgICByID0gTWF0aC5taW4oIGJiLmgsIGJiLncgKSAvIDIgLSBtaW5EaXN0YW5jZTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gIGlmKCBub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgIHZhciBkY29zID0gTWF0aC5jb3MoIGRUaGV0YSApIC0gTWF0aC5jb3MoIDAgKTtcbiAgICB2YXIgZHNpbiA9IE1hdGguc2luKCBkVGhldGEgKSAtIE1hdGguc2luKCAwICk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoIGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gIH1cblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIGVsZSApe1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoIGNsb2Nrd2lzZSA/IDEgOiAtMSApO1xuXG4gICAgdmFyIHJ4ID0gciAqIE1hdGguY29zKCB0aGV0YSApO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbiggdGhldGEgKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSwgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLCAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgZXF1aWRpc3RhbnQ6IGZhbHNlLCAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICBtaW5Ob2RlU3BhY2luZzogMTAsIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgaGVpZ2h0OiB1bmRlZmluZWQsIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gIHdpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwICBcbiAgY29uY2VudHJpYzogZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICByZXR1cm4gbm9kZS5kZWdyZWUoKTtcbiAgfSxcbiAgbGV2ZWxXaWR0aDogZnVuY3Rpb24oIG5vZGVzICl7IC8vIHRoZSB2YXJpYXRpb24gb2YgY29uY2VudHJpYyB2YWx1ZXMgaW4gZWFjaCBsZXZlbFxuICAgIHJldHVybiBub2Rlcy5tYXhEZWdyZWUoKSAvIDQ7XG4gIH0sXG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuXG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKTtcblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcblxuICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMuYXBwbHkoIG5vZGUsIFsgbm9kZSBdICk7XG4gICAgbm9kZVZhbHVlcy5wdXNoKCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSApO1xuXG4gICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9XG5cbiAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgbm9kZXMudXBkYXRlU3R5bGUoKTtcblxuICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgIHZhciBuYmIgPSBub2RlLmJvdW5kaW5nQm94KCk7XG5cbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KCBtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oICk7XG4gIH1cblxuICAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG4gIG5vZGVWYWx1ZXMuc29ydCggZnVuY3Rpb24oIGEsIGIgKXtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0gKTtcblxuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aCggbm9kZXMgKTtcblxuICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICB2YXIgbGV2ZWxzID0gWyBbXSBdO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1sgaSBdO1xuXG4gICAgaWYoIGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwICl7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKCBjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUgKTtcblxuICAgICAgaWYoIGRpZmYgPj0gbGV2ZWxXaWR0aCApe1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goIGN1cnJlbnRMZXZlbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKCB2YWwgKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gIGlmKCAhb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gKCBNYXRoLm1pbiggYmIudywgYmIuaCApIC8gMiAtIG1pbkRpc3QgKTtcbiAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKCBsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwICk7XG5cbiAgICBtaW5EaXN0ID0gTWF0aC5taW4oIG1pbkRpc3QsIHJTdGVwICk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBtZXRyaWNzIGZvciBlYWNoIGxldmVsXG4gIHZhciByID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcbiAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbGV2ZWwubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhID0gc3dlZXAgLyAoIE1hdGgubWF4KCAxLCBsZXZlbC5sZW5ndGggLSAxICkgKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYoIGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyggZFRoZXRhICkgLSBNYXRoLmNvcyggMCApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbiggZFRoZXRhICkgLSBNYXRoLnNpbiggMCApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3QgKiBtaW5EaXN0IC8gKCBkY29zICogZGNvcyArIGRzaW4gKiBkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgICB9XG5cbiAgICBsZXZlbC5yID0gcjtcblxuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmKCBvcHRpb25zLmVxdWlkaXN0YW50ICl7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuICAgICAgdmFyIHJEZWx0YSA9IGxldmVsLnIgLSByO1xuXG4gICAgICByRGVsdGFNYXggPSBNYXRoLm1heCggckRlbHRhTWF4LCByRGVsdGEgKTtcbiAgICB9XG5cbiAgICByID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgIHIgPSBsZXZlbC5yO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC5yID0gcjtcblxuICAgICAgciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YTtcbiAgICB2YXIgciA9IGxldmVsLnI7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgdmFsID0gbGV2ZWxbIGogXTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogZFRoZXRhICogajtcblxuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgciAqIE1hdGguY29zKCB0aGV0YSApLFxuICAgICAgICB5OiBjZW50ZXIueSArIHIgKiBNYXRoLnNpbiggdGhldGEgKVxuICAgICAgfTtcblxuICAgICAgcG9zWyB2YWwubm9kZS5pZCgpIF0gPSBwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGlkID0gdGhpcy5pZCgpO1xuXG4gICAgcmV0dXJuIHBvc1sgaWQgXTtcbiAgfSApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25jZW50cmljTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbmh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xudmFyIFRocmVhZCA9IHJlcXVpcmUoICcuLi8uLi90aHJlYWQnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBERUJVRztcblxuLyoqXG4gKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbigpe30sXG5cbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wOiBmdW5jdGlvbigpe30sXG5cbiAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICBhbmltYXRlOiB0cnVlLFxuXG4gIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgLy8gKDAgLT4gb25seSB1cGRhdGVkIG9uIHRoZSBlbmQpXG4gIHJlZnJlc2g6IDIwLFxuXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcblxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nOiAzMCxcblxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcblxuICAvLyBSYW5kb21pemUgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBub2RlcyAodHJ1ZSkgb3IgdXNlIGV4aXN0aW5nIHBvc2l0aW9ucyAoZmFsc2UpXG4gIHJhbmRvbWl6ZTogZmFsc2UsXG5cbiAgLy8gRXh0cmEgc3BhY2luZyBiZXR3ZWVuIGNvbXBvbmVudHMgaW4gbm9uLWNvbXBvdW5kIGdyYXBoc1xuICBjb21wb25lbnRTcGFjaW5nOiAxMDAsXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiBmdW5jdGlvbiggbm9kZSApeyByZXR1cm4gNDAwMDAwOyB9LFxuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlT3ZlcmxhcDogMTAsXG5cbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDEwOyB9LFxuXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDEwMDsgfSxcblxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDUsXG5cbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDgwLFxuXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAxMDAwLFxuXG4gIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gIGluaXRpYWxUZW1wOiAyMDAsXG5cbiAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgY29vbGluZ0ZhY3RvcjogMC45NSxcblxuICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgbWluVGVtcDogMS4wLFxuXG4gIC8vIFdoZXRoZXIgdG8gdXNlIHRocmVhZGluZyB0byBzcGVlZCB1cCB0aGUgbGF5b3V0XG4gIHVzZU11bHRpdGFza2luZzogdHJ1ZSxcblxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWRcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQ29zZUxheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG5cbiAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG59XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSAgICAgID0gb3B0aW9ucy5jeTtcbiAgdmFyIGxheW91dCAgPSB0aGlzO1xuICB2YXIgdGhyZWFkICA9IHRoaXMudGhyZWFkO1xuXG4gIGlmKCAhdGhyZWFkIHx8IHRocmVhZC5zdG9wcGVkKCkgKXtcbiAgICB0aHJlYWQgPSB0aGlzLnRocmVhZCA9IFRocmVhZCggeyBkaXNhYmxlZDogIW9wdGlvbnMudXNlTXVsdGl0YXNraW5nIH0gKTtcbiAgfVxuXG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICBpZiggdHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1ZyApe1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oIGN5LCBsYXlvdXQsIG9wdGlvbnMgKTtcblxuICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gIGlmKCBERUJVRyApe1xuICAgIHByaW50TGF5b3V0SW5mbyggbGF5b3V0SW5mbyApO1xuICB9XG5cbiAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICByYW5kb21pemVQb3NpdGlvbnMoIGxheW91dEluZm8sIGN5ICk7XG4gIH1cblxuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiggck9wdHMgKXtcbiAgICByT3B0cyA9IHJPcHRzIHx8IHt9O1xuXG4gICAgaWYoIHJlZnJlc2hSZXF1ZXN0ZWQgJiYgIXJPcHRzLm5leHQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggIXJPcHRzLmZvcmNlICYmIERhdGUubm93KCkgLSBzdGFydFRpbWUgPCBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgdXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uKCl7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyApO1xuXG4gICAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYoIHRydWUgPT09IG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYoIHJPcHRzLm5leHQgKXsgck9wdHMubmV4dCgpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhyZWFkLm9uKCAnbWVzc2FnZScsIGZ1bmN0aW9uKCBlICl7XG4gICAgdmFyIGxheW91dE5vZGVzID0gZS5tZXNzYWdlO1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dE5vZGVzO1xuICAgIHJlZnJlc2goKTtcbiAgfSApO1xuXG4gIHRocmVhZC5wYXNzKCB7XG4gICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsXG4gICAgICByZWZyZXNoOiBvcHRpb25zLnJlZnJlc2gsXG4gICAgICBjb21wb25lbnRTcGFjaW5nOiBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmcsXG4gICAgICBub2RlT3ZlcmxhcDogb3B0aW9ucy5ub2RlT3ZlcmxhcCxcbiAgICAgIG5lc3RpbmdGYWN0b3I6IG9wdGlvbnMubmVzdGluZ0ZhY3RvcixcbiAgICAgIGdyYXZpdHk6IG9wdGlvbnMuZ3Jhdml0eSxcbiAgICAgIG51bUl0ZXI6IG9wdGlvbnMubnVtSXRlcixcbiAgICAgIGluaXRpYWxUZW1wOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgICAgY29vbGluZ0ZhY3Rvcjogb3B0aW9ucy5jb29saW5nRmFjdG9yLFxuICAgICAgbWluVGVtcDogb3B0aW9ucy5taW5UZW1wXG4gICAgfVxuICB9ICkucnVuKCBmdW5jdGlvbiggcGFzcyApe1xuICAgIHZhciBsYXlvdXRJbmZvID0gcGFzcy5sYXlvdXRJbmZvO1xuICAgIHZhciBvcHRpb25zID0gcGFzcy5vcHRpb25zO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gICAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgICAqL1xuICAgIHZhciBzdGVwID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMsIHN0ZXAgKXtcbiAgICAgIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gICAgICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAgICAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gICAgICBjYWxjdWxhdGVOb2RlRm9yY2VzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgICAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcbiAgICAgIGNhbGN1bGF0ZUVkZ2VGb3JjZXMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICAgIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICAgICAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgICAgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgICAgcHJvcGFnYXRlRm9yY2VzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG4gICAgICB1cGRhdGVQb3NpdGlvbnMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gICAgICAvLyBOb2RlcyBvbmx5IHJlcGVsIGVhY2ggb3RoZXIgaWYgdGhleSBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JhcGhcbiAgICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrICl7XG4gICAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbIGkgXTtcbiAgICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAgICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKysgKXtcbiAgICAgICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZ3JhcGhbIGogXSBdIF07XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrICl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZ3JhcGhbIGsgXSBdIF07XG5cbiAgICAgICAgICAgIG5vZGVSZXB1bHNpb24oIG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmFuZG9tRGlzdGFuY2UgPSBmdW5jdGlvbiggbWF4ICl7XG4gICAgICByZXR1cm4gLW1heCArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAgICAgKi9cbiAgICB2YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uKCBub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICAgICAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gICAgICB2YXIgY21wdElkMiA9IG5vZGUyLmNtcHRJZDtcblxuICAgICAgaWYoIGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCApeyByZXR1cm47IH1cblxuICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gICAgICB2YXIgbWF4UmFuZERpc3QgPSAxO1xuICAgICAgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG5cbiAgICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG4gICAgICBpZiggMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZICl7XG4gICAgICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZSggbWF4UmFuZERpc3QgKTtcbiAgICAgICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKCBtYXhSYW5kRGlzdCApO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcCggbm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZICk7XG5cbiAgICAgIGlmKCBvdmVybGFwID4gMCApe1xuICAgICAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAgICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAgICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbFxuICAgICAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgICAgICB2YXIgZm9yY2UgICAgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkgKTtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VYICAgPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGZvcmNlWSAgID0gZm9yY2UgKiBkaXJlY3Rpb25ZIC8gZGlzdGFuY2U7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludCggbm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkgKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KCBub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkgKTtcblxuICAgICAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICAgICAgdmFyIGRpc3RhbmNlWCAgID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGRpc3RhbmNlWSAgID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgICB2YXIgZGlzdGFuY2UgICAgPSBNYXRoLnNxcnQoIGRpc3RhbmNlU3FyICk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgICB2YXIgZm9yY2UgID0gKCBub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbiApIC8gZGlzdGFuY2VTcXI7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgZm9yY2VcbiAgICAgIGlmKCAhbm9kZTEuaXNMb2NrZWQgKXtcbiAgICAgICAgbm9kZTEub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICAgICAgfVxuXG4gICAgICBpZiggIW5vZGUyLmlzTG9ja2VkICl7XG4gICAgICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmICA6IERldGVybWluZXMgd2hldGhlciB0d28gbm9kZXMgb3ZlcmxhcCBvciBub3RcbiAgICAgKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gICAgICovXG4gICAgdmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uKCBub2RlMSwgbm9kZTIsIGRYLCBkWSApe1xuXG4gICAgICBpZiggZFggPiAwICl7XG4gICAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gICAgICB9XG5cbiAgICAgIGlmKCBkWSA+IDAgKXtcbiAgICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgICAgIH1cblxuICAgICAgaWYoIG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCApe1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCBvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gICAgICogICAgICAgICAgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCBvZiBpdCdzIHNvdXJjZS90YXJnZXQgbm9kZVxuICAgICAqL1xuICAgIHZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uKCBub2RlLCBkWCwgZFkgKXtcblxuICAgICAgLy8gU2hvcmN1dHNcbiAgICAgIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICAgICAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICAgICAgdmFyIFcgPSBub2RlLndpZHRoIHx8IDE7XG4gICAgICB2YXIgZGlyU2xvcGUgICAgID0gZFkgLyBkWDtcbiAgICAgIHZhciBub2RlU2xvcGUgICAgPSBIIC8gVztcblxuICAgICAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAgICAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgICAgIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAgICAgLy9cbiAgICAgIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBkbyB7XG4gICAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gICAgICAgIGlmKCAwID09PSBkWCAmJiAwIDwgZFkgKXtcbiAgICAgICAgICByZXMueCA9IFg7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuICAgICAgICBpZiggMCA9PT0gZFggJiYgMCA+IGRZICl7XG4gICAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICAgIGlmKCAwIDwgZFggJiZcbiAgICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiZcbiAgICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlICl7XG4gICAgICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICAgICAgcmVzLnkgPSBZICsgKFcgKiBkWSAvIDIgLyBkWCk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgICBpZiggMCA+IGRYICYmXG4gICAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmXG4gICAgICAgIGRpclNsb3BlIDw9IG5vZGVTbG9wZSApe1xuICAgICAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgICAgIHJlcy55ID0gWSAtIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG4gICAgICAgIGlmKCAwIDwgZFkgJiZcbiAgICAgICAgKCBkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fFxuICAgICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApICl7XG4gICAgICAgICAgcmVzLnggPSBYICsgKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblRvcCBib3JkZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgICAgaWYoIDAgPiBkWSAmJlxuICAgICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkgKXtcbiAgICAgICAgICByZXMueCA9IFggLSAoSCAqIGRYIC8gMiAvIGRZKTtcbiAgICAgICAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIH0gd2hpbGUoIGZhbHNlKTtcblxuICAgICAgLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKyApe1xuICAgICAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgICAgIHZhciBlZGdlICAgICA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbIGkgXTtcbiAgICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIGVkZ2Uuc291cmNlSWQgXTtcbiAgICAgICAgdmFyIHNvdXJjZSAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgc291cmNlSXggXTtcbiAgICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIGVkZ2UudGFyZ2V0SWQgXTtcbiAgICAgICAgdmFyIHRhcmdldCAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgdGFyZ2V0SXggXTtcblxuICAgICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRhcmdldC5wb3NpdGlvblggLSBzb3VyY2UucG9zaXRpb25YO1xuICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZO1xuXG4gICAgICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuICAgICAgICBpZiggMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoIHNvdXJjZSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSApO1xuICAgICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQoIHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkgKTtcblxuXG4gICAgICAgIHZhciBseCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICAgIHZhciBsICA9IE1hdGguc3FydCggbHggKiBseCArIGx5ICogbHkgKTtcblxuICAgICAgICB2YXIgZm9yY2UgID0gTWF0aC5wb3coIGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyICkgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICAgICAgaWYoIDAgIT09IGwgKXtcbiAgICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcbiAgICAgICAgaWYoICFzb3VyY2UuaXNMb2NrZWQgKXtcbiAgICAgICAgICBzb3VyY2Uub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICF0YXJnZXQuaXNMb2NrZWQgKXtcbiAgICAgICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7XG5cbiAgICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrICl7XG4gICAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbIGkgXTtcbiAgICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgICAgICBpZiggMCA9PT0gaSApe1xuICAgICAgICAgIHZhciBjZW50ZXJYICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICAgICAgdmFyIGNlbnRlclkgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGggIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgICAgIHZhciB0ZW1wICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGdyYXBoWzBdIF0gXTtcbiAgICAgICAgICB2YXIgcGFyZW50ICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyB0ZW1wLnBhcmVudElkIF0gXTtcbiAgICAgICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgICAgICB9XG4gICAgICAgIC8vIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGdyYXBoWyBqIF0gXSBdO1xuICAgICAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcblxuICAgICAgICAgIGlmKCBub2RlLmlzTG9ja2VkICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICAgICAgdmFyIGR5ID0gY2VudGVyWSAtIG5vZGUucG9zaXRpb25ZO1xuICAgICAgICAgIHZhciBkICA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcbiAgICAgICAgICBpZiggZCA+IGRpc3RUaHJlc2hvbGQgKXtcbiAgICAgICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTtcbiAgICAgICAgICAgIC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAgICAgKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICAgICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gICAgICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICAgICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgIHZhciBzdGFydCA9IDA7ICAgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICAgIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcblxuICAgICAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZS5wdXNoLmFwcGx5KCBxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSApO1xuICAgICAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gICAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICAgICAgd2hpbGUoIHN0YXJ0IDw9IGVuZCApe1xuICAgICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICAgIHZhciBub2RlSWQgICAgPSBxdWV1ZVsgc3RhcnQrKyBdO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIG5vZGVJZCBdO1xuICAgICAgICB2YXIgbm9kZSAgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbm9kZUluZGV4IF07XG4gICAgICAgIHZhciBjaGlsZHJlbiAgPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcbiAgICAgICAgaWYoIDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQgKXtcbiAgICAgICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTtcblxuICAgICAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGNoaWxkcmVuWyBpIF0gXSBdO1xuICAgICAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7XG4gICAgICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICAgICAgcXVldWVbICsrZW5kIF0gPSBjaGlsZHJlblsgaSBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG4gICAgICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb25cbiAgICAgKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBvcHRpb25zICl7XG4gICAgICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICAgICAgaWYoIDAgPCBuLmNoaWxkcmVuLmxlbmd0aCApe1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgICBuLm1heFggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1pblkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBpIF07XG4gICAgICAgIGlmKCAwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCApe1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAgICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcblxuICAgICAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2UoIG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICk7XG4gICAgICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54O1xuICAgICAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICAgICAgbi5vZmZzZXRYID0gMDtcbiAgICAgICAgbi5vZmZzZXRZID0gMDtcbiAgICAgICAgbi5taW5YICAgID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgICAgICBuLm1heFggICAgPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgICAgIG4ubWluWSAgICA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7XG4gICAgICAgIG4ubWF4WSAgICA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7XG4gICAgICAgIC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG4gICAgICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyggbiwgbGF5b3V0SW5mbyApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBpIF07XG4gICAgICAgIGlmKCAwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQgKXtcbiAgICAgICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgICAgICBuLndpZHRoICAgICA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgICAgICBuLmhlaWdodCAgICA9IG4ubWF4WSAtIG4ubWluWTtcbiAgICAgICAgICAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuV2lkdGg6IFwiICsgbi53aWR0aCArIFwiLCBIZWlnaHQ6IFwiICsgbi5oZWlnaHQ7XG4gICAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3RcbiAgICAgKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LlxuICAgICA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbiggZm9yY2VYLCBmb3JjZVksIG1heCApe1xuICAgICAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoIGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSApO1xuXG4gICAgICBpZiggZm9yY2UgPiBtYXggKXtcbiAgICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgICB4OiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgICAgICB5OiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgICAgICB9O1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgIHg6IGZvcmNlWCxcbiAgICAgICAgICB5OiBmb3JjZVlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAgICAgKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICAgICAqL1xuICAgIHZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbiggbm9kZSwgbGF5b3V0SW5mbyApe1xuICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICAgICAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcbiAgICAgIGlmKCBudWxsID09IHBhcmVudElkICl7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgICAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IFBhcmVudCBOb2RlXG4gICAgICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBwYXJlbnRJZCBdIF07XG4gICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgICAvLyBNYXhYXG4gICAgICBpZiggbnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCApe1xuICAgICAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gICAgICB9XG5cbiAgICAgIC8vIE1pblhcbiAgICAgIGlmKCBudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblggKXtcbiAgICAgICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gICAgICB9XG5cbiAgICAgIC8vIE1heFlcbiAgICAgIGlmKCBudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSApe1xuICAgICAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICAgICAgfVxuXG4gICAgICAvLyBNaW5ZXG4gICAgICBpZiggbnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkgKXtcbiAgICAgICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcbiAgICAgIGlmKCBmbGFnICl7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKCBwLCBsYXlvdXRJbmZvICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgdmFyIHNlcGFyYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uKCBsYXl1dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIHZhciBub2RlcyA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXM7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICAgICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1sgY2lkIF0gPSBjb21wb25lbnRzWyBjaWQgXSB8fCBbXTtcblxuICAgICAgICBjb21wb25lbnQucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxBID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjID0gY29tcG9uZW50c1sgaSBdO1xuXG4gICAgICAgIGlmKCAhYyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICAgICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICAgICAgYy55MSA9IEluZmluaXR5O1xuICAgICAgICBjLnkyID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBuID0gY1sgaiBdO1xuXG4gICAgICAgICAgYy54MSA9IE1hdGgubWluKCBjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyICk7XG4gICAgICAgICAgYy54MiA9IE1hdGgubWF4KCBjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGggLyAyICk7XG4gICAgICAgICAgYy55MSA9IE1hdGgubWluKCBjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0IC8gMiApO1xuICAgICAgICAgIGMueTIgPSBNYXRoLm1heCggYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMudyA9IGMueDIgLSBjLngxO1xuICAgICAgICBjLmggPSBjLnkyIC0gYy55MTtcblxuICAgICAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnNvcnQoIGZ1bmN0aW9uKCBjMSwgYzIgKXtcbiAgICAgICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gICAgICB9ICk7XG5cbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciB1c2VkVyA9IDA7XG4gICAgICB2YXIgcm93SCA9IDA7XG4gICAgICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCggdG90YWxBICkgKiBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbIGkgXTtcblxuICAgICAgICBpZiggIWMgKXsgY29udGludWU7IH1cblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgbiA9IGNbIGogXTtcblxuICAgICAgICAgIGlmKCAhbi5pc0xvY2tlZCApe1xuICAgICAgICAgICAgbi5wb3NpdGlvblggKz0geDtcbiAgICAgICAgICAgIG4ucG9zaXRpb25ZICs9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeCArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgIHVzZWRXICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgcm93SCA9IE1hdGgubWF4KCByb3dILCBjLmggKTtcblxuICAgICAgICBpZiggdXNlZFcgPiBtYXhSb3dXICl7XG4gICAgICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHVzZWRXID0gMDtcbiAgICAgICAgICByb3dIID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiggaSApe1xuICAgICAgaWYoIHN0b3BwZWQgKXtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG4gICAgICBzdGVwKCBsYXlvdXRJbmZvLCBvcHRpb25zLCBpICk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuICAgICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgICAgaWYoIGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXAgKXtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbG9vcFJldDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgd2hpbGUoIGYgPCBvcHRpb25zLnJlZnJlc2ggJiYgaSA8IG9wdGlvbnMubnVtSXRlciApe1xuICAgICAgICB2YXIgbG9vcFJldCA9IG1haW5Mb29wKCBpICk7XG4gICAgICAgIGlmKCAhbG9vcFJldCApeyBicmVhazsgfVxuXG4gICAgICAgIGYrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgIGJyb2FkY2FzdCggbGF5b3V0SW5mby5sYXlvdXROb2RlcyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB9XG5cbiAgICB9IHdoaWxlKCBsb29wUmV0ICYmIGkgKyAxIDwgb3B0aW9ucy5udW1JdGVyICk7XG5cbiAgICBzZXBhcmF0ZUNvbXBvbmVudHMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcblxuICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICB9ICkudGhlbiggZnVuY3Rpb24oIGxheW91dEluZm9VcGRhdGVkICl7XG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dEluZm9VcGRhdGVkLmxheW91dE5vZGVzOyAvLyBnZXQgdGhlIHBvc2l0aW9uc1xuXG4gICAgdGhyZWFkLnN0b3AoKTtcbiAgICBkb25lKCk7XG4gIH0gKTtcblxuICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmVmcmVzaCh7XG4gICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIExheW91dCBoYXMgZmluaXNoZWRcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgaWYoIHRoaXMudGhyZWFkICl7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgdGhpcy50cmlnZ2VyKCAnbGF5b3V0c3RvcCcgKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiggdGhpcy50aHJlYWQgKXtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiggY3ksIGxheW91dCwgb3B0aW9ucyApe1xuICAvLyBTaG9ydGN1dFxuICB2YXIgZWRnZXMgPSBvcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG5cbiAgdmFyIGxheW91dEluZm8gICA9IHtcbiAgICBpc0NvbXBvdW5kOiBjeS5oYXNDb21wb3VuZE5vZGVzKCksXG4gICAgbGF5b3V0Tm9kZXM6IFtdLFxuICAgIGlkVG9JbmRleDoge30sXG4gICAgbm9kZVNpemU6IG5vZGVzLnNpemUoKSxcbiAgICBncmFwaFNldDogW10sXG4gICAgaW5kZXhUb0dyYXBoOiBbXSxcbiAgICBsYXlvdXRFZGdlczogW10sXG4gICAgZWRnZVNpemU6IGVkZ2VzLnNpemUoKSxcbiAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICBjbGllbnRXaWR0aDogY3kud2lkdGgoKSxcbiAgICBjbGllbnRIZWlnaHQ6IGN5LndpZHRoKCksXG4gICAgYm91bmRpbmdCb3g6IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgICAgICAgICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgICAgICAgICAgICAgICB9IClcbiAgfTtcblxuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1sgaSBdO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBub2RlID0gY29tcG9uZW50WyBqIF07XG5cbiAgICAgIGlkMmNtcHRJZFsgbm9kZS5pZCgpIF0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgIHZhciBuID0gbm9kZXNbIGkgXTtcbiAgICB2YXIgbmJiID0gbi5ib3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHRlbXBOb2RlICAgICAgICA9IHt9O1xuICAgIHRlbXBOb2RlLmlzTG9ja2VkICAgPSBuLmxvY2tlZCgpO1xuICAgIHRlbXBOb2RlLmlkICAgICAgICAgPSBuLmRhdGEoICdpZCcgKTtcbiAgICB0ZW1wTm9kZS5wYXJlbnRJZCAgID0gbi5kYXRhKCAncGFyZW50JyApO1xuICAgIHRlbXBOb2RlLmNtcHRJZCAgICAgPSBpZDJjbXB0SWRbIG4uaWQoKSBdO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuICAgPSBbXTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblggID0gbi5wb3NpdGlvbiggJ3gnICk7XG4gICAgdGVtcE5vZGUucG9zaXRpb25ZICA9IG4ucG9zaXRpb24oICd5JyApO1xuICAgIHRlbXBOb2RlLm9mZnNldFggICAgPSAwO1xuICAgIHRlbXBOb2RlLm9mZnNldFkgICAgPSAwO1xuICAgIHRlbXBOb2RlLmhlaWdodCAgICAgPSBuYmIudztcbiAgICB0ZW1wTm9kZS53aWR0aCAgICAgID0gbmJiLmg7XG4gICAgdGVtcE5vZGUubWF4WCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgdGVtcE5vZGUubWluWCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgdGVtcE5vZGUubWF4WSAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUubWluWSAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUucGFkTGVmdCAgICA9IHBhcnNlRmxvYXQoIG4uc3R5bGUoICdwYWRkaW5nJyApICk7XG4gICAgdGVtcE5vZGUucGFkUmlnaHQgICA9IHBhcnNlRmxvYXQoIG4uc3R5bGUoICdwYWRkaW5nJyApICk7XG4gICAgdGVtcE5vZGUucGFkVG9wICAgICA9IHBhcnNlRmxvYXQoIG4uc3R5bGUoICdwYWRkaW5nJyApICk7XG4gICAgdGVtcE5vZGUucGFkQm90dG9tICA9IHBhcnNlRmxvYXQoIG4uc3R5bGUoICdwYWRkaW5nJyApICk7XG5cbiAgICAvLyBmb3JjZXNcbiAgICB0ZW1wTm9kZS5ub2RlUmVwdWxzaW9uID0gaXMuZm4oIG9wdGlvbnMubm9kZVJlcHVsc2lvbiApID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uLmNhbGwoIG4sIG4gKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcblxuICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCggdGVtcE5vZGUgKTtcbiAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBOb2RlLmlkIF0gPSBpO1xuICB9XG5cbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIHZhciB0ZW1wR3JhcGggPSBbXTtcblxuICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYoIG51bGwgIT0gcF9pZCApe1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHBfaWQgXSBdLmNoaWxkcmVuLnB1c2goIG4uaWQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsgKytlbmQgXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaCggbi5pZCApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG4gIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCggdGVtcEdyYXBoICk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUoIHN0YXJ0IDw9IGVuZCApe1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCAgPSBxdWV1ZVsgc3RhcnQrKyBdO1xuICAgIHZhciBub2RlX2l4ICA9IGxheW91dEluZm8uaWRUb0luZGV4WyBub2RlX2lkIF07XG4gICAgdmFyIG5vZGUgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbm9kZV9peCBdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYoIGNoaWxkcmVuLmxlbmd0aCA+IDAgKXtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCggY2hpbGRyZW4gKTtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBxdWV1ZVsgKytlbmQgXSA9IGNoaWxkcmVuWyBpIF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFsgaSBdO1xuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFsgaiBdIF07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgaW5kZXggXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrICl7XG4gICAgdmFyIGUgPSBlZGdlc1sgaSBdO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkICAgICAgID0gZS5kYXRhKCAnaWQnICk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoICdzb3VyY2UnICk7XG4gICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoICd0YXJnZXQnICk7XG5cbiAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgIHZhciBpZGVhbExlbmd0aCA9IGlzLmZuKCBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCApID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGguY2FsbCggZSwgZSApIDogb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gICAgdmFyIGVsYXN0aWNpdHkgPSBpcy5mbiggb3B0aW9ucy5lZGdlRWxhc3RpY2l0eSApID8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eS5jYWxsKCBlLCBlICkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5O1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG4gICAgdmFyIHNvdXJjZUl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBFZGdlLnNvdXJjZUlkIF07XG4gICAgdmFyIHRhcmdldEl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBFZGdlLnRhcmdldElkIF07XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbIHNvdXJjZUl4IF07XG4gICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbIHRhcmdldEl4IF07XG5cbiAgICBpZiggc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGggKXtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EoIHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyApO1xuXG4gICAgICAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0WyBsY2EgXTtcbiAgICAgIHZhciBkZXB0aCAgICA9IDA7XG5cbiAgICAgIC8vIFNvdXJjZSBkZXB0aFxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgc291cmNlSXggXTtcbiAgICAgIHdoaWxlKCAtMSA9PT0gbGNhR3JhcGguaW5kZXhPZiggdGVtcE5vZGUuaWQgKSApe1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyB0ZW1wTm9kZS5wYXJlbnRJZCBdIF07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyB0YXJnZXRJeCBdO1xuICAgICAgd2hpbGUoIC0xID09PSBsY2FHcmFwaC5pbmRleE9mKCB0ZW1wTm9kZS5pZCApICl7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBOb2RlLnBhcmVudElkIF0gXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuXG4gICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgIH1cblxuICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG4gICAgdGVtcEVkZ2UuZWxhc3RpY2l0eSA9IGVsYXN0aWNpdHk7XG5cbiAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2goIHRlbXBFZGdlICk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuXG5cbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uKCBub2RlMSwgbm9kZTIsIGxheW91dEluZm8gKXtcbiAgLy8gRmluZCB0aGVpciBjb21tb24gYW5jZXN0ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgZ3JhcGhcbiAgdmFyIHJlcyA9IGZpbmRMQ0FfYXV4KCBub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8gKTtcbiAgaWYoIDIgPiByZXMuY291bnQgKXtcbiAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLFxuICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzLmdyYXBoO1xuICB9XG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG52YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbiggbm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvICl7XG4gIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbIGdyYXBoSXggXTtcbiAgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcbiAgaWYoIC0xIDwgZ3JhcGguaW5kZXhPZiggbm9kZTEgKSAmJiAtMSA8IGdyYXBoLmluZGV4T2YoIG5vZGUyICkgKXtcbiAgICByZXR1cm4ge2NvdW50OiAyLCBncmFwaDogZ3JhcGhJeH07XG4gIH1cblxuICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICB2YXIgYyA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZUlkICAgPSBncmFwaFsgaSBdO1xuICAgIHZhciBub2RlSXggICA9IGxheW91dEluZm8uaWRUb0luZGV4WyBub2RlSWQgXTtcbiAgICB2YXIgY2hpbGRyZW4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBub2RlSXggXS5jaGlsZHJlbjtcblxuICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgIGlmKCAwID09PSBjaGlsZHJlbi5sZW5ndGggKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGNoaWxkcmVuWzBdIF0gXTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgoIG5vZGUxLCBub2RlMiwgY2hpbGRHcmFwaEl4LCBsYXlvdXRJbmZvICk7XG4gICAgaWYoIDAgPT09IHJlc3VsdC5jb3VudCApe1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmKCAxID09PSByZXN1bHQuY291bnQgKXtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmKCAyID09PSBjICl7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7Y291bnQ6IGMsIGdyYXBoOiBncmFwaEl4fTtcbn07XG5cblxuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cbnZhciBwcmludExheW91dEluZm8gPSBmdW5jdGlvbiggbGF5b3V0SW5mbyApe1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4gIGlmKCAhREVCVUcgKXtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5kZWJ1ZyggJ2xheW91dE5vZGVzOicgKTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICB2YXIgcyA9XG4gICAgJ1xcbmluZGV4OiAnICAgICArIGkgK1xuICAgICdcXG5JZDogJyAgICAgICAgKyBuLmlkICtcbiAgICAnXFxuQ2hpbGRyZW46ICcgICsgbi5jaGlsZHJlbi50b1N0cmluZygpICtcbiAgICAnXFxucGFyZW50SWQ6ICcgICsgbi5wYXJlbnRJZCAgK1xuICAgICdcXG5wb3NpdGlvblg6ICcgKyBuLnBvc2l0aW9uWCArXG4gICAgJ1xcbnBvc2l0aW9uWTogJyArIG4ucG9zaXRpb25ZICtcbiAgICAnXFxuT2Zmc2V0WDogJyArIG4ub2Zmc2V0WCArXG4gICAgJ1xcbk9mZnNldFk6ICcgKyBuLm9mZnNldFkgK1xuICAgICdcXG5wYWRMZWZ0OiAnICsgbi5wYWRMZWZ0ICtcbiAgICAnXFxucGFkUmlnaHQ6ICcgKyBuLnBhZFJpZ2h0ICtcbiAgICAnXFxucGFkVG9wOiAnICsgbi5wYWRUb3AgK1xuICAgICdcXG5wYWRCb3R0b206ICcgKyBuLnBhZEJvdHRvbTtcblxuICAgIGNvbnNvbGUuZGVidWcoIHMgKTtcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoICdpZFRvSW5kZXgnICk7XG4gIGZvciggdmFyIGkgaW4gbGF5b3V0SW5mby5pZFRvSW5kZXggKXtcbiAgICBjb25zb2xlLmRlYnVnKCAnSWQ6ICcgKyBpICsgJ1xcbkluZGV4OiAnICsgbGF5b3V0SW5mby5pZFRvSW5kZXhbIGkgXSApO1xuICB9XG5cbiAgY29uc29sZS5kZWJ1ZyggJ0dyYXBoIFNldCcgKTtcbiAgdmFyIHNldCA9IGxheW91dEluZm8uZ3JhcGhTZXQ7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArKyApe1xuICAgIGNvbnNvbGUuZGVidWcoICdTZXQgOiAnICsgaSArICc6ICcgKyBzZXRbIGkgXS50b1N0cmluZygpICk7XG4gIH1cblxuICB2YXIgcyA9ICdJbmRleFRvR3JhcGgnO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uaW5kZXhUb0dyYXBoLmxlbmd0aDsgaSArKyApe1xuICAgIHMgKz0gJ1xcbkluZGV4IDogJyArIGkgKyAnIEdyYXBoOiAnICsgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbIGkgXTtcbiAgfVxuICBjb25zb2xlLmRlYnVnKCBzICk7XG5cbiAgcyA9ICdMYXlvdXQgRWRnZXMnO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubGF5b3V0RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbIGkgXTtcbiAgICBzICs9ICdcXG5FZGdlIEluZGV4OiAnICsgaSArICcgSUQ6ICcgKyBlLmlkICtcbiAgICAnIFNvdWNlSUQ6ICcgKyBlLnNvdXJjZUlkICsgJyBUYXJnZXRJZDogJyArIGUudGFyZ2V0SWQgK1xuICAgICcgSWRlYWwgTGVuZ3RoOiAnICsgZS5pZGVhbExlbmd0aDtcbiAgfVxuICBjb25zb2xlLmRlYnVnKCBzICk7XG5cbiAgcyA9ICAnbm9kZVNpemU6ICcgKyBsYXlvdXRJbmZvLm5vZGVTaXplO1xuICBzICs9ICdcXG5lZGdlU2l6ZTogJyArIGxheW91dEluZm8uZWRnZVNpemU7XG4gIHMgKz0gJ1xcbnRlbXBlcmF0dXJlOiAnICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZTtcbiAgY29uc29sZS5kZWJ1ZyggcyApO1xuXG4gIHJldHVybjtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xufTtcblxuXG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24oIGxheW91dEluZm8sIGN5ICl7XG4gIHZhciB3aWR0aCAgICAgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ICAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKysgKXtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcblxuICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuICAgIGlmKCAwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCApe1xuICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgY3ksIG9wdGlvbnMgKXtcbiAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICB2YXIgbGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQ7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuXG4gIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgbm9kZXMuZm9yRWFjaCggZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBub2RlLmRhdGEoICdpZCcgKSBdIF07XG5cbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKCBjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCApO1xuICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoIGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YICk7XG5cbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKCBjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoIGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgfSApO1xuXG4gICAgY29zZUJCLncgPSBjb3NlQkIueDIgLSBjb3NlQkIueDE7XG4gICAgY29zZUJCLmggPSBjb3NlQkIueTIgLSBjb3NlQkIueTE7XG4gIH1cblxuICBub2Rlcy5wb3NpdGlvbnMoIGZ1bmN0aW9uKCBpLCBlbGUgKXtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZWxlLmRhdGEoICdpZCcgKSBdIF07XG4gICAgLy8gcyA9IFwiTm9kZTogXCIgKyBsbm9kZS5pZCArIFwiLiBSZWZyZXNoZWQgcG9zaXRpb246IChcIiArXG4gICAgLy8gbG5vZGUucG9zaXRpb25YICsgXCIsIFwiICsgbG5vZGUucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXsgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbG5vZGUucG9zaXRpb25YLFxuICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcbiAgaWYoIHRydWUgIT09IGxheW91dEluZm8ucmVhZHkgKXtcbiAgICAvLyBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgIGxheW91dC5vbmUoICdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkgKTtcbiAgICBsYXlvdXQudHJpZ2dlciggeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IHRoaXMgfSApO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gKi9cbi8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgaWYgKERFQlVHKSB7XG4vLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbi8vICAgfVxuLy8gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3NlTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLCAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiggbm9kZSApe30sIC8vIHJldHVybnMgeyByb3csIGNvbCB9IGZvciBlbGVtZW50XG4gIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gR3JpZExheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cbkdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuXG4gIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIGlmKCBiYi5oID09PSAwIHx8IGJiLncgPT09IDAgKXtcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4geyB4OiBiYi54MSwgeTogYmIueTEgfTtcbiAgICB9ICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmggLyBiYi53ICk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKCBzcGxpdHMgKTtcbiAgICB2YXIgY29scyA9IE1hdGgucm91bmQoIGJiLncgLyBiYi5oICogc3BsaXRzICk7XG5cbiAgICB2YXIgc21hbGwgPSBmdW5jdGlvbiggdmFsICl7XG4gICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKCByb3dzLCBjb2xzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oIHJvd3MsIGNvbHMgKTtcbiAgICAgICAgaWYoIG1pbiA9PSByb3dzICl7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoIHJvd3MsIGNvbHMgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCggcm93cywgY29scyApO1xuICAgICAgICBpZiggbWF4ID09IHJvd3MgKXtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9Sb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgIHZhciBvQ29scyA9IG9wdGlvbnMuY29scyAhPSBudWxsID8gb3B0aW9ucy5jb2xzIDogb3B0aW9ucy5jb2x1bW5zO1xuXG4gICAgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcbiAgICBpZiggb1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsICl7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgfSBlbHNlIGlmKCBvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwgKXtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBNYXRoLmNlaWwoIGNlbGxzIC8gcm93cyApO1xuICAgIH0gZWxzZSBpZiggb1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsICl7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgICByb3dzID0gTWF0aC5jZWlsKCBjZWxscyAvIGNvbHMgKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcblxuICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgZWxzZSBpZiggY29scyAqIHJvd3MgPiBjZWxscyApe1xuICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgaWYoIChzbSAtIDEpICogbGcgPj0gY2VsbHMgKXtcbiAgICAgICAgc21hbGwoIHNtIC0gMSApO1xuICAgICAgfSBlbHNlIGlmKCAobGcgLSAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgIGxhcmdlKCBsZyAtIDEgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgd2hpbGUoIGNvbHMgKiByb3dzIDwgY2VsbHMgKXtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgICAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG4gICAgICAgIGlmKCAobGcgKyAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgICAgbGFyZ2UoIGxnICsgMSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYWxsKCBzbSArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYoIG9wdGlvbnMuY29uZGVuc2UgKXtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBpZiggcG9zLnggPT0gbnVsbCB8fCBwb3MueSA9PSBudWxsICl7IC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmJiID0gbm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcblxuICAgICAgICB2YXIgdyA9IG5iYi53ICsgcDtcbiAgICAgICAgdmFyIGggPSBuYmIuaCArIHA7XG5cbiAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoIGNlbGxXaWR0aCwgdyApO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoIGNlbGxIZWlnaHQsIGggKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24oIHJvdywgY29sICl7XG4gICAgICByZXR1cm4gY2VsbFVzZWRbICdjLScgKyByb3cgKyAnLScgKyBjb2wgXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uKCByb3csIGNvbCApe1xuICAgICAgY2VsbFVzZWRbICdjLScgKyByb3cgKyAnLScgKyBjb2wgXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIGNvbCA9IDA7XG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24oKXtcbiAgICAgIGNvbCsrO1xuICAgICAgaWYoIGNvbCA+PSBjb2xzICl7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICB2YXIgaWQybWFuUG9zID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICBpZiggcmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSApeyAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICBwb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKCBwb3Mucm93LCBwb3MuY29sICkgKXtcbiAgICAgICAgICAgIHBvcy5jb2wrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggcG9zLnJvdyA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgIHBvcy5yb3cgPSAwO1xuXG4gICAgICAgICAgd2hpbGUoIHVzZWQoIHBvcy5yb3csIHBvcy5jb2wgKSApe1xuICAgICAgICAgICAgcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlkMm1hblBvc1sgbm9kZS5pZCgpIF0gPSBwb3M7XG4gICAgICAgIHVzZSggcG9zLnJvdywgcG9zLmNvbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgZWxlbWVudCApe1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zWyBlbGVtZW50LmlkKCkgXTtcbiAgICAgIGlmKCByY1BvcyApe1xuICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuXG4gICAgICAgIHdoaWxlKCB1c2VkKCByb3csIGNvbCApICl7XG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgdXNlKCByb3csIGNvbCApO1xuXG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblxuICAgIH07XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZExheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgbmFtZTogJ2JyZWFkdGhmaXJzdCcsIGltcGw6IHJlcXVpcmUoICcuL2JyZWFkdGhmaXJzdCcgKSB9LFxuICB7IG5hbWU6ICdjaXJjbGUnLCBpbXBsOiByZXF1aXJlKCAnLi9jaXJjbGUnICkgfSxcbiAgeyBuYW1lOiAnY29uY2VudHJpYycsaW1wbDogcmVxdWlyZSggJy4vY29uY2VudHJpYycgKSB9LFxuICB7IG5hbWU6ICdjb3NlJywgaW1wbDogcmVxdWlyZSggJy4vY29zZScgKSB9LFxuICB7IG5hbWU6ICdncmlkJywgaW1wbDogcmVxdWlyZSggJy4vZ3JpZCcgKSB9LFxuICB7IG5hbWU6ICdudWxsJywgaW1wbDogcmVxdWlyZSggJy4vbnVsbCcgKSB9LFxuICB7IG5hbWU6ICdwcmVzZXQnLCBpbXBsOiByZXF1aXJlKCAnLi9wcmVzZXQnICkgfSxcbiAgeyBuYW1lOiAncmFuZG9tJywgaW1wbDogcmVxdWlyZSggJy4vcmFuZG9tJyApIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbi8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbnZhciBkZWZhdWx0cyA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3Bcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbmZ1bmN0aW9uIE51bGxMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG4vLyBydW5zIHRoZSBsYXlvdXRcbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gIGxheW91dC50cmlnZ2VyKCAnbGF5b3V0c3RhcnQnICk7XG5cbiAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSApO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICBsYXlvdXQudHJpZ2dlciggJ2xheW91dHJlYWR5JyApO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gIGxheW91dC5vbmUoICdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wICk7XG4gIGxheW91dC50cmlnZ2VyKCAnbGF5b3V0c3RvcCcgKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHBvc2l0aW9uczogdW5kZWZpbmVkLCAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICB6b29tOiB1bmRlZmluZWQsIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgcGFuOiB1bmRlZmluZWQsIC8vIHRoZSBwYW4gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gaXMuZm4oIG9wdGlvbnMucG9zaXRpb25zICk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oIG5vZGUgKXtcbiAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbIG5vZGUuX3ByaXZhdGUuZGF0YS5pZCBdO1xuXG4gICAgaWYoIHBvcyA9PSBudWxsICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiggaSwgbm9kZSApe1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKCBub2RlICk7XG5cbiAgICBpZiggbm9kZS5sb2NrZWQoKSB8fCBwb3NpdGlvbiA9PSBudWxsICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9ICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldExheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uL21hdGgnICk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCwgLy8gZml0IHBhZGRpbmdcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIFJhbmRvbUxheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cblJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCAnOnBhcmVudCcgKTtcblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLncgKSxcbiAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLmggKVxuICAgIH07XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuXG5CUnAucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcnJvd1NoYXBlcyA9IHRoaXMuYXJyb3dTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB4MiA9IHRyYW5zbGF0aW9uLnggKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIHkxID0gdHJhbnNsYXRpb24ueSAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuXG4gICAgdmFyIGluc2lkZSA9ICh4MSA8PSB4ICYmIHggPD0geDIpICYmICh5MSA8PSB5ICYmIHkgPD0geTIpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyggYW5nbGUgKSAtIHkgKiBNYXRoLnNpbiggYW5nbGUgKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oIGFuZ2xlICkgKyB5ICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cbiAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcblxuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiggcHRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMiApe1xuICAgICAgdmFyIHggPSBwdHNbIGkgXTtcbiAgICAgIHZhciB5ID0gcHRzWyBpICsgMV07XG5cbiAgICAgIHJldFB0cy5wdXNoKCB0cmFuc2Zvcm0oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFB0cztcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiggcHRzICl7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwID0gcHRzWyBpIF07XG5cbiAgICAgIHJldC5wdXNoKCBwLngsIHAueSApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24oIGVkZ2UgKSB7XG4gICAgcmV0dXJuIGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkucGZWYWx1ZSAqIDI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiggbmFtZSwgZGVmbiApe1xuICAgIGlmKCBpcy5zdHJpbmcoIGRlZm4gKSApe1xuICAgICAgZGVmbiA9IGFycm93U2hhcGVzWyBkZWZuIF07XG4gICAgfVxuXG4gICAgYXJyb3dTaGFwZXNbIG5hbWUgXSA9IHV0aWwuZXh0ZW5kKCB7XG4gICAgICBuYW1lOiBuYW1lLFxuXG4gICAgICBwb2ludHM6IFtcbiAgICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAgIDAuMTUsIDAuMyxcbiAgICAgICAgLTAuMTUsIDAuM1xuICAgICAgXSxcblxuICAgICAgY29sbGlkZTogZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRzVG9BcnIoIHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKTtcblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcblxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCAncG9seWdvbicgKSggY29udGV4dCwgcG9pbnRzICk7XG4gICAgICB9LFxuXG4gICAgICBzcGFjaW5nOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG5cbiAgICAgIGdhcDogc3RhbmRhcmRHYXBcbiAgICB9LCBkZWZuICk7XG4gIH07XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ25vbmUnLCB7XG4gICAgY29sbGlkZTogdXRpbC5mYWxzaWZ5LFxuXG4gICAgcm91Z2hDb2xsaWRlOiB1dGlsLmZhbHNpZnksXG5cbiAgICBkcmF3OiB1dGlsLm5vb3AsXG5cbiAgICBzcGFjaW5nOiB1dGlsLnplcm9pZnksXG5cbiAgICBnYXA6IHV0aWwuemVyb2lmeVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3RyaWFuZ2xlJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuM1xuICAgIF1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdhcnJvdycsICd0cmlhbmdsZScgKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgIHBvaW50czogYXJyb3dTaGFwZXNbICd0cmlhbmdsZScgXS5wb2ludHMsXG5cbiAgICBjb250cm9sUG9pbnQ6IFsgMCwgLTAuMTUgXSxcblxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oIGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoIHRoaXMubmFtZSApKCBjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMgKTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuOTg1O1xuICAgIH1cbiAgfSApO1xuXG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF0sXG5cbiAgICBwb2ludHNUZWU6IFtcbiAgICAgIC0wLjE1LCAtMC40LFxuICAgICAgLTAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNFxuICAgIF0sXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIoIHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuXG4gICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRyaVB0cyApIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCB0ZWVQdHMgKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHNUZWUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyaVB0cywgdGVlUHRzICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcblxuICAgIGNyb3NzTGluZVBvaW50czogW1xuICAgICAgLTAuMjQxNzUsIC0wLjQsXG4gICAgICAwLjI0MTc1LCAtMC40LFxuICAgIF0sXG5cbiAgICBmb3JjZVN0cm9rZTogdHJ1ZSxcblxuICAgIG1hdGNoRWRnZVdpZHRoOiB0cnVlLFxuXG4gICAgc2NhbGVDb29yZDogZnVuY3Rpb24gKCBjb25zdGFudCwgc2l6ZSwgZWRnZVdpZHRoICl7XG4gICAgIHJldHVybiBjb25zdGFudCArICggZWRnZVdpZHRoICogMC4wMTIgKSArICggbWF0aC5sb2cyKCBzaXplIC0gMjguOTUgKSAqIDAuMDAxICk7XG4gICAgfSxcblxuICAgc2NhbGVDcm9zc0xpbmVYQ29vcmQ6IGZ1bmN0aW9uKCBzaXplLCBlZGdlV2lkdGggKXtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlQ29vcmQoIDAuNDIsIHNpemUsIGVkZ2VXaWR0aCApO1xuICAgIH0sXG5cbiAgICBzY2FsZUNyb3NzTGluZVlDb29yZDogZnVuY3Rpb24oIHNpemUsIGVkZ2VXaWR0aCApe1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVDb29yZCggLTAuMDEsIHNpemUsIGVkZ2VXaWR0aCApO1xuICAgIH0sXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIoIHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLmNyb3NzTGluZVBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuXG4gICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRyaVB0cyApXG4gICAgICB8fCBtYXRoLmluTGluZVZpY2luaXR5KCB4LCB5LFxuICAgICAgICBjcm9zc0xpbmVQdHNbMF0sIGNyb3NzTGluZVB0c1sxXSwgY3Jvc3NMaW5lUHRzWzJdLCBjcm9zc0xpbmVQdHNbM10sIHBhZGRpbmcgKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoICl7XG4gICAgICB2YXIgc2NhbGVkQ3Jvc3NMaW5lID0gW1xuICAgICAgICB0aGlzLmNyb3NzTGluZVBvaW50c1swXSArIHRoaXMuc2NhbGVDcm9zc0xpbmVYQ29vcmQoIHNpemUsIGVkZ2VXaWR0aCApLFxuICAgICAgICB0aGlzLmNyb3NzTGluZVBvaW50c1sxXSAtIHRoaXMuc2NhbGVDcm9zc0xpbmVZQ29vcmQoIHNpemUsIGVkZ2VXaWR0aCApLFxuICAgICAgICB0aGlzLmNyb3NzTGluZVBvaW50c1syXSAtIHRoaXMuc2NhbGVDcm9zc0xpbmVYQ29vcmQoIHNpemUsIGVkZ2VXaWR0aCApLFxuICAgICAgICB0aGlzLmNyb3NzTGluZVBvaW50c1szXSAtIHRoaXMuc2NhbGVDcm9zc0xpbmVZQ29vcmQoIHNpemUsIGVkZ2VXaWR0aCApXG4gICAgICBdO1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHRyYW5zZm9ybVBvaW50cyggc2NhbGVkQ3Jvc3NMaW5lLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoIHRoaXMubmFtZSApKCBjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyApO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd2ZWUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgMCwgLTAuMTVcbiAgICBdLFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC45ODU7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2NpcmNsZScsIHtcbiAgICByYWRpdXM6IDAuMTUsXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgdmFyIGluc2lkZSA9ICggTWF0aC5wb3coIHQueCAtIHgsIDIgKSArIE1hdGgucG93KCB0LnkgLSB5LCAyICkgPD0gTWF0aC5wb3coIChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIgKSApO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSApO1xuICAgIH0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoIGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSwgZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZSApXG4gICAgICAgICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2luaGliaXRvcicsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAwLFxuICAgICAgLTAuMTUsIC0wLjEsXG4gICAgICAwLjE1LCAtMC4xLFxuICAgICAgMC4xNSwgMFxuICAgIF0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGdhcDogZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0ZWUnLCAnaW5oaWJpdG9yJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdXG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4xNSxcbiAgICAgIDAsIC0wLjMsXG4gICAgICAwLjE1LCAtMC4xNSxcbiAgICAgIDAsIDBcbiAgICBdLFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkudmFsdWU7XG4gICAgfVxuICB9ICk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciB6SW5kZXhTb3J0ID0gcmVxdWlyZSggJy4uLy4uLy4uL2NvbGxlY3Rpb24venNvcnQnICk7XG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uLy4uLy4uL3dpbmRvdycgKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uKCBlbGVzLCBlICl7XG4gICAgZWxlc1RvVXBkYXRlLm1lcmdlKCBlbGVzICk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICBfcC5iYkNhY2hlID0gbnVsbDtcblxuICAgICAgdmFyIGV2dHMgPSByc3R5bGUuZGlydHlFdmVudHMgPSByc3R5bGUuZGlydHlFdmVudHMgfHwgeyBsZW5ndGg6IDAgfTtcblxuICAgICAgaWYoICFldnRzWyBlLnR5cGUgXSApe1xuICAgICAgICBldnRzWyBlLnR5cGUgXSA9IHRydWU7XG4gICAgICAgIGV2dHMubGVuZ3RoKys7XG4vL1xuICAgICAgICAvLyBlbGVzVG9VcGRhdGUubWVyZ2UoIGVsZSApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByLmJpbmRlciggY3kgKVxuICAgIC8vIG5vZGVzXG5cbiAgICAub24oJ3Bvc2l0aW9uLiogc3R5bGUuKiBmcmVlLionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlNb2ROb2RlKCBlICl7XG4gICAgICB2YXIgbm9kZSA9IGUuY3lUYXJnZXQ7XG5cbiAgICAgIGVucXVldWUoIG5vZGUsIGUgKTtcbiAgICAgIGVucXVldWUoIG5vZGUuY29ubmVjdGVkRWRnZXMoKSwgZSApO1xuXG4gICAgICBpZiggY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgIHZhciBwYXJlbnRzID0gbm9kZS5wYXJlbnRzKCk7XG5cbiAgICAgICAgZW5xdWV1ZSggcGFyZW50cywgZSApO1xuICAgICAgICBlbnF1ZXVlKCBwYXJlbnRzLmNvbm5lY3RlZEVkZ2VzKCksIGUgKTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLm9uKCdhZGQuKiBiYWNrZ3JvdW5kLionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlBZGROb2RlKCBlICl7XG4gICAgICB2YXIgZWxlID0gZS5jeVRhcmdldDtcblxuICAgICAgZW5xdWV1ZSggZWxlLCBlICk7XG4gICAgfSlcblxuICAgIC8vIGVkZ2VzXG5cbiAgICAub24oJ2FkZC4qIHN0eWxlLionLCAnZWRnZScsIGZ1bmN0aW9uIG9uRGlydHlFZGdlKCBlICl7XG4gICAgICB2YXIgZWRnZSA9IGUuY3lUYXJnZXQ7XG5cbiAgICAgIGVucXVldWUoIGVkZ2UsIGUgKTtcbiAgICAgIGVucXVldWUoIGVkZ2UucGFyYWxsZWxFZGdlcygpLCBlICk7XG4gICAgfSlcblxuICAgIC5vbigncmVtb3ZlLionLCAnZWRnZScsIGZ1bmN0aW9uIG9uRGlydHlSZW1vdmVFZGdlKCBlICl7XG4gICAgICB2YXIgZWRnZSA9IGUuY3lUYXJnZXQ7XG4gICAgICB2YXIgcEVkZ2VzID0gZWRnZS5wYXJhbGxlbEVkZ2VzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwRWRnZSA9IHBFZGdlc1tpXTtcblxuICAgICAgICBpZiggIXBFZGdlLnJlbW92ZWQoKSApe1xuICAgICAgICAgIGVucXVldWUoIHBFZGdlLCBlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICA7XG5cbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24oIHdpbGxEcmF3ICl7XG4gICAgaWYoIHdpbGxEcmF3ICl7XG4gICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zO1xuXG4gICAgICBpZiggZm5zICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmbiA9IGZuc1tpXTtcblxuICAgICAgICBmbiggd2lsbERyYXcsIGVsZXNUb1VwZGF0ZSApO1xuICAgICAgfSB9XG5cbiAgICAgIHIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCBlbGVzVG9VcGRhdGUsIGZhbHNlICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvVXBkYXRlLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVsZXNUb1VwZGF0ZVtpXS5fcHJpdmF0ZS5yc3R5bGUuZGlydHlFdmVudHMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIHIuYmVmb3JlUmVuZGVyKCB1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzICk7XG59O1xuXG5CUnAub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uKCBmbiApe1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuXG4gIGZucy5wdXNoKCBmbiApO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVzLCB1c2VDYWNoZSApe1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG4gIGlmKCB0aGlzLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuICBpZiggdXNlQ2FjaGUgPT09IHVuZGVmaW5lZCApeyB1c2VDYWNoZSA9IHRydWU7IH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG4gICAgaWYoICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4pIHx8IGVsZS5yZW1vdmVkKCkgKXsgY29udGludWU7IH1cblxuICAgIC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG4gICAgaWYoIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnICl7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSB7IC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICB9XG5cbiAgICByc3R5bGUuY2xlYW4gPSB0cnVlO1xuICAgIC8vIHJzdHlsZS5kaXJ0eUV2ZW50cyA9IG51bGw7XG4gIH1cblxuICAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiggZWxlICk7XG5cbiAgICByc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICByc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICByc3R5bGUubm9kZVcgPSBlbGUucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZTtcbiAgICByc3R5bGUubm9kZUggPSBlbGUucHN0eWxlKCAnaGVpZ2h0JyApLnBmVmFsdWU7XG4gIH1cblxuICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKCBlZGdlcyApO1xuXG4gIC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVkZ2VzWyBpIF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoIGVsZSApO1xuXG4gICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICByc3R5bGUuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHJzdHlsZS5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgcnN0eWxlLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgcnN0eWxlLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgcnN0eWxlLm1pZFggPSBycy5taWRYO1xuICAgIHJzdHlsZS5taWRZID0gcnMubWlkWTtcbiAgICByc3R5bGUubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgIHJzdHlsZS50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxuLy8gUHJvamVjdCBtb3VzZVxuQlJwLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiggY2xpZW50WCwgY2xpZW50WSApe1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gIHZhciB4ID0gKCBjbGllbnRYIC0gb2Zmc2V0TGVmdCAtIHBhbi54ICkgLyB6b29tO1xuICB2YXIgeSA9ICggY2xpZW50WSAtIG9mZnNldFRvcCAtIHBhbi55ICkgLyB6b29tO1xuXG4gIHJldHVybiBbIHgsIHkgXTtcbn07XG5cbkJScC5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24oKXtcbiAgaWYoIHRoaXMuY29udGFpbmVyQkIgKXtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQjtcbiAgfVxuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250YWluZXIgKTtcbiAgdmFyIHN0eWxlVmFsdWUgPSBmdW5jdGlvbiggbmFtZSApeyByZXR1cm4gcGFyc2VGbG9hdCggc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApICk7IH07XG4gIHZhciBleHRyYSA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSArIHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJykgKyBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgfTtcblxuICByZXR1cm4gKCB0aGlzLmNvbnRhaW5lckJCID0gWyAvLyB4LCB5LCB3LCBoXG4gICAgcmVjdC5sZWZ0ICsgZXh0cmEubGVmdCxcbiAgICByZWN0LnRvcCArIGV4dHJhLnRvcCxcbiAgICByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IC0gZXh0cmEubGVmdCAtIGV4dHJhLnJpZ2h0LFxuICAgIHJlY3QuYm90dG9tIC0gcmVjdC50b3AgLSBleHRyYS50b3AgLSBleHRyYS5ib3R0b21cbiAgXSApO1xufTtcblxuQlJwLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xufTtcblxuQlJwLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uKCB4LCB5LCBpc1RvdWNoICl7XG4gIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoIHgsIHksIGlzVG91Y2ggKVswXTtcbn07XG5cbkJScC5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24oIHgsIHksIGlzVG91Y2ggKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuXG4gIGZ1bmN0aW9uIGFkZEVsZSggZWxlLCBzcURpc3QgKXtcbiAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICBpZiggbmVhck5vZGUgKXtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCByZXBsYWNlIG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXJOb2RlID0gZWxlO1xuICAgICAgICBuZWFyLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgJiYgKCBzcURpc3QgPT0gbnVsbCB8fCBzcURpc3QgPCBtaW5TcURpc3QgKSApe1xuICAgICAgaWYoIG5lYXJFZGdlICl7IC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmKCBuZWFyRWRnZS5wc3R5bGUoICd6LWluZGV4JyApLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWluZGV4JykudmFsdWUgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGlmKCBuZWFyW2ldLmlzRWRnZSgpICl7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goIGVsZSApO1xuICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tOb2RlKCBub2RlICl7XG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcblxuICAgIGlmKCBub2RlLnBzdHlsZSggJ2V2ZW50cycgKS5zdHJWYWx1ZSA9PT0gJ25vJyApeyByZXR1cm47IH1cblxuICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcblxuICAgIGlmKFxuICAgICAgcG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgICAgICYmXG4gICAgICBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApe1xuICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzWyBzZWxmLmdldE5vZGVTaGFwZSggbm9kZSApIF07XG5cbiAgICAgIGlmKFxuICAgICAgICBzaGFwZS5jaGVja1BvaW50KCB4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkgKVxuICAgICAgKXtcbiAgICAgICAgYWRkRWxlKCBub2RlLCAwICk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlICl7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcblxuICAgIGlmKCBlZGdlLnBzdHlsZSgnZXZlbnRzJykuc3RyVmFsdWUgPT09ICdubycgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSggJ2Fycm93LXNjYWxlJyApLnZhbHVlO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlV2lkdGggLyAyICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG4gICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBpbkVkZ2VCQiA9IGZhbHNlO1xuICAgIHZhciBzcURpc3Q7XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gMiApe1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSBtYXRoLmluTGluZVZpY2luaXR5KCB4LCB5LCBwdHNbIGkgXSwgcHRzWyBpICsgMV0sIHB0c1sgaSArIDJdLCBwdHNbIGkgKyAzXSwgd2lkdGgyICkpXG4gICAgICAgICAgICAmJlxuICAgICAgICAgIHdpZHRoU3EgPiAoIHNxRGlzdCA9IG1hdGguc3FkaXN0VG9GaW5pdGVMaW5lKCB4LCB5LCBwdHNbIGkgXSwgcHRzWyBpICsgMV0sIHB0c1sgaSArIDJdLCBwdHNbIGkgKyAzXSApIClcbiAgICAgICAgKXtcbiAgICAgICAgICBhZGRFbGUoIGVkZ2UsIHNxRGlzdCApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICAgIGlmKFxuICAgICAgICAgIChpbkVkZ2VCQiA9IG1hdGguaW5CZXppZXJWaWNpbml0eSggeCwgeSwgcHRzWyBpIF0sIHB0c1sgaSArIDFdLCBwdHNbIGkgKyAyXSwgcHRzWyBpICsgM10sIHB0c1sgaSArIDRdLCBwdHNbIGkgKyA1XSwgd2lkdGgyICkpXG4gICAgICAgICAgICAmJlxuICAgICAgICAgICh3aWR0aFNxID4gKHNxRGlzdCA9IG1hdGguc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoIHgsIHksIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSwgcHRzWyBpICsgMl0sIHB0c1sgaSArIDNdLCBwdHNbIGkgKyA0XSwgcHRzWyBpICsgNV0gKSkgKVxuICAgICAgICApe1xuICAgICAgICAgIGFkZEVsZSggZWRnZSwgc3FEaXN0ICk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuICAgIHZhciBzcmMgPSBzcmMgfHwgX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuXG4gICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aCggc3R5bGVXaWR0aCwgc2NhbGUgKTtcblxuICAgIHZhciBhcnJvd3MgPSBbXG4gICAgICB7IG5hbWU6ICdzb3VyY2UnLCB4OiBycy5hcnJvd1N0YXJ0WCwgeTogcnMuYXJyb3dTdGFydFksIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQnLCB4OiBycy5hcnJvd0VuZFgsIHk6IHJzLmFycm93RW5kWSwgYW5nbGU6IHJzLnRndEFycm93QW5nbGUgfSxcbiAgICAgIHsgbmFtZTogJ21pZC1zb3VyY2UnLCB4OiBycy5taWRYLCB5OiBycy5taWRZLCBhbmdsZTogcnMubWlkc3JjQXJyb3dBbmdsZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldCcsIHg6IHJzLm1pZFgsIHk6IHJzLm1pZFksIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlIH1cbiAgICBdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBhciA9IGFycm93c1sgaSBdO1xuICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1sgZWRnZS5wc3R5bGUoIGFyLm5hbWUgKyAnLWFycm93LXNoYXBlJyApLnZhbHVlIF07XG5cbiAgICAgIGlmKFxuICAgICAgICBzaGFwZS5yb3VnaENvbGxpZGUoIHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHsgeDogYXIueCwgeTogYXIueSB9LCBlZGdlVGhyZXNob2xkIClcbiAgICAgICAgICYmXG4gICAgICAgIHNoYXBlLmNvbGxpZGUoIHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHsgeDogYXIueCwgeTogYXIueSB9LCBlZGdlVGhyZXNob2xkIClcbiAgICAgICl7XG4gICAgICAgIGFkZEVsZSggZWRnZSApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcbiAgICBpZiggaGFzQ29tcG91bmRzICYmIG5lYXIubGVuZ3RoID4gMCApe1xuICAgICAgY2hlY2tOb2RlKCBzcmMgKTtcbiAgICAgIGNoZWNrTm9kZSggdGd0ICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcHJvcCggb2JqLCBuYW1lLCBwcmUgKXtcbiAgICByZXR1cm4gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCBvYmosIG5hbWUsIHByZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbCggZWxlLCBwcmVmaXggKXtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG5cbiAgICB2YXIgcHJlZml4RGFzaDtcbiAgICBpZiggcHJlZml4ICl7XG4gICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBlbGUucHN0eWxlKCBwcmVmaXhEYXNoICsgJ2xhYmVsJyApLnZhbHVlO1xuICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSggJ3RleHQtZXZlbnRzJyApLnN0clZhbHVlID09PSAneWVzJztcblxuICAgIGlmKCAhZXZlbnRzRW5hYmxlZCB8fCAhdGV4dCApeyByZXR1cm47IH1cblxuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIGJ3ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBwdyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcbiAgICB2YXIgbHcgPSBwcmVwcm9wKCByc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4ICkgKyBidyArIDIqdGggKyAyKnB3O1xuICAgIHZhciBsaCA9IHByZXByb3AoIHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4ICkgKyBidyArIDIqdGggKyAyKnB3O1xuICAgIHZhciBseCA9IHByZXByb3AoIHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCApO1xuICAgIHZhciBseSA9IHByZXByb3AoIHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCApO1xuXG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcCggX3AucnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4ICk7XG5cbiAgICB2YXIgbHgxID0gbHggLSBsdyAvIDI7XG4gICAgdmFyIGx4MiA9IGx4ICsgbHcgLyAyO1xuICAgIHZhciBseTEgPSBseSAtIGxoIC8gMjtcbiAgICB2YXIgbHkyID0gbHkgKyBsaCAvIDI7XG5cbiAgICBpZiggdGhldGEgKXtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyggdGhldGEgKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uKCB4LCB5ICl7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZSggbHgxLCBseTEgKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZSggbHgxLCBseTIgKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZSggbHgyLCBseTEgKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZSggbHgyLCBseTIgKTtcblxuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgcHgxeTEueCwgcHgxeTEueSxcbiAgICAgICAgcHgyeTEueCwgcHgyeTEueSxcbiAgICAgICAgcHgyeTIueCwgcHgyeTIueSxcbiAgICAgICAgcHgxeTIueCwgcHgxeTIueVxuICAgICAgXTtcblxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKSApe1xuICAgICAgICBhZGRFbGUoIGVsZSApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBkbyBhIGNoZWFwZXIgYmIgY2hlY2tcbiAgICAgIHZhciBiYiA9IHtcbiAgICAgICAgdzogbHcsXG4gICAgICAgIGg6IGxoLFxuICAgICAgICB4MTogbHgxLFxuICAgICAgICB4MjogbHgyLFxuICAgICAgICB5MTogbHkxLFxuICAgICAgICB5MjogbHkyXG4gICAgICB9O1xuXG4gICAgICBpZiggbWF0aC5pbkJvdW5kaW5nQm94KCBiYiwgeCwgeSApICl7XG4gICAgICAgIGFkZEVsZSggZWxlICk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgZm9yKCB2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXsgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICBjaGVja05vZGUoIGVsZSApIHx8IGNoZWNrTGFiZWwoIGVsZSApO1xuXG4gICAgfSBlbHNlIHsgLy8gdGhlbiBlZGdlXG4gICAgICBjaGVja0VkZ2UoIGVsZSApIHx8IGNoZWNrTGFiZWwoIGVsZSApIHx8IGNoZWNrTGFiZWwoIGVsZSwgJ3NvdXJjZScgKSB8fCBjaGVja0xhYmVsKCBlbGUsICd0YXJnZXQnICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXI7XG59O1xuXG4vLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5CUnAuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiggeDEsIHkxLCB4MiwgeTIgKXtcbiAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXM7XG4gIHZhciBlZGdlcyA9IGVsZXMuZWRnZXM7XG4gIHZhciBib3ggPSBbXTtcblxuICB2YXIgeDFjID0gTWF0aC5taW4oIHgxLCB4MiApO1xuICB2YXIgeDJjID0gTWF0aC5tYXgoIHgxLCB4MiApO1xuICB2YXIgeTFjID0gTWF0aC5taW4oIHkxLCB5MiApO1xuICB2YXIgeTJjID0gTWF0aC5tYXgoIHkxLCB5MiApO1xuXG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuXG4gIHZhciBib3hCYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCB7XG4gICAgeDE6IHgxLCB5MTogeTEsXG4gICAgeDI6IHgyLCB5MjogeTJcbiAgfSApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goIHtcbiAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICBpbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVTaGFkb3dzOiBmYWxzZVxuICAgIH0gKTtcblxuICAgIGlmKCBtYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGJveEJiLCBub2RlQmIgKSApe1xuICAgICAgYm94LnB1c2goIG5vZGVzWyBpIF0gKTtcbiAgICB9XG4gIH1cblxuICBmb3IoIHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrICl7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1sgZSBdO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICBpZiggcnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgIW1hdGguaW5Cb3VuZGluZ0JveCggYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZICkgKXsgY29udGludWU7IH1cbiAgICBpZiggcnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KCBib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcblxuICAgICAgdmFyIHB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCAhbWF0aC5wb2ludEluQm91bmRpbmdCb3goIGJveEJiLCBwdHNbIGkgXSApICl7XG4gICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGFsbEluc2lkZSApe1xuICAgICAgICBib3gucHVzaCggZWRnZSApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyApe1xuICAgICAgYm94LnB1c2goIGVkZ2UgKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGdpdmVuIG5vZGVcbiAqIGlzIHNldCB0byBhdXRvLCB0aGUgbm9kZSBpcyBjb25zaWRlcmVkIHRvIGJlIGEgY29tcG91bmQuXG4gKlxuICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBzaGFwZSBvZiB0aGUgbm9kZVxuICovXG5CUnAuZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZSggJ3NoYXBlJyApLnZhbHVlO1xuXG4gIGlmKCBub2RlLmlzUGFyZW50KCkgKXtcbiAgICBpZiggc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnICl7XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICB9XG4gIH1cblxuICBpZiggc2hhcGUgPT09ICdwb2x5Z29uJyApe1xuICAgIHZhciBwb2ludHMgPSBub2RlLnBzdHlsZSggJ3NoYXBlLXBvbHlnb24tcG9pbnRzJyApLnZhbHVlO1xuXG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbiggcG9pbnRzICkubmFtZTtcbiAgfVxuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbkJScC51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcblxuICBpZiggIWVsZXMgKXtcbiAgICAvLyBqdXN0IGxldCB0aGlzIGJlIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCB6IHNvcnQgdGlja1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZXMuZHJhZyA9IFtdO1xuICBlbGVzLm5vbmRyYWcgPSBbXTtcblxuICB2YXIgZ3JhYlRhcmdldHMgPSBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiggZWxlLmdyYWJiZWQoKSAmJiAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgIGdyYWJUYXJnZXRzLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSBpZiggcnMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKCBlbGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5ub25kcmFnLnB1c2goIGVsZSApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuICBmb3IoIHZhciBpID0gMDsgaSA8IGdyYWJUYXJnZXRzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGdyYWJUYXJnZXRzW2ldO1xuXG4gICAgZWxlcy5kcmFnLnB1c2goIGVsZSApO1xuICB9XG59O1xuXG5CUnAuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IG51bGw7XG59O1xuXG5CUnAuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiggZm9yY2VSZWNhbGMgKXtcbiAgaWYoIGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzICl7XG4gICAgdmFyIGN5RWxlcyA9IHRoaXMuY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgdmFyIGVsZXMgPSBbXTtcblxuICAgIGVsZXMubm9kZXMgPSBbXTtcbiAgICBlbGVzLmVkZ2VzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGN5RWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGN5RWxlc1tpXTtcblxuICAgICAgaWYoIGVsZS5hbmltYXRlZCgpIHx8IChlbGUudmlzaWJsZSgpICYmICFlbGUudHJhbnNwYXJlbnQoKSkgKXtcbiAgICAgICAgZWxlcy5wdXNoKCBlbGUgKTtcblxuICAgICAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgZWxlcy5ub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVzLmVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlcy5zb3J0KCB6SW5kZXhTb3J0ICk7XG5cbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcblxuICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgfVxuXG4gIHJldHVybiBlbGVzO1xufTtcblxuZnVuY3Rpb24gcHVzaEJlemllclB0cyggciwgZWRnZSwgcHRzICl7XG4gIHZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiggcDEsIHAyLCBwMywgdCApeyByZXR1cm4gbWF0aC5xYmV6aWVyQXQoIHAxLCBwMiwgcDMsIHQgKTsgfTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcblxuICAgIGJwdHMucHVzaCgge1xuICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCBwICksXG4gICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIHAgKVxuICAgIH0gKTtcbiAgfVxufVxuXG5CUnAucHJvamVjdExpbmVzID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuXG4gIC8vIGNsZWFyIHRoZSBjYWNoZWQgcG9pbnRzIHN0YXRlXG4gIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBudWxsO1xuICBfcC5yc3R5bGUubGluZVB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IG51bGw7XG5cbiAgaWYoIGV0ID09PSAnbXVsdGliZXppZXInIHx8ICBldCA9PT0gJ2JlemllcicgfHwgIGV0ID09PSAnc2VsZicgfHwgIGV0ID09PSAnY29tcG91bmQnICl7XG4gICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCB0aGlzLCBlZGdlLCBycy5hbGxwdHMuc2xpY2UoIGksIGkgKyA2ICkgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggIGV0ID09PSAnc2VnbWVudHMnICl7XG4gICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICBscHRzLnB1c2goIHtcbiAgICAgICAgeDogcnMuYWxscHRzWyBpIF0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1sgaSArIDFdXG4gICAgICB9ICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGV0ID09PSAnaGF5c3RhY2snICl7XG4gICAgdmFyIGhwdHMgPSBycy5oYXlzdGFja1B0cztcblxuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFtcbiAgICAgIHsgeDogaHB0c1swXSwgeTogaHB0c1sxXSB9LFxuICAgICAgeyB4OiBocHRzWzJdLCB5OiBocHRzWzNdIH1cbiAgICBdO1xuICB9XG5cbiAgX3AucnN0eWxlLmFycm93V2lkdGggPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkudmFsdWUgKVxuICAgICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG59O1xuXG5CUnAucHJvamVjdEJlemllciA9IEJScC5wcm9qZWN0TGluZXM7XG5cbkJScC5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggbm9kZSApe1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCAnbGFiZWwnICkuc3RyVmFsdWU7XG5cbiAgaWYoIGlzLmVtcHR5U3RyaW5nKGNvbnRlbnQpICl7IHJldHVybjsgfVxuXG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gIHZhciBub2RlUG9zID0gX3AucG9zaXRpb247XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoICd0ZXh0LWhhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRWYWxpZ24gPSBub2RlLnBzdHlsZSggJ3RleHQtdmFsaWduJyApLnN0clZhbHVlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHRleHRYID0gbm9kZVBvcy54IC0gbm9kZVdpZHRoIC8gMiAtIHBhZGRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHRleHRYID0gbm9kZVBvcy54ICsgbm9kZVdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyBlLmcuIG1pZGRsZVxuICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gIH1cblxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIG5vZGUgKTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIHA7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgfTtcblxuICBpZiggY29udGVudC5taWQgfHwgY29udGVudC5zb3VyY2UgfHwgY29udGVudC50YXJnZXQgKXtcbiAgICAvLyB0aGVuIHdlIGhhdmUgdG8gY2FsY3VsYXRlLi4uXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuOyAvLyBubyBsYWJlbHMgPT4gbm8gY2FsY3NcbiAgfVxuXG4gIC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gIC8vXG4gIHAgPSB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG5cbiAgdmFyIHNldFJzID0gZnVuY3Rpb24oIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICl7XG4gICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUgKTtcbiAgICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzdHlsZSwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUgKTtcbiAgfTtcblxuICBzZXRScyggJ2xhYmVsWCcsIG51bGwsIHAueCApO1xuICBzZXRScyggJ2xhYmVsWScsIG51bGwsIHAueSApO1xuXG4gIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24oKXtcbiAgICBpZiggY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSApeyByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZTsgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG4gICAgdmFyIGN0cmxwdHMgPSBbXTtcblxuICAgIC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuICAgIGZvciggdmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCApe1xuICAgICAgdmFyIHAwID0geyB4OiBycy5hbGxwdHNbaV0sIHk6IHJzLmFsbHB0c1tpKzFdIH07XG4gICAgICB2YXIgcDEgPSB7IHg6IHJzLmFsbHB0c1tpKzJdLCB5OiBycy5hbGxwdHNbaSszXSB9OyAvLyBjdHJscHRcbiAgICAgIHZhciBwMiA9IHsgeDogcnMuYWxscHRzW2krNF0sIHk6IHJzLmFsbHB0c1tpKzVdIH07XG5cbiAgICAgIGN0cmxwdHMucHVzaCh7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICBwMjogcDIsXG4gICAgICAgIHN0YXJ0RGlzdDogMCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBzZWdtZW50czogW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBhZGRTZWdtZW50KCBjcCwgcDAsIHAxLCB0MCwgdDEgKXtcbiAgICAgIHZhciBsZW5ndGggPSBtYXRoLmRpc3QoIHAwLCBwMSApO1xuICAgICAgdmFyIHByZXZTZWdtZW50ID0gY3Auc2VnbWVudHNbIGNwLnNlZ21lbnRzLmxlbmd0aCAtIDEgXTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgdDA6IHQwLFxuICAgICAgICB0MTogdDEsXG4gICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfTtcblxuICAgICAgY3Auc2VnbWVudHMucHVzaCggc2VnbWVudCApO1xuXG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBlYWNoIGN0cmxwdCB3aXRoIHNlZ21lbnQgaW5mb1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY3RybHB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tpXTtcbiAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW2kgLSAxXTtcblxuICAgICAgaWYoIHByZXZDcCApe1xuICAgICAgICBjcC5zdGFydERpc3QgPSBwcmV2Q3Auc3RhcnREaXN0ICsgcHJldkNwLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgYWRkU2VnbWVudChcbiAgICAgICAgY3AsXG4gICAgICAgIGNwLnAwLCAgIGJwdHNbIGkgKiBuUHJvanMgXSxcbiAgICAgICAgMCwgICAgICAgci5iZXppZXJQcm9qUGN0c1sgMCBdXG4gICAgICApOyAvLyBmaXJzdFxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKyApe1xuICAgICAgICBhZGRTZWdtZW50KFxuICAgICAgICAgIGNwLFxuICAgICAgICAgIGJwdHNbIGkgKiBuUHJvanMgKyBqIF0sICAgYnB0c1sgaSAqIG5Qcm9qcyArIGogKyAxIF0sXG4gICAgICAgICAgci5iZXppZXJQcm9qUGN0c1sgaiBdLCAgICByLmJlemllclByb2pQY3RzWyBqICsgMSBdXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGFkZFNlZ21lbnQoXG4gICAgICAgIGNwLFxuICAgICAgICBicHRzWyBpICogblByb2pzICsgblByb2pzIC0gMSBdLCAgIGNwLnAyLFxuICAgICAgICByLmJlemllclByb2pQY3RzWyBuUHJvanMgLSAxIF0sICAgIDFcbiAgICAgICk7IC8vIGxhc3RcbiAgICB9XG5cbiAgICByZXR1cm4gKCBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlID0gY3RybHB0cyApO1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uID0gZnVuY3Rpb24oIHByZWZpeCApe1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuXG4gICAgaWYoICFjb250ZW50WyBwcmVmaXggXSApeyByZXR1cm47IH1cblxuICAgIHZhciBvZmZzZXQgPSBlZGdlLnBzdHlsZShwcmVmaXgrJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICB2YXIgbGluZUFuZ2xlID0gZnVuY3Rpb24oIHAwLCBwMSApe1xuICAgICAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gICAgICB2YXIgZHkgPSBwMS55IC0gcDAueTtcblxuICAgICAgcmV0dXJuIE1hdGguYXRhbiggZHkgLyBkeCApO1xuICAgIH07XG5cbiAgICB2YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgdCApe1xuICAgICAgdmFyIHQwID0gbWF0aC5ib3VuZCggMCwgdCAtIDAuMDAxLCAxICk7XG4gICAgICB2YXIgdDEgPSBtYXRoLmJvdW5kKCAwLCB0ICsgMC4wMDEsIDEgKTtcblxuICAgICAgdmFyIGxwMCA9IG1hdGgucWJlemllclB0QXQoIHAwLCBwMSwgcDIsIHQwICk7XG4gICAgICB2YXIgbHAxID0gbWF0aC5xYmV6aWVyUHRBdCggcDAsIHAxLCBwMiwgdDEgKTtcblxuICAgICAgcmV0dXJuIGxpbmVBbmdsZSggbHAwLCBscDEgKTtcbiAgICB9O1xuXG4gICAgc3dpdGNoKCBycy5lZGdlVHlwZSApe1xuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICB2YXIgY3BzID0gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpO1xuICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgIHZhciBzdGFydERpc3QgPSAwO1xuICAgICAgICB2YXIgdG90YWxEaXN0ID0gMDtcblxuICAgICAgICAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGNwID0gY3BzWyBpc1NyYyA/IGkgOiBjcHMubGVuZ3RoIC0gMSAtIGkgXTtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3Auc2VnbWVudHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBzZWcgPSBjcC5zZWdtZW50c1sgaXNTcmMgPyBqIDogY3Auc2VnbWVudHMubGVuZ3RoIC0gMSAtIGogXTtcbiAgICAgICAgICAgIHZhciBsYXN0U2VnID0gaSA9PT0gY3BzLmxlbmd0aCAtIDEgJiYgaiA9PT0gY3Auc2VnbWVudHMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgc3RhcnREaXN0ID0gdG90YWxEaXN0O1xuICAgICAgICAgICAgdG90YWxEaXN0ICs9IHNlZy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmKCB0b3RhbERpc3QgPj0gb2Zmc2V0IHx8IGxhc3RTZWcgKXtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7IGNwOiBjcCwgc2VnbWVudDogc2VnIH07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBzZWxlY3RlZCApeyBicmVhazsgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNwID0gc2VsZWN0ZWQuY3A7XG4gICAgICAgIHZhciBzZWcgPSBzZWxlY3RlZC5zZWdtZW50O1xuICAgICAgICB2YXIgdFNlZ21lbnQgPSAoIG9mZnNldCAtIHN0YXJ0RGlzdCApIC8gKCBzZWcubGVuZ3RoICk7XG4gICAgICAgIHZhciBzZWdEdCA9IHNlZy50MSAtIHNlZy50MDtcbiAgICAgICAgdmFyIHQgPSBpc1NyYyA/IHNlZy50MCArIHNlZ0R0ICogdFNlZ21lbnQgOiBzZWcudDEgLSBzZWdEdCAqIHRTZWdtZW50O1xuXG4gICAgICAgIHQgPSBtYXRoLmJvdW5kKCAwLCB0LCAxICk7XG4gICAgICAgIHAgPSBtYXRoLnFiZXppZXJQdEF0KCBjcC5wMCwgY3AucDEsIGNwLnAyLCB0ICk7XG4gICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoIGNwLnAwLCBjcC5wMSwgY3AucDIsIHQsIHAgKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICB2YXIgZCA9IDAsIGRpLCBkMDtcbiAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgdmFyIGwgPSBycy5hbGxwdHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpICsgMyA8IGw7IGkgKz0gMiApe1xuICAgICAgICAgIGlmKCBpc1NyYyApe1xuICAgICAgICAgICAgcDAgPSB7IHg6IHJzLmFsbHB0c1tpXSwgICAgIHk6IHJzLmFsbHB0c1tpKzFdIH07XG4gICAgICAgICAgICBwMSA9IHsgeDogcnMuYWxscHRzW2krMl0sICAgeTogcnMuYWxscHRzW2krM10gfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDAgPSB7IHg6IHJzLmFsbHB0c1tsLTItaV0sIHk6IHJzLmFsbHB0c1tsLTEtaV0gfTtcbiAgICAgICAgICAgIHAxID0geyB4OiBycy5hbGxwdHNbbC00LWldLCB5OiBycy5hbGxwdHNbbC0zLWldIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGkgPSBtYXRoLmRpc3QoIHAwLCBwMSApO1xuICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICBkICs9IGRpO1xuXG4gICAgICAgICAgaWYoIGQgPj0gb2Zmc2V0ICl7IGJyZWFrOyB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcEQgPSBvZmZzZXQgLSBkMDtcbiAgICAgICAgdmFyIHQgPSBwRCAvIGRpO1xuXG4gICAgICAgIHQgID0gbWF0aC5ib3VuZCggMCwgdCwgMSApO1xuICAgICAgICBwID0gbWF0aC5saW5lQXQoIHAwLCBwMSwgdCApO1xuICAgICAgICBhbmdsZSA9IGxpbmVBbmdsZSggcDAsIHAxICk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2V0UnMoICdsYWJlbFgnLCBwcmVmaXgsIHAueCApO1xuICAgIHNldFJzKCAnbGFiZWxZJywgcHJlZml4LCBwLnkgKTtcbiAgICBzZXRScyggJ2xhYmVsQXV0b0FuZ2xlJywgcHJlZml4LCBhbmdsZSApO1xuICB9O1xuXG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oICdzb3VyY2UnICk7XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oICd0YXJnZXQnICk7XG5cbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyggZWRnZSApO1xufTtcblxuQlJwLmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSApe1xuICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoIGVsZSApO1xuXG4gIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoIGVsZSwgJ3NvdXJjZScgKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoIGVsZSwgJ3RhcmdldCcgKTtcbiAgfVxufTtcblxuQlJwLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlLCBwcmVmaXggKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZSwgcHJlZml4ICk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXh0ICk7XG5cbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc3R5bGUsICAgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIGxhYmVsRGltcy53aWR0aCApO1xuICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgbGFiZWxEaW1zLndpZHRoICk7XG5cbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc3R5bGUsICAgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBsYWJlbERpbXMuaGVpZ2h0ICk7XG4gIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgbGFiZWxEaW1zLmhlaWdodCApO1xufTtcblxuQlJwLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uKCBlbGUsIHByZWZpeCApe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHRleHQgPSBlbGUucHN0eWxlKCBwZmQgKyAnbGFiZWwnICkuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VHJhbnNmb3JtID0gZWxlLnBzdHlsZSggJ3RleHQtdHJhbnNmb3JtJyApLnZhbHVlO1xuICB2YXIgcnNjcmF0Y2ggPSBmdW5jdGlvbiggcHJvcE5hbWUsIHZhbHVlICl7XG4gICAgaWYoIHZhbHVlICl7XG4gICAgICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSApO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCApO1xuICAgIH1cbiAgfTtcblxuICBpZiggdGV4dFRyYW5zZm9ybSA9PSAnbm9uZScgKXtcbiAgICAvLyBwYXNzdGhyb3VnaFxuICB9IGVsc2UgaWYoIHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScgKXtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYoIHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScgKXtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoICd0ZXh0LXdyYXAnICkudmFsdWU7XG5cbiAgaWYoIHdyYXBTdHlsZSA9PT0gJ3dyYXAnICl7XG4gICAgLy9jb25zb2xlLmxvZygnd3JhcCcpO1xuXG4gICAgdmFyIGxhYmVsS2V5ID0gcnNjcmF0Y2goICdsYWJlbEtleScgKTtcblxuICAgIC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiggbGFiZWxLZXkgJiYgcnNjcmF0Y2goICdsYWJlbFdyYXBLZXknICkgPT09IGxhYmVsS2V5ICl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBoaXQnKTtcbiAgICAgIHJldHVybiByc2NyYXRjaCggJ2xhYmVsV3JhcENhY2hlZFRleHQnICk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIG1pc3MnKTtcblxuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoICdcXG4nICk7XG4gICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCAndGV4dC1tYXgtd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG5cbiAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzWyBsIF07XG4gICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCBsaW5lLCAnbGluZT0nICsgbGluZSApO1xuICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG5cbiAgICAgIGlmKCBsaW5lVyA+IG1heFcgKXsgLy8gbGluZSBpcyB0b28gbG9uZ1xuICAgICAgICB2YXIgd29yZHMgPSBsaW5lLnNwbGl0KCAvXFxzKy8gKTsgLy8gTkI6IGFzc3VtZSBjb2xsYXBzZWQgd2hpdGVzcGFjZSBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuXG4gICAgICAgIGZvciggdmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KysgKXtcbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzWyB3IF07XG4gICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArICcgJyArIHdvcmQ7XG4gICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgdGVzdExpbmUsICd0ZXN0TGluZT0nICsgdGVzdExpbmUgKTtcbiAgICAgICAgICB2YXIgdGVzdFcgPSB0ZXN0RGltcy53aWR0aDtcblxuICAgICAgICAgIGlmKCB0ZXN0VyA8PSBtYXhXICl7IC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArICcgJztcbiAgICAgICAgICB9IGVsc2UgeyAvLyB3b3JkIHN0YXJ0cyBuZXcgbGluZVxuICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgICAgIHN1YmxpbmUgPSB3b3JkICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuICAgICAgICBpZiggIXN1YmxpbmUubWF0Y2goIC9eXFxzKyQvICkgKXtcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggc3VibGluZSApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBsaW5lICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJzY3JhdGNoKCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCB3cmFwcGVkTGluZXMgKTtcbiAgICB0ZXh0ID0gcnNjcmF0Y2goICdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oICdcXG4nICkgKTtcbiAgICByc2NyYXRjaCggJ2xhYmVsV3JhcEtleScsIGxhYmVsS2V5ICk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0ZXh0KVxuICB9IGVsc2UgaWYoIHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJyApe1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSggJ3RleHQtbWF4LXdpZHRoJyApLnBmVmFsdWU7XG4gICAgdmFyIGVsbGlwc2l6ZWQgPSAnJztcbiAgICB2YXIgZWxsaXBzaXMgPSAnXFx1MjAyNic7XG4gICAgdmFyIGluY0xhc3RDaCA9IGZhbHNlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgd2lkdGhXaXRoTmV4dENoID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcyApLndpZHRoO1xuXG4gICAgICBpZiggd2lkdGhXaXRoTmV4dENoID4gbWF4VyApeyBicmVhazsgfVxuXG4gICAgICBlbGxpcHNpemVkICs9IHRleHRbaV07XG5cbiAgICAgIGlmKCBpID09PSB0ZXh0Lmxlbmd0aCAtIDEgKXsgaW5jTGFzdENoID0gdHJ1ZTsgfVxuICAgIH1cblxuICAgIGlmKCAhaW5jTGFzdENoICl7XG4gICAgICBlbGxpcHNpemVkICs9IGVsbGlwc2lzO1xuICAgIH1cblxuICAgIHJldHVybiBlbGxpcHNpemVkO1xuICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG4gIHJldHVybiB0ZXh0O1xufTtcblxuQlJwLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUsIHRleHQsIGV4dHJhS2V5ICl7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgY2FjaGVLZXkgPSBlbGUuX3ByaXZhdGUubGFiZWxTdHlsZUtleSArICckQCQnICsgdGV4dDtcblxuICBpZiggZXh0cmFLZXkgKXtcbiAgICBjYWNoZUtleSArPSAnJEAkJyArIGV4dHJhS2V5O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSB7fSk7XG5cbiAgaWYoIGNhY2hlWyBjYWNoZUtleSBdICl7XG4gICAgcmV0dXJuIGNhY2hlWyBjYWNoZUtleSBdO1xuICB9XG5cbiAgdmFyIHNpemVNdWx0ID0gMTsgLy8gaW5jcmVhc2UgdGhlIHNjYWxlIHRvIGluY3JlYXNlIGFjY3VyYWN5IHcuci50LiB6b29tZWQgdGV4dFxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSggJ2ZvbnQtc3R5bGUnICkuc3RyVmFsdWU7XG4gIHZhciBzaXplID0gKCBzaXplTXVsdCAqIGVsZS5wc3R5bGUoICdmb250LXNpemUnICkucGZWYWx1ZSApICsgJ3B4JztcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoICdmb250LWZhbWlseScgKS5zdHJWYWx1ZTtcbiAgdmFyIHdlaWdodCA9IGVsZS5wc3R5bGUoICdmb250LXdlaWdodCcgKS5zdHJWYWx1ZTtcblxuICB2YXIgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXY7XG5cbiAgaWYoICFkaXYgKXtcbiAgICBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBkaXYgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIGRzID0gZGl2LnN0eWxlO1xuXG4gIC8vIGZyb20gZWxlIHN0eWxlXG4gIGRzLmZvbnRGYW1pbHkgPSBmYW1pbHk7XG4gIGRzLmZvbnRTdHlsZSA9IGZTdHlsZTtcbiAgZHMuZm9udFNpemUgPSBzaXplO1xuICBkcy5mb250V2VpZ2h0ID0gd2VpZ2h0O1xuXG4gIC8vIGZvcmNlZCBzdHlsZVxuICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgZHMuekluZGV4ID0gJy0xJztcbiAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICBkcy5wYWRkaW5nID0gJzAnO1xuICBkcy5saW5lSGVpZ2h0ID0gJzEnO1xuXG4gIGlmKCBlbGUucHN0eWxlKCAndGV4dC13cmFwJyApLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgfSBlbHNlIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gIH1cblxuICAvLyBwdXQgbGFiZWwgY29udGVudCBpbiBkaXZcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcblxuICBjYWNoZVsgY2FjaGVLZXkgXSA9IHtcbiAgICB3aWR0aDogTWF0aC5jZWlsKCBkaXYuY2xpZW50V2lkdGggLyBzaXplTXVsdCApLFxuICAgIGhlaWdodDogTWF0aC5jZWlsKCBkaXYuY2xpZW50SGVpZ2h0IC8gc2l6ZU11bHQgKVxuICB9O1xuXG4gIHJldHVybiBjYWNoZVsgY2FjaGVLZXkgXTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBlZGdlcyApe1xuICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyggZWRnZXMgKTtcbn07XG5cblxuLy8gRmluZCBlZGdlIGNvbnRyb2wgcG9pbnRzXG5CUnAuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oIGVkZ2VzICl7XG4gIGlmKCAhZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICB2YXIgcGFpcklkcyA9IFtdO1xuICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdO1xuXG4gIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICB2YXIgcGFpcklkO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1sgaSBdO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGRhdGEgPSBfcC5kYXRhO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoICdjdXJ2ZS1zdHlsZScgKS52YWx1ZTtcbiAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cyc7XG5cbiAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgIGlmKCBlZGdlLnBzdHlsZSggJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiggY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgc3JjSWQgPSBkYXRhLnNvdXJjZTtcbiAgICB2YXIgdGd0SWQgPSBkYXRhLnRhcmdldDtcblxuICAgIHBhaXJJZCA9IHNyY0lkID4gdGd0SWQgP1xuICAgICAgdGd0SWQgKyAnJC0kJyArIHNyY0lkIDpcbiAgICAgIHNyY0lkICsgJyQtJCcgKyB0Z3RJZCA7XG5cbiAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICBwYWlySWQgPSAndW5idW5kbGVkJyArICckLSQnICsgZGF0YS5pZDtcbiAgICB9XG5cbiAgICBpZiggaGFzaFRhYmxlWyBwYWlySWQgXSA9PSBudWxsICl7XG4gICAgICBoYXNoVGFibGVbIHBhaXJJZCBdID0gW107XG4gICAgICBwYWlySWRzLnB1c2goIHBhaXJJZCApO1xuICAgIH1cblxuICAgIGhhc2hUYWJsZVsgcGFpcklkIF0ucHVzaCggZWRnZSApO1xuXG4gICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgaGFzaFRhYmxlWyBwYWlySWQgXS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcmMsIHRndCwgc3JjX3AsIHRndF9wLCBzcmNQb3MsIHRndFBvcywgc3JjVywgc3JjSCwgdGd0VywgdGd0SCwgc3JjU2hhcGUsIHRndFNoYXBlO1xuICB2YXIgdmVjdG9yTm9ybUludmVyc2U7XG4gIHZhciBiYWRCZXppZXI7XG5cbiAgLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnRcbiAgZm9yKCB2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrICl7XG4gICAgcGFpcklkID0gcGFpcklkc1sgcCBdO1xuICAgIHZhciBwYWlyRWRnZXMgPSBoYXNoVGFibGVbIHBhaXJJZCBdO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICBwYWlyRWRnZXMuc29ydCggZnVuY3Rpb24oIGVkZ2UxLCBlZGdlMiApe1xuICAgICAgcmV0dXJuIGVkZ2UxLnBvb2xJbmRleCgpIC0gZWRnZTIucG9vbEluZGV4KCk7XG4gICAgfSApO1xuXG4gICAgc3JjID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnNvdXJjZTtcbiAgICB0Z3QgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudCBmb3IgYnVuZGxlZCBlZGdlc1xuICAgIGlmKCAhcGFpckVkZ2VzLmhhc1VuYnVuZGxlZCAmJiBzcmMuaWQoKSA+IHRndC5pZCgpICl7XG4gICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgIHNyYyA9IHRndDtcbiAgICAgIHRndCA9IHRlbXA7XG4gICAgfVxuXG4gICAgc3JjX3AgPSBzcmMuX3ByaXZhdGU7XG4gICAgdGd0X3AgPSB0Z3QuX3ByaXZhdGU7XG5cbiAgICBzcmNQb3MgPSBzcmNfcC5wb3NpdGlvbjtcbiAgICB0Z3RQb3MgPSB0Z3RfcC5wb3NpdGlvbjtcblxuICAgIHNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgIHNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgIHRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHRndEggPSB0Z3Qub3V0ZXJIZWlnaHQoKTtcblxuICAgIHNyY1NoYXBlID0gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggc3JjICkgXTtcbiAgICB0Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIHRndCApIF07XG5cbiAgICBiYWRCZXppZXIgPSBmYWxzZTtcblxuXG4gICAgaWYoIChwYWlyRWRnZXMubGVuZ3RoID4gMSAmJiBzcmMgIT09IHRndCkgfHwgcGFpckVkZ2VzLmhhc1VuYnVuZGxlZCApe1xuXG4gICAgICAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgc3JjUG9zLngsXG4gICAgICAgIHNyY1Bvcy55LFxuICAgICAgICBzcmNXLFxuICAgICAgICBzcmNILFxuICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgdGd0UG9zLnksXG4gICAgICAgIDBcbiAgICAgICk7XG5cbiAgICAgIC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgdGd0UG9zLnksXG4gICAgICAgIHRndFcsXG4gICAgICAgIHRndEgsXG4gICAgICAgIHNyY1Bvcy54LFxuICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgMFxuICAgICAgKTtcblxuICAgICAgdmFyIG1pZHB0U3JjUHRzID0ge1xuICAgICAgICB4MTogc3JjT3V0c2lkZVswXSxcbiAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICB5MjogdGd0T3V0c2lkZVsxXVxuICAgICAgfTtcblxuICAgICAgdmFyIHBvc1B0cyA9IHtcbiAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICB4MjogdGd0UG9zLngsXG4gICAgICAgIHkxOiBzcmNQb3MueSxcbiAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICB9O1xuXG4gICAgICB2YXIgZHkgPSAoIHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdICk7XG4gICAgICB2YXIgZHggPSAoIHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdICk7XG4gICAgICB2YXIgbCA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuICAgICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgeDogZHgsXG4gICAgICAgIHk6IGR5XG4gICAgICB9O1xuXG4gICAgICB2YXIgdmVjdG9yTm9ybSA9IHtcbiAgICAgICAgeDogdmVjdG9yLnggLyBsLFxuICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgIH07XG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuICAgICAgaWYoXG4gICAgICAgIHRndFNoYXBlLmNoZWNrUG9pbnQoIHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIDAsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSApICAmJlxuICAgICAgICBzcmNTaGFwZS5jaGVja1BvaW50KCB0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCAwLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnkgKVxuICAgICAgKXtcbiAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7fTtcbiAgICAgICAgYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBlZGdlX3A7XG4gICAgdmFyIHJzO1xuXG4gICAgdmFyIGRpckNvdW50cyA9IHtcbiAgICAgICdub3J0aCc6IDAsXG4gICAgICAnd2VzdCc6IDAsXG4gICAgICAnc291dGgnOiAwLFxuICAgICAgJ2Vhc3QnOiAwLFxuICAgICAgJ25vcnRod2VzdCc6IDAsXG4gICAgICAnc291dGh3ZXN0JzogMCxcbiAgICAgICdub3J0aGVhc3QnOiAwLFxuICAgICAgJ3NvdXRoZWFzdCc6IDBcbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYWlyRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVkZ2UgPSBwYWlyRWRnZXNbIGkgXTtcbiAgICAgIGVkZ2VfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICBycyA9IGVkZ2VfcC5yc2NyYXRjaDtcblxuICAgICAgdmFyIGVkZ2VJbmRleDEgPSBycy5sYXN0RWRnZUluZGV4O1xuICAgICAgdmFyIGVkZ2VJbmRleDIgPSBpO1xuXG4gICAgICB2YXIgbnVtRWRnZXMxID0gcnMubGFzdE51bUVkZ2VzO1xuICAgICAgdmFyIG51bUVkZ2VzMiA9IHBhaXJFZGdlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoICdjdXJ2ZS1zdHlsZScgKS52YWx1ZTtcbiAgICAgIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnICk7XG5cbiAgICAgIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgICAgIHZhciBsb29wU3dwID0gZWRnZS5wc3R5bGUoJ2xvb3Atc3dlZXAnKS5wZlZhbHVlO1xuXG4gICAgICB2YXIgY3RybHB0V3MgPSBlZGdlLnBzdHlsZSggJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycgKTtcbiAgICAgIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbiggY3RybHB0RGlzdHMudmFsdWUubGVuZ3RoLCBjdHJscHRXcy52YWx1ZS5sZW5ndGggKSA6IDE7XG4gICAgICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSggJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyApLnBmVmFsdWU7XG4gICAgICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVswXTtcbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJztcblxuICAgICAgdmFyIHNyY1gxID0gcnMubGFzdFNyY0N0bFB0WDtcbiAgICAgIHZhciBzcmNYMiA9IHNyY1Bvcy54O1xuICAgICAgdmFyIHNyY1kxID0gcnMubGFzdFNyY0N0bFB0WTtcbiAgICAgIHZhciBzcmNZMiA9IHNyY1Bvcy55O1xuICAgICAgdmFyIHNyY1cxID0gcnMubGFzdFNyY0N0bFB0VztcbiAgICAgIHZhciBzcmNXMiA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgc3JjSDEgPSBycy5sYXN0U3JjQ3RsUHRIO1xuICAgICAgdmFyIHNyY0gyID0gc3JjLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICB2YXIgdGd0WDIgPSB0Z3RQb3MueDtcbiAgICAgIHZhciB0Z3RZMSA9IHJzLmxhc3RUZ3RDdGxQdFk7XG4gICAgICB2YXIgdGd0WTIgPSB0Z3RQb3MueTtcbiAgICAgIHZhciB0Z3RXMSA9IHJzLmxhc3RUZ3RDdGxQdFc7XG4gICAgICB2YXIgdGd0VzIgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIHRndEgxID0gcnMubGFzdFRndEN0bFB0SDtcbiAgICAgIHZhciB0Z3RIMiA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgICB2YXIgd2lkdGgxID0gcnMubGFzdFc7XG4gICAgICB2YXIgd2lkdGgyID0gZWRnZS5wc3R5bGUoICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScgKS5wZlZhbHVlO1xuXG4gICAgICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuXG4gICAgICBpZiggYmFkQmV6aWVyICl7XG4gICAgICAgIHJzLmJhZEJlemllciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHNyY1gxID09PSBzcmNYMiAmJiBzcmNZMSA9PT0gc3JjWTIgJiYgc3JjVzEgPT09IHNyY1cyICYmIHNyY0gxID09PSBzcmNIMlxuICAgICAgJiYgIHRndFgxID09PSB0Z3RYMiAmJiB0Z3RZMSA9PT0gdGd0WTIgJiYgdGd0VzEgPT09IHRndFcyICYmIHRndEgxID09PSB0Z3RIMlxuICAgICAgJiYgIHdpZHRoMSA9PT0gd2lkdGgyXG4gICAgICAmJiAgKChlZGdlSW5kZXgxID09PSBlZGdlSW5kZXgyICYmIG51bUVkZ2VzMSA9PT0gbnVtRWRnZXMyKSB8fCBlZGdlSXNVbmJ1bmRsZWQpICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlZGdlIGN0cmwgcHQgY2FjaGUgSElUJylcbiAgICAgICAgY29udGludWU7IC8vIHRoZW4gdGhlIGNvbnRyb2wgcG9pbnRzIGhhdmVuJ3QgY2hhbmdlZCBhbmQgd2UgY2FuIHNraXAgY2FsY3VsYXRpbmcgdGhlbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0WCA9IHNyY1gyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRZID0gc3JjWTI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFcgPSBzcmNXMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0SCA9IHNyY0gyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRYID0gdGd0WDI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFkgPSB0Z3RZMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0VyA9IHRndFcyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRIID0gdGd0SDI7XG4gICAgICAgIHJzLmxhc3RFZGdlSW5kZXggPSBlZGdlSW5kZXgyO1xuICAgICAgICBycy5sYXN0TnVtRWRnZXMgPSBudW1FZGdlczI7XG4gICAgICAgIHJzLmxhc3RXaWR0aCA9IHdpZHRoMjtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBNSVNTJylcbiAgICAgIH1cblxuICAgICAgaWYoIHNyYyA9PT0gdGd0ICl7XG4gICAgICAgIC8vIFNlbGYtZWRnZVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuXG4gICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgIGogPSAwO1xuICAgICAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRBbmdsZSA9ICBsb29wRGlyIC0gbG9vcFN3cCAvIDI7XG4gICAgICAgIHZhciBpbkFuZ2xlICA9ICBsb29wRGlyICsgbG9vcFN3cCAvIDI7XG5cbiAgICAgICAgLy8gaW5jcmVhc2UgYnkgc3RlcCBzaXplIGZvciBvdmVybGFwcGluZyBsb29wcywga2V5ZWQgb24gZGlyZWN0aW9uIGFuZCBzd2VlcCB2YWx1ZXNcbiAgICAgICAgdmFyIGRjID0gU3RyaW5nKGxvb3BEaXIgKyAnXycgKyBsb29wU3dwKTtcbiAgICAgICAgaiA9IGRpckNvdW50c1tkY10gPT09IHVuZGVmaW5lZCA/IGRpckNvdW50c1tkY10gPSAwIDogKytkaXJDb3VudHNbZGNdO1xuXG4gICAgICAgIHJzLmN0cmxwdHMgPSBbXG4gICAgICAgICAgc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy55ICsgTWF0aC5zaW4ob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSxcbiAgICAgICAgICBzcmNQb3MueCArIE1hdGguY29zKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSxcbiAgICAgICAgICBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKVxuICAgICAgICBdO1xuXG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIGhhc0NvbXBvdW5kcyAmJlxuICAgICAgICAoIHNyYy5pc1BhcmVudCgpIHx8IHNyYy5pc0NoaWxkKCkgfHwgdGd0LmlzUGFyZW50KCkgfHwgdGd0LmlzQ2hpbGQoKSApICYmXG4gICAgICAgICggc3JjLnBhcmVudHMoKS5hbnlTYW1lKCB0Z3QgKSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoIHNyYyApIClcbiAgICAgICl7XG4gICAgICAgIC8vIENvbXBvdW5kIGVkZ2VcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGluZSBhcHByb3hpbWF0aW9uIGRvZXNuJ3QgYXBwbHkgZm9yIGNvbXBvdW5kIGJlemllcnNcbiAgICAgICAgLy8gKGxvb3Avc2VsZiBlZGdlcyBhcmUgYWxyZWFkeSBlbGlkZWQgYi9jIG9mIGNoZWFwIHNyYz09dGd0IGNoZWNrKVxuICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9vcFcgPSA1MDtcblxuICAgICAgICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgICAgICAgeDogc3JjUG9zLnggLSBzcmNXIC8gMixcbiAgICAgICAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3BiUG9zID0ge1xuICAgICAgICAgIHg6IHRndFBvcy54IC0gdGd0VyAvIDIsXG4gICAgICAgICAgeTogdGd0UG9zLnkgLSB0Z3RIIC8gMlxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb29wUG9zID0ge1xuICAgICAgICAgIHg6IE1hdGgubWluKCBsb29wYVBvcy54LCBsb29wYlBvcy54ICksXG4gICAgICAgICAgeTogTWF0aC5taW4oIGxvb3BhUG9zLnksIGxvb3BiUG9zLnkgKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuICAgICAgICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMC41O1xuICAgICAgICB2YXIgY29tcG91bmRTdHJldGNoQSA9IE1hdGgubWF4KCBtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKCBzcmNXICogMC4wMSApICk7XG4gICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coIHRndFcgKiAwLjAxICkgKTtcblxuICAgICAgICBycy5jdHJscHRzID0gW1xuICAgICAgICAgIGxvb3BQb3MueCxcbiAgICAgICAgICBsb29wUG9zLnkgLSAoMSArIE1hdGgucG93KCBsb29wVywgMS4xMiApIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLFxuXG4gICAgICAgICAgbG9vcFBvcy54IC0gKDEgKyBNYXRoLnBvdyggbG9vcFcsIDEuMTIgKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQixcbiAgICAgICAgICBsb29wUG9zLnlcbiAgICAgICAgXTtcblxuICAgICAgfSBlbHNlIGlmKCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnICl7XG4gICAgICAgIC8vIFNlZ21lbnRzIChtdWx0aXBsZSBzdHJhaWdodCBsaW5lcylcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtdO1xuXG4gICAgICAgIHZhciBzZWdtZW50V3MgPSBlZGdlLnBzdHlsZSggJ3NlZ21lbnQtd2VpZ2h0cycgKS5wZlZhbHVlO1xuICAgICAgICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoICdzZWdtZW50LWRpc3RhbmNlcycgKS5wZlZhbHVlO1xuICAgICAgICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oIHNlZ21lbnRXcy5sZW5ndGgsIHNlZ21lbnREcy5sZW5ndGggKTtcblxuICAgICAgICBmb3IoIHZhciBzID0gMDsgcyA8IHNlZ21lbnRzTjsgcysrICl7XG4gICAgICAgICAgdmFyIHcgPSBzZWdtZW50V3NbIHMgXTtcbiAgICAgICAgICB2YXIgZCA9IHNlZ21lbnREc1sgcyBdO1xuXG4gICAgICAgICAgdmFyIHcxID0gMSAtIHc7XG4gICAgICAgICAgdmFyIHcyID0gdztcblxuICAgICAgICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IG1pZHB0U3JjUHRzO1xuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICAgICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgICAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJzLnNlZ3B0cy5wdXNoKFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGQsXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgLy8gU3RyYWlnaHQgZWRnZVxuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICBwYWlyRWRnZXMubGVuZ3RoICUgMiA9PT0gMVxuICAgICAgICAmJiBpID09PSBNYXRoLmZsb29yKCBwYWlyRWRnZXMubGVuZ3RoIC8gMiApXG4gICAgICAgICYmICFlZGdlSXNVbmJ1bmRsZWRcbiAgICAgICl7XG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgICAgICAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gICAgICAgIHJzLmN0cmxwdHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKyApe1xuICAgICAgICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlyRWRnZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemU7XG4gICAgICAgICAgdmFyIG1hbmN0cmxwdERpc3Q7XG4gICAgICAgICAgdmFyIHNpZ24gPSBtYXRoLnNpZ251bSggbm9ybWN0cmxwdERpc3QgKTtcblxuICAgICAgICAgIGlmKCBtdWx0aSApe1xuICAgICAgICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVsgYiBdIDogc3RlcFNpemU7IC8vIGZhbGwgYmFjayBvbiBzdGVwIHNpemVcbiAgICAgICAgICAgIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWyBiIF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApeyAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcblxuICAgICAgICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgICAgICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuXG4gICAgICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogbWlkcHRTcmNQdHM7XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuY3RybHB0cy5wdXNoKFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgZW5kcHRzIGZvciBlZGdlXG4gICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcblxuICAgICAgdmFyIGJhZFN0YXJ0ID0gIWlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgIWlzLm51bWJlciggcnMuc3RhcnRZICk7XG4gICAgICB2YXIgYmFkQVN0YXJ0ID0gIWlzLm51bWJlciggcnMuYXJyb3dTdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WSApO1xuICAgICAgdmFyIGJhZEVuZCA9ICFpcy5udW1iZXIoIHJzLmVuZFggKSB8fCAhaXMubnVtYmVyKCBycy5lbmRZICk7XG4gICAgICB2YXIgYmFkQUVuZCA9ICFpcy5udW1iZXIoIHJzLmFycm93RW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmFycm93RW5kWSApO1xuXG4gICAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlLnBzdHlsZSggJ3dpZHRoJyApLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkudmFsdWUgKVxuICAgICAgICAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xuICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICAgIHZhciBzdGFydEFDcERpc3QgPSBtYXRoLmRpc3QoIHsgeDogcnMuY3RybHB0c1swXSwgeTogcnMuY3RybHB0c1sxXSB9LCB7IHg6IHJzLnN0YXJ0WCwgeTogcnMuc3RhcnRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgICAgICB2YXIgZW5kQUNwRGlzdCA9IG1hdGguZGlzdCggeyB4OiBycy5jdHJscHRzWzBdLCB5OiBycy5jdHJscHRzWzFdIH0sIHsgeDogcnMuZW5kWCwgeTogcnMuZW5kWSB9ICk7XG4gICAgICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuXG4gICAgICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCBiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSBzcmNQb3MueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELnggKiBjcEQueCArIGNwRC55ICogY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoIHNyY1csIHNyY0ggKTtcbiAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgICAgc3JjVyxcbiAgICAgICAgICAgIHNyY0gsXG4gICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgIGNwUHJvai55LFxuICAgICAgICAgICAgMFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiggY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHRndFBvcy54LFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHRndFBvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heCggc3JjVywgc3JjSCApO1xuICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgICB0Z3RXLFxuICAgICAgICAgICAgdGd0SCxcbiAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmKCBjbG9zZUVuZEFDcCApe1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHRndEN0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gdGd0Q3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvdmVybGFwcGluZyApe1xuICAgICAgICAgIC8vIHJlY2FsYyBlbmRwdHNcbiAgICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyApe1xuICAgICAgICBycy5hbGxwdHMgPSBbXTtcblxuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuc3RhcnRYLCBycy5zdGFydFkgKTtcblxuICAgICAgICBmb3IoIHZhciBiID0gMDsgYiArIDEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyICl7XG4gICAgICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuY3RybHB0c1sgYiBdLCBycy5jdHJscHRzWyBiICsgMV0gKTtcblxuICAgICAgICAgIC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuICAgICAgICAgIGlmKCBiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoICl7XG4gICAgICAgICAgICBycy5hbGxwdHMucHVzaCggKHJzLmN0cmxwdHNbIGIgXSArIHJzLmN0cmxwdHNbIGIgKyAyXSkgLyAyLCAocnMuY3RybHB0c1sgYiArIDFdICsgcnMuY3RybHB0c1sgYiArIDNdKSAvIDIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuZW5kWCwgcnMuZW5kWSApO1xuXG4gICAgICAgIHZhciBtLCBtdDtcbiAgICAgICAgaWYoIHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDAgKXtcbiAgICAgICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1sgbSBdO1xuICAgICAgICAgIHJzLm1pZFkgPSBycy5hbGxwdHNbIG0gKyAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAzO1xuICAgICAgICAgIG10ID0gMC41O1xuXG4gICAgICAgICAgcnMubWlkWCA9IG1hdGgucWJlemllckF0KCBycy5hbGxwdHNbIG0gXSwgcnMuYWxscHRzWyBtICsgMl0sIHJzLmFsbHB0c1sgbSArIDRdLCBtdCApO1xuICAgICAgICAgIHJzLm1pZFkgPSBtYXRoLnFiZXppZXJBdCggcnMuYWxscHRzWyBtICsgMV0sIHJzLmFsbHB0c1sgbSArIDNdLCBycy5hbGxwdHNbIG0gKyA1XSwgbXQgKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnICl7XG4gICAgICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICAgICAgcnMuYWxscHRzID0gWyBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSBdO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcbiAgICAgICAgcnMubWlkWCA9ICggcnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYICkgLyA0O1xuICAgICAgICBycy5taWRZID0gKCBycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkgKSAvIDQ7XG5cbiAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgKXtcbiAgICAgICAgcnMuYWxscHRzID0gW107XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5zdGFydFgsIHJzLnN0YXJ0WSApO1xuICAgICAgICBycy5hbGxwdHMucHVzaC5hcHBseSggcnMuYWxscHRzLCBycy5zZWdwdHMgKTtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLmVuZFgsIHJzLmVuZFkgKTtcblxuICAgICAgICBpZiggcnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDAgKXtcbiAgICAgICAgICB2YXIgaTIgPSBycy5zZWdwdHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICB2YXIgaTEgPSBpMiAtIDI7XG5cbiAgICAgICAgICBycy5taWRYID0gKCBycy5zZWdwdHNbIGkxIF0gKyBycy5zZWdwdHNbIGkyIF0gKSAvIDI7XG4gICAgICAgICAgcnMubWlkWSA9ICggcnMuc2VncHRzWyBpMSArIDFdICsgcnMuc2VncHRzWyBpMiArIDFdICkgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpMSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcblxuICAgICAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbIGkxIF07XG4gICAgICAgICAgcnMubWlkWSA9IHJzLnNlZ3B0c1sgaTEgKyAxXTtcbiAgICAgICAgfVxuXG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9qZWN0TGluZXMoIGVkZ2UgKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoIGVkZ2UgKTtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyggZWRnZSApO1xuICAgICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyggZWRnZSApO1xuXG4gICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuICB9IC8vIGZvciBwYWlyIGlkc1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgaGF5c3RhY2tFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlZGdlID0gaGF5c3RhY2tFZGdlc1sgaSBdO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHJzID0gcnNjcmF0Y2g7XG5cbiAgICBpZiggIXJzY3JhdGNoLmhheXN0YWNrICl7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgIHJzY3JhdGNoLnNvdXJjZSA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoIGFuZ2xlICksXG4gICAgICAgIHk6IE1hdGguc2luKCBhbmdsZSApXG4gICAgICB9O1xuXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgIHJzY3JhdGNoLnRhcmdldCA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoIGFuZ2xlICksXG4gICAgICAgIHk6IE1hdGguc2luKCBhbmdsZSApXG4gICAgICB9O1xuXG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCAnaGF5c3RhY2stcmFkaXVzJyApLnZhbHVlO1xuICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW1xuICAgICAgcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LFxuICAgICAgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LFxuICAgICAgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LFxuICAgICAgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XG4gICAgXTtcblxuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjtcblxuICAgIC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG4gICAgcnNjcmF0Y2guZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgIHJzY3JhdGNoLmhheXN0YWNrID0gdHJ1ZTtcblxuICAgIHRoaXMucHJvamVjdExpbmVzKCBlZGdlICk7XG4gICAgdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyggZWRnZSApO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyggZWRnZSApO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoIGVkZ2UgKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoVGFibGU7XG59O1xuXG52YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uKCBkaXNwWCwgZGlzcFkgKXtcbiAgcmV0dXJuIE1hdGguYXRhbjIoIGRpc3BZLCBkaXNwWCApIC0gTWF0aC5QSSAvIDI7XG59O1xuXG5CUnAuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnO1xuXG4gIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG5cbiAgdmFyIHNyY1BvcyA9IGVkZ2UuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICB2YXIgdGd0UG9zID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgfVxuXG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTtcblxuICAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiggaXNTZWdtZW50cyApe1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYoIGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IG1hdGgucWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEgKTtcbiAgICB2YXIgYlkgPSBtYXRoLnFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xICk7XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgfVxuXG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyBtaWQgdGFyZ2V0XG4gIC8vXG5cbiAgdmFyIG1pZFggPSBycy5taWRYO1xuICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICBtaWRYID0gKCBzdGFydFggKyBlbmRYICkgLyAyO1xuICAgIG1pZFkgPSAoIHN0YXJ0WSArIGVuZFkgKSAvIDI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiggaXNTZWxmICl7XG4gICAgZGlzcFggPSAtMTtcbiAgICBkaXNwWSA9IDE7XG4gIH0gZWxzZSBpZiggaXNTZWdtZW50cyApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiggcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwICl7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgZGlzcFggPSAoIHB0c1sgaTIgXSAtIHB0c1sgaTEgXSApO1xuICAgICAgZGlzcFkgPSAoIHB0c1sgaTIgKyAxXSAtIHB0c1sgaTEgKyAxXSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gKCBwdHNbIGkyIF0gLSBwdHNbIGkxIF0gKTtcbiAgICAgIGRpc3BZID0gKCBwdHNbIGkyICsgMV0gLSBwdHNbIGkxICsgMV0gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiggY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC4wICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuMCApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgXSwgcHRzWyBpYyBdLCBwdHNbIHAxIF0sIDAuMDAwMSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwICsgMV0sIHB0c1sgaWMgKyAxXSwgcHRzWyBwMSArIDFdLCAwLjAwMDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuICAgICAgdmFyIHAwID0gaWMgLSAyOyAvLyBzdGFydHB0XG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC40OTk5ICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuNDk5OSApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgXSwgcHRzWyBpYyBdLCBwdHNbIHAxIF0sIDAuNSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwICsgMV0sIHB0c1sgaWMgKyAxXSwgcHRzWyBwMSArIDFdLCAwLjUgKTtcbiAgICB9XG5cbiAgICBkaXNwWCA9ICggYnAxeCAtIGJwMHggKTtcbiAgICBkaXNwWSA9ICggYnAxeSAtIGJwMHkgKTtcbiAgfVxuXG4gIHJzLm1pZHRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG5cbiAgaWYoIGlzU2VnbWVudHMgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYoIHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgLy8gYWxyZWFkeSBva1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gLSggcHRzWyBpMyBdIC0gcHRzWyBpMiBdICk7XG4gICAgICBkaXNwWSA9IC0oIHB0c1sgaTMgKyAxXSAtIHB0c1sgaTIgKyAxXSApO1xuICAgIH1cbiAgfVxuXG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyB0YXJnZXRcbiAgLy9cblxuICBpZiggaXNTZWdtZW50cyApe1xuICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1sgcnMuc2VncHRzLmxlbmd0aCAtIDIgXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbIHJzLnNlZ3B0cy5sZW5ndGggLSAxIF07XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0JlemllciApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGwgPSBwdHMubGVuZ3RoO1xuICAgIHZhciBiWCA9IG1hdGgucWJlemllckF0KCBwdHNbbC02XSwgcHRzW2wtNF0sIHB0c1tsLTJdLCAwLjkgKTtcbiAgICB2YXIgYlkgPSBtYXRoLnFiZXppZXJBdCggcHRzW2wtNV0sIHB0c1tsLTNdLCBwdHNbbC0xXSwgMC45ICk7XG5cbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cblxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcCggZGlzcFgsIGRpc3BZICk7XG59O1xuXG5CUnAuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciByb3QgPSBlbGUucHN0eWxlKCAndGV4dC1yb3RhdGlvbicgKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcblxuICBpZiggcm90U3RyID09PSAnbm9uZScgKXtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGUgPSAwO1xuICB9IGVsc2UgaWYoIGlzRWRnZSAmJiByb3RTdHIgPT09ICdhdXRvcm90YXRlJyApe1xuICAgIHJzLmxhYmVsQW5nbGUgPSBNYXRoLmF0YW4oIHJzLm1pZERpc3BZIC8gcnMubWlkRGlzcFggKTtcbiAgICBycy5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBdXRvQW5nbGU7XG4gICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYoIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnICl7XG4gICAgcnMubGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlID0gMDtcbiAgfSBlbHNlIHtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGUgPSByb3QucGZWYWx1ZTtcbiAgfVxufTtcblxuQlJwLm1hbnVhbEVuZHB0VG9QeCA9IGZ1bmN0aW9uKCBub2RlLCBwcm9wICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5wb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuXG4gIGlmKCBwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMiApe1xuICAgIHZhciBwID0gW1xuICAgICAgcHJvcC5wZlZhbHVlWzBdLFxuICAgICAgcHJvcC5wZlZhbHVlWzFdXG4gICAgXTtcblxuICAgIGlmKCBwcm9wLnVuaXRzWzBdID09PSAnJScgKXtcbiAgICAgIHBbMF0gPSBwWzBdICogdztcbiAgICB9XG5cbiAgICBpZiggcHJvcC51bml0c1sxXSA9PT0gJyUnICl7XG4gICAgICBwWzFdID0gcFsxXSAqIGg7XG4gICAgfVxuXG4gICAgcFswXSArPSBucG9zLng7XG4gICAgcFsxXSArPSBucG9zLnk7XG5cbiAgICByZXR1cm4gcDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5nbGUgPSBwcm9wLnBmVmFsdWVbMF07XG5cbiAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCggdywgaCApO1xuXG4gICAgdmFyIHAgPSBbXG4gICAgICBucG9zLnggKyBNYXRoLmNvcyggYW5nbGUgKSAqIGwsXG4gICAgICBucG9zLnkgKyBNYXRoLnNpbiggYW5nbGUgKSAqIGxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIG5vZGUgKSBdLmludGVyc2VjdExpbmUoXG4gICAgICBucG9zLngsIG5wb3MueSxcbiAgICAgIHcsIGgsXG4gICAgICBwWzBdLCBwWzFdLFxuICAgICAgMFxuICAgICk7XG4gIH1cbn07XG5cbkJScC5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW50ZXJzZWN0O1xuXG4gIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICB2YXIgc3JjX3AgPSBzb3VyY2UuX3ByaXZhdGU7XG4gIHZhciB0Z3RfcCA9IHRhcmdldC5fcHJpdmF0ZTtcblxuICB2YXIgc3JjUG9zID0gc3JjX3AucG9zaXRpb247XG4gIHZhciB0Z3RQb3MgPSB0Z3RfcC5wb3NpdGlvbjtcblxuICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UucHN0eWxlKCAndGFyZ2V0LWFycm93LXNoYXBlJyApLnZhbHVlO1xuICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UucHN0eWxlKCAnc291cmNlLWFycm93LXNoYXBlJyApLnZhbHVlO1xuXG4gIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyApLnBmVmFsdWU7XG4gIHZhciBzcmNEaXN0ID0gZWRnZS5wc3R5bGUoICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJyApLnBmVmFsdWU7XG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcblxuICBycy5zcmNNYW5FbmRwdCA9IHNyY01hbkVuZHB0O1xuICBycy50Z3RNYW5FbmRwdCA9IHRndE1hbkVuZHB0O1xuXG4gIHZhciBwMTsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHRhcmdldCBzaWRlXG4gIHZhciBwMjsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHNvdXJjZSBzaWRlXG5cbiAgdmFyIHAxX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHRhcmdldCBzaGFwZVxuICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgaWYoIGJlemllciApe1xuICAgIHZhciBjcFN0YXJ0ID0gWyBycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdIF07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbIHJzLmN0cmxwdHNbIHJzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbIHJzLmN0cmxwdHMubGVuZ3RoIC0gMV0gXSA6IGNwU3RhcnQ7XG5cbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmKCBsaW5lcyApe1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFsgdGd0UG9zLngsIHRndFBvcy55IF0gOiBycy5zZWdwdHMuc2xpY2UoIDAsIDIgKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbIHNyY1Bvcy54LCBzcmNQb3MueSBdIDogcnMuc2VncHRzLnNsaWNlKCBycy5zZWdwdHMubGVuZ3RoIC0gMiApO1xuXG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG5cbiAgaWYoIHRndE1hbkVuZHB0LnZhbHVlID09PSAnaW5zaWRlLXRvLW5vZGUnICl7XG4gICAgaW50ZXJzZWN0ID0gWyB0Z3RQb3MueCwgdGd0UG9zLnkgXTtcbiAgfSBlbHNlIGlmKCB0Z3RNYW5FbmRwdC51bml0cyApe1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KCB0YXJnZXQsIHRndE1hbkVuZHB0ICk7XG4gIH0gZWxzZSB7XG4gICAgaWYoIHRndE1hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1ub2RlJyApe1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiggdGd0TWFuRW5kcHQudmFsdWUgPT09ICdvdXRzaWRlLXRvLWxpbmUnICl7XG4gICAgICBwMV9pID0gWyBzcmNQb3MueCwgc3JjUG9zLnkgXTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCB0YXJnZXQgKSBdLmludGVyc2VjdExpbmUoXG4gICAgICB0Z3RQb3MueCxcbiAgICAgIHRndFBvcy55LFxuICAgICAgdGFyZ2V0Lm91dGVyV2lkdGgoKSxcbiAgICAgIHRhcmdldC5vdXRlckhlaWdodCgpLFxuICAgICAgcDFfaVswXSxcbiAgICAgIHAxX2lbMV0sXG4gICAgICAwXG4gICAgKTtcbiAgfVxuXG4gIHZhciBhcnJvd0VuZCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDEsXG4gICAgci5hcnJvd1NoYXBlc1sgdGd0QXJTaGFwZSBdLnNwYWNpbmcoIGVkZ2UgKSArIHRndERpc3RcbiAgKTtcbiAgdmFyIGVkZ2VFbmQgPSBtYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgaW50ZXJzZWN0LFxuICAgIHAxLFxuICAgIHIuYXJyb3dTaGFwZXNbIHRndEFyU2hhcGUgXS5nYXAoIGVkZ2UgKSArIHRndERpc3RcbiAgKTtcblxuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG5cbiAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuXG4gIGlmKCBzcmNNYW5FbmRwdC52YWx1ZSA9PT0gJ2luc2lkZS10by1ub2RlJyApe1xuICAgIGludGVyc2VjdCA9IFsgc3JjUG9zLngsIHNyY1Bvcy55IF07XG4gIH0gZWxzZSBpZiggc3JjTWFuRW5kcHQudW5pdHMgKXtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCggc291cmNlLCBzcmNNYW5FbmRwdCApO1xuICB9IGVsc2Uge1xuICAgIGlmKCBzcmNNYW5FbmRwdC52YWx1ZSA9PT0gJ291dHNpZGUtdG8tbm9kZScgKXtcbiAgICAgIHAyX2kgPSBwMjtcbiAgICB9IGVsc2UgaWYoIHNyY01hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1saW5lJyApe1xuICAgICAgcDJfaSA9IFsgdGd0UG9zLngsIHRndFBvcy55IF07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggc291cmNlICkgXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgc3JjUG9zLngsXG4gICAgICBzcmNQb3MueSxcbiAgICAgIHNvdXJjZS5vdXRlcldpZHRoKCksXG4gICAgICBzb3VyY2Uub3V0ZXJIZWlnaHQoKSxcbiAgICAgIHAyX2lbMF0sXG4gICAgICBwMl9pWzFdLFxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICB2YXIgYXJyb3dTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDIsXG4gICAgci5hcnJvd1NoYXBlc1sgc3JjQXJTaGFwZSBdLnNwYWNpbmcoIGVkZ2UgKSArIHNyY0Rpc3RcbiAgKTtcbiAgdmFyIGVkZ2VTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDIsXG4gICAgci5hcnJvd1NoYXBlc1sgc3JjQXJTaGFwZSBdLmdhcCggZWRnZSApICsgc3JjRGlzdFxuICApO1xuXG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuXG4gIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuXG4gIGlmKCBoYXNFbmRwdHMgKXtcbiAgICBpZiggIWlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgIWlzLm51bWJlciggcnMuc3RhcnRZICkgfHwgIWlzLm51bWJlciggcnMuZW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmVuZFkgKSApe1xuICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJScC5nZXRBcnJvd1dpZHRoID0gQlJwLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24oIGVkZ2VXaWR0aCwgc2NhbGUgKXtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcblxuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbIGVkZ2VXaWR0aCArICcsICcgKyBzY2FsZSBdO1xuICBpZiggY2FjaGVkVmFsICl7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIGNhY2hlZFZhbCA9ICBNYXRoLm1heCggTWF0aC5wb3coIGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkgKSwgMjkgKSAqIHNjYWxlO1xuICBjYWNoZVsgZWRnZVdpZHRoICsgJywgJyArIHNjYWxlIF0gPSBjYWNoZWRWYWw7XG5cbiAgcmV0dXJuIGNhY2hlZFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uKCB1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVsgdXJsIF07XG5cbiAgaWYoIGNhY2hlICl7XG4gICAgaWYoICFjYWNoZS5pbWFnZS5jb21wbGV0ZSApe1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlID0gaW1hZ2VDYWNoZVsgdXJsIF0gPSBpbWFnZUNhY2hlWyB1cmwgXSB8fCB7fTtcblxuICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcblxuICAgIC8vICMxNTgyIHNhZmFyaSBkb2Vzbid0IGxvYWQgZGF0YSB1cmlzIHdpdGggY3Jvc3NPcmlnaW4gcHJvcGVybHlcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzOTc4XG4gICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKCAwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCApLnRvTG93ZXJDYXNlKCkgPT09IGRhdGFVcmlQcmVmaXg7XG4gICAgaWYoICFpc0RhdGFVcmkgKXtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47IC8vIHByZXZlbnQgdGFpbnRlZCBjYW52YXNcbiAgICB9XG5cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKXsgdGhpcy5pbml0KCBvcHRpb25zICk7IH07XG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuXG5CUnAuY2xpZW50RnVuY3Rpb25zID0gWyAncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnIF07XG5cbkJScC5pbml0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgci5jeSA9IG9wdGlvbnMuY3k7XG5cbiAgci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuXG4gIHIuc2VsZWN0aW9uID0gWyB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdOyAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWdcblxuICByLmJlemllclByb2pQY3RzID0gWyAwLjA1LCAwLjIyNSwgMC40LCAwLjUsIDAuNiwgMC43NzUsIDAuOTUgXTtcblxuICAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcbiAgci5ob3ZlckRhdGEgPSB7ZG93bjogbnVsbCwgbGFzdDogbnVsbCxcbiAgICAgIGRvd25UaW1lOiBudWxsLCB0cmlnZ2VyTW9kZTogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGluaXRpYWxQYW46IFsgbnVsbCwgbnVsbCBdLCBjYXB0dXJlOiBmYWxzZX07XG5cbiAgci5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuXG4gIHIudG91Y2hEYXRhID0ge1xuICAgIHN0YXJ0OiBudWxsLCBjYXB0dXJlOiBmYWxzZSxcblxuICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgIHN0YXJ0UG9zaXRpb246IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG5cbiAgICBub3c6IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdLFxuICAgIGVhcmxpZXI6IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdXG4gIH07XG5cbiAgci5yZWRyYXdzID0gMDtcbiAgci5zaG93RnBzID0gb3B0aW9ucy5zaG93RnBzO1xuICByLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gIHIuaGlkZUxhYmVsc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0O1xuICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICByLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ID0gMSAtIHIubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICByLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG4gIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMgPSB7IC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgYW5pbWF0aW9uczogICA0MDAsXG4gICAgZWxlQ2FsY3M6ICAgICAzMDAsXG4gICAgZWxlVHhyRGVxOiAgICAyMDAsXG4gICAgbHlyVHhyRGVxOiAgICAxMDBcbiAgfTtcblxuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG4gIHIubG9hZCgpO1xufTtcblxuQlJwLm5vdGlmeSA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgdmFyIHR5cGVzO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gIGlmKCB0aGlzLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICBpZiggaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICB0eXBlcyA9IHBhcmFtcy50eXBlO1xuXG4gIH0gZWxzZSB7XG4gICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gIH1cblxuICB2YXIgaGFzID0ge307XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdHlwZSA9IHR5cGVzWyBpIF07XG5cbiAgICBoYXNbIHR5cGUgXSA9IHRydWU7XG4gIH0gLy8gZm9yXG5cbiAgaWYoIGhhc1snZGVzdHJveSddICl7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYoIGhhc1snYWRkJ10gfHwgaGFzWydyZW1vdmUnXSB8fCBoYXNbJ2xvYWQnXSB8fCBoYXNbJ3pvcmRlciddICl7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgfVxuXG4gIGlmKCBoYXNbJ3ZpZXdwb3J0J10gKXtcbiAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gIH1cblxuICBpZiggaGFzWydsb2FkJ10gfHwgaGFzWydyZXNpemUnXSApe1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgci5tYXRjaENhbnZhc1NpemUoIHIuY29udGFpbmVyICk7XG4gIH1cblxuICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG5cbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScC5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIuZGVzdHJveWVkID0gdHJ1ZTtcblxuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzWyBpIF07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcblxuICAgICggdGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lciApLmFwcGx5KCB0Z3QsIGIuYXJncyApO1xuICB9XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcblxuICBpZiggci5yZW1vdmVPYnNlcnZlciApe1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYoIHIuc3R5bGVPYnNlcnZlciApe1xuICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiggci5sYWJlbENhbGNEaXYgKXtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggci5sYWJlbENhbGNEaXYgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2goIGUgKXtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbltcbiAgcmVxdWlyZSggJy4vYXJyb3ctc2hhcGVzJyApLFxuICByZXF1aXJlKCAnLi9jb29yZC1lbGUtbWF0aCcgKSxcbiAgcmVxdWlyZSggJy4vaW1hZ2VzJyApLFxuICByZXF1aXJlKCAnLi9sb2FkLWxpc3RlbmVycycgKSxcbiAgcmVxdWlyZSggJy4vbm9kZS1zaGFwZXMnICksXG4gIHJlcXVpcmUoICcuL3JlZHJhdycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIEJScCwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vZXZlbnQnICk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uKCB0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlICl7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KCBhcmd1bWVudHMsIFsxXSApOyAvLyBjb3B5XG4gIHZhciBiID0gdGhpcy5iaW5kZXIoIHRhcmdldCApO1xuXG4gIHJldHVybiBiLm9uLmFwcGx5KCBiLCBhcmdzICk7XG59O1xuXG5CUnAuYmluZGVyID0gZnVuY3Rpb24oIHRndCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHRndElzRG9tID0gdGd0ID09PSB3aW5kb3cgfHwgdGd0ID09PSBkb2N1bWVudCB8fCB0Z3QgPT09IGRvY3VtZW50LmJvZHkgfHwgaXMuZG9tRWxlbWVudCggdGd0ICk7XG5cbiAgaWYoIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwgKXtcblxuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9ICk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndGVzdCcsIG51bGwsIG9wdHMgKTtcbiAgICB9IGNhdGNoKCBlcnIgKXt9XG5cbiAgICByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZTtcbiAgfVxuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSApe1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gICAgaWYoIHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzICl7IC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGd0LFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuXG4gICAgKCB0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24gKS5hcHBseSggdGd0LCBhcmdzICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBvbixcbiAgICBhZGRFdmVudExpc3RlbmVyOiBvbixcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgYmluZDogb25cbiAgfTtcbn07XG5cbkJScC5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiggbm9kZSApe1xuICByZXR1cm4gKFxuICAgIG5vZGVcbiAgICAmJiBub2RlLmlzTm9kZSgpXG4gICAgJiYgIW5vZGUubG9ja2VkKClcbiAgICAmJiBub2RlLmdyYWJiYWJsZSgpXG4gICk7XG59O1xuXG5CUnAubm9kZUlzR3JhYmJhYmxlID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgcmV0dXJuIChcbiAgICB0aGlzLm5vZGVJc0RyYWdnYWJsZSggbm9kZSApXG4gICAgJiYgbm9kZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlICE9PSAwXG4gICAgJiYgbm9kZS5wc3R5bGUoICd2aXNpYmlsaXR5JyApLnZhbHVlID09PSAndmlzaWJsZSdcbiAgICAmJiBub2RlLnBzdHlsZSggJ2Rpc3BsYXknICkudmFsdWUgPT09ICdlbGVtZW50J1xuICApO1xufTtcblxuQlJwLmxvYWQgPSBmdW5jdGlvbigpe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lcywgZSwgcHJvcHMgKXtcbiAgICBpZiggdGFyZ2V0ID09IG51bGwgKXtcbiAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1sgaSBdO1xuXG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoIGUsIHV0aWwuZXh0ZW5kKCB7IHR5cGU6IG5hbWUgfSwgcHJvcHMgKSApO1xuICAgICAgdGFyZ2V0LnRyaWdnZXIoIGV2ZW50ICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24oIGUgKXtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuXG4gIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uKCBkb3duLCBkb3ducyApe1xuICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcblxuICAgIGlmKCByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBkb3duICYmIGRvd24uaXNFZGdlKCkgKXtcbiAgICAgIC8vIGEgY29tcG91bmQgbm9kZSBiZWxvdyB0aGUgZWRnZSA9PiBubyBwYXNzdGhyb3VnaCBwYW5uaW5nXG4gICAgICBmb3IoIHZhciBpID0gMDsgZG93bnMgJiYgaSA8IGRvd25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBkb3duID0gZG93bnNbaV07XG5cbiAgICAgICAgaWYoIGRvd24uaXNOb2RlKCkgJiYgZG93bi5pc1BhcmVudCgpICl7XG4gICAgICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhbGxvd1Bhc3N0aHJvdWdoO1xuICB9O1xuXG4gIHZhciBnZXREcmFnTGlzdElkcyA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgdmFyIGxpc3RIYXNJZDtcblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApeyAvLyBvbmx5IG5lZWRlZCBmb3IgY29tcG91bmQgZ3JhcGhzXG4gICAgICBpZiggIW9wdHMuYWRkVG9MaXN0Lmhhc0lkICl7IC8vIGJ1aWxkIGlkcyBsb29rdXAgaWYgZG9lc24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICAgIG9wdHMuYWRkVG9MaXN0Lmhhc0lkID0ge307XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRzLmFkZFRvTGlzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBvcHRzLmFkZFRvTGlzdFsgaSBdO1xuXG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3RIYXNJZCA9IG9wdHMuYWRkVG9MaXN0Lmhhc0lkO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0SGFzSWQgfHwge307XG4gIH07XG5cbiAgdmFyIHNldEdyYWJiZWQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzZXRGcmVlZCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBzZXRJbkRyYWdMYXllciA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzZXRPdXREcmFnTGF5ZXIgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEdyYWJUYXJnZXQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUdyYWJUYXJnZXQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhZGRUb0RyYWdMaXN0ID0gZnVuY3Rpb24oIGVsZSwgb3B0cyApe1xuICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgaWYoICFsaXN0SGFzSWRbIGVsZS5pZCgpIF0gKXtcbiAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIGVsZSApO1xuICAgICAgbGlzdEhhc0lkWyBlbGUuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgc2V0R3JhYmJlZCggZWxlICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG4gIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uKCBub2RlLCBvcHRzICl7XG4gICAgaWYoICFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICBpbm5lck5vZGVzLmZvckVhY2goIHNldEluRHJhZ0xheWVyICk7XG4gICAgICBpbm5lck5vZGVzLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgKXtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoIGVsZSwgb3B0cyApO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzIGFuZCBpdHMgbmVpZ2hib3VyaG9vZCB0byB0aGUgZHJhZyBsYXllclxuICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiggbm9kZXMsIG9wdHMgKXtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgbm9kZXMuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcblxuICAgICAgbm9kZXMubmVpZ2hib3Job29kKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pLmZvckVhY2goIHNldEluRHJhZ0xheWVyICk7XG4gICAgfVxuXG4gICAgaWYoIG9wdHMuYWRkVG9MaXN0ICl7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgYWRkVG9EcmFnTGlzdCggZWxlLCBvcHRzICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGREZXNjZW5kYW50c1RvRHJhZyggbm9kZXMsIG9wdHMgKTsgLy8gYWx3YXlzIGFkZCB0byBkcmFnXG5cbiAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKCBub2Rlcywge1xuICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICB9ICk7XG5cbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG5cbiAgdmFyIGFkZE5vZGVUb0RyYWcgPSBhZGROb2Rlc1RvRHJhZztcblxuICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCBncmFiYmVkRWxlcyApe1xuICAgIGlmKCAhZ3JhYmJlZEVsZXMgKXsgcmV0dXJuOyB9XG5cbiAgICBncmFiYmVkRWxlcy5oYXNJZCA9IHt9OyAvLyBjbGVhciB0aGUgaWQgbGlzdFxuXG4gICAgLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcbiAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICBzZXRGcmVlZCggZWxlICk7XG4gICAgICBzZXRPdXREcmFnTGF5ZXIoIGVsZSApO1xuICAgICAgcmVtb3ZlR3JhYlRhcmdldCggZWxlICk7XG4gICAgfSk7XG5cbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiggbm9kZSwgb3B0cyApe1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICBpZiggIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5hbmNlc3RvcnMoKS5vcnBoYW5zKCk7XG5cbiAgICAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgaWYoIHBhcmVudC5zYW1lKCBub2RlICkgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKVxuICAgICAgLm1lcmdlKCBwYXJlbnQgKVxuICAgICAgLnVubWVyZ2UoIG5vZGUgKVxuICAgICAgLnVubWVyZ2UoIG5vZGUuZGVzY2VuZGFudHMoKSApXG4gICAgO1xuXG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICBlZGdlcy5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuICAgICAgbm9kZXMuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgKXtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICBhZGRUb0RyYWdMaXN0KCBlbGUsIG9wdHMgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGF2ZU11dGF0aW9uc0FwaSA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcblxuICAvLyB3YXRjaCBmb3Igd2hlbiB0aGUgY3kgY29udGFpbmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gIGlmKCBoYXZlTXV0YXRpb25zQXBpICl7XG4gICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCBmdW5jdGlvbiggbXV0bnMgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbXV0biA9IG11dG5zWyBpIF07XG4gICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICBpZiggck5vZGVzICl7IGZvciggdmFyIGogPSAwOyBqIDwgck5vZGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzWyBqIF07XG5cbiAgICAgICAgICBpZiggck5vZGUgPT09IHIuY29udGFpbmVyICl7XG4gICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XG4gICAgICB9XG4gICAgfSApO1xuXG4gICAgaWYoIHIuY29udGFpbmVyLnBhcmVudE5vZGUgKXtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZSggci5jb250YWluZXIucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKCBlICl7XG4gICAgICByLmRlc3Ryb3koKTtcbiAgICB9ICk7XG4gIH1cblxuICB2YXIgb25SZXNpemUgPSB1dGlsLmRlYm91bmNlKCBmdW5jdGlvbigpe1xuICAgIHIuY3kuaW52YWxpZGF0ZVNpemUoKTtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuXG4gICAgci5tYXRjaENhbnZhc1NpemUoIHIuY29udGFpbmVyICk7XG4gICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICAgIHIucmVkcmF3KCk7XG4gIH0sIDEwMCApO1xuXG4gIGlmKCBoYXZlTXV0YXRpb25zQXBpICl7XG4gICAgci5zdHlsZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIG9uUmVzaXplICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKCByLmNvbnRhaW5lciwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0gKTtcbiAgfVxuXG4gIC8vIGF1dG8gcmVzaXplXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCB3aW5kb3csICdyZXNpemUnLCBvblJlc2l6ZSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIGludmFsQ3RuckJCT25TY3JvbGwgPSBmdW5jdGlvbiggZG9tRWxlICl7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoIGRvbUVsZSwgJ3Njcm9sbCcsIGZ1bmN0aW9uKCBlICl7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIH0gKTtcbiAgfTtcblxuICB2YXIgYmJDdG5yID0gci5jeS5jb250YWluZXIoKTtcblxuICBmb3IoIDs7ICl7XG5cbiAgICBpbnZhbEN0bnJCQk9uU2Nyb2xsKCBiYkN0bnIgKTtcblxuICAgIGlmKCBiYkN0bnIucGFyZW50Tm9kZSApe1xuICAgICAgYmJDdG5yID0gYmJDdG5yLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICB9XG5cbiAgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oIGUgKXtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0gKTtcblxuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcblxuICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgLy8gc2F2ZSBjeWNsZXMgaWYgbW91c2UgZXZlbnRzIGFyZW4ndCB0byBiZSBjYXB0dXJlZFxuICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIHggPSBjb250YWluZXJQYWdlQ29vcmRzWzBdO1xuICAgIHZhciB5ID0gY29udGFpbmVyUGFnZUNvb3Jkc1sxXTtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXJQYWdlQ29vcmRzWzJdO1xuICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJQYWdlQ29vcmRzWzNdO1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IGUudG91Y2hlcyA/IGUudG91Y2hlcyA6IFsgZSBdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmKCB4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoXG4gICAgICAgICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0XG4gICAgICApe1xuICAgICAgICBhdExlYXN0T25lUG9zSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoICFhdExlYXN0T25lUG9zSW5zaWRlICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHIuY29udGFpbmVyO1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICB2YXIgdFBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIHZhciBjb250YWluZXJJc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgd2hpbGUoIHRQYXJlbnQgKXtcbiAgICAgIGlmKCB0UGFyZW50ID09PSBjb250YWluZXIgKXtcbiAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiggIWNvbnRhaW5lcklzVGFyZ2V0ICl7IHJldHVybiBmYWxzZTsgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQcmltYXJ5IGtleVxuICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbiBtb3VzZWRvd25IYW5kbGVyKCBlICl7XG4gICAgaWYoICFldmVudEluQ29udGFpbmVyKGUpICl7IHJldHVybjsgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGdwb3MgPSBbIGUuY2xpZW50WCwgZS5jbGllbnRZIF07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZ3Bvc1swXSwgZ3Bvc1sxXSApO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMoIHBvc1swXSwgcG9zWzFdLCBmYWxzZSApO1xuICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBncG9zO1xuXG4gICAgdmFyIGNoZWNrRm9yVGFwaG9sZCA9IGZ1bmN0aW9uKCl7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgKTtcblxuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgICAgZWxlLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uICk7XG4gICAgfTtcblxuICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgIGlmKCBlLndoaWNoID09IDMgKXtcblxuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIHZhciBjeHRFdnQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci50cmlnZ2VyKCBjeHRFdnQgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBQcmltYXJ5IGJ1dHRvblxuICAgIH0gZWxzZSBpZiggZS53aGljaCA9PSAxICl7XG5cbiAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWxlbWVudCBkcmFnZ2luZ1xuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYoIG5lYXIgIT0gbnVsbCApe1xuXG4gICAgICAgICAgaWYoIHIubm9kZUlzR3JhYmJhYmxlKCBuZWFyICkgKXtcblxuICAgICAgICAgICAgdmFyIGdyYWJFdmVudCA9IG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KCBuZWFyICk7XG5cbiAgICAgICAgICAgIGlmKCAhbmVhci5zZWxlY3RlZCgpICl7XG5cbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcblxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIGdyYWJFdmVudCApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gWyAgXTtcblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlzTm9kZSgpICYmIHRoaXMuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZSggdGhpcyApOyB9ICk7XG5cbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIHNlbGVjdGVkTm9kZXMsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggZ3JhYkV2ZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93bnMgPSBuZWFycztcbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbICdtb3VzZWRvd24nLCAndGFwc3RhcnQnLCAndm1vdXNlZG93bicgXSwgZSwge1xuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgPT0gbnVsbCApe1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IGVsc2UgaWYoIG5lYXIuaXNFZGdlKCkgKXtcbiAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgIH1cblxuICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG5cbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcbiAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIG1vdXNlbW92ZUhhbmRsZXIoIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmKCAhY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSApeyByZXR1cm47IH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbIGUuY2xpZW50WCwgZS5jbGllbnRZIF07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZ3Bvc1swXSwgZ3Bvc1sxXSApO1xuICAgIHZhciBtZG93blBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgIHZhciBtZG93bkdQb3MgPSByLmhvdmVyRGF0YS5tZG93bkdQb3M7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgdmFyIG5lYXIgPSBudWxsO1xuICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIHBvc1swXSwgcG9zWzFdLCBmYWxzZSApO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgdmFyIGRpc3AgPSBbIHBvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdIF07XG5cbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYoIG1kb3duR1BvcyApe1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuXG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMjtcbiAgICB9XG5cbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKCBlICk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnIF0sIGUsIHtcbiAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgIH0gKTtcblxuICAgIHZhciBnb0ludG9Cb3hNb2RlID0gZnVuY3Rpb24oKXtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgY3kudHJpZ2dlcignYm94c3RhcnQnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG4gICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYoIGlzT3ZlclRocmVzaG9sZERyYWcgKXtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyBFdmVudCggZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKCAhci5ob3ZlckRhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgIH0gZWxzZSBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiggci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gKXtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcblxuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6ICggcG9zWzBdIC0gbWRQb3NbMF0gKSAqIHpvb20sXG4gICAgICAgICAgICB5OiAoIHBvc1sxXSAtIG1kUG9zWzFdICkgKiB6b29tXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY3kucGFuQnkoIGRlbHRhUCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLmNsaWVudFgsIGUuY2xpZW50WSApO1xuXG4gICAgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgfSBlbHNlIGlmKFxuICAgICAgICBzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24uaXNFZGdlKCkpXG4gICAgKXtcblxuICAgICAgaWYoIGlzT3ZlclRocmVzaG9sZERyYWcgKXtcblxuICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAoIG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApICl7XG4gICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiggIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCggZG93biwgci5ob3ZlckRhdGEuZG93bnMgKTtcblxuICAgICAgICAgIGlmKCBhbGxvd1Bhc3N0aHJvdWdoICl7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBtYXRoLmFycmF5MnBvaW50KCBtZG93blBvcyApO1xuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkb3duICYmIGRvd24uaXNFZGdlKCkgJiYgZG93bi5hY3RpdmUoKSApeyBkb3duLnVuYWN0aXZhdGUoKTsgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICAgIGlmKCAoICFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSApICYmIG5lYXIgIT0gbGFzdCApe1xuXG4gICAgICAgIGlmKCBsYXN0ICl7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyggbGFzdCwgWyAnbW91c2VvdXQnLCAndGFwZHJhZ291dCcgXSwgZSwge1xuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbICdtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInIF0sIGUsIHtcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICBpZiggZG93biAmJiByLm5vZGVJc0RyYWdnYWJsZSggZG93biApICl7XG5cbiAgICAgICAgaWYoIGlzT3ZlclRocmVzaG9sZERyYWcgKXsgLy8gdGhlbiB3ZSBjYW4gdGFrZSBhY3Rpb25cblxuICAgICAgICAgIGlmKCBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24gKXsgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiggZG93biAmJiBkb3duLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlbWVudHMgKTtcblxuICAgICAgICAgICAgICBkb3duLnRyaWdnZXIoJ2ZyZWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuXG4gICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGRyYWdcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IFtdO1xuXG4gICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIGN5LmNvbGxlY3Rpb24oIGRyYWdnZWRFbGVtZW50cyApLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRFbGUgPSBkcmFnZ2VkRWxlbWVudHNbIGkgXTtcblxuICAgICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIGRFbGUgKSAmJiBkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKCBkRWxlICk7XG5cbiAgICAgICAgICAgICAgICBpZiggaXMubnVtYmVyKCBkaXNwWzBdICkgJiYgaXMubnVtYmVyKCBkaXNwWzFdICkgKXtcbiAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVQb3MgPSAhZEVsZS5pc1BhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiggdXBkYXRlUG9zICl7XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgZHJhZ0RlbHRhICYmIGlzLm51bWJlciggZHJhZ0RlbHRhWzBdICkgJiYgaXMubnVtYmVyKCBkcmFnRGVsdGFbMV0gKSApe1xuICAgICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciB0Y29sID0gY3kuY29sbGVjdGlvbiggdG9UcmlnZ2VyICk7XG5cbiAgICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRjb2wudHJpZ2dlciggJ3Bvc2l0aW9uIGRyYWcnICk7XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNlbGVjdFsyXSA9IHBvc1swXTsgc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgaWYoIHByZXZlbnREZWZhdWx0ICl7XG4gICAgICBpZiggZS5zdG9wUHJvcGFnYXRpb24gKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYoIGUucHJldmVudERlZmF1bHQgKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBmYWxzZSApO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCB3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gbW91c2V1cEhhbmRsZXIoIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICBpZiggIWNhcHR1cmUgKXsgcmV0dXJuOyB9XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS5jbGllbnRYLCBlLmNsaWVudFkgKTsgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIHBvc1swXSwgcG9zWzFdLCBmYWxzZSApO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzOyB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93biggZSApO1xuXG4gICAgaWYoIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiApe1xuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmKCBkb3duICl7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgIHZhciBjeHRFdnQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZiggZG93biApe1xuICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICB2YXIgY3h0VGFwID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuXG4gICAgfSBlbHNlIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMSApe1xuXG4gICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgaWYoIChkb3duID09IG51bGwpIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgJiYgIWlzTXVsdFNlbEtleURvd24oIGUgKVxuICAgICAgKXtcblxuICAgICAgICBjeS4kKCBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgIH0gKS51bnNlbGVjdCgpO1xuXG4gICAgICAgIGlmKCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgIH1cblxuICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJyBdLCBlLCB7XG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZihcbiAgICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgKXtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyggZG93biwgWydjbGljaycsICd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgc2VsZWN0aW9uXG4gICAgICBpZiggbmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICBpZiggbmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICAgICAgICAvLyBpZiBwYW5uaW5nLCBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICFtdWx0U2VsS2V5RG93biApe1xuICAgICAgICAgICAgICBjeS4kKCAnOnNlbGVjdGVkJyApLnVubWVyZ2UoIG5lYXIgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbiggci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICkgKTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgICAgaWYoIGJveC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnRyaWdnZXIoJ2JveGVuZCcpO1xuXG4gICAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTsgfTtcblxuICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnICl7XG4gICAgICAgICAgYm94XG4gICAgICAgICAgICAudHJpZ2dlcignYm94JylcbiAgICAgICAgICAgIC5zdGRGaWx0ZXIoIGVsZVdvdWxkQmVTZWxlY3RlZCApXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAudHJpZ2dlcignYm94c2VsZWN0JylcbiAgICAgICAgICA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoICFtdWx0U2VsS2V5RG93biApe1xuICAgICAgICAgICAgY3kuJCggJzpzZWxlY3RlZCcgKS51bm1lcmdlKCBib3ggKS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveFxuICAgICAgICAgICAgLnRyaWdnZXIoJ2JveCcpXG4gICAgICAgICAgICAuc3RkRmlsdGVyKCBlbGVXb3VsZEJlU2VsZWN0ZWQgKVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ2JveHNlbGVjdCcpXG4gICAgICAgICAgO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcbiAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgZHJhZyBwYW5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICBpZiggIXNlbGVjdFs0XSApIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG5cbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZW1lbnRzICk7XG5cbiAgICAgICAgaWYoIGRvd25XYXNHcmFiYmVkICl7IGRvd24udHJpZ2dlcignZnJlZScpOyB9XG4gICAgICB9XG5cbiAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cbiAgICBzZWxlY3RbNF0gPSAwOyByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcblxuICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IG51bGw7XG5cbiAgfSwgZmFsc2UgKTtcblxuICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24oIGUgKXtcblxuXG4gICAgaWYoIHIuc2Nyb2xsaW5nUGFnZSApeyByZXR1cm47IH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLmNsaWVudFgsIGUuY2xpZW50WSApO1xuICAgIHZhciBycG9zID0gWyBwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LFxuICAgICAgICAgICAgICAgICAgcG9zWzFdICogY3kuem9vbSgpICsgY3kucGFuKCkueSBdO1xuXG4gICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkgKXsgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoIHIuZGF0YS53aGVlbFRpbWVvdXQgKTtcbiAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIDE1MCApO1xuXG4gICAgICB2YXIgZGlmZjtcblxuICAgICAgaWYoIGUuZGVsdGFZICE9IG51bGwgKXtcbiAgICAgICAgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MDtcbiAgICAgIH0gZWxzZSBpZiggZS53aGVlbERlbHRhWSAhPSBudWxsICl7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGFZIC8gMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgfVxuXG4gICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcbiAgICAgIGlmKCBuZWVkc1doZWVsRml4ICl7IC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICB9XG5cbiAgICAgIGN5Lnpvb20oIHtcbiAgICAgICAgbGV2ZWw6IGN5Lnpvb20oKSAqIE1hdGgucG93KCAxMCwgZGlmZiApLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7IHg6IHJwb3NbMF0sIHk6IHJwb3NbMV0gfVxuICAgICAgfSApO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gIC8vIC0tXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlICk7XG5cbiAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAnc2Nyb2xsJywgZnVuY3Rpb24gc2Nyb2xsSGFuZGxlciggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcblxuICAgIGNsZWFyVGltZW91dCggci5zY3JvbGxpbmdQYWdlVGltZW91dCApO1xuICAgIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwICk7XG4gIH0sIHRydWUgKTtcblxuICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIGhhbmRsaW5nIG1vdXNlb3V0L21vdXNlb3ZlciBvbiB0aGUgQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlciggZSApe1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7XG5cbiAgICByLmN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgIH0gKSApO1xuICB9LCBmYWxzZSApO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoIGUgKXtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLmNsaWVudFgsIGUuY2xpZW50WSApO1xuXG4gICAgci5jeS50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApICk7XG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiggeDEsIHkxLCB4MiwgeTIgKXtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkgKTtcbiAgfTtcblxuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICAgIHJldHVybiAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gIH07XG5cbiAgdmFyIHRvdWNoc3RhcnRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbiggZSApe1xuICAgIGlmKCAhZXZlbnRJbkNvbnRhaW5lcihlKSApeyByZXR1cm47IH1cblxuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiggZS50b3VjaGVzWzBdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSApOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmKCBlLnRvdWNoZXNbMV0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZICk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1syXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkgKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICBpZiggZS50b3VjaGVzWzFdICl7XG5cbiAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyApO1xuXG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcblxuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID1cbiAgICAgICAgICAgMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgO1xuXG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgY2VudGVyMSA9IFsgKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyIF07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbXG4gICAgICAgIChjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXG4gICAgICBdO1xuXG4gICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG4gICAgICBpZiggZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSApe1xuXG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSApO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggbm93WzJdLCBub3dbM10sIHRydWUgKTtcblxuICAgICAgICBpZiggbmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkgKXtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG5cbiAgICAgICAgfSBlbHNlIGlmKCBuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSApe1xuICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSApICk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKCBlLnRvdWNoZXNbMl0gKXtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzFdICl7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9IGVsc2UgaWYoIGUudG91Y2hlc1swXSApe1xuICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSApO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcblxuICAgICAgaWYoIG5lYXIgIT0gbnVsbCApe1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICBpZiggci5ub2RlSXNHcmFiYmFibGUoIG5lYXIgKSApe1xuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gW107XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKCB0aGlzICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKCBzZWxlY3RlZE5vZGVzLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEdyYWJUYXJnZXQoIG5lYXIgKTtcblxuICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbICd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nIF0sIGUsIHtcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKCBuZWFyID09IG51bGwgKXtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAvLyAtLS0tLVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQoIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG4gICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKFxuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2VcbiAgICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICApe1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIHIudG91Y2hEYXRhLnN0YXJ0LCBbICd0YXBob2xkJyBdLCBlLCB7XG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICBpZiggIXIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgICBjeS4kKCAnOnNlbGVjdGVkJyApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uICk7XG4gICAgfVxuXG4gICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPj0gMSApe1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuXG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFsgdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZIF07XG4gICAgfVxuXG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiggIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzBdICYmIHN0YXJ0R1BvcyApe1xuICAgICAgdmFyIGRpc3AgPSBbXTsgZm9yICh2YXIgaj0wO2o8bm93Lmxlbmd0aDtqKyspIHsgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07IH1cbiAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuXG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG4gICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuXG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgIGlmKCBmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EgKXtcbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG5cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFxuICAgICAgICAgICAgLnVuYWN0aXZhdGUoKVxuICAgICAgICAgICAgLnRyaWdnZXIoIGN4dEV2dCApXG4gICAgICAgICAgO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlXG4gICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICB9ICk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfVxuXG4gICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggbm93WzBdLCBub3dbMV0sIHRydWUgKTtcblxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICBpZiggci50b3VjaERhdGEuY3h0T3ZlciApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIC8vIGJveCBzZWxlY3Rpb25cbiAgICB9IGVsc2UgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcblxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgY3kudHJpZ2dlcignYm94c3RhcnQnKTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICBpZiggIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDMgKyAxO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDMgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICByLnJlZHJhdygpO1xuXG4gICAgLy8gcGluY2ggdG8gem9vbVxuICAgIH0gZWxzZSBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7IC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICBpZiggZHJhZ2dlZEVsZXMgKXtcbiAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGRlX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGRlX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRlX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuXG4gICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG4gICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICBpZiggdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlICl7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTtcblxuICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyO1xuXG4gICAgICAgIC8vIGFkanVzdCBmYWN0b3IgYnkgdGhlIHNwZWVkIG11bHRpcGxpZXJcbiAgICAgICAgLy8gdmFyIHNwZWVkID0gMS41O1xuICAgICAgICAvLyBpZiggZmFjdG9yID4gMSApe1xuICAgICAgICAvLyAgIGZhY3RvciA9IChmYWN0b3IgLSAxKSAqIHNwZWVkICsgMTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBmYWN0b3IgPSAxIC0gKDEgLSBmYWN0b3IpICogc3BlZWQ7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG4gICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTEgKiBmYWN0b3I7XG4gICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7XG5cbiAgICAgICAgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG4gICAgICAgIHZhciBjdHJ4ID0gbW9kZWxDZW50ZXIxWzBdICogem9vbTEgKyBwYW4xLng7XG4gICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG5cbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCAmJiByLnRvdWNoRGF0YS5zdGFydC5hY3RpdmUoKSApe1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVzICk7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFxuICAgICAgICAgICAgLnVuYWN0aXZhdGUoKVxuICAgICAgICAgICAgLnRyaWdnZXIoICdmcmVlJyApXG4gICAgICAgICAgO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kudmlld3BvcnQoIHtcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgIH0gKTtcblxuICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZTI7XG4gICAgICAgIGYxeDEgPSBmMXgyO1xuICAgICAgICBmMXkxID0gZjF5MjtcbiAgICAgICAgZjJ4MSA9IGYyeDI7XG4gICAgICAgIGYyeTEgPSBmMnkyO1xuXG4gICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICBpZiggZS50b3VjaGVzWzBdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSApOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmKCBlLnRvdWNoZXNbMl0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZICk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICB9IGVsc2UgaWYoIGUudG91Y2hlc1swXSApe1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICB2YXIgbmVhcjtcblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nICl7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggbm93WzBdLCBub3dbMV0sIHRydWUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCApe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYWdnaW5nIG5vZGVzXG4gICAgICBpZiggY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsICYmIHIubm9kZUlzRHJhZ2dhYmxlKCBzdGFydCApICl7XG5cbiAgICAgICAgaWYoIGlzT3ZlclRocmVzaG9sZERyYWcgKXsgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIGN5LmNvbGxlY3Rpb24oIGRyYWdnZWRFbGVzICksIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlID0gZHJhZ2dlZEVsZXNbIGsgXTtcblxuICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKCBkcmFnZ2VkRWxlICkgJiYgZHJhZ2dlZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIGRQb3MgPSBkcmFnZ2VkRWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICB2YXIgdXBkYXRlUG9zID0gIWRyYWdnZWRFbGUuaXNQYXJlbnQoKTtcblxuICAgICAgICAgICAgICBpZiggdXBkYXRlUG9zICYmIGlzLm51bWJlciggZGlzcFswXSApICYmIGlzLm51bWJlciggZGlzcFsxXSApICl7XG4gICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiggdXBkYXRlUG9zICYmIGRyYWdEZWx0YSAmJiBpcy5udW1iZXIoIGRyYWdEZWx0YVswXSApICYmIGlzLm51bWJlciggZHJhZ0RlbHRhWzFdICkgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRjb2wgPSBjeS5jb2xsZWN0aW9uKCBkcmFnZ2VkRWxlcyApO1xuXG4gICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgIHRjb2wudHJpZ2dlciggJ3Bvc2l0aW9uIGRyYWcnICk7XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcblxuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdXG4gICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV1cbiAgICAgICAgICApe1xuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIG90aGVyaXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzBdICk7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0b3VjaG1vdmVcbiAgICAgIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyggKHN0YXJ0IHx8IG5lYXIpLCBbICd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJyBdLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggKCAhc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSApICYmIG5lYXIgIT0gbGFzdCApe1xuICAgICAgICAgIGlmKCBsYXN0ICl7IGxhc3QudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7IHR5cGU6ICd0YXBkcmFnb3V0JywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0gKSApOyB9XG4gICAgICAgICAgaWYoIG5lYXIgKXsgbmVhci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHsgdHlwZTogJ3RhcGRyYWdvdmVyJywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0gKSApOyB9XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcbiAgICAgIGlmKCBjYXB0dXJlICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgaWYoIG5vd1sgaSBdXG4gICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWyBpIF1cbiAgICAgICAgICAgICYmIGlzT3ZlclRocmVzaG9sZERyYWcgKXtcblxuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhbm5pbmdcbiAgICAgIGlmKFxuICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgICAmJiAoIHN0YXJ0ID09IG51bGwgfHwgc3RhcnQuaXNFZGdlKCkgKVxuICAgICAgICAgICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKClcbiAgICAgICl7XG5cbiAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCggc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyApO1xuXG4gICAgICAgIGlmKCBhbGxvd1Bhc3N0aHJvdWdoICl7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYoIHIuc3dpcGVQYW5uaW5nICl7XG4gICAgICAgICAgICBjeS5wYW5CeSgge1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiggaXNPdmVyVGhyZXNob2xkRHJhZyApe1xuICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBjeS5wYW5CeSgge1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICAgIGlmKCAhci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gbWF0aC5hcnJheTJwb2ludCggci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrICl7IGVhcmxpZXJbIGogXSA9IG5vd1sgaiBdOyB9XG4gICAgLy9yLnJlZHJhdygpO1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24oIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYoIHN0YXJ0ICl7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9ICk7XG5cbiAgdmFyIHRvdWNoZW5kSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyID0gZnVuY3Rpb24oIGUgKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiggZS50b3VjaGVzWzBdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSApOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmKCBlLnRvdWNoZXNbMV0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZICk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1syXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkgKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIGlmKCBzdGFydCApe1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgaWYoIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgY3R4VGFwZW5kID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcGVuZCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICB2YXIgY3R4VGFwID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuXG4gICAgICByLnJlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICBpZiggIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nICl7XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcblxuICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oIHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApICk7XG5cbiAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgY3kudHJpZ2dlcignYm94ZW5kJyk7XG5cbiAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTsgfTtcblxuICAgICAgYm94XG4gICAgICAgIC50cmlnZ2VyKCdib3gnKVxuICAgICAgICAuc3RkRmlsdGVyKCBlbGVXb3VsZEJlU2VsZWN0ZWQgKVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC50cmlnZ2VyKCdib3hzZWxlY3QnKVxuICAgICAgO1xuXG4gICAgICBpZiggYm94Lm5vbmVtcHR5KCkgKXtcbiAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBpZiggc3RhcnQgIT0gbnVsbCApe1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGlmKCBlLnRvdWNoZXNbMl0gKXtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICB9IGVsc2UgaWYoIGUudG91Y2hlc1sxXSApe1xuICAgICAgLy8gaWdub3JlXG4gICAgfSBlbHNlIGlmKCBlLnRvdWNoZXNbMF0gKXtcbiAgICAgIC8vIGlnbm9yZVxuXG4gICAgLy8gTGFzdCB0b3VjaCByZWxlYXNlZFxuICAgIH0gZWxzZSBpZiggIWUudG91Y2hlc1swXSApe1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcblxuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcblxuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlcyApO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG5cbiAgICAgICAgaWYoIHN0YXJ0V2FzR3JhYmJlZCApe1xuICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoICdmcmVlJyApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyggc3RhcnQsIFsgJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0JyBdLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSApO1xuXG4gICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0JyBdLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGxcbiAgICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBkcmFnIG5vZGVzIGFyb3VuZFxuICAgICAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGVcbiAgICAgICAgICAmJiByZGlzdDIgPCByLnRvdWNoVGFwVGhyZXNob2xkMlxuICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICApe1xuXG4gICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgY3kuJCggJzpzZWxlY3RlZCcgKS51bm1lcmdlKCBzdGFydCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIHN0YXJ0LnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkICl7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoIHN0YXJ0LCBbICd0YXAnLCAndmNsaWNrJyBdLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKysgKXsgZWFybGllclsgaiBdID0gbm93WyBqIF07IH1cblxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCBtb3VzZWRvd25cblxuICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoID09PSAwICl7XG4gICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoIDwgMiApe1xuICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLy9yLnJlZHJhdygpO1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcbiAgaWYoIHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJyApe1xuXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG5cbiAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgcmFkaXVzWDogZS53aWR0aCAvIDIsXG4gICAgICAgIHJhZGl1c1k6IGUuaGVpZ2h0IC8gMixcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogZSxcbiAgICAgICAgdG91Y2g6IG1ha2VUb3VjaCggZSApXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBwb2ludGVycy5wdXNoKCBtYWtlUG9pbnRlciggZSApICk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVQb2ludGVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHAgPSBwb2ludGVyc1sgaSBdO1xuXG4gICAgICAgIGlmKCBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQgKXtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgdmFyIHAgPSBwb2ludGVycy5maWx0ZXIoIGZ1bmN0aW9uKCBwICl7XG4gICAgICAgIHJldHVybiBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQ7XG4gICAgICB9IClbMF07XG5cbiAgICAgIHAuZXZlbnQgPSBlO1xuICAgICAgcC50b3VjaCA9IG1ha2VUb3VjaCggZSApO1xuICAgIH07XG5cbiAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiggZSApe1xuICAgICAgZS50b3VjaGVzID0gcG9pbnRlcnMubWFwKCBmdW5jdGlvbiggcCApe1xuICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAncG9pbnRlcmRvd24nLCBmdW5jdGlvbiggZSApe1xuICAgICAgaWYoIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGFkZFBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKCBlICk7XG4gICAgfSApO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIGlmKCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2hlbmRIYW5kbGVyKCBlICk7XG4gICAgfSApO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBpZiggZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNoY2FuY2VsSGFuZGxlciggZSApO1xuICAgIH0gKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIGlmKCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB1cGRhdGVQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaG1vdmVIYW5kbGVyKCBlICk7XG4gICAgfSApO1xuXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5nZW5lcmF0ZVBvbHlnb24gPSBmdW5jdGlvbiggbmFtZSwgcG9pbnRzICl7XG4gIHJldHVybiAoIHRoaXMubm9kZVNoYXBlc1sgbmFtZSBdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogbmFtZSxcblxuICAgIHBvaW50czogcG9pbnRzLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCggJ3BvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICByZXR1cm4gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIHRoaXMucG9pbnRzLFxuICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMixcbiAgICAgICAgICBwYWRkaW5nIClcbiAgICAgICAgO1xuICAgIH0sXG5cbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiggeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuICAgICAgcmV0dXJuIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKCB4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyApXG4gICAgICA7XG4gICAgfVxuICB9ICk7XG59O1xuXG5CUnAuZ2VuZXJhdGVFbGxpcHNlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICggdGhpcy5ub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiAnZWxsaXBzZScsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgcmV0dXJuIG1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyICsgcGFkZGluZyxcbiAgICAgICAgaGVpZ2h0IC8gMiArIHBhZGRpbmcgKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiggeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgeSAtPSBjZW50ZXJZO1xuXG4gICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcblxuICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgPD0gMTtcbiAgICB9XG4gIH0gKTtcbn07XG5cbkJScC5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICggdGhpcy5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ3JvdW5kcmVjdGFuZ2xlJyxcblxuICAgIHBvaW50czogbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDQsIDAgKSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoIHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICByZXR1cm4gbWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgcGFkZGluZyApXG4gICAgICA7XG4gICAgfSxcblxuICAgIC8vIExvb2tzIGxpa2UgdGhlIHdpZHRoIHBhc3NlZCBpbnRvIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgdGhlIHRvdGFsIHdpZHRoIC8gMlxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gbWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyggd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiggbWF0aC5wb2ludEluc2lkZVBvbHlnb24oIHgsIHksIHRoaXMucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNvcm5lclJhZGl1cywgWzAsIC0xXSwgcGFkZGluZyApICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiggbWF0aC5wb2ludEluc2lkZVBvbHlnb24oIHgsIHksIHRoaXMucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiBjb3JuZXJSYWRpdXMsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyApICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiggeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApe1xuICAgICAgICB4IC09IGNlbnRlclg7XG4gICAgICAgIHkgLT0gY2VudGVyWTtcblxuICAgICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuXG4gICAgICAgIHJldHVybiAoeCAqIHggKyB5ICogeSA8PSAxKTtcbiAgICAgIH07XG5cblxuICAgICAgLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmKCBjaGVja0luRWxsaXBzZSggeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcgKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmKCBjaGVja0luRWxsaXBzZSggeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcgKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmKCBjaGVja0luRWxsaXBzZSggeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcgKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYoIGNoZWNrSW5FbGxpcHNlKCB4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZyApICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gKTtcbn07XG5cbkJScC5yZWdpc3Rlck5vZGVTaGFwZXMgPSBmdW5jdGlvbigpe1xuICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIHRoaXMuZ2VuZXJhdGVFbGxpcHNlKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICd0cmlhbmdsZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCAzLCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3JlY3RhbmdsZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA0LCAwICkgKTtcbiAgbm9kZVNoYXBlc1sgJ3NxdWFyZScgXSA9IG5vZGVTaGFwZXNbICdyZWN0YW5nbGUnIF07XG5cbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICdkaWFtb25kJywgW1xuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAwLCAtMSxcbiAgICAtMSwgMFxuICBdICk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICdwZW50YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA1LCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ2hleGFnb24nLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSggNiwgMCApICk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICdoZXB0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA3LCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ29jdGFnb24nLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSggOCwgMCApICk7XG5cbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KCAyMCApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKCA1LCAwICk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKCA1LCBNYXRoLlBJIC8gNSApO1xuXG4gICAgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCggNSApKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7aSA8IGlubmVyUG9pbnRzLmxlbmd0aCAvIDI7aSsrICl7XG4gICAgICBpbm5lclBvaW50c1sgaSAqIDJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbIGkgKiAyICsgMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7aSA8IDIwIC8gNDtpKysgKXtcbiAgICAgIHN0YXI1UG9pbnRzWyBpICogNF0gPSBvdXRlclBvaW50c1sgaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbIGkgKiA0ICsgMV0gPSBvdXRlclBvaW50c1sgaSAqIDIgKyAxXTtcblxuICAgICAgc3RhcjVQb2ludHNbIGkgKiA0ICsgMl0gPSBpbm5lclBvaW50c1sgaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbIGkgKiA0ICsgM10gPSBpbm5lclBvaW50c1sgaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cblxuICBzdGFyNVBvaW50cyA9IG1hdGguZml0UG9seWdvblRvU3F1YXJlKCBzdGFyNVBvaW50cyApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAnc3RhcicsIHN0YXI1UG9pbnRzICk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICd2ZWUnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAsIC0wLjMzMyxcbiAgICAxLCAtMSxcbiAgICAwLCAxXG4gIF0gKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3Job21ib2lkJywgW1xuICAgIC0xLCAtMSxcbiAgICAwLjMzMywgLTEsXG4gICAgMSwgMSxcbiAgICAtMC4zMzMsIDFcbiAgXSApO1xuXG4gIG5vZGVTaGFwZXMubWFrZVBvbHlnb24gPSBmdW5jdGlvbiggcG9pbnRzICl7XG5cbiAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcblxuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbiggJyQnICk7XG4gICAgdmFyIG5hbWUgPSAncG9seWdvbi0nICsga2V5O1xuICAgIHZhciBzaGFwZTtcblxuICAgIGlmKCAoc2hhcGUgPSB0aGlzWyBuYW1lIF0pICl7IC8vIGdvdCBjYWNoZWQgc2hhcGVcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuICAgIHJldHVybiByZW5kZXJlci5nZW5lcmF0ZVBvbHlnb24oIG5hbWUsIHBvaW50cyApO1xuICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAudGltZVRvUmVuZGVyID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbn07XG5cbkJScC5yZWRyYXcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7IH1cbiAgaWYoIHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3RSZWRyYXdUaW1lID0gMDsgfVxuICBpZiggci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3REcmF3VGltZSA9IDA7IH1cblxuICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbkJScC5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiggZm4sIHByaW9yaXR5ICl7XG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBhZGQgdGljayBjYWxsYmFja3Mgd2hlbiBkZXN0cm95ZWRcbiAgaWYoIHRoaXMuZGVzdHJveWVkICl7IHJldHVybjsgfVxuXG4gIHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblxuICB2YXIgY2JzID0gdGhpcy5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG5cbiAgY2JzLnB1c2goeyBmbjogZm4sIHByaW9yaXR5OiBwcmlvcml0eSB9KTtcblxuICAvLyBoaWdoZXIgcHJpb3JpdHkgY2FsbGJhY2tzIGV4ZWN1dGVkIGZpcnN0XG4gIGNicy5zb3J0KGZ1bmN0aW9uKCBhLCBiICl7IHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTsgfSk7XG59O1xuXG52YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24oIHIsIHdpbGxEcmF3LCBzdGFydFRpbWUgKXtcbiAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7XG4gICAgY2JzW2ldLmZuKCB3aWxsRHJhdywgc3RhcnRUaW1lICk7XG4gIH1cbn07XG5cbkJScC5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbigpe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYoIHIucmVuZGVyTG9vcFN0YXJ0ZWQgKXtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgci5yZW5kZXJMb29wU3RhcnRlZCA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiggcmVxdWVzdFRpbWUgKXtcbiAgICBpZiggci5kZXN0cm95ZWQgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUgKXtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyggciwgdHJ1ZSwgcmVxdWVzdFRpbWUgKTtcblxuICAgICAgdmFyIHN0YXJ0VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgci5yZW5kZXIoIHIucmVuZGVyT3B0aW9ucyApO1xuXG4gICAgICB2YXIgZW5kVGltZSA9IHIubGFzdERyYXdUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICBpZiggci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiggci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgIGlmKCByLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lIC8gMiArIGR1cmF0aW9uIC8gMjtcblxuICAgICAgci5yZXF1ZXN0ZWRGcmFtZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MoIHIsIGZhbHNlLCByZXF1ZXN0VGltZSApO1xuICAgIH1cblxuICAgIHIuc2tpcEZyYW1lID0gZmFsc2U7XG5cbiAgICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVuZGVyRm4gKTtcbiAgfTtcblxuICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVuZGVyRm4gKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxudmFyIGltcGw7XG5cbkNScC5hcnJvd1NoYXBlSW1wbCA9IGZ1bmN0aW9uKCBuYW1lICl7XG4gIHJldHVybiAoIGltcGwgfHwgKGltcGwgPSB7XG4gICAgJ3BvbHlnb24nOiBmdW5jdGlvbiggY29udGV4dCwgcG9pbnRzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbIGkgXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogZnVuY3Rpb24oIGNvbnRleHQsIHBvaW50cywgY29udHJvbFBvaW50ICl7XG4gICAgICB2YXIgZmlyc3RQdDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzWyBpIF07XG5cbiAgICAgICAgaWYoIGkgPT09IDAgKXtcbiAgICAgICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkgKTtcbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzICl7XG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHQgPSB0cmlQdHNbIGkgXTtcblxuICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICAgIH1cblxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cblxuICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgICAgICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICAgICAgICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oIGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55ICk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHQgPSB0ZWVQdHNbIGkgXTtcblxuICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICAgIH1cbiAgICAgIGlmKCBjb250ZXh0LmNsb3NlUGF0aCApeyBjb250ZXh0LmNsb3NlUGF0aCgpOyB9XG4gICAgfSxcblxuICAgICd0cmlhbmdsZS1jcm9zcyc6IGZ1bmN0aW9uKCBjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgY3Jvc3NMaW5lUG9pbnRzICl7XG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHQgPSB0cmlQdHNbIGkgXTtcblxuICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICAgIH1cblxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cblxuXG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gY3Jvc3NMaW5lUG9pbnRzO1xuICAgICAgdmFyIGZpcnN0VGVlUHQgPSBjcm9zc0xpbmVQb2ludHNbMF07XG4gICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjcm9zc0xpbmVQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHB0ID0gY3Jvc3NMaW5lUHRzWyBpIF07XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cbiAgICAgIGlmKCBjb250ZXh0LmNsb3NlUGF0aCApeyBjb250ZXh0LmNsb3NlUGF0aCgpOyB9XG4gICAgfSxcblxuICAgICdjaXJjbGUnOiBmdW5jdGlvbiggY29udGV4dCwgcngsIHJ5LCByICl7XG4gICAgICBjb250ZXh0LmFyYyggcngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UgKTtcbiAgICB9XG4gIH0pIClbIG5hbWUgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3RWRnZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlZGdlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBkcmF3TGFiZWwsIGRyYXdPdmVybGF5SW5zdGVhZCApe1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgaWYoIHJzLmJhZExpbmUgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSApeyAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiggIWVkZ2UudmlzaWJsZSgpICl7IHJldHVybjsgfVxuXG4gIHZhciBiYjtcbiAgaWYoIHNoaWZ0VG9PcmlnaW5XaXRoQmIgKXtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggLWJiLngxLCAtYmIueTEgKTtcbiAgfVxuXG4gIHZhciBvdmVybGF5UGFkZGluZyA9IGVkZ2UucHN0eWxlKCAnb3ZlcmxheS1wYWRkaW5nJyApLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCAnb3ZlcmxheS1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gZWRnZS5wc3R5bGUoICdvdmVybGF5LWNvbG9yJyApLnZhbHVlO1xuXG4gIC8vIEVkZ2UgY29sb3IgJiBvcGFjaXR5XG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgIGlmKCBvdmVybGF5T3BhY2l0eSA9PT0gMCApeyAvLyBleGl0IGVhcmx5IGlmIG5vIG92ZXJsYXlcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0cm9rZVN0eWxlKCBjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSApO1xuICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT0gJ3NlbGYnICYmICF1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHZhciBsaW5lQ29sb3IgPSBlZGdlLnBzdHlsZSggJ2xpbmUtY29sb3InICkudmFsdWU7XG5cbiAgICB0aGlzLnN0cm9rZVN0eWxlKCBjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBlZGdlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWUgKTtcblxuICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgfVxuXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSggJ3dpZHRoJyApLnBmVmFsdWUgKyAoZHJhd092ZXJsYXlJbnN0ZWFkID8gMiAqIG92ZXJsYXlQYWRkaW5nIDogMCk7XG4gIHZhciBsaW5lU3R5bGUgPSBkcmF3T3ZlcmxheUluc3RlYWQgPyAnc29saWQnIDogZWRnZS5wc3R5bGUoICdsaW5lLXN0eWxlJyApLnZhbHVlO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcblxuICB2YXIgc2hhZG93Qmx1ciA9IGVkZ2UucHN0eWxlKCAnc2hhZG93LWJsdXInICkucGZWYWx1ZTtcbiAgdmFyIHNoYWRvd09wYWNpdHkgPSBlZGdlLnBzdHlsZSggJ3NoYWRvdy1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBlZGdlLnBzdHlsZSggJ3NoYWRvdy1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBlZGdlLnBzdHlsZSggJ3NoYWRvdy1vZmZzZXQteCcgKS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WSA9IGVkZ2UucHN0eWxlKCAnc2hhZG93LW9mZnNldC15JyApLnBmVmFsdWU7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgIHNoYWRvd0NvbG9yLCBkcmF3T3ZlcmxheUluc3RlYWQgPyAwIDogc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSApO1xuXG4gIHRoaXMuZHJhd0VkZ2VQYXRoKFxuICAgIGVkZ2UsXG4gICAgY29udGV4dCxcbiAgICBycy5hbGxwdHMsXG4gICAgbGluZVN0eWxlLFxuICAgIGVkZ2VXaWR0aFxuICApO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZHMoIGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCApO1xuXG4gIHRoaXMuc2hhZG93U3R5bGUoIGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDAgKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgaWYoICFkcmF3T3ZlcmxheUluc3RlYWQgKXtcbiAgICB0aGlzLmRyYXdFZGdlKCBjb250ZXh0LCBlZGdlLCBmYWxzZSwgZHJhd0xhYmVsLCB0cnVlICk7XG4gIH1cblxuICB0aGlzLmRyYXdFbGVtZW50VGV4dCggY29udGV4dCwgZWRnZSwgZHJhd0xhYmVsICk7XG5cbiAgaWYoIHNoaWZ0VG9PcmlnaW5XaXRoQmIgKXtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggYmIueDEsIGJiLnkxICk7XG4gIH1cbn07XG5cblxuQ1JwLmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uKCBlZGdlLCBjb250ZXh0LCBwdHMsIHR5cGUsIHdpZHRoICl7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cy5qb2luKCAnJCcgKTtcbiAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcblxuICAgIGlmKCBrZXlNYXRjaGVzICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBjYW52YXNDeHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goIFsgMSwgMSBdICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goIFsgNiwgMyBdICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCggWyBdICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhcGF0aENhY2hlSGl0ICYmICFycy5iYWRMaW5lICl7XG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cbiAgICBjb250ZXh0Lm1vdmVUbyggcHRzWzBdLCBwdHNbMV0gKTtcblxuICAgIHN3aXRjaCggcnMuZWRnZVR5cGUgKXtcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgZm9yKCB2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKCBwdHNbIGkgXSwgcHRzWyBpICsgMV0sIHB0c1sgaSArIDJdLCBwdHNbIGkgKyAzXSApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIGZvciggdmFyIGkgPSAyOyBpICsgMSA8IHB0cy5sZW5ndGg7IGkgKz0gMiApe1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdHNbIGkgXSwgcHRzWyBpICsgMV0gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuICBpZiggdXNlUGF0aHMgKXtcbiAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcbiAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyBdICk7XG4gIH1cblxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCApe1xuICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7IHJldHVybjsgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBmb3Igb3ZlcmxheXNcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gIGlmKCAhaXNIYXlzdGFjayApe1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ3NvdXJjZScsIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgcnMuc3JjQXJyb3dBbmdsZSApO1xuICB9XG5cbiAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUgKTtcblxuICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICdtaWQtc291cmNlJywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkc3JjQXJyb3dBbmdsZSApO1xuXG4gIGlmKCAhaXNIYXlzdGFjayApe1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlICk7XG4gIH1cbn07XG5cbkNScC5kcmF3QXJyb3doZWFkID0gZnVuY3Rpb24oIGNvbnRleHQsIGVkZ2UsIHByZWZpeCwgeCwgeSwgYW5nbGUgKXtcbiAgaWYoIGlzTmFOKCB4ICkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKCB5ICkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKCBhbmdsZSApIHx8IGFuZ2xlID09IG51bGwgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKCBwcmVmaXggKyAnLWFycm93LXNoYXBlJyApLnZhbHVlO1xuICBpZiggYXJyb3dTaGFwZSA9PT0gJ25vbmUnICkgeyByZXR1cm47IH1cblxuICB2YXIgYXJyb3dDbGVhckZpbGwgPSBlZGdlLnBzdHlsZSggcHJlZml4ICsgJy1hcnJvdy1maWxsJyApLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICB2YXIgYXJyb3dGaWxsID0gZWRnZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctZmlsbCcgKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZTtcbiAgdmFyIG9wYWNpdHkgPSBlZGdlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWU7XG5cbiAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gIHZhciBzaGFwZUltcGwgPSBzZWxmLmFycm93U2hhcGVzWyBhcnJvd1NoYXBlIF07XG5cbiAgLy8gY2hlY2sgaWYgdGhlIHNoYXBlIG5lZWRzIGJvdGggZmlsbCBhbmQgc3Ryb2tlIG9wZXJhdGlvbnMgdG8gYmUgZHJhd25cbiAgaWYoIHNoYXBlSW1wbC5mb3JjZVN0cm9rZSAmJiBhcnJvd0ZpbGwgPT09ICdmaWxsZWQnICl7XG4gICAgYXJyb3dGaWxsID0gJ2JvdGgnO1xuICB9XG5cbiAgaWYoIG9wYWNpdHkgIT09IDEgfHwgYXJyb3dGaWxsID09PSAnaG9sbG93JyApeyAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICBzZWxmLmZpbGxTdHlsZSggY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSApO1xuICAgIHNlbGYuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEgKTtcblxuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCxcbiAgICAgIGFycm93Q2xlYXJGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIHgsIHksIGFuZ2xlXG4gICAgKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZSggcHJlZml4ICsgJy1hcnJvdy1jb2xvcicgKS52YWx1ZTtcbiAgc2VsZi5maWxsU3R5bGUoIGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkgKTtcbiAgc2VsZi5zdHJva2VTdHlsZSggY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSApO1xuXG4gIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCxcbiAgICBhcnJvd0ZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGVcbiAgKTtcbn07XG5cbkNScC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uKCBlZGdlLCBhcnJvd1R5cGUsIGNvbnRleHQsIGZpbGwsIGVkZ2VXaWR0aCwgc2hhcGUsIHgsIHksIGFuZ2xlICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYXRoO1xuICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gIHZhciB0cmFuc2xhdGlvbiA9IHsgeDogeCwgeTogeSB9O1xuICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSggJ2Fycm93LXNjYWxlJyApLnZhbHVlO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZVdpZHRoLCBzY2FsZSApO1xuICB2YXIgc2hhcGVJbXBsID0gci5hcnJvd1NoYXBlc1sgc2hhcGUgXTtcblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gc2l6ZSArICckJyArIHNoYXBlICsgJyQnICsgYW5nbGUgKyAnJCcgKyB4ICsgJyQnICsgeTtcbiAgICBycy5hcnJvd1BhdGhDYWNoZUtleSA9IHJzLmFycm93UGF0aENhY2hlS2V5IHx8IHt9O1xuICAgIHJzLmFycm93UGF0aENhY2hlID0gcnMuYXJyb3dQYXRoQ2FjaGUgfHwge307XG5cbiAgICB2YXIgYWxyZWFkeUNhY2hlZCA9IHJzLmFycm93UGF0aENhY2hlS2V5WyBhcnJvd1R5cGUgXSA9PT0gcGF0aENhY2hlS2V5O1xuICAgIGlmKCBhbHJlYWR5Q2FjaGVkICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLmFycm93UGF0aENhY2hlWyBhcnJvd1R5cGUgXTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBycy5hcnJvd1BhdGhDYWNoZUtleVsgYXJyb3dUeXBlIF0gPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZVsgYXJyb3dUeXBlIF0gPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcbiAgICBzaGFwZUltcGwuZHJhdyggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGggKTtcbiAgfVxuXG4gIGlmKCAhc2hhcGVJbXBsLmxlYXZlUGF0aE9wZW4gJiYgY29udGV4dC5jbG9zZVBhdGggKXtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgaWYoIGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9ICggc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSApO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmRyYXdFbGVtZW50ID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsICl7XG4gIHZhciByID0gdGhpcztcblxuICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgci5kcmF3Tm9kZSggY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwgKTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlKCBjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCApO1xuICB9XG59O1xuXG5DUnAuZHJhd0NhY2hlZEVsZW1lbnQgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IHJldHVybjsgfVxuXG4gIGlmKCAhZXh0ZW50IHx8IG1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCggYmIsIGV4dGVudCApICl7XG4gICAgdmFyIGNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlLmdldEVsZW1lbnQoIGVsZSwgYmIsIHB4UmF0aW8gKTtcblxuICAgIGlmKCBjYWNoZSApe1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGNhY2hlLnRleHR1cmUuY2FudmFzLCBjYWNoZS54LCAwLCBjYWNoZS53aWR0aCwgY2FjaGUuaGVpZ2h0LCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmggKTtcbiAgICB9IGVsc2UgeyAvLyBpZiB0aGUgZWxlbWVudCBpcyBub3QgY2FjaGVhYmxlLCB0aGVuIGRyYXcgZGlyZWN0bHlcbiAgICAgIHIuZHJhd0VsZW1lbnQoIGNvbnRleHQsIGVsZSApO1xuICAgIH1cbiAgfVxufTtcblxuQ1JwLmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVzICl7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgci5kcmF3RWxlbWVudCggY29udGV4dCwgZWxlICk7XG4gIH1cbn07XG5cbkNScC5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50ICl7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudCggY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdDYWNoZWROb2RlcyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICBpZiggIWVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudCggY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50ICl7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgbGF5ZXJzID0gci5kYXRhLmx5clR4ckNhY2hlLmdldExheWVycyggZWxlcywgcHhSYXRpbyApO1xuXG4gIGlmKCBsYXllcnMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgdmFyIGJiID0gbGF5ZXIuYmI7XG5cbiAgICAgIGlmKCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgKXsgY29udGludWU7IH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGxheWVyLmNhbnZhcywgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oICk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50cyggY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50ICk7XG4gIH1cbn07XG5cbkNScC5kcmF3RGVidWdQb2ludHMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlcyApe1xuICB2YXIgZHJhdyA9IGZ1bmN0aW9uKCB4LCB5LCBjb2xvciApe1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5maWxsUmVjdCggeCAtIDEsIHkgLSAxLCAzLCAzICk7XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICB2YXIgcCA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgICBkcmF3KCBwLngsIHAueSwgJ21hZ2VudGEnICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqICsgMSA8IHB0cy5sZW5ndGg7IGogKz0gMiApe1xuICAgICAgICB2YXIgeCA9IHB0c1sgaiBdO1xuICAgICAgICB2YXIgeSA9IHB0c1sgaiArIDEgXTtcblxuICAgICAgICBkcmF3KCB4LCB5LCAnY3lhbicgKTtcbiAgICAgIH1cblxuICAgICAgZHJhdyggcnMubWlkWCwgcnMubWlkWSwgJ3llbGxvdycgKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24oIGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKTtcbiAgfSBjYXRjaCggZSApe1xuICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcblxuICAgIHIuZHJhd2luZ0ltYWdlID0gdHJ1ZTtcblxuICAgIHIucmVkcmF3KCk7XG4gIH1cbn07XG5cbkNScC5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbiggY29udGV4dCwgaW1nLCBub2RlICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVYID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICB2YXIgbm9kZVkgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gIHZhciBmaXQgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtZml0JyApLnZhbHVlO1xuICB2YXIgeFBvcyA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyApO1xuICB2YXIgeVBvcyA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyApO1xuICB2YXIgcmVwZWF0ID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLXJlcGVhdCcgKS52YWx1ZTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2xpcCA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1jbGlwJyApLnZhbHVlO1xuICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgdmFyIGltZ09wYWNpdHkgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScgKS52YWx1ZTtcblxuICB2YXIgaW1nVyA9IGltZy53aWR0aCB8fCBpbWcuY2FjaGVkVztcbiAgdmFyIGltZ0ggPSBpbWcuaGVpZ2h0IHx8IGltZy5jYWNoZWRIO1xuXG4gIC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG4gIGlmKCBudWxsID09IGltZ1cgfHwgbnVsbCA9PSBpbWdIICl7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggaW1nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggaW1nICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuXG4gIHZhciB3ID0gaW1nVztcbiAgdmFyIGggPSBpbWdIO1xuXG4gIHZhciBiZ1cgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtd2lkdGgnICk7XG4gIGlmKCBiZ1cudmFsdWUgIT09ICdhdXRvJyApe1xuICAgIGlmKCBiZ1cudW5pdHMgPT09ICclJyApe1xuICAgICAgdyA9IGJnVy5wZlZhbHVlICogbm9kZVc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBiZ1cucGZWYWx1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmdIID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLWhlaWdodCcgKTtcbiAgaWYoIGJnSC52YWx1ZSAhPT0gJ2F1dG8nICl7XG4gICAgaWYoIGJnSC51bml0cyA9PT0gJyUnICl7XG4gICAgICBoID0gYmdILnBmVmFsdWUgKiBub2RlSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGJnSC5wZlZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCB3ID09PSAwIHx8IGggPT09IDAgKXtcbiAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgfVxuXG4gIGlmKCBmaXQgPT09ICdjb250YWluJyApe1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKCBub2RlVyAvIHcsIG5vZGVIIC8gaCApO1xuXG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuXG4gIH0gZWxzZSBpZiggZml0ID09PSAnY292ZXInICl7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoIG5vZGVXIC8gdywgbm9kZUggLyBoICk7XG5cbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH1cblxuICB2YXIgeCA9IChub2RlWCAtIG5vZGVXIC8gMik7IC8vIGxlZnRcbiAgaWYoIHhQb3MudW5pdHMgPT09ICclJyApe1xuICAgIHggKz0gKG5vZGVXIC0gdykgKiB4UG9zLnBmVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgeCArPSB4UG9zLnBmVmFsdWU7XG4gIH1cblxuICB2YXIgeSA9IChub2RlWSAtIG5vZGVIIC8gMik7IC8vIHRvcFxuICBpZiggeVBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgeSArPSAobm9kZUggLSBoKSAqIHlQb3MucGZWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IHlQb3MucGZWYWx1ZTtcbiAgfVxuXG4gIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICB4IC09IG5vZGVYO1xuICAgIHkgLT0gbm9kZVk7XG5cbiAgICBub2RlWCA9IDA7XG4gICAgbm9kZVkgPSAwO1xuICB9XG5cbiAgdmFyIGdBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG5cbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG5cbiAgaWYoIHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcgKXtcblxuICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgICAgICBjb250ZXh0LmNsaXAoIHJzLnBhdGhDYWNoZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzWyByLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGVYLCBub2RlWSxcbiAgICAgICAgICBub2RlVywgbm9kZUggKTtcblxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByLnNhZmVEcmF3SW1hZ2UoIGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCApO1xuXG4gICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybiggaW1nLCByZXBlYXQgKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG5cbiAgICByLm5vZGVTaGFwZXNbIHIuZ2V0Tm9kZVNoYXBlKCBub2RlICkgXS5kcmF3KFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBub2RlWCwgbm9kZVksXG4gICAgICAgIG5vZGVXLCBub2RlSCApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoIHgsIHkgKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXgsIC15ICk7XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmVsZVRleHRCaWdnZXJUaGFuTWluID0gZnVuY3Rpb24oIGVsZSwgc2NhbGUgKXtcbiAgaWYoICFzY2FsZSApe1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIGx2bCA9IE1hdGguY2VpbCggbWF0aC5sb2cyKCB6b29tICogcHhSYXRpbyApICk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgc2NhbGUgPSBNYXRoLnBvdyggMiwgbHZsICk7XG4gIH1cblxuICB2YXIgY29tcHV0ZWRTaXplID0gZWxlLnBzdHlsZSggJ2ZvbnQtc2l6ZScgKS5wZlZhbHVlICogc2NhbGU7XG4gIHZhciBtaW5TaXplID0gZWxlLnBzdHlsZSggJ21pbi16b29tZWQtZm9udC1zaXplJyApLnBmVmFsdWU7XG5cbiAgaWYoIGNvbXB1dGVkU2l6ZSA8IG1pblNpemUgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNScC5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlLCBmb3JjZSApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYoIGZvcmNlID09PSB1bmRlZmluZWQgKXtcbiAgICBpZiggIXIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oIGVsZSApICl7IHJldHVybjsgfVxuICB9IGVsc2Uge1xuICAgIGlmKCAhZm9yY2UgKXsgcmV0dXJuOyB9XG4gIH1cblxuICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZSggJ2xhYmVsJyApO1xuXG4gICAgaWYoICFsYWJlbCB8fCAhbGFiZWwudmFsdWUgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dEhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LWhhbGlnbicgKS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcblxuICAgIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZSggJ2xhYmVsJyApO1xuICAgIHZhciBzcmNMYWJlbCA9IGVsZS5wc3R5bGUoICdzb3VyY2UtbGFiZWwnICk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSggJ3RhcmdldC1sYWJlbCcgKTtcblxuICAgIGlmKFxuICAgICAgKCAhbGFiZWwgfHwgIWxhYmVsLnZhbHVlIClcbiAgICAgICYmICggIXNyY0xhYmVsIHx8ICFzcmNMYWJlbC52YWx1ZSApXG4gICAgICAmJiAoICF0Z3RMYWJlbCB8fCAhdGd0TGFiZWwudmFsdWUgKVxuICAgICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9XG5cblxuICByLmRyYXdUZXh0KCBjb250ZXh0LCBlbGUgKTtcblxuICBpZiggZWxlLmlzRWRnZSgpICl7XG4gICAgci5kcmF3VGV4dCggY29udGV4dCwgZWxlLCAnc291cmNlJyApO1xuXG4gICAgci5kcmF3VGV4dCggY29udGV4dCwgZWxlLCAndGFyZ2V0JyApO1xuICB9XG59O1xuXG5DUnAuZHJhd05vZGVUZXh0ID0gQ1JwLmRyYXdFZGdlVGV4dCA9IENScC5kcmF3RWxlbWVudFRleHQ7XG5cbkNScC5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbiggY29udGV4dCApe1xuICB2YXIgY2FjaGU7XG5cbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbIGkgXTtcblxuICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUgPSB7XG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xuICB0aGlzLmZvbnRDYWNoZXMucHVzaCggY2FjaGUgKTtcblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG4vLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4vLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5DUnAuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlICl7XG4gIC8vIEZvbnQgc3R5bGVcbiAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICB2YXIgbGFiZWxTdHlsZSA9IGVsZS5wc3R5bGUoICdmb250LXN0eWxlJyApLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSggJ2ZvbnQtc2l6ZScgKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGxhYmVsRmFtaWx5ID0gZWxlLnBzdHlsZSggJ2ZvbnQtZmFtaWx5JyApLnN0clZhbHVlO1xuICB2YXIgbGFiZWxXZWlnaHQgPSBlbGUucHN0eWxlKCAnZm9udC13ZWlnaHQnICkuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtb3BhY2l0eScgKS52YWx1ZSAqIGVsZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlICogcGFyZW50T3BhY2l0eTtcbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtb3V0bGluZS1vcGFjaXR5JyApLnZhbHVlICogb3BhY2l0eTtcbiAgdmFyIGNvbG9yID0gZWxlLnBzdHlsZSggJ2NvbG9yJyApLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSggJ3RleHQtb3V0bGluZS1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIHNoYWRvd0JsdXIgPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctYmx1cicgKS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IGVsZS5wc3R5bGUoICd0ZXh0LXNoYWRvdy1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctY29sb3InICkudmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRYID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LW9mZnNldC14JyApLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LW9mZnNldC15JyApLnBmVmFsdWU7XG5cbiAgdmFyIGZvbnRDYWNoZUtleSA9IGVsZS5fcHJpdmF0ZS5mb250S2V5O1xuICB2YXIgY2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZSggY29udGV4dCApO1xuXG4gIGlmKCBjYWNoZS5rZXkgIT09IGZvbnRDYWNoZUtleSApe1xuICAgIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuXG4gICAgY2FjaGUua2V5ID0gZm9udENhY2hlS2V5O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvbiBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudFxuXG4gIC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcblxuICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgY29sb3JbIDAgXSwgY29sb3JbIDEgXSwgY29sb3JbIDIgXSwgb3BhY2l0eSApO1xuXG4gIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIG91dGxpbmVDb2xvclsgMCBdLCBvdXRsaW5lQ29sb3JbIDEgXSwgb3V0bGluZUNvbG9yWyAyIF0sIG91dGxpbmVPcGFjaXR5ICk7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkgKTtcbn07XG5cbmZ1bmN0aW9uIHJvdW5kUmVjdCggY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKXtcbiAgdmFyIHJhZGl1cyA9IHJhZGl1cyB8fCA1O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oIHggKyByYWRpdXMsIHkgKTtcbiAgY3R4LmxpbmVUbyggeCArIHdpZHRoIC0gcmFkaXVzLCB5ICk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyApO1xuICBjdHgubGluZVRvKCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMgKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0ICk7XG4gIGN0eC5saW5lVG8oIHggKyByYWRpdXMsIHkgKyBoZWlnaHQgKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMgKTtcbiAgY3R4LmxpbmVUbyggeCwgeSArIHJhZGl1cyApO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyggeCwgeSwgeCArIHJhZGl1cywgeSApO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5maWxsKCk7XG59XG5cbi8vIERyYXcgdGV4dFxuQ1JwLmRyYXdUZXh0ID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZSwgcHJlZml4ICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgaWYoIHBhcmVudE9wYWNpdHkgPT09IDAgfHwgZWxlLnBzdHlsZSggJ3RleHQtb3BhY2l0eScgKS52YWx1ZSA9PT0gMCApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0WCA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXggKTtcbiAgdmFyIHRleHRZID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCApO1xuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGUsIHByZWZpeCApO1xuXG4gIGlmKCB0ZXh0ICE9IG51bGwgJiYgdGV4dCAhPT0gJycgJiYgIWlzTmFOKCB0ZXh0WCApICYmICFpc05hTiggdGV4dFkgKSApe1xuICAgIHRoaXMuc2V0dXBUZXh0U3R5bGUoIGNvbnRleHQsIGVsZSApO1xuXG4gICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHRleHRXID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXggKTtcbiAgICB2YXIgdGV4dEggPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXggKTtcbiAgICB2YXIgdGV4dEFuZ2xlID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXggKTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUoIHBkYXNoICsgJ3RleHQtbWFyZ2luLXgnICkucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUoIHBkYXNoICsgJ3RleHQtbWFyZ2luLXknICkucGZWYWx1ZTtcblxuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcblxuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC1oYWxpZ24nICkudmFsdWU7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS52YWx1ZTtcblxuICAgIGlmKCBpc0VkZ2UgKXtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuXG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZSggJ3RleHQtcm90YXRpb24nICk7XG4gICAgdmFyIHRoZXRhO1xuXG4gICAgaWYoIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScgKXtcbiAgICAgIHRoZXRhID0gaXNFZGdlID8gdGV4dEFuZ2xlIDogMDtcbiAgICB9IGVsc2UgaWYoIHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScgKXtcbiAgICAgIHRoZXRhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICAgIH1cblxuICAgIGlmKCB0aGV0YSAhPT0gMCApe1xuICAgICAgdmFyIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICB2YXIgb3JnVGV4dFkgPSB0ZXh0WTtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUoIG9yZ1RleHRYLCBvcmdUZXh0WSApO1xuICAgICAgY29udGV4dC5yb3RhdGUoIHRoZXRhICk7XG5cbiAgICAgIHRleHRYID0gMDtcbiAgICAgIHRleHRZID0gMDtcbiAgICB9XG5cbiAgICBzd2l0Y2goIHZhbGlnbiApe1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IGVsZS5wc3R5bGUoICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScgKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IGVsZS5wc3R5bGUoICd0ZXh0LWJvcmRlci1vcGFjaXR5JyApLnZhbHVlO1xuICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgYmFja2dyb3VuZFBhZGRpbmcgPSBlbGUucHN0eWxlKCAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnICkucGZWYWx1ZTtcblxuICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgKCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwICkgKXtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICBzd2l0Y2goIGhhbGlnbiApe1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgYmdYIC09IHRleHRXIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmdZID0gdGV4dFkgLSB0ZXh0SCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnVyA9IHRleHRXICsgMipiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ0ggPSB0ZXh0SCArIDIqYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1jb2xvcicgKS52YWx1ZTtcblxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWyAwIF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWyAxIF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWyAyIF0gKyAnLCcgKyBiYWNrZ3JvdW5kT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIHZhciBzdHlsZVNoYXBlID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1zaGFwZScgKS5zdHJWYWx1ZTtcbiAgICAgICAgaWYoIHN0eWxlU2hhcGUgPT0gJ3JvdW5kcmVjdGFuZ2xlJyApe1xuICAgICAgICAgIHJvdW5kUmVjdCggY29udGV4dCwgYmdYLCBiZ1ksIGJnVywgYmdILCAyICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdCggYmdYLCBiZ1ksIGJnVywgYmdIICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIH1cblxuICAgICAgaWYoIHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gZWxlLnBzdHlsZSggJ3RleHQtYm9yZGVyLWNvbG9yJyApLnZhbHVlO1xuICAgICAgICB2YXIgdGV4dEJvcmRlclN0eWxlID0gZWxlLnBzdHlsZSggJ3RleHQtYm9yZGVyLXN0eWxlJyApLnZhbHVlO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWyAwIF0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbIDEgXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsgMiBdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIHN3aXRjaCggdGV4dEJvcmRlclN0eWxlICl7XG4gICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIDEsIDEgXSApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgNCwgMiBdICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyA0OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFtdICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbXSApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoIGJnWCwgYmdZLCBiZ1csIGJnSCApO1xuXG4gICAgICAgIGlmKCB0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnICl7XG4gICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyAyO1xuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KCBiZ1ggKyB3aGl0ZVdpZHRoLCBiZ1kgKyB3aGl0ZVdpZHRoLCBiZ1cgLSB3aGl0ZVdpZHRoICogMiwgYmdIIC0gd2hpdGVXaWR0aCAqIDIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFtdICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBsaW5lV2lkdGggPSAyICogZWxlLnBzdHlsZSggJ3RleHQtb3V0bGluZS13aWR0aCcgKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG5cbiAgICBpZiggZWxlLnBzdHlsZSggJ3RleHQtd3JhcCcgKS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgICB2YXIgbGluZXMgPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXggKTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGV4dEggLyBsaW5lcy5sZW5ndGg7XG5cbiAgICAgIHN3aXRjaCggdmFsaWduICl7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdGV4dFkgLT0gKCBsaW5lcy5sZW5ndGggLSAxICkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZIC09ICggbGluZXMubGVuZ3RoIC0gMSApICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCggbGluZXNbIGwgXSwgdGV4dFgsIHRleHRZICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCBsaW5lc1sgbCBdLCB0ZXh0WCwgdGV4dFkgKTtcblxuICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCggdGV4dCwgdGV4dFgsIHRleHRZICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZmlsbFRleHQoIHRleHQsIHRleHRYLCB0ZXh0WSApO1xuICAgIH1cblxuICAgIGlmKCB0aGV0YSAhPT0gMCApe1xuICAgICAgY29udGV4dC5yb3RhdGUoIC10aGV0YSApO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIC1vcmdUZXh0WCwgLW9yZ1RleHRZICk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi8uLi9pcycgKTtcblxudmFyIENScCA9IHt9O1xuXG5DUnAuZHJhd05vZGUgPSBmdW5jdGlvbiggY29udGV4dCwgbm9kZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgZHJhd0xhYmVsICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIHBvcyA9IHBvcyB8fCBfcC5wb3NpdGlvbjtcblxuICBpZiggIWlzLm51bWJlciggcG9zLnggKSB8fCAhaXMubnVtYmVyKCBwb3MueSApICl7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuXG4gIGlmKCAhbm9kZS52aXNpYmxlKCkgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHBhcmVudE9wYWNpdHkgPSBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcblxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG5cbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG5cbiAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7XG5cbiAgY29udGV4dC5saW5lV2lkdGggPSBub2RlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlO1xuXG4gIC8vXG4gIC8vIHNldHVwIHNoaWZ0XG5cbiAgdmFyIGJiO1xuICBpZiggc2hpZnRUb09yaWdpbldpdGhCYiApe1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKCAtYmIueDEsIC1iYi55MSApO1xuICB9XG5cbiAgLy9cbiAgLy8gbG9hZCBiZyBpbWFnZVxuXG4gIHZhciBiZ0ltZ1Byb3AgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtaW1hZ2UnICk7XG4gIHZhciB1cmwgPSBiZ0ltZ1Byb3AudmFsdWVbMl0gfHwgYmdJbWdQcm9wLnZhbHVlWzFdO1xuICB2YXIgaW1hZ2U7XG5cbiAgaWYoIHVybCAhPT0gdW5kZWZpbmVkICl7XG5cbiAgICB2YXIgYmdJbWdDcm9zc09yaWdpbiA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicgKTtcblxuICAgIC8vIGdldCBpbWFnZSwgYW5kIGlmIG5vdCBsb2FkZWQgdGhlbiBhc2sgdG8gcmVkcmF3IHdoZW4gbGF0ZXIgbG9hZGVkXG4gICAgaW1hZ2UgPSB0aGlzLmdldENhY2hlZEltYWdlKCB1cmwsIGJnSW1nQ3Jvc3NPcmlnaW4sIGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLnRyaWdnZXIoJ2JhY2tncm91bmQnKTtcblxuICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgIHIuZHJhd2luZ0ltYWdlID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9ICk7XG5cbiAgICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgICBfcC5iYWNrZ3JvdW5kaW5nID0gIWltYWdlLmNvbXBsZXRlO1xuXG4gICAgaWYoIHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZyApeyAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgIG5vZGUudXBkYXRlU3R5bGUoIGZhbHNlICk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gc2V0dXAgc3R5bGVzXG5cbiAgdmFyIGJnQ29sb3IgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtY29sb3InICkudmFsdWU7XG4gIHZhciBib3JkZXJDb2xvciA9IG5vZGUucHN0eWxlKCAnYm9yZGVyLWNvbG9yJyApLnZhbHVlO1xuICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSggJ2JvcmRlci1zdHlsZScgKS52YWx1ZTtcblxuICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgYmdDb2xvclswXSwgYmdDb2xvclsxXSwgYmdDb2xvclsyXSwgbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLW9wYWNpdHknICkudmFsdWUgKiBwYXJlbnRPcGFjaXR5ICk7XG5cbiAgdGhpcy5zdHJva2VTdHlsZSggY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgbm9kZS5wc3R5bGUoICdib3JkZXItb3BhY2l0eScgKS52YWx1ZSAqIHBhcmVudE9wYWNpdHkgKTtcblxuICB2YXIgc2hhZG93Qmx1ciA9IG5vZGUucHN0eWxlKCAnc2hhZG93LWJsdXInICkucGZWYWx1ZTtcbiAgdmFyIHNoYWRvd09wYWNpdHkgPSBub2RlLnBzdHlsZSggJ3NoYWRvdy1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBub2RlLnBzdHlsZSggJ3NoYWRvdy1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBub2RlLnBzdHlsZSggJ3NoYWRvdy1vZmZzZXQteCcgKS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WSA9IG5vZGUucHN0eWxlKCAnc2hhZG93LW9mZnNldC15JyApLnBmVmFsdWU7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkgKTtcblxuICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBzd2l0Y2goIGJvcmRlclN0eWxlICl7XG4gICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIDEsIDEgXSApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyA0LCAyIF0gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgXSApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuXG4gIC8vXG4gIC8vIGRyYXcgc2hhcGVcblxuICB2YXIgc3R5bGVTaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnN0clZhbHVlO1xuICB2YXIgc2hhcGVQdHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS5wZlZhbHVlO1xuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzdHlsZVNoYXBlICsgJyQnICsgbm9kZVdpZHRoICsgJyQnICsgbm9kZUhlaWdodCArICggc3R5bGVTaGFwZSA9PT0gJ3BvbHlnb24nID8gJyQnICsgc2hhcGVQdHMuam9pbignJCcpIDogJycgKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKCBwb3MueCwgcG9zLnkgKTtcblxuICAgIGlmKCBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleSApe1xuICAgICAgcGF0aCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcblxuICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBucG9zID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIG5vZGUgKSBdLmRyYXcoXG4gICAgICAgICAgKCBwYXRoIHx8IGNvbnRleHQgKSxcbiAgICAgICAgICBucG9zLngsXG4gICAgICAgICAgbnBvcy55LFxuICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICBub2RlSGVpZ2h0ICk7XG4gIH1cblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIHRoaXMuc2hhZG93U3R5bGUoIGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDAgKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgLy9cbiAgLy8gYmcgaW1hZ2VcblxuICBpZiggdXJsICE9PSB1bmRlZmluZWQgKXtcbiAgICBpZiggaW1hZ2UuY29tcGxldGUgKXtcbiAgICAgIHRoaXMuZHJhd0luc2NyaWJlZEltYWdlKCBjb250ZXh0LCBpbWFnZSwgbm9kZSApO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIHBpZVxuXG4gIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1ibGFja2VuJyApLnZhbHVlO1xuICB2YXIgYm9yZGVyV2lkdGggPSBub2RlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlO1xuXG4gIGlmKCB0aGlzLmhhc1BpZSggbm9kZSApICl7XG4gICAgdGhpcy5kcmF3UGllKCBjb250ZXh0LCBub2RlLCBwYXJlbnRPcGFjaXR5ICk7XG5cbiAgICAvLyByZWRyYXcgcGF0aCBmb3IgYmxhY2tlbiBhbmQgYm9yZGVyXG4gICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgIGlmKCAhdXNlUGF0aHMgKXtcbiAgICAgICAgci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBwb3MueCxcbiAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgbm9kZUhlaWdodCApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIGRhcmtlbi9saWdodGVuXG5cbiAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCAwLCAwLCAwLCBkYXJrbmVzcyApO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgdGhpcy5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIC1kYXJrbmVzcyApO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gYm9yZGVyXG5cbiAgaWYoIGJvcmRlcldpZHRoID4gMCApe1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbm9kZS5wc3R5bGUoICdib3JkZXItd2lkdGgnICkucGZWYWx1ZSAvIDM7XG5cbiAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgfVxuXG4gIH1cblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXBvcy54LCAtcG9zLnkgKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgXSApO1xuICB9XG5cbiAgLy9cbiAgLy8gbGFiZWxcblxuICByLmRyYXdFbGVtZW50VGV4dCggY29udGV4dCwgbm9kZSwgZHJhd0xhYmVsICk7XG5cbiAgLy9cbiAgLy8gb3ZlcmxheVxuXG4gIHZhciBvdmVybGF5UGFkZGluZyA9IG5vZGUucHN0eWxlKCAnb3ZlcmxheS1wYWRkaW5nJyApLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IG5vZGUucHN0eWxlKCAnb3ZlcmxheS1vcGFjaXR5JyApLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gbm9kZS5wc3R5bGUoICdvdmVybGF5LWNvbG9yJyApLnZhbHVlO1xuXG4gIGlmKCBvdmVybGF5T3BhY2l0eSA+IDAgKXtcbiAgICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkgKTtcblxuICAgIHIubm9kZVNoYXBlc1sgJ3JvdW5kcmVjdGFuZ2xlJyBdLmRyYXcoXG4gICAgICBjb250ZXh0LFxuICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLFxuICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICk7XG5cbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYoIHNoaWZ0VG9PcmlnaW5XaXRoQmIgKXtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggYmIueDEsIGJiLnkxICk7XG4gIH1cblxufTtcblxuLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5DUnAuaGFzUGllID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcblxuQ1JwLmRyYXdQaWUgPSBmdW5jdGlvbiggY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHksIHBvcyApe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgcGllU2l6ZSA9IG5vZGUucHN0eWxlKCAncGllLXNpemUnICk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBvcyA9IHBvcyB8fCBfcC5wb3NpdGlvbjtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYoIHBpZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgcmFkaXVzID0gcGllU2l6ZS5wZlZhbHVlIC8gMjtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSggJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJyApLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJyApLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScgKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG5cbiAgICAvLyBwZXJjZW50IGNhbid0IHB1c2ggYmV5b25kIDFcbiAgICBpZiggcGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSApe1xuICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTtcblxuICAgIC8vIGlnbm9yZSBpZlxuICAgIC8vIC0gemVybyBzaXplXG4gICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgaWYoIHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKCB4LCB5ICk7XG4gICAgY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQgKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgdGhpcy5maWxsU3R5bGUoIGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkgKTtcblxuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG5cbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gIGlmKCB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCApe1xuICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gIH1cblxuICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufTtcblxuQ1JwLnBhaW50Q2FjaGUgPSBmdW5jdGlvbiggY29udGV4dCApe1xuICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gIHZhciBjYWNoZTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgIGNhY2hlID0gY2FjaGVzWyBpIF07XG5cbiAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBuZWVkVG9DcmVhdGVDYWNoZSApe1xuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgY2FjaGVzLnB1c2goIGNhY2hlICk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAuZmlsbFN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIHIsIGcsIGIsIGEgKXtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIHIsIGcsIGIsIGEgKXtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAuc2hhZG93U3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgY29sb3IsIG9wYWNpdHksIGJsdXIsIG9mZnNldFgsIG9mZnNldFkgKXtcbiAgdmFyIHpvb20gPSB0aGlzLmN5Lnpvb20oKTtcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoIGNvbnRleHQgKTtcbiAgLy9cbiAgLy8gLy8gZG9uJ3QgbWFrZSBleHBlbnNpdmUgY2hhbmdlcyB0byB0aGUgc2hhZG93IHN0eWxlIGlmIGl0J3Mgbm90IHVzZWRcbiAgLy8gaWYoIGNhY2hlLnNoYWRvd09wYWNpdHkgPT09IDAgJiYgb3BhY2l0eSA9PT0gMCApe1xuICAvLyAgIHJldHVybjtcbiAgLy8gfVxuICAvL1xuICAvLyBjYWNoZS5zaGFkb3dPcGFjaXR5ID0gb3BhY2l0eTtcblxuICBpZiggb3BhY2l0eSA+IDAgKXtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBibHVyICogem9vbTtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3JnYmEoJyArIGNvbG9yWzBdICsgJywnICsgY29sb3JbMV0gKyAnLCcgKyBjb2xvclsyXSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0WCAqIHpvb207XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0WSAqIHpvb207XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gIH1cbn07XG5cbi8vIFJlc2l6ZSBjYW52YXNcbkNScC5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiggY29udGFpbmVyICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICBpZihcbiAgICBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF0gfHxcbiAgICBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF1cbiAgKXtcbiAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICB9XG5cbiAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhcztcblxuICBpZiggY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCApe1xuICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICB9XG5cbiAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHIuQ0FOVkFTX0xBWUVSUzsgaSsrICl7XG5cbiAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzWyBpIF07XG5cbiAgICBpZiggY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQgKXtcblxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKysgKXtcblxuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXTtcblxuICAgIGlmKCBjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCApe1xuXG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIHIudGV4dHVyZU11bHQgPSAxO1xuICBpZiggcGl4ZWxSYXRpbyA8PSAxICl7XG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1sgci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG5cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcblxufTtcblxuQ1JwLnJlbmRlclRvID0gZnVuY3Rpb24oIGN4dCwgem9vbSwgcGFuLCBweFJhdGlvICl7XG4gIHRoaXMucmVuZGVyKCB7XG4gICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gIH0gKTtcbn07XG5cbkNScC5yZW5kZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICB2YXIgZm9yY2VkWm9vbSA9IG9wdGlvbnMuZm9yY2VkWm9vbTtcbiAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwaXhlbFJhdGlvID0gb3B0aW9ucy5mb3JjZWRQeFJhdGlvID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFBpeGVsUmF0aW8oKSA6IG9wdGlvbnMuZm9yY2VkUHhSYXRpbztcbiAgdmFyIGN5ID0gci5jeTsgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG4gIHZhciBtb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdGlvbkJsdXIgOiByLm1vdGlvbkJsdXI7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGluTm9kZURyYWdHZXN0dXJlID0gci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nID8gdHJ1ZSA6IGZhbHNlO1xuICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkICYmICFpbkJveFNlbGVjdGlvbjtcbiAgdmFyIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gbW90aW9uQmx1cjtcblxuICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICBpZiggci5wcmV2UHhSYXRpbyAhPT0gcGl4ZWxSYXRpbyApe1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKCByLmNvbnRhaW5lciApO1xuXG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgIH1cblxuICAgIHIucHJldlB4UmF0aW8gPSBwaXhlbFJhdGlvO1xuICB9XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQgKXtcbiAgICBjbGVhclRpbWVvdXQoIHIubW90aW9uQmx1clRpbWVvdXQgKTtcbiAgfVxuXG4gIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgaWYoIHIubWJGcmFtZXMgPT0gbnVsbCApe1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgfVxuXG4gICAgaWYoICFyLmRyYXdpbmdJbWFnZSApeyAvLyBpbWFnZSBsb2FkaW5nIGZyYW1lcyBkb24ndCBjb3VudCB0b3dhcmRzIG1vdGlvbiBibHVyIGJsdXJyeSBmcmFtZXNcbiAgICAgIHIubWJGcmFtZXMrKztcbiAgICB9XG5cbiAgICBpZiggci5tYkZyYW1lcyA8IDMgKXsgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG4gICAgaWYoIHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcyApe1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgIH1cbiAgfVxuXG4gIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuICBpZiggci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcgKXtcbiAgICBuZWVkRHJhd1sgci5OT0RFIF0gPSB0cnVlO1xuICAgIG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSA9IHRydWU7XG4gIH1cblxuICB2YXIgY29yZVN0eWxlID0gY3kuc3R5bGUoKS5fcHJpdmF0ZS5jb3JlU3R5bGU7XG5cbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICB4OiBwYW4ueCxcbiAgICB5OiBwYW4ueVxuICB9O1xuXG4gIHZhciB2cCA9IHtcbiAgICB6b29tOiB6b29tLFxuICAgIHBhbjoge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH1cbiAgfTtcbiAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7XG5cbiAgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcbiAgaWYoICF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgaWYoIGZvcmNlZFBhbiApe1xuICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgfVxuXG4gIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuXG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gIGZ1bmN0aW9uIG1iY2xlYXIoIGNvbnRleHQsIHgsIHksIHcsIGggKXtcbiAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgKTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KCB4LCB5LCB3LCBoICk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIGNsZWFyICl7XG4gICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgaWYoICFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF0pICl7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG5cbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cbiAgICBpZiggY2xlYXIgPT09ICdtb3Rpb25CbHVyJyApe1xuICAgICAgbWJjbGVhciggY29udGV4dCwgMCwgMCwgdywgaCApO1xuICAgIH0gZWxzZSBpZiggIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpICl7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCggMCwgMCwgdywgaCApO1xuICAgIH1cblxuICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGVQYW4ueCwgZVBhbi55ICk7XG4gICAgICBjb250ZXh0LnNjYWxlKCBlWm9vbSwgZVpvb20gKTtcbiAgICB9XG4gICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSApO1xuICAgIH1cbiAgICBpZiggZm9yY2VkWm9vbSApe1xuICAgICAgY29udGV4dC5zY2FsZSggZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSApO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gIH1cblxuICBpZiggdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcblxuICAgIHZhciBiYjtcblxuICAgIGlmKCAhci50ZXh0dXJlQ2FjaGUgKXtcbiAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG5cbiAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgY3h0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuICAgICAgY3h0LmNsZWFyUmVjdCggMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCApO1xuXG4gICAgICByLnJlbmRlcigge1xuICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgfSApO1xuXG4gICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgfTtcblxuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbIHIuRFJBRyBdID0gZmFsc2U7XG4gICAgbmVlZERyYXdbIHIuTk9ERSBdID0gZmFsc2U7XG5cbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdO1xuXG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuXG4gICAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICAgIG1iY2xlYXIoIGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InIF0udmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBjb3JlU3R5bGVbICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScgXS52YWx1ZTtcbiAgICByLmZpbGxTdHlsZSggY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcblxuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgZmFsc2UgKTtcblxuICAgIGNvbnRleHQuY2xlYXJSZWN0KCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8gKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggdGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvICk7XG5cbiAgfSBlbHNlIGlmKCByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICl7IC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKTtcbiAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuXG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuXG4gIG5lZWRNYkNsZWFyWyByLk5PREUgXSA9ICFuZWVkRHJhd1sgci5OT0RFIF0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5OT0RFIF0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmKCBuZWVkTWJDbGVhclsgci5OT0RFIF0gKXsgci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5OT0RFIF0gPSB0cnVlOyB9XG5cbiAgbmVlZE1iQ2xlYXJbIHIuRFJBRyBdID0gIW5lZWREcmF3WyByLkRSQUcgXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLkRSQUcgXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYoIG5lZWRNYkNsZWFyWyByLkRSQUcgXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLkRSQUcgXSA9IHRydWU7IH1cblxuICBpZiggbmVlZERyYXdbIHIuTk9ERSBdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIgfHwgbmVlZE1iQ2xlYXJbIHIuTk9ERSBdICl7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyWyByLk5PREUgXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSA6IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdICk7XG4gICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgY2xlYXIgKTtcblxuICAgIGlmKCBoaWRlRWRnZXMgKXtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKCBjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoIGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfVxuXG4gICAgaWYoIHIuZGVidWcgKXtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKCBjb250ZXh0LCBlbGVzLm5vbmRyYWcgKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgIG5lZWREcmF3WyByLk5PREUgXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3WyByLkRSQUcgXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyWyByLkRSQUcgXSkgKXtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbIHIuRFJBRyBdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdIDogZGF0YS5jb250ZXh0c1sgci5EUkFHIF0gKTtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCApO1xuXG4gICAgaWYoIGhpZGVFZGdlcyApe1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoIGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKCBjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuICAgIH1cblxuICAgIGlmKCByLmRlYnVnICl7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyggY29udGV4dCwgZWxlcy5kcmFnICk7XG4gICAgfVxuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyICl7XG4gICAgICBuZWVkRHJhd1sgci5EUkFHIF0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiggci5zaG93RnBzIHx8ICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSAmJiAhZHJhd0FsbExheWVycykpICl7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbIHIuU0VMRUNUX0JPWCBdO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCApO1xuXG4gICAgaWYoIHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nICkgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcgXS52YWx1ZSAvIHpvb207XG5cbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWNvbG9yJyBdLnZhbHVlWzBdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1jb2xvcicgXS52YWx1ZVsxXSArICcsJ1xuICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtY29sb3InIF0udmFsdWVbMl0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICByLnNlbGVjdGlvblsxXSxcbiAgICAgICAgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSxcbiAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSApO1xuXG4gICAgICBpZiggYm9yZGVyV2lkdGggPiAwICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnXG4gICAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicgXS52YWx1ZVswXSArICcsJ1xuICAgICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InIF0udmFsdWVbMV0gKyAnLCdcbiAgICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyBdLnZhbHVlWzJdICsgJywnXG4gICAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzFdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sXG4gICAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzBdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzFdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLWNvbG9yJyBdLnZhbHVlWzJdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnYWN0aXZlLWJnLW9wYWNpdHknIF0udmFsdWUgKyAnKSc7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyggcG9zLngsIHBvcy55LCBjb3JlU3R5bGVbICdhY3RpdmUtYmctc2l6ZScgXS5wZlZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkgKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmKCByLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyICl7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKCB0aW1lVG9SZW5kZXIgKTtcbiAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKCAxMDAwIC8gdGltZVRvUmVuZGVyICk7XG5cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjAgKTtcblxuICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KCAwLCAzMCwgMjUwLCAyMCApO1xuICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMzAsIDI1MCAqIE1hdGgubWluKCBmcHMgLyBtYXhGcHMsIDEgKSwgMjAgKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgIG5lZWREcmF3WyByLlNFTEVDVF9CT1ggXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuICBpZiggbW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEgKXtcbiAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbIHIuTk9ERSBdO1xuICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXTtcblxuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1sgci5EUkFHIF07XG4gICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24oIGN4dCwgdHh0LCBuZWVkQ2xlYXIgKXtcbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuICAgICAgaWYoIG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QgKXtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCggMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1iY2xlYXIoIGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHB4ciA9IG1iUHhSYXRpbztcblxuICAgICAgY3h0LmRyYXdJbWFnZShcbiAgICAgICAgdHh0LCAvLyBpbWdcbiAgICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgICAgMCwgMCwgLy8geCwgeVxuICAgICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiggbmVlZERyYXdbIHIuTk9ERSBdIHx8IG5lZWRNYkNsZWFyWyByLk5PREUgXSApe1xuICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyWyByLk5PREUgXSApO1xuICAgICAgbmVlZERyYXdbIHIuTk9ERSBdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIG5lZWREcmF3WyByLkRSQUcgXSB8fCBuZWVkTWJDbGVhclsgci5EUkFHIF0gKXtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKCBjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhclsgci5EUkFHIF0gKTtcbiAgICAgIG5lZWREcmF3WyByLkRSQUcgXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuXG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLk5PREUgXSA9IGZhbHNlO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1clsgci5EUkFHIF0gPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICByLm1iRnJhbWVzID0gMDtcblxuICAgICAgbmVlZERyYXdbIHIuTk9ERSBdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3WyByLkRSQUcgXSA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5ICk7XG4gIH1cblxuICByLmRyYXdpbmdJbWFnZSA9IGZhbHNlO1xuXG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICYmICFyLmluaXRyZW5kZXIgKXtcbiAgICByLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgIGN5LnRyaWdnZXIoICdpbml0cmVuZGVyJyApO1xuICB9XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgY3kudHJpZ2dlcigncmVuZGVyJyk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG5cbnZhciBDUnAgPSB7fTtcblxuLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5DUnAuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24oXG4gIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyApe1xuXG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIGNvbnRleHQubW92ZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSApO1xuXG4gIGZvciggdmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKyApe1xuICAgIGNvbnRleHQubGluZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbIGkgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzWyBpICogMiArIDFdICk7XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbkNScC5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24oXG4gIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKXtcblxuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG4gIGNvbnRleHQubW92ZVRvKCB4LCB5IC0gaGFsZkhlaWdodCApO1xuICAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcbiAgY29udGV4dC5hcmNUbyggeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyApO1xuICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICBjb250ZXh0LmFyY1RvKCB4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyApO1xuICAvLyBBcmMgZnJvbSBib3R0b20gdG8gbGVmdCBzaWRlXG4gIGNvbnRleHQuYXJjVG8oIHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMgKTtcbiAgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuICBjb250ZXh0LmFyY1RvKCB4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyApO1xuICAvLyBKb2luIGxpbmVcbiAgY29udGV4dC5saW5lVG8oIHgsIHkgLSBoYWxmSGVpZ2h0ICk7XG5cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxudmFyIHNpbjAgPSBNYXRoLnNpbiggMCApO1xudmFyIGNvczAgPSBNYXRoLmNvcyggMCApO1xuXG52YXIgc2luID0ge307XG52YXIgY29zID0ge307XG5cbnZhciBlbGxpcHNlU3RlcFNpemUgPSBNYXRoLlBJIC8gNDA7XG5cbmZvciggdmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApe1xuICBzaW5bIGkgXSA9IE1hdGguc2luKCBpICk7XG4gIGNvc1sgaSBdID0gTWF0aC5jb3MoIGkgKTtcbn1cblxuQ1JwLmRyYXdFbGxpcHNlUGF0aCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIGlmKCBjb250ZXh0LmVsbGlwc2UgKXtcbiAgICAgIGNvbnRleHQuZWxsaXBzZSggY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeFBvcywgeVBvcztcbiAgICAgIHZhciBydyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG4gICAgICBmb3IoIHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUgKXtcbiAgICAgICAgeFBvcyA9IGNlbnRlclggLSAocncgKiBzaW5bIGkgXSkgKiBzaW4wICsgKHJ3ICogY29zWyBpIF0pICogY29zMDtcbiAgICAgICAgeVBvcyA9IGNlbnRlclkgKyAocmggKiBjb3NbIGkgXSkgKiBzaW4wICsgKHJoICogc2luWyBpIF0pICogY29zMDtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKCB4UG9zLCB5UG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHhQb3MsIHlQb3MgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi8uLi9tYXRoJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBIZWFwID0gcmVxdWlyZSggJy4uLy4uLy4uL2hlYXAnICk7XG52YXIgZGVmcyA9IHJlcXVpcmUoICcuL3RleHR1cmUtY2FjaGUtZGVmcycgKTtcblxudmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG52YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG52YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcbnZhciBtYXhUeHJIID0gMTAyNDsgIC8vIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHRleHR1cmVcbnZhciBtaW5VdGlsaXR5ID0gMC41OyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG52YXIgbWF4RnVsbG5lc3MgPSAwLjg7IC8vIGZ1bGxuZXNzIG9mIHRleHR1cmUgYWZ0ZXIgd2hpY2ggcXVldWUgcmVtb3ZhbCBpcyBjaGVja2VkXG52YXIgbWF4RnVsbG5lc3NDaGVja3MgPSAxMDsgLy8gZGVxdWV1ZWQgYWZ0ZXIgdGhpcyBtYW55IGNoZWNrc1xudmFyIGFsbG93RWRnZVR4ckNhY2hpbmcgPSBmYWxzZTsgLy8gd2hldGhlciBlZGdlcyBjYW4gYmUgY2FjaGVkIGFzIHRleHR1cmVzIChUT0RPIG1heWJlIGJldHRlciBvbiBpZiB3ZWJnbCBzdXBwb3J0ZWQ/KVxudmFyIGFsbG93UGFyZW50VHhyQ2FjaGluZyA9IGZhbHNlOyAvLyB3aGV0aGVyIHBhcmVudCBub2RlcyBjYW4gYmUgY2FjaGVkIGFzIHRleHR1cmVzIChUT0RPIG1heWJlIGJldHRlciBvbiBpZiB3ZWJnbCBzdXBwb3J0ZWQ/KVxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gMTAwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgZ2V0VHhyUmVhc29ucyA9IHtcbiAgZGVxdWV1ZTogJ2RlcXVldWUnLFxuICBkb3duc2NhbGU6ICdkb3duc2NhbGUnLFxuICBoaWdoUXVhbGl0eTogJ2hpZ2hRdWFsaXR5J1xufTtcblxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiggcmVuZGVyZXIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgc2VsZi5vbkRlcXVldWVzID0gW107XG5cbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5cbkVUQ3AucmVhc29ucyA9IGdldFR4clJlYXNvbnM7XG5cbi8vIHRoZSBsaXN0IG9mIHRleHR1cmVzIGluIHdoaWNoIG5ldyBzdWJ0ZXh0dXJlcyBmb3IgZWxlbWVudHMgY2FuIGJlIHBsYWNlZFxuRVRDcC5nZXRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiggdHhySCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWxlSW1nQ2FjaGVzID0gc2VsZi5lbGVJbWdDYWNoZXMgfHwge307XG5cbiAgcmV0dXJuICggc2VsZi5lbGVJbWdDYWNoZXNbIHR4ckggXSA9IHNlbGYuZWxlSW1nQ2FjaGVzWyB0eHJIIF0gfHwgW10gKTtcbn07XG5cbi8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24oIHR4ckggKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBydHh0clFzID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgfHwge307XG4gIHZhciBydHh0clEgPSBydHh0clFzWyB0eHJIIF0gPSBydHh0clFzWyB0eHJIIF0gfHwgW107XG5cbiAgcmV0dXJuIHJ0eHRyUTtcbn07XG5cbi8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcChmdW5jdGlvbiggYSwgYiApe1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH0pO1xuXG4gIHJldHVybiBxO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHMgKGVsZW1lbnQgaWQgbG9va3VwKVxuRVRDcC5nZXRFbGVtZW50SWRUb1F1ZXVlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBpZDJxID0gc2VsZi5lbGVJZFRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlSWRUb0NhY2hlUXVldWUgfHwge307XG5cbiAgcmV0dXJuIGlkMnE7XG59O1xuXG5FVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiggZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24gKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcblxuICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IHJldHVybiBudWxsOyB9XG5cbiAgaWYoIGx2bCA9PSBudWxsICl7XG4gICAgbHZsID0gTWF0aC5jZWlsKCBtYXRoLmxvZzIoIHpvb20gKiBweFJhdGlvICkgKTtcbiAgfVxuXG4gIGlmKCBsdmwgPCBtaW5MdmwgKXtcbiAgICBsdmwgPSBtaW5Mdmw7XG4gIH0gZWxzZSBpZiggem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCApe1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gIHZhciBjYWNoZXMgPSBycy5pbWdDYWNoZXMgPSBycy5pbWdDYWNoZXMgfHwge307XG4gIHZhciBlbGVDYWNoZSA9IGNhY2hlc1tsdmxdO1xuXG4gIGlmKCBlbGVDYWNoZSApe1xuICAgIHJldHVybiBlbGVDYWNoZTtcbiAgfVxuXG4gIHZhciB0eHJIOyAvLyB3aGljaCB0ZXh0dXJlIGhlaWdodCB0aGlzIGVsZSBiZWxvbmdzIHRvXG5cbiAgaWYoIGVsZVNjYWxlZEggPD0gbWluVHhySCApe1xuICAgIHR4ckggPSBtaW5UeHJIO1xuICB9IGVsc2UgaWYoIGVsZVNjYWxlZEggPD0gdHhyU3RlcEggKXtcbiAgICB0eHJIID0gdHhyU3RlcEg7XG4gIH0gZWxzZSB7XG4gICAgdHhySCA9IE1hdGguY2VpbCggZWxlU2NhbGVkSCAvIHR4clN0ZXBIICkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmKFxuICAgIGVsZVNjYWxlZEggPiBtYXhUeHJIXG4gICAgfHwgZWxlU2NhbGVkVyA+IG1heFR4cldcbiAgICB8fCAoICFhbGxvd0VkZ2VUeHJDYWNoaW5nICYmIGVsZS5pc0VkZ2UoKSApXG4gICAgfHwgKCAhYWxsb3dQYXJlbnRUeHJDYWNoaW5nICYmIGVsZS5pc1BhcmVudCgpIClcbiAgKXtcbiAgICByZXR1cm4gbnVsbDsgLy8gY2FjaGluZyBsYXJnZSBlbGVtZW50cyBpcyBub3QgZWZmaWNpZW50XG4gIH1cblxuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuICB2YXIgdHhyID0gdHhyUVsgdHhyUS5sZW5ndGggLSAyIF07XG5cbiAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUoIHR4ckgsIGVsZVNjYWxlZFcgKSB8fCBzZWxmLmFkZFRleHR1cmUoIHR4ckgsIGVsZVNjYWxlZFcgKTtcbiAgfTtcblxuICAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuICBpZiggIXR4ciApe1xuICAgIHR4ciA9IHR4clFbIHR4clEubGVuZ3RoIC0gMSBdO1xuICB9XG5cbiAgLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcbiAgaWYoICF0eHIgKXtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUgY3VycmVudCB0ZXh0dXJlLCB3ZSBuZWVkIGEgbmV3IG9uZVxuICBpZiggdHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcgKXtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbiggZWxlLCBzY2FsZSApO1xuICB2YXIgc2NhbGFibGVGcm9tID0gZnVuY3Rpb24oIG90aGVyQ2FjaGUgKXtcbiAgICByZXR1cm4gb3RoZXJDYWNoZSAmJiBvdGhlckNhY2hlLnNjYWxlZExhYmVsU2hvd24gPT09IHNjYWxlZExhYmVsU2hvd247XG4gIH07XG5cbiAgdmFyIGRlcWluZyA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZGVxdWV1ZTtcbiAgdmFyIGhpZ2hRdWFsaXR5UmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5oaWdoUXVhbGl0eTtcbiAgdmFyIGRvd25zY2FsZVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZG93bnNjYWxlO1xuXG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuICBmb3IoIHZhciBsID0gbHZsICsgMTsgbCA8PSBtYXhMdmw7IGwrKyApe1xuICAgIHZhciBjID0gY2FjaGVzW2xdO1xuXG4gICAgaWYoIGMgKXsgaGlnaGVyQ2FjaGUgPSBjOyBicmVhazsgfVxuICB9XG5cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24oKXtcbiAgICB0eHIuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLFxuICAgICAgb25lVXBDYWNoZS54LCAwLFxuICAgICAgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsXG4gICAgICB0eHIudXNlZFdpZHRoLCAwLFxuICAgICAgZWxlU2NhbGVkVywgZWxlU2NhbGVkSFxuICAgICk7XG4gIH07XG5cbiAgaWYoIHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSApe1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcblxuICB9IGVsc2UgaWYoIHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkgKXtcbiAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcblxuICAgIGlmKCBoaWdoUXVhbGl0eVJlcSApe1xuICAgICAgZm9yKCB2YXIgbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBsID4gbHZsOyBsLS0gKXtcbiAgICAgICAgb25lVXBDYWNoZSA9IHNlbGYuZ2V0RWxlbWVudCggZWxlLCBiYiwgcHhSYXRpbywgbCwgZ2V0VHhyUmVhc29ucy5kb3duc2NhbGUgKTtcbiAgICAgIH1cblxuICAgICAgZG93bnNjYWxlKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoIGVsZSwgYmIsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSApO1xuXG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuICAgIGlmKCAhZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxICl7XG4gICAgICBmb3IoIHZhciBsID0gbHZsIC0gMTsgbCA+PSBtaW5Mdmw7IGwtLSApe1xuICAgICAgICB2YXIgYyA9IGNhY2hlc1tsXTtcblxuICAgICAgICBpZiggYyApeyBsb3dlckNhY2hlID0gYzsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpICl7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcblxuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoIGVsZSwgYmIsIGx2bCApO1xuXG4gICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICB9XG5cbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoIHR4ci51c2VkV2lkdGgsIDAgKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZSggc2NhbGUsIHNjYWxlICk7XG5cbiAgICByLmRyYXdFbGVtZW50KCB0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biApO1xuXG4gICAgdHhyLmNvbnRleHQuc2NhbGUoIDEvc2NhbGUsIDEvc2NhbGUgKTtcbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoIC10eHIudXNlZFdpZHRoLCAwICk7XG4gIH1cblxuICBlbGVDYWNoZSA9IGNhY2hlc1tsdmxdID0ge1xuICAgIGVsZTogZWxlLFxuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG5cbiAgdHhyLnVzZWRXaWR0aCArPSBNYXRoLmNlaWwoIGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nICk7XG5cbiAgdHhyLmVsZUNhY2hlcy5wdXNoKCBlbGVDYWNoZSApO1xuXG4gIHNlbGYuY2hlY2tUZXh0dXJlRnVsbG5lc3MoIHR4ciApO1xuXG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5cbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlcyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdDYWNoZXM7XG5cbiAgaWYoIGNhY2hlcyApe1xuICAgIGZvciggdmFyIGx2bCA9IG1pbkx2bDsgbHZsIDw9IG1heEx2bDsgbHZsKysgKXtcbiAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1sgbHZsIF07XG5cbiAgICAgIGlmKCBjYWNoZSApe1xuICAgICAgICB2YXIgdHhyID0gY2FjaGUudGV4dHVyZTtcblxuICAgICAgICAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG4gICAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoICs9IGNhY2hlLndpZHRoO1xuXG4gICAgICAgIC8vIHJlbW92ZSByZWZzIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgY2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgICAgIHV0aWwucmVtb3ZlRnJvbUFycmF5KCB0eHIuZWxlQ2FjaGVzLCBjYWNoZSApO1xuXG4gICAgICAgIC8vIG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoZSBlbnRpcmUgdGV4dHVyZSBpZiBpdCdzIG5vdCBlZmZpY2llbnRseSB1c2luZyBpdHMgc3BhY2VcbiAgICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KCB0eHIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uKCB0eHIgKXtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYoIHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGggKXtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUoIHR4ciApO1xuICB9XG59O1xuXG5FVENwLmNoZWNrVGV4dHVyZUZ1bGxuZXNzID0gZnVuY3Rpb24oIHR4ciApe1xuICAvLyBpZiB0ZXh0dXJlIGhhcyBiZWVuIG1vc3RseSBmaWxsZWQgYW5kIHBhc3NlZCBvdmVyIHNldmVyYWwgdGltZXMsIHJlbW92ZVxuICAvLyBpdCBmcm9tIHRoZSBxdWV1ZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlIHRpbWUgbG9va2luZyBhdCBpdCB0byBwdXQgbmV3IHRoaW5nc1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSggdHhyLmhlaWdodCApO1xuXG4gIGlmKCB0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzICl7XG4gICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHR4clEsIHR4ciApO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuXG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiggdHhyICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHR4clEsIHR4ciApO1xuXG4gIHR4ci5yZXRpcmVkID0gdHJ1ZTtcblxuICAvLyByZW1vdmUgdGhlIHJlZnMgZnJvbSB0aGUgZWxlcyB0byB0aGUgY2FjaGVzOlxuXG4gIHZhciBlbGVDYWNoZXMgPSB0eHIuZWxlQ2FjaGVzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlQ2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZUNhY2hlID0gZWxlQ2FjaGVzW2ldO1xuICAgIHZhciBlbGUgPSBlbGVDYWNoZS5lbGU7XG4gICAgdmFyIGx2bCA9IGVsZUNhY2hlLmxldmVsO1xuICAgIHZhciBpbWdDYWNoZXMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2guaW1nQ2FjaGVzO1xuXG4gICAgaWYoIGltZ0NhY2hlcyApe1xuICAgICAgaW1nQ2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdXRpbC5jbGVhckFycmF5KCBlbGVDYWNoZXMgKTtcblxuICAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSggdHhySCApO1xuXG4gIHJ0eHRyUS5wdXNoKCB0eHIgKTtcbn07XG5cbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uKCB0eHJILCBtaW5XICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSggdHhySCApO1xuICB2YXIgdHhyID0ge307XG5cbiAgdHhyUS5wdXNoKCB0eHIgKTtcblxuICB0eHIuZWxlQ2FjaGVzID0gW107XG5cbiAgdHhyLmhlaWdodCA9IHR4ckg7XG4gIHR4ci53aWR0aCA9IE1hdGgubWF4KCBkZWZUeHJXaWR0aCwgbWluVyApO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuXG4gIHR4ci5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB0eHIuY2FudmFzLndpZHRoID0gdHhyLndpZHRoO1xuICB0eHIuY2FudmFzLmhlaWdodCA9IHR4ci5oZWlnaHQ7XG5cbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgcmV0dXJuIHR4cjtcbn07XG5cbkVUQ3AucmVjeWNsZVRleHR1cmUgPSBmdW5jdGlvbiggdHhySCwgbWluVyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUoIHR4ckggKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSggdHhySCApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcblxuICAgIGlmKCB0eHIud2lkdGggPj0gbWluVyApe1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcblxuICAgICAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuXG4gICAgICB1dGlsLmNsZWFyQXJyYXkoIHR4ci5lbGVDYWNoZXMgKTtcblxuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB0eHIud2lkdGgsIHR4ci5oZWlnaHQgKTtcblxuICAgICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHJ0eHRyUSwgdHhyICk7XG4gICAgICB0eHJRLnB1c2goIHR4ciApO1xuXG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlLCBiYiwgbHZsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgaWQycSA9IHNlbGYuZ2V0RWxlbWVudElkVG9RdWV1ZSgpO1xuICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgdmFyIGV4aXN0aW5nUmVxID0gaWQycVsgaWQgXTtcblxuICBpZiggZXhpc3RpbmdSZXEgKXsgLy8gdXNlIHRoZSBtYXggbHZsIGIvYyBpbiBiZXR3ZWVuIGx2bHMgYXJlIGNoZWFwIHRvIG1ha2VcbiAgICBleGlzdGluZ1JlcS5sZXZlbCA9IE1hdGgubWF4KCBleGlzdGluZ1JlcS5sZXZlbCwgbHZsICk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKCBleGlzdGluZ1JlcSApO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSB7XG4gICAgICBlbGU6IGVsZSxcbiAgICAgIGJiOiBiYixcbiAgICAgIHBvc2l0aW9uOiBtYXRoLmNvcHlQb3NpdGlvbiggZWxlLnBvc2l0aW9uKCkgKSxcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICByZXFzOiAxXG4gICAgfTtcblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICAgIHJlcS5wb3NpdGlvbnMgPSB7XG4gICAgICAgIHNvdXJjZTogbWF0aC5jb3B5UG9zaXRpb24oIGVsZS5zb3VyY2UoKS5wb3NpdGlvbigpICksXG4gICAgICAgIHRhcmdldDogbWF0aC5jb3B5UG9zaXRpb24oIGVsZS50YXJnZXQoKS5wb3NpdGlvbigpIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcS5wdXNoKCByZXEgKTtcblxuICAgIGlkMnFbIGlkIF0gPSByZXE7XG4gIH1cbn07XG5cbkVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uKCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBpZDJxID0gc2VsZi5nZXRFbGVtZW50SWRUb1F1ZXVlKCk7XG4gIHZhciBkZXF1ZXVlZCA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZTsgaSsrICl7XG4gICAgaWYoIHEuc2l6ZSgpID4gMCApe1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG5cbiAgICAgIGlkMnFbIHJlcS5lbGUuaWQoKSBdID0gbnVsbDtcblxuICAgICAgZGVxdWV1ZWQucHVzaCggcmVxICk7XG5cbiAgICAgIHZhciBlbGUgPSByZXEuZWxlO1xuICAgICAgdmFyIGJiO1xuXG4gICAgICBpZihcbiAgICAgICAgKCBlbGUuaXNFZGdlKClcbiAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAhbWF0aC5hcmVQb3NpdGlvbnNTYW1lKCBlbGUuc291cmNlKCkucG9zaXRpb24oKSwgcmVxLnBvc2l0aW9ucy5zb3VyY2UgKVxuICAgICAgICAgICAgfHwgIW1hdGguYXJlUG9zaXRpb25zU2FtZSggZWxlLnRhcmdldCgpLnBvc2l0aW9uKCksIHJlcS5wb3NpdGlvbnMudGFyZ2V0IClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgfHwgKCAhbWF0aC5hcmVQb3NpdGlvbnNTYW1lKCBlbGUucG9zaXRpb24oKSwgcmVxLnBvc2l0aW9uICkgKVxuICAgICAgKXtcbiAgICAgICAgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJiID0gcmVxLmJiO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmdldEVsZW1lbnQoIHJlcS5lbGUsIGJiLCBweFJhdGlvLCByZXEubGV2ZWwsIGdldFR4clJlYXNvbnMuZGVxdWV1ZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxdWV1ZWQ7XG59O1xuXG5FVENwLm9uRGVxdWV1ZSA9IGZ1bmN0aW9uKCBmbiApeyB0aGlzLm9uRGVxdWV1ZXMucHVzaCggZm4gKTsgfTtcbkVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uKCBmbiApeyB1dGlsLnJlbW92ZUZyb21BcnJheSggdGhpcy5vbkRlcXVldWVzLCBmbiApOyB9O1xuXG5FVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQsXG4gIGRlcUNvc3Q6IGRlcUNvc3QsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCxcbiAgZGVxOiBmdW5jdGlvbiggc2VsZiwgcHhSYXRpbywgZXh0ZW50ICl7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZSggcHhSYXRpbywgZXh0ZW50ICk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24oIHNlbGYsIGRlcWQgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuXG4gICAgICBmbiggZGVxZCApO1xuICAgIH1cbiAgfSxcbiAgc2hvdWxkUmVkcmF3OiBmdW5jdGlvbiggc2VsZiwgZGVxZCwgcHhSYXRpbywgZXh0ZW50ICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXFkLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYmIgPSBkZXFkW2ldLmJiO1xuXG4gICAgICBpZiggbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBiYiwgZXh0ZW50ICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmlvcml0eTogZnVuY3Rpb24oIHNlbGYgKXtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZVR4ckRlcTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudFRleHR1cmVDYWNoZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiggdywgaCApe1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICBidWZmZXIud2lkdGggPSB3O1xuICBidWZmZXIuaGVpZ2h0ID0gaDtcblxuICByZXR1cm4gWyBidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCAnMmQnICkgXTtcbn07XG5cbkNScC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKCBiYi53ICkgOiBjdHJSZWN0WzJdO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKCBiYi5oICkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gaXMubnVtYmVyKCBvcHRpb25zLm1heFdpZHRoICkgfHwgaXMubnVtYmVyKCBvcHRpb25zLm1heEhlaWdodCApO1xuICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgc2NhbGUgPSAxO1xuXG4gIGlmKCBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgKXtcbiAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICB9IGVsc2UgaWYoIHNwZWNkTWF4RGltcyApe1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1heFdpZHRoICkgKXtcbiAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgIH1cblxuICAgIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWF4SGVpZ2h0ICkgKXtcbiAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBNYXRoLm1pbiggbWF4U2NhbGVXLCBtYXhTY2FsZUggKTtcblxuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuXG4gIGlmKCAhc3BlY2RNYXhEaW1zICl7XG4gICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICBzY2FsZSAqPSBweFJhdGlvO1xuICB9XG5cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgaWYoIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwICl7XG5cbiAgICBidWZmQ3h0LmNsZWFyUmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgaWYoIG9wdGlvbnMuYmcgKXtcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgaWYoIG9wdGlvbnMuZnVsbCApeyAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKCAtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUgKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoIHNjYWxlLCBzY2FsZSApO1xuXG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyggYnVmZkN4dCwgenNvcnRlZEVsZXMgKTtcbiAgICB9IGVsc2UgeyAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiBwYW4ueCAqIHNjYWxlLFxuICAgICAgICB5OiBwYW4ueSAqIHNjYWxlXG4gICAgICB9O1xuXG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG5cbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55ICk7XG4gICAgICBidWZmQ3h0LnNjYWxlKCBzY2FsZSwgc2NhbGUgKTtcblxuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoIGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZDYW52YXM7XG59O1xuXG5mdW5jdGlvbiBiNjRUb0Jsb2IoIGI2NCwgbWltZVR5cGUgKXtcbiAgdmFyIGJ5dGVzID0gYXRvYiggYjY0ICk7XG4gIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKCBieXRlcy5sZW5ndGggKTtcbiAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KCBidWZmICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKyApe1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoIFtidWZmXSwgeyB0eXBlOiBtaW1lVHlwZSB9ICk7XG59XG5cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KCBiNjR1cmkgKXtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuXG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKCBpICsgMSApO1xufTtcblxuZnVuY3Rpb24gb3V0cHV0KCBvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlICl7XG4gIHZhciBiNjRVcmkgPSBjYW52YXMudG9EYXRhVVJMKCBtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5ICk7XG5cbiAgc3dpdGNoKCBvcHRpb25zLm91dHB1dCApe1xuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYiggYjY0VXJpVG9CNjQoIGI2NFVyaSApLCBtaW1lVHlwZSApO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiNjRVcmlUb0I2NCggYjY0VXJpICk7XG5cbiAgICBjYXNlICdiYXNlNjR1cmknOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYjY0VXJpO1xuICB9XG59XG5cbkNScC5wbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICByZXR1cm4gb3V0cHV0KCBvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICksICdpbWFnZS9wbmcnICk7XG59O1xuXG5DUnAuanBnID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgcmV0dXJuIG91dHB1dCggb3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLCAnaW1hZ2UvanBlZycgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiLypcblRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IHJlcXVpcmUoJy4vZWxlLXRleHR1cmUtY2FjaGUnKTtcbnZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gcmVxdWlyZSgnLi9sYXllcmVkLXRleHR1cmUtY2FjaGUnKTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuXG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlciggb3B0aW9ucyApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5kYXRhID0ge1xuICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoIENScC5DQU5WQVNfTEFZRVJTICksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheSggQ1JwLkNBTlZBU19MQVlFUlMgKSxcbiAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KCBDUnAuQ0FOVkFTX0xBWUVSUyApLFxuXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheSggQ1JwLkJVRkZFUl9DT1VOVCApLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoIENScC5DQU5WQVNfTEFZRVJTICksXG4gIH07XG5cbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7JyApO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKCByLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG4gIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICggY29udGFpbmVyLmdldEF0dHJpYnV0ZSggJ3N0eWxlJyApIHx8ICcnICkgKyAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKysgKXtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzWyBpIF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuZGF0YS5jb250ZXh0c1sgaSBdID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCAnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOyBvdXRsaW5lLXN0eWxlOiBub25lOycgKyAoIGlzLm1zKCkgPyAnIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7IHRvdWNoLWFjdGlvbjogbm9uZTsgJyA6ICcnICkgKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoICdkYXRhLWlkJywgJ2xheWVyJyArIGkgKTtcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gU3RyaW5nKCBDUnAuQ0FOVkFTX0xBWUVSUyAtIGkgKTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKCBjYW52YXMgKTtcblxuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgaSBdID0gZmFsc2U7XG4gIH1cbiAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcblxuICByLmRhdGEuY2FudmFzZXNbIENScC5OT0RFIF0uc2V0QXR0cmlidXRlKCAnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuTk9ERSArICctbm9kZScgKTtcbiAgci5kYXRhLmNhbnZhc2VzWyBDUnAuU0VMRUNUX0JPWCBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcgKTtcbiAgci5kYXRhLmNhbnZhc2VzWyBDUnAuRFJBRyBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBDUnAuQlVGRkVSX0NPVU5UOyBpKysgKXtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzWyBpIF0gPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXS5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBpIF0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkgKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoIC1pIC0gMSApO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcblxuICByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZSggciApO1xuICByLmRhdGEubHlyVHhyQ2FjaGUgPSBuZXcgTGF5ZXJlZFRleHR1cmVDYWNoZSggciwgci5kYXRhLmVsZVR4ckNhY2hlICk7XG5cbiAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uIGludmFsaWRhdGVUZXh0dXJlQ2FjaGVzKCB3aWxsRHJhdywgZWxlcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuICAgICAgdmFyIGRlID0gcnMuZGlydHlFdmVudHM7XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgJiYgZGUgJiYgZGUubGVuZ3RoID09PSAxICYmIGRlWydwb3NpdGlvbiddICl7XG4gICAgICAgIC8vIHRoZW4ga2VlcCBjYWNoZWQgZWxlIHRleHR1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIuZGF0YS5lbGVUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgci5kYXRhLmx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyggZWxlcyApO1xuICAgIH1cbiAgfSk7XG59XG5cbkNScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24oIGdyb3VwLCBib29sICl7XG4gIHZhciByID0gdGhpcztcblxuICBzd2l0Y2goIGdyb3VwICl7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbIENScC5OT0RFIF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbIENScC5EUkFHIF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLlNFTEVDVF9CT1ggXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24oIG9uICl7XG4gIGlmKCBvbiA9PT0gdW5kZWZpbmVkICl7XG4gICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICB9XG5cbiAgdGhpcy5wYXRoc0VuYWJsZWQgPSBvbiA/IHRydWUgOiBmYWxzZTtcbn07XG5cbkNScC51c2VQYXRocyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xufTtcblxuW1xuICByZXF1aXJlKCAnLi9hcnJvdy1zaGFwZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctZWxlbWVudHMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctZWRnZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctaW1hZ2VzJyApLFxuICByZXF1aXJlKCAnLi9kcmF3aW5nLWxhYmVsLXRleHQnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctbm9kZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctcmVkcmF3JyApLFxuICByZXF1aXJlKCAnLi9kcmF3aW5nLXNoYXBlcycgKSxcbiAgcmVxdWlyZSggJy4vZXhwb3J0LWltYWdlJyApLFxuICByZXF1aXJlKCAnLi9ub2RlLXNoYXBlcycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIENScCwgcHJvcHMgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgSGVhcCA9IHJlcXVpcmUoICcuLi8uLi8uLi9oZWFwJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xudmFyIGRlZnMgPSByZXF1aXJlKCAnLi90ZXh0dXJlLWNhY2hlLWRlZnMnICk7XG5cbnZhciBkZWZOdW1MYXllcnMgPSAxOyAvLyBkZWZhdWx0IG51bWJlciBvZiBsYXllcnMgdG8gdXNlXG52YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSA1MDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcbnZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcbnZhciBkaXNhYmxlRWxlSW1nU21vb3RoaW5nID0gdHJ1ZTsgLy8gd2hlbiBkcmF3aW5nIGVsZXMgb24gbGF5ZXJzIGZyb20gYW4gZWxlIGNhY2hlIDsgY3Jpc3BlciBhbmQgbW9yZSBwZXJmb3JtYW50IHdoZW4gdHJ1ZVxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgbWF4RGVxU2l6ZSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG52YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xudmFyIG1heExheWVyQXJlYSA9IDQwMDAgKiA0MDAwOyAvLyBsYXllcnMgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhpc1xudmFyIGFsd2F5c1F1ZXVlID0gdHJ1ZTsgLy8gbmV2ZXIgZHJhdyBhbGwgdGhlIGxheWVycyBpbiBhIGxldmVsIG9uIGEgZnJhbWU7IGRyYXcgZGlyZWN0bHkgdW50aWwgYWxsIGRlcXVldWVkXG52YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuXG52YXIgdXNlRWxlVHhyQ2FjaGluZyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGluZGl2aWR1YWwgZWxlIHRleHR1cmUgY2FjaGluZyB1bmRlcm5lYXRoIHRoaXMgY2FjaGVcblxuLy8gdmFyIGxvZyA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTsgfTtcblxudmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiggcmVuZGVyZXIsIGVsZVR4ckNhY2hlICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICBzZWxmLmxheWVyc0J5TGV2ZWwgPSB7fTsgLy8gZS5nLiAyID0+IFsgbGF5ZXIxLCBsYXllcjIsIC4uLiwgbGF5ZXJOIF1cblxuICBzZWxmLmZpcnN0R2V0ID0gdHJ1ZTtcblxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpIC0gMippbnZhbGlkVGhyZXNob2xkO1xuXG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcblxuICByLmJlZm9yZVJlbmRlcihmdW5jdGlvbiggd2lsbERyYXcsIG5vdyApe1xuICAgIGlmKCBub3cgLSBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lIDw9IGludmFsaWRUaHJlc2hvbGQgKXtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcVNvcnQgPSBmdW5jdGlvbihhLCBiKXtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9O1xuXG4gIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgSGVhcCggcVNvcnQgKTtcblxuICBzZWxmLmVsZVR4ckNhY2hlID0gZWxlVHhyQ2FjaGU7XG5cbiAgc2VsZi5zZXR1cEVsZUNhY2hlSW52YWxpZGF0aW9uKCk7XG5cbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5cbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbkxUQ3AubWFrZUxheWVyID0gZnVuY3Rpb24oIGJiLCBsdmwgKXtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuXG4gIHZhciB3ID0gTWF0aC5jZWlsKCBiYi53ICogc2NhbGUgKTtcbiAgdmFyIGggPSBNYXRoLmNlaWwoIGJiLmggKiBzY2FsZSApO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuXG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogKGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQgKSxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07XG5cbiAgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7XG5cbiAgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG4gIGN4dC5zY2FsZSggc2NhbGUsIHNjYWxlICk7XG4gIGN4dC50cmFuc2xhdGUoIGR4LCBkeSApO1xuXG4gIHJldHVybiBsYXllcjtcbn07XG5cbkxUQ3AuZ2V0TGF5ZXJzID0gZnVuY3Rpb24oIGVsZXMsIHB4UmF0aW8sIGx2bCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBmaXJzdEdldCA9IHNlbGYuZmlyc3RHZXQ7XG5cbiAgc2VsZi5maXJzdEdldCA9IGZhbHNlO1xuXG4gIC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYoIGx2bCA9PSBudWxsICl7XG4gICAgbHZsID0gTWF0aC5jZWlsKCBtYXRoLmxvZzIoIHpvb20gKiBweFJhdGlvICkgKTtcblxuICAgIGlmKCBsdmwgPCBtaW5MdmwgKXtcbiAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICB9IGVsc2UgaWYoIHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcoIGx2bCwgZWxlcyApO1xuXG4gIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coIDIsIGx2bCApO1xuICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbIGx2bCBdID0gbGF5ZXJzQnlMdmxbIGx2bCBdIHx8IFtdO1xuICB2YXIgYmI7XG5cbiAgdmFyIGx2bENvbXBsZXRlID0gc2VsZi5sZXZlbElzQ29tcGxldGUoIGx2bCwgZWxlcyApO1xuICB2YXIgdG1wTGF5ZXJzO1xuXG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjYW5Vc2VBc1RtcEx2bCA9IGZ1bmN0aW9uKCBsICl7XG4gICAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKCBsLCBlbGVzICk7XG5cbiAgICAgIGlmKCBzZWxmLmxldmVsSXNDb21wbGV0ZSggbCwgZWxlcyApICl7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uKCBkaXIgKXtcbiAgICAgIGlmKCB0bXBMYXllcnMgKXsgcmV0dXJuOyB9XG5cbiAgICAgIGZvciggdmFyIGwgPSBsdmwgKyBkaXI7IG1pbkx2bCA8PSBsICYmIGwgPD0gbWF4THZsOyBsICs9IGRpciApe1xuICAgICAgICBpZiggY2FuVXNlQXNUbXBMdmwobCkgKXsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tMdmxzKCArMSApO1xuICAgIGNoZWNrTHZscyggLTEgKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgaW52YWxpZCBsYXllcnM7IHRoZXkgd2lsbCBiZSByZXBsYWNlZCBhcyBuZWVkZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvblxuICAgIGZvciggdmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgaWYoIGxheWVyLmludmFsaWQgKXtcbiAgICAgICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIGxheWVycywgbGF5ZXIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYoICFsdmxDb21wbGV0ZSApe1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuXG4gICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBsb2coJ2xldmVsIGNvbXBsZXRlLCB1c2luZyBleGlzdGluZyBsYXllcnNcXG4tLScpO1xuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICB2YXIgZ2V0QmIgPSBmdW5jdGlvbigpe1xuICAgIGlmKCAhYmIgKXtcbiAgICAgIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIG1hdGgudXBkYXRlQm91bmRpbmdCb3goIGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuXG4gICAgZ2V0QmIoKTtcblxuICAgIHZhciBhcmVhID0gKCBiYi53ICogc2NhbGUgKSAqICggYmIuaCAqIHNjYWxlICk7XG5cbiAgICBpZiggYXJlYSA+IG1heExheWVyQXJlYSApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoIGJiLCBsdmwgKTtcblxuICAgIGlmKCBhZnRlciAhPSBudWxsICl7XG4gICAgICB2YXIgaW5kZXggPSBsYXllcnMuaW5kZXhPZiggYWZ0ZXIgKSArIDE7XG5cbiAgICAgIGxheWVycy5zcGxpY2UoIGluZGV4LCAwLCBsYXllciApO1xuICAgIH0gZWxzZSBpZiggb3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCApe1xuICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICBsYXllcnMudW5zaGlmdCggbGF5ZXIgKTtcbiAgICB9XG5cbiAgICAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgICAvL3NlbGYucXVldWVMYXllciggbGF5ZXIgKTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH07XG5cbiAgaWYoIHNlbGYuc2tpcHBpbmcgJiYgIWZpcnN0R2V0ICl7XG4gICAgLy8gbG9nKCdza2lwIGxheWVycycpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbG9nKCdkbyBsYXllcnMnKTtcblxuICB2YXIgbGF5ZXIgPSBudWxsO1xuICB2YXIgbWF4RWxlc1BlckxheWVyID0gZWxlcy5sZW5ndGggLyBkZWZOdW1MYXllcnM7XG4gIHZhciBhbGxvd0xhenlRdWV1ZWluZyA9IGFsd2F5c1F1ZXVlICYmICFmaXJzdEdldDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbIGx2bCBdO1xuXG4gICAgaWYoIGV4aXN0aW5nTGF5ZXIgKXtcbiAgICAgIC8vIHJldXNlIGxheWVyIGZvciBsYXRlciBlbGVzXG4gICAgICAvLyBsb2coJ3JldXNlIGxheWVyIGZvcicsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gZXhpc3RpbmdMYXllcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKFxuICAgICAgIWxheWVyXG4gICAgICB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXJcbiAgICAgIHx8ICFtYXRoLmJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCggbGF5ZXIuYmIsIGVsZS5ib3VuZGluZ0JveCgpIClcbiAgICApe1xuICAgICAgLy8gbG9nKCdtYWtlIG5ldyBsYXllciBmb3IgZWxlICVzJywgZWxlLmlkKCkpO1xuXG4gICAgICBsYXllciA9IG1ha2VMYXllcih7IGluc2VydDogdHJ1ZSwgYWZ0ZXI6IGxheWVyIH0pO1xuXG4gICAgICAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG4gICAgICBpZiggIWxheWVyICl7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG4gICAgfVxuXG4gICAgaWYoIHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZyApe1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKCBsYXllciwgZWxlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllciggbGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvICk7XG4gICAgfVxuXG4gICAgbGF5ZXIuZWxlcy5wdXNoKCBlbGUgKTtcblxuICAgIGNhY2hlc1sgbHZsIF0gPSBsYXllcjtcbiAgfVxuXG4gIC8vIGxvZygnLS0nKTtcblxuICBpZiggdG1wTGF5ZXJzICl7IC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuXG4gIGlmKCBhbGxvd0xhenlRdWV1ZWluZyApe1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufTtcblxuLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiggbHZsLCBweFJhdGlvICl7XG4gIHJldHVybiBsdmw7XG59O1xuXG5mdW5jdGlvbiBpbWdTbW9vdGhpbmcoIGNvbnRleHQsIGJvb2wgKXtcbiAgaWYoIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwgKXtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufVxuXG5MVENwLmRyYXdFbGVJbkxheWVyID0gZnVuY3Rpb24oIGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIGNvbnRleHQgPSBsYXllci5jb250ZXh0O1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICBpZiggYmIudyA9PT0gMCB8fCBiYi5oID09PSAwICl7IHJldHVybjsgfVxuXG4gIHZhciBlbGVDYWNoZSA9IHNlbGYuZWxlVHhyQ2FjaGU7XG4gIHZhciByZWFzb24gPSB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPyBlbGVDYWNoZS5yZWFzb25zLmhpZ2hRdWFsaXR5IDogdW5kZWZpbmVkO1xuXG4gIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKCBsdmwsIHB4UmF0aW8gKTtcblxuICB2YXIgY2FjaGUgPSB1c2VFbGVUeHJDYWNoaW5nID8gZWxlQ2FjaGUuZ2V0RWxlbWVudCggZWxlLCBiYiwgbnVsbCwgbHZsLCByZWFzb24gKSA6IG51bGw7XG5cbiAgaWYoIGNhY2hlICl7XG4gICAgaWYoIGRpc2FibGVFbGVJbWdTbW9vdGhpbmcgKXsgaW1nU21vb3RoaW5nKCBjb250ZXh0LCBmYWxzZSApOyB9XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSggY2FjaGUudGV4dHVyZS5jYW52YXMsIGNhY2hlLngsIDAsIGNhY2hlLndpZHRoLCBjYWNoZS5oZWlnaHQsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCApO1xuXG4gICAgaWYoIGRpc2FibGVFbGVJbWdTbW9vdGhpbmcgKXsgaW1nU21vb3RoaW5nKCBjb250ZXh0LCB0cnVlICk7IH1cbiAgfSBlbHNlIHsgLy8gaWYgdGhlIGVsZW1lbnQgaXMgbm90IGNhY2hlYWJsZSwgdGhlbiBkcmF3IGRpcmVjdGx5XG4gICAgci5kcmF3RWxlbWVudCggY29udGV4dCwgZWxlICk7XG4gIH1cbn07XG5cbkxUQ3AubGV2ZWxJc0NvbXBsZXRlID0gZnVuY3Rpb24oIGx2bCwgZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbIGx2bCBdO1xuXG4gIGlmKCAhbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmKCBsYXllci5yZXFzID4gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBpcyBpbnZhbGlkLCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYoIGxheWVyLmludmFsaWQgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcbiAgaWYoIG51bUVsZXNJbkxheWVycyAhPT0gZWxlcy5sZW5ndGggKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24oIGx2bCwgZWxlcyApe1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsWyBsdmwgXTtcblxuICBpZiggIWxheWVycyApeyByZXR1cm47IH1cblxuICAvLyBpZiBpbiBhIGxheWVyIHRoZSBlbGVzIGFyZSBub3QgaW4gdGhlIHNhbWUgb3JkZXIsIHRoZW4gdGhlIGxheWVyIGlzIGludmFsaWRcbiAgLy8gKGkuZS4gdGhlcmUgaXMgYW4gZWxlIGluIGJldHdlZW4gdGhlIGVsZXMgaW4gdGhlIGxheWVyKVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcblxuICAgIC8vIGZpbmQgdGhlIG9mZnNldFxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgaWYoIGxheWVyLmVsZXNbMF0gPT09IGVsZXNbal0gKXtcbiAgICAgICAgb2Zmc2V0ID0gajtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIG9mZnNldCA8IDAgKXtcbiAgICAgIC8vIHRoZW4gdGhlIGxheWVyIGhhcyBub25leGlzdGFudCBlbGVtZW50cyBhbmQgaXMgaW52YWxpZFxuICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgaWYoIGxheWVyLmVsZXNbal0gIT09IGVsZXNbbytqXSApe1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTFRDcC51cGRhdGVFbGVtZW50c0luTGF5ZXJzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpc0VsZXMgPSBpcy5lbGVtZW50KCBlbGVzWzBdICk7XG5cbiAgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBmb3IoIHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrICl7XG4gICAgICB2YXIgbGF5ZXIgPSBjYWNoZXNbbF07XG5cbiAgICAgIGlmKCAhbGF5ZXIgKXsgY29udGludWU7IH1cblxuICAgICAgLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgIGlmKCByZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwoIGxheWVyLmxldmVsICkgIT09IHJlcS5sZXZlbCApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCBsYXllciwgZWxlLCByZXEgKTtcbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AuaGF2ZUxheWVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcblxuICBmb3IoIHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrICl7XG4gICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsXTtcblxuICAgIGlmKCBsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCA+IDAgKXtcbiAgICAgIGhhdmVMYXllcnMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhdmVMYXllcnM7XG59O1xuXG5MVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICBpZiggZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpICl7IHJldHVybjsgfVxuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyggZWxlcywgZnVuY3Rpb24gaW52YWxBc3NvY0xheWVycyggbGF5ZXIsIGVsZSwgcmVxICl7XG4gICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIoIGxheWVyICk7XG4gIH0gKTtcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24oIGxheWVyICl7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuXG4gIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYoIGxheWVyLmludmFsaWQgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzXG5cbiAgdmFyIGx2bCA9IGxheWVyLmxldmVsO1xuICB2YXIgZWxlcyA9IGxheWVyLmVsZXM7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbIGx2bCBdO1xuXG4gICAvLyBsb2coJ2ludmFsaWRhdGUgbGF5ZXInLCBsYXllci5pZCApO1xuXG4gIHV0aWwucmVtb3ZlRnJvbUFycmF5KCBsYXllcnMsIGxheWVyICk7XG4gIC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcblxuICBsYXllci5pbnZhbGlkID0gdHJ1ZTtcblxuICBpZiggbGF5ZXIucmVwbGFjZW1lbnQgKXtcbiAgICBsYXllci5yZXBsYWNlbWVudC5pbnZhbGlkID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuXG4gICAgaWYoIGNhY2hlcyApe1xuICAgICAgY2FjaGVzWyBsdmwgXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoIGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUoIGxheWVyLCBlbGUsIHJlcSApe1xuICAgIHZhciByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQ7XG5cbiAgICBpZiggIXJMeXIgKXtcbiAgICAgIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudCA9IHNlbGYubWFrZUxheWVyKCBsYXllci5iYiwgbGF5ZXIubGV2ZWwgKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7XG5cbiAgICAgICAvLyBsb2coJ21ha2UgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgZm9yICVzIHdpdGggbGV2ZWwgJXMnLCByTHlyLmlkLCBsYXllci5pZCwgckx5ci5sZXZlbCk7XG4gICAgfVxuXG4gICAgaWYoICFyTHlyLnJlcXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgckx5ci5lbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHNlbGYucXVldWVMYXllciggckx5ciwgckx5ci5lbGVzW2ldICk7XG4gICAgICB9XG5cbiAgICAgICAvLyBsb2coJ3F1ZXVlIHJlcGxhY2VtZW50IGxheWVyIHJlZmluZW1lbnQnLCByTHlyLmlkKTtcbiAgICB9XG4gIH0gKTtcbn07XG5cbkxUQ3Auc2V0dXBFbGVDYWNoZUludmFsaWRhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZURlcXMgPSBbXTtcblxuICBpZiggIXVzZUVsZVR4ckNhY2hpbmcgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHVwZGF0ZWRFbGVzSW5MYXllcnMgPSB1dGlsLmRlYm91bmNlKCBmdW5jdGlvbigpe1xuICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKCBlbGVEZXFzICk7XG5cbiAgICBlbGVEZXFzID0gW107XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSApO1xuXG4gIHNlbGYuZWxlVHhyQ2FjaGUub25EZXF1ZXVlKGZ1bmN0aW9uKCByZXFzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrICl7XG4gICAgICBlbGVEZXFzLnB1c2goIHJlcXNbaV0gKTtcbiAgICB9XG5cbiAgICB1cGRhdGVkRWxlc0luTGF5ZXJzKCk7XG4gIH0pO1xufTtcblxuTFRDcC5xdWV1ZUxheWVyID0gZnVuY3Rpb24oIGxheWVyLCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBlbGVzUSA9IGxheWVyLmVsZXNRdWV1ZTtcbiAgdmFyIGhhc0lkID0gZWxlc1EuaGFzSWQgPSBlbGVzUS5oYXNJZCB8fCB7fTtcblxuICAvLyBpZiBhIGxheWVyIGlzIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBxdWV1aW5nIGlzIGEgd2FzdGUgb2YgdGltZVxuICBpZiggbGF5ZXIucmVwbGFjZW1lbnQgKXsgcmV0dXJuOyB9XG5cbiAgaWYoIGVsZSApe1xuICAgIGlmKCBoYXNJZFsgZWxlLmlkKCkgXSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZXNRLnB1c2goIGVsZSApO1xuICAgIGhhc0lkWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmKCBsYXllci5yZXFzICl7XG4gICAgbGF5ZXIucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKCBsYXllciApO1xuICB9IGVsc2Uge1xuICAgIGxheWVyLnJlcXMgPSAxO1xuXG4gICAgcS5wdXNoKCBsYXllciApO1xuICB9XG59O1xuXG5MVENwLmRlcXVldWUgPSBmdW5jdGlvbiggcHhSYXRpbyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGRlcWQgPSBbXTtcbiAgdmFyIGVsZURlcXMgPSAwO1xuXG4gIHdoaWxlKCBlbGVEZXFzIDwgbWF4RGVxU2l6ZSApe1xuICAgIGlmKCBxLnNpemUoKSA9PT0gMCApeyBicmVhazsgfVxuXG4gICAgdmFyIGxheWVyID0gcS5wZWVrKCk7XG5cbiAgICAvLyBpZiBhIGxheWVyIGhhcyBiZWVuIG9yIHdpbGwgYmUgcmVwbGFjZWQsIHRoZW4gZG9uJ3Qgd2FzdGUgdGltZSB3aXRoIGl0XG4gICAgaWYoIGxheWVyLnJlcGxhY2VtZW50ICl7XG4gICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG4gICAgaWYoIGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCApe1xuICAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKCBsYXllci5pbnZhbGlkICl7XG4gICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciAlcyBpcyBpbnZhbGlkOyBkZXF1ZXVlZCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKCBsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyApO1xuXG4gICAgICBlbGVEZXFzKys7XG4gICAgfVxuXG4gICAgaWYoIGRlcWQubGVuZ3RoID09PSAwICl7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKCB0cnVlICk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcbiAgICBpZiggbGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCApe1xuICAgICAgcS5wb3AoKTtcblxuICAgICAgbGF5ZXIucmVxcyA9IDA7XG5cbiAgICAgICAvLyBsb2coJ2RlcXVldWUgb2YgbGF5ZXIgJXMgY29tcGxldGUnLCBsYXllci5pZCk7XG5cbiAgICAgIC8vIHdoZW4gYSByZXBsYWNlbWVudCBsYXllciBpcyBkZXF1ZXVlZCwgaXQgcmVwbGFjZXMgdGhlIG9sZCBsYXllciBpbiB0aGUgbGV2ZWxcbiAgICAgIGlmKCBsYXllci5yZXBsYWNlcyApe1xuICAgICAgICBzZWxmLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCggbGF5ZXIgKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcWQ7XG59O1xuXG5MVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uKCBsYXllciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsWyBsYXllci5sZXZlbCBdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKCByZXBsYWNlZCApO1xuXG4gIC8vIGlmIHRoZSByZXBsYWNlZCBsYXllciBpcyBub3QgaW4gdGhlIGFjdGl2ZSBsaXN0IGZvciB0aGUgbGV2ZWwsIHRoZW4gcmVwbGFjaW5nXG4gIC8vIHJlZnMgd291bGQgYmUgYSBtaXN0YWtlIChpLmUuIG92ZXJ3cml0aW5nIHRoZSB0cnVlIGFjdGl2ZSBsYXllcilcbiAgaWYoIGluZGV4IDwgMCB8fCByZXBsYWNlZC5pbnZhbGlkICl7XG4gICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGF5ZXJzSW5MZXZlbFsgaW5kZXggXSA9IGxheWVyOyAvLyByZXBsYWNlIGxldmVsIHJlZlxuXG4gIC8vIHJlcGxhY2UgcmVmcyBpbiBlbGVzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBfcCA9IGxheWVyLmVsZXNbaV0uX3ByaXZhdGU7XG4gICAgdmFyIGNhY2hlID0gX3AuaW1nTGF5ZXJDYWNoZXMgPSBfcC5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGlmKCBjYWNoZSApe1xuICAgICAgY2FjaGVbIGxheWVyLmxldmVsIF0gPSBsYXllcjtcbiAgICB9XG4gIH1cblxuICAgLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbn07XG5cbkxUQ3AucmVxdWVzdFJlZHJhdyA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcblxuICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuICByLnJlZHJhdygpO1xufSwgMTAwICk7XG5cbkxUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uKCBzZWxmLCBweFJhdGlvICl7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZSggcHhSYXRpbyApO1xuICB9LFxuICBvbkRlcWQ6IHV0aWwubm9vcCxcbiAgc2hvdWxkUmVkcmF3OiB1dGlsLnRydWVpZnksXG4gIHByaW9yaXR5OiBmdW5jdGlvbiggc2VsZiApe1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXllcmVkVGV4dHVyZUNhY2hlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24oIG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyApe1xuICBzd2l0Y2goIG5hbWUgKXtcbiAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKTtcbiAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgZnVsbEZwc1RpbWUgPSAxMDAwLzYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24oIG9wdHMgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICBpZiggc2VsZi5kZXF1ZXVlaW5nU2V0dXAgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5kZXF1ZXVlaW5nU2V0dXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVldWVSZWRyYXcgPSB1dGlsLmRlYm91bmNlKCBmdW5jdGlvbigpe1xuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCApO1xuXG4gICAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uKCB3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUgKXtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIHdoaWxlKCB0cnVlICl7XG4gICAgICAgICAgdmFyIG5vdyA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBub3cgLSBmcmFtZVN0YXJ0VGltZTtcblxuICAgICAgICAgIGlmKCByZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUgKXtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG5cbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAoIHdpbGxEcmF3ID8gYXZnUmVuZGVyVGltZSA6IDAgKTtcblxuICAgICAgICAgICAgaWYoIGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUgKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCB3aWxsRHJhdyApe1xuICAgICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA+PSBvcHRzLmRlcUNvc3QgKiByZW5kZXJUaW1lXG4gICAgICAgICAgICAgICAgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZVxuICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUgKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoIHNlbGYsIHBpeGVsUmF0aW8sIGV4dGVudCApO1xuXG4gICAgICAgICAgaWYoIHRoaXNEZXFkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgZGVxZC5wdXNoKCB0aGlzRGVxZFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuICAgICAgICBpZiggZGVxZC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgb3B0cy5vbkRlcWQoIHNlbGYsIGRlcWQgKTtcblxuICAgICAgICAgIGlmKCAhd2lsbERyYXcgJiYgb3B0cy5zaG91bGRSZWRyYXcoIHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCApICl7XG4gICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCB1dGlsLm5vb3A7XG5cbiAgICAgIHIuYmVmb3JlUmVuZGVyKCBkZXF1ZXVlLCBwcmlvcml0eSggc2VsZiApICk7XG4gICAgfTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgbmFtZTogJ251bGwnLCBpbXBsOiByZXF1aXJlKCAnLi9udWxsJyApIH0sXG4gIHsgbmFtZTogJ2Jhc2UnLCBpbXBsOiByZXF1aXJlKCAnLi9iYXNlJyApIH0sXG4gIHsgbmFtZTogJ2NhbnZhcycsIGltcGw6IHJlcXVpcmUoICcuL2NhbnZhcycgKSB9XG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBOdWxsUmVuZGVyZXIoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbigpe307XG5cbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgbm90aWZ5OiBmdW5jdGlvbigpeyB0aGlzLm5vdGlmaWNhdGlvbnMrKzsgfSxcbiAgaW5pdDogbm9vcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsUmVuZGVyZXI7XG4iLCIvKiEgV2VhdmVyIGxpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2UpLCBjb3B5cmlnaHQgTWF4IEZyYW56ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBUaHJlYWQgPSByZXF1aXJlKCcuL3RocmVhZCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCcuL2RlZmluZScpO1xuXG52YXIgRmFicmljID0gZnVuY3Rpb24oIE4gKXtcbiAgaWYoICEodGhpcyBpbnN0YW5jZW9mIEZhYnJpYykgKXtcbiAgICByZXR1cm4gbmV3IEZhYnJpYyggTiApO1xuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBwYXNzOiBbXVxuICB9O1xuXG4gIHZhciBkZWZOID0gNDtcblxuICBpZiggaXMubnVtYmVyKE4pICl7XG4gICAgLy8gdGhlbiB1c2UgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGhyZWFkc1xuICB9IGlmKCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAhPSBudWxsICl7XG4gICAgTiA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICB9IGVsc2Uge1xuICAgIHRyeXtcbiAgICAgIE4gPSByZXF1aXJlKCdvcycpLmNwdXMoKS5sZW5ndGg7XG4gICAgfSBjYXRjaCggZXJyICl7XG4gICAgICBOID0gZGVmTjtcbiAgICB9XG4gIH0gLy8gVE9ETyBjb3VsZCB1c2UgYW4gZXN0aW1hdGlvbiBoZXJlIGJ1dCB3b3VsZCB0aGUgYWRkaXRpb25hbCBleHBlbnNlIGJlIHdvcnRoIGl0P1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgTjsgaSsrICl7XG4gICAgdGhpc1tpXSA9IG5ldyBUaHJlYWQoKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTjtcbn07XG5cbnZhciBmYWJmbiA9IEZhYnJpYy5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbnV0aWwuZXh0ZW5kKGZhYmZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAnZmFicmljJzsgfSxcblxuICAvLyByZXF1aXJlIGZuIGluIGFsbCB0aHJlYWRzXG4gIHJlcXVpcmU6IGZ1bmN0aW9uKCBmbiwgYXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICB0aHJlYWQucmVxdWlyZSggZm4sIGFzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gZ2V0IGEgcmFuZG9tIHRocmVhZFxuICByYW5kb206IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkgPSBNYXRoLnJvdW5kKCAodGhpcy5sZW5ndGggLSAxKSAqIE1hdGgucmFuZG9tKCkgKTtcbiAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgIHJldHVybiB0aHJlYWQ7XG4gIH0sXG5cbiAgLy8gcnVuIG9uIHJhbmRvbSB0aHJlYWRcbiAgcnVuOiBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgcmV0dXJuIHRoaXMucmFuZG9tKCkucGFzcyggcGFzcyApLnJ1biggZm4gKTtcbiAgfSxcblxuICAvLyBzZW5kcyBhIHJhbmRvbSB0aHJlYWQgYSBtZXNzYWdlXG4gIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgcmV0dXJuIHRoaXMucmFuZG9tKCkubWVzc2FnZSggbSApO1xuICB9LFxuXG4gIC8vIHNlbmQgYWxsIHRocmVhZHMgYSBtZXNzYWdlXG4gIGJyb2FkY2FzdDogZnVuY3Rpb24oIG0gKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICB0aHJlYWQubWVzc2FnZSggbSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIHN0b3AgYWxsIHRocmVhZHNcbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICB0aHJlYWQuc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIHBhc3MgZGF0YSB0byBiZSB1c2VkIHdpdGggLnNwcmVhZCgpIGV0Yy5cbiAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcztcblxuICAgIGlmKCBpcy5hcnJheShkYXRhKSApe1xuICAgICAgcGFzcy5wdXNoKCBkYXRhICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdPbmx5IGFycmF5cyBtYXkgYmUgdXNlZCB3aXRoIGZhYnJpYy5wYXNzKCknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNwcmVhZFNpemU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHN1YnNpemUgPSAgTWF0aC5jZWlsKCB0aGlzLl9wcml2YXRlLnBhc3NbMF0ubGVuZ3RoIC8gdGhpcy5sZW5ndGggKTtcblxuICAgIHN1YnNpemUgPSBNYXRoLm1heCggMSwgc3Vic2l6ZSApOyAvLyBkb24ndCBwYXNzIGxlc3MgdGhhbiBvbmUgZWxlIHRvIGVhY2ggdGhyZWFkXG5cbiAgICByZXR1cm4gc3Vic2l6ZTtcbiAgfSxcblxuICAvLyBzcGxpdCB0aGUgZGF0YSBpbnRvIHNsaWNlcyB0byBzcHJlYWQgdGhlIGRhdGEgZXF1YWxseSBhbW9uZyB0aHJlYWRzXG4gIHNwcmVhZDogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gICAgdmFyIHN1YnNpemUgPSBzZWxmLnNwcmVhZFNpemUoKTsgLy8gbnVtYmVyIG9mIHBhc3MgZWxlcyB0byBoYW5kbGUgaW4gZWFjaCB0aHJlYWRcbiAgICB2YXIgcGFzcyA9IF9wLnBhc3Muc2hpZnQoKS5jb25jYXQoW10pOyAvLyBrZWVwIGEgY29weVxuICAgIHZhciBydW5QcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcbiAgICAgIHZhciBzbGljZSA9IHBhc3Muc3BsaWNlKCAwLCBzdWJzaXplICk7XG5cbiAgICAgIHZhciBydW5QID0gdGhyZWFkLnBhc3MoIHNsaWNlICkucnVuKCBmbiApO1xuXG4gICAgICBydW5Qcy5wdXNoKCBydW5QICk7XG5cbiAgICAgIHZhciBkb25lRWFybHkgPSBwYXNzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmKCBkb25lRWFybHkgKXsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoIHJ1blBzICkudGhlbihmdW5jdGlvbiggdGhlbnMgKXtcbiAgICAgIHZhciBwb3N0cGFzcyA9IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuXG4gICAgICAvLyBmaWxsIHBvc3RwYXNzIHdpdGggdGhlIHRvdGFsIHJlc3VsdCBqb2luZWQgZnJvbSBhbGwgdGhyZWFkc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGVucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdGhlbiA9IHRoZW5zW2ldOyAvLyBhcnJheSByZXN1bHQgZnJvbSB0aHJlYWQgaVxuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgdGhlbi5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciB0ID0gdGhlbltqXTsgLy8gYXJyYXkgZWxlbWVudFxuXG4gICAgICAgICAgcG9zdHBhc3NbIHArKyBdID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zdHBhc3M7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gcGFyYWxsZWwgdmVyc2lvbiBvZiBhcnJheS5tYXAoKVxuICBtYXA6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYucmVxdWlyZSggZm4sICdfJF8kX2ZhYm1hcCcgKTtcblxuICAgIHJldHVybiBzZWxmLnNwcmVhZChmdW5jdGlvbiggc3BsaXQgKXtcbiAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgIHZhciBvcmlnUmVzb2x2ZSA9IHJlc29sdmU7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICByZXNvbHZlID0gZnVuY3Rpb24oIHZhbCApeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgbWFwcGVkLnB1c2goIHZhbCApO1xuICAgICAgfTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb2xkTGVuID0gbWFwcGVkLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IF8kXyRfZmFibWFwKCBzcGxpdFtpXSApOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgdmFyIG5vdGhpbmdJbnNkQnlSZXNvbHZlID0gb2xkTGVuID09PSBtYXBwZWQubGVuZ3RoO1xuXG4gICAgICAgIGlmKCBub3RoaW5nSW5zZEJ5UmVzb2x2ZSApe1xuICAgICAgICAgIG1hcHBlZC5wdXNoKCByZXQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgLy8gcGFyYWxsZWwgdmVyc2lvbiBvZiBhcnJheS5maWx0ZXIoKVxuICBmaWx0ZXI6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHBhc3MgPSBfcC5wYXNzWzBdO1xuXG4gICAgcmV0dXJuIHRoaXMubWFwKCBmbiApLnRoZW4oZnVuY3Rpb24oIGluY2x1ZGUgKXtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXNzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBkYXR1bSA9IHBhc3NbaV07XG4gICAgICAgIHZhciBpbmNEYXR1bSA9IGluY2x1ZGVbaV07XG5cbiAgICAgICAgaWYoIGluY0RhdHVtICl7XG4gICAgICAgICAgcmV0LnB1c2goIGRhdHVtICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBzb3J0cyB0aGUgcGFzc2VkIGFycmF5IHVzaW5nIGEgZGl2aWRlIGFuZCBjb25xdWVyIHN0cmF0ZWd5XG4gIHNvcnQ6IGZ1bmN0aW9uKCBjbXAgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIFAgPSB0aGlzLl9wcml2YXRlLnBhc3NbMF0ubGVuZ3RoO1xuICAgIHZhciBzdWJzaXplID0gdGhpcy5zcHJlYWRTaXplKCk7XG5cbiAgICBjbXAgPSBjbXAgfHwgZnVuY3Rpb24oIGEsIGIgKXsgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICBpZiggYSA8IGIgKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmKCBhID4gYiApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIHNlbGYucmVxdWlyZSggY21wLCAnXyRfJF9jbXAnICk7XG5cbiAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7IC8vIHNvcnQgZWFjaCBzcGxpdCBub3JtYWxseVxuICAgICAgdmFyIHNvcnRlZFNwbGl0ID0gc3BsaXQuc29ydCggXyRfJF9jbXAgKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXNvbHZlKCBzb3J0ZWRTcGxpdCApOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIH0pLnRoZW4oZnVuY3Rpb24oIGpvaW5lZCApe1xuICAgICAgLy8gZG8gYWxsIHRoZSBtZXJnaW5nIGluIHRoZSBtYWluIHRocmVhZCB0byBtaW5pbWlzZSBkYXRhIHRyYW5zZmVyXG5cbiAgICAgIC8vIFRPRE8gY291bGQgZG8gbWVyZ2luZyBpbiBzZXBhcmF0ZSB0aHJlYWRzIGJ1dCB3b3VsZCBpbmN1ciBhZGQnbCBjb3N0IG9mIGRhdGEgdHJhbnNmZXJcbiAgICAgIC8vIGZvciBlYWNoIGxldmVsIG9mIHRoZSBtZXJnZVxuXG4gICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbiggaSwgaiwgbWF4ICl7XG4gICAgICAgIC8vIGRvbid0IG92ZXJmbG93IGFycmF5XG4gICAgICAgIGogPSBNYXRoLm1pbiggaiwgUCApO1xuICAgICAgICBtYXggPSBNYXRoLm1pbiggbWF4LCBQICk7XG5cbiAgICAgICAgLy8gbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2YgbWVyZ2VcbiAgICAgICAgdmFyIGwgPSBpO1xuICAgICAgICB2YXIgciA9IGo7XG5cbiAgICAgICAgdmFyIHNvcnRlZCA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGsgPSBsOyBrIDwgbWF4OyBrKysgKXtcblxuICAgICAgICAgIHZhciBlbGVJID0gam9pbmVkW2ldO1xuICAgICAgICAgIHZhciBlbGVKID0gam9pbmVkW2pdO1xuXG4gICAgICAgICAgaWYoIGkgPCByICYmICggaiA+PSBtYXggfHwgY21wKGVsZUksIGVsZUopIDw9IDAgKSApe1xuICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUkgKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUogKTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIHRoZSBhcnJheSBwcm9wZXIsIHB1dCB0aGUgc29ydGVkIHZhbHVlc1xuICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IHNvcnRlZC5sZW5ndGg7IGsrKyApeyAvLyBrdGggc29ydGVkIGl0ZW1cbiAgICAgICAgICB2YXIgaW5kZXggPSBsICsgaztcblxuICAgICAgICAgIGpvaW5lZFsgaW5kZXggXSA9IHNvcnRlZFtrXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yKCB2YXIgc3BsaXRMID0gc3Vic2l6ZTsgc3BsaXRMIDwgUDsgc3BsaXRMICo9IDIgKXsgLy8gbWVyZ2UgdW50aWwgYXJyYXkgaXMgXCJzcGxpdFwiIGFzIDFcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IFA7IGkgKz0gMipzcGxpdEwgKXtcbiAgICAgICAgICBtZXJnZSggaSwgaSArIHNwbGl0TCwgaSArIDIqc3BsaXRMICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gam9pbmVkO1xuICAgIH0pO1xuICB9XG5cblxufSk7XG5cbnZhciBkZWZpbmVSYW5kb21QYXNzZXIgPSBmdW5jdGlvbiggb3B0cyApe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oIGZuLCBhcmcxICl7XG4gICAgdmFyIHBhc3MgPSB0aGlzLl9wcml2YXRlLnBhc3Muc2hpZnQoKTtcblxuICAgIHJldHVybiB0aGlzLnJhbmRvbSgpLnBhc3MoIHBhc3MgKVsgb3B0cy50aHJlYWRGbiBdKCBmbiwgYXJnMSApO1xuICB9O1xufTtcblxudXRpbC5leHRlbmQoZmFiZm4sIHtcbiAgcmFuZG9tTWFwOiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ21hcCcgfSksXG5cbiAgcmVkdWNlOiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ3JlZHVjZScgfSksXG5cbiAgcmVkdWNlUmlnaHQ6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAncmVkdWNlUmlnaHQnIH0pXG59KTtcblxuLy8gYWxpYXNlc1xudmFyIGZuID0gZmFiZm47XG5mbi5wcm9taXNlID0gZm4ucnVuO1xuZm4udGVybWluYXRlID0gZm4uaGFsdCA9IGZuLnN0b3A7XG5mbi5pbmNsdWRlID0gZm4ucmVxdWlyZTtcblxuLy8gcHVsbCBpbiBldmVudCBhcGlzXG51dGlsLmV4dGVuZChmYWJmbiwge1xuICBvbjogZGVmaW5lLm9uKCksXG4gIG9uZTogZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgb2ZmOiBkZWZpbmUub2ZmKCksXG4gIHRyaWdnZXI6IGRlZmluZS50cmlnZ2VyKClcbn0pO1xuXG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oIGZhYmZuICk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFicmljO1xuIiwiLyohXG5Qb3J0ZWQgYnkgWHVlcWlhbyBYdSA8eHVlcWlhb3h1QGdtYWlsLmNvbT47XG5cblBTRiBMSUNFTlNFIEFHUkVFTUVOVCBGT1IgUFlUSE9OIDIuNy4yXG5cbjEuIFRoaXMgTElDRU5TRSBBR1JFRU1FTlQgaXMgYmV0d2VlbiB0aGUgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb24gKOKAnFBTRuKAnSksIGFuZCB0aGUgSW5kaXZpZHVhbCBvciBPcmdhbml6YXRpb24gKOKAnExpY2Vuc2Vl4oCdKSBhY2Nlc3NpbmcgYW5kIG90aGVyd2lzZSB1c2luZyBQeXRob24gMi43LjIgc29mdHdhcmUgaW4gc291cmNlIG9yIGJpbmFyeSBmb3JtIGFuZCBpdHMgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uLlxuMi4gU3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhpcyBMaWNlbnNlIEFncmVlbWVudCwgUFNGIGhlcmVieSBncmFudHMgTGljZW5zZWUgYSBub25leGNsdXNpdmUsIHJveWFsdHktZnJlZSwgd29ybGQtd2lkZSBsaWNlbnNlIHRvIHJlcHJvZHVjZSwgYW5hbHl6ZSwgdGVzdCwgcGVyZm9ybSBhbmQvb3IgZGlzcGxheSBwdWJsaWNseSwgcHJlcGFyZSBkZXJpdmF0aXZlIHdvcmtzLCBkaXN0cmlidXRlLCBhbmQgb3RoZXJ3aXNlIHVzZSBQeXRob24gMi43LjIgYWxvbmUgb3IgaW4gYW55IGRlcml2YXRpdmUgdmVyc2lvbiwgcHJvdmlkZWQsIGhvd2V2ZXIsIHRoYXQgUFNG4oCZcyBMaWNlbnNlIEFncmVlbWVudCBhbmQgUFNG4oCZcyBub3RpY2Ugb2YgY29weXJpZ2h0LCBpLmUuLCDigJxDb3B5cmlnaHQgwqkgMjAwMS0yMDEyIFB5dGhvbiBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBBbGwgUmlnaHRzIFJlc2VydmVk4oCdIGFyZSByZXRhaW5lZCBpbiBQeXRob24gMi43LjIgYWxvbmUgb3IgaW4gYW55IGRlcml2YXRpdmUgdmVyc2lvbiBwcmVwYXJlZCBieSBMaWNlbnNlZS5cbjMuIEluIHRoZSBldmVudCBMaWNlbnNlZSBwcmVwYXJlcyBhIGRlcml2YXRpdmUgd29yayB0aGF0IGlzIGJhc2VkIG9uIG9yIGluY29ycG9yYXRlcyBQeXRob24gMi43LjIgb3IgYW55IHBhcnQgdGhlcmVvZiwgYW5kIHdhbnRzIHRvIG1ha2UgdGhlIGRlcml2YXRpdmUgd29yayBhdmFpbGFibGUgdG8gb3RoZXJzIGFzIHByb3ZpZGVkIGhlcmVpbiwgdGhlbiBMaWNlbnNlZSBoZXJlYnkgYWdyZWVzIHRvIGluY2x1ZGUgaW4gYW55IHN1Y2ggd29yayBhIGJyaWVmIHN1bW1hcnkgb2YgdGhlIGNoYW5nZXMgbWFkZSB0byBQeXRob24gMi43LjIuXG40LiBQU0YgaXMgbWFraW5nIFB5dGhvbiAyLjcuMiBhdmFpbGFibGUgdG8gTGljZW5zZWUgb24gYW4g4oCcQVMgSVPigJ0gYmFzaXMuIFBTRiBNQUtFUyBOTyBSRVBSRVNFTlRBVElPTlMgT1IgV0FSUkFOVElFUywgRVhQUkVTUyBPUiBJTVBMSUVELiBCWSBXQVkgT0YgRVhBTVBMRSwgQlVUIE5PVCBMSU1JVEFUSU9OLCBQU0YgTUFLRVMgTk8gQU5EIERJU0NMQUlNUyBBTlkgUkVQUkVTRU5UQVRJT04gT1IgV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEFOWSBQQVJUSUNVTEFSIFBVUlBPU0UgT1IgVEhBVCBUSEUgVVNFIE9GIFBZVEhPTiAyLjcuMiBXSUxMIE5PVCBJTkZSSU5HRSBBTlkgVEhJUkQgUEFSVFkgUklHSFRTLlxuNS4gUFNGIFNIQUxMIE5PVCBCRSBMSUFCTEUgVE8gTElDRU5TRUUgT1IgQU5ZIE9USEVSIFVTRVJTIE9GIFBZVEhPTiAyLjcuMiBGT1IgQU5ZIElOQ0lERU5UQUwsIFNQRUNJQUwsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBMT1NTIEFTIEEgUkVTVUxUIE9GIE1PRElGWUlORywgRElTVFJJQlVUSU5HLCBPUiBPVEhFUldJU0UgVVNJTkcgUFlUSE9OIDIuNy4yLCBPUiBBTlkgREVSSVZBVElWRSBUSEVSRU9GLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIFRIRVJFT0YuXG42LiBUaGlzIExpY2Vuc2UgQWdyZWVtZW50IHdpbGwgYXV0b21hdGljYWxseSB0ZXJtaW5hdGUgdXBvbiBhIG1hdGVyaWFsIGJyZWFjaCBvZiBpdHMgdGVybXMgYW5kIGNvbmRpdGlvbnMuXG43LiBOb3RoaW5nIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgc2hhbGwgYmUgZGVlbWVkIHRvIGNyZWF0ZSBhbnkgcmVsYXRpb25zaGlwIG9mIGFnZW5jeSwgcGFydG5lcnNoaXAsIG9yIGpvaW50IHZlbnR1cmUgYmV0d2VlbiBQU0YgYW5kIExpY2Vuc2VlLiBUaGlzIExpY2Vuc2UgQWdyZWVtZW50IGRvZXMgbm90IGdyYW50IHBlcm1pc3Npb24gdG8gdXNlIFBTRiB0cmFkZW1hcmtzIG9yIHRyYWRlIG5hbWUgaW4gYSB0cmFkZW1hcmsgc2Vuc2UgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIG9yIHNlcnZpY2VzIG9mIExpY2Vuc2VlLCBvciBhbnkgdGhpcmQgcGFydHkuXG44LiBCeSBjb3B5aW5nLCBpbnN0YWxsaW5nIG9yIG90aGVyd2lzZSB1c2luZyBQeXRob24gMi43LjIsIExpY2Vuc2VlIGFncmVlcyB0byBiZSBib3VuZCBieSB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhpcyBMaWNlbnNlIEFncmVlbWVudC5cbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcblxudmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG5mbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbi8qXG5EZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICovXG5cbmRlZmF1bHRDbXAgPSBmdW5jdGlvbiggeCwgeSApe1xuICBpZiggeCA8IHkgKXtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYoIHggPiB5ICl7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbi8qXG5JbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuXG5JZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG5cbk9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2Vcbm9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gKi9cblxuaW5zb3J0ID0gZnVuY3Rpb24oIGEsIHgsIGxvLCBoaSwgY21wICl7XG4gIHZhciBtaWQ7XG4gIGlmKCBsbyA9PSBudWxsICl7XG4gICAgbG8gPSAwO1xuICB9XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgaWYoIGxvIDwgMCApe1xuICAgIHRocm93IG5ldyBFcnJvciggJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyApO1xuICB9XG4gIGlmKCBoaSA9PSBudWxsICl7XG4gICAgaGkgPSBhLmxlbmd0aDtcbiAgfVxuICB3aGlsZSggbG8gPCBoaSApe1xuICAgIG1pZCA9IGZsb29yKCAobG8gKyBoaSkgLyAyICk7XG4gICAgaWYoIGNtcCggeCwgYVsgbWlkIF0gKSA8IDAgKXtcbiAgICAgIGhpID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsbyA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KCBhLCBbIGxvLCBsbyAtIGxvIF0uY29uY2F0KCB4ICkgKSwgeCk7XG59O1xuXG5cbi8qXG5QdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gKi9cblxuaGVhcHB1c2ggPSBmdW5jdGlvbiggYXJyYXksIGl0ZW0sIGNtcCApe1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGFycmF5LnB1c2goIGl0ZW0gKTtcbiAgcmV0dXJuIF9zaWZ0ZG93biggYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCApO1xufTtcblxuXG4vKlxuUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICovXG5cbmhlYXBwb3AgPSBmdW5jdGlvbiggYXJyYXksIGNtcCApe1xuICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gIGlmKCBhcnJheS5sZW5ndGggKXtcbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgIF9zaWZ0dXAoIGFycmF5LCAwLCBjbXAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgfVxuICByZXR1cm4gcmV0dXJuaXRlbTtcbn07XG5cblxuLypcblBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cblxuVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG5tb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbnJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbnRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gKi9cblxuaGVhcHJlcGxhY2UgPSBmdW5jdGlvbiggYXJyYXksIGl0ZW0sIGNtcCApe1xuICB2YXIgcmV0dXJuaXRlbTtcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gIGFycmF5WzBdID0gaXRlbTtcbiAgX3NpZnR1cCggYXJyYXksIDAsIGNtcCApO1xuICByZXR1cm4gcmV0dXJuaXRlbTtcbn07XG5cblxuLypcbkZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAqL1xuXG5oZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIHZhciBfcmVmO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGlmKCBhcnJheS5sZW5ndGggJiYgY21wKCBhcnJheVswXSwgaXRlbSApIDwgMCApe1xuICAgIF9yZWYgPSBbIGFycmF5WzBdLCBpdGVtIF0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgX3NpZnR1cCggYXJyYXksIDAsIGNtcCApO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG4vKlxuVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAqL1xuXG5oZWFwaWZ5ID0gZnVuY3Rpb24oIGFycmF5LCBjbXAgKXtcbiAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgX3JlZjEgPSAoZnVuY3Rpb24oKXtcbiAgICBfcmVzdWx0czEgPSBbXTtcbiAgICBmb3IoIHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vciggYXJyYXkubGVuZ3RoIC8gMiApOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tICl7IF9yZXN1bHRzMS5wdXNoKCBfaiApOyB9XG4gICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgfSkuYXBwbHkoIHRoaXMgKS5yZXZlcnNlKCk7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciggX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKysgKXtcbiAgICBpID0gX3JlZjFbIF9pIF07XG4gICAgX3Jlc3VsdHMucHVzaCggX3NpZnR1cCggYXJyYXksIGksIGNtcCApICk7XG4gIH1cbiAgcmV0dXJuIF9yZXN1bHRzO1xufTtcblxuXG4vKlxuVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cblRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICovXG5cbnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbiggYXJyYXksIGl0ZW0sIGNtcCApe1xuICB2YXIgcG9zO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIHBvcyA9IGFycmF5LmluZGV4T2YoIGl0ZW0gKTtcbiAgaWYoIHBvcyA9PT0gLTEgKXtcbiAgICByZXR1cm47XG4gIH1cbiAgX3NpZnRkb3duKCBhcnJheSwgMCwgcG9zLCBjbXAgKTtcbiAgcmV0dXJuIF9zaWZ0dXAoIGFycmF5LCBwb3MsIGNtcCApO1xufTtcblxuXG4vKlxuRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAqL1xuXG5ubGFyZ2VzdCA9IGZ1bmN0aW9uKCBhcnJheSwgbiwgY21wICl7XG4gIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIHJlc3VsdCA9IGFycmF5LnNsaWNlKCAwLCBuICk7XG4gIGlmKCAhcmVzdWx0Lmxlbmd0aCApe1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGVhcGlmeSggcmVzdWx0LCBjbXAgKTtcbiAgX3JlZiA9IGFycmF5LnNsaWNlKCBuICk7XG4gIGZvciggX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKyApe1xuICAgIGVsZW0gPSBfcmVmWyBfaSBdO1xuICAgIGhlYXBwdXNocG9wKCByZXN1bHQsIGVsZW0sIGNtcCApO1xuICB9XG4gIHJldHVybiByZXN1bHQuc29ydCggY21wICkucmV2ZXJzZSgpO1xufTtcblxuXG4vKlxuRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gKi9cblxubnNtYWxsZXN0ID0gZnVuY3Rpb24oIGFycmF5LCBuLCBjbXAgKXtcbiAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBpZiggbiAqIDEwIDw9IGFycmF5Lmxlbmd0aCApe1xuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKCAwLCBuICkuc29ydCggY21wICk7XG4gICAgaWYoICFyZXN1bHQubGVuZ3RoICl7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb3MgPSByZXN1bHRbIHJlc3VsdC5sZW5ndGggLSAxXTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2UoIG4gKTtcbiAgICBmb3IoIF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKysgKXtcbiAgICAgIGVsZW0gPSBfcmVmWyBfaSBdO1xuICAgICAgaWYoIGNtcCggZWxlbSwgbG9zICkgPCAwICl7XG4gICAgICAgIGluc29ydCggcmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXAgKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICBsb3MgPSByZXN1bHRbIHJlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoZWFwaWZ5KCBhcnJheSwgY21wICk7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciggaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4oIG4sIGFycmF5Lmxlbmd0aCApOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2ogKXtcbiAgICBfcmVzdWx0cy5wdXNoKCBoZWFwcG9wKCBhcnJheSwgY21wICkgKTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5fc2lmdGRvd24gPSBmdW5jdGlvbiggYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCApe1xuICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgbmV3aXRlbSA9IGFycmF5WyBwb3MgXTtcbiAgd2hpbGUoIHBvcyA+IHN0YXJ0cG9zICl7XG4gICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgcGFyZW50ID0gYXJyYXlbIHBhcmVudHBvcyBdO1xuICAgIGlmKCBjbXAoIG5ld2l0ZW0sIHBhcmVudCApIDwgMCApe1xuICAgICAgYXJyYXlbIHBvcyBdID0gcGFyZW50O1xuICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhcnJheVsgcG9zIF0gPSBuZXdpdGVtO1xufTtcblxuX3NpZnR1cCA9IGZ1bmN0aW9uKCBhcnJheSwgcG9zLCBjbXAgKXtcbiAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gIHN0YXJ0cG9zID0gcG9zO1xuICBuZXdpdGVtID0gYXJyYXlbIHBvcyBdO1xuICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICB3aGlsZSggY2hpbGRwb3MgPCBlbmRwb3MgKXtcbiAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICBpZiggcmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoIGFycmF5WyBjaGlsZHBvcyBdLCBhcnJheVsgcmlnaHRwb3MgXSApIDwgMCkgKXtcbiAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgfVxuICAgIGFycmF5WyBwb3MgXSA9IGFycmF5WyBjaGlsZHBvcyBdO1xuICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gIH1cbiAgYXJyYXlbIHBvcyBdID0gbmV3aXRlbTtcbiAgcmV0dXJuIF9zaWZ0ZG93biggYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCApO1xufTtcblxuSGVhcCA9IChmdW5jdGlvbigpe1xuICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICBmdW5jdGlvbiBIZWFwKCBjbXAgKXtcbiAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gIH1cblxuICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gaGVhcHB1c2goIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gaGVhcHBvcCggdGhpcy5ub2RlcywgdGhpcy5jbXAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKCB4ICl7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZiggeCApICE9PSAtMTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gaGVhcHJlcGxhY2UoIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKCB4ICl7XG4gICAgcmV0dXJuIGhlYXBwdXNocG9wKCB0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCApO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBoZWFwaWZ5KCB0aGlzLm5vZGVzLCB0aGlzLmNtcCApO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbiggeCApe1xuICAgIHJldHVybiB1cGRhdGVJdGVtKCB0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCApO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgaGVhcDtcbiAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSggMCApO1xuICAgIHJldHVybiBoZWFwO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKCAwICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgcmV0dXJuIEhlYXA7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhcDtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi8tcHJlYW1ibGUnKTtcblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoICcuL3dpbmRvdycgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xudmFyIENvcmUgPSByZXF1aXJlKCAnLi9jb3JlJyApO1xudmFyIGV4dGVuc2lvbiA9IHJlcXVpcmUoICcuL2V4dGVuc2lvbicgKTtcbnZhciByZWdpc3RlckpxdWVyeSA9IHJlcXVpcmUoICcuL2pxdWVyeS1wbHVnaW4nICk7XG52YXIgU3R5bGVzaGVldCA9IHJlcXVpcmUoICcuL3N0eWxlc2hlZXQnICk7XG52YXIgVGhyZWFkID0gcmVxdWlyZSggJy4vdGhyZWFkJyApO1xudmFyIEZhYnJpYyA9IHJlcXVpcmUoICcuL2ZhYnJpYycgKTtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgaWYoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApe1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbnN0YW5jZVxuICBpZiggaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgIHJldHVybiBuZXcgQ29yZSggb3B0aW9ucyApO1xuICB9XG5cbiAgLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gIGVsc2UgaWYoIGlzLnN0cmluZyggb3B0aW9ucyApICl7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5hcHBseSggZXh0ZW5zaW9uLCBhcmd1bWVudHMgKTtcbiAgfVxufTtcblxuLy8gcmVwbGFjZWQgYnkgYnVpbGQgc3lzdGVtXG5jeXRvc2NhcGUudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4vLyB0cnkgdG8gcmVnaXN0ZXIgdy8ganF1ZXJ5XG5pZiggd2luZG93ICYmIHdpbmRvdy5qUXVlcnkgKXtcbiAgcmVnaXN0ZXJKcXVlcnkoIHdpbmRvdy5qUXVlcnksIGN5dG9zY2FwZSApO1xufVxuXG4vLyBleHBvc2UgcmVnaXN0ZXIgYXBpXG5jeXRvc2NhcGUucmVnaXN0ZXJKcXVlcnkgPSBmdW5jdGlvbiggalF1ZXJ5ICl7XG4gIHJlZ2lzdGVySnF1ZXJ5KCBqUXVlcnksIGN5dG9zY2FwZSApO1xufTtcblxuLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcbmN5dG9zY2FwZS50aHJlYWQgPSBjeXRvc2NhcGUuVGhyZWFkID0gVGhyZWFkO1xuY3l0b3NjYXBlLmZhYnJpYyA9IGN5dG9zY2FwZS5GYWJyaWMgPSBGYWJyaWM7XG5cbm1vZHVsZS5leHBvcnRzID0gY3l0b3NjYXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmdsb2JhbCBIVE1MRWxlbWVudCBEb2N1bWVudFRvdWNoICovXG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi93aW5kb3cnICk7XG52YXIgbmF2aWdhdG9yID0gd2luZG93ID8gd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG52YXIgZG9jdW1lbnQgPSB3aW5kb3cgPyB3aW5kb3cuZG9jdW1lbnQgOiBudWxsO1xuXG52YXIgdHlwZW9mc3RyID0gdHlwZW9mICcnO1xudmFyIHR5cGVvZm9iaiA9IHR5cGVvZiB7fTtcbnZhciB0eXBlb2ZmbiA9IHR5cGVvZiBmdW5jdGlvbigpe307XG52YXIgdHlwZW9maHRtbGVsZSA9IHR5cGVvZiBIVE1MRWxlbWVudDtcblxudmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24oIG9iaiApe1xuICByZXR1cm4gb2JqICYmIG9iai5pbnN0YW5jZVN0cmluZyAmJiBpcy5mbiggb2JqLmluc3RhbmNlU3RyaW5nICkgPyBvYmouaW5zdGFuY2VTdHJpbmcoKSA6IG51bGw7XG59O1xuXG52YXIgaXMgPSB7XG4gIGRlZmluZWQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGw7IC8vIG5vdCB1bmRlZmluZWQgb3IgbnVsbFxuICB9LFxuXG4gIHN0cmluZzogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09IHR5cGVvZnN0cjtcbiAgfSxcblxuICBmbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZmbjtcbiAgfSxcblxuICBhcnJheTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSggb2JqICkgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbiAgfSxcblxuICBwbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmogJiYgIWlzLmFycmF5KCBvYmogKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgfSxcblxuICBvYmplY3Q6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mb2JqO1xuICB9LFxuXG4gIG51bWJlcjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgMSAmJiAhaXNOYU4oIG9iaiApO1xuICB9LFxuXG4gIGludGVnZXI6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaXMubnVtYmVyKCBvYmogKSAmJiBNYXRoLmZsb29yKCBvYmogKSA9PT0gb2JqO1xuICB9LFxuXG4gIGJvb2w6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIHRydWU7XG4gIH0sXG5cbiAgaHRtbEVsZW1lbnQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH0sXG5cbiAgZWxlbWVudE9yQ29sbGVjdGlvbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5lbGVtZW50KCBvYmogKSB8fCBpcy5jb2xsZWN0aW9uKCBvYmogKTtcbiAgfSxcblxuICBlbGVtZW50OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gIH0sXG5cbiAgY29sbGVjdGlvbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpbnN0YW5jZVN0ciggb2JqICkgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfSxcblxuICBjb3JlOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ2NvcmUnO1xuICB9LFxuXG4gIHN0eWxlOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ3N0eWxlJztcbiAgfSxcblxuICBzdHlsZXNoZWV0OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ3N0eWxlc2hlZXQnO1xuICB9LFxuXG4gIGV2ZW50OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ2V2ZW50JztcbiAgfSxcblxuICB0aHJlYWQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAndGhyZWFkJztcbiAgfSxcblxuICBmYWJyaWM6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnZmFicmljJztcbiAgfSxcblxuICBlbXB0eVN0cmluZzogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwgKXsgLy8gbnVsbCBpcyBlbXB0eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmKCBvYmogPT09ICcnIHx8IG9iai5tYXRjaCggL15cXHMrJC8gKSApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG4gIH0sXG5cbiAgbm9uZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggb2JqICYmIGlzLnN0cmluZyggb2JqICkgJiYgb2JqICE9PSAnJyAmJiAhb2JqLm1hdGNoKCAvXlxccyskLyApICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZG9tRWxlbWVudDogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnICl7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBib3VuZGluZ0JveDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5wbGFpbk9iamVjdCggb2JqICkgJiZcbiAgICAgIGlzLm51bWJlciggb2JqLngxICkgJiYgaXMubnVtYmVyKCBvYmoueDIgKSAmJlxuICAgICAgaXMubnVtYmVyKCBvYmoueTEgKSAmJiBpcy5udW1iZXIoIG9iai55MiApXG4gICAgO1xuICB9LFxuXG4gIHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaXMub2JqZWN0KCBvYmogKSAmJiBpcy5mbiggb2JqLnRoZW4gKTtcbiAgfSxcblxuICB0b3VjaDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93ICYmICggKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoICk7XG4gIH0sXG5cbiAgZ2Vja286IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiAoIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcgfHwgKCdNb3pBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpICk7XG4gIH0sXG5cbiAgd2Via2l0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgKTtcbiAgfSxcblxuICBjaHJvbWl1bTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93ICYmICggdHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgKTtcbiAgfSxcblxuICBraHRtbDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci52ZW5kb3IubWF0Y2goIC9rZGUvaSApOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICBraHRtbEV0YzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gaXMua2h0bWwoKSB8fCBpcy53ZWJraXQoKSB8fCBpcy5jaHJvbWl1bSgpO1xuICB9LFxuXG4gIG1zOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCggL21zaWV8dHJpZGVudHxlZGdlL2kgKTsgLy8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG4gIH0sXG5cbiAgd2luZG93czogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKCAvV2luL2kgKTtcbiAgfSxcblxuICBtYWM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCggL01hYy9pICk7XG4gIH0sXG5cbiAgbGludXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCggL0xpbnV4L2kgKTtcbiAgfSxcblxuICB1bml4OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goIC9YMTEvaSApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi9pcycgKTtcblxudmFyIGN5UmVnID0gZnVuY3Rpb24oICRlbGUgKXtcbiAgdmFyIGQgPSAkZWxlWzBdLl9jeXJlZyA9ICRlbGVbMF0uX2N5cmVnIHx8IHt9O1xuXG4gIHJldHVybiBkO1xufTtcblxudmFyIHJlZ2lzdGVySnF1ZXJ5ID0gZnVuY3Rpb24oICQsIGN5dG9zY2FwZSApe1xuICBpZiggISQgKXsgcmV0dXJuOyB9IC8vIG5vIGpxdWVyeSA9PiBkb24ndCBuZWVkIHRoaXNcblxuICBpZiggJC5mbi5jeXRvc2NhcGUgKXsgcmV0dXJuOyB9IC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuXG4gIC8vIGFsbG93IGNhbGxzIG9uIGEgalF1ZXJ5IHNlbGVjdG9yIGJ5IHByb3h5aW5nIGNhbGxzIHRvICQuY3l0b3NjYXBlXG4gIC8vIGUuZy4gJChcIiNmb29cIikuY3l0b3NjYXBlKG9wdGlvbnMpID0+ICQuY3l0b3NjYXBlKG9wdGlvbnMpIG9uICNmb29cbiAgJC5mbi5jeXRvc2NhcGUgPSBmdW5jdGlvbiggb3B0cyApe1xuICAgIHZhciAkdGhpcyA9ICQoIHRoaXMgKTtcblxuICAgIC8vIGdldCBvYmplY3RcbiAgICBpZiggb3B0cyA9PT0gJ2dldCcgKXtcbiAgICAgIHJldHVybiBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICB9XG5cbiAgICAvLyBiaW5kIHRvIHJlYWR5XG4gICAgZWxzZSBpZiggaXMuZm4oIG9wdHMgKSApe1xuXG4gICAgICB2YXIgcmVhZHkgPSBvcHRzO1xuICAgICAgdmFyIGN5ID0gY3lSZWcoICR0aGlzICkuY3k7XG5cbiAgICAgIGlmKCBjeSAmJiBjeS5pc1JlYWR5KCkgKXsgLy8gYWxyZWFkeSByZWFkeSBzbyBqdXN0IHRyaWdnZXIgbm93XG4gICAgICAgIGN5LnRyaWdnZXIoICdyZWFkeScsIFtdLCByZWFkeSApO1xuXG4gICAgICB9IGVsc2UgeyAvLyBub3QgeWV0IHJlYWR5LCBzbyBhZGQgdG8gcmVhZGllcyBsaXN0XG4gICAgICAgIHZhciBkYXRhID0gY3lSZWcoICR0aGlzICk7XG4gICAgICAgIHZhciByZWFkaWVzID0gZGF0YS5yZWFkaWVzID0gZGF0YS5yZWFkaWVzIHx8IFtdO1xuXG4gICAgICAgIHJlYWRpZXMucHVzaCggcmVhZHkgKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHByb3h5IHRvIGNyZWF0ZSBpbnN0YW5jZVxuICAgIGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBvcHRzICkgKXtcbiAgICAgIHJldHVybiAkdGhpcy5lYWNoKCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0cywge1xuICAgICAgICAgIGNvbnRhaW5lcjogJCggdGhpcyApWzBdXG4gICAgICAgIH0gKTtcblxuICAgICAgICBjeXRvc2NhcGUoIG9wdGlvbnMgKTtcbiAgICAgIH0gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgY3l0b3NjYXBlIG9iamVjdCB1bmRlciBqcXVlcnkgZm9yIGxlZ2FjeSByZWFzb25zXG4gICQuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuXG4gIC8vIHVzZSBzaG9ydCBhbGlhcyAoY3kpIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgaWYoICQuZm4uY3kgPT0gbnVsbCAmJiAkLmN5ID09IG51bGwgKXtcbiAgICAkLmZuLmN5ID0gJC5mbi5jeXRvc2NhcGU7XG4gICAgJC5jeSA9ICQuY3l0b3NjYXBlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVySnF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHt9O1xuXG5tYXRoLmFyZVBvc2l0aW9uc1NhbWUgPSBmdW5jdGlvbiggcDEsIHAyICl7XG4gIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59O1xuXG5tYXRoLmNvcHlQb3NpdGlvbiA9IGZ1bmN0aW9uKCBwICl7XG4gIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XG59O1xuXG5tYXRoLmFycmF5MnBvaW50ID0gZnVuY3Rpb24oIGFyciApe1xuICByZXR1cm4ge1xuICAgIHg6IGFyclswXSxcbiAgICB5OiBhcnJbMV1cbiAgfTtcbn07XG5cbm1hdGguZGVnMnJhZCA9IGZ1bmN0aW9uKCBkZWcgKXtcbiAgcmV0dXJuIE1hdGguUEkgKiBkZWcgLyAxODA7XG59O1xuXG5tYXRoLmxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24oIG4gKXtcbiAgcmV0dXJuIE1hdGgubG9nKCBuICkgLyBNYXRoLmxvZyggMiApO1xufTtcblxubWF0aC5zaWdudW0gPSBmdW5jdGlvbiggeCApe1xuICBpZiggeCA+IDAgKXtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmKCB4IDwgMCApe1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxubWF0aC5kaXN0ID0gZnVuY3Rpb24oIHAxLCBwMiApe1xuICByZXR1cm4gTWF0aC5zcXJ0KCBtYXRoLnNxZGlzdCggcDEsIHAyICkgKTtcbn07XG5cbm1hdGguc3FkaXN0ID0gZnVuY3Rpb24oIHAxLCBwMiApe1xuICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcblxuLy8gZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xubWF0aC5xYmV6aWVyQXQgPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgdCApe1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbn07XG5cbm1hdGgucWJlemllclB0QXQgPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgdCApe1xuICByZXR1cm4ge1xuICAgIHg6IG1hdGgucWJlemllckF0KCBwMC54LCBwMS54LCBwMi54LCB0ICksXG4gICAgeTogbWF0aC5xYmV6aWVyQXQoIHAwLnksIHAxLnksIHAyLnksIHQgKVxuICB9O1xufTtcblxubWF0aC5saW5lQXQgPSBmdW5jdGlvbiggcDAsIHAxLCB0LCBkICl7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcblxuICB2YXIgdmVjRGlzdCA9IG1hdGguZGlzdCggcDAsIHAxICk7XG5cbiAgdmFyIG5vcm1WZWMgPSB7XG4gICAgeDogdmVjLnggLyB2ZWNEaXN0LFxuICAgIHk6IHZlYy55IC8gdmVjRGlzdFxuICB9O1xuXG4gIHQgPSB0ID09IG51bGwgPyAwIDogdDtcblxuICB2YXIgZCA9IGQgIT0gbnVsbCA/IGQgOiB0ICogdmVjRGlzdDtcblxuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xuXG5tYXRoLmxpbmVBdERpc3QgPSBmdW5jdGlvbiggcDAsIHAxLCBkICl7XG4gIHJldHVybiBtYXRoLmxpbmVBdCggcDAsIHAxLCB1bmRlZmluZWQsIGQgKTtcbn07XG5cbi8vIGdldCBhbmdsZSBhdCBBIHZpYSBjb3NpbmUgbGF3XG5tYXRoLnRyaWFuZ2xlQW5nbGUgPSBmdW5jdGlvbiggQSwgQiwgQyApe1xuICB2YXIgYSA9IG1hdGguZGlzdCggQiwgQyApO1xuICB2YXIgYiA9IG1hdGguZGlzdCggQSwgQyApO1xuICB2YXIgYyA9IG1hdGguZGlzdCggQSwgQiApO1xuXG4gIHJldHVybiBNYXRoLmFjb3MoIChhKmEgKyBiKmIgLSBjKmMpLygyKmEqYikgKTtcbn07XG5cbm1hdGguYm91bmQgPSBmdW5jdGlvbiggbWluLCB2YWwsIG1heCApe1xuICByZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsICkgKTtcbn07XG5cbi8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG5tYXRoLm1ha2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiApe1xuICBpZiggYmIgPT0gbnVsbCApe1xuICAgIHJldHVybiB7XG4gICAgICB4MTogSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB4MjogLUluZmluaXR5LFxuICAgICAgeTI6IC1JbmZpbml0eSxcbiAgICAgIHc6IDAsXG4gICAgICBoOiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmKCBiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwgKXtcbiAgICBpZiggYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICB5MjogYmIueTIsXG4gICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKCBiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDAgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICB3OiBiYi53LFxuICAgICAgICBoOiBiYi5oXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxubWF0aC51cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAvLyB1cGRhdGUgYmIxIHdpdGggYmIyIGJvdW5kc1xuXG4gIGJiMS54MSA9IE1hdGgubWluKCBiYjEueDEsIGJiMi54MSApO1xuICBiYjEueDIgPSBNYXRoLm1heCggYmIxLngyLCBiYjIueDIgKTtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG5cbiAgYmIxLnkxID0gTWF0aC5taW4oIGJiMS55MSwgYmIyLnkxICk7XG4gIGJiMS55MiA9IE1hdGgubWF4KCBiYjEueTIsIGJiMi55MiApO1xuICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbn07XG5cbm1hdGguZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHBhZGRpbmcgKXtcbiAgYmIueDEgLT0gcGFkZGluZztcbiAgYmIueDIgKz0gcGFkZGluZztcbiAgYmIueTEgLT0gcGFkZGluZztcbiAgYmIueTIgKz0gcGFkZGluZztcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gIHJldHVybiBiYjtcbn07XG5cbm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYoIGJiMS54MSA+IGJiMi54MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYoIGJiMi54MSA+IGJiMS54MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICBpZiggYmIxLngyIDwgYmIyLngxICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLngyIDwgYmIxLngxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuICBpZiggYmIxLnkyIDwgYmIyLnkxICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLnkyIDwgYmIxLnkxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICBpZiggYmIxLnkxID4gYmIyLnkyICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLnkxID4gYmIxLnkyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1hdGguaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgeCwgeSApe1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG5cbm1hdGgucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCBwdCApe1xuICByZXR1cm4gdGhpcy5pbkJvdW5kaW5nQm94KCBiYiwgcHQueCwgcHQueSApO1xufTtcblxubWF0aC5ib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgcmV0dXJuIChcbiAgICAgICBtYXRoLmluQm91bmRpbmdCb3goIGJiMSwgYmIyLngxLCBiYjIueTEgKVxuICAgICYmIG1hdGguaW5Cb3VuZGluZ0JveCggYmIxLCBiYjIueDIsIGJiMi55MiApXG4gICk7XG59O1xuXG5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKXtcblxuICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyggd2lkdGgsIGhlaWdodCApO1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UgKTtcblxuICAgIGlmKCBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgKXtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICB2YXIgcmlnaHRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSApO1xuXG4gICAgaWYoIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAge1xuICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlICk7XG5cbiAgICBpZiggc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICl7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSApO1xuXG4gICAgaWYoIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3AgTGVmdFxuICB7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcgKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmKCBhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkgKXtcbiAgICAgIHJldHVybiBbIGFyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV0gXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZICl7XG4gICAgICByZXR1cm4gWyBhcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdIF07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIFJpZ2h0XG4gIHtcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLFxuICAgICAgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcgKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmKCBhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSApe1xuICAgICAgcmV0dXJuIFsgYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXSBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBMZWZ0XG4gIHtcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSApe1xuICAgICAgcmV0dXJuIFsgYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcblxubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uKCB4LCB5LCBseDEsIGx5MSwgbHgyLCBseTIsIHRvbGVyYW5jZSApe1xuICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICB2YXIgeDEgPSBNYXRoLm1pbiggbHgxLCBseDIgKTtcbiAgdmFyIHgyID0gTWF0aC5tYXgoIGx4MSwgbHgyICk7XG4gIHZhciB5MSA9IE1hdGgubWluKCBseTEsIGx5MiApO1xuICB2YXIgeTIgPSBNYXRoLm1heCggbHkxLCBseTIgKTtcblxuICByZXR1cm4geDEgLSB0IDw9IHggJiYgeCA8PSB4MiArIHRcbiAgICAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG5cbm1hdGguaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uKFxuICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UgKXtcblxuICB2YXIgYmIgPSB7XG4gICAgeDE6IE1hdGgubWluKCB4MSwgeDMsIHgyICkgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KCB4MSwgeDMsIHgyICkgKyB0b2xlcmFuY2UsXG4gICAgeTE6IE1hdGgubWluKCB5MSwgeTMsIHkyICkgLSB0b2xlcmFuY2UsXG4gICAgeTI6IE1hdGgubWF4KCB5MSwgeTMsIHkyICkgKyB0b2xlcmFuY2VcbiAgfTtcblxuICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgaWYoIHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55MiApe1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxubWF0aC5zb2x2ZUN1YmljID0gZnVuY3Rpb24oIGEsIGIsIGMsIGQsIHJlc3VsdCApe1xuXG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG5cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcblxuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuXG4gIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgciAvPSA1NC4wO1xuXG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IChiIC8gMy4wKTtcblxuICBpZiggZGlzY3JpbWluYW50ID4gMCApe1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKTtcbiAgICBzID0gKChzIDwgMCkgPyAtTWF0aC5wb3coIC1zLCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHMsICgxLjAgLyAzLjApICkpO1xuICAgIHQgPSByIC0gTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKTtcbiAgICB0ID0gKCh0IDwgMCkgPyAtTWF0aC5wb3coIC10LCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHQsICgxLjAgLyAzLjApICkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KCAzLjAgKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcblxuICBpZiggZGlzY3JpbWluYW50ID09PSAwICl7XG4gICAgcjEzID0gKChyIDwgMCkgPyAtTWF0aC5wb3coIC1yLCAoMS4wIC8gMy4wKSApIDogTWF0aC5wb3coIHIsICgxLjAgLyAzLjApICkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MoIHIgLyBNYXRoLnNxcnQoIGR1bTEgKSApO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQoIHEgKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIGR1bTEgLyAzLjAgKTtcbiAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjAgKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoIChkdW0xICsgNC4wICogTWF0aC5QSSkgLyAzLjAgKTtcblxuICByZXR1cm47XG59O1xuXG5tYXRoLnNxZGlzdFRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24oXG4gIHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMgKXtcblxuICAvLyBGaW5kIG1pbmltdW0gZGlzdGFuY2UgYnkgdXNpbmcgdGhlIG1pbmltdW0gb2YgdGhlIGRpc3RhbmNlXG4gIC8vIGZ1bmN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50IGFuZCB0aGUgY3VydmVcblxuICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG5cbiAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzXG4gICAgKyB5MSAqIHkxIC0gNCAqIHkxICogeTIgKyAyICogeTEgKiB5MyArIDQgKiB5MiAqIHkyIC0gNCAqIHkyICogeTMgKyB5MyAqIHkzO1xuXG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4M1xuICAgICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcblxuICB2YXIgYyA9IDEuMCAqIDMgKiB4MSAqIHgxIC0gNiAqIHgxICogeDIgKyB4MSAqIHgzIC0geDEgKiB4ICsgMiAqIHgyICogeDIgKyAyICogeDIgKiB4IC0geDMgKiB4XG4gICAgKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcblxuICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4XG4gICAgKyB5MSAqIHkyIC0geTEgKiB5MSArIHkxICogeSAtIHkyICogeTtcblxuICAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107XG5cbiAgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuICB0aGlzLnNvbHZlQ3ViaWMoIGEsIGIsIGMsIGQsIHJvb3RzICk7XG5cbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG5cbiAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gIGZvciggdmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyICl7XG4gICAgaWYoIE1hdGguYWJzKCByb290c1sgaW5kZXggKyAxXSApIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAmJiByb290c1sgaW5kZXggXSA+PSAwXG4gICAgICAgICYmIHJvb3RzWyBpbmRleCBdIDw9IDEuMCApe1xuICAgICAgcGFyYW1zLnB1c2goIHJvb3RzWyBpbmRleCBdICk7XG4gICAgfVxuICB9XG5cbiAgcGFyYW1zLnB1c2goIDEuMCApO1xuICBwYXJhbXMucHVzaCggMC4wICk7XG5cbiAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICB2YXIgY2xvc2VzdFBhcmFtO1xuXG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKysgKXtcbiAgICBjdXJYID0gTWF0aC5wb3coIDEuMCAtIHBhcmFtc1sgaSBdLCAyLjAgKSAqIHgxXG4gICAgICArIDIuMCAqICgxIC0gcGFyYW1zWyBpIF0pICogcGFyYW1zWyBpIF0gKiB4MlxuICAgICAgKyBwYXJhbXNbIGkgXSAqIHBhcmFtc1sgaSBdICogeDM7XG5cbiAgICBjdXJZID0gTWF0aC5wb3coIDEgLSBwYXJhbXNbIGkgXSwgMi4wICkgKiB5MVxuICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1sgaSBdKSAqIHBhcmFtc1sgaSBdICogeTJcbiAgICAgICsgcGFyYW1zWyBpIF0gKiBwYXJhbXNbIGkgXSAqIHkzO1xuXG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyggY3VyWCAtIHgsIDIgKSArIE1hdGgucG93KCBjdXJZIC0geSwgMiApO1xuICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgIGlmKCBtaW5EaXN0YW5jZVNxdWFyZWQgPj0gMCApe1xuICAgICAgaWYoIGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkICl7XG4gICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbIGkgXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbIGkgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xufTtcblxubWF0aC5zcWRpc3RUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbiggeCwgeSwgeDEsIHkxLCB4MiwgeTIgKXtcbiAgdmFyIG9mZnNldCA9IFsgeCAtIHgxLCB5IC0geTEgXTtcbiAgdmFyIGxpbmUgPSBbIHgyIC0geDEsIHkyIC0geTEgXTtcblxuICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuXG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmKCBkb3RQcm9kdWN0IDwgMCApe1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmKCBhZGpTcSA+IGxpbmVTcSApe1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiggeCwgeSwgcG9pbnRzICl7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzO1xuXG4gIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgdmFyIHVwID0gMDtcbiAgdmFyIGRvd24gPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcblxuICAgIHgxID0gcG9pbnRzWyBpICogMl07XG4gICAgeTEgPSBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMiApe1xuICAgICAgeDIgPSBwb2ludHNbIChpICsgMSkgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHBvaW50c1sgKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1sgKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgIH1cblxuICAgIGlmKCB4MSA9PSB4ICYmIHgyID09IHggKXtcbiAgICAgIC8vIHRoZW4gaWdub3JlXG4gICAgfSBlbHNlIGlmKCAoeDEgPj0geCAmJiB4ID49IHgyKVxuICAgICAgfHwgKHgxIDw9IHggJiYgeCA8PSB4MikgKXtcblxuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICBpZiggeTMgPiB5ICl7XG4gICAgICAgIHVwKys7XG4gICAgICB9XG5cbiAgICAgIGlmKCB5MyA8IHkgKXtcbiAgICAgICAgZG93bisrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICB9XG5cbiAgaWYoIHVwICUgMiA9PT0gMCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nICl7XG5cbiAgLy92YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzWzZdO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoIGJhc2VQb2ludHMubGVuZ3RoICk7XG5cbiAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgdmFyIGFuZ2xlO1xuXG4gIGlmKCBkaXJlY3Rpb25bMF0gIT0gbnVsbCApe1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKCBkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0gKTtcblxuICAgIGlmKCBkaXJlY3Rpb25bMF0gPCAwICl7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgdmFyIGNvcyA9IE1hdGguY29zKCAtYW5nbGUgKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKCAtYW5nbGUgKTtcblxuICAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSA9XG4gICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1sgaSAqIDJdICogY29zXG4gICAgICAgIC0gYmFzZVBvaW50c1sgaSAqIDIgKyAxXSAqIHNpbik7XG5cbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDIgKyAxXSA9XG4gICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbIGkgKiAyICsgMV0gKiBjb3NcbiAgICAgICAgKyBiYXNlUG9pbnRzWyBpICogMl0gKiBzaW4pO1xuXG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzWyBpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmKCBwYWRkaW5nID4gMCApe1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSB0aGlzLmV4cGFuZFBvbHlnb24oXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgIC1wYWRkaW5nICk7XG5cbiAgICBwb2ludHMgPSB0aGlzLmpvaW5MaW5lcyggZXhwYW5kZWRMaW5lU2V0ICk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cblxuICByZXR1cm4gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHBvaW50cyApO1xufTtcblxubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbiggbGluZVNldCApe1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheSggbGluZVNldC5sZW5ndGggLyAyICk7XG5cbiAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKysgKXtcbiAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbIGkgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbIGkgKiA0ICsgMV07XG4gICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFsgaSAqIDQgKyAyXTtcbiAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0WyBpICogNCArIDNdO1xuXG4gICAgaWYoIGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxICl7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbIChpICsgMSkgKiA0XTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsgKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbIChpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyAoaSArIDEpICogNCArIDNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbMF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFszXTtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSxcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLFxuICAgICAgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksXG4gICAgICB0cnVlICk7XG5cbiAgICB2ZXJ0aWNlc1sgaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgIHZlcnRpY2VzWyBpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcblxubWF0aC5leHBhbmRQb2x5Z29uID0gZnVuY3Rpb24oIHBvaW50cywgcGFkICl7XG5cbiAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheSggcG9pbnRzLmxlbmd0aCAqIDIgKTtcblxuICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcbiAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzWyBpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1sgaSAqIDIgKyAxXTtcblxuICAgIGlmKCBpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxICl7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyAoaSArIDEpICogMl07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cblxuICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cbiAgICB2YXIgb2Zmc2V0WCA9IChuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WSk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQoIG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkgKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG5cbiAgICBleHBhbmRlZExpbmVTZXRbIGkgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbIGkgKiA0ICsgMV0gPSBjdXJyZW50UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0WyBpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFsgaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xuXG5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24oXG4gIHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cyApe1xuXG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcblxuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG5cbiAgdmFyIGxlbiA9IE1hdGguc3FydCggZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkgKTtcblxuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICBpZiggbmV3TGVuZ3RoIDwgMCApe1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuXG4gIHJldHVybiBbIChjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5IF07XG59O1xuXG4vLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxubWF0aC5pbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24oXG4gIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgKXtcblxuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gWyB4MiAtIHgxLCB5MiAtIHkxIF07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgYyA9IFsgY2VudGVyWCwgY2VudGVyWSBdOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gIHZhciBmID0gWyB4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWSBdO1xuXG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IChmWzBdICogZlswXSArIGZbMV0gKiBmWzFdKSAtIHJhZGl1cyAqIHJhZGl1cyA7XG5cbiAgdmFyIGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gIGlmKCBkaXNjcmltaW5hbnQgPCAwICl7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KCBkaXNjcmltaW5hbnQgKSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoIGRpc2NyaW1pbmFudCApKSAvICgyICogYSk7XG5cbiAgdmFyIHRNaW4gPSBNYXRoLm1pbiggdDEsIHQyICk7XG4gIHZhciB0TWF4ID0gTWF0aC5tYXgoIHQxLCB0MiApO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmKCB0TWluID49IDAgJiYgdE1pbiA8PSAxICl7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKCB0TWluICk7XG4gIH1cblxuICBpZiggdE1heCA+PSAwICYmIHRNYXggPD0gMSApe1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCggdE1heCApO1xuICB9XG5cbiAgaWYoIGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwICl7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcblxuICBpZiggaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxICl7XG5cbiAgICBpZiggaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdICl7XG4gICAgICByZXR1cm4gWyBuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblkgXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG5cbiAgICAgIHJldHVybiBbIG5lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWSBdO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbIG5lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSBdO1xuICB9XG5cbn07XG5cbm1hdGguZmluZENpcmNsZU5lYXJQb2ludCA9IGZ1bmN0aW9uKCBjZW50ZXJYLCBjZW50ZXJZLFxuICByYWRpdXMsIGZhclgsIGZhclkgKXtcblxuICB2YXIgZGlzcGxhY2VtZW50WCA9IGZhclggLSBjZW50ZXJYO1xuICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGRpc3BsYWNlbWVudFggKiBkaXNwbGFjZW1lbnRYXG4gICAgKyBkaXNwbGFjZW1lbnRZICogZGlzcGxhY2VtZW50WSApO1xuXG4gIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgdmFyIHVuaXREaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50WSAvIGRpc3RhbmNlO1xuXG4gIHJldHVybiBbIGNlbnRlclggKyB1bml0RGlzcGxhY2VtZW50WCAqIHJhZGl1cyxcbiAgICBjZW50ZXJZICsgdW5pdERpc3BsYWNlbWVudFkgKiByYWRpdXMgXTtcbn07XG5cbm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcbiAgdmFyIG1heFNxRGlzdGFuY2UgPSAwLjAwMDAwMTtcbiAgdmFyIHNxRGlzdGFuY2U7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG5cbiAgICBzcURpc3RhbmNlID0gcG9pbnRzWyBpICogMl0gKiBwb2ludHNbIGkgKiAyXVxuICAgICAgKyBwb2ludHNbIGkgKiAyICsgMV0gKiBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UgKXtcbiAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhTcURpc3RhbmNlO1xufTtcblxubWF0aC5taWRPZlRocmVlID0gZnVuY3Rpb24oIGEsIGIsIGMgKXtcbiAgaWYoIChiIDw9IGEgJiYgYSA8PSBjKSB8fCAoYyA8PSBhICYmIGEgPD0gYikgKXtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmKCAoYSA8PSBiICYmIGIgPD0gYykgfHwgKGMgPD0gYiAmJiBiIDw9IGEpICl7XG4gICAgcmV0dXJuIGI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn07XG5cbm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiggeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzICl7XG5cbiAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gIHZhciBkeDQzID0geDQgLSB4MztcblxuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuXG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iICA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG5cbiAgaWYoIHVfYiAhPT0gMCApe1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcblxuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG4gICAgdmFyIG1pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuICAgIHZhciBtYXggPSAxICsgZmxwdFRocmVzaG9sZDtcblxuICAgIGlmKCBtaW4gPD0gdWEgJiYgdWEgPD0gbWF4ICYmIG1pbiA8PSB1YiAmJiB1YiA8PSBtYXggKXtcbiAgICAgIHJldHVybiBbIHgxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMSBdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCAhaW5maW5pdGVMaW5lcyApe1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWyB4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjEgXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYoIHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCApe1xuXG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYoIHRoaXMubWlkT2ZUaHJlZSggeDEsIHgyLCB4NCApID09PSB4NCApe1xuICAgICAgICByZXR1cm4gWyB4NCwgeTQgXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmKCB0aGlzLm1pZE9mVGhyZWUoIHgxLCB4MiwgeDMgKSA9PT0geDMgKXtcbiAgICAgICAgcmV0dXJuIFsgeDMsIHkzIF07XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICAgIGlmKCB0aGlzLm1pZE9mVGhyZWUoIHgzLCB4NCwgeDIgKSA9PT0geDIgKXtcbiAgICAgICAgcmV0dXJuIFsgeDIsIHkyIF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07XG5cbm1hdGgucG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApe1xuXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG5cbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KCBiYXNlUG9pbnRzLmxlbmd0aCApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyXSA9IGJhc2VQb2ludHNbIGkgKiAyXSAqIHdpZHRoICsgY2VudGVyWDtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbIGkgKiAyICsgMV0gKiBoZWlnaHQgKyBjZW50ZXJZO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiggcGFkZGluZyA+IDAgKXtcbiAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbWF0aC5leHBhbmRQb2x5Z29uKFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAtcGFkZGluZyApO1xuXG4gICAgcG9pbnRzID0gbWF0aC5qb2luTGluZXMoIGV4cGFuZGVkTGluZVNldCApO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICB9XG4gIC8vIHZhciBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcblxuICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG5cbiAgICBjdXJyZW50WCA9IHBvaW50c1sgaSAqIDJdO1xuICAgIGN1cnJlbnRZID0gcG9pbnRzWyBpICogMiArIDFdO1xuXG4gICAgaWYoIGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEgKXtcbiAgICAgIG5leHRYID0gcG9pbnRzWyAoaSArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1sgKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgIGN1cnJlbnRYLCBjdXJyZW50WSxcbiAgICAgIG5leHRYLCBuZXh0WSApO1xuXG4gICAgaWYoIGludGVyc2VjdGlvbi5sZW5ndGggIT09IDAgKXtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaCggaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG5cbm1hdGguc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKFxuICBpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50ICl7XG5cbiAgdmFyIGRpc3AgPSBbIGludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdIF07XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCggZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSApO1xuXG4gIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuXG4gIGlmKCBsZW5SYXRpbyA8IDAgKXtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cblxuICByZXR1cm4gWyBvZmZzZXRbMF0gKyBsZW5SYXRpbyAqIGRpc3BbMF0sIG9mZnNldFsxXSArIGxlblJhdGlvICogZGlzcFsxXSBdO1xufTtcblxubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiggc2lkZXMsIHJvdGF0aW9uUmFkaWFucyApe1xuICB2YXIgcG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKCBzaWRlcywgcm90YXRpb25SYWRpYW5zICk7XG4gIHBvaW50cyA9IG1hdGguZml0UG9seWdvblRvU3F1YXJlKCBwb2ludHMgKTtcblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbiggcG9pbnRzICl7XG4gIHZhciB4LCB5O1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKyApe1xuICAgIHggPSBwb2ludHNbMiAqIGkgXTtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV07XG5cbiAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICBtaW5ZID0gTWF0aC5taW4oIG1pblksIHkgKTtcbiAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgfVxuXG4gIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrICl7XG4gICAgeCA9IHBvaW50c1syICogaSBdID0gcG9pbnRzWzIgKiBpIF0gKiBzeDtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSAqIHN5O1xuXG4gICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgbWF4WCA9IE1hdGgubWF4KCBtYXhYLCB4ICk7XG4gICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gIH1cblxuICBpZiggbWluWSA8IC0xICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrICl7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSArICgtMSAtIG1pblkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiggc2lkZXMsIHJvdGF0aW9uUmFkaWFucyApe1xuXG4gIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/XG4gICAgTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gIC8vICAgIGNvbnNvbGUubG9nKG5vZGVTaGFwZXNbJ3NxdWFyZSddKTtcbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG5cbiAgdmFyIHBvaW50cyA9IG5ldyBBcnJheSggc2lkZXMgKiAyICk7XG5cbiAgdmFyIGN1cnJlbnRBbmdsZSwgeCwgeTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrICl7XG4gICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG5cbiAgICB4ID0gcG9pbnRzWzIgKiBpIF0gPSBNYXRoLmNvcyggY3VycmVudEFuZ2xlICk7Ly8gKiAoMSArIGkvMik7XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oIC1jdXJyZW50QW5nbGUgKTsvLyAgKiAoMSArIGkvMik7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICl7XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1cywgdW5sZXNzIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBkZWZhdWx0XG4gIHJldHVybiBNYXRoLm1pbiggd2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4ICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGg7XG4iLCIvKiFcbkVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG5MaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HICAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xudmFyIFNUQVRFX1JFSkVDVEVEICA9IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xudmFyIGFwaSA9IGZ1bmN0aW9uKCBleGVjdXRvciApe1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgYXBpKSApXG4gICAgcmV0dXJuIG5ldyBhcGkoIGV4ZWN1dG9yICk7XG5cbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICB0aGlzLmlkICAgICAgICAgICA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gIHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgdmFsdWUgICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgcmVhc29uICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG4gIHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gIHRoaXMub25SZWplY3RlZCAgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKCB0aGlzIClcbiAgfTtcblxuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cbiAgaWYoIHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgZXhlY3V0b3IuY2FsbCggdGhpcywgdGhpcy5mdWxmaWxsLmJpbmQoIHRoaXMgKSwgdGhpcy5yZWplY3QuYmluZCggdGhpcyApICk7XG59O1xuXG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cbmFwaS5wcm90b3R5cGUgPSB7XG4gIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICBmdWxmaWxsOiBmdW5jdGlvbiggdmFsdWUgKXsgcmV0dXJuIGRlbGl2ZXIoIHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlICk7IH0sXG4gIHJlamVjdDogIGZ1bmN0aW9uKCB2YWx1ZSApeyByZXR1cm4gZGVsaXZlciggdGhpcywgU1RBVEVfUkVKRUNURUQsICAncmVqZWN0UmVhc29uJywgdmFsdWUgKTsgfSxcblxuICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gIHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApe1xuICAgIHZhciBjdXJyID0gdGhpcztcbiAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2goXG4gICAgICByZXNvbHZlciggb25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJyApICk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuICAgIGN1cnIub25SZWplY3RlZC5wdXNoKFxuICAgICAgcmVzb2x2ZXIoIG9uUmVqZWN0ZWQsICBuZXh0LCAncmVqZWN0JyApICk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgIGV4ZWN1dGUoIGN1cnIgKTtcbiAgICByZXR1cm4gbmV4dC5wcm94eTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICB9XG59O1xuXG4vKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG52YXIgZGVsaXZlciA9IGZ1bmN0aW9uKCBjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUgKXtcbiAgaWYoIGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcgKXtcbiAgICBjdXJyLnN0YXRlID0gc3RhdGU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuICAgIGN1cnJbIG5hbWUgXSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICBleGVjdXRlKCBjdXJyICk7XG4gIH1cbiAgcmV0dXJuIGN1cnI7XG59O1xuXG4vKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKCBjdXJyICl7XG4gIGlmKCBjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQgKVxuICAgIGV4ZWN1dGVfaGFuZGxlcnMoIGN1cnIsICdvbkZ1bGZpbGxlZCcsIGN1cnIuZnVsZmlsbFZhbHVlICk7XG4gIGVsc2UgaWYoIGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEIClcbiAgICBleGVjdXRlX2hhbmRsZXJzKCBjdXJyLCAnb25SZWplY3RlZCcsICBjdXJyLnJlamVjdFJlYXNvbiApO1xufTtcblxuLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uKCBjdXJyLCBuYW1lLCB2YWx1ZSApe1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgaWYoIGN1cnJbIG5hbWUgXS5sZW5ndGggPT09IDAgKVxuICAgIHJldHVybjtcblxuICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuICB2YXIgaGFuZGxlcnMgPSBjdXJyWyBuYW1lIF07XG4gIGN1cnJbIG5hbWUgXSA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG4gIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrIClcbiAgICAgIGhhbmRsZXJzWyBpIF0oIHZhbHVlICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICBpZiggdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgc2V0SW1tZWRpYXRlKCBmdW5jICk7XG4gIGVsc2VcbiAgICBzZXRUaW1lb3V0KCBmdW5jLCAwICk7XG59O1xuXG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uKCBjYiwgbmV4dCwgbWV0aG9kICl7XG4gIHJldHVybiBmdW5jdGlvbiggdmFsdWUgKXtcbiAgICBpZiggdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0WyBtZXRob2QgXS5jYWxsKCBuZXh0LCB2YWx1ZSApOyAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHRyeSB7IHJlc3VsdCA9IGNiKCB2YWx1ZSApOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgY2F0Y2goIGUgKXtcbiAgICAgICAgbmV4dC5yZWplY3QoIGUgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSggbmV4dCwgcmVzdWx0ICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgfVxuICB9O1xufTtcblxuLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbnZhciByZXNvbHZlID0gZnVuY3Rpb24oIHByb21pc2UsIHggKXtcbiAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiggcHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4ICl7XG4gICAgcHJvbWlzZS5yZWplY3QoIG5ldyBUeXBlRXJyb3IoICdjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJyApICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cbiAgdmFyIHRoZW47XG4gIGlmKCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICl7XG4gICAgdHJ5IHsgdGhlbiA9IHgudGhlbjsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgIGNhdGNoKCBlICl7XG4gICAgICBwcm9taXNlLnJlamVjdCggZSApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgaWYoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICl7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKCB4LFxuICAgICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgICBmdW5jdGlvbiggeSApe1xuICAgICAgICAgIGlmKCByZXNvbHZlZCApIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgaWYoIHkgPT09IHggKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KCBuZXcgVHlwZUVycm9yKCAnY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nICkgKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXNvbHZlKCBwcm9taXNlLCB5ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogIHJlamVjdFByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4yXSAgKi9cbiAgICAgICAgZnVuY3Rpb24oIHIgKXtcbiAgICAgICAgICBpZiggcmVzb2x2ZWQgKSByZXR1cm47IHJlc29sdmVkID0gdHJ1ZTsgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KCByICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoKCBlICl7XG4gICAgICBpZiggIXJlc29sdmVkICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KCBlICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG4gIHByb21pc2UuZnVsZmlsbCggeCApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTtcblxuLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuYXBpLmFsbCA9IGZ1bmN0aW9uKCBwcyApe1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiggcmVzb2x2ZUFsbCwgcmVqZWN0QWxsICl7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkoIHBzLmxlbmd0aCApO1xuICAgIHZhciBkb25lQ291bnQgPSAwO1xuXG4gICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiggaSwgdmFsICl7XG4gICAgICB2YWxzWyBpIF0gPSB2YWw7XG4gICAgICBkb25lQ291bnQrKztcblxuICAgICAgaWYoIGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoICl7XG4gICAgICAgIHJlc29sdmVBbGwoIHZhbHMgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKyApe1xuICAgICAgKGZ1bmN0aW9uKCBpICl7XG4gICAgICAgIHZhciBwID0gcHNbaV07XG4gICAgICAgIHZhciBpc1Byb21pc2UgPSBwICE9IG51bGwgJiYgcC50aGVuICE9IG51bGw7XG5cbiAgICAgICAgaWYoIGlzUHJvbWlzZSApe1xuICAgICAgICAgIHAudGhlbiggZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oIGVyciApe1xuICAgICAgICAgICAgcmVqZWN0QWxsKCBlcnIgKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHA7XG4gICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgIH1cbiAgICAgIH0pKCBpICk7XG4gICAgfVxuXG4gIH0gKTtcbn07XG5cbmFwaS5yZXNvbHZlID0gZnVuY3Rpb24oIHZhbCApe1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7IHJlc29sdmUoIHZhbCApOyB9KTtcbn07XG5cbmFwaS5yZWplY3QgPSBmdW5jdGlvbiggdmFsICl7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXsgcmVqZWN0KCB2YWwgKTsgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTZWxlY3RvcikgKXtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKCBzZWxlY3RvciApO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuX3ByaXZhdGUgPSB7XG4gICAgc2VsZWN0b3JUZXh0OiBudWxsLFxuICAgIGludmFsaWQ6IHRydWVcbiAgfTtcblxuICAvLyBzdG9yYWdlIGZvciBwYXJzZWQgcXVlcmllc1xuICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBbXSxcbiAgICAgIGNvbG9uU2VsZWN0b3JzOiBbXSxcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICBpZHM6IFtdLFxuICAgICAgbWV0YTogW10sXG5cbiAgICAgIC8vIGZha2Ugc2VsZWN0b3JzXG4gICAgICBjb2xsZWN0aW9uOiBudWxsLCAvLyBhIGNvbGxlY3Rpb24gdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgZmlsdGVyOiBudWxsLCAvLyBmaWx0ZXIgZnVuY3Rpb25cblxuICAgICAgLy8gdGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIHVwd2FyZCBkaXJlY3Rpb24gcmF0aGVyIHRoYW4gZG93biAoZS5nLiBjaGlsZClcbiAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyB1cCBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcXVlcnkgb2JqXG4gICAgICBhbmNlc3RvcjogbnVsbCwgLy8gYW5jZXN0b3IgcXVlcnkgb2JqXG4gICAgICBzdWJqZWN0OiBudWxsLCAvLyBkZWZpbmVzIHN1YmplY3QgaW4gY29tcG91bmQgcXVlcnkgKHN1YmplY3QgcXVlcnkgb2JqOyBwb2ludHMgdG8gc2VsZiBpZiBzdWJqZWN0KVxuXG4gICAgICAvLyB1c2UgdGhlc2Ugb25seSB3aGVuIHN1YmplY3QgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAgY2hpbGQ6IG51bGwsXG4gICAgICBkZXNjZW5kYW50OiBudWxsXG4gICAgfTtcbiAgfTtcblxuICBpZiggIXNlbGVjdG9yIHx8ICggaXMuc3RyaW5nKCBzZWxlY3RvciApICYmIHNlbGVjdG9yLm1hdGNoKCAvXlxccyokLyApICkgKXtcblxuICAgIHNlbGYubGVuZ3RoID0gMDtcblxuICB9IGVsc2UgaWYoIHNlbGVjdG9yID09PSAnKicgfHwgc2VsZWN0b3IgPT09ICdlZGdlJyB8fCBzZWxlY3RvciA9PT0gJ25vZGUnICl7XG5cbiAgICAvLyBtYWtlIHNpbmdsZSwgZ3JvdXAtb25seSBzZWxlY3RvcnMgY2hlYXAgdG8gbWFrZSBhbmQgY2hlYXAgdG8gZmlsdGVyXG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmdyb3VwID0gc2VsZWN0b3IgPT09ICcqJyA/IHNlbGVjdG9yIDogc2VsZWN0b3IgKyAncyc7XG4gICAgc2VsZlswXS5ncm91cE9ubHkgPSB0cnVlO1xuICAgIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xuICAgIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIH0gZWxzZSBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggc2VsZWN0b3IgKSApe1xuXG4gICAgdmFyIGNvbGxlY3Rpb24gPSBzZWxlY3Rvci5jb2xsZWN0aW9uKCk7XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcblxuICB9IGVsc2UgaWYoIGlzLmZuKCBzZWxlY3RvciApICl7XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmZpbHRlciA9IHNlbGVjdG9yO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcblxuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggc2VsZWN0b3IgKSApe1xuXG4gICAgLy8gdGhlIGN1cnJlbnQgc3ViamVjdCBpbiB0aGUgcXVlcnlcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBudWxsO1xuXG4gICAgLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxuICAgIHZhciB0b2tlbnMgPSB7XG4gICAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIHZhciBuYW1lcywgZXRjXG4gICAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJywgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkrXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKydcIiwgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICAgIG51bWJlcjogdXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgICAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLCAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICAgICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICAgIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gICAgICBzdWJqZWN0OiAnXFxcXCQnXG4gICAgfTtcbiAgICB0b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuICAgIHRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcbiAgICB0b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG4gICAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gICAgLy8gd2hlbiBhIHRva2VuIGxpa2UgYSB2YXJpYWJsZSBoYXMgZXNjYXBlZCBtZXRhIGNoYXJhY3RlcnMsIHdlIG5lZWQgdG8gY2xlYW4gdGhlIGJhY2tzbGFzaGVzIG91dFxuICAgIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSggbmV3IFJlZ0V4cCggJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyApLCBmdW5jdGlvbiggbWF0Y2gsICQxLCBvZmZzZXQsIG9yaWdpbmFsICl7XG4gICAgICAgIHJldHVybiAkMTtcbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoICd8JyApO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgb3AgPSBvcHNbIGkgXTtcbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgIH1cblxuICAgIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCAnfCcgKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG9wID0gb3BzWyBpIF07XG5cbiAgICAgIGlmKCBvcC5pbmRleE9mKCAnIScgKSA+PSAwICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICAgIGlmKCBvcCA9PT0gJz0nICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4gICAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gICAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZltpXSAtLS0geW91IGNhbiB1c2UgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIHBvcHVsYXRlIGZ1bmN0aW9uO1xuICAgIC8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gU2VsZWN0b3IuZmlsdGVyKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuICAgIC8vIC0gd2hlbiB5b3UgYWRkIHNvbWV0aGluZyBoZXJlLCBhbHNvIGFkZCB0byBTZWxlY3Rvci50b1N0cmluZygpXG4gICAgdmFyIGV4cHJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnZ3JvdXAnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICcobm9kZXxlZGdlfFxcXFwqKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXAgPT09ICcqJyA/IGdyb3VwIDogZ3JvdXAgKyAncyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3N0YXRlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIC8vIE5COiBpZiBvbmUgY29sb24gc2VsZWN0b3IgaXMgYSBzdWJzdHJpbmcgb2YgYW5vdGhlciBmcm9tIGl0cyBzdGFydCwgcGxhY2UgdGhlIGxvbmdlciBvbmUgZmlyc3RcbiAgICAgICAgLy8gZS5nLiA6Zm9vYmFyfDpmb29cbiAgICAgICAgcmVnZXg6ICcoOnNlbGVjdGVkfDp1bnNlbGVjdGVkfDpsb2NrZWR8OnVubG9ja2VkfDp2aXNpYmxlfDpoaWRkZW58OnRyYW5zcGFyZW50fDpncmFiYmVkfDpmcmVlfDpyZW1vdmVkfDppbnNpZGV8OmdyYWJiYWJsZXw6dW5ncmFiYmFibGV8OmFuaW1hdGVkfDp1bmFuaW1hdGVkfDpzZWxlY3RhYmxlfDp1bnNlbGVjdGFibGV8Om9ycGhhbnw6bm9ub3JwaGFufDpwYXJlbnR8OmNoaWxkfDpsb29wfDpzaW1wbGV8OmFjdGl2ZXw6aW5hY3RpdmV8OnRvdWNofDpiYWNrZ3JvdW5kaW5nfDpub25iYWNrZ3JvdW5kaW5nKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggc3RhdGUgKXtcbiAgICAgICAgICB0aGlzLmNvbG9uU2VsZWN0b3JzLnB1c2goIHN0YXRlICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICAgIHRoaXMuaWRzLnB1c2goIGNsZWFuTWV0YUNoYXJzKCBpZCApICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsYXNzTmFtZScsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFwuKCcgKyB0b2tlbnMuY2xhc3NOYW1lICsgJyknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xuICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCBjbGVhbk1ldGFDaGFycyggY2xhc3NOYW1lICkgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSApe1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKCB7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMoIHZhcmlhYmxlIClcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlLCBjb21wYXJhdG9yT3AsIHZhbHVlICl7XG4gICAgICAgICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCAnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnICkuZXhlYyggdmFsdWUgKSAhPSBudWxsO1xuXG4gICAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKCAxLCB2YWx1ZS5sZW5ndGggLSAxICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCgge1xuICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKCB2YXJpYWJsZSApLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUJvb2wnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLmJvb2xPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBib29sT3AsIHZhcmlhYmxlICl7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goIHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyggdmFyaWFibGUgKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21ldGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignICsgdG9rZW5zLm1ldGEgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMubnVtYmVyICsgJylcXFxccypcXFxcXVxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBtZXRhLCBjb21wYXJhdG9yT3AsIG51bWJlciApe1xuICAgICAgICAgIHRoaXMubWV0YS5wdXNoKCB7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMoIG1ldGEgKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCggbnVtYmVyIClcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ25leHRRdWVyeScsXG4gICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICAgICAgICBzZWxmWyArK2kgXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjaGlsZCcsXG4gICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgcGFyZW50IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICB2YXIgY2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgY2hpbGRRdWVyeS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgIGNoaWxkUXVlcnkuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuXG4gICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICBzZWxmWyBpIF0gPSBjaGlsZFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICB2YXIgZGVzY2VuZGFudFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgc2VsZlsgaSBdID0gZGVzY2VuZGFudFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzdWJqZWN0JyxcbiAgICAgICAgbW9kaWZpZXI6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoIGN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgdGhpcy5zdWJqZWN0ICE9IHRoaXMgKXtcbiAgICAgICAgICAgIHV0aWwuZXJyb3IoICdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AnICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFN1YmplY3QgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuc3ViamVjdCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIF07XG5cbiAgICBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIHZhciByZW1haW5pbmcgPSBzZWxlY3RvcjtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvLyBvZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHRcbiAgICB2YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiggZXhwZWN0YXRpb24gKXtcbiAgICAgIHZhciBleHByO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIG5hbWU7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGUgPSBleHByc1sgaiBdO1xuICAgICAgICB2YXIgbiA9IGUubmFtZTtcblxuICAgICAgICAvLyBpZ25vcmUgdGhpcyBleHByZXNzaW9uIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgZXhwZWN0YXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYoIGlzLmZuKCBleHBlY3RhdGlvbiApICYmICFleHBlY3RhdGlvbiggbiwgZSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goIG5ldyBSZWdFeHAoICdeJyArIGUucmVnZXggKSApO1xuXG4gICAgICAgIGlmKCBtICE9IG51bGwgKXtcbiAgICAgICAgICBtYXRjaCA9IG07XG4gICAgICAgICAgZXhwciA9IGU7XG4gICAgICAgICAgbmFtZSA9IG47XG5cbiAgICAgICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuXG4gICAgICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cHI6IGV4cHIsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gY29uc3VtZSBhbGwgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgdmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCggL15cXHMrLyApO1xuXG4gICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTsgLy8gZ2V0IHN0YXJ0ZWRcblxuICAgIGNvbnN1bWVXaGl0ZXNwYWNlKCk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgZm9yKCA7OyApe1xuICAgICAgdmFyIGNoZWNrID0gY29uc3VtZUV4cHIoKTtcblxuICAgICAgaWYoIGNoZWNrLmV4cHIgPT0gbnVsbCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYGlzIGludmFsaWQnICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciggdmFyIGogPSAxOyBqIDwgY2hlY2subWF0Y2gubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICBhcmdzLnB1c2goIGNoZWNrLm1hdGNoWyBqIF0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCAoaS5lLiBpbiBzZWxmW2ldKVxuICAgICAgICB2YXIgcmV0ID0gY2hlY2suZXhwci5wb3B1bGF0ZS5hcHBseSggc2VsZlsgaSBdLCBhcmdzICk7XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgcmV0dXJuOyB9IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgIH1cblxuICAgICAgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG4gICAgICBpZiggcmVtYWluaW5nLm1hdGNoKCAvXlxccyokLyApICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYubGVuZ3RoID0gaSArIDE7XG5cbiAgICAvLyBhZGp1c3QgcmVmZXJlbmNlcyBmb3Igc3ViamVjdFxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZlsgaiBdO1xuXG4gICAgICBpZiggcXVlcnkuc3ViamVjdCAhPSBudWxsICl7XG4gICAgICAgIC8vIGdvIHVwIHRoZSB0cmVlIHVudGlsIHdlIHJlYWNoIHRoZSBzdWJqZWN0XG4gICAgICAgIGZvciggOzsgKXtcbiAgICAgICAgICBpZiggcXVlcnkuc3ViamVjdCA9PSBxdWVyeSApeyBicmVhazsgfSAvLyBkb25lIGlmIHN1YmplY3QgaXMgc2VsZlxuXG4gICAgICAgICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7IC8vIHN3YXAgcGFyZW50L2NoaWxkIHJlZmVyZW5jZVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHF1ZXJ5LnBhcmVudDtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkID0gY2hpbGQ7XG5cbiAgICAgICAgICAgIHF1ZXJ5ID0gcGFyZW50OyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgIH0gZWxzZSBpZiggcXVlcnkuYW5jZXN0b3IgIT0gbnVsbCApeyAvLyBzd2FwIGFuY2VzdG9yL2Rlc2NlbmRhbnRcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHF1ZXJ5LmFuY2VzdG9yO1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSBxdWVyeTtcblxuICAgICAgICAgICAgZGVzY2VuZGFudC5hbmNlc3RvciA9IG51bGw7XG4gICAgICAgICAgICBhbmNlc3Rvci5kZXNjZW5kYW50ID0gZGVzY2VuZGFudDtcblxuICAgICAgICAgICAgcXVlcnkgPSBhbmNlc3RvcjsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5lcnJvciggJ1doZW4gYWRqdXN0aW5nIHJlZmVyZW5jZXMgZm9yIHRoZSBzZWxlY3RvciBgJyArIHF1ZXJ5ICsgJ2AsIG5laXRoZXIgcGFyZW50IG5vciBhbmNlc3RvciB3YXMgZm91bmQnICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yXG5cbiAgICAgICAgc2VsZlsgaiBdID0gcXVlcnkuc3ViamVjdDsgLy8gc3ViamVjdCBzaG91bGQgYmUgdGhlIHJvb3QgcXVlcnlcbiAgICAgIH0gLy8gaWZcbiAgICB9IC8vIGZvclxuXG4gIH0gZWxzZSB7XG4gICAgdXRpbC5lcnJvciggJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcgKyBzZWxlY3RvciApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xuXG59O1xuXG52YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG5cbnNlbGZuLnNpemUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5zZWxmbi5lcSA9IGZ1bmN0aW9uKCBpICl7XG4gIHJldHVybiB0aGlzWyBpIF07XG59O1xuXG52YXIgcXVlcnlNYXRjaGVzID0gZnVuY3Rpb24oIHF1ZXJ5LCBlbGUgKXtcbiAgdmFyIGVsZV9wID0gZWxlLl9wcml2YXRlO1xuXG4gIC8vIG1ha2Ugc2luZ2xlIGdyb3VwLW9ubHkgc2VsZWN0b3JzIHJlYWxseSBjaGVhcCB0byBjaGVjayBzaW5jZSB0aGV5J3JlIHRoZSBtb3N0IGNvbW1vbiBvbmVzXG4gIGlmKCBxdWVyeS5ncm91cE9ubHkgKXtcbiAgICByZXR1cm4gcXVlcnkuZ3JvdXAgPT09ICcqJyB8fCBxdWVyeS5ncm91cCA9PT0gZWxlX3AuZ3JvdXA7XG4gIH1cblxuICAvLyBjaGVjayBncm91cFxuICBpZiggcXVlcnkuZ3JvdXAgIT0gbnVsbCAmJiBxdWVyeS5ncm91cCAhPSAnKicgJiYgcXVlcnkuZ3JvdXAgIT0gZWxlX3AuZ3JvdXAgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY3kgPSBlbGUuY3koKTtcblxuICAvLyBjaGVjayBjb2xvbiBzZWxlY3RvcnNcbiAgdmFyIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSB0cnVlO1xuICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLmxlbmd0aDsgaysrICl7XG4gICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzWyBrIF07XG5cbiAgICBzd2l0Y2goIHNlbCApe1xuICAgICAgY2FzZSAnOnNlbGVjdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5zZWxlY3RlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bnNlbGVjdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2VsZWN0YWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuc2VsZWN0YWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bnNlbGVjdGFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5zZWxlY3RhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmxvY2tlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVubG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnZpc2libGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLnZpc2libGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aGlkZGVuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0cmFuc3BhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUudHJhbnNwYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Z3JhYmJlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuZ3JhYmJlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpmcmVlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUuZ3JhYmJlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpyZW1vdmVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5yZW1vdmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluc2lkZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLnJlbW92ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Z3JhYmJhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5ncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6YW5pbWF0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmFuaW1hdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuYW5pbWF0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5hbmltYXRlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpwYXJlbnQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmlzTm9kZSgpICYmIGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmNoaWxkJzpcbiAgICAgIGNhc2UgJzpub25vcnBoYW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpvcnBoYW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpsb29wJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5pc0VkZ2UoKSAmJiBlbGUuZGF0YSggJ3NvdXJjZScgKSA9PT0gZWxlLmRhdGEoICd0YXJnZXQnICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnNpbXBsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuaXNFZGdlKCkgJiYgZWxlLmRhdGEoICdzb3VyY2UnICkgIT09IGVsZS5kYXRhKCAndGFyZ2V0JyApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzphY3RpdmUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzppbmFjdGl2ZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLmFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0b3VjaCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBpcy50b3VjaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpiYWNrZ3JvdW5kaW5nJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOm5vbmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIGJyZWFrO1xuICB9XG4gIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBjaGVjayBpZFxuICB2YXIgYWxsSWRzTWF0Y2ggPSB0cnVlO1xuICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyApe1xuICAgIHZhciBpZCA9IHF1ZXJ5Lmlkc1sgayBdO1xuICAgIHZhciBhY3R1YWxJZCA9IGVsZV9wLmRhdGEuaWQ7XG5cbiAgICBhbGxJZHNNYXRjaCA9IGFsbElkc01hdGNoICYmIChpZCA9PSBhY3R1YWxJZCk7XG5cbiAgICBpZiggIWFsbElkc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxJZHNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBjaGVjayBjbGFzc2VzXG4gIHZhciBhbGxDbGFzc2VzTWF0Y2ggPSB0cnVlO1xuICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBrKysgKXtcbiAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1sgayBdO1xuXG4gICAgYWxsQ2xhc3Nlc01hdGNoID0gYWxsQ2xhc3Nlc01hdGNoICYmIGVsZS5oYXNDbGFzcyggY2xzICk7XG5cbiAgICBpZiggIWFsbENsYXNzZXNNYXRjaCApIGJyZWFrO1xuICB9XG4gIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGdlbmVyaWMgY2hlY2tpbmcgZm9yIGRhdGEvbWV0YWRhdGFcbiAgdmFyIG9wZXJhbmRzTWF0Y2ggPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGFsbERhdGFNYXRjaGVzID0gdHJ1ZTtcbiAgICBmb3IoIHZhciBrID0gMDsgayA8IHF1ZXJ5WyBwYXJhbXMubmFtZSBdLmxlbmd0aDsgaysrICl7XG4gICAgICB2YXIgZGF0YSA9IHF1ZXJ5WyBwYXJhbXMubmFtZSBdWyBrIF07XG4gICAgICB2YXIgb3BlcmF0b3IgPSBkYXRhLm9wZXJhdG9yO1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICB2YXIgbWF0Y2hlcztcblxuICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuXG4gICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKCBmaWVsZCApO1xuICAgICAgICB2YXIgZmllbGRTdHIgPSAhaXMuc3RyaW5nKCBmaWVsZFZhbCApICYmICFpcy5udW1iZXIoIGZpZWxkVmFsICkgPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICAgIHZhciB2YWxTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICAgIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoICdAJyApID49IDAgKXtcbiAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoICdAJywgJycgKTtcbiAgICAgICAgICBjYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoICchJyApID49IDAgKXtcbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoICchJywgJycgKTtcbiAgICAgICAgICBub3RFeHByID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICAgICAgICBpZiggY2FzZUluc2Vuc2l0aXZlICl7XG4gICAgICAgICAgdmFsdWUgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoKCBvcGVyYXRvciApe1xuICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YoIHZhbFN0ciApID49IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZiggdmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoICkgPj0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKCB2YWxTdHIgKSA9PT0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIG5vdCBvcCwgYnV0IG51bGwgdmFscyBmb3IgaW5lcXVhbGl0aWVzIHNob3VsZCBhbHdheXMgc3RheSBub24tbWF0Y2hpbmdcbiAgICAgICAgaWYoIG5vdEV4cHIgJiYgKCBmaWVsZFZhbCAhPSBudWxsIHx8ICFpc0luZXFDbXAgKSApe1xuICAgICAgICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCBvcGVyYXRvciAhPSBudWxsICl7XG4gICAgICAgIHN3aXRjaCggb3BlcmF0b3IgKXtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFRydXRoeSggZmllbGQgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRUcnV0aHkoIGZpZWxkICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIG1hdGNoZXMgPSBwYXJhbXMuZmllbGRVbmRlZmluZWQoIGZpZWxkICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVW5kZWZpbmVkKCBmaWVsZCApO1xuICAgICAgfVxuXG4gICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgYWxsRGF0YU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJldHVybiBhbGxEYXRhTWF0Y2hlcztcbiAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuXG4gIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKCB7XG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgcmV0dXJuIGVsZV9wLmRhdGFbIGZpZWxkIF07XG4gICAgfSxcbiAgICBmaWVsZFVuZGVmaW5lZDogZnVuY3Rpb24oIGZpZWxkICl7XG4gICAgICByZXR1cm4gZWxlX3AuZGF0YVsgZmllbGQgXSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgaWYoIGVsZV9wLmRhdGFbIGZpZWxkIF0gKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9ICk7XG5cbiAgaWYoICFhbGxEYXRhTWF0Y2hlcyApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgdmFyIGFsbE1ldGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCgge1xuICAgIG5hbWU6ICdtZXRhJyxcbiAgICBmaWVsZFZhbHVlOiBmdW5jdGlvbiggZmllbGQgKXtcbiAgICAgIHJldHVybiBlbGVbIGZpZWxkIF0oKTtcbiAgICB9LFxuICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbiggZmllbGQgKXtcbiAgICAgIHJldHVybiBlbGVbIGZpZWxkIF0oKSA9PSBudWxsO1xuICAgIH0sXG4gICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgaWYoIGVsZVsgZmllbGQgXSgpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSApO1xuXG4gIGlmKCAhYWxsTWV0YU1hdGNoZXMgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjaGVjayBjb2xsZWN0aW9uXG4gIGlmKCBxdWVyeS5jb2xsZWN0aW9uICE9IG51bGwgKXtcbiAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZCggZWxlLmlkKCkgKTtcblxuICAgIGlmKCAhbWF0Y2hlc0FueSApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGZpbHRlciBmdW5jdGlvblxuICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlLmNvbGxlY3Rpb24oKS5maWx0ZXIoIHF1ZXJ5LmZpbHRlciApLnNpemUoKSA9PT0gMCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIHBhcmVudC9jaGlsZCByZWxhdGlvbnNcbiAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZXMgKXtcbiAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgaWYoICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcygpOyAvLyBzYXZlIGN5Y2xlcyBpZiBxdWVyeSA9PSBudWxsXG5cbiAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVzWyBpIF0gKSApe1xuICAgICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgaWYoICFjb25maXJtUmVsYXRpb25zKCBxdWVyeS5wYXJlbnQsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZS5wYXJlbnQoKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmKCAhY29uZmlybVJlbGF0aW9ucyggcXVlcnkuYW5jZXN0b3IsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZS5wYXJlbnRzKCk7XG4gIH0gKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiggIWNvbmZpcm1SZWxhdGlvbnMoIHF1ZXJ5LmNoaWxkLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmKCAhY29uZmlybVJlbGF0aW9ucyggcXVlcnkuZGVzY2VuZGFudCwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlLmRlc2NlbmRhbnRzKCk7XG4gIH0gKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQsIHNvIHdlJ3ZlIG1hdGNoZWQgZXZlcnl0aGluZyBmb3IgdGhpcyBxdWVyeVxuICByZXR1cm4gdHJ1ZTtcbn07IC8vIHF1ZXJ5TWF0Y2hlc1xuXG4vLyBmaWx0ZXIgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxuc2VsZm4uZmlsdGVyID0gZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBjb2xsZWN0aW9uLmN5KCk7XG5cbiAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCBpLCBlbGVtZW50ICl7XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmWyBqIF07XG5cbiAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50ICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9O1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uZmlsdGVyKCBzZWxlY3RvckZ1bmN0aW9uICk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkQ29sbGVjdGlvbjtcbn07IC8vIGZpbHRlclxuXG4vLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG5zZWxmbi5tYXRjaGVzID0gZnVuY3Rpb24oIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgIHZhciBxdWVyeSA9IHNlbGZbIGogXTtcblxuICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGUgKSApe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gZmlsdGVyXG5cbi8vIGl0aCBxdWVyeSB0byBzdHJpbmdcbnNlbGZuLnRvU3RyaW5nID0gc2VsZm4uc2VsZWN0b3IgPSBmdW5jdGlvbigpe1xuXG4gIHZhciBzdHIgPSAnJztcblxuICB2YXIgY2xlYW4gPSBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGVhblZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICBpZiggaXMuc3RyaW5nKCB2YWwgKSApe1xuICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xlYW4oIHZhbCApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3BhY2UgPSBmdW5jdGlvbiggdmFsICl7XG4gICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKCBxdWVyeSApe1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09PSBxdWVyeSApe1xuICAgICAgc3RyICs9ICckJztcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSBjbGVhbiggcXVlcnkuZ3JvdXAgKTtcbiAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKCAwLCBncm91cC5sZW5ndGggLSAxICk7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHF1ZXJ5LmRhdGEubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkuZGF0YVsgaiBdO1xuXG4gICAgICBpZiggZGF0YS52YWx1ZSApe1xuICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIHNwYWNlKCBjbGVhbiggZGF0YS5vcGVyYXRvciApICkgKyBjbGVhblZhbCggZGF0YS52YWx1ZSApICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9ICdbJyArIGNsZWFuKCBkYXRhLm9wZXJhdG9yICkgKyBkYXRhLmZpZWxkICsgJ10nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkubWV0YS5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG1ldGEgPSBxdWVyeS5tZXRhWyBqIF07XG4gICAgICBzdHIgKz0gJ1tbJyArIG1ldGEuZmllbGQgKyBzcGFjZSggY2xlYW4oIG1ldGEub3BlcmF0b3IgKSApICsgY2xlYW5WYWwoIG1ldGEudmFsdWUgKSArICddXSc7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzWyBpIF07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkuaWRzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgc2VsID0gJyMnICsgcXVlcnkuaWRzWyBpIF07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbIGogXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5hbmNlc3RvciApICsgJyAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5jaGlsZCApO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5kZXNjZW5kYW50ICE9IG51bGwgKXtcbiAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcXVlcnkgPSB0aGlzWyBpIF07XG5cbiAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcblxuICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSApe1xuICAgICAgc3RyICs9ICcsICc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcbnN0eWZuLmFwcGx5ID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuXG4gIGlmKCBfcC5uZXdTdHlsZSApeyAvLyBjbGVhciBzdHlsZSBjYWNoZXNcbiAgICBfcC5jb250ZXh0U3R5bGVzID0ge307XG4gICAgX3AucHJvcERpZmZzID0ge307XG5cbiAgICBzZWxmLmNsZWFuRWxlbWVudHMoIGVsZXMsIHRydWUgKTtcbiAgfVxuXG4gIGZvciggdmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpZSBdO1xuXG4gICAgdmFyIGN4dE1ldGEgPSBzZWxmLmdldENvbnRleHRNZXRhKCBlbGUgKTtcbiAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZSggY3h0TWV0YSApO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICk7XG5cbiAgICBzZWxmLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGFwcC5kaWZmUHJvcHMgKTtcbiAgICBzZWxmLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gIH0gLy8gZm9yIGVsZW1lbnRzXG5cbiAgX3AubmV3U3R5bGUgPSBmYWxzZTtcbn07XG5cbnN0eWZuLmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24oIG9sZEN4dEtleSwgbmV3Q3h0S2V5ICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVsgZHVhbEN4dEtleSBdO1xuXG4gIGlmKCBjYWNoZWRWYWwgKXtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGN4dCA9IHNlbGZbIGkgXTtcbiAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5WyBpIF0gPT09ICd0JztcbiAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5WyBpIF0gPT09ICd0JztcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgIGlmKCBjeHRIYXNEaWZmZWQgfHwgY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgIHZhciBwcm9wcztcblxuICAgICAgaWYoIGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICB9IGVsc2UgaWYoIGN4dEhhc0RpZmZlZCApe1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICB9IGVsc2UgaWYoIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzWyBqIF07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgIC8vIGlzIGNhY2hlZClcbiAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmWyBrIF07XG4gICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5WyBrIF0gPT09ICd0JztcblxuICAgICAgICAgIGlmKCAhaGFzTGF0ZXJDeHQgKXsgY29udGludWU7IH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzWyBwcm9wLm5hbWUgXSAhPSBudWxsO1xuXG4gICAgICAgICAgaWYoIGxhdGVyQ3h0T3ZlcnJpZGVzICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFybHkgYXMgbG9uZyBhcyBvbmUgbGF0ZXIgY29udGV4dCBvdmVycmlkZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhYWRkZWRQcm9wWyBuYW1lIF0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzICl7XG4gICAgICAgICAgYWRkZWRQcm9wWyBuYW1lIF0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKCBuYW1lICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgfSAvLyBpZlxuXG4gIH0gLy8gZm9yIGNvbnRleHRzXG5cbiAgY2FjaGVbIGR1YWxDeHRLZXkgXSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5cbnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24oIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRLZXkgPSAnJztcbiAgdmFyIGRpZmZQcm9wcztcbiAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXtcbiAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICB9XG5cbiAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb250ZXh0ID0gc2VsZlsgaSBdO1xuICAgIHZhciBjb250ZXh0U2VsZWN0b3JNYXRjaGVzID0gY29udGV4dC5zZWxlY3RvciAmJiBjb250ZXh0LnNlbGVjdG9yLm1hdGNoZXMoIGVsZSApOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICBpZiggY29udGV4dFNlbGVjdG9yTWF0Y2hlcyApe1xuICAgICAgY3h0S2V5ICs9ICd0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0S2V5ICs9ICdmJztcbiAgICB9XG4gIH0gLy8gZm9yIGNvbnRleHRcblxuICBkaWZmUHJvcHMgPSBzZWxmLmdldFByb3BlcnRpZXNEaWZmKCBwcmV2S2V5LCBjeHRLZXkgKTtcblxuICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGN4dEtleSxcbiAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHNcbiAgfTtcbn07XG5cbi8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbnN0eWZuLmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhICl7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9O1xuXG4gIC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG4gIGlmKCBjeHRTdHlsZXNbIGN4dEtleSBdICl7IHJldHVybiBjeHRTdHlsZXNbIGN4dEtleSBdOyB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIF9wcml2YXRlOiB7XG4gICAgICBrZXk6IGN4dEtleVxuICAgIH1cbiAgfTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gc2VsZlsgaSBdO1xuICAgIHZhciBoYXNDeHQgPSBjeHRLZXlbIGkgXSA9PT0gJ3QnO1xuXG4gICAgaWYoICFoYXNDeHQgKXsgY29udGludWU7IH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbIGogXTtcblxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBjeHRTdHlsZXNbIGN4dEtleSBdID0gc3R5bGU7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnN0eWZuLmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICB2YXIgcmV0RGlmZlByb3BzID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzWyBpIF07XG4gICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVsgZGlmZlByb3BOYW1lIF07XG4gICAgdmFyIGVsZVByb3AgPSBlbGUucHN0eWxlKCBkaWZmUHJvcE5hbWUgKTtcblxuICAgIGlmKCAhY3h0UHJvcCApeyAvLyBubyBjb250ZXh0IHByb3AgbWVhbnMgZGVsZXRlXG4gICAgICBpZiggIWVsZVByb3AgKXtcbiAgICAgICAgY29udGludWU7IC8vIG5vIGV4aXN0aW5nIHByb3AgbWVhbnMgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIC8vIG5iIGFmZmVjdHMgaW5pdGlhbCBhcHBsaWNhdGlvbiBvbiBtYXBwZWQgdmFsdWVzIGxpa2UgY29udHJvbC1wb2ludC1kaXN0YW5jZXNcbiAgICAgIH0gZWxzZSBpZiggZWxlUHJvcC5ieXBhc3MgKXtcbiAgICAgICAgY3h0UHJvcCA9IHsgbmFtZTogZGlmZlByb3BOYW1lLCBkZWxldGVCeXBhc3NlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0UHJvcCA9IHsgbmFtZTogZGlmZlByb3BOYW1lLCBkZWxldGU6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIHRoZSBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICBpZiggZWxlUHJvcCA9PT0gY3h0UHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzWyBkaWZmUHJvcE5hbWUgXSA9IHtcbiAgICAgIHByZXY6IGVsZVByb3BcbiAgICB9O1xuXG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIGN4dFByb3AgKTtcblxuICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKCBkaWZmUHJvcE5hbWUgKTtcblxuICAgIGlmKCByZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzICl7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gIH07XG59O1xuXG5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24oZWxlKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYoIGVsZS5yZW1vdmVkKCkgKXsgcmV0dXJuOyB9XG5cbiAgLy8gc2V0IHdoZXRoZXIgaGFzIHBpZSBvciBub3Q7IGZvciBncmVhdGVyIGVmZmljaWVuY3lcbiAgdmFyIGhhc1BpZSA9IGZhbHNlO1xuICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSBzZWxmLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgICAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnICkudmFsdWU7XG5cbiAgICAgIGlmKCBzaXplID4gMCApe1xuICAgICAgICBoYXNQaWUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcC5oYXNQaWUgPSBoYXNQaWU7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoICd0ZXh0LXRyYW5zZm9ybScgKS5zdHJWYWx1ZTtcbiAgdmFyIGNvbnRlbnQgPSBlbGUucHN0eWxlKCAnbGFiZWwnICkuc3RyVmFsdWU7XG4gIHZhciBzcmNDb250ZW50ID0gZWxlLnBzdHlsZSggJ3NvdXJjZS1sYWJlbCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHRndENvbnRlbnQgPSBlbGUucHN0eWxlKCAndGFyZ2V0LWxhYmVsJyApLnN0clZhbHVlO1xuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSggJ2ZvbnQtc3R5bGUnICkuc3RyVmFsdWU7XG4gIHZhciBzaXplID0gZWxlLnBzdHlsZSggJ2ZvbnQtc2l6ZScgKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoICdmb250LWZhbWlseScgKS5zdHJWYWx1ZTtcbiAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCAnZm9udC13ZWlnaHQnICkuc3RyVmFsdWU7XG4gIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC12YWxpZ24nICkuc3RyVmFsdWU7XG4gIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCAndGV4dC12YWxpZ24nICkuc3RyVmFsdWU7XG4gIHZhciBvV2lkdGggPSBlbGUucHN0eWxlKCAndGV4dC1vdXRsaW5lLXdpZHRoJyApLnBmVmFsdWU7XG4gIHZhciB3cmFwID0gZWxlLnBzdHlsZSggJ3RleHQtd3JhcCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHdyYXBXID0gZWxlLnBzdHlsZSggJ3RleHQtbWF4LXdpZHRoJyApLnBmVmFsdWU7XG4gIHZhciBsYWJlbFN0eWxlS2V5ID0gZlN0eWxlICsgJyQnICsgc2l6ZSArICckJyArIGZhbWlseSArICckJyArIHdlaWdodCArICckJyArIHRyYW5zZm9ybSArICckJyArIHZhbGlnbiArICckJyArIGhhbGlnbiArICckJyArIG9XaWR0aCArICckJyArIHdyYXAgKyAnJCcgKyB3cmFwVztcbiAgX3AubGFiZWxTdHlsZUtleSA9IGxhYmVsU3R5bGVLZXk7XG4gIF9wLnNvdXJjZUxhYmVsS2V5ID0gbGFiZWxTdHlsZUtleSArICckJyArIHNyY0NvbnRlbnQ7XG4gIF9wLnRhcmdldExhYmVsS2V5ID0gbGFiZWxTdHlsZUtleSArICckJyArIHRndENvbnRlbnQ7XG4gIF9wLmxhYmVsS2V5ID0gbGFiZWxTdHlsZUtleSArICckJyArIGNvbnRlbnQ7XG4gIF9wLmZvbnRLZXkgPSBmU3R5bGUgKyAnJCcgKyB3ZWlnaHQgKyAnJCcgKyBzaXplICsgJyQnICsgZmFtaWx5O1xuXG4gIF9wLnN0eWxlS2V5ID0gRGF0ZS5ub3coKTtcbn07XG5cbi8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuc3R5Zm4uYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBlbGUsIHBhcnNlZFByb3AgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZpZWxkVmFsLCBmbGF0UHJvcDtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbIHByb3AubmFtZSBdLnR5cGU7XG4gIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgdmFyIG9yaWdQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgZmxhdFByb3BNYXBwaW5nID0gJ21hcHBpbmcnO1xuXG4gIC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBpZihcbiAgICBwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZSdcbiAgICAmJiBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snXG4gICAgJiYgZWxlLmlzRWRnZSgpXG4gICAgJiYgKCBlbGUuaXNMb29wKCkgfHwgZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCkgKVxuICApe1xuICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggcGFyc2VkUHJvcC5uYW1lLCAnYmV6aWVyJywgcHJvcElzQnlwYXNzICk7XG4gIH1cblxuICBpZiggcHJvcC5kZWxldGUgKXsgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBhbmQgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGZhbHNleSB2YWx1ZVxuICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYoIHByb3AuZGVsZXRlQnlwYXNzZWQgKXsgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmKCAhb3JpZ1Byb3AgKXtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuXG4gICAgfSBlbHNlIGlmKCBvcmlnUHJvcC5ieXBhc3MgKXsgLy8gZGVsZXRlIGJ5cGFzc2VkXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuICBpZiggcHJvcC5kZWxldGVCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgIGlmKCAhb3JpZ1Byb3AgKXtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IG5vdCBkZWZpbmVkXG5cbiAgICB9IGVsc2UgaWYoIG9yaWdQcm9wLmJ5cGFzcyApeyAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IG9yaWdQcm9wLmJ5cGFzc2VkO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmludE1hcHBpbmdFcnIgPSBmdW5jdGlvbigpe1xuICAgIHV0aWwuZXJyb3IoICdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChlLmcuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnICk7XG4gIH07XG5cbiAgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuICBzd2l0Y2goIHByb3AubWFwcGVkICl7IC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICBjYXNlIHR5cGVzLm1hcERhdGE6XG4gIGNhc2UgdHlwZXMubWFwTGF5b3V0RGF0YTpcbiAgY2FzZSB0eXBlcy5tYXBTY3JhdGNoOlxuXG4gICAgdmFyIGlzTGF5b3V0ID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLm1hcExheW91dERhdGE7XG4gICAgdmFyIGlzU2NyYXRjaCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5tYXBTY3JhdGNoO1xuXG4gICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCAnLicgKTtcbiAgICB2YXIgZmllbGRWYWw7XG5cbiAgICBpZiggaXNTY3JhdGNoIHx8IGlzTGF5b3V0ICl7XG4gICAgICBmaWVsZFZhbCA9IF9wLnNjcmF0Y2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKyApe1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG4gICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50O1xuICAgIGlmKCAhaXMubnVtYmVyKCBmaWVsZFZhbCApICl7IC8vIHRoZW4ga2VlcCB0aGUgbWFwcGluZyBidXQgYXNzdW1lIDAlIGZvciBub3dcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyAocHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW4pO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG4gICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgdmFyIGNsciA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCggcjEgKyAocjIgLSByMSkgKiBwZXJjZW50ICksXG4gICAgICAgIE1hdGgucm91bmQoIGcxICsgKGcyIC0gZzEpICogcGVyY2VudCApLFxuICAgICAgICBNYXRoLnJvdW5kKCBiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQgKSxcbiAgICAgICAgTWF0aC5yb3VuZCggYTEgKyAoYTIgLSBhMSkgKiBwZXJjZW50IClcbiAgICAgIF07XG5cbiAgICAgIGZsYXRQcm9wID0geyAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgfVxuXG4gICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICAvLyBkaXJlY3QgbWFwcGluZ1xuICBjYXNlIHR5cGVzLmRhdGE6XG4gIGNhc2UgdHlwZXMubGF5b3V0RGF0YTpcbiAgY2FzZSB0eXBlcy5zY3JhdGNoOlxuICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5sYXlvdXREYXRhO1xuICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMuc2NyYXRjaDtcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCggJy4nICk7XG4gICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgaWYoIGlzU2NyYXRjaCB8fCBpc0xheW91dCApe1xuICAgICAgZmllbGRWYWwgPSBfcC5zY3JhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgfVxuXG4gICAgaWYoIGZpZWxkVmFsICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcbiAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgfSB9XG5cbiAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcblxuICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgdmFyIGZsYXRQcm9wVmFsID0gb3JpZ1Byb3AgPyBvcmlnUHJvcC5zdHJWYWx1ZSA6ICcnO1xuXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICBjYXNlIHR5cGVzLmZuOlxuICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgdmFyIGZuUmV0VmFsID0gZm4oIGVsZSApO1xuXG4gICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nICk7XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICBjYXNlIHVuZGVmaW5lZDpcbiAgICBicmVhazsgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfVxuXG4gIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICBpZiggcHJvcElzQnlwYXNzICl7XG4gICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7IC8vIHRoZW4gbGluayB0aGUgb3JpZyBwcm9wIHRvIHRoZSBuZXcgYnlwYXNzXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgfVxuXG4gICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYW5kIHNldFxuXG4gIH0gZWxzZSB7IC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2UgeyAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlciggZWxlLCBwcm9wLm5hbWUsIG9yaWdQcm9wID8gb3JpZ1Byb3AudmFsdWUgOiBudWxsLCBwcm9wLnZhbHVlICk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zdHlmbi5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZXMsIGtlZXBCeXBhc3NlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmKCAha2VlcEJ5cGFzc2VzICl7XG4gICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBlbGVQcm9wICl7XG4gICAgICAgICAgaWYoIGVsZVByb3AuYnlwYXNzICl7XG4gICAgICAgICAgICBlbGVQcm9wLmJ5cGFzc2VkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTtcblxuLy8ganVzdCB1cGRhdGUgdGhlIGZ1bmN0aW9uYWwgcHJvcGVydGllcyAoaS5lLiBtYXBwaW5ncykgaW4gdGhlIGVsZW1lbnRzJ1xuLy8gc3R5bGVzIChsZXNzIGV4cGVuc2l2ZSB0aGFuIHJlY2FsY3VsYXRpb24pXG5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBqIF07XG4gICAgICB2YXIgcHJvcEluU3R5bGUgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgIGlmKCBwcm9wSW5TdHlsZSAmJiBwcm9wSW5TdHlsZS5tYXBwaW5nICl7XG4gICAgICAgIHZhciBtYXBwaW5nID0gcHJvcEluU3R5bGUubWFwcGluZztcbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gIH1cbn07XG5cbi8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwcm9wcyA9IGVsZS5wc3R5bGUoICd0cmFuc2l0aW9uLXByb3BlcnR5JyApLnZhbHVlO1xuICB2YXIgZHVyYXRpb24gPSBlbGUucHN0eWxlKCAndHJhbnNpdGlvbi1kdXJhdGlvbicgKS5wZlZhbHVlO1xuICB2YXIgZGVsYXkgPSBlbGUucHN0eWxlKCAndHJhbnNpdGlvbi1kZWxheScgKS5wZlZhbHVlO1xuXG4gIGlmKCBwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCApe1xuXG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKCBwcm9wICk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AgXTtcblxuICAgICAgaWYoICFkaWZmUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgdmFyIGluaXRWYWw7XG4gICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgIGlmKCAhZnJvbVByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgLy8gY29uc2lkZXIgcHggdmFsdWVzXG4gICAgICBpZiggaXMubnVtYmVyKCBmcm9tUHJvcC5wZlZhbHVlICkgJiYgaXMubnVtYmVyKCB0b1Byb3AucGZWYWx1ZSApICl7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AucGZWYWx1ZSAtIGZyb21Qcm9wLnBmVmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIGZyb21Qcm9wLnZhbHVlICkgJiYgaXMubnVtYmVyKCB0b1Byb3AudmFsdWUgKSApe1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnZhbHVlIC0gZnJvbVByb3AudmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC52YWx1ZSArIGluaXREdCAqIGRpZmY7XG5cbiAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIGZyb21Qcm9wLnZhbHVlICkgJiYgaXMuYXJyYXkoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdXG4gICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXVxuICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl1cbiAgICAgICAgO1xuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG4gICAgICBpZiggZGlmZiApe1xuICAgICAgICBjc3NbIHByb3AgXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG4gICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoIGVsZSwgcHJvcCwgaW5pdFZhbCApOyAvLyBmcm9tIHZhbFxuICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgaWYoICFhbnlQcmV2ICl7IHJldHVybjsgfVxuXG4gICAgX3AudHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICBlbGUuc3RvcCgpO1xuXG4gICAgaWYoIGRlbGF5ID4gMCApe1xuICAgICAgZWxlLmRlbGF5KCBkZWxheSApO1xuICAgIH1cblxuICAgIGVsZS5hbmltYXRlKCB7XG4gICAgICBjc3M6IGNzc1xuICAgIH0sIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGVhc2luZzogZWxlLnBzdHlsZSggJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyApLnZhbHVlLFxuICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIHByb3BzICk7XG4gICAgICAgIH1cblxuICAgICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSApO1xuXG4gIH0gZWxzZSBpZiggX3AudHJhbnNpdGlvbmluZyApe1xuICAgIGVsZS5zdG9wKCk7XG5cbiAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIHByb3BzICk7XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gIH1cbn07XG5cbnN0eWZuLmNoZWNrWk9yZGVyVHJpZ2dlciA9IGZ1bmN0aW9uKCBlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSApe1xuICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1sgbmFtZSBdO1xuXG4gIGlmKCBwcm9wLnRyaWdnZXJzWk9yZGVyICYmICggZnJvbVZhbHVlID09IG51bGwgfHwgcHJvcC50cmlnZ2Vyc1pPcmRlciggZnJvbVZhbHVlLCB0b1ZhbHVlICkgKSApe1xuICAgIHRoaXMuX3ByaXZhdGUuY3kubm90aWZ5KHtcbiAgICAgIHR5cGU6ICd6b3JkZXInLFxuICAgICAgZWxlczogZWxlXG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gIGlmKCBuYW1lID09PSAnKicgfHwgbmFtZSA9PT0gJyoqJyApeyAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcblxuICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgaSBdO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlLCB0cnVlICk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoIG5hbWUgKSApeyAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlLCB0cnVlICk7XG5cbiAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgcHJvcHMucHVzaCggcGFyc2VkUHJvcCApO1xuICAgIH1cbiAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggbmFtZSApICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgaSBdO1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgbmFtZSBdO1xuXG4gICAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICB2YWx1ZSA9IHNwZWNpZmllZFByb3BzWyB1dGlsLmRhc2gyY2FtZWwoIG5hbWUgKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlLCB0cnVlICk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7IC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcbiAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICB2YXIgZGlmZlByb3A7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuICAgICAgICBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBwcm9wICkgfHwgcmV0O1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuICAgICAgfVxuXG4gICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIGlmKCByZXQgKXtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gICAgfVxuXG4gICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cbnN0eWZuLm92ZXJyaWRlQnlwYXNzID0gZnVuY3Rpb24oIGVsZXMsIG5hbWUsIHZhbHVlICl7XG4gIG5hbWUgPSB1dGlsLmNhbWVsMmRhc2goIG5hbWUgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgIHZhciBwcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlWyBuYW1lIF07XG4gICAgdmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXNbIG5hbWUgXS50eXBlO1xuICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcblxuICAgIGlmKCAhcHJvcCB8fCAhcHJvcC5ieXBhc3MgKXsgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBuYW1lLCB2YWx1ZSApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG9sZFZhbHVlID0gcHJvcC5wZlZhbHVlICE9IG51bGwgPyBwcm9wLnBmVmFsdWUgOiBwcm9wLnZhbHVlO1xuXG4gICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYoIHByb3AucGZWYWx1ZSAhPSBudWxsICl7XG4gICAgICBwcm9wLnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiggaXNDb2xvciApe1xuICAgICAgcHJvcC5zdHJWYWx1ZSA9ICdyZ2IoJyArIHZhbHVlLmpvaW4oICcsJyApICsgJyknO1xuICAgIH0gZWxzZSBpZiggaXNNdWx0aSApe1xuICAgICAgcHJvcC5zdHJWYWx1ZSA9IHZhbHVlLmpvaW4oICcgJyApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlciggZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUgKTtcbiAgfVxufTtcblxuc3R5Zm4ucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZXMsIHRoaXMucHJvcGVydHlOYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbn07XG5cbnN0eWZuLnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24oIGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBqIF07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1sgaSBdO1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuXG4gICAgICBpZiggIXByZXZQcm9wIHx8ICFwcmV2UHJvcC5ieXBhc3MgKXtcbiAgICAgICAgLy8gaWYgYSBieXBhc3MgZG9lc24ndCBleGlzdCBmb3IgdGhlIHByb3AsIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBwYXJzZWRQcm9wICk7XG5cbiAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKCBwcm9wLm5hbWUgKTtcbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcblxuICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uL3dpbmRvdycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5zdHlmbi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBweCA9IHRoaXMuY29udGFpbmVyQ3NzKCAnZm9udC1zaXplJyApO1xuXG4gIGlmKCBweCAhPSBudWxsICl7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoIHB4ICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7IC8vIGZvciBoZWFkbGVzc1xuICB9XG59O1xuXG4vLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuc3R5Zm4uY29udGFpbmVyQ3NzID0gZnVuY3Rpb24oIHByb3BOYW1lICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgaWYoIHdpbmRvdyAmJiBkb21FbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICl7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkb21FbGVtZW50ICkuZ2V0UHJvcGVydHlWYWx1ZSggcHJvcE5hbWUgKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGdldHMgdGhlIHJlbmRlcmVkIHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbi5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZSwgcHJvcCApe1xuICBpZiggcHJvcCApe1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBwcm9wLCB0cnVlICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoIGVsZSwgdHJ1ZSApO1xuICB9XG59O1xuXG4vLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuLmdldFJhd1N0eWxlID0gZnVuY3Rpb24oIGVsZSwgaXNSZW5kZXJlZFZhbCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiggZWxlICl7XG4gICAgdmFyIHJzdHlsZSA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICB2YXIgdmFsID0gc2VsZi5nZXRTdHlsZVByb3BlcnR5VmFsdWUoIGVsZSwgcHJvcC5uYW1lLCBpc1JlbmRlcmVkVmFsICk7XG5cbiAgICAgIGlmKCB2YWwgIT0gbnVsbCApe1xuICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICByc3R5bGVbIHV0aWwuZGFzaDJjYW1lbCggcHJvcC5uYW1lICkgXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9XG59O1xuXG5zdHlmbi5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiggZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiggZWxlICl7XG4gICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIHByb3BOYW1lIF07XG5cbiAgICBpZiggcHJvcC5hbGlhcyApe1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgdmFyIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzID8gdHlwZS5pbXBsaWNpdFVuaXRzIHx8ICdweCcgOiBudWxsO1xuICAgICAgdmFyIHZhbCA9IHVuaXRzID8gW10uY29uY2F0KCBzdHlsZVByb3AucGZWYWx1ZSApLm1hcCggZnVuY3Rpb24oIHBmVmFsdWUgKXtcbiAgICAgICAgcmV0dXJuICggcGZWYWx1ZSAqIChpc1JlbmRlcmVkVmFsID8gem9vbSA6IDEpICkgKyB1bml0cztcbiAgICAgIH0gKS5qb2luKCAnICcgKSA6IHN0eWxlUHJvcC5zdHJWYWx1ZTtcblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnN0eWZuLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUgPSBmdW5jdGlvbiggZWxlLCBhbmlQcm9wcyApe1xuICB2YXIgcnN0eWxlID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbmlQcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBhbmlQcm9wID0gYW5pUHJvcHNbIGkgXTtcbiAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcblxuICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKCBuYW1lICk7XG5cbiAgICBpZiggc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBtYWtlIGEgcHJvcCBvZiBpdFxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBzdHlsZVByb3AgKSApe1xuICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKCBuYW1lLCBzdHlsZVByb3Auc3RyVmFsdWUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHN0eWxlUHJvcCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgIHJzdHlsZVsgbmFtZSBdID0gc3R5bGVQcm9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByc3R5bGU7XG59O1xuXG5zdHlmbi5nZXRQcm9wc0xpc3QgPSBmdW5jdGlvbiggcHJvcHNPYmogKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnN0eWxlID0gW107XG4gIHZhciBzdHlsZSA9IHByb3BzT2JqO1xuICB2YXIgcHJvcHMgPSBzZWxmLnByb3BlcnRpZXM7XG5cbiAgaWYoIHN0eWxlICl7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoIHN0eWxlICk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHN0eWxlWyBuYW1lIF07XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBuYW1lIF0gfHwgcHJvcHNbIHV0aWwuY2FtZWwyZGFzaCggbmFtZSApIF07XG4gICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCB2YWwgKTtcblxuICAgICAgcnN0eWxlLnB1c2goIHN0eWxlUHJvcCApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByc3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSggJy4uL3NlbGVjdG9yJyApO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcblxuICBpZiggISh0aGlzIGluc3RhbmNlb2YgU3R5bGUpICl7XG4gICAgcmV0dXJuIG5ldyBTdHlsZSggY3kgKTtcbiAgfVxuXG4gIGlmKCAhaXMuY29yZSggY3kgKSApe1xuICAgIHV0aWwuZXJyb3IoICdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge31cbiAgfTtcblxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZXNldFRvRGVmYXVsdCgpO1xufTtcblxudmFyIHN0eWZuID0gU3R5bGUucHJvdG90eXBlO1xuXG5zdHlmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAnc3R5bGUnO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBjb250ZXh0c1xuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbigpe1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB0aGlzWyBpIF0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgX3AubmV3U3R5bGUgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3Rvclxuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZTtcbn07XG5cbi8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbnN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yU3RyICl7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuXG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKzsgLy8gbmV3IGNvbnRleHQgbWVhbnMgbmV3IGluZGV4XG4gIHRoaXNbIGkgXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW10sXG4gICAgbWFwcGVkUHJvcGVydGllczogW10sXG4gICAgaW5kZXg6IGlcbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gIGNhc2UgMTpcbiAgICB2YXIgbWFwID0gYXJnc1swXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgaSBdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFsgcHJvcC5uYW1lIF07XG5cbiAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBtYXBWYWwgPSBtYXBbIHV0aWwuZGFzaDJjYW1lbCggcHJvcC5uYW1lICkgXTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuY3NzUnVsZSggcHJvcC5uYW1lLCBtYXBWYWwgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcblxuICBjYXNlIDI6XG4gICAgdGhpcy5jc3NSdWxlKCBhcmdzWzBdLCBhcmdzWzFdICk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICBicmVhazsgLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5zdHlsZSA9IHN0eWZuLmNzcztcblxuLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlICk7XG5cbiAgLy8gYWRkIHByb3BlcnR5IHRvIGN1cnJlbnQgY29udGV4dCBpZiB2YWxpZFxuICBpZiggcHJvcGVydHkgKXtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICB0aGlzWyBpIF0ucHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgIHRoaXNbIGkgXS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgaWYoIHByb3BlcnR5Lm5hbWUubWF0Y2goIC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8gKSAmJiBwcm9wZXJ0eS52YWx1ZSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKCBwcm9wZXJ0eS5tYXBwZWQgKXtcbiAgICAgIHRoaXNbIGkgXS5tYXBwZWRQcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzWyBpIF0uc2VsZWN0b3I7XG4gICAgaWYoIGN1cnJlbnRTZWxlY3RvcklzQ29yZSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gc3RhdGljIGZ1bmN0aW9uXG5TdHlsZS5mcm9tSnNvbiA9IGZ1bmN0aW9uKCBjeSwganNvbiApe1xuICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoIGN5ICk7XG5cbiAgc3R5bGUuZnJvbUpzb24oIGpzb24gKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5TdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oIGN5LCBzdHJpbmcgKXtcbiAgcmV0dXJuIG5ldyBTdHlsZSggY3kgKS5mcm9tU3RyaW5nKCBzdHJpbmcgKTtcbn07XG5cbltcbiAgcmVxdWlyZSggJy4vYXBwbHknICksXG4gIHJlcXVpcmUoICcuL2J5cGFzcycgKSxcbiAgcmVxdWlyZSggJy4vY29udGFpbmVyJyApLFxuICByZXF1aXJlKCAnLi9nZXQtZm9yLWVsZScgKSxcbiAgcmVxdWlyZSggJy4vanNvbicgKSxcbiAgcmVxdWlyZSggJy4vc3RyaW5nLXNoZWV0JyApLFxuICByZXF1aXJlKCAnLi9wcm9wZXJ0aWVzJyApLFxuICByZXF1aXJlKCAnLi9wYXJzZScgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIHN0eWZuLCBwcm9wcyApO1xufSApO1xuXG5cblN0eWxlLnR5cGVzID0gc3R5Zm4udHlwZXM7XG5TdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4ucHJvcGVydGllcztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0eWZuID0ge307XG5cbnN0eWZuLmFwcGx5RnJvbUpzb24gPSBmdW5jdGlvbigganNvbiApe1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb250ZXh0ID0ganNvblsgaSBdO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyggcHJvcHMgKTtcblxuICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tqXTtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzWyBuYW1lIF07XG5cbiAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBseUZyb21Kc29uKCBqc29uICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuc3R5Zm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBqc29uID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gdGhpc1sgaSBdO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBqIF07XG4gICAgICBjc3NbIHByb3AubmFtZSBdID0gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG5cbiAgICBqc29uLnB1c2goIHtcbiAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgc3R5bGU6IGNzc1xuICAgIH0gKTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uL21hdGgnICk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcbnN0eWZuLnBhcnNlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGZ1bmN0aW9uIHZhbHVlcyBjYW4ndCBiZSBjYWNoZWQgaW4gYWxsIGNhc2VzLCBhbmQgdGhlcmUgaXNuJ3QgbXVjaCBiZW5lZml0IG9mIGNhY2hpbmcgdGhlbSBhbnl3YXlcbiAgaWYoIGlzLmZuKCB2YWx1ZSApICl7XG4gICAgcmV0dXJuIHNlbGYucGFyc2VJbXBsV2FybiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApO1xuICB9XG5cbiAgdmFyIGZsYXRLZXkgPSAoIHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyB8fCBwcm9wSXNGbGF0ID09PSB0cnVlIHx8IHByb3BJc0ZsYXQgPT09IGZhbHNlIHx8IHByb3BJc0ZsYXQgPT0gbnVsbCApID8gJ2RvbnRjYXJlJyA6IHByb3BJc0ZsYXQ7XG4gIHZhciBhcmdIYXNoID0gWyBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBmbGF0S2V5IF0uam9pbiggJyQnICk7XG4gIHZhciBwcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlIHx8IHt9O1xuICB2YXIgcmV0O1xuXG4gIGlmKCAhKHJldCA9IHByb3BDYWNoZVsgYXJnSGFzaCBdKSApe1xuICAgIHJldCA9IHByb3BDYWNoZVsgYXJnSGFzaCBdID0gc2VsZi5wYXJzZUltcGxXYXJuKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICk7XG4gIH1cblxuICAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuICBpZiggcHJvcElzQnlwYXNzIHx8IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyApe1xuICAgIC8vIG5lZWQgYSBjb3B5IHNpbmNlIHByb3BzIGFyZSBtdXRhdGVkIGxhdGVyIGluIHRoZWlyIGxpZmVjeWNsZXNcbiAgICByZXQgPSB1dGlsLmNvcHkoIHJldCApO1xuXG4gICAgaWYoIHJldCApe1xuICAgICAgcmV0LnZhbHVlID0gdXRpbC5jb3B5KCByZXQudmFsdWUgKTsgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSBhbiBhcnJheSwgZS5nLiBjb2xvdXJcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuc3R5Zm4ucGFyc2VJbXBsV2FybiA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICl7XG4gIHZhciBwcm9wID0gdGhpcy5wYXJzZUltcGwoIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKTtcblxuICBpZiggIXByb3AgJiYgdmFsdWUgIT0gbnVsbCApe1xuICAgIHV0aWwuZXJyb3IoJ1RoZSBzdHlsZSBwcm9wZXJ0eSBgJXM6ICVzYCBpcyBpbnZhbGlkJywgbmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHByb3A7XG59O1xuXG4vLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuLy8gZmllbGRzIDpcbi8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gc3RyVmFsdWUgOiBhIHN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IHZhbHVlIGluIHZhbGlkIGNzc1xuLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbnN0eWZuLnBhcnNlSW1wbCA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBuYW1lID0gdXRpbC5jYW1lbDJkYXNoKCBuYW1lICk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcblxuICB2YXIgcHJvcGVydHkgPSBzZWxmLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgaWYoICFwcm9wZXJ0eSApeyByZXR1cm4gbnVsbDsgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgKXsgcmV0dXJuIG51bGw7IH0gLy8gY2FuJ3QgYXNzaWduIG51bGxcblxuICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG4gIGlmKCBwcm9wZXJ0eS5hbGlhcyApe1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cblxuICB2YXIgdmFsdWVJc1N0cmluZyA9IGlzLnN0cmluZyggdmFsdWUgKTtcbiAgaWYoIHZhbHVlSXNTdHJpbmcgKXsgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICBpZiggIXR5cGUgKXsgcmV0dXJuIG51bGw7IH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG4gIGlmKCBwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcbiAgaWYoIGlzLmZuKCB2YWx1ZSApICl7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgIG1hcHBlZDogdHlwZXMuZm4sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcbiAgdmFyIGRhdGEsIG1hcERhdGEsIGxheW91dERhdGEsIG1hcExheW91dERhdGEsIHNjcmF0Y2gsIG1hcFNjcmF0Y2g7XG4gIGlmKCAhdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0ICl7XG4gICAgLy8gdGhlbiBkb24ndCBib3RoZXIgdG8gZG8gdGhlIGV4cGVuc2l2ZSByZWdleCBjaGVja3NcblxuICB9IGVsc2UgaWYoXG4gICAgKCBkYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMuZGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggbGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLmxheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAoIHNjcmF0Y2ggPSBuZXcgUmVnRXhwKCB0eXBlcy5zY3JhdGNoLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApXG4gICl7XG4gICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgIHZhciBtYXBwZWQ7XG4gICAgaWYoIGRhdGEgKXtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLmRhdGE7XG4gICAgfSBlbHNlIGlmKCBsYXlvdXREYXRhICl7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5sYXlvdXREYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5zY3JhdGNoO1xuICAgIH1cblxuICAgIGRhdGEgPSBkYXRhIHx8IGxheW91dERhdGEgfHwgc2NyYXRjaDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgfSBlbHNlIGlmKFxuICAgICggbWFwRGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAoIG1hcExheW91dERhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5tYXBMYXlvdXREYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgKCBtYXBTY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwU2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICApe1xuICAgIGlmKCBwcm9wSXNCeXBhc3MgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG4gICAgaWYoIHR5cGUubXVsdGlwbGUgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGltcG9zc2libGUgdG8gbWFwIHRvIG51bVxuXG4gICAgdmFyIG1hcHBlZDtcbiAgICBpZiggbWFwRGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcbiAgICB9IGVsc2UgaWYoIG1hcExheW91dERhdGEgKXtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLm1hcExheW91dERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLm1hcFNjcmF0Y2g7XG4gICAgfVxuXG4gICAgbWFwRGF0YSA9IG1hcERhdGEgfHwgbWFwTGF5b3V0RGF0YSB8fCBtYXBTY3JhdGNoO1xuXG4gICAgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG4gICAgaWYoICEodHlwZS5jb2xvciB8fCB0eXBlLm51bWJlcikgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgdmFsdWVNaW4gPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzRdICk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYoICF2YWx1ZU1pbiB8fCB2YWx1ZU1pbi5tYXBwZWQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzVdICk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYoICF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG4gICAgaWYoIHZhbHVlTWluLnZhbHVlID09PSB2YWx1ZU1heC52YWx1ZSApe1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG5cbiAgICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgdmFyIGMyID0gdmFsdWVNYXgudmFsdWU7XG5cbiAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICAgJiYgYzFbMl0gPT09IGMyWzJdIC8vIGJsdWVcbiAgICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICAgICAgfHwgKFxuICAgICAgICAgICAgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGMyWzNdID09IG51bGwgfHwgYzJbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDI/XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICA7XG5cbiAgICAgIGlmKCBzYW1lICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IG1hcERhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdCggbWFwRGF0YVsyXSApLCAvLyBtaW4gJiBtYXggYXJlIG51bWVyaWNcbiAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KCBtYXBEYXRhWzNdICksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICBpZiggdHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnICl7XG4gICAgdmFyIHZhbHM7XG5cbiAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KCAvXFxzKy8gKTtcbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCB2YWx1ZSApICl7XG4gICAgICB2YWxzID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHMgPSBbIHZhbHVlIF07XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIHZhbEFyciA9IFtdO1xuICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgIHZhciBoYXNFbnVtID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwID0gc2VsZi5wYXJzZSggbmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnICk7XG5cbiAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IGlzLnN0cmluZyggcC52YWx1ZSApO1xuXG4gICAgICB2YWxBcnIucHVzaCggcC52YWx1ZSApO1xuICAgICAgcGZWYWxBcnIucHVzaCggcC5wZlZhbHVlICE9IG51bGwgPyBwLnBmVmFsdWUgOiBwLnZhbHVlICk7XG4gICAgICB1bml0c0Fyci5wdXNoKCBwLnVuaXRzICk7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUudmFsaWRhdGUgJiYgIXR5cGUudmFsaWRhdGUoIHZhbEFyciwgdW5pdHNBcnIgKSApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuc2luZ2xlRW51bSAmJiBoYXNFbnVtICl7XG4gICAgICBpZiggdmFsQXJyLmxlbmd0aCA9PT0gMSAmJiBpcy5zdHJpbmcoIHZhbEFyclswXSApICl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHZhbEFyci5qb2luKCAnICcgKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgfTtcbiAgfVxuXG4gIC8vIHNldmVyYWwgdHlwZXMgYWxzbyBhbGxvdyBlbnVtc1xuICB2YXIgY2hlY2tFbnVtcyA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlLmVudW1zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZW4gPSB0eXBlLmVudW1zWyBpIF07XG5cbiAgICAgIGlmKCBlbiA9PT0gdmFsdWUgKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG9iamVjdFxuICBpZiggdHlwZS5udW1iZXIgKXtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiggdHlwZS51bml0cyApeyAvLyB1c2Ugc3BlY2lmaWVkIHVuaXRzIGlmIHNldFxuICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgIH1cblxuICAgIGlmKCB0eXBlLmltcGxpY2l0VW5pdHMgKXtcbiAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgfVxuXG4gICAgaWYoICF0eXBlLnVuaXRsZXNzICl7XG4gICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcbiAgICAgICAgaWYoIHVuaXRzICl7IHVuaXRzUmVnZXggPSB1bml0czsgfSAvLyBvbmx5IGFsbG93IGV4cGxpY2l0IHVuaXRzIGlmIHNvIHNldFxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCggJ14oJyArIHV0aWwucmVnZXgubnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnICk7XG5cbiAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCAhdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzICl7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICBpZiggaXNOYU4oIHZhbHVlICkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuICAgIGlmKCBpc05hTiggdmFsdWUgKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG5cbiAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgaWYoIHR5cGUuaW50ZWdlciAmJiAhaXMuaW50ZWdlciggdmFsdWUgKSApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgaWYoICggdHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAoIHZhbHVlIDwgdHlwZS5taW4gfHwgKHR5cGUuc3RyaWN0TWluICYmIHZhbHVlID09PSB0eXBlLm1pbikgKSApXG4gICAgfHwgICggdHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiAoIHZhbHVlID4gdHlwZS5tYXggfHwgKHR5cGUuc3RyaWN0TWF4ICYmIHZhbHVlID09PSB0eXBlLm1heCkgKSApXG4gICAgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZXQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcbiAgICBpZiggdHlwZS51bml0bGVzcyB8fCAodW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucGZWYWx1ZSA9ICggdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gKHZhbHVlKSA6ICh0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZSkgKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICBpZiggdW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJyApe1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiByYWRcbiAgICBpZiggdW5pdHMgPT09ICdkZWcnIHx8IHVuaXRzID09PSAncmFkJyApe1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3JhZCcgPyB2YWx1ZSA6IG1hdGguZGVnMnJhZCggdmFsdWUgKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdmFsdWUgaW4gJVxuICAgIGlmKCB1bml0cyA9PT0gJyUnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlIC8gMTAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbiAgfSBlbHNlIGlmKCB0eXBlLnByb3BMaXN0ICl7XG5cbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgaWYoIHByb3BzU3RyID09PSAnbm9uZScgKXtcbiAgICAgIC8vIGxlYXZlIGVtcHR5XG5cbiAgICB9IGVsc2UgeyAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KCAnLCcgKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHNTcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wc1NwbGl0WyBpIF0udHJpbSgpO1xuXG4gICAgICAgIGlmKCBzZWxmLnByb3BlcnRpZXNbIHByb3BOYW1lIF0gKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwcm9wTmFtZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBwcm9wcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIG51bGw7IH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCAnLCAnICksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgdmFyIHR1cGxlID0gdXRpbC5jb2xvcjJ0dXBsZSggdmFsdWUgKTtcblxuICAgIGlmKCAhdHVwbGUgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHR1cGxlLFxuICAgICAgcGZWYWx1ZTogdHVwbGUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgcm91bmRWYWx1ZTogdHJ1ZVxuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLnJlZ2V4IHx8IHR5cGUucmVnZXhlcyApe1xuXG4gICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICBpZiggdHlwZS5lbnVtcyApe1xuICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuXG4gICAgICBpZiggZW51bVByb3AgKXsgcmV0dXJuIGVudW1Qcm9wOyB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbIHR5cGUucmVnZXggXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVnZXhlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggcmVnZXhlc1sgaSBdICk7IC8vIG1ha2UgYSByZWdleCBmcm9tIHRoZSB0eXBlIHN0cmluZ1xuICAgICAgdmFyIG0gPSByZWdleC5leGVjKCB2YWx1ZSApO1xuXG4gICAgICBpZiggbSApeyAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcblxuICB9IGVsc2UgaWYoIHR5cGUuc3RyaW5nICl7XG4gICAgLy8ganVzdCByZXR1cm5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLmVudW1zICl7IC8vIGNoZWNrIGVudW1zIGxhc3QgYmVjYXVzZSBpdCdzIGEgY29tYm8gdHlwZSBpbiBvdGhlcnNcbiAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4oZnVuY3Rpb24oKXtcbiAgdmFyIG51bWJlciA9IHV0aWwucmVnZXgubnVtYmVyO1xuICB2YXIgcmdiYSA9IHV0aWwucmVnZXgucmdiYU5vQmFja1JlZnM7XG4gIHZhciBoc2xhID0gdXRpbC5yZWdleC5oc2xhTm9CYWNrUmVmcztcbiAgdmFyIGhleDMgPSB1dGlsLnJlZ2V4LmhleDM7XG4gIHZhciBoZXg2ID0gdXRpbC5yZWdleC5oZXg2O1xuICB2YXIgZGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7IH07XG4gIHZhciBtYXBEYXRhID0gZnVuY3Rpb24oIHByZWZpeCApe1xuICAgIHZhciBtYXBBcmcgPSBudW1iZXIgKyAnfFxcXFx3K3wnICsgcmdiYSArICd8JyArIGhzbGEgKyAnfCcgKyBoZXgzICsgJ3wnICsgaGV4NjtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICB9O1xuXG4gIC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcbiAgc3R5Zm4udHlwZXMgPSB7XG4gICAgdGltZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgdW5pdHM6ICdzfG1zJywgaW1wbGljaXRVbml0czogJ21zJyB9LFxuICAgIHBlcmNlbnQ6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIG1heDogMTAwLCB1bml0czogJyUnLCBpbXBsaWNpdFVuaXRzOiAnJScgfSxcbiAgICB6ZXJvT25lTnVtYmVyOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbk9uZU9uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBub25OZWdhdGl2ZUludDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgaW50ZWdlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBwb3NpdGlvbjogeyBlbnVtczogWyAncGFyZW50JywgJ29yaWdpbicgXSB9LFxuICAgIG5vZGVTaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBlbnVtczogWyAnbGFiZWwnIF0gfSxcbiAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG51bWJlcnM6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlLCBtaW46IDAsIHN0cmljdE1pbjogdHJ1ZSB9LFxuICAgIHNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAgfSxcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZTogeyBudW1iZXI6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7IG51bWJlcjogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWyAnYXV0bycgXSB9LFxuICAgIGJnUG9zOiB7IG51bWJlcjogdHJ1ZSwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgYmdSZXBlYXQ6IHsgZW51bXM6IFsgJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnIF0gfSxcbiAgICBiZ0ZpdDogeyBlbnVtczogWyAnbm9uZScsICdjb250YWluJywgJ2NvdmVyJyBdIH0sXG4gICAgYmdDcm9zc09yaWdpbjogeyBlbnVtczogWyAnYW5vbnltb3VzJywgJ3VzZS1jcmVkZW50aWFscycgXSB9LFxuICAgIGJnQ2xpcDogeyBlbnVtczogWyAnbm9uZScsICdub2RlJyBdIH0sXG4gICAgY29sb3I6IHsgY29sb3I6IHRydWUgfSxcbiAgICBib29sOiB7IGVudW1zOiBbICd5ZXMnLCAnbm8nIF0gfSxcbiAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsgJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnIF0gfSxcbiAgICBib3JkZXJTdHlsZTogeyBlbnVtczogWyAnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnIF0gfSxcbiAgICBjdXJ2ZVN0eWxlOiB7IGVudW1zOiBbICdiZXppZXInLCAndW5idW5kbGVkLWJlemllcicsICdoYXlzdGFjaycsICdzZWdtZW50cycgXSB9LFxuICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnIH0sXG4gICAgZm9udFZhcmlhbnQ6IHsgZW51bXM6IFsgJ3NtYWxsLWNhcHMnLCAnbm9ybWFsJyBdIH0sXG4gICAgZm9udFN0eWxlOiB7IGVudW1zOiBbICdpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnIF0gfSxcbiAgICBmb250V2VpZ2h0OiB7IGVudW1zOiBbICdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMCBdIH0sXG4gICAgdGV4dERlY29yYXRpb246IHsgZW51bXM6IFsgJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCcgXSB9LFxuICAgIHRleHRUcmFuc2Zvcm06IHsgZW51bXM6IFsgJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZScgXSB9LFxuICAgIHRleHRXcmFwOiB7IGVudW1zOiBbICdub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnIF0gfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7IGVudW1zOiBbICdyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnIF19LFxuICAgIG5vZGVTaGFwZTogeyBlbnVtczogWyAncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ2hleGFnb24nLCAnaGVwdGFnb24nLCAnb2N0YWdvbicsICdzdGFyJywgJ2RpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3BvbHlnb24nIF0gfSxcbiAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHsgZW51bXM6IFsgJ2luY2x1ZGUnLCAnZXhjbHVkZScgXSB9LFxuICAgIGFycm93U2hhcGU6IHsgZW51bXM6IFsgJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdub25lJyBdIH0sXG4gICAgYXJyb3dGaWxsOiB7IGVudW1zOiBbICdmaWxsZWQnLCAnaG9sbG93JyBdIH0sXG4gICAgZGlzcGxheTogeyBlbnVtczogWyAnZWxlbWVudCcsICdub25lJyBdIH0sXG4gICAgdmlzaWJpbGl0eTogeyBlbnVtczogWyAnaGlkZGVuJywgJ3Zpc2libGUnIF0gfSxcbiAgICB6Q29tcG91bmREZXB0aDogeyBlbnVtczogWyAnYm90dG9tJywgJ29ycGhhbicsICdhdXRvJywgJ3RvcCcgXSB9LFxuICAgIHpJbmRleENvbXBhcmU6IHsgZW51bXM6IFsgJ2F1dG8nLCAnbWFudWFsJyBdIH0sXG4gICAgdmFsaWduOiB7IGVudW1zOiBbICd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbScgXSB9LFxuICAgIGhhbGlnbjogeyBlbnVtczogWyAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnIF0gfSxcbiAgICB0ZXh0OiB7IHN0cmluZzogdHJ1ZSB9LFxuICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoICdkYXRhJyApIH0sXG4gICAgbGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSggJ2xheW91dERhdGEnICkgfSxcbiAgICBzY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCAnc2NyYXRjaCcgKSB9LFxuICAgIG1hcERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoICdtYXBEYXRhJyApIH0sXG4gICAgbWFwTGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSggJ21hcExheW91dERhdGEnICkgfSxcbiAgICBtYXBTY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCAnbWFwU2NyYXRjaCcgKSB9LFxuICAgIGZuOiB7IG1hcHBpbmc6IHRydWUsIGZuOiB0cnVlIH0sXG4gICAgdXJsOiB7IHJlZ2V4OiAndXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKXxub25lfCguKykkJyB9LFxuICAgIHByb3BMaXN0OiB7IHByb3BMaXN0OiB0cnVlIH0sXG4gICAgYW5nbGU6IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnLCBpbXBsaWNpdFVuaXRzOiAncmFkJyB9LFxuICAgIHRleHRSb3RhdGlvbjogeyBudW1iZXI6IHRydWUsIHVuaXRzOiAnZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdyYWQnLCBlbnVtczogWyAnbm9uZScsICdhdXRvcm90YXRlJyBdIH0sXG4gICAgcG9seWdvblBvaW50TGlzdDogeyBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlLCBldmVuTXVsdGlwbGU6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBlZGdlRGlzdGFuY2VzOiB7IGVudW1zOiBbJ2ludGVyc2VjdGlvbicsICdub2RlLXBvc2l0aW9uJ10gfSxcbiAgICBlZGdlRW5kcG9pbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSwgbXVsdGlwbGU6IHRydWUsIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJywgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbICdpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1saW5lJyBdLCBzaW5nbGVFbnVtOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCB2YWxBcnIsIHVuaXRzQXJyICl7XG4gICAgICAgIHN3aXRjaCggdmFsQXJyLmxlbmd0aCApe1xuICAgICAgICAgIGNhc2UgMjogLy8gY2FuIGJlICUgb3IgcHggb25seVxuICAgICAgICAgICAgcmV0dXJuIHVuaXRzQXJyWzBdICE9PSAnZGVnJyAmJiB1bml0c0FyclswXSAhPT0gJ3JhZCcgJiYgdW5pdHNBcnJbMV0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzFdICE9PSAncmFkJztcbiAgICAgICAgICBjYXNlIDE6IC8vIGNhbiBiZSBlbnVtLCBkZWcsIG9yIHJhZCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gaXMuc3RyaW5nKCB2YWxBcnJbMF0gKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVhc2luZzoge1xuICAgICAgcmVnZXhlczogW1xuICAgICAgICAnXihzcHJpbmcpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSQnLFxuICAgICAgICAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJ1xuICAgICAgXSxcbiAgICAgIGVudW1zOiBbXG4gICAgICAgICdsaW5lYXInLFxuICAgICAgICAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JyxcbiAgICAgICAgJ2Vhc2UtaW4tc2luZScsICdlYXNlLW91dC1zaW5lJywgJ2Vhc2UtaW4tb3V0LXNpbmUnLFxuICAgICAgICAnZWFzZS1pbi1xdWFkJywgJ2Vhc2Utb3V0LXF1YWQnLCAnZWFzZS1pbi1vdXQtcXVhZCcsXG4gICAgICAgICdlYXNlLWluLWN1YmljJywgJ2Vhc2Utb3V0LWN1YmljJywgJ2Vhc2UtaW4tb3V0LWN1YmljJyxcbiAgICAgICAgJ2Vhc2UtaW4tcXVhcnQnLCAnZWFzZS1vdXQtcXVhcnQnLCAnZWFzZS1pbi1vdXQtcXVhcnQnLFxuICAgICAgICAnZWFzZS1pbi1xdWludCcsICdlYXNlLW91dC1xdWludCcsICdlYXNlLWluLW91dC1xdWludCcsXG4gICAgICAgICdlYXNlLWluLWV4cG8nLCAnZWFzZS1vdXQtZXhwbycsICdlYXNlLWluLW91dC1leHBvJyxcbiAgICAgICAgJ2Vhc2UtaW4tY2lyYycsICdlYXNlLW91dC1jaXJjJywgJ2Vhc2UtaW4tb3V0LWNpcmMnXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIHZhciB6T3JkZXJEaWZmID0ge1xuICAgIHplcm9Ob25aZXJvOiBmdW5jdGlvbiggdmFsMSwgdmFsMiApe1xuICAgICAgaWYoIHZhbDEgPT09IDAgJiYgdmFsMiAhPT0gMCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiggdmFsMSAhPT0gMCAmJiB2YWwyID09PSAwICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW55RGlmZjogZnVuY3Rpb24oIHZhbDEsIHZhbDIgKXtcbiAgICAgIHJldHVybiB2YWwxICE9PSB2YWwyO1xuICAgIH1cbiAgfTtcblxuICB2YXIgemQgPSB6T3JkZXJEaWZmO1xuXG4gIC8vIGRlZmluZSB2aXN1YWwgc3R5bGUgcHJvcGVydGllc1xuICB2YXIgdCA9IHN0eWZuLnR5cGVzO1xuICB2YXIgcHJvcHMgPSBzdHlmbi5wcm9wZXJ0aWVzID0gW1xuICAgIC8vIG1haW4gbGFiZWxcbiAgICB7IG5hbWU6ICdsYWJlbCcsIHR5cGU6IHQudGV4dCB9LFxuICAgIHsgbmFtZTogJ3RleHQtcm90YXRpb24nLCB0eXBlOiB0LnRleHRSb3RhdGlvbiB9LFxuICAgIHsgbmFtZTogJ3RleHQtbWFyZ2luLXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1tYXJnaW4teScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcblxuICAgIC8vIHNvdXJjZSBsYWJlbFxuICAgIHsgbmFtZTogJ3NvdXJjZS1sYWJlbCcsIHR5cGU6IHQudGV4dCB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teCcsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtdGV4dC1vZmZzZXQnLCB0eXBlOiB0LnNpemUgfSxcblxuICAgIC8vIHRhcmdldCBsYWJlbFxuICAgIHsgbmFtZTogJ3RhcmdldC1sYWJlbCcsIHR5cGU6IHQudGV4dCB9LFxuICAgIHsgbmFtZTogJ3RhcmdldC10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teCcsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtdGV4dC1vZmZzZXQnLCB0eXBlOiB0LnNpemUgfSxcblxuICAgIC8vIGNvbW1vbiBsYWJlbCBzdHlsZVxuICAgIHsgbmFtZTogJ3RleHQtdmFsaWduJywgdHlwZTogdC52YWxpZ24gfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWhhbGlnbicsIHR5cGU6IHQuaGFsaWduIH0sXG4gICAgeyBuYW1lOiAnY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsIHR5cGU6IHQuYm9yZGVyU3R5bGUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLCB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGV9LFxuICAgIC8vIHsgbmFtZTogJ3RleHQtZGVjb3JhdGlvbicsIHR5cGU6IHQudGV4dERlY29yYXRpb24gfSwgLy8gbm90IHN1cHBvcnRlZCBpbiBjYW52YXNcbiAgICB7IG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsIHR5cGU6IHQudGV4dFRyYW5zZm9ybSB9LFxuICAgIHsgbmFtZTogJ3RleHQtd3JhcCcsIHR5cGU6IHQudGV4dFdyYXAgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtZXZlbnRzJywgdHlwZTogdC5ib29sIH0sXG4gICAgeyBuYW1lOiAnZm9udC1mYW1pbHknLCB0eXBlOiB0LmZvbnRGYW1pbHkgfSxcbiAgICB7IG5hbWU6ICdmb250LXN0eWxlJywgdHlwZTogdC5mb250U3R5bGUgfSxcbiAgICAvLyB7IG5hbWU6ICdmb250LXZhcmlhbnQnLCB0eXBlOiB0LmZvbnRWYXJpYW50IH0sIC8vIG5vdCB1c2VmdWxcbiAgICB7IG5hbWU6ICdmb250LXdlaWdodCcsIHR5cGU6IHQuZm9udFdlaWdodCB9LFxuICAgIHsgbmFtZTogJ2ZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyBiZWhhdmlvdXJcbiAgICB7IG5hbWU6ICdldmVudHMnLCB0eXBlOiB0LmJvb2wgfSxcblxuICAgIC8vIHZpc2liaWxpdHlcbiAgICB7IG5hbWU6ICdkaXNwbGF5JywgdHlwZTogdC5kaXNwbGF5LCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LFxuICAgIHsgbmFtZTogJ3Zpc2liaWxpdHknLCB0eXBlOiB0LnZpc2liaWxpdHksIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sXG4gICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciwgdHJpZ2dlcnNaT3JkZXI6IHpkLnplcm9Ob25aZXJvIH0sXG4gICAgeyBuYW1lOiAnei1jb21wb3VuZC1kZXB0aCcsIHR5cGU6IHQuekNvbXBvdW5kRGVwdGgsIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sXG4gICAgeyBuYW1lOiAnei1pbmRleC1jb21wYXJlJywgdHlwZTogdC56SW5kZXhDb21wYXJlLCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LFxuICAgIHsgbmFtZTogJ3otaW5kZXgnLCB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50LCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LFxuXG4gICAgLy8gb3ZlcmxheXNcbiAgICB7IG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdvdmVybGF5LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgLy8gc2hhZG93c1xuICAgIHsgbmFtZTogJ3NoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NoYWRvdy1vZmZzZXQteScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcblxuICAgIC8vIGxhYmVsIHNoYWRvd3NcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuXG4gICAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsIHR5cGU6IHQucHJvcExpc3QgfSxcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdHlwZTogdC50aW1lIH0sXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LFxuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgdHlwZTogdC5lYXNpbmcgfSxcblxuICAgIC8vIG5vZGUgYm9keVxuICAgIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQubm9kZVNpemUgfSxcbiAgICB7IG5hbWU6ICd3aWR0aCcsIHR5cGU6IHQubm9kZVNpemUgfSxcbiAgICB7IG5hbWU6ICdzaGFwZScsIHR5cGU6IHQubm9kZVNoYXBlIH0sXG4gICAgeyBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLCB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsIHR5cGU6IHQubk9uZU9uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcblxuICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgeyBuYW1lOiAnYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2JvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuXG4gICAgLy8gbm9kZSBiYWNrZ3JvdW5kIGltYWdlc1xuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCB0eXBlOiB0LmJnQ3Jvc3NPcmlnaW4gfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgdHlwZTogdC5iZ1BvcyB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JywgdHlwZTogdC5iZ1JlcGVhdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtZml0JywgdHlwZTogdC5iZ0ZpdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsIHR5cGU6IHQuYmdDbGlwIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsIHR5cGU6IHQuYmdXSCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JywgdHlwZTogdC5iZ1dIIH0sXG5cbiAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogdC5wb3NpdGlvbiB9LFxuICAgIHsgbmFtZTogJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJywgdHlwZTogdC5jb21wb3VuZEluY2x1ZGVMYWJlbHMgfSxcbiAgICB7IG5hbWU6ICdtaW4td2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdtaW4td2lkdGgtYmlhcy1sZWZ0JywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sXG4gICAgeyBuYW1lOiAnbWluLXdpZHRoLWJpYXMtcmlnaHQnLCB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQgfSxcbiAgICB7IG5hbWU6ICdtaW4taGVpZ2h0JywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnbWluLWhlaWdodC1iaWFzLXRvcCcsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LFxuICAgIHsgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nLCB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQgfSxcblxuICAgIC8vIGVkZ2UgbGluZVxuICAgIHsgbmFtZTogJ2xpbmUtc3R5bGUnLCB0eXBlOiB0LmxpbmVTdHlsZSB9LFxuICAgIHsgbmFtZTogJ2xpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnY3VydmUtc3R5bGUnLCB0eXBlOiB0LmN1cnZlU3R5bGUgfSxcbiAgICB7IG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtZW5kcG9pbnQnLCB0eXBlOiB0LmVkZ2VFbmRwb2ludCB9LFxuICAgIHsgbmFtZTogJ3RhcmdldC1lbmRwb2ludCcsIHR5cGU6IHQuZWRnZUVuZHBvaW50IH0sXG4gICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzIH0sXG4gICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJywgdHlwZTogdC5udW1iZXJzIH0sXG4gICAgeyBuYW1lOiAnc2VnbWVudC1kaXN0YW5jZXMnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyB9LFxuICAgIHsgbmFtZTogJ3NlZ21lbnQtd2VpZ2h0cycsIHR5cGU6IHQubnVtYmVycyB9LFxuICAgIHsgbmFtZTogJ2VkZ2UtZGlzdGFuY2VzJywgdHlwZTogdC5lZGdlRGlzdGFuY2VzIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctc2NhbGUnLCB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnbG9vcC1kaXJlY3Rpb24nLCB0eXBlOiB0LmFuZ2xlIH0sXG4gICAgeyBuYW1lOiAnbG9vcC1zd2VlcCcsIHR5cGU6IHQuYW5nbGUgfSxcbiAgICB7IG5hbWU6ICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgLy8gdGhlc2UgYXJlIGp1c3QgZm9yIHRoZSBjb3JlXG4gICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH1cbiAgXTtcblxuICAvLyBkZWZpbmUgYWxpYXNlc1xuICB2YXIgYWxpYXNlcyA9IHN0eWZuLmFsaWFzZXMgPSBbXG4gICAgeyBuYW1lOiAnY29udGVudCcsIHBvaW50c1RvOiAnbGFiZWwnIH0sXG4gICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnIH0sXG4gICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLCBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycgfSxcbiAgICB7IG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLCBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1sZWZ0JywgcG9pbnRzVG86ICdwYWRkaW5nJyB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmctcmlnaHQnLCBwb2ludHNUbzogJ3BhZGRpbmcnIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy10b3AnLCBwb2ludHNUbzogJ3BhZGRpbmcnIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1ib3R0b20nLCBwb2ludHNUbzogJ3BhZGRpbmcnIH1cbiAgXTtcblxuICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gIHN0eWZuLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBwcm9wcy5wdXNoKCB7IG5hbWU6ICdwaWUtc2l6ZScsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9ICk7XG4gIGZvciggdmFyIGkgPSAxOyBpIDw9IHN0eWZuLnBpZUJhY2tncm91bmROOyBpKysgKXtcbiAgICBwcm9wcy5wdXNoKCB7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0gKTtcbiAgICBwcm9wcy5wdXNoKCB7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsIHR5cGU6IHQucGVyY2VudCB9ICk7XG4gICAgcHJvcHMucHVzaCggeyBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSApO1xuICB9XG5cbiAgLy8gZWRnZSBhcnJvd3NcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbi5hcnJvd1ByZWZpeGVzID0gWyAnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnIF07XG4gIFtcbiAgICB7IG5hbWU6ICdhcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgIHsgbmFtZTogJ2Fycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2Fycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9XG4gIF0uZm9yRWFjaCggZnVuY3Rpb24oIHByb3AgKXtcbiAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goIGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG5cbiAgICAgIHByb3BzLnB1c2goIHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSB9ICk7XG4gICAgfSApO1xuICB9LCB7fSApO1xuXG4gIC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgc3R5Zm4ucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcCggZnVuY3Rpb24oIHAgKXsgcmV0dXJuIHAubmFtZTsgfSApO1xuXG4gIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuIHN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBwcm9wID0gcHJvcHNbIGkgXTtcblxuICAgIHByb3BzWyBwcm9wLm5hbWUgXSA9IHByb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cblxuICAvLyBtYXAgYWxpYXNlc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgYWxpYXMgPSBhbGlhc2VzWyBpIF07XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzWyBhbGlhcy5wb2ludHNUbyBdO1xuICAgIHZhciBhbGlhc1Byb3AgPSB7XG4gICAgICBuYW1lOiBhbGlhcy5uYW1lLFxuICAgICAgYWxpYXM6IHRydWUsXG4gICAgICBwb2ludHNUbzogcG9pbnRzVG9Qcm9wXG4gICAgfTtcblxuICAgIC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG4gICAgcHJvcHMucHVzaCggYWxpYXNQcm9wICk7XG5cbiAgICBwcm9wc1sgYWxpYXMubmFtZSBdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG5zdHlmbi5nZXREZWZhdWx0UHJvcGVydHkgPSBmdW5jdGlvbiggbmFtZSApe1xuICByZXR1cm4gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcygpWyBuYW1lIF07XG59O1xuXG5zdHlmbi5nZXREZWZhdWx0UHJvcGVydGllcyA9IHV0aWwubWVtb2l6ZSggZnVuY3Rpb24oKXtcbiAgdmFyIHJhd1Byb3BzID0gdXRpbC5leHRlbmQoIHtcbiAgICAvLyBjb21tb24gbm9kZS9lZGdlIHByb3BzXG4gICAgJ2V2ZW50cyc6ICd5ZXMnLFxuICAgICd0ZXh0LWV2ZW50cyc6ICdubycsXG4gICAgJ3RleHQtdmFsaWduJzogJ3RvcCcsXG4gICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICd0ZXh0LW1heC13aWR0aCc6IDk5OTksXG4gICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnOiAwLFxuICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICd0ZXh0LWJvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxcbiAgICAnZm9udC1zdHlsZSc6ICdub3JtYWwnLFxuICAgIC8vICdmb250LXZhcmlhbnQnOiBmb250VmFyaWFudCxcbiAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAnZm9udC1zaXplJzogMTYsXG4gICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAndGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAnc291cmNlLXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3RhcmdldC10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICdvcGFjaXR5JzogMSxcbiAgICAnei1jb21wb3VuZC1kZXB0aCc6ICdhdXRvJyxcbiAgICAnei1pbmRleC1jb21wYXJlJzogJ2F1dG8nLFxuICAgICd6LWluZGV4JzogMCxcbiAgICAnbGFiZWwnOiAnJyxcbiAgICAndGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RleHQtbWFyZ2luLXknOiAwLFxuICAgICdzb3VyY2UtbGFiZWwnOiAnJyxcbiAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3RhcmdldC1sYWJlbCc6ICcnLFxuICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ3NoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAnc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICdzaGFkb3ctYmx1cic6IDEwLFxuICAgICdzaGFkb3ctb2Zmc2V0LXgnOiAwLFxuICAgICdzaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICd0ZXh0LXNoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1zaGFkb3ctY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtc2hhZG93LWJsdXInOiA1LFxuICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgJ3RleHQtc2hhZG93LW9mZnNldC15JzogMCxcbiAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICdsaW5lYXInLFxuXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnYXV0bycsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICdoZWlnaHQnOiAzMCxcbiAgICAnd2lkdGgnOiAzMCxcbiAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgJ3BhZGRpbmcnOiAwLFxuICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcbiAgICAnbWluLXdpZHRoJzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLXJpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy10b3AnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogMFxuICB9LCB7XG4gICAgLy8gbm9kZSBwaWUgYmdcbiAgICAncGllLXNpemUnOiAnMTAwJSdcbiAgfSwgW1xuICAgIHsgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLWNvbG9yJywgdmFsdWU6ICdibGFjaycgfSxcbiAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJywgdmFsdWU6ICcwJScgfSxcbiAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JywgdmFsdWU6IDEgfVxuICBdLnJlZHVjZSggZnVuY3Rpb24oIGNzcywgcHJvcCApe1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IHN0eWZuLnBpZUJhY2tncm91bmROOyBpKysgKXtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoICd7e2l9fScsIGkgKTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuXG4gICAgICBjc3NbIG5hbWUgXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSApLCB7XG4gICAgLy8gZWRnZSBwcm9wc1xuICAgICdsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnbGluZS1jb2xvcic6ICcjOTk5JyxcbiAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgJ2VkZ2UtZGlzdGFuY2VzJzogJ2ludGVyc2VjdGlvbicsXG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgJ2hheXN0YWNrLXJhZGl1cyc6IDAsXG4gICAgJ2Fycm93LXNjYWxlJzogMSxcbiAgICAnbG9vcC1kaXJlY3Rpb24nOiAnLTEzNWRlZycsXG4gICAgJ2xvb3Atc3dlZXAnOiAnLTkwZGVnJyxcbiAgICAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZSdcbiAgfSwgW1xuICAgIHsgbmFtZTogJ2Fycm93LXNoYXBlJywgdmFsdWU6ICdub25lJyB9LFxuICAgIHsgbmFtZTogJ2Fycm93LWNvbG9yJywgdmFsdWU6ICcjOTk5JyB9LFxuICAgIHsgbmFtZTogJ2Fycm93LWZpbGwnLCB2YWx1ZTogJ2ZpbGxlZCcgfVxuICBdLnJlZHVjZSggZnVuY3Rpb24oIGNzcywgcHJvcCApe1xuICAgIHN0eWZuLmFycm93UHJlZml4ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHByZWZpeCApe1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcblxuICAgICAgY3NzWyBuYW1lIF0gPSB2YWw7XG4gICAgfSApO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30gKSApO1xuXG4gIHZhciBwYXJzZWRQcm9wcyA9IHt9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG5cbiAgICBpZiggcHJvcC5wb2ludHNUbyApeyBjb250aW51ZTsgfVxuXG4gICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgdmFyIHZhbCA9IHJhd1Byb3BzWyBuYW1lIF07XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBuYW1lLCB2YWwgKTtcblxuICAgIHBhcnNlZFByb3BzWyBuYW1lIF0gPSBwYXJzZWRQcm9wO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFByb3BzO1xufSApO1xuXG5zdHlmbi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXNcbiAgICAuc2VsZWN0b3IoICckbm9kZSA+IG5vZGUnICkgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKCB7XG4gICAgICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAncGFkZGluZyc6IDEwLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZWVlJyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAgICAgJ2JvcmRlci13aWR0aCc6IDFcbiAgICAgIH0gKVxuICAgIC5zZWxlY3RvciggJ2VkZ2UnICkgLy8ganVzdCBlZGdlIHByb3BlcnRpZXNcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ3dpZHRoJzogMyxcbiAgICAgICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJ1xuICAgICAgfSApXG4gICAgLnNlbGVjdG9yKCAnOnNlbGVjdGVkJyApXG4gICAgICAuY3NzKCB7XG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknXG4gICAgICB9IClcbiAgICAuc2VsZWN0b3IoICdub2RlOnBhcmVudDpzZWxlY3RlZCcgKVxuICAgICAgLmNzcygge1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjQ0NFMUY5JyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjYWVjOGU1J1xuICAgICAgfSApXG4gICAgLnNlbGVjdG9yKCAnOmFjdGl2ZScgKVxuICAgICAgLmNzcygge1xuICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgICAgIH0gKVxuICAgIC5zZWxlY3RvciggJ2NvcmUnICkgLy8ganVzdCBjb3JlIHByb3BlcnRpZXNcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjVcbiAgICAgIH0gKVxuICA7XG5cbiAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSggJy4uL3NlbGVjdG9yJyApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0cmluZyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoIC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycgKTtcblxuICBmdW5jdGlvbiByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKXtcbiAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICBpZiggcmVtYWluaW5nLmxlbmd0aCA+IHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApe1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0ciggc2VsQW5kQmxvY2tTdHIubGVuZ3RoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCl7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgcHJvcGVydHkgYW5kIHZhbHVlIGZyb20gdGhlIHJlbWFpbmluZyBibG9jayB0ZXh0IHRvIHBhcnNlXG4gICAgaWYoIGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoICl7XG4gICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0ciggcHJvcEFuZFZhbFN0ci5sZW5ndGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICB9XG4gIH1cblxuICB3aGlsZSggdHJ1ZSApe1xuICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goIC9eXFxzKiQvICk7XG4gICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKCAvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vICk7XG5cbiAgICBpZiggIXNlbEFuZEJsb2NrICl7XG4gICAgICB1dGlsLmVycm9yKCAnSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTtcblxuICAgIC8vIHBhcnNlIHRoZSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgIGlmKCBzZWxlY3RvclN0ciAhPT0gJ2NvcmUnICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG4gICAgICBpZiggc2VsZWN0b3IuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBzZWxlY3RvciBmb3VuZCBpbiBzdHJpbmcgc3R5bGVzaGVldDogJyArIHNlbGVjdG9yU3RyICk7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHNlbGVjdG9yIGFuZCBibG9ja1xuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgd2hpbGUoIHRydWUgKXtcbiAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSBibG9ja1JlbS5tYXRjaCggL15cXHMqJC8gKTtcbiAgICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCggL15cXHMqKC4rPylcXHMqOlxccyooLis/KVxccyo7LyApO1xuXG4gICAgICBpZiggIXByb3BBbmRWYWwgKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyICk7XG4gICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgIHZhciBwcm9wU3RyID0gcHJvcEFuZFZhbFsxXTtcbiAgICAgIHZhciB2YWxTdHIgPSBwcm9wQW5kVmFsWzJdO1xuXG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgcHJvcFN0ciBdO1xuICAgICAgaWYoICFwcm9wICl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0ciApO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UoIHByb3BTdHIsIHZhbFN0ciApO1xuXG4gICAgICBpZiggIXBhcnNlZFByb3AgKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyICk7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCgge1xuICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgfSApO1xuICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICB9XG5cbiAgICBpZiggaW52YWxpZEJsb2NrICl7XG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIGkgXTtcbiAgICAgIHN0eWxlLmNzcyggcHJvcC5uYW1lLCBwcm9wLnZhbCApO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBseUZyb21TdHJpbmcoIHN0cmluZyApO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApO1xudmFyIFN0eWxlID0gcmVxdWlyZSggJy4vc3R5bGUnICk7XG5cbi8vIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3QgdGhhdCBkb2Vzbid0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmVcbi8vICh1c2VmdWwgZm9yIGluaXQpXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSApe1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAnc3R5bGVzaGVldCc7XG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuXG4gIHRoaXNbIGkgXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW11cbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgaWYoIGlzLnN0cmluZyggbmFtZSApICl7XG4gICAgdGhpc1sgaSBdLnByb3BlcnRpZXMucHVzaCgge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0gKTtcbiAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggbmFtZSApICl7XG4gICAgdmFyIG1hcCA9IG5hbWU7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IFN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1sgaiBdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFsgcHJvcC5uYW1lIF07XG5cbiAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApeyAvLyBhbHNvIHRyeSBjYW1lbCBjYXNlIG5hbWVcbiAgICAgICAgbWFwVmFsID0gbWFwWyB1dGlsLmRhc2gyY2FtZWwoIHByb3AubmFtZSApIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHZhbHVlID0gbWFwVmFsO1xuXG4gICAgICAgIHRoaXNbIGkgXS5wcm9wZXJ0aWVzLnB1c2goIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zaGVldGZuLnN0eWxlID0gc2hlZXRmbi5jc3M7XG5cbi8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZSggY3kgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbIGkgXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaiBdO1xuXG4gICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVzaGVldDtcbiIsIi8qISBXZWF2ZXIgbGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL3RsZHJsZWdhbC5jb20vbGljZW5zZS9taXQtbGljZW5zZSksIGNvcHlyaWdodCBNYXggRnJhbnogKi9cblxuLy8gY3Jvc3MtZW52IHRocmVhZC93b3JrZXJcbi8vIE5CIDogdXNlcyAoaGVhdnl3ZWlnaHQpIHByb2Nlc3NlcyBvbiBub2RlanMgc28gYmVzdCBub3QgdG8gY3JlYXRlIHRvbyBtYW55IHRocmVhZHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnLi93aW5kb3cnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJy4vZGVmaW5lJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbnZhciBUaHJlYWQgPSBmdW5jdGlvbiggb3B0cyApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgVGhyZWFkKSApe1xuICAgIHJldHVybiBuZXcgVGhyZWFkKCBvcHRzICk7XG4gIH1cblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIHJlcXVpcmVzOiBbXSxcbiAgICBmaWxlczogW10sXG4gICAgcXVldWU6IG51bGwsXG4gICAgcGFzczogW10sXG4gICAgZGlzYWJsZWQ6IGZhbHNlXG4gIH07XG5cbiAgaWYoIGlzLnBsYWluT2JqZWN0KG9wdHMpICl7XG4gICAgaWYoIG9wdHMuZGlzYWJsZWQgIT0gbnVsbCApe1xuICAgICAgX3AuZGlzYWJsZWQgPSAhIW9wdHMuZGlzYWJsZWQ7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciB0aGRmbiA9IFRocmVhZC5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbnZhciBzdHJpbmdpZnlGaWVsZFZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgdmFyIHZhbFN0ciA9IGlzLmZuKCB2YWwgKSA/IHZhbC50b1N0cmluZygpIDogXCJKU09OLnBhcnNlKCdcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyBcIicpXCI7XG5cbiAgcmV0dXJuIHZhbFN0cjtcbn07XG5cbi8vIGFsbG93cyBmb3IgcmVxdWlyZXMgd2l0aCBwcm90b3R5cGVzIGFuZCBzdWJvYmpzIGV0Y1xudmFyIGZuQXNSZXF1aXJlID0gZnVuY3Rpb24oIGZuICl7XG4gIHZhciByZXE7XG4gIHZhciBmbk5hbWU7XG5cbiAgaWYoIGlzLm9iamVjdChmbikgJiYgZm4uZm4gKXsgLy8gbWFudWFsIGZuXG4gICAgcmVxID0gZm5BcyggZm4uZm4sIGZuLm5hbWUgKTtcbiAgICBmbk5hbWUgPSBmbi5uYW1lO1xuICAgIGZuID0gZm4uZm47XG4gIH0gZWxzZSBpZiggaXMuZm4oZm4pICl7IC8vIGF1dG8gZm5cbiAgICByZXEgPSBmbi50b1N0cmluZygpO1xuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gIH0gZWxzZSBpZiggaXMuc3RyaW5nKGZuKSApeyAvLyBzdHJpbmdpZmllZCBmblxuICAgIHJlcSA9IGZuO1xuICB9IGVsc2UgaWYoIGlzLm9iamVjdChmbikgKXsgLy8gcGxhaW4gb2JqZWN0XG4gICAgaWYoIGZuLnByb3RvICl7XG4gICAgICByZXEgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxID0gZm4ubmFtZSArICcgPSB7fTsnO1xuICAgIH1cblxuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgZm4gPSBmbi5vYmo7XG4gIH1cblxuICByZXEgKz0gJ1xcbic7XG5cbiAgdmFyIHByb3RvcmVxID0gZnVuY3Rpb24oIHZhbCwgc3VibmFtZSApe1xuICAgIGlmKCB2YWwucHJvdG90eXBlICl7XG4gICAgICB2YXIgcHJvdG9Ob25lbXB0eSA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgcHJvcCBpbiB2YWwucHJvdG90eXBlICl7IHByb3RvTm9uZW1wdHkgPSB0cnVlOyBicmVhazsgfSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgaWYoIHByb3RvTm9uZW1wdHkgKXtcbiAgICAgICAgcmVxICs9IGZuQXNSZXF1aXJlKCB7XG4gICAgICAgICAgbmFtZTogc3VibmFtZSxcbiAgICAgICAgICBvYmo6IHZhbCxcbiAgICAgICAgICBwcm90bzogdHJ1ZVxuICAgICAgICB9LCB2YWwgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcHVsbCBpbiBwcm90b3R5cGVcbiAgaWYoIGZuLnByb3RvdHlwZSAmJiBmbk5hbWUgIT0gbnVsbCApe1xuXG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbi5wcm90b3R5cGUgKXtcbiAgICAgIHZhciBwcm90b1N0ciA9ICcnO1xuXG4gICAgICB2YXIgdmFsID0gZm4ucHJvdG90eXBlWyBuYW1lIF07XG4gICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnLnByb3RvdHlwZS4nICsgbmFtZTtcblxuICAgICAgcHJvdG9TdHIgKz0gc3VibmFtZSArICcgPSAnICsgdmFsU3RyICsgJztcXG4nO1xuXG4gICAgICBpZiggcHJvdG9TdHIgKXtcbiAgICAgICAgcmVxICs9IHByb3RvU3RyO1xuICAgICAgfVxuXG4gICAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICAgIH1cblxuICB9XG5cbiAgLy8gcHVsbCBpbiBwcm9wZXJ0aWVzIGZvciBvYmovZm5zXG4gIGlmKCAhaXMuc3RyaW5nKGZuKSApeyBmb3IoIHZhciBuYW1lIGluIGZuICl7XG4gICAgdmFyIHByb3BzU3RyID0gJyc7XG5cbiAgICBpZiggZm4uaGFzT3duUHJvcGVydHkobmFtZSkgKXtcbiAgICAgIHZhciB2YWwgPSBmblsgbmFtZSBdO1xuICAgICAgdmFyIHZhbFN0ciA9IHN0cmluZ2lmeUZpZWxkVmFsKCB2YWwgKTtcbiAgICAgIHZhciBzdWJuYW1lID0gZm5OYW1lICsgJ1tcIicgKyBuYW1lICsgJ1wiXSc7XG5cbiAgICAgIHByb3BzU3RyICs9IHN1Ym5hbWUgKyAnID0gJyArIHZhbFN0ciArICc7XFxuJztcbiAgICB9XG5cbiAgICBpZiggcHJvcHNTdHIgKXtcbiAgICAgIHJlcSArPSBwcm9wc1N0cjtcbiAgICB9XG5cbiAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICB9IH1cblxuICByZXR1cm4gcmVxO1xufTtcblxudmFyIGlzUGF0aFN0ciA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgcmV0dXJuIGlzLnN0cmluZyhzdHIpICYmIHN0ci5tYXRjaCgvXFwuanMkLyk7XG59O1xuXG51dGlsLmV4dGVuZCh0aGRmbiwge1xuXG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gJ3RocmVhZCc7IH0sXG5cbiAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgIHZhciByZXF1aXJlcyA9IHRoaXMuX3ByaXZhdGUucmVxdWlyZXM7XG5cbiAgICBpZiggaXNQYXRoU3RyKGZuKSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5maWxlcy5wdXNoKCBmbiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggYXMgKXtcbiAgICAgIGlmKCBpcy5mbihmbikgKXtcbiAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBmbjogZm4gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuID0geyBuYW1lOiBhcywgb2JqOiBmbiB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggaXMuZm4oZm4pICl7XG4gICAgICAgIGlmKCAhZm4ubmFtZSApe1xuICAgICAgICAgIHRocm93ICdUaGUgZnVuY3Rpb24gbmFtZSBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkLiAgVXNlIHRocmVhZC5yZXF1aXJlKCBzb21lRnVuY3Rpb24sIFwic29tZUZ1bmN0aW9uXCIgKSc7XG4gICAgICAgIH1cblxuICAgICAgICBmbiA9IHsgbmFtZTogZm4ubmFtZSwgZm46IGZuIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWlyZXMucHVzaCggZm4gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhc3M6IGZ1bmN0aW9uKCBkYXRhICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5wYXNzLnB1c2goIGRhdGEgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHJ1bjogZnVuY3Rpb24oIGZuLCBwYXNzICl7IC8vIGZuIHVzZWQgbGlrZSBtYWluKClcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBwYXNzID0gcGFzcyB8fCBfcC5wYXNzLnNoaWZ0KCk7XG5cbiAgICBpZiggX3Auc3RvcHBlZCApe1xuICAgICAgdGhyb3cgJ0F0dGVtcHRlZCB0byBydW4gYSBzdG9wcGVkIHRocmVhZCEgIFN0YXJ0IGEgbmV3IHRocmVhZCBvciBkbyBub3Qgc3RvcCB0aGUgZXhpc3RpbmcgdGhyZWFkIGFuZCByZXVzZSBpdC4nO1xuICAgIH1cblxuICAgIGlmKCBfcC5ydW5uaW5nICl7XG4gICAgICByZXR1cm4gKCBfcC5xdWV1ZSA9IF9wLnF1ZXVlLnRoZW4oZnVuY3Rpb24oKXsgLy8gaW5kdWN0aXZlIHN0ZXBcbiAgICAgICAgcmV0dXJuIHNlbGYucnVuKCBmbiwgcGFzcyApO1xuICAgICAgfSkgKTtcbiAgICB9XG5cbiAgICB2YXIgdXNlV1cgPSB3aW5kb3cgIT0gbnVsbCAmJiAhX3AuZGlzYWJsZWQ7XG4gICAgdmFyIHVzZU5vZGUgPSAhd2luZG93ICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmICFfcC5kaXNhYmxlZDtcblxuICAgIHNlbGYudHJpZ2dlcigncnVuJyk7XG5cbiAgICB2YXIgcnVuUCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcblxuICAgICAgX3AucnVubmluZyA9IHRydWU7XG5cbiAgICAgIHZhciB0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyA9IF9wLnJhbjtcblxuICAgICAgdmFyIGZuSW1wbFN0ciA9IGlzLnN0cmluZyggZm4gKSA/IGZuIDogZm4udG9TdHJpbmcoKTtcblxuICAgICAgLy8gd29ya2VyIGNvZGUgdG8gZXhlY1xuICAgICAgdmFyIGZuU3RyID0gJ1xcbicgKyAoIF9wLnJlcXVpcmVzLm1hcChmdW5jdGlvbiggciApe1xuICAgICAgICByZXR1cm4gZm5Bc1JlcXVpcmUoIHIgKTtcbiAgICAgIH0pICkuY29uY2F0KCBfcC5maWxlcy5tYXAoZnVuY3Rpb24oIGYgKXtcbiAgICAgICAgaWYoIHVzZVdXICl7XG4gICAgICAgICAgdmFyIHd3aWZ5RmlsZSA9IGZ1bmN0aW9uKCBmaWxlICl7XG4gICAgICAgICAgICBpZiggZmlsZS5tYXRjaCgvXlxcLlxcLy8pIHx8IGZpbGUubWF0Y2goL15cXC5cXC4vKSApe1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGZpbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGZpbGUubWF0Y2goL15cXC8vKSApe1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArICcvJyArIGZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuICdpbXBvcnRTY3JpcHRzKFwiJyArIHd3aWZ5RmlsZShmKSArICdcIik7JztcbiAgICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICkge1xuICAgICAgICAgIHJldHVybiAnZXZhbCggcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhcIicgKyBmICsgJ1wiLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KSApOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0V4dGVybmFsIGZpbGUgYCcgKyBmICsgJ2AgY2FuIG5vdCBiZSByZXF1aXJlZCB3aXRob3V0IGFueSB0aHJlYWRpbmcgdGVjaG5vbG9neS4nO1xuICAgICAgICB9XG4gICAgICB9KSApLmNvbmNhdChbXG4gICAgICAgICcoIGZ1bmN0aW9uKCl7JyxcbiAgICAgICAgICAndmFyIHJldCA9ICgnICsgZm5JbXBsU3RyICsgJykoJyArIEpTT04uc3RyaW5naWZ5KHBhc3MpICsgJyk7JyxcbiAgICAgICAgICAnaWYoIHJldCAhPT0gdW5kZWZpbmVkICl7IHJlc29sdmUocmV0KTsgfScsIC8vIGFzc3VtZSBpZiByYW4gZm4gcmV0dXJucyBkZWZpbmVkIHZhbHVlIChpbmNsLiBudWxsKSwgdGhhdCB3ZSB3YW50IHRvIHJlc29sdmUgdG8gaXRcbiAgICAgICAgJ30gKSgpXFxuJ1xuICAgICAgXSkuam9pbignXFxuJyk7XG5cbiAgICAgIC8vIGJlY2F1c2Ugd2UndmUgbm93IGNvbnN1bWVkIHRoZSByZXF1aXJlcywgZW1wdHkgdGhlIGxpc3Qgc28gd2UgZG9uJ3QgZHVwZSBvbiBuZXh0IHJ1bigpXG4gICAgICBfcC5yZXF1aXJlcyA9IFtdO1xuICAgICAgX3AuZmlsZXMgPSBbXTtcblxuICAgICAgaWYoIHVzZVdXICl7XG4gICAgICAgIHZhciBmbkJsb2IsIGZuVXJsO1xuXG4gICAgICAgIC8vIGFkZCBub3JtYWxpc2VkIHRocmVhZCBhcGkgZnVuY3Rpb25zXG4gICAgICAgIGlmKCAhdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXtcbiAgICAgICAgICB2YXIgZm5QcmUgPSBmblN0ciArICcnO1xuXG4gICAgICAgICAgZm5TdHIgPSBbXG4gICAgICAgICAgICAnZnVuY3Rpb24gX3JlZl8obyl7IHJldHVybiBldmFsKG8pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gYnJvYWRjYXN0KG0peyByZXR1cm4gbWVzc2FnZShtKTsgfTsnLCAvLyBhbGlhc1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG1lc3NhZ2UobSl7IHBvc3RNZXNzYWdlKG0pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsnLFxuICAgICAgICAgICAgJyAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihtKXsgJyxcbiAgICAgICAgICAgICcgICAgaWYoIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIChtLmRhdGEuJCRldmFsIHx8IG0uZGF0YSA9PT0gXCIkJHN0YXJ0XCIpICl7JyxcbiAgICAgICAgICAgICcgICAgfSBlbHNlIHsgJyxcbiAgICAgICAgICAgICcgICAgICBmbiggbS5kYXRhICk7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICB9KTsnLFxuICAgICAgICAgICAgJ307JyxcbiAgICAgICAgICAgICdzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAgaWYoIG0uZGF0YS4kJGV2YWwgKXsgZXZhbCggbS5kYXRhLiQkZXZhbCApOyB9ICB9KTsnLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlc29sdmUodil7IHBvc3RNZXNzYWdlKHsgJCRyZXNvbHZlOiB2IH0pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gcmVqZWN0KHYpeyBwb3N0TWVzc2FnZSh7ICQkcmVqZWN0OiB2IH0pOyB9OydcbiAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgZm5TdHIgKz0gZm5QcmU7XG5cbiAgICAgICAgICBmbkJsb2IgPSBuZXcgQmxvYihbIGZuU3RyIF0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZuVXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIGZuQmxvYiApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSB3ZWJ3b3JrZXIgYW5kIGxldCBpdCBleGVjIHRoZSBzZXJpYWxpc2VkIGNvZGVcbiAgICAgICAgdmFyIHd3ID0gX3Aud2Vid29ya2VyID0gX3Aud2Vid29ya2VyIHx8IG5ldyBXb3JrZXIoIGZuVXJsICk7XG5cbiAgICAgICAgaWYoIHRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7IC8vIHRoZW4ganVzdCBleGVjIG5ldyBydW4oKSBjb2RlXG4gICAgICAgICAgd3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJCRldmFsOiBmblN0clxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29ya2VyIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICB2YXIgY2I7XG4gICAgICAgIHd3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgdmFyIGlzT2JqZWN0ID0gaXMub2JqZWN0KG0pICYmIGlzLm9iamVjdCggbS5kYXRhICk7XG5cbiAgICAgICAgICBpZiggaXNPYmplY3QgJiYgKCckJHJlc29sdmUnIGluIG0uZGF0YSkgKXtcbiAgICAgICAgICAgIHd3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgcmVzb2x2ZSggbS5kYXRhLiQkcmVzb2x2ZSApO1xuICAgICAgICAgIH0gZWxzZSBpZiggaXNPYmplY3QgJiYgKCckJHJlamVjdCcgaW4gbS5kYXRhKSApe1xuICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgIHJlamVjdCggbS5kYXRhLiQkcmVqZWN0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3IEV2ZW50KG0sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtLmRhdGEgfSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBpZiggIXRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7XG4gICAgICAgICAgd3cucG9zdE1lc3NhZ2UoJyQkc3RhcnQnKTsgLy8gc3RhcnQgdXAgdGhlIHdvcmtlclxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggdXNlTm9kZSApe1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcHJvY2Vzc1xuXG4gICAgICAgIGlmKCAhX3AuY2hpbGQgKXtcbiAgICAgICAgICBfcC5jaGlsZCA9ICggcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmZvcmsoIHJlcXVpcmUoJ3BhdGgnKS5qb2luKF9fZGlybmFtZSwgJ3RocmVhZC1ub2RlLWZvcmsnKSApICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBfcC5jaGlsZDtcblxuICAgICAgICAvLyBjaGlsZCBwcm9jZXNzIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICB2YXIgY2I7XG4gICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgY2IgPSBmdW5jdGlvbiggbSApe1xuICAgICAgICAgIGlmKCBpcy5vYmplY3QobSkgJiYgKCckJHJlc29sdmUnIGluIG0pICl7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlc29sdmUoKVxuXG4gICAgICAgICAgICByZXNvbHZlKCBtLiQkcmVzb2x2ZSApO1xuICAgICAgICAgIH0gZWxzZSBpZiggaXMub2JqZWN0KG0pICYmICgnJCRyZWplY3QnIGluIG0pICl7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgIHJlamVjdCggbS4kJHJlamVjdCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoIG5ldyBFdmVudCh7fSwgeyB0eXBlOiAnbWVzc2FnZScsIG1lc3NhZ2U6IG0gfSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFzayB0aGUgY2hpbGQgcHJvY2VzcyB0byBldmFsIHRoZSB3b3JrZXIgY29kZVxuICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgIH0pO1xuXG4gICAgICB9IGVsc2UgeyAvLyB1c2UgYSBmYWxsYmFjayBtZWNoYW5pc20gdXNpbmcgYSB0aW1lb3V0XG5cbiAgICAgICAgdmFyIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgdmFyIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG5cbiAgICAgICAgdmFyIHRpbWVyID0gX3AudGltZXIgPSBfcC50aW1lciB8fCB7XG5cbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuXG4gICAgICAgICAgZXhlYzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIGFzIGEgc3RyaW5nIHNvIGl0IGNhbid0IGJlIG1hbmdsZWQgYnkgbWluaWZpZXJzIGFuZCBwcm9jZXNzb3JzXG4gICAgICAgICAgICBmblN0ciA9IFtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIF9yZWZfKG8peyByZXR1cm4gZXZhbChvKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gYnJvYWRjYXN0KG0peyByZXR1cm4gbWVzc2FnZShtKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbWVzc2FnZShtKXsgc2VsZi50cmlnZ2VyKCBuZXcgRXZlbnQoe30sIHsgdHlwZTogXCJtZXNzYWdlXCIsIG1lc3NhZ2U6IG0gfSkgKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsgdGltZXIubGlzdGVuZXJzLnB1c2goIGZuICk7IH07JyxcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlc29sdmUodil7IHByb21pc2VSZXNvbHZlKHYpOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiByZWplY3Qodil7IHByb21pc2VSZWplY3Qodik7IH07J1xuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSArIGZuU3RyO1xuXG4gICAgICAgICAgICAvLyB0aGUgLnJ1bigpIGNvZGVcbiAgICAgICAgICAgIGV2YWwoIGZuU3RyICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBtZXNzYWdlOiBmdW5jdGlvbiggbSApe1xuICAgICAgICAgICAgdmFyIGxzID0gdGltZXIubGlzdGVuZXJzO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBmbiA9IGxzW2ldO1xuXG4gICAgICAgICAgICAgIGZuKCBtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGltZXIuZXhlYygpO1xuICAgICAgfVxuXG4gICAgfSkudGhlbihmdW5jdGlvbiggdiApe1xuICAgICAgX3AucnVubmluZyA9IGZhbHNlO1xuICAgICAgX3AucmFuID0gdHJ1ZTtcblxuICAgICAgc2VsZi50cmlnZ2VyKCdyYW4nKTtcblxuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG5cbiAgICBpZiggX3AucXVldWUgPT0gbnVsbCApe1xuICAgICAgX3AucXVldWUgPSBydW5QOyAvLyBpLmUuIGZpcnN0IHN0ZXAgb2YgaW5kdWN0aXZlIHByb21pc2UgY2hhaW4gKGZvciBxdWV1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gcnVuUDtcbiAgfSxcblxuICAvLyBzZW5kIHRoZSB0aHJlYWQgYSBtZXNzYWdlXG4gIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC53ZWJ3b3JrZXIgKXtcbiAgICAgIF9wLndlYndvcmtlci5wb3N0TWVzc2FnZSggbSApO1xuICAgIH1cblxuICAgIGlmKCBfcC5jaGlsZCApe1xuICAgICAgX3AuY2hpbGQuc2VuZCggbSApO1xuICAgIH1cblxuICAgIGlmKCBfcC50aW1lciApe1xuICAgICAgX3AudGltZXIubWVzc2FnZSggbSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC53ZWJ3b3JrZXIgKXtcbiAgICAgIF9wLndlYndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG5cbiAgICBpZiggX3AuY2hpbGQgKXtcbiAgICAgIF9wLmNoaWxkLmtpbGwoKTtcbiAgICB9XG5cbiAgICBpZiggX3AudGltZXIgKXtcbiAgICAgIC8vIG5vdGhpbmcgd2UgY2FuIGRvIGlmIHdlJ3ZlIHJ1biBhIHRpbWVvdXRcbiAgICB9XG5cbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3N0b3AnKTsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzdG9wcGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0b3BwZWQ7XG4gIH1cblxufSk7XG5cbi8vIHR1cm5zIGEgc3RyaW5naWZpZWQgZnVuY3Rpb24gaW50byBhIChyZSluYW1lZCBmdW5jdGlvblxudmFyIGZuQXMgPSBmdW5jdGlvbiggZm4sIG5hbWUgKXtcbiAgdmFyIGZuU3RyID0gZm4udG9TdHJpbmcoKTtcbiAgZm5TdHIgPSBmblN0ci5yZXBsYWNlKC9mdW5jdGlvblxccyo/XFxTKj9cXHMqP1xcKC8sICdmdW5jdGlvbiAnICsgbmFtZSArICcoJyk7XG5cbiAgcmV0dXJuIGZuU3RyO1xufTtcblxudmFyIGRlZmluZUZuYWwgPSBmdW5jdGlvbiggb3B0cyApe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gZm5hbEltcGwoIGZuLCBhcmcxICl7XG4gICAgdmFyIGZuU3RyID0gZm5BcyggZm4sICdfJF8kXycgKyBvcHRzLm5hbWUgKTtcblxuICAgIHRoaXMucmVxdWlyZSggZm5TdHIgKTtcblxuICAgIHJldHVybiB0aGlzLnJ1biggW1xuICAgICAgJ2Z1bmN0aW9uKCBkYXRhICl7JyxcbiAgICAgICcgIHZhciBvcmlnUmVzb2x2ZSA9IHJlc29sdmU7JyxcbiAgICAgICcgIHZhciByZXMgPSBbXTsnLFxuICAgICAgJyAgJyxcbiAgICAgICcgIHJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7JyxcbiAgICAgICcgICAgcmVzLnB1c2goIHZhbCApOycsXG4gICAgICAnICB9OycsXG4gICAgICAnICAnLFxuICAgICAgJyAgdmFyIHJldCA9IGRhdGEuJyArIG9wdHMubmFtZSArICcoIF8kXyRfJyArIG9wdHMubmFtZSArICggYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAnLCAnICsgSlNPTi5zdHJpbmdpZnkoYXJnMSkgOiAnJyApICsgJyApOycsXG4gICAgICAnICAnLFxuICAgICAgJyAgcmVzb2x2ZSA9IG9yaWdSZXNvbHZlOycsXG4gICAgICAnICByZXNvbHZlKCByZXMubGVuZ3RoID4gMCA/IHJlcyA6IHJldCApOycsXG4gICAgICAnfSdcbiAgICBdLmpvaW4oJ1xcbicpICk7XG4gIH07XG59O1xuXG51dGlsLmV4dGVuZCh0aGRmbiwge1xuICByZWR1Y2U6IGRlZmluZUZuYWwoeyBuYW1lOiAncmVkdWNlJyB9KSxcblxuICByZWR1Y2VSaWdodDogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2VSaWdodCcgfSksXG5cbiAgbWFwOiBkZWZpbmVGbmFsKHsgbmFtZTogJ21hcCcgfSlcbn0pO1xuXG4vLyBhbGlhc2VzXG52YXIgZm4gPSB0aGRmbjtcbmZuLnByb21pc2UgPSBmbi5ydW47XG5mbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbmZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4vLyBwdWxsIGluIGV2ZW50IGFwaXNcbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG4gIG9uOiBkZWZpbmUub24oKSxcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSxcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKVxufSk7XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbiggdGhkZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgaGV4MnR1cGxlOiBmdW5jdGlvbiggaGV4ICl7XG4gICAgaWYoICEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJyApeyByZXR1cm47IH1cblxuICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgdmFyIHIsIGcsIGI7XG4gICAgdmFyIGJhc2UgPSAxNjtcblxuICAgIGlmKCBzaG9ydEhleCApe1xuICAgICAgciA9IHBhcnNlSW50KCBoZXhbMV0gKyBoZXhbMV0sIGJhc2UgKTtcbiAgICAgIGcgPSBwYXJzZUludCggaGV4WzJdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICBiID0gcGFyc2VJbnQoIGhleFszXSArIGhleFszXSwgYmFzZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgZyA9IHBhcnNlSW50KCBoZXhbM10gKyBoZXhbNF0sIGJhc2UgKTtcbiAgICAgIGIgPSBwYXJzZUludCggaGV4WzVdICsgaGV4WzZdLCBiYXNlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsgciwgZywgYiBdO1xuICB9LFxuXG4gIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKXtcbiAgICAgIGlmKCB0IDwgMCApIHQgKz0gMTtcbiAgICAgIGlmKCB0ID4gMSApIHQgLT0gMTtcbiAgICAgIGlmKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgIGlmKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcbiAgICAgIGlmKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoICdeJyArIHRoaXMucmVnZXguaHNsYSArICckJyApLmV4ZWMoIGhzbCApO1xuICAgIGlmKCBtICl7XG5cbiAgICAgIC8vIGdldCBodWVcbiAgICAgIGggPSBwYXJzZUludCggbVsxXSApO1xuICAgICAgaWYoIGggPCAwICl7XG4gICAgICAgIGggPSAoIDM2MCAtICgtMSAqIGggJSAzNjApICkgJSAzNjA7XG4gICAgICB9IGVsc2UgaWYoIGggPiAzNjAgKXtcbiAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICB9XG4gICAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBzID0gcGFyc2VGbG9hdCggbVsyXSApO1xuICAgICAgaWYoIHMgPCAwIHx8IHMgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cbiAgICAgIHMgPSBzIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGwgPSBwYXJzZUZsb2F0KCBtWzNdICk7XG4gICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBhID0gbVs0XTtcbiAgICAgIGlmKCBhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICBpZiggYSA8IDAgfHwgYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgICAgfVxuXG4gICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgICAgaWYoIHMgPT09IDAgKXtcbiAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZCggbCAqIDI1NSApOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYiggcCwgcSwgaCArIDEgLyAzICkgKTtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IoIHAsIHEsIGggKSApO1xuICAgICAgICBiID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYiggcCwgcSwgaCAtIDEgLyAzICkgKTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gWyByLCBnLCBiLCBhIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcbiAgcmdiMnR1cGxlOiBmdW5jdGlvbiggcmdiICl7XG4gICAgdmFyIHJldDtcblxuICAgIHZhciBtID0gbmV3IFJlZ0V4cCggJ14nICsgdGhpcy5yZWdleC5yZ2JhICsgJyQnICkuZXhlYyggcmdiICk7XG4gICAgaWYoIG0gKXtcbiAgICAgIHJldCA9IFtdO1xuXG4gICAgICB2YXIgaXNQY3QgPSBbXTtcbiAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IDM7IGkrKyApe1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG1bIGkgXTtcblxuICAgICAgICBpZiggY2hhbm5lbFsgY2hhbm5lbC5sZW5ndGggLSAxIF0gPT09ICclJyApe1xuICAgICAgICAgIGlzUGN0WyBpIF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KCBjaGFubmVsICk7XG5cbiAgICAgICAgaWYoIGlzUGN0WyBpIF0gKXtcbiAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICAgIH1cblxuICAgICAgICBpZiggY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goIE1hdGguZmxvb3IoIGNoYW5uZWwgKSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICBpZiggYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QgKXsgcmV0dXJuOyB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICB2YXIgYWxwaGEgPSBtWzRdO1xuICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KCBhbHBoYSApO1xuXG4gICAgICAgIGlmKCBhbHBoYSA8IDAgfHwgYWxwaGEgPiAxICl7IHJldHVybjsgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBjb2xvcm5hbWUydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgIHJldHVybiB0aGlzLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICB9LFxuXG4gIGNvbG9yMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICByZXR1cm4gKCBpcy5hcnJheSggY29sb3IgKSA/IGNvbG9yIDogbnVsbCApXG4gICAgICB8fCB0aGlzLmNvbG9ybmFtZTJ0dXBsZSggY29sb3IgKVxuICAgICAgfHwgdGhpcy5oZXgydHVwbGUoIGNvbG9yIClcbiAgICAgIHx8IHRoaXMucmdiMnR1cGxlKCBjb2xvciApXG4gICAgICB8fCB0aGlzLmhzbDJ0dXBsZSggY29sb3IgKTtcbiAgfSxcblxuICBjb2xvcnM6IHtcbiAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICBhbGljZWJsdWU6IFsgMjQwLCAyNDgsIDI1NSBdLFxuICAgIGFudGlxdWV3aGl0ZTogWyAyNTAsIDIzNSwgMjE1IF0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1IF0sXG4gICAgYXF1YW1hcmluZTogWyAxMjcsIDI1NSwgMjEyIF0sXG4gICAgYXp1cmU6IFsgMjQwLCAyNTUsIDI1NSBdLFxuICAgIGJlaWdlOiBbIDI0NSwgMjQ1LCAyMjAgXSxcbiAgICBiaXNxdWU6IFsgMjU1LCAyMjgsIDE5NiBdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsgMjU1LCAyMzUsIDIwNSBdLFxuICAgIGJsdWU6IFswLCAwLCAyNTUgXSxcbiAgICBibHVldmlvbGV0OiBbIDEzOCwgNDMsIDIyNiBdLFxuICAgIGJyb3duOiBbIDE2NSwgNDIsIDQyIF0sXG4gICAgYnVybHl3b29kOiBbIDIyMiwgMTg0LCAxMzUgXSxcbiAgICBjYWRldGJsdWU6IFsgOTUsIDE1OCwgMTYwIF0sXG4gICAgY2hhcnRyZXVzZTogWyAxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbIDIxMCwgMTA1LCAzMCBdLFxuICAgIGNvcmFsOiBbIDI1NSwgMTI3LCA4MCBdLFxuICAgIGNvcm5mbG93ZXJibHVlOiBbIDEwMCwgMTQ5LCAyMzcgXSxcbiAgICBjb3Juc2lsazogWyAyNTUsIDI0OCwgMjIwIF0sXG4gICAgY3JpbXNvbjogWyAyMjAsIDIwLCA2MCBdLFxuICAgIGN5YW46IFswLCAyNTUsIDI1NSBdLFxuICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5IF0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOSBdLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFsgMTg0LCAxMzQsIDExIF0sXG4gICAgZGFya2dyYXk6IFsgMTY5LCAxNjksIDE2OSBdLFxuICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgZGFya2dyZXk6IFsgMTY5LCAxNjksIDE2OSBdLFxuICAgIGRhcmtraGFraTogWyAxODksIDE4MywgMTA3IF0sXG4gICAgZGFya21hZ2VudGE6IFsgMTM5LCAwLCAxMzkgXSxcbiAgICBkYXJrb2xpdmVncmVlbjogWyA4NSwgMTA3LCA0NyBdLFxuICAgIGRhcmtvcmFuZ2U6IFsgMjU1LCAxNDAsIDBdLFxuICAgIGRhcmtvcmNoaWQ6IFsgMTUzLCA1MCwgMjA0IF0sXG4gICAgZGFya3JlZDogWyAxMzksIDAsIDBdLFxuICAgIGRhcmtzYWxtb246IFsgMjMzLCAxNTAsIDEyMiBdLFxuICAgIGRhcmtzZWFncmVlbjogWyAxNDMsIDE4OCwgMTQzIF0sXG4gICAgZGFya3NsYXRlYmx1ZTogWyA3MiwgNjEsIDEzOSBdLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOSBdLFxuICAgIGRhcmt2aW9sZXQ6IFsgMTQ4LCAwLCAyMTEgXSxcbiAgICBkZWVwcGluazogWyAyNTUsIDIwLCAxNDcgXSxcbiAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1IF0sXG4gICAgZGltZ3JheTogWyAxMDUsIDEwNSwgMTA1IF0sXG4gICAgZGltZ3JleTogWyAxMDUsIDEwNSwgMTA1IF0sXG4gICAgZG9kZ2VyYmx1ZTogWyAzMCwgMTQ0LCAyNTUgXSxcbiAgICBmaXJlYnJpY2s6IFsgMTc4LCAzNCwgMzQgXSxcbiAgICBmbG9yYWx3aGl0ZTogWyAyNTUsIDI1MCwgMjQwIF0sXG4gICAgZm9yZXN0Z3JlZW46IFsgMzQsIDEzOSwgMzQgXSxcbiAgICBmdWNoc2lhOiBbIDI1NSwgMCwgMjU1IF0sXG4gICAgZ2FpbnNib3JvOiBbIDIyMCwgMjIwLCAyMjAgXSxcbiAgICBnaG9zdHdoaXRlOiBbIDI0OCwgMjQ4LCAyNTUgXSxcbiAgICBnb2xkOiBbIDI1NSwgMjE1LCAwXSxcbiAgICBnb2xkZW5yb2Q6IFsgMjE4LCAxNjUsIDMyIF0sXG4gICAgZ3JheTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgZ3JleTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgIGdyZWVueWVsbG93OiBbIDE3MywgMjU1LCA0NyBdLFxuICAgIGhvbmV5ZGV3OiBbIDI0MCwgMjU1LCAyNDAgXSxcbiAgICBob3RwaW5rOiBbIDI1NSwgMTA1LCAxODAgXSxcbiAgICBpbmRpYW5yZWQ6IFsgMjA1LCA5MiwgOTIgXSxcbiAgICBpbmRpZ286IFsgNzUsIDAsIDEzMCBdLFxuICAgIGl2b3J5OiBbIDI1NSwgMjU1LCAyNDAgXSxcbiAgICBraGFraTogWyAyNDAsIDIzMCwgMTQwIF0sXG4gICAgbGF2ZW5kZXI6IFsgMjMwLCAyMzAsIDI1MCBdLFxuICAgIGxhdmVuZGVyYmx1c2g6IFsgMjU1LCAyNDAsIDI0NSBdLFxuICAgIGxhd25ncmVlbjogWyAxMjQsIDI1MiwgMF0sXG4gICAgbGVtb25jaGlmZm9uOiBbIDI1NSwgMjUwLCAyMDUgXSxcbiAgICBsaWdodGJsdWU6IFsgMTczLCAyMTYsIDIzMCBdLFxuICAgIGxpZ2h0Y29yYWw6IFsgMjQwLCAxMjgsIDEyOCBdLFxuICAgIGxpZ2h0Y3lhbjogWyAyMjQsIDI1NSwgMjU1IF0sXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsgMjUwLCAyNTAsIDIxMCBdLFxuICAgIGxpZ2h0Z3JheTogWyAyMTEsIDIxMSwgMjExIF0sXG4gICAgbGlnaHRncmVlbjogWyAxNDQsIDIzOCwgMTQ0IF0sXG4gICAgbGlnaHRncmV5OiBbIDIxMSwgMjExLCAyMTEgXSxcbiAgICBsaWdodHBpbms6IFsgMjU1LCAxODIsIDE5MyBdLFxuICAgIGxpZ2h0c2FsbW9uOiBbIDI1NSwgMTYwLCAxMjIgXSxcbiAgICBsaWdodHNlYWdyZWVuOiBbIDMyLCAxNzgsIDE3MCBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjUwIF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBbIDExOSwgMTM2LCAxNTMgXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWyAxNzYsIDE5NiwgMjIyIF0sXG4gICAgbGlnaHR5ZWxsb3c6IFsgMjU1LCAyNTUsIDIyNCBdLFxuICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgIGxpbWVncmVlbjogWyA1MCwgMjA1LCA1MCBdLFxuICAgIGxpbmVuOiBbIDI1MCwgMjQwLCAyMzAgXSxcbiAgICBtYWdlbnRhOiBbIDI1NSwgMCwgMjU1IF0sXG4gICAgbWFyb29uOiBbIDEyOCwgMCwgMF0sXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWyAxMDIsIDIwNSwgMTcwIF0sXG4gICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNSBdLFxuICAgIG1lZGl1bW9yY2hpZDogWyAxODYsIDg1LCAyMTEgXSxcbiAgICBtZWRpdW1wdXJwbGU6IFsgMTQ3LCAxMTIsIDIxOSBdLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbIDYwLCAxNzksIDExMyBdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWyAxMjMsIDEwNCwgMjM4IF0sXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NCBdLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogWyA3MiwgMjA5LCAyMDQgXSxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFsgMTk5LCAyMSwgMTMzIF0sXG4gICAgbWlkbmlnaHRibHVlOiBbIDI1LCAyNSwgMTEyIF0sXG4gICAgbWludGNyZWFtOiBbIDI0NSwgMjU1LCAyNTAgXSxcbiAgICBtaXN0eXJvc2U6IFsgMjU1LCAyMjgsIDIyNSBdLFxuICAgIG1vY2Nhc2luOiBbIDI1NSwgMjI4LCAxODEgXSxcbiAgICBuYXZham93aGl0ZTogWyAyNTUsIDIyMiwgMTczIF0sXG4gICAgbmF2eTogWzAsIDAsIDEyOCBdLFxuICAgIG9sZGxhY2U6IFsgMjUzLCAyNDUsIDIzMCBdLFxuICAgIG9saXZlOiBbIDEyOCwgMTI4LCAwXSxcbiAgICBvbGl2ZWRyYWI6IFsgMTA3LCAxNDIsIDM1IF0sXG4gICAgb3JhbmdlOiBbIDI1NSwgMTY1LCAwXSxcbiAgICBvcmFuZ2VyZWQ6IFsgMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbIDIxOCwgMTEyLCAyMTQgXSxcbiAgICBwYWxlZ29sZGVucm9kOiBbIDIzOCwgMjMyLCAxNzAgXSxcbiAgICBwYWxlZ3JlZW46IFsgMTUyLCAyNTEsIDE1MiBdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsgMTc1LCAyMzgsIDIzOCBdLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFsgMjE5LCAxMTIsIDE0NyBdLFxuICAgIHBhcGF5YXdoaXA6IFsgMjU1LCAyMzksIDIxMyBdLFxuICAgIHBlYWNocHVmZjogWyAyNTUsIDIxOCwgMTg1IF0sXG4gICAgcGVydTogWyAyMDUsIDEzMywgNjMgXSxcbiAgICBwaW5rOiBbIDI1NSwgMTkyLCAyMDMgXSxcbiAgICBwbHVtOiBbIDIyMSwgMTYwLCAyMjEgXSxcbiAgICBwb3dkZXJibHVlOiBbIDE3NiwgMjI0LCAyMzAgXSxcbiAgICBwdXJwbGU6IFsgMTI4LCAwLCAxMjggXSxcbiAgICByZWQ6IFsgMjU1LCAwLCAwXSxcbiAgICByb3N5YnJvd246IFsgMTg4LCAxNDMsIDE0MyBdLFxuICAgIHJveWFsYmx1ZTogWyA2NSwgMTA1LCAyMjUgXSxcbiAgICBzYWRkbGVicm93bjogWyAxMzksIDY5LCAxOSBdLFxuICAgIHNhbG1vbjogWyAyNTAsIDEyOCwgMTE0IF0sXG4gICAgc2FuZHlicm93bjogWyAyNDQsIDE2NCwgOTYgXSxcbiAgICBzZWFncmVlbjogWyA0NiwgMTM5LCA4NyBdLFxuICAgIHNlYXNoZWxsOiBbIDI1NSwgMjQ1LCAyMzggXSxcbiAgICBzaWVubmE6IFsgMTYwLCA4MiwgNDUgXSxcbiAgICBzaWx2ZXI6IFsgMTkyLCAxOTIsIDE5MiBdLFxuICAgIHNreWJsdWU6IFsgMTM1LCAyMDYsIDIzNSBdLFxuICAgIHNsYXRlYmx1ZTogWyAxMDYsIDkwLCAyMDUgXSxcbiAgICBzbGF0ZWdyYXk6IFsgMTEyLCAxMjgsIDE0NCBdLFxuICAgIHNsYXRlZ3JleTogWyAxMTIsIDEyOCwgMTQ0IF0sXG4gICAgc25vdzogWyAyNTUsIDI1MCwgMjUwIF0sXG4gICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyNyBdLFxuICAgIHN0ZWVsYmx1ZTogWyA3MCwgMTMwLCAxODAgXSxcbiAgICB0YW46IFsgMjEwLCAxODAsIDE0MCBdLFxuICAgIHRlYWw6IFswLCAxMjgsIDEyOCBdLFxuICAgIHRoaXN0bGU6IFsgMjE2LCAxOTEsIDIxNiBdLFxuICAgIHRvbWF0bzogWyAyNTUsIDk5LCA3MSBdLFxuICAgIHR1cnF1b2lzZTogWyA2NCwgMjI0LCAyMDggXSxcbiAgICB2aW9sZXQ6IFsgMjM4LCAxMzAsIDIzOCBdLFxuICAgIHdoZWF0OiBbIDI0NSwgMjIyLCAxNzkgXSxcbiAgICB3aGl0ZTogWyAyNTUsIDI1NSwgMjU1IF0sXG4gICAgd2hpdGVzbW9rZTogWyAyNDUsIDI0NSwgMjQ1IF0sXG4gICAgeWVsbG93OiBbIDI1NSwgMjU1LCAwXSxcbiAgICB5ZWxsb3dncmVlbjogWyAxNTQsIDIwNSwgNTAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmdsb2JhbCBjb25zb2xlICovXG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uL21hdGgnICk7XG5cbnZhciB1dGlsID0ge1xuXG4gIHRydWVpZnk6IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9LFxuXG4gIGZhbHNpZnk6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfSxcblxuICB6ZXJvaWZ5OiBmdW5jdGlvbigpeyByZXR1cm4gMDsgfSxcblxuICBub29wOiBmdW5jdGlvbigpe30sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKXtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGlmKCBjb25zb2xlLmVycm9yICl7XG4gICAgICBjb25zb2xlLmVycm9yLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCgge30sIG9iaiApO1xuICB9LFxuXG4gIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gIGNvcHk6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBpZiggaXMuYXJyYXkoIG9iaiApICl7XG4gICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggb2JqICkgKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCBvYmogKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sXG5cbiAgdXVpZDogZnVuY3Rpb24oXG4gICAgICBhLGIgICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXJzXG4gICl7XG4gICAgICBmb3IoICAgICAgICAgICAgICAgLy8gbG9vcCA6KVxuICAgICAgICAgIGI9YT0nJzsgICAgICAgIC8vIGIgLSByZXN1bHQgLCBhIC0gbnVtZXJpYyB2YXJpYWJsZVxuICAgICAgICAgIGErKzwzNjsgICAgICAgIC8vXG4gICAgICAgICAgYis9YSo1MSY1MiAgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgICAgICAgICAgICAgICAgICAgICA/ICAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgYV4xNSAgICAgIC8vIGlmIFwiYVwiIGlzIG5vdCAxNVxuICAgICAgICAgICAgICAgICAgPyAgICAgIC8vIGdlbmV0YXRlIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgICAgICAgICAgICAgIDheTWF0aC5yYW5kb20oKSpcbiAgICAgICAgICAgICAgIChhXjIwPzE2OjQpICAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICAgICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgNCAgICAgICAgICAgIC8vICBvdGhlcndpc2UgNFxuICAgICAgICAgICAgICAgKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgJy0nICAgICAgICAgICAgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGI7XG4gIH1cblxufTtcblxudXRpbC5tYWtlQm91bmRpbmdCb3ggPSBtYXRoLm1ha2VCb3VuZGluZ0JveC5iaW5kKCBtYXRoICk7XG5cbnV0aWwuX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG5cbnV0aWwuc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdXRpbC5fc3RhdGljRW1wdHlPYmplY3Q7XG59O1xuXG51dGlsLmV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiggdGd0ICl7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGZvciggdmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBvYmogPSBhcmdzWyBpIF07XG5cbiAgICBpZiggIW9iaiApeyBjb250aW51ZTsgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggb2JqICk7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcblxuICAgICAgdGd0WyBrIF0gPSBvYmpbIGsgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGd0O1xufTtcblxudXRpbC5kZWZhdWx0ID0gZnVuY3Rpb24oIHZhbCwgZGVmICl7XG4gIGlmKCB2YWwgPT09IHVuZGVmaW5lZCApe1xuICAgIHJldHVybiBkZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcblxudXRpbC5yZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiggYXJyLCBlbGUsIG1hbnlDb3BpZXMgKXtcbiAgZm9yKCB2YXIgaSA9IGFyci5sZW5ndGg7IGkgPj0gMDsgaS0tICl7XG4gICAgaWYoIGFycltpXSA9PT0gZWxlICl7XG4gICAgICBhcnIuc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgIGlmKCAhbWFueUNvcGllcyApeyBicmVhazsgfVxuICAgIH1cbiAgfVxufTtcblxudXRpbC5jbGVhckFycmF5ID0gZnVuY3Rpb24oIGFyciApe1xuICBhcnIuc3BsaWNlKCAwLCBhcnIubGVuZ3RoICk7XG59O1xuXG51dGlsLmdldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiggb2JqLCBwcm9wTmFtZSwgcHJlZml4ICl7XG4gIGlmKCBwcmVmaXggKXtcbiAgICBwcm9wTmFtZSA9IHRoaXMucHJlcGVuZENhbWVsKCBwcmVmaXgsIHByb3BOYW1lICk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgcmV0dXJuIG9ialsgcHJvcE5hbWUgXTtcbn07XG5cbnV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICl7XG4gIGlmKCBwcmVmaXggKXtcbiAgICBwcm9wTmFtZSA9IHRoaXMucHJlcGVuZENhbWVsKCBwcmVmaXgsIHByb3BOYW1lICk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqWyBwcm9wTmFtZSBdID0gdmFsdWU7XG59O1xuXG5bXG4gIHJlcXVpcmUoICcuL2NvbG9ycycgKSxcbiAgcmVxdWlyZSggJy4vbWFwcycgKSxcbiAgeyBtZW1vaXplOiByZXF1aXJlKCAnLi9tZW1vaXplJyApIH0sXG4gIHJlcXVpcmUoICcuL3JlZ2V4JyApLFxuICByZXF1aXJlKCAnLi9zdHJpbmdzJyApLFxuICByZXF1aXJlKCAnLi90aW1pbmcnIClcbl0uZm9yRWFjaCggZnVuY3Rpb24oIHJlcSApe1xuICB1dGlsLmV4dGVuZCggdXRpbCwgcmVxICk7XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gaGFzIGFueXRoaW5nIGJlZW4gc2V0IGluIHRoZSBtYXBcbiAgbWFwRW1wdHk6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgaWYoIG1hcCAhPSBudWxsICl7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoIG1hcCApLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH0sXG5cbiAgLy8gcHVzaGVzIHRvIHRoZSBhcnJheSBhdCB0aGUgZW5kIG9mIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgcHVzaE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmdldE1hcCggb3B0aW9ucyApO1xuXG4gICAgaWYoIGFycmF5ID09IG51bGwgKXsgLy8gaWYgZW1wdHksIHB1dCBpbml0aWFsIGFycmF5XG4gICAgICB0aGlzLnNldE1hcCggdGhpcy5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHZhbHVlOiBbIG9wdGlvbnMudmFsdWUgXVxuICAgICAgfSApICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LnB1c2goIG9wdGlvbnMudmFsdWUgKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxuICBzZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIga2V5ID0ga2V5c1sgaSBdO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgIHRoaXMuZXJyb3IoICdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGkgPCBrZXlzLmxlbmd0aCAtIDEgKXtcblxuICAgICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYoIG9ialsga2V5IF0gPT0gbnVsbCApe1xuICAgICAgICAgIG9ialsga2V5IF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9ialsga2V5IF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgIG9ialsga2V5IF0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuICBnZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGtleSA9IGtleXNbIGkgXTtcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICB0aGlzLmVycm9yKCAnVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknICk7XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialsga2V5IF07XG5cbiAgICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuICBkZWxldGVNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGtlZXBDaGlsZHJlbiA9IG9wdGlvbnMua2VlcENoaWxkcmVuO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBrZXkgPSBrZXlzWyBpIF07XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgdGhpcy5lcnJvciggJ1RyaWVkIHRvIGRlbGV0ZSBtYXAgd2l0aCBvYmplY3Qga2V5JyApO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEtleSA9IGkgPT09IG9wdGlvbnMua2V5cy5sZW5ndGggLSAxO1xuICAgICAgaWYoIGxhc3RLZXkgKXtcblxuICAgICAgICBpZigga2VlcENoaWxkcmVuICl7IC8vIHRoZW4gb25seSBkZWxldGUgY2hpbGQgZmllbGRzIG5vdCBpbiBrZWVwQ2hpbGRyZW5cbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBPYmplY3Qua2V5cyggb2JqICk7XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltqXTtcblxuICAgICAgICAgICAgaWYoICFrZWVwQ2hpbGRyZW5bIGNoaWxkIF0gKXtcbiAgICAgICAgICAgICAgb2JqWyBjaGlsZCBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IG9ialsga2V5IF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lbW9pemUoIGZuLCBrZXlGbiApe1xuICBpZiggIWtleUZuICl7XG4gICAga2V5Rm4gPSBmdW5jdGlvbigpe1xuICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGFyZ3MucHVzaCggYXJndW1lbnRzWyBpIF0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbiggJyQnICk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBtZW1vaXplZEZuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgayA9IGtleUZuLmFwcGx5KCBzZWxmLCBhcmdzICk7XG4gICAgdmFyIGNhY2hlID0gbWVtb2l6ZWRGbi5jYWNoZTtcblxuICAgIGlmKCAhKHJldCA9IGNhY2hlWyBrIF0pICl7XG4gICAgICByZXQgPSBjYWNoZVsgayBdID0gZm4uYXBwbHkoIHNlbGYsIGFyZ3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIG1lbW9pemVkRm4uY2FjaGUgPSB7fTtcblxuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXIgPSAnKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKSc7XG5cbnZhciByZ2JhID0gJ3JnYlthXT9cXFxcKCgnICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciByZ2JhTm9CYWNrUmVmcyA9ICdyZ2JbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcblxudmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuXG52YXIgaGV4MyA9ICdcXFxcI1swLTlhLWZBLUZdezN9JztcbnZhciBoZXg2ID0gJ1xcXFwjWzAtOWEtZkEtRl17Nn0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVnZXg6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICByZ2JhOiByZ2JhLFxuICAgIHJnYmFOb0JhY2tSZWZzOiByZ2JhTm9CYWNrUmVmcyxcbiAgICBoc2xhOiBoc2xhLFxuICAgIGhzbGFOb0JhY2tSZWZzOiBoc2xhTm9CYWNrUmVmcyxcbiAgICBoZXgzOiBoZXgzLFxuICAgIGhleDY6IGhleDZcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1lbW9pemUgPSByZXF1aXJlKCAnLi9tZW1vaXplJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjYW1lbDJkYXNoOiBtZW1vaXplKCBmdW5jdGlvbiggc3RyICl7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvKFtBLVpdKS9nLCBmdW5jdGlvbiggdiApe1xuICAgICAgcmV0dXJuICctJyArIHYudG9Mb3dlckNhc2UoKTtcbiAgICB9ICk7XG4gIH0gKSxcblxuICBkYXNoMmNhbWVsOiBtZW1vaXplKCBmdW5jdGlvbiggc3RyICl7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvKC1cXHcpL2csIGZ1bmN0aW9uKCB2ICl7XG4gICAgICByZXR1cm4gdlsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gKTtcbiAgfSApLFxuXG4gIHByZXBlbmRDYW1lbDogbWVtb2l6ZSggZnVuY3Rpb24oIHByZWZpeCwgc3RyICl7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfSwgZnVuY3Rpb24oIHByZWZpeCwgc3RyICl7XG4gICAgcmV0dXJuIHByZWZpeCArICckJyArIHN0cjtcbiAgfSApLFxuXG4gIGNhcGl0YWxpemU6IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICBpZiggaXMuZW1wdHlTdHJpbmcoIHN0ciApICl7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoIDEgKTtcbiAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4uL3dpbmRvdycgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdyA/IHdpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XG5cbnZhciB1dGlsID0ge307XG5cbnZhciByYWYgPSAhd2luZG93ID8gZnVuY3Rpb24oIGZuICl7XG4gIGlmKCBmbiApe1xuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICBmbiggcG5vdygpICk7XG4gICAgfSwgMTAwMCAvIDYwICk7XG4gIH1cbn0gOiAoZnVuY3Rpb24oKXtcbiAgaWYoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuICl7IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZuICk7IH07XG4gIH0gZWxzZSBpZiggd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSApe1xuICAgIHJldHVybiBmdW5jdGlvbiggZm4gKXsgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSggZm4gKTsgfTtcbiAgfSBlbHNlIGlmKCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBmbiApeyB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmbiApOyB9O1xuICB9IGVsc2UgaWYoIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSApe1xuICAgIHJldHVybiBmdW5jdGlvbiggZm4gKXsgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmbiApOyB9O1xuICB9XG59KSgpO1xuXG51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBmbiApe1xuICByYWYoIGZuICk7XG59O1xuXG52YXIgcG5vdyA9IHBlcmZvcm1hbmNlICYmIHBlcmZvcm1hbmNlLm5vdyA/IGZ1bmN0aW9uKCl7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfSA6IGZ1bmN0aW9uKCl7IHJldHVybiBEYXRlLm5vdygpOyB9O1xuXG51dGlsLnBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxuLy8gcG9ydGVkIGxvZGFzaCB0aHJvdHRsZSBmdW5jdGlvblxudXRpbC50aHJvdHRsZSA9IGZ1bmN0aW9uKCBmdW5jLCB3YWl0LCBvcHRpb25zICl7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiggb3B0aW9ucyA9PT0gZmFsc2UgKXtcbiAgICBsZWFkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gIG9wdGlvbnMubWF4V2FpdCA9IHdhaXQ7XG4gIG9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICByZXR1cm4gdXRpbC5kZWJvdW5jZSggZnVuYywgd2FpdCwgb3B0aW9ucyApO1xufTtcblxudXRpbC5ub3cgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbnV0aWwuZGVib3VuY2UgPSBmdW5jdGlvbiggZnVuYywgd2FpdCwgb3B0aW9ucyApeyAvLyBwb3J0ZWQgbG9kYXNoIGRlYm91bmNlIGZ1bmN0aW9uXG4gIHZhciB1dGlsID0gdGhpcztcbiAgdmFyIGFyZ3MsXG4gICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFtcCxcbiAgICAgIHRoaXNBcmcsXG4gICAgICB0aW1lb3V0SWQsXG4gICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiggIWlzLmZuKCBmdW5jICkgKXtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FpdCA9IE1hdGgubWF4KCAwLCB3YWl0ICkgfHwgMDtcbiAgaWYoIG9wdGlvbnMgPT09IHRydWUgKXtcbiAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKE1hdGgubWF4KCB3YWl0LCBvcHRpb25zLm1heFdhaXQgKSB8fCAwKTtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAodXRpbC5ub3coKSAtIHN0YW1wKTtcbiAgICBpZiggcmVtYWluaW5nIDw9IDAgKXtcbiAgICAgIGlmKCBtYXhUaW1lb3V0SWQgKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCBtYXhUaW1lb3V0SWQgKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmKCBpc0NhbGxlZCApe1xuICAgICAgICBsYXN0Q2FsbGVkID0gdXRpbC5ub3coKTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSggdGhpc0FyZywgYXJncyApO1xuICAgICAgICBpZiggIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkICl7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIGRlbGF5ZWQsIHJlbWFpbmluZyApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRpbWVvdXRJZCApe1xuICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0SWQgKTtcbiAgICB9XG4gICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgIGlmKCB0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkgKXtcbiAgICAgIGxhc3RDYWxsZWQgPSB1dGlsLm5vdygpO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSggdGhpc0FyZywgYXJncyApO1xuICAgICAgaWYoICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCApe1xuICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgaWYoIG1heFdhaXQgPT09IGZhbHNlICl7XG4gICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCAhbWF4VGltZW91dElkICYmICFsZWFkaW5nICl7XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgIH1cbiAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMDtcblxuICAgICAgaWYoIGlzQ2FsbGVkICl7XG4gICAgICAgIGlmKCBtYXhUaW1lb3V0SWQgKXtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQoIG1heFRpbWVvdXRJZCApO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSggdGhpc0FyZywgYXJncyApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiggIW1heFRpbWVvdXRJZCApe1xuICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCBtYXhEZWxheWVkLCByZW1haW5pbmcgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIGlzQ2FsbGVkICYmIHRpbWVvdXRJZCApe1xuICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KCB0aW1lb3V0SWQgKTtcbiAgICB9XG4gICAgZWxzZSBpZiggIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0ICl7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCBkZWxheWVkLCB3YWl0ICk7XG4gICAgfVxuICAgIGlmKCBsZWFkaW5nQ2FsbCApe1xuICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSggdGhpc0FyZywgYXJncyApO1xuICAgIH1cbiAgICBpZiggaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkICl7XG4gICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiMi43LjE0XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIi8qIEZpbGVTYXZlci5qc1xuICogQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKiAxLjMuMlxuICogMjAxNi0wNi0xNiAxODoyNToxOVxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IE1JVFxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlLCBpbmRlbnQ6IDQsIGxheGJyZWFrOiB0cnVlLCBsYXhjb21tYTogdHJ1ZSwgc21hcnR0YWJzOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0ZpbGVTYXZlci5qcyAqL1xuXG52YXIgc2F2ZUFzID0gc2F2ZUFzIHx8IChmdW5jdGlvbih2aWV3KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvLyBJRSA8MTAgaXMgZXhwbGljaXRseSB1bnN1cHBvcnRlZFxuXHRpZiAodHlwZW9mIHZpZXcgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXJcblx0XHQgIGRvYyA9IHZpZXcuZG9jdW1lbnRcblx0XHQgIC8vIG9ubHkgZ2V0IFVSTCB3aGVuIG5lY2Vzc2FyeSBpbiBjYXNlIEJsb2IuanMgaGFzbid0IG92ZXJyaWRkZW4gaXQgeWV0XG5cdFx0LCBnZXRfVVJMID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkwgfHwgdmlldztcblx0XHR9XG5cdFx0LCBzYXZlX2xpbmsgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcblx0XHQsIGNhbl91c2Vfc2F2ZV9saW5rID0gXCJkb3dubG9hZFwiIGluIHNhdmVfbGlua1xuXHRcdCwgY2xpY2sgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpO1xuXHRcdFx0bm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0LCBpc19zYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHZpZXcuSFRNTEVsZW1lbnQpIHx8IHZpZXcuc2FmYXJpXG5cdFx0LCBpc19jaHJvbWVfaW9zID0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcblx0XHQsIHRocm93X291dHNpZGUgPSBmdW5jdGlvbihleCkge1xuXHRcdFx0KHZpZXcuc2V0SW1tZWRpYXRlIHx8IHZpZXcuc2V0VGltZW91dCkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IGV4O1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHRcdCwgZm9yY2Vfc2F2ZWFibGVfdHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcblx0XHQvLyB0aGUgQmxvYiBBUEkgaXMgZnVuZGFtZW50YWxseSBicm9rZW4gYXMgdGhlcmUgaXMgbm8gXCJkb3dubG9hZGZpbmlzaGVkXCIgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG5cdFx0LCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSAxMDAwICogNDAgLy8gaW4gbXNcblx0XHQsIHJldm9rZSA9IGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdHZhciByZXZva2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikgeyAvLyBmaWxlIGlzIGFuIG9iamVjdCBVUkxcblx0XHRcdFx0XHRnZXRfVVJMKCkucmV2b2tlT2JqZWN0VVJMKGZpbGUpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBmaWxlIGlzIGEgRmlsZVxuXHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRzZXRUaW1lb3V0KHJldm9rZXIsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCk7XG5cdFx0fVxuXHRcdCwgZGlzcGF0Y2ggPSBmdW5jdGlvbihmaWxlc2F2ZXIsIGV2ZW50X3R5cGVzLCBldmVudCkge1xuXHRcdFx0ZXZlbnRfdHlwZXMgPSBbXS5jb25jYXQoZXZlbnRfdHlwZXMpO1xuXHRcdFx0dmFyIGkgPSBldmVudF90eXBlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHZhciBsaXN0ZW5lciA9IGZpbGVzYXZlcltcIm9uXCIgKyBldmVudF90eXBlc1tpXV07XG5cdFx0XHRcdGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsKGZpbGVzYXZlciwgZXZlbnQgfHwgZmlsZXNhdmVyKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0dGhyb3dfb3V0c2lkZShleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdCwgYXV0b19ib20gPSBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHQvLyBwcmVwZW5kIEJPTSBmb3IgVVRGLTggWE1MIGFuZCB0ZXh0LyogdHlwZXMgKGluY2x1ZGluZyBIVE1MKVxuXHRcdFx0Ly8gbm90ZTogeW91ciBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBjb252ZXJ0IFVURi0xNiBVK0ZFRkYgdG8gRUYgQkIgQkZcblx0XHRcdGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwge3R5cGU6IGJsb2IudHlwZX0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0fVxuXHRcdCwgRmlsZVNhdmVyID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdGlmICghbm9fYXV0b19ib20pIHtcblx0XHRcdFx0YmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QgdHJ5IGEuZG93bmxvYWQsIHRoZW4gd2ViIGZpbGVzeXN0ZW0sIHRoZW4gb2JqZWN0IFVSTHNcblx0XHRcdHZhclxuXHRcdFx0XHQgIGZpbGVzYXZlciA9IHRoaXNcblx0XHRcdFx0LCB0eXBlID0gYmxvYi50eXBlXG5cdFx0XHRcdCwgZm9yY2UgPSB0eXBlID09PSBmb3JjZV9zYXZlYWJsZV90eXBlXG5cdFx0XHRcdCwgb2JqZWN0X3VybFxuXHRcdFx0XHQsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG5cdFx0XHRcdCwgZnNfZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoKGlzX2Nocm9tZV9pb3MgfHwgKGZvcmNlICYmIGlzX3NhZmFyaSkpICYmIHZpZXcuRmlsZVJlYWRlcikge1xuXHRcdFx0XHRcdFx0Ly8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG5cdFx0XHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHVybCA9IGlzX2Nocm9tZV9pb3MgPyByZWFkZXIucmVzdWx0IDogcmVhZGVyLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG5cdFx0XHRcdFx0XHRcdHZhciBwb3B1cCA9IHZpZXcub3Blbih1cmwsICdfYmxhbmsnKTtcblx0XHRcdFx0XHRcdFx0aWYoIXBvcHVwKSB2aWV3LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cdFx0XHRcdFx0XHRcdHVybD11bmRlZmluZWQ7IC8vIHJlbGVhc2UgcmVmZXJlbmNlIGJlZm9yZSBkaXNwYXRjaGluZ1xuXHRcdFx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcblx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGRvbid0IGNyZWF0ZSBtb3JlIG9iamVjdCBVUkxzIHRoYW4gbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCFvYmplY3RfdXJsKSB7XG5cdFx0XHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHR2aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgb3BlbmVkID0gdmlldy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCFvcGVuZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXBwbGUgZG9lcyBub3QgYWxsb3cgd2luZG93Lm9wZW4sIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9Ub29scy9Db25jZXB0dWFsL1NhZmFyaUV4dGVuc2lvbkd1aWRlL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy5odG1sXG5cdFx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0cmV2b2tlKG9iamVjdF91cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHQ7XG5cdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXG5cdFx0XHRpZiAoY2FuX3VzZV9zYXZlX2xpbmspIHtcblx0XHRcdFx0b2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG5cdFx0XHRcdFx0Y2xpY2soc2F2ZV9saW5rKTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZnNfZXJyb3IoKTtcblx0XHR9XG5cdFx0LCBGU19wcm90byA9IEZpbGVTYXZlci5wcm90b3R5cGVcblx0XHQsIHNhdmVBcyA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcblx0XHR9XG5cdDtcblx0Ly8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuXHRcdHJldHVybiBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0bmFtZSA9IG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIjtcblxuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSk7XG5cdFx0fTtcblx0fVxuXG5cdEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24oKXt9O1xuXHRGU19wcm90by5yZWFkeVN0YXRlID0gRlNfcHJvdG8uSU5JVCA9IDA7XG5cdEZTX3Byb3RvLldSSVRJTkcgPSAxO1xuXHRGU19wcm90by5ET05FID0gMjtcblxuXHRGU19wcm90by5lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG5cdEZTX3Byb3RvLm9ucHJvZ3Jlc3MgPVxuXHRGU19wcm90by5vbndyaXRlID1cblx0RlNfcHJvdG8ub25hYm9ydCA9XG5cdEZTX3Byb3RvLm9uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlZW5kID1cblx0XHRudWxsO1xuXG5cdHJldHVybiBzYXZlQXM7XG59KFxuXHQgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG5cdHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG5cdHx8IHRoaXMuY29udGVudFxuKSk7XG4vLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnNhdmVBcyA9IHNhdmVBcztcbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVmaW5lICE9PSBudWxsKSAmJiAoZGVmaW5lLmFtZCAhPT0gbnVsbCkpIHtcbiAgZGVmaW5lKFwiRmlsZVNhdmVyLmpzXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzYXZlQXM7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh0eXBlb2Yga2V5ID09ICdudW1iZXInICYmIHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Z1bGxdIFNwZWNpZnkgYSBjbG9uZSBpbmNsdWRpbmcgc3ltYm9scy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICBpZiAoaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmICghaXNBcnIpIHtcbiAgICB2YXIgcHJvcHMgPSBpc0Z1bGwgPyBnZXRBbGxLZXlzKHZhbHVlKSA6IGtleXModmFsdWUpO1xuICB9XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90bykge1xuICByZXR1cm4gaXNPYmplY3QocHJvdG8pID8gb2JqZWN0Q3JlYXRlKHByb3RvKSA6IHt9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSkpIHtcbiAgICB2YXIgcHJvcHMgPSBiYXNlS2V5c0luKHNvdXJjZSk7XG4gIH1cbiAgYXJyYXlFYWNoKHByb3BzIHx8IHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3JjVmFsdWU7XG4gICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV0sXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBidWZmZXIuY29uc3RydWN0b3IoYnVmZmVyLmxlbmd0aCk7XG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSwgdHJ1ZSkgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIHRydWUpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2wgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9IG5hdGl2ZUdldFN5bWJvbHMgPyBvdmVyQXJnKG5hdGl2ZUdldFN5bWJvbHMsIE9iamVjdCkgOiBzdHViQXJyYXk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIG1lcmdlRGVmYXVsdHMsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c1xuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gKi9cbnZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gIGFyZ3MucHVzaCh1bmRlZmluZWQsIG1lcmdlRGVmYXVsdHMpO1xuICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNldmVuIGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHNEZWVwO1xuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBjb252ZXJ0ZXIgPSByZXF1aXJlKCcuL3NiZ25tbENvbnZlcnRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiBjb252ZXJ0ZXIuY29udmVydCh0ZXh0KTtcbn07XG4iLCIvKiBqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3Q6IGZhbHNlICovXG5cbnZhciBzYmdubWxDb252ZXJ0ZXIgPSB7XG4gIGxvYWRYTUxGcm9tU3RyaW5nOiBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciBkb2M7XG4gICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICBkb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgZG9jLmFzeW5jID0gJ2ZhbHNlJztcbiAgICAgIGRvYy5sb2FkWE1MKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC94bWwnKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VFcnJvciA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKTtcbiAgICBpZiAocGFyc2VFcnJvci5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHRoZSBmb2xsb3dpbmcgdGV4dCB0byB4bWw6ICcgKyBKU09OLnN0cmluZ2lmeSh0ZXh0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfSxcbiAgc2Jnbm1sVGFnczoge1xuICAgICd1bnNwZWNpZmllZCBlbnRpdHknOiB0cnVlLFxuICAgICdzaW1wbGUgY2hlbWljYWwnOiB0cnVlLFxuICAgICdtYWNyb21vbGVjdWxlJzogdHJ1ZSxcbiAgICAnbnVjbGVpYyBhY2lkIGZlYXR1cmUnOiB0cnVlLFxuICAgICdwZXJ0dXJiaW5nIGFnZW50JzogdHJ1ZSxcbiAgICAnc291cmNlIGFuZCBzaW5rJzogdHJ1ZSxcbiAgICAnY29tcGxleCc6IHRydWUsXG4gICAgJ3Byb2Nlc3MnOiB0cnVlLFxuICAgICdvbWl0dGVkIHByb2Nlc3MnOiB0cnVlLFxuICAgICd1bmNlcnRhaW4gcHJvY2Vzcyc6IHRydWUsXG4gICAgJ2Fzc29jaWF0aW9uJzogdHJ1ZSxcbiAgICAnZGlzc29jaWF0aW9uJzogdHJ1ZSxcbiAgICAncGhlbm90eXBlJzogdHJ1ZSxcbiAgICAndGFnJzogdHJ1ZSxcbiAgICAnY29uc3VtcHRpb24nOiB0cnVlLFxuICAgICdwcm9kdWN0aW9uJzogdHJ1ZSxcbiAgICAnbW9kdWxhdGlvbic6IHRydWUsXG4gICAgJ3N0aW11bGF0aW9uJzogdHJ1ZSxcbiAgICAnY2F0YWx5c2lzJzogdHJ1ZSxcbiAgICAnaW5oaWJpdGlvbic6IHRydWUsXG4gICAgJ25lY2Vzc2FyeSBzdGltdWxhdGlvbic6IHRydWUsXG4gICAgJ2xvZ2ljIGFyYyc6IHRydWUsXG4gICAgJ2VxdWl2YWxlbmNlIGFyYyc6IHRydWUsXG4gICAgJ2FuZCBvcGVyYXRvcic6IHRydWUsXG4gICAgJ29yIG9wZXJhdG9yJzogdHJ1ZSxcbiAgICAnbm90IG9wZXJhdG9yJzogdHJ1ZSxcbiAgICAnYW5kJzogdHJ1ZSxcbiAgICAnb3InOiB0cnVlLFxuICAgICdub3QnOiB0cnVlLFxuICAgICdudWNsZWljIGFjaWQgZmVhdHVyZSBtdWx0aW1lcic6IHRydWUsXG4gICAgJ21hY3JvbW9sZWN1bGUgbXVsdGltZXInOiB0cnVlLFxuICAgICdzaW1wbGUgY2hlbWljYWwgbXVsdGltZXInOiB0cnVlLFxuICAgICdjb21wbGV4IG11bHRpbWVyJzogdHJ1ZSxcbiAgICAnY29tcGFydG1lbnQnOiB0cnVlXG4gIH0sXG4gIGluc2VydGVkTm9kZXM6IHt9LFxuICBnZXRBbGxDb21wYXJ0bWVudHM6IGZ1bmN0aW9uICh4bWxPYmplY3QpIHtcbiAgICB2YXIgY29tcGFydG1lbnRzID0gW107XG5cbiAgICB2YXIgY29tcGFydG1lbnRFbHMgPSB4bWxPYmplY3QucXVlcnlTZWxlY3RvckFsbChcImdseXBoW2NsYXNzPSdjb21wYXJ0bWVudCddXCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wYXJ0bWVudEVscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBhcnRtZW50ID0gY29tcGFydG1lbnRFbHNbaV07XG4gICAgICB2YXIgYmJveCA9IHRoaXMuZmluZENoaWxkTm9kZShjb21wYXJ0bWVudCwgJ2Jib3gnKTtcbiAgICAgIGNvbXBhcnRtZW50cy5wdXNoKHtcbiAgICAgICAgJ3gnOiBwYXJzZUZsb2F0KGJib3guZ2V0QXR0cmlidXRlKCd4JykpLFxuICAgICAgICAneSc6IHBhcnNlRmxvYXQoYmJveC5nZXRBdHRyaWJ1dGUoJ3knKSksXG4gICAgICAgICd3JzogcGFyc2VGbG9hdChiYm94LmdldEF0dHJpYnV0ZSgndycpKSxcbiAgICAgICAgJ2gnOiBwYXJzZUZsb2F0KGJib3guZ2V0QXR0cmlidXRlKCdoJykpLFxuICAgICAgICAnaWQnOiBjb21wYXJ0bWVudC5nZXRBdHRyaWJ1dGUoJ2lkJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBhcnRtZW50cy5zb3J0KGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgIGlmIChjMS5oICogYzEudyA8IGMyLmggKiBjMi53KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChjMS5oICogYzEudyA+IGMyLmggKiBjMi53KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29tcGFydG1lbnRzO1xuICB9LFxuICBpc0luQm91bmRpbmdCb3g6IGZ1bmN0aW9uIChiYm94MSwgYmJveDIpIHtcbiAgICBpZiAoYmJveDEueCA+IGJib3gyLnggJiZcbiAgICAgICAgYmJveDEueSA+IGJib3gyLnkgJiZcbiAgICAgICAgYmJveDEueCArIGJib3gxLncgPCBiYm94Mi54ICsgYmJveDIudyAmJlxuICAgICAgICBiYm94MS55ICsgYmJveDEuaCA8IGJib3gyLnkgKyBiYm94Mi5oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBiYm94UHJvcDogZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBiYm94ID0ge307XG4gICAgdmFyIGJib3hFbCA9IGVsZS5xdWVyeVNlbGVjdG9yKCdiYm94Jyk7XG5cbiAgICBiYm94LnggPSBiYm94RWwuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgYmJveC55ID0gYmJveEVsLmdldEF0dHJpYnV0ZSgneScpO1xuICAgIGJib3gudyA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ3cnKTtcbiAgICBiYm94LmggPSBiYm94RWwuZ2V0QXR0cmlidXRlKCdoJyk7XG4gICAgLy8gc2V0IHBvc2l0aW9ucyBhcyBjZW50ZXJcbiAgICBiYm94LnggPSBwYXJzZUZsb2F0KGJib3gueCkgKyBwYXJzZUZsb2F0KGJib3gudykgLyAyO1xuICAgIGJib3gueSA9IHBhcnNlRmxvYXQoYmJveC55KSArIHBhcnNlRmxvYXQoYmJveC5oKSAvIDI7XG5cbiAgICByZXR1cm4gYmJveDtcbiAgfSxcbiAgc3RhdGVBbmRJbmZvQmJveFByb3A6IGZ1bmN0aW9uIChlbGUsIHBhcmVudEJib3gpIHtcbiAgICB2YXIgeFBvcyA9IHBhcnNlRmxvYXQocGFyZW50QmJveC54KTtcbiAgICB2YXIgeVBvcyA9IHBhcnNlRmxvYXQocGFyZW50QmJveC55KTtcblxuICAgIHZhciBiYm94ID0ge307XG4gICAgdmFyIGJib3hFbCA9IGVsZS5xdWVyeVNlbGVjdG9yKCdiYm94Jyk7XG5cbiAgICBiYm94LnggPSBiYm94RWwuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgYmJveC55ID0gYmJveEVsLmdldEF0dHJpYnV0ZSgneScpO1xuICAgIGJib3gudyA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ3cnKTtcbiAgICBiYm94LmggPSBiYm94RWwuZ2V0QXR0cmlidXRlKCdoJyk7XG5cbiAgICAvLyBzZXQgcG9zaXRpb25zIGFzIGNlbnRlclxuICAgIGJib3gueCA9IHBhcnNlRmxvYXQoYmJveC54KSArIHBhcnNlRmxvYXQoYmJveC53KSAvIDIgLSB4UG9zO1xuICAgIGJib3gueSA9IHBhcnNlRmxvYXQoYmJveC55KSArIHBhcnNlRmxvYXQoYmJveC5oKSAvIDIgLSB5UG9zO1xuXG4gICAgYmJveC54ID0gYmJveC54IC8gcGFyc2VGbG9hdChwYXJlbnRCYm94LncpICogMTAwO1xuICAgIGJib3gueSA9IGJib3gueSAvIHBhcnNlRmxvYXQocGFyZW50QmJveC5oKSAqIDEwMDtcblxuICAgIHJldHVybiBiYm94O1xuICB9LFxuICBmaW5kQ2hpbGROb2RlczogZnVuY3Rpb24gKGVsZSwgY2hpbGRUYWdOYW1lKSB7XG4gICAgLy8gZmluZCBjaGlsZCBub2RlcyBhdCBkZXB0aCBsZXZlbCBvZiAxIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gZWxlLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEgJiYgY2hpbGQudGFnTmFtZSA9PT0gY2hpbGRUYWdOYW1lKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGZpbmRDaGlsZE5vZGU6IGZ1bmN0aW9uIChlbGUsIGNoaWxkVGFnTmFtZSkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuZmluZENoaWxkTm9kZXMoZWxlLCBjaGlsZFRhZ05hbWUpO1xuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gbm9kZXNbMF0gOiB1bmRlZmluZWQ7XG4gIH0sXG4gIHN0YXRlQW5kSW5mb1Byb3A6IGZ1bmN0aW9uIChlbGUsIHBhcmVudEJib3gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXRlQW5kSW5mb0FycmF5ID0gW107XG5cbiAgICB2YXIgY2hpbGRHbHlwaHMgPSB0aGlzLmZpbmRDaGlsZE5vZGVzKGVsZSwgJ2dseXBoJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkR2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ2x5cGggPSBjaGlsZEdseXBoc1tpXTtcbiAgICAgIHZhciBpbmZvID0ge307XG5cbiAgICAgIGlmIChnbHlwaC5jbGFzc05hbWUgPT09ICd1bml0IG9mIGluZm9ybWF0aW9uJykge1xuICAgICAgICBpbmZvLmlkID0gZ2x5cGguZ2V0QXR0cmlidXRlKCdpZCcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaW5mby5jbGF6eiA9IGdseXBoLmNsYXNzTmFtZSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBsYWJlbCA9IGdseXBoLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG4gICAgICAgIGluZm8ubGFiZWwgPSB7XG4gICAgICAgICAgJ3RleHQnOiAobGFiZWwgJiYgbGFiZWwuZ2V0QXR0cmlidXRlKCd0ZXh0JykpIHx8IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBpbmZvLmJib3ggPSBzZWxmLnN0YXRlQW5kSW5mb0Jib3hQcm9wKGdseXBoLCBwYXJlbnRCYm94KTtcbiAgICAgICAgc3RhdGVBbmRJbmZvQXJyYXkucHVzaChpbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2x5cGguY2xhc3NOYW1lID09PSAnc3RhdGUgdmFyaWFibGUnKSB7XG4gICAgICAgIGluZm8uaWQgPSBnbHlwaC5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICBpbmZvLmNsYXp6ID0gZ2x5cGguY2xhc3NOYW1lIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2x5cGgucXVlcnlTZWxlY3Rvcignc3RhdGUnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gKHN0YXRlICYmIHN0YXRlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdmFyaWFibGUgPSAoc3RhdGUgJiYgc3RhdGUuZ2V0QXR0cmlidXRlKCd2YXJpYWJsZScpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGluZm8uc3RhdGUgPSB7XG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGVcbiAgICAgICAgfTtcbiAgICAgICAgaW5mby5iYm94ID0gc2VsZi5zdGF0ZUFuZEluZm9CYm94UHJvcChnbHlwaCwgcGFyZW50QmJveCk7XG4gICAgICAgIHN0YXRlQW5kSW5mb0FycmF5LnB1c2goaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICByZXR1cm4gc3RhdGVBbmRJbmZvQXJyYXk7XG4gIH0sXG4gIGFkZFBhcmVudEluZm9Ub05vZGU6IGZ1bmN0aW9uIChlbGUsIG5vZGVPYmosIHBhcmVudCwgY29tcGFydG1lbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb21wYXJ0bWVudFJlZiA9IGVsZS5nZXRBdHRyaWJ1dGUoJ2NvbXBhcnRtZW50UmVmJyk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlT2JqLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFydG1lbnRSZWYpIHtcbiAgICAgIG5vZGVPYmoucGFyZW50ID0gY29tcGFydG1lbnRSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVPYmoucGFyZW50ID0gJyc7XG5cbiAgICAgIC8vIGFkZCBjb21wYXJ0bWVudCBhY2NvcmRpbmcgdG8gZ2VvbWV0cnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcGFydG1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiYm94RWwgPSBzZWxmLmZpbmRDaGlsZE5vZGUoZWxlLCAnYmJveCcpO1xuICAgICAgICB2YXIgYmJveCA9IHtcbiAgICAgICAgICAneCc6IHBhcnNlRmxvYXQoYmJveEVsLmdldEF0dHJpYnV0ZSgneCcpKSxcbiAgICAgICAgICAneSc6IHBhcnNlRmxvYXQoYmJveEVsLmdldEF0dHJpYnV0ZSgneScpKSxcbiAgICAgICAgICAndyc6IHBhcnNlRmxvYXQoYmJveEVsLmdldEF0dHJpYnV0ZSgndycpKSxcbiAgICAgICAgICAnaCc6IHBhcnNlRmxvYXQoYmJveEVsLmdldEF0dHJpYnV0ZSgnaCcpKSxcbiAgICAgICAgICAnaWQnOiBlbGUuZ2V0QXR0cmlidXRlKCdpZCcpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZWxmLmlzSW5Cb3VuZGluZ0JveChiYm94LCBjb21wYXJ0bWVudHNbaV0pKSB7XG4gICAgICAgICAgbm9kZU9iai5wYXJlbnQgPSBjb21wYXJ0bWVudHNbaV0uaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZEN5dG9zY2FwZUpzTm9kZTogZnVuY3Rpb24gKGVsZSwganNvbkFycmF5LCBwYXJlbnQsIGNvbXBhcnRtZW50cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbm9kZU9iaiA9IHt9O1xuXG4gICAgLy8gYWRkIGlkIGluZm9ybWF0aW9uXG4gICAgbm9kZU9iai5pZCA9IGVsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgLy8gYWRkIG5vZGUgYm91bmRpbmcgYm94IGluZm9ybWF0aW9uXG4gICAgbm9kZU9iai5iYm94ID0gc2VsZi5iYm94UHJvcChlbGUpO1xuICAgIC8vIGFkZCBjbGFzcyBpbmZvcm1hdGlvblxuICAgIG5vZGVPYmouY2xhc3MgPSBlbGUuY2xhc3NOYW1lO1xuICAgIC8vIGFkZCBsYWJlbCBpbmZvcm1hdGlvblxuICAgIHZhciBsYWJlbCA9IHNlbGYuZmluZENoaWxkTm9kZShlbGUsICdsYWJlbCcpO1xuICAgIG5vZGVPYmoubGFiZWwgPSAobGFiZWwgJiYgbGFiZWwuZ2V0QXR0cmlidXRlKCd0ZXh0JykpIHx8IHVuZGVmaW5lZDtcbiAgICAvLyBhZGQgc3RhdGUgYW5kIGluZm8gYm94IGluZm9ybWF0aW9uXG4gICAgbm9kZU9iai5zdGF0ZXNhbmRpbmZvcyA9IHNlbGYuc3RhdGVBbmRJbmZvUHJvcChlbGUsIG5vZGVPYmouYmJveCk7XG4gICAgLy8gYWRkaW5nIHBhcmVudCBpbmZvcm1hdGlvblxuICAgIHNlbGYuYWRkUGFyZW50SW5mb1RvTm9kZShlbGUsIG5vZGVPYmosIHBhcmVudCwgY29tcGFydG1lbnRzKTtcblxuICAgIC8vIGFkZCBjbG9uZSBpbmZvcm1hdGlvblxuICAgIHZhciBjbG9uZU1hcmtlcnMgPSBzZWxmLmZpbmRDaGlsZE5vZGVzKGVsZSwgJ2Nsb25lJyk7XG4gICAgaWYgKGNsb25lTWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlT2JqLmNsb25lbWFya2VyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZU9iai5jbG9uZW1hcmtlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBhZGQgcG9ydCBpbmZvcm1hdGlvblxuICAgIHZhciBwb3J0cyA9IFtdO1xuICAgIHZhciBwb3J0RWxlbWVudHMgPSBlbGUucXVlcnlTZWxlY3RvckFsbCgncG9ydCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3J0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3J0RWwgPSBwb3J0RWxlbWVudHNbaV07XG4gICAgICB2YXIgaWQgPSBwb3J0RWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgdmFyIHJlbGF0aXZlWFBvcyA9IHBhcnNlRmxvYXQocG9ydEVsLmdldEF0dHJpYnV0ZSgneCcpKSAtIG5vZGVPYmouYmJveC54O1xuICAgICAgdmFyIHJlbGF0aXZlWVBvcyA9IHBhcnNlRmxvYXQocG9ydEVsLmdldEF0dHJpYnV0ZSgneScpKSAtIG5vZGVPYmouYmJveC55O1xuXG4gICAgICByZWxhdGl2ZVhQb3MgPSByZWxhdGl2ZVhQb3MgLyBwYXJzZUZsb2F0KG5vZGVPYmouYmJveC53KSAqIDEwMDtcbiAgICAgIHJlbGF0aXZlWVBvcyA9IHJlbGF0aXZlWVBvcyAvIHBhcnNlRmxvYXQobm9kZU9iai5iYm94LmgpICogMTAwO1xuXG4gICAgICBwb3J0cy5wdXNoKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB4OiByZWxhdGl2ZVhQb3MsXG4gICAgICAgIHk6IHJlbGF0aXZlWVBvc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZU9iai5wb3J0cyA9IHBvcnRzO1xuXG4gICAgdmFyIGN5dG9zY2FwZUpzTm9kZSA9IHtkYXRhOiBub2RlT2JqfTtcbiAgICBqc29uQXJyYXkucHVzaChjeXRvc2NhcGVKc05vZGUpO1xuICB9LFxuICB0cmF2ZXJzZU5vZGVzOiBmdW5jdGlvbiAoZWxlLCBqc29uQXJyYXksIHBhcmVudCwgY29tcGFydG1lbnRzKSB7XG4gICAgdmFyIGVsSWQgPSBlbGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmICghdGhpcy5zYmdubWxUYWdzW2VsZS5jbGFzc05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5zZXJ0ZWROb2Rlc1tlbElkXSA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGFkZCBjb21wbGV4IG5vZGVzIGhlcmVcblxuICAgIHZhciBlbGVDbGFzcyA9IGVsZS5jbGFzc05hbWU7XG5cbiAgICBpZiAoZWxlQ2xhc3MgPT09ICdjb21wbGV4JyB8fCBlbGVDbGFzcyA9PT0gJ3N1Ym1hcCcpIHtcbiAgICAgIHNlbGYuYWRkQ3l0b3NjYXBlSnNOb2RlKGVsZSwganNvbkFycmF5LCBwYXJlbnQsIGNvbXBhcnRtZW50cyk7XG5cbiAgICAgIHZhciBjaGlsZEdseXBocyA9IHNlbGYuZmluZENoaWxkTm9kZXMoZWxlLCAnZ2x5cGgnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRHbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoID0gY2hpbGRHbHlwaHNbaV07XG4gICAgICAgIHZhciBnbHlwaENsYXNzID0gZ2x5cGguY2xhc3NOYW1lO1xuICAgICAgICBpZiAoZ2x5cGhDbGFzcyAhPT0gJ3N0YXRlIHZhcmlhYmxlJyAmJiBnbHlwaENsYXNzICE9PSAndW5pdCBvZiBpbmZvcm1hdGlvbicpIHtcbiAgICAgICAgICBzZWxmLnRyYXZlcnNlTm9kZXMoZ2x5cGgsIGpzb25BcnJheSwgZWxJZCwgY29tcGFydG1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFkZEN5dG9zY2FwZUpzTm9kZShlbGUsIGpzb25BcnJheSwgcGFyZW50LCBjb21wYXJ0bWVudHMpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UG9ydHM6IGZ1bmN0aW9uICh4bWxPYmplY3QpIHtcbiAgICByZXR1cm4gKCB4bWxPYmplY3QuX2NhY2hlZFBvcnRzID0geG1sT2JqZWN0Ll9jYWNoZWRQb3J0cyB8fCB4bWxPYmplY3QucXVlcnlTZWxlY3RvckFsbCgncG9ydCcpKTtcbiAgfSxcbiAgZ2V0R2x5cGhzOiBmdW5jdGlvbiAoeG1sT2JqZWN0KSB7XG4gICAgdmFyIGdseXBocyA9IHhtbE9iamVjdC5fY2FjaGVkR2x5cGhzO1xuXG4gICAgaWYgKCFnbHlwaHMpIHtcbiAgICAgIGdseXBocyA9IHhtbE9iamVjdC5fY2FjaGVkR2x5cGhzID0geG1sT2JqZWN0Ll9jYWNoZWRHbHlwaHMgfHwgeG1sT2JqZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2dseXBoJyk7XG5cbiAgICAgIHZhciBpZDJnbHlwaCA9IHhtbE9iamVjdC5faWQyZ2x5cGggPSB7fTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICB2YXIgZyA9IGdseXBoc1tpXTtcbiAgICAgICAgdmFyIGlkID0gZy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgaWQyZ2x5cGhbIGlkIF0gPSBnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG4gIH0sXG4gIGdldEdseXBoQnlJZDogZnVuY3Rpb24gKHhtbE9iamVjdCwgaWQpIHtcbiAgICB0aGlzLmdldEdseXBocyh4bWxPYmplY3QpOyAvLyBtYWtlIHN1cmUgY2FjaGUgaXMgYnVpbHRcblxuICAgIHJldHVybiB4bWxPYmplY3QuX2lkMmdseXBoW2lkXTtcbiAgfSxcbiAgZ2V0QXJjU291cmNlQW5kVGFyZ2V0OiBmdW5jdGlvbiAoYXJjLCB4bWxPYmplY3QpIHtcbiAgICAvLyBzb3VyY2UgYW5kIHRhcmdldCBjYW4gYmUgaW5zaWRlIG9mIGEgcG9ydFxuICAgIHZhciBzb3VyY2UgPSBhcmMuZ2V0QXR0cmlidXRlKCdzb3VyY2UnKTtcbiAgICB2YXIgdGFyZ2V0ID0gYXJjLmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgdmFyIHNvdXJjZU5vZGVJZDtcbiAgICB2YXIgdGFyZ2V0Tm9kZUlkO1xuXG4gICAgdmFyIHNvdXJjZUV4aXN0cyA9IHRoaXMuZ2V0R2x5cGhCeUlkKHhtbE9iamVjdCwgc291cmNlKTtcbiAgICB2YXIgdGFyZ2V0RXhpc3RzID0gdGhpcy5nZXRHbHlwaEJ5SWQoeG1sT2JqZWN0LCB0YXJnZXQpO1xuXG4gICAgaWYgKHNvdXJjZUV4aXN0cykge1xuICAgICAgc291cmNlTm9kZUlkID0gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXRFeGlzdHMpIHtcbiAgICAgIHRhcmdldE5vZGVJZCA9IHRhcmdldDtcbiAgICB9XG5cblxuICAgIHZhciBpO1xuICAgIHZhciBwb3J0RWxzID0gdGhpcy5nZXRQb3J0cyh4bWxPYmplY3QpO1xuICAgIHZhciBwb3J0O1xuICAgIGlmIChzb3VyY2VOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvcnRFbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHBvcnQgPSBwb3J0RWxzW2ldO1xuICAgICAgICBpZiAocG9ydC5nZXRBdHRyaWJ1dGUoJ2lkJykgPT09IHNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZU5vZGVJZCA9IHBvcnQucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Tm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3J0RWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvcnQgPSBwb3J0RWxzW2ldO1xuICAgICAgICBpZiAocG9ydC5nZXRBdHRyaWJ1dGUoJ2lkJykgPT09IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldE5vZGVJZCA9IHBvcnQucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geydzb3VyY2UnOiBzb3VyY2VOb2RlSWQsICd0YXJnZXQnOiB0YXJnZXROb2RlSWR9O1xuICB9LFxuXG4gIGdldEFyY0JlbmRQb2ludFBvc2l0aW9uczogZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBiZW5kUG9pbnRQb3NpdGlvbnMgPSBbXTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZmluZENoaWxkTm9kZXMoZWxlLCAnbmV4dCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvc1ggPSBjaGlsZHJlbltpXS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgIHZhciBwb3NZID0gY2hpbGRyZW5baV0uZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICAgIGJlbmRQb2ludFBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgeDogcG9zWCxcbiAgICAgICAgeTogcG9zWVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlbmRQb2ludFBvc2l0aW9ucztcbiAgfSxcbiAgYWRkQ3l0b3NjYXBlSnNFZGdlOiBmdW5jdGlvbiAoZWxlLCBqc29uQXJyYXksIHhtbE9iamVjdCkge1xuICAgIGlmICghdGhpcy5zYmdubWxUYWdzW2VsZS5jbGFzc05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzb3VyY2VBbmRUYXJnZXQgPSBzZWxmLmdldEFyY1NvdXJjZUFuZFRhcmdldChlbGUsIHhtbE9iamVjdCk7XG5cbiAgICBpZiAoIXRoaXMuaW5zZXJ0ZWROb2Rlc1tzb3VyY2VBbmRUYXJnZXQuc291cmNlXSB8fCAhdGhpcy5pbnNlcnRlZE5vZGVzW3NvdXJjZUFuZFRhcmdldC50YXJnZXRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VPYmogPSB7fTtcbiAgICB2YXIgYmVuZFBvaW50UG9zaXRpb25zID0gc2VsZi5nZXRBcmNCZW5kUG9pbnRQb3NpdGlvbnMoZWxlKTtcblxuICAgIGVkZ2VPYmouaWQgPSBlbGUuZ2V0QXR0cmlidXRlKCdpZCcpIHx8IHVuZGVmaW5lZDtcbiAgICBlZGdlT2JqLmNsYXNzID0gZWxlLmNsYXNzTmFtZTtcbiAgICBlZGdlT2JqLmJlbmRQb2ludFBvc2l0aW9ucyA9IGJlbmRQb2ludFBvc2l0aW9ucztcblxuICAgIHZhciBnbHlwaENoaWxkcmVuID0gc2VsZi5maW5kQ2hpbGROb2RlcyhlbGUsICdnbHlwaCcpO1xuICAgIHZhciBnbHlwaERlc2NlbmRlbnRzID0gZWxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2dseXBoJyk7XG4gICAgaWYgKGdseXBoRGVzY2VuZGVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIGVkZ2VPYmouY2FyZGluYWxpdHkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGdseXBoQ2hpbGRyZW5baV0uY2xhc3NOYW1lID09PSAnY2FyZGluYWxpdHknKSB7XG4gICAgICAgICAgdmFyIGxhYmVsID0gZ2x5cGhDaGlsZHJlbltpXS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpO1xuICAgICAgICAgIGVkZ2VPYmouY2FyZGluYWxpdHkgPSBsYWJlbC5nZXRBdHRyaWJ1dGUoJ3RleHQnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlZGdlT2JqLnNvdXJjZSA9IHNvdXJjZUFuZFRhcmdldC5zb3VyY2U7XG4gICAgZWRnZU9iai50YXJnZXQgPSBzb3VyY2VBbmRUYXJnZXQudGFyZ2V0O1xuXG4gICAgZWRnZU9iai5wb3J0c291cmNlID0gZWxlLmdldEF0dHJpYnV0ZSgnc291cmNlJyk7XG4gICAgZWRnZU9iai5wb3J0dGFyZ2V0ID0gZWxlLmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG5cbiAgICB2YXIgY3l0b3NjYXBlSnNFZGdlID0ge2RhdGE6IGVkZ2VPYmp9O1xuICAgIGpzb25BcnJheS5wdXNoKGN5dG9zY2FwZUpzRWRnZSk7XG4gIH0sXG4gIGNvbnZlcnQ6IGZ1bmN0aW9uIChzYmdubWxUZXh0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeXRvc2NhcGVKc05vZGVzID0gW107XG4gICAgdmFyIGN5dG9zY2FwZUpzRWRnZXMgPSBbXTtcblxuICAgIHZhciB4bWxPYmplY3QgPSB0aGlzLmxvYWRYTUxGcm9tU3RyaW5nKHNiZ25tbFRleHQpO1xuXG4gICAgdmFyIGNvbXBhcnRtZW50cyA9IHNlbGYuZ2V0QWxsQ29tcGFydG1lbnRzKHhtbE9iamVjdCk7XG5cbiAgICB2YXIgZ2x5cGhzID0gc2VsZi5maW5kQ2hpbGROb2Rlcyh4bWxPYmplY3QucXVlcnlTZWxlY3RvcignbWFwJyksICdnbHlwaCcpO1xuICAgIHZhciBhcmNzID0gc2VsZi5maW5kQ2hpbGROb2Rlcyh4bWxPYmplY3QucXVlcnlTZWxlY3RvcignbWFwJyksICdhcmMnKTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIHNlbGYudHJhdmVyc2VOb2RlcyhnbHlwaCwgY3l0b3NjYXBlSnNOb2RlcywgJycsIGNvbXBhcnRtZW50cyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhcmMgPSBhcmNzW2ldO1xuICAgICAgc2VsZi5hZGRDeXRvc2NhcGVKc0VkZ2UoYXJjLCBjeXRvc2NhcGVKc0VkZ2VzLCB4bWxPYmplY3QpO1xuICAgIH1cblxuICAgIHZhciBjeXRvc2NhcGVKc0dyYXBoID0ge307XG4gICAgY3l0b3NjYXBlSnNHcmFwaC5ub2RlcyA9IGN5dG9zY2FwZUpzTm9kZXM7XG4gICAgY3l0b3NjYXBlSnNHcmFwaC5lZGdlcyA9IGN5dG9zY2FwZUpzRWRnZXM7XG5cbiAgICB0aGlzLmluc2VydGVkTm9kZXMgPSB7fTtcblxuICAgIHJldHVybiBjeXRvc2NhcGVKc0dyYXBoO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNiZ25tbENvbnZlcnRlcjtcbiIsImxldCBDeXRvc2NhcGUgPSByZXF1aXJlKCdjeXRvc2NhcGUnKTtcbmxldCBkZWZhdWx0c0RlZXAgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHNkZWVwJyk7XG5cbmxldCBzYmduU3R5bGVTaGVldCA9IHJlcXVpcmUoJy4vc2JnblN0eWxlL2dyYXBoJyk7XG5cbmxldCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3R5bGU6IHNiZ25TdHlsZVNoZWV0KEN5dG9zY2FwZSksXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gIHNob3dPdmVybGF5OiBmYWxzZSxcbiAgbWluWm9vbTogZmFsc2UsXG4gIG1heFpvb206IGZhbHNlLFxuICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgd2hlZWxTZW5zaXRpdml0eTogMC4xXG59O1xuXG5jbGFzcyBTQkdOUmVuZGVyZXIgZXh0ZW5kcyBDeXRvc2NhcGUge1xuICBjb25zdHJ1Y3Rvciggb3B0aW9ucyApe1xuICAgIHN1cGVyKCBkZWZhdWx0c0RlZXAoIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyApICk7XG4gIH1cbi8vICAgVE9ETzogSW5pdGlhbCBzYmduLXJlbmRlcmVyIGFwaVxuLy8gICBzYmduIChrZGZrZCkgeyAvLyB0aGUgZnVuY3Rpb24gdGhhdCBjYW4gcG9zc2libHkgdHVybmVkIGludG8gYW4gZXh0ZW5zaW9uXG4vLyAgIC4uLjsgLy8gc3R5bGUgc2hlZXQgY2FuIGJlIHNldCBpbiBoZXJlXG4vLyAgIC4uLjsgLy8gYWNjZXB0IHNibmdtbCBmaWxlIG9yIHN0cmluZywgcHJvbWlzZSB0byByZXNvbHZlIHRvIHN0cmluZyAoZmV0Y2ggc3VwcG9ydCksIHBvc3NpYmx5IGFsd2F5cyB0cmVhdCBpdCBhcyBhIHByb21pc2Vcbi8vICAgLi4uOyAvLyBleHBvcnQgIHRvIHNiZ25tbCBmaWxlIG9yIHBpY3R1cmVcbi8vICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU0JHTlJlbmRlcmVyO1xuIiwidmFyIGVsZW1lbnRTdHlsZSA9IHt9O1xuXG5lbGVtZW50U3R5bGUuc2JnblNoYXBlID0gKG5vZGUpID0+IHtcbiAgbGV0IHNiZ25DbGFzcyA9IG5vZGUuZGF0YSgnY2xhc3MnKTtcbiAgaWYgKHNiZ25DbGFzcy5lbmRzV2l0aCgnIG11bHRpbWVyJykpIHtcbiAgICBzYmduQ2xhc3MgPSBzYmduQ2xhc3MucmVwbGFjZSgnIG11bHRpbWVyJywgJycpO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAncGhlbm90eXBlJykge1xuICAgIHJldHVybiAnaGV4YWdvbic7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdwcm9jZXNzJykge1xuICAgIHJldHVybiAnc3F1YXJlJztcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT0gJ3BlcnR1cmJpbmcgYWdlbnQnIHx8IHNiZ25DbGFzcyA9PSAndGFnJ1xuICAgIHx8IHNiZ25DbGFzcyA9PSAnc291cmNlIGFuZCBzaW5rJyB8fCBzYmduQ2xhc3MgPT0gJ2NvbXBhcnRtZW50JyB8fCBzYmduQ2xhc3MgPT0gJ2NvbXBsZXgnKSB7XG4gICAgcmV0dXJuICdwb2x5Z29uJztcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT0gJ2Rpc3NvY2lhdGlvbicpIHtcbiAgICByZXR1cm4gJ2VsbGlwc2UnO1xuICB9XG5cbiAgaWYgKCBzYmduQ2xhc3MgPT0gJ251Y2xlaWMgYWNpZCBmZWF0dXJlJ1xuICAgICAgfHwgc2JnbkNsYXNzID09ICdtYWNyb21vbGVjdWxlJyB8fCBzYmduQ2xhc3MgPT0gJ3NpbXBsZSBjaGVtaWNhbCdcbiAgICAgIHx8IHNiZ25DbGFzcyA9PSAnb21pdHRlZCBwcm9jZXNzJ1xuICAgICAgfHwgc2JnbkNsYXNzID09ICd1bmNlcnRhaW4gcHJvY2VzcycgfHwgc2JnbkNsYXNzID09ICdhc3NvY2lhdGlvbidcbiAgICApIHtcbiAgICByZXR1cm4gJ3JvdW5kcmVjdGFuZ2xlJztcbiAgfVxuICByZXR1cm4gJ2VsbGlwc2UnO1xufTtcblxuZWxlbWVudFN0eWxlLnNiZ25BcnJvd1NoYXBlID0gKGVkZ2UpID0+IHtcbiAgbGV0IHNiZ25DbGFzcyA9IGVkZ2UuZGF0YSgnY2xhc3MnKTtcbiAgaWYgKHNiZ25DbGFzcyA9PSAnbmVjZXNzYXJ5IHN0aW11bGF0aW9uJykge1xuICAgIHJldHVybiAndHJpYW5nbGUtY3Jvc3MnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2luaGliaXRpb24nKSB7XG4gICAgcmV0dXJuICd0ZWUnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2NhdGFseXNpcycpIHtcbiAgICByZXR1cm4gJ2NpcmNsZSc7XG4gIH1cbiAgaWYgKHNiZ25DbGFzcyA9PSAnc3RpbXVsYXRpb24nIHx8IHNiZ25DbGFzcyA9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gJ3RyaWFuZ2xlJztcbiAgfVxuICBpZiAoc2JnbkNsYXNzID09ICdtb2R1bGF0aW9uJykge1xuICAgIHJldHVybiAnZGlhbW9uZCc7XG4gIH1cbiAgcmV0dXJuICdub25lJztcbn07XG5cbmVsZW1lbnRTdHlsZS5zYmduQ29udGVudCA9IChub2RlKSA9PiB7XG4gIGxldCBzYmduQ2xhc3MgPSBub2RlLmRhdGEoJ2NsYXNzJyk7XG4gIGxldCBjb250ZW50ID0gJyc7XG5cbiAgaWYgKHNiZ25DbGFzcy5lbmRzV2l0aCgnIG11bHRpbWVyJykpIHtcbiAgICBzYmduQ2xhc3MgPSBzYmduQ2xhc3MucmVwbGFjZSgnIG11bHRpbWVyJywgJycpO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAnbWFjcm9tb2xlY3VsZScgfHwgc2JnbkNsYXNzID09ICdzaW1wbGUgY2hlbWljYWwnXG4gICAgICB8fCBzYmduQ2xhc3MgPT0gJ3BoZW5vdHlwZSdcbiAgICAgIHx8IHNiZ25DbGFzcyA9PSAndW5zcGVjaWZpZWQgZW50aXR5JyB8fCBzYmduQ2xhc3MgPT0gJ251Y2xlaWMgYWNpZCBmZWF0dXJlJ1xuICAgICAgfHwgc2JnbkNsYXNzID09ICdwZXJ0dXJiaW5nIGFnZW50JyB8fCBzYmduQ2xhc3MgPT0gJ3RhZycpIHtcbiAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdsYWJlbCcpID8gbm9kZS5kYXRhKCdsYWJlbCcpIDogJyc7XG4gIH1cbiAgZWxzZSBpZihzYmduQ2xhc3MgPT0gJ2NvbXBhcnRtZW50Jyl7XG4gICAgY29udGVudCA9IG5vZGUuZGF0YSgnbGFiZWwnKSA/IG5vZGUuZGF0YSgnbGFiZWwnKSA6ICcnO1xuICB9XG4gIGVsc2UgaWYoc2JnbkNsYXNzID09ICdjb21wbGV4Jyl7XG4gICAgaWYobm9kZS5jaGlsZHJlbigpLmxlbmd0aCA9PSAwKXtcbiAgICAgIGlmKG5vZGUuZGF0YSgnbGFiZWwnKSl7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmRhdGEoJ2xhYmVsJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKG5vZGUuZGF0YSgnaW5mb0xhYmVsJykpe1xuICAgICAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdpbmZvTGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdhbmQnKSB7XG4gICAgY29udGVudCA9ICdBTkQnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb3InKSB7XG4gICAgY29udGVudCA9ICdPUic7XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdub3QnKSB7XG4gICAgY29udGVudCA9ICdOT1QnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb21pdHRlZCBwcm9jZXNzJykge1xuICAgIGNvbnRlbnQgPSAnXFxcXFxcXFwnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAndW5jZXJ0YWluIHByb2Nlc3MnKSB7XG4gICAgY29udGVudCA9ICc/JztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufTtcblxuY29uc3QgZHluYW1pY0xhYmVsVGV4dFNpemUgPSAobm9kZUhlaWdodCwgc2l6ZUNvZWZmaWNpZW50ID0gMSkgPT4ge1xuICByZXR1cm4gKG5vZGVIZWlnaHQgLyAyLjQ1KSAqIHNpemVDb2VmZmljaWVudDtcbn07XG5cbmVsZW1lbnRTdHlsZS5sYWJlbFRleHRTaXplID0gKG5vZGUpID0+IHtcbiAgY29uc3Qgc2JnbkNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICBjb25zdCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgLy8gRGlydHkgbGVnYWN5IGhhY2suICBUaGVzZSB0eXBlcyBvZiBub2RlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGhhdmUgbGFiZWxzXG4gIC8vIGJ1dCBhcHBhcmVudGx5IHRoZXkgbmVlZCB0byBoYXZlIGEgdGV4dCBzaXplXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhc3NvY2lhdGlvbicgfHwgc2JnbkNsYXNzID09PSAnZGlzc29jaWF0aW9uJykge1xuICAgIHJldHVybiAyMDtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhbmQnIHx8IHNiZ25DbGFzcyA9PT0gJ29yJyB8fCBzYmduQ2xhc3MgPT09ICdub3QnKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNMYWJlbFRleHRTaXplKG5oLCAxKTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MuZW5kc1dpdGgoJ3Byb2Nlc3MnKSkge1xuICAgIHJldHVybiBkeW5hbWljTGFiZWxUZXh0U2l6ZShuaCwgMS41KTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdjb21wbGV4JyB8fCBzYmduQ2xhc3MgPT09ICdjb21wYXJ0bWVudCcpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cblxuICByZXR1cm4gZHluYW1pY0xhYmVsVGV4dFNpemUobmgpO1xufTtcblxuZWxlbWVudFN0eWxlLmNhcmRpbmFsaXR5RGlzdGFuY2UgPSAoZWRnZSkgPT4ge1xuICBjb25zdCBzcmNQb3MgPSBlZGdlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gIGNvbnN0IHRndFBvcyA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdygoc3JjUG9zLnggLSB0Z3RQb3MueCksIDIpICsgTWF0aC5wb3coKHNyY1Bvcy55IC0gdGd0UG9zLnkpLCAyKSk7XG4gIHJldHVybiBkaXN0YW5jZSAqIDAuMTU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRTdHlsZTtcbiIsImNvbnN0IGJhc2VTaGFwZXMgPSB7XG4gIHN0eWxlTWFwMlN0ciAoc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYCR7Wy4uLnN0eWxlTWFwXS5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn07YCkuam9pbignICcpfWA7XG4gIH0sXG5cbiAgYmFzZVJlY3RhbmdsZSh4LCB5LCB3LCBoLCByMSwgcjIsIHIzLCByNCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgIDxwYXRoIHN0eWxlPScke3RoaXMuc3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0nIGQ9J1xuICAgICAgTSAke3ggKyByMX0gJHt5fVxuICAgICAgTCAke3ggKyB3IC0gcjJ9ICR7eX0gUSAke3ggKyB3fSAke3l9ICR7eCArIHd9ICR7eSArIHIyfVxuICAgICAgTCAke3ggKyB3IH0gJHt5ICsgaCAtIHIzfSBRICR7eCArIHd9ICR7eSArIGh9ICR7eCArIHcgLSByM30gJHt5ICsgaH1cbiAgICAgIEwgJHt4ICsgcjR9ICR7eSArIGh9IFEgJHt4fSAke3kgKyBofSAke3h9ICR7eSArIGggLSByNH1cbiAgICAgIEwgJHt4fSAke3kgKyByMX0gUSAke3h9ICR7eX0gJHt4ICsgcjF9ICR7eX1cbiAgICAgIFonXG4gICAgLz5cbiAgICBgO1xuICB9LFxuXG4gIGJhcnJlbCh3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG5cbiAgICA8ZyBzdHlsZT1cIiR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfVwiPlxuICAgICAgPHBhdGggZD1cIk0gJHswKndpZHRofSAkey4wMypoZWlnaHR9IEwgJHswKndpZHRofSAkey45NypoZWlnaHR9IFEgJHswLjA2KndpZHRofSAke2hlaWdodH0gJHswLjI1KndpZHRofSAke2hlaWdodH1cIi8+XG5cbiAgICAgIDxwYXRoIGQ9XCJNICR7MC4yNSp3aWR0aH0gJHtoZWlnaHR9IEwgJHswLjc1KndpZHRofSAke2hlaWdodH0gUSAkezAuOTUqd2lkdGh9ICR7aGVpZ2h0fSAke3dpZHRofSAkezAuOTUqaGVpZ2h0fVwiLz5cblxuICAgICAgPHBhdGggZD1cIk0gJHt3aWR0aH0gJHsuOTUqaGVpZ2h0fSBMICR7d2lkdGh9ICR7MC4wNSpoZWlnaHR9IFEgJHt3aWR0aH0gJHswKmhlaWdodH0gJHswLjc1KndpZHRofSAkezAqaGVpZ2h0fVwiLz5cblxuICAgICAgPHBhdGggZD1cIk0gJHswLjc1KndpZHRofSAkezAqaGVpZ2h0fSBMICR7MC4yNSp3aWR0aH0gJHswKmhlaWdodH0gUSAkezAuMDYqd2lkdGh9ICR7MCpoZWlnaHR9ICR7MCp3aWR0aH0gJHswLjAzKmhlaWdodH1cIi8+XG4gICAgPC9nPlxuXG4gICAgYDtcbiAgfSxcblxuICBjaXJjbGUoY3gsIGN5LCByLCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgPGNpcmNsZSBjeD0nJHtjeH0nIGN5PScke2N5fScgcj0nJHtyfScgc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfScgLz5gO1xuICB9LFxuXG4gIGNvbmNhdmVIZXhhZ29uKHdpZHRoLCBoZWlnaHQsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGBcbiAgICA8cG9seWdvbiBzdHlsZT0nJHt0aGlzLnN0eWxlTWFwMlN0cihzdHlsZU1hcCl9J1xuICAgICAgcG9pbnRzPSckezB9LCAkezB9LCAke3dpZHRofSwgJHswfSwgJHswLjg1KndpZHRofSwgJHswLjUqaGVpZ2h0fSwgJHt3aWR0aH0sICR7aGVpZ2h0fSwgJHswfSwgJHtoZWlnaHR9LCAkezAuMTUqd2lkdGh9LCAkezAuNSpoZWlnaHR9J1xuICAgIC8+YDtcbiAgfSxcblxuICBjdXRSZWN0YW5nbGUod2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgIDxwb2x5Z29uIHN0eWxlPScke3RoaXMuc3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0nXG4gICAgICBwb2ludHM9J1xuICAgICAgJHswKndpZHRofSAkezAuMDUqaGVpZ2h0fSAkezAuMDUqd2lkdGh9ICR7MCpoZWlnaHR9ICR7MC45NSp3aWR0aH0gJHswKmhlaWdodH0gJHt3aWR0aH0gJHswLjA1KmhlaWdodH1cbiAgICAgICR7d2lkdGh9ICR7MC45NSpoZWlnaHR9ICR7MC45NSp3aWR0aH0gJHtoZWlnaHR9ICR7MC4wNSp3aWR0aH0gJHtoZWlnaHR9ICR7MCp3aWR0aH0gJHswLjk1KmhlaWdodH1cbiAgICAgICdcbiAgICAvPlxuICAgIGA7XG4gIH0sXG5cbiAgZWxsaXBzZShjeCwgY3ksIHJ4LCByeSwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGVsbGlwc2UgY3g9JyR7Y3h9JyBjeT0nJHtjeX0nIHJ4PScke3J4fScgcnk9JyR7cnl9JyBzdHlsZT0nJHt0aGlzLnN0eWxlTWFwMlN0cihzdHlsZU1hcCl9JyAvPlxuICAgIGA7XG4gIH0sXG5cbiAgaGV4YWdvbih3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG4gICAgPHBvbHlnb24gc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfSdcbiAgICAgIHBvaW50cz0nJHswfSwgJHswLjUqaGVpZ2h0fSwgJHswLjI1KndpZHRofSwgJHswKmhlaWdodH0sICR7MC43NSp3aWR0aH0sICR7MCpoZWlnaHR9LCAke3dpZHRofSwgJHswLjUqaGVpZ2h0fSwgJHswLjc1KndpZHRofSwgJHtoZWlnaHR9LCAkezAuMjUqd2lkdGh9LCAke2hlaWdodH0nXG4gICAgLz5gO1xuICB9LFxuXG4gIGxpbmUoeDEsIHkxLCB4MiwgeTIsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGA8bGluZSB4MT0nJHt4MX0nIHkxPScke3kxfScgeDI9JyR7eDJ9JyB5Mj0nJHt5Mn0nIHN0eWxlPScke3RoaXMuc3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0nIC8+YDtcbiAgfSxcblxuICByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIDAsIDAsIDAsIHN0eWxlTWFwKTtcbiAgfSxcblxuICByb3VuZEJvdHRvbVJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgLjMqaGVpZ2h0LCAuMypoZWlnaHQsIHN0eWxlTWFwKTtcbiAgfSxcblxuICByb3VuZFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgLjMqaGVpZ2h0LCAuMypoZWlnaHQsIC4zKmhlaWdodCwgLjMqaGVpZ2h0LCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgc3F1YXJlKHgsIHksIGxlbmd0aCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlUmVjdGFuZ2xlKHgsIHksIGxlbmd0aCwgbGVuZ3RoLCAwLCAwLCAwLCAwLCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgdGV4dCh0LCB4LCB5LCB0ZXh0QW5jaG9yLCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgPHRleHQgeD0nJHt4fScgeT0nJHt4fScgdGV4dEFuY2hvcj0nJHt0ZXh0QW5jaG9yfScgc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfSc+JHt0fTwvdGV4dD5gO1xuICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2hhcGVzO1xuIiwibGV0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMuanMnKTtcblxubGV0IHN2Z2I2NFN0ciA9IHJlcXVpcmUoJy4uL3V0aWwvc3ZnLmpzJyk7XG5sZXQgdW5pdE9mSW5mbyA9IHJlcXVpcmUoJy4vdW5pdE9mSW5mb3JtYXRpb24uanMnKTtcbi8vIFFVQUQxICB8ICBRVUFEMlxuLy8gKC0sIC0pIHwgICgrLCAtKVxuLy8gLS0tLS0tLS0tLS0tLVxuLy8gUVVBRDQgIHwgUVVBRDNcbi8vICgtLCArKSB8ICAoKywgKylcbmNvbnN0IHF1YWQxID0gJy0xLCAtMC45LCAtMC45NSwgLTAuOTUsIC0wLjMzLCAtMSc7XG5cbmNvbnN0IHF1YWQyID0gJzAuMzMsIC0xLCAwLjksIC0wLjk1LCAxLCAtMC45JztcblxuY29uc3QgcXVhZDMgPSAnMSwgMC45LCAwLjk1LCAwLjk1LCAwLjMzLCAxJztcblxuY29uc3QgcXVhZDQgPSAnLTAuMzMsIDEsIC0wLjk1LCAwLjk1LCAtMSwgMC45JztcblxuY29uc3QgcG9pbnRzID0gKCkgPT4ge1xuICByZXR1cm4gYCR7cXVhZDF9LCAke3F1YWQyfSwgJHtxdWFkM30sICR7cXVhZDR9YDtcbn07XG5cbmNvbnN0IHN2Z1VyaSA9IChub2RlLCBib3JkZXJXaWR0aCA9IDMuNzUpID0+IHtcblxuICBsZXQgbmggPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gIGxldCBudyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuXG4gIGxldCB1SW5mbyA9ICcnO1xuXG4gIGlmIChub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGluZm8gPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJylbMF0ubGFiZWwudGV4dDsgLy8gZnJhZ2lsZVxuICAgIHVJbmZvID0gdW5pdE9mSW5mby5wbGFjZShpbmZvLCAwLCBuaCAvIDIsIC4xKm53LCAwLjA1Km53LCBudywgbmgpO1xuICB9XG5cbiAgbGV0IHN0eWxlID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgYm9yZGVyV2lkdGgpXG4gICAgLnNldCgnZmlsbCcsICdub25lJylcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpO1xuXG4gIGNvbnN0IGNvbXBhcnRtZW50ID1cbiAgYFxuICAke2Jhc2VTaGFwZXMuYmFycmVsKG53LCBuaCwgc3R5bGUpfVxuICAke3VJbmZvfVxuICBgO1xuXG4gIHJldHVybiBzdmdiNjRTdHIoY29tcGFydG1lbnQsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwb2ludHM6IHBvaW50cyxcbiAgc3ZnVXJpOiBzdmdVcmlcbn07XG4iLCJjb25zdCBiYXNlU2hhcGVzID0gcmVxdWlyZSgnLi9iYXNlU2hhcGVzLmpzJyk7XG5jb25zdCBzdmdTdHIgPSByZXF1aXJlKCcuLi91dGlsL3N2Zy5qcycpO1xuXG5jb25zdCBlbnRpdHlQb29sTm9kZXMgPSB7XG5cbiAgdW5zcGVjaWZpZWRFbnRpdHkobm9kZSkge1xuICAgIGxldCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgbGV0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCB1bnNwZWNFbnRpdHlTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5lbGxpcHNlKG53IC8gMiwgbmggLyAyLCAoIG5oIC0gMiApIC8gMiwgKCBudyAtIDIgKSAvIDIsIHN0eWxlTWFwKX1cbiAgICBgO1xuICAgIHJldHVybiBzdmdTdHIodW5zcGVjRW50aXR5U3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG4gIHNpbXBsZUNoZW1pY2FsKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgc2ltcGxlQ2hlbWljYWxTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUobncgLyAyLCBuaCAvIDIsIChNYXRoLm1pbihudywgbmgpIC0gMikgLyAyLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHNpbXBsZUNoZW1pY2FsU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG4gIG1hY3JvbW9sZWN1bGUobm9kZSkge1xuICAgIGxldCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgbGV0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICczJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCBtYWNyb21vbGVjdWxlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMucm91bmRSZWN0YW5nbGUoMCwgMCwgbncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKG1hY3JvbW9sZWN1bGVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcbiAgbnVjbGVpY0FjaWRGZWF0dXJlKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMycpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgbnVjbGVpY0FjaWRGZWF0dXJlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMucm91bmRCb3R0b21SZWN0YW5nbGUoMCwgMCwgbncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKG51Y2xlaWNBY2lkRmVhdHVyZVN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuICBjb21wbGV4KG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgICBsZXQgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzMnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgbGV0IGNvbXBsZXhTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jdXRSZWN0YW5nbGUobncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKGNvbXBsZXhTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcbiAgc291cmNlQW5kU2luayhub2RlKSB7XG4gICAgbGV0IG5vZGVDZW50ZXJYID0gbm9kZS53aWR0aCgpIC8gMjtcbiAgICBsZXQgbm9kZUNlbnRlclkgPSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBsZXQgY2lyY2xlUmFkaXVzID0gKG5vZGUud2lkdGgoKSAtIDIpIC8gMjtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2UtbGluZWNhcCcsICdzcXVhcmUnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcxLjUnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgY29uc3Qgc291cmNlQW5kU2lua1N2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShub2RlQ2VudGVyWCwgbm9kZUNlbnRlclksIGNpcmNsZVJhZGl1cywgc3R5bGVNYXApfVxuICAgICAgJHtiYXNlU2hhcGVzLmxpbmUoMCwgbm9kZS5oZWlnaHQoKSwgbm9kZS53aWR0aCgpLCAwLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHNvdXJjZUFuZFNpbmtTdmcsIG5vZGUud2lkdGgoKSwgbm9kZS5oZWlnaHQoKSwgMCwgMCwgbm9kZS53aWR0aCgpLCBub2RlLmhlaWdodCgpKTtcbiAgfSxcbiAgcGVydHVyYmluZ0FnZW50KG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMycpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgcGVydHVyYmluZ0FnZW50U3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuY29uY2F2ZUhleGFnb24obncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHBlcnR1cmJpbmdBZ2VudFN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9XG59O1xuXG5jb25zdCBlcG5NYXAgPSBuZXcgTWFwKClcbi5zZXQoJ3NvdXJjZSBhbmQgc2luaycsIGVudGl0eVBvb2xOb2Rlcy5zb3VyY2VBbmRTaW5rKVxuLnNldCgndW5zcGVjaWZpZWQgZW50aXR5JywgZW50aXR5UG9vbE5vZGVzLnVuc3BlY2lmaWVkRW50aXR5KVxuLnNldCgnc2ltcGxlIGNoZW1pY2FsJywgZW50aXR5UG9vbE5vZGVzLnNpbXBsZUNoZW1pY2FsKVxuLnNldCgnbWFjcm9tb2xlY3VsZScsIGVudGl0eVBvb2xOb2Rlcy5tYWNyb21vbGVjdWxlKVxuLnNldCgnbnVjbGVpYyBhY2lkIGZlYXR1cmUnLCBlbnRpdHlQb29sTm9kZXMubnVjbGVpY0FjaWRGZWF0dXJlKVxuLnNldCgnY29tcGxleCcsIGVudGl0eVBvb2xOb2Rlcy5jb21wbGV4KVxuLnNldCgncGVydHVyYmluZyBhZ2VudCcsIGVudGl0eVBvb2xOb2Rlcy5wZXJ0dXJiaW5nQWdlbnQpO1xuXG5jb25zdCBkcmF3ID0gKG5vZGUpID0+IHtcbiAgcmV0dXJuIGVwbk1hcC5nZXQobm9kZS5kYXRhKCdjbGFzcycpKShub2RlKSB8fCAnJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3XG59OyIsImNvbnN0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMuanMnKTtcbmNvbnN0IHN2Z1N0ciA9IHJlcXVpcmUoJy4uL3V0aWwvc3ZnLmpzJyk7XG5cbmNvbnN0IHByb2Nlc3NOb2RlcyA9IHtcblxuICBwcm9jZXNzKG5vZGUpIHtcbiAgICBjb25zdCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBjb25zdCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgICBjb25zdCBsaW5lU3R5bGUgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzEnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgY29uc3Qgc3F1YXJlU3R5bGUgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzEnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnd2hpdGUnKVxuICAgIC5zZXQoJ2ZpbGwtb3BhY2l0eScsICcxJyk7XG5cbiAgICBjb25zdCBsaW5lID0gYmFzZVNoYXBlcy5saW5lKDAsIG5oIC8gMiwgbncsIG5oIC8gMiwgbGluZVN0eWxlKTtcblxuICAgIGNvbnN0IHByb2Nlc3NTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5zcXVhcmUoMC4xKm53LCAwLjEqbmgsIDAuOCpNYXRoLm1heChudywgbmgpLCBzcXVhcmVTdHlsZSl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHByb2Nlc3NTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBhc3NvY2lhdGlvbihub2RlKSB7XG4gICAgY29uc3QgbncgPSBub2RlLndpZHRoKCk7XG4gICAgY29uc3QgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgY29uc3QgY2VudGVyWCA9IG53IC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gbmggLyAyO1xuICAgIGNvbnN0IHJhZGl1cyA9IChNYXRoLm1pbihudywgbmgpIC0gMikgLyAyO1xuXG4gICAgY29uc3Qgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzInKVxuICAgIC5zZXQoJ2ZpbGwnLCAnIzZBNkE2QScpO1xuXG4gICAgY29uc3QgbGluZSA9IGJhc2VTaGFwZXMubGluZSgwLCBuaCAvIDIsIG53LCBuaCAvIDIsIHN0eWxlTWFwKTtcblxuICAgIGNvbnN0IGFzc29jaWF0aW9uU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuY2lyY2xlKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgc3R5bGVNYXApfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihhc3NvY2lhdGlvblN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuXG4gIGRpc3NvY2lhdGlvbihub2RlKSB7XG4gICAgY29uc3QgbncgPSBub2RlLndpZHRoKCk7XG4gICAgY29uc3QgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgY29uc3QgY2VudGVyWCA9IG5vZGUud2lkdGgoKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IG5vZGUuaGVpZ2h0KCkgLyAyO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gKE1hdGgubWluKG53LCBuaCkgLSAyKSAvIDI7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSAoTWF0aC5taW4obncsIG5oKSAtIDIpIC8gMztcblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGNvbnN0IGRpc3NvY2lhdGlvblN2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3R5bGVNYXApfVxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgc3R5bGVNYXApfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihkaXNzb2NpYXRpb25TdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBwaGVub3R5cGUobm9kZSkge1xuICAgIGNvbnN0IG53ID0gbm9kZS53aWR0aCgpO1xuICAgIGNvbnN0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICczJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCBwaGVub3R5cGVTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5oZXhhZ29uKG53LCBuaCwgc3R5bGVNYXApfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihwaGVub3R5cGVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfVxufTtcblxuY29uc3QgcHJvY2Vzc01hcCA9IG5ldyBNYXAoKVxuLnNldCgncHJvY2VzcycsIHByb2Nlc3NOb2Rlcy5wcm9jZXNzKVxuLnNldCgnb21pdHRlZCBwcm9jZXNzJywgcHJvY2Vzc05vZGVzLnByb2Nlc3MpXG4uc2V0KCd1bmNlcnRhaW4gcHJvY2VzcycsIHByb2Nlc3NOb2Rlcy5wcm9jZXNzKVxuLnNldCgnYXNzb2NpYXRpb24nLCBwcm9jZXNzTm9kZXMuYXNzb2NpYXRpb24pXG4uc2V0KCdkaXNzb2NpYXRpb24nLCBwcm9jZXNzTm9kZXMuZGlzc29jaWF0aW9uKVxuLnNldCgncGhlbm90eXBlJywgcHJvY2Vzc05vZGVzLnBoZW5vdHlwZSk7XG5cbmNvbnN0IGRyYXcgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gcHJvY2Vzc01hcC5nZXQobm9kZS5kYXRhKCdjbGFzcycpKShub2RlKSB8fCAnJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3XG59OyIsImxldCBzdmdiNjRTdHIgPSByZXF1aXJlKCcuLi91dGlsL3N2Zy5qcycpO1xubGV0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMuanMnKTtcblxuLy8gUVVBRDEgIHwgIFFVQUQyXG4vLyAoLSwgLSkgfCAgKCssIC0pXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyBRVUFENCAgfCBRVUFEM1xuLy8gKC0sICspIHwgICgrLCArKVxuY29uc3QgcXVhZDEgPSAnLTAuODYsIDAuNSwgLTAuNzUsIDAuNjUsIC0xLCAwLjk1LCAtMC45NSwgMSwgLTAuNjUsIDAuNzUsIC0wLjUsIDAuODYsIDAsIDEnO1xuXG5jb25zdCBxdWFkMiA9ICcwLjUsIDAuODYsIDAuNzEsIDAuNzEsIDAuODYsIDAuNSwgMSwgMCc7XG5cbmNvbnN0IHF1YWQzID0gJzAuODYsIC0wLjUsIDAuNzUsIC0wLjY1LCAxLCAtMC45NSwgMC45NSwgLTEsIDAuNjUsIC0wLjc1LCAwLjUsIC0wLjg2LCAwLCAtMSc7XG5cbmNvbnN0IHF1YWQ0ID0gJy0wLjUsIC0wLjg2LCAtMC43MSwgLTAuNzEsIC0wLjg2LCAtMC41LCAtMSwgMCwnO1xuXG5jb25zdCBwb2ludHMgPSAoKSA9PiB7XG4gIHJldHVybiBgJHtxdWFkMX0sICR7cXVhZDJ9LCAke3F1YWQzfSwgJHtxdWFkNH1gO1xufTtcblxuY29uc3Qgc3ZnVXJpID0gKG5vZGUsIHN0cm9rZUNvbG9yID0gJ2dyZXknICwgZWRnZVdpZHRoID0gMSkgPT4ge1xuICBsZXQgY2xvbmVNYXJrZXIgPSAnJztcbiAgbGV0IGNsaXBQYXRoID0gJyc7XG5cbiAgbGV0IG5vZGVDZW50ZXJYID0gbm9kZS53aWR0aCgpIC8gMjtcbiAgbGV0IG5vZGVDZW50ZXJZID0gbm9kZS5oZWlnaHQoKSAvIDI7XG4gIGxldCBjaXJjbGVSYWRpdXMgPSAobm9kZS53aWR0aCgpIC0gMikgLyAyO1xuXG4gIGlmIChub2RlLmRhdGEoJ2Nsb25lbWFya2VyJykpIHtcbiAgICBjbGlwUGF0aCA9IGBcbiAgICA8ZGVmcz5cbiAgICAgIDxjbGlwUGF0aCBpZD1cImN1dC1vZmYtYm90dG9tXCI+XG4gICAgICAgIDxyZWN0IHg9XCIwXCIgeT1cIiR7MiAqIG5vZGUuaGVpZ2h0KCkgLyAzfVwiIHdpZHRoPVwiJHtub2RlLndpZHRoKCl9XCIgaGVpZ2h0PVwiJHtub2RlLndpZHRoKCl9XCIgLz5cbiAgICAgIDwvY2xpcFBhdGg+XG4gICAgPC9kZWZzPlxuICAgIGA7XG4gICAgY2xvbmVNYXJrZXIgPSBgXG4gICAgPGNpcmNsZSBjeD1cIiR7bm9kZUNlbnRlclh9XCIgY3k9XCIke25vZGVDZW50ZXJZfVwiIHI9XCIke2NpcmNsZVJhZGl1c31cIiBmaWxsPScjRDJEMkQyJyBzdHJva2U9J2dyZXknIGNsaXAtcGF0aD1cInVybCgjY3V0LW9mZi1ib3R0b20pXCIgLz5cbiAgICBgO1xuICB9XG5cbiAgbGV0IHN0eWxlID0gbmV3IE1hcCgpXG4gIC5zZXQoJ2ZpbGwnLCAnbm9uZScpXG4gIC5zZXQoJ3N0cm9rZScsIHN0cm9rZUNvbG9yKVxuICAuc2V0KCdzdHJva2Utd2lkdGgnLCBlZGdlV2lkdGgpO1xuXG4gIGNvbnN0IHNvdXJjZUFuZFNpbmsgPSBcbiAgYFxuICAgICR7YmFzZVNoYXBlcy5jaXJjbGUobm9kZUNlbnRlclgsIG5vZGVDZW50ZXJZLCBjaXJjbGVSYWRpdXMsIHN0eWxlKX1cbiAgICAke2NsaXBQYXRofVxuICAgICR7Y2xvbmVNYXJrZXJ9XG4gICAgJHtiYXNlU2hhcGVzLmxpbmUoMCwgbm9kZS5oZWlnaHQoKSwgbm9kZS53aWR0aCgpLCAwLCBzdHlsZSl9XG4gIGA7XG5cbiAgcmV0dXJuIHN2Z2I2NFN0cihzb3VyY2VBbmRTaW5rLCBub2RlLndpZHRoKCksIG5vZGUuaGVpZ2h0KCksIDAsIDAsIG5vZGUud2lkdGgoKSwgbm9kZS5oZWlnaHQoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ZnVXJpOiBzdmdVcmksXG4gIHBvaW50czogcG9pbnRzXG59O1xuIiwiY29uc3QgcG9pbnRPbk5vZGVQZXJpbWV0ZXIgPSAoeCwgeSwgbm9kZSkgPT4ge1xuICByZXR1cm4gKCAoIHggPT09IDAgfHwgeCA9PT0gbm9kZS53aWR0aCgpICkgJiYgKCAwIDw9IHkgPD0gbm9kZS5oZWlnaHQoKSApIClcbiAgIHx8ICggKCB5ID09PSAwIHx8IHkgPT09IG5vZGUuaGVpZ2h0KCkgKSAmJiAoIDAgPD0geCA8PSBub2RlLndpZHRoKCkgKSApOyBcbn07XG5cbmNvbnN0IHBsYWNlID0gKGxhYmVsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCkgPT4ge1xuICByZXR1cm4gYFxuICA8c3ZnIHByc2VydmVBc3BlY3RSYXRpbz0neE1pZFlNaW4gbWVldCcgd2lkdGg9JyR7dnBXaWR0aH0nIGhlaWdodD0nJHt2cEhlaWdodH0nIHZpZXdCb3g9JzAgMCAke3ZwV2lkdGh9ICR7dnBIZWlnaHR9Jz5cbiAgICA8cmVjdCBmaWxsPSd3aGl0ZScgc3Ryb2tlPSdibGFjaycgeD0nJHt4fScgeT0nJHt5fScgd2lkdGg9JyR7d2lkdGh9JyBoZWlnaHQ9JyR7aGVpZ2h0fScgLz5cbiAgICA8dGV4dCB0ZXh0LWFuY2hvcj0nbWlkZGxlJyB4PScke3ggKyAod2lkdGgvMil9JyB5PScke3kgKyAoaGVpZ2h0LzIpfSc+JHtsYWJlbH08L3RleHQ+XG4gIDwvc3ZnPlxuICBgO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBsYWNlOiBwbGFjZVxufTtcbiIsImNvbnN0IGVsZW1lbnRTdHlsZSA9IHJlcXVpcmUoJy4vZWxlbWVudC5qcycpO1xuXG5jb25zdCBzb3VyY2VBbmRTaW5rID0gcmVxdWlyZSgnLi9nbHlwaC9zb3VyY2VBbmRTaW5rLmpzJyk7XG5jb25zdCBjb21wYXJ0bWVudCA9IHJlcXVpcmUoJy4vZ2x5cGgvY29tcGFydG1lbnQuanMnKTtcblxuY29uc3QgZW50aXR5UG9vbFNoYXBlcyA9IHJlcXVpcmUoJy4vZ2x5cGgvZW50aXR5UG9vbE5vZGVTaGFwZXMuanMnKTtcbmNvbnN0IHByb2Nlc3NOb2RlU2hhcGVzID0gcmVxdWlyZSgnLi9nbHlwaC9wcm9jZXNzTm9kZVNoYXBlcy5qcycpO1xuXG4vLyBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGN5dG9zY2FwZSBzdHlsZSBzaGVldCBmcm9tIGEgZ2l2ZW5cbi8vIGN5dG9zY2FwZSBpbnN0YW5jZVxudmFyIHNiZ25TdHlsZVNoZWV0ID0gZnVuY3Rpb24gKGN5dG9zY2FwZSkge1xuXG4gIHJldHVybiBjeXRvc2NhcGUuc3R5bGVzaGVldCgpXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdjb250ZW50JzogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50U3R5bGUuc2JnbkNvbnRlbnQobm9kZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnZm9udC1zaXplJzogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50U3R5bGUubGFiZWxUZXh0U2l6ZShub2RlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAxLjUsXG4gICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjNTU1JyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZjZmNmY2JyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC13cmFwJzogJ3dyYXAnLFxuICAgICAgICAgICd0ZXh0LW1heC13aWR0aCc6IDEwMCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzaGFwZSc6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFN0eWxlLnNiZ25TaGFwZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cInByb2Nlc3NcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUnOiAnc3F1YXJlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBwcm9jZXNzTm9kZVNoYXBlcy5kcmF3KG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxNTAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTUwJScsXG4gICAgICAgICAgJ3BhZGRpbmcnOiAobm9kZSkgPT4gTWF0aC5tYXgobm9kZS53aWR0aCgpLCBub2RlLmhlaWdodCgpKSAqIDAuMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cImFzc29jaWF0aW9uXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHByb2Nlc3NOb2RlU2hhcGVzLmRyYXcobm9kZSksXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cImRpc3NvY2lhdGlvblwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBwcm9jZXNzTm9kZVNoYXBlcy5kcmF3KG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJwaGVub3R5cGVcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUnOiAnaGV4YWdvbicsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gcHJvY2Vzc05vZGVTaGFwZXMuZHJhdyhub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwic291cmNlIGFuZCBzaW5rXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogc291cmNlQW5kU2luay5wb2ludHMoKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBlbnRpdHlQb29sU2hhcGVzLmRyYXcobm9kZSksXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cIm51Y2xlaWMgYWNpZCBmZWF0dXJlXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gZW50aXR5UG9vbFNoYXBlcy5kcmF3KG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJwZXJ0dXJiaW5nIGFnZW50XCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAtMC41LCAwLCAgLTEsIDEsICAgMSwgMSwgICAwLjUsIDAsIDEsIC0xJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBlbnRpdHlQb29sU2hhcGVzLmRyYXcobm9kZSksXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cImNvbXBsZXhcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBlbnRpdHlQb29sU2hhcGVzLmRyYXcobm9kZSksXG4gICAgICAgICAgJ3BhZGRpbmcnOiAobm9kZSkgPT4gTWF0aC5taW4obm9kZS5oZWlnaHQoKSwgbm9kZS53aWR0aCgpKSAqIC4wNTUsXG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzExMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMTAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICdib3R0b20nLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdtaW4taGVpZ2h0JzogKG5vZGUpID0+IG5vZGUud2lkdGgoKSAqIC43NSxcbiAgICAgICAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6ICc1MCUnLFxuICAgICAgICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogJzUwJSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwibWFjcm9tb2xlY3VsZVwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IGVudGl0eVBvb2xTaGFwZXMuZHJhdyhub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwic2ltcGxlIGNoZW1pY2FsXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IGVudGl0eVBvb2xTaGFwZXMuZHJhdyhub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwidW5zcGVjaWZpZWQgZW50aXR5XCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IGVudGl0eVBvb2xTaGFwZXMuZHJhdyhub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwiY29tcGFydG1lbnRcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiBjb21wYXJ0bWVudC5wb2ludHMoKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFydG1lbnQuc3ZnVXJpKG5vZGUsIDUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzExMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMTAlJyxcbiAgICAgICAgICAncGFkZGluZyc6IChub2RlKSA9PiBNYXRoLm1heChub2RlLmhlaWdodCgpLCBub2RlLndpZHRoKCkpICogLjEsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMSxcbiAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJ2dyZWVuJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC12YWxpZ24nOiAnYm90dG9tJyxcbiAgICAgICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAnbWluLWhlaWdodCc6IDEwMCxcbiAgICAgICAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6ICc1MCUnLFxuICAgICAgICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogJzUwJScsXG4gICAgICAgICAgJ21pbi13aWR0aCc6IDE3NSxcbiAgICAgICAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAnNTAlJyxcbiAgICAgICAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6ICc1MCUnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cInRhZ1wiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMC4yNSwgLTEsICAgMSwgMCwgICAgMC4yNSwgMSwgICAgLTEsIDEnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cImFzc29jaWF0aW9uXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzZCNkI2QidcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2Jib3hdW2NsYXNzXVtjbGFzcyE9XCJjb21wbGV4XCJdW2NsYXNzIT1cImNvbXBhcnRtZW50XCJdW2NsYXNzIT1cInN1Ym1hcFwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6ICdkYXRhKGJib3gudyknLFxuICAgICAgICAgICdoZWlnaHQnOiAnZGF0YShiYm94LmgpJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGU6c2VsZWN0ZWQnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlOmFjdGl2ZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjcsICdvdmVybGF5LWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICdvdmVybGF5LXBhZGRpbmcnOiAnMTQnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgICAgICdsaW5lLWNvbG9yJzogJyM1NTUnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdob2xsb3cnLFxuICAgICAgICAgICdzb3VyY2UtYXJyb3ctZmlsbCc6ICdob2xsb3cnLFxuICAgICAgICAgICd3aWR0aCc6IDEuNSxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyM1NTUnLFxuICAgICAgICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcjZDY3NjE0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGdlLmNzcygnbGluZS1jb2xvcicpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2NvbG9yJzogKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcjZDY3NjE0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGdlLmNzcygnbGluZS1jb2xvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlOnNlbGVjdGVkJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2Q2NzYxNCcsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyNkNjc2MTQnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZTphY3RpdmUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMC43LCAnb3ZlcmxheS1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogJzgnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZVtjYXJkaW5hbGl0eSA+IDBdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RleHQtcm90YXRpb24nOiAnYXV0b3JvdGF0ZScsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogJzEnLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci13aWR0aCc6ICcxJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJ3doaXRlJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAnMSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzPVwiY29uc3VtcHRpb25cIl1bY2FyZGluYWxpdHkgPiAwXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzb3VyY2UtbGFiZWwnOiAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZWRnZS5kYXRhKCdjYXJkaW5hbGl0eScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogJy0xMCcsXG4gICAgICAgICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IChlZGdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFN0eWxlLmNhcmRpbmFsaXR5ZGlzdGFuY2UoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3M9XCJwcm9kdWN0aW9uXCJdW2NhcmRpbmFsaXR5ID4gMF0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAndGFyZ2V0LWxhYmVsJzogKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGVkZ2UuZGF0YSgnY2FyZGluYWxpdHknKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6ICctMTAnLFxuICAgICAgICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRTdHlsZS5nZXRDYXJkaW5hbGl0eURpc3RhbmNlKGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRTdHlsZS5zYmduQXJyb3dTaGFwZShlZGdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzPVwiaW5oaWJpdGlvblwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZVtjbGFzcz1cInByb2R1Y3Rpb25cIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2NvcmUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogJzAuMicsICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjZDY3NjE0J1xuICAgICAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2JnblN0eWxlU2hlZXQ7XG4iLCJjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cblxuY29uc3Qgc3ZnID0gKHN2Z1N0ciwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgdmJYID0gMCwgdmJZID0gMCwgdmJXaWR0aCA9IDEwMCwgdmJIZWlnaHQgPSAxMDApID0+IHtcbiAgbGV0IHN2Z1RleHQgPVxuICBgXG4gICAgPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JyR7d2lkdGh9JyBoZWlnaHQ9JyR7aGVpZ2h0fScgdmlld0JveD0nJHt2Ylh9ICR7dmJZfSAke3ZiV2lkdGh9ICR7dmJIZWlnaHR9Jz5cbiAgICAke3N2Z1N0cn1cbiAgICA8L3N2Zz5cbiAgYDtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnVGV4dCwgJ3RleHQveG1sJykuZG9jdW1lbnRFbGVtZW50O1xufTtcblxuY29uc3Qgc3ZnYjY0U3RyID0gKHN2Z1RleHQsIHZpZXdQb3J0V2lkdGgsIHZpZXdQb3J0SGVpZ2h0LCB2aWV3Qm94WCwgdmlld0JveFksIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCkgPT4ge1xuICBsZXQgc3ZnRWwgPSBzdmcoc3ZnVGV4dCwgdmlld1BvcnRXaWR0aCwgdmlld1BvcnRIZWlnaHQsIHZpZXdCb3hYLCB2aWV3Qm94WSwgdmlld0JveFdpZHRoLCB2aWV3Qm94SGVpZ2h0KTtcbiAgbGV0IGI2NERhdGEgPSBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2Eoc3ZnRWwub3V0ZXJIVE1MKX1gO1xuXG4gIHJldHVybiBiNjREYXRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdmdiNjRTdHI7Il19
