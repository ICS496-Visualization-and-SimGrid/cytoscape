(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _index = require('../src/index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var convertSbgnml = require('sbgnml-to-cytoscape'); /* global $ */

var saveAs = require('file-saver').saveAs;

var defaultData = require('./test-data');

var loadFileText = function loadFileText(absFilePath) {
  var xhttp;
  if (window.XMLHttpRequest) {
    xhttp = new XMLHttpRequest();
  } else {
    xhttp = new ActiveXObject('Microsoft.XMLHTTP');
  }
  xhttp.open('GET', absFilePath, false);
  xhttp.send();
  return xhttp.responseText;
};

var readFile = function readFile(renderer, file) {
  var reader = new FileReader();

  reader.onload = function (e) {
    var graph = convertSbgnml(e.target.result);
    renderGraph(renderer, graph);
  };

  reader.readAsText(file);
};

var renderGraph = function renderGraph(cy, cyGraph) {
  cy.startBatch();
  cy.remove('*');
  cy.add(cyGraph);

  var nodePositions = {};
  for (var i = 0; i < cyGraph.nodes.length; i++) {
    var xPos = cyGraph.nodes[i].data.bbox.x;
    var yPos = cyGraph.nodes[i].data.bbox.y;
    nodePositions[cyGraph.nodes[i].data.id] = { 'x': xPos, 'y': yPos };
  }

  cy.layout({
    name: 'preset',
    positions: nodePositions,
    fit: true,
    padding: 50
  });

  cy.endBatch();
  cy.style().update();
};

var b64toBlob = function b64toBlob(b64Data, contentType, sliceSize) {
  contentType = contentType || '';
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

var save = function save(renderer, filename) {
  var graphFileString = renderer.png({ scale: 3, full: true });

  var b64Data = graphFileString.substr(graphFileString.indexOf(',') + 1);
  saveAs(b64toBlob(b64Data, 'image/png'), filename);
};

$(document).ready(function () {

  var container = $('#sbgn-network-container');

  var renderer = new _index2.default({
    container: container
  });

  window.r = window.cy = renderer;
  renderGraph(renderer, defaultData);

  $('#graph-load').click(function () {
    $('#graph-input').trigger('click');
  });

  $('#graph-input').change(function () {
    if ($(this).val() != '') {
      var file = this.files[0];

      readFile(renderer, file);
    }
  });

  $('#graph-save').click(function () {
    save(renderer, 'graph');
  });

  $('.sample-file').click(function () {
    var fileText = loadFileText('samples/' + $(this)[0].innerText + '.xml');
    var graphJson = convertSbgnml(fileText);
    renderGraph(renderer, graphJson);
  });
});

},{"../src/index":118,"./test-data":2,"file-saver":111,"sbgnml-to-cytoscape":116}],2:[function(require,module,exports){
"use strict";

var mapkCascadeData = {
    "nodes": [{
        "data": {
            "id": "glyph4",
            "bbox": {
                "x": 318.1589165885067,
                "y": 162.59898679973332,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph5",
            "bbox": {
                "x": 368.7150698032765,
                "y": 353.3425311332147,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph7",
            "bbox": {
                "x": 423.4601247086921,
                "y": 103.68144699737059,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph6",
            "bbox": {
                "x": 514.8286564804162,
                "y": 40.16169718646756,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph10",
            "bbox": {
                "x": 588.775693273037,
                "y": 410.5318087906144,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph9",
            "bbox": {
                "x": 497.6859428037237,
                "y": 352.2241646137692,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph2",
            "bbox": {
                "x": 467.18302213209245,
                "y": 240.2873064873903,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAF",
            "statesandinfos": [{
                "id": "glyph2a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph18",
            "bbox": {
                "x": 944.040949176361,
                "y": 284.0657446868406,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph16",
            "bbox": {
                "x": 689.1314585303767,
                "y": 482.44467100584745,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ADP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph15",
            "bbox": {
                "x": 882.8443326294546,
                "y": 482.5246268128043,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph17",
            "bbox": {
                "x": 759.9810408902129,
                "y": 220.58540441014577,
                "w": "60.0",
                "h": "60.0"
            },
            "class": "simple chemical",
            "label": "ATP",
            "statesandinfos": [],
            "parent": "",
            "clonemarker": true,
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph12",
            "bbox": {
                "x": 722.5240088762721,
                "y": 352.770069365478,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph12a",
                "clazz": "state variable",
                "state": {
                    "value": "2P"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "32.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph19",
            "bbox": {
                "x": 887.0312955929699,
                "y": 188.01104320899924,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph19a",
                "clazz": "state variable",
                "state": {
                    "value": "2P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "32.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph20",
            "bbox": {
                "x": 971.0567176507191,
                "y": 84.6685272739719,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "tag",
            "label": "ERK",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph1",
            "bbox": {
                "x": 213.55056132706864,
                "y": 236.18933213306605,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAS",
            "statesandinfos": [{
                "id": "glyph1a",
                "clazz": "state variable",
                "state": {
                    "value": "active"
                },
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "50.0",
                    "h": "26.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph0",
            "bbox": {
                "x": 60.134389512288635,
                "y": 200.02587224541605,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "tag",
            "label": "RAS",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph24",
            "bbox": {
                "x": 607.5584862953788,
                "y": 216.36466489184716,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph24a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph11",
            "bbox": {
                "x": 592.6185230656652,
                "y": 313.4502085225929,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph25",
            "bbox": {
                "x": 247.4431965319236,
                "y": 338.29565236558483,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "RAF",
            "statesandinfos": [{
                "id": "glyph25a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": 0,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph3",
            "bbox": {
                "x": 337.77918025112933,
                "y": 259.13454532846924,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph23",
            "bbox": {
                "x": 631.3665810796247,
                "y": 93.61445750305336,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "MEK",
            "statesandinfos": [{
                "id": "glyph23a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph8",
            "bbox": {
                "x": 516.9252315842282,
                "y": 142.01290840429613,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph22",
            "bbox": {
                "x": 786.1602768573573,
                "y": 557.4534904328991,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph22a",
                "clazz": "state variable",
                "state": {},
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "20.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph13",
            "bbox": {
                "x": 844.4300288939096,
                "y": 284.87165823750354,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph14",
            "bbox": {
                "x": 783.7402046808443,
                "y": 453.1501505501591,
                "w": "20.0",
                "h": "20.0"
            },
            "class": "process",
            "statesandinfos": [],
            "parent": "",
            "ports": []
        }
    }, {
        "data": {
            "id": "glyph21",
            "bbox": {
                "x": 872.1517334162531,
                "y": 378.5680972732039,
                "w": "100.0",
                "h": "60.0"
            },
            "class": "macromolecule",
            "label": "ERK",
            "statesandinfos": [{
                "id": "glyph21a",
                "clazz": "state variable",
                "state": {
                    "value": "P"
                },
                "bbox": {
                    "x": -25,
                    "y": 50,
                    "w": "25.0",
                    "h": "22.0"
                }
            }],
            "parent": "",
            "ports": []
        }
    }],
    "edges": [{
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph3",
            "target": "glyph2",
            "portsource": "glyph3",
            "porttarget": "glyph2"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph4",
            "target": "glyph3",
            "portsource": "glyph4",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph3",
            "target": "glyph5",
            "portsource": "glyph3",
            "porttarget": "glyph5"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph1",
            "target": "glyph3",
            "portsource": "glyph1",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph7",
            "target": "glyph8",
            "portsource": "glyph7",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph8",
            "target": "glyph6",
            "portsource": "glyph8",
            "porttarget": "glyph6"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph10",
            "target": "glyph11",
            "portsource": "glyph10",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph11",
            "target": "glyph12",
            "portsource": "glyph11",
            "porttarget": "glyph12"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph11",
            "target": "glyph9",
            "portsource": "glyph11",
            "porttarget": "glyph9"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph2",
            "target": "glyph11",
            "portsource": "glyph2",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph2",
            "target": "glyph8",
            "portsource": "glyph2",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph13",
            "target": "glyph19",
            "portsource": "glyph13",
            "porttarget": "glyph19"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph13",
            "target": "glyph18",
            "portsource": "glyph13",
            "porttarget": "glyph18"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph14",
            "target": "glyph16",
            "portsource": "glyph14",
            "porttarget": "glyph16"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph15",
            "target": "glyph14",
            "portsource": "glyph15",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph17",
            "target": "glyph13",
            "portsource": "glyph17",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph12",
            "target": "glyph13",
            "portsource": "glyph12",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "catalysis",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph12",
            "target": "glyph14",
            "portsource": "glyph12",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "equivalence arc",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph19",
            "target": "glyph20",
            "portsource": "glyph19",
            "porttarget": "glyph20"
        }
    }, {
        "data": {
            "class": "equivalence arc",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph1",
            "target": "glyph0",
            "portsource": "glyph1",
            "porttarget": "glyph0"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph8",
            "target": "glyph24",
            "portsource": "glyph8",
            "porttarget": "glyph24"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph24",
            "target": "glyph11",
            "portsource": "glyph24",
            "porttarget": "glyph11"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph25",
            "target": "glyph3",
            "portsource": "glyph25",
            "porttarget": "glyph3"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph23",
            "target": "glyph8",
            "portsource": "glyph23",
            "porttarget": "glyph8"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph22",
            "target": "glyph14",
            "portsource": "glyph22",
            "porttarget": "glyph14"
        }
    }, {
        "data": {
            "class": "consumption",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph21",
            "target": "glyph13",
            "portsource": "glyph21",
            "porttarget": "glyph13"
        }
    }, {
        "data": {
            "class": "production",
            "bendPointPositions": [],
            "cardinality": 0,
            "source": "glyph14",
            "target": "glyph21",
            "portsource": "glyph14",
            "porttarget": "glyph21"
        }
    }]
};

module.exports = mapkCascadeData;

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){

/*!

Cytoscape.js {{VERSION}} (MIT licensed)

Copyright (c) The Cytoscape Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

'use strict';

},{}],5:[function(require,module,exports){
'use strict';

var util = require( './util' );
var is = require( './is' );
var Promise = require( './promise' );

var Animation = function( target, opts, opts2 ){
  if( !(this instanceof Animation) ){
    return new Animation( target, opts, opts2 );
  }

  var _p = this._private = util.extend( {
    duration: 1000
  }, opts, opts2 );

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if( _p.complete && is.fn( _p.complete ) ){
    _p.completes.push( _p.complete );
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend( anifn, {

  instanceString: function(){ return 'animation'; },

  hook: function(){
    var _p = this._private;

    if( !_p.hooked ){
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;
      if( _p.queue ){
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push( this );

      // add to the animation loop pool
      if( is.elementOrCollection( _p.target ) ){
        _p.target.cy().addToAnimationPool( _p.target );
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function(){
    var _p = this._private;

    // autorewind
    if( _p.progress === 1 ){
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function(){
    return this._private.playing;
  },

  apply: function(){
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function(){
    return this._private.applying;
  },

  pause: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function(){
    return this.progress( 0 );
  },

  fastforward: function(){
    return this.progress( 1 );
  },

  time: function( t ){
    var _p = this._private;

    if( t === undefined ){
      return _p.progress * _p.duration;
    } else {
      return this.progress( t / _p.duration );
    }
  },

  progress: function( p ){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( p === undefined ){
      return _p.progress;
    } else {
      if( wasPlaying ){
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if( wasPlaying ){
        this.play();
      }
    }

    return this;
  },

  completed: function(){
    return this._private.progress === 1;
  },

  reverse: function(){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( wasPlaying ){
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function( a, b ){
      var _pa = _p[ a ];

      _p[ a ] = _p[ b ];
      _p[ b ] = _pa;
    };

    swap( 'zoom', 'startZoom' );
    swap( 'pan', 'startPan' );
    swap( 'position', 'startPosition' );

    // swap styles
    for( var i = 0; i < _p.style.length; i++ ){
      var prop = _p.style[ i ];
      var name = prop.name;
      var startStyleProp = _p.startStyle[ name ];

      _p.startStyle[ name ] = prop;
      _p.style[ i ] = startStyleProp;
    }

    if( wasPlaying ){
      this.play();
    }

    return this;
  },

  promise: function( type ){
    var _p = this._private;

    var arr;

    switch( type ){
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise( function( resolve, reject ){
      arr.push( function(){
        resolve();
      } );
    } );
  }

} );

anifn.complete = anifn.completed;

module.exports = Animation;

},{"./is":86,"./promise":89,"./util":103}],6:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  aStar: function( options ){
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function( start, end, cameFromMap, pathAcum ){
      // Base case
      if( start == end ){
        pathAcum.push( cy.getElementById( end ) );
        return pathAcum;
      }

      if( end in cameFromMap ){
        // We know which node is before the last one
        var previous = cameFromMap[ end ];
        var previousEdge = cameFromEdge[ end ];

        pathAcum.push( cy.getElementById( end ) );
        pathAcum.push( cy.getElementById( previousEdge ) );


        return reconstructPath( start,
                     previous,
                     cameFromMap,
                     pathAcum );
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function( openSet, fScore ){
      if( openSet.length === 0 ){
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[ openSet[0] ];
      for( var i = 1; i < openSet.length; i++ ){
        var s = fScore[ openSet[ i ] ];
        if( s < tempScore ){
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if( options != null && options.root != null ){
      var source = is.string( options.root ) ?
        // use it as a selector, e.g. "#rootID
        this.filter( options.root )[0] :
        options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if( options.goal != null ){
      var target = is.string( options.goal ) ?
        // use it as a selector, e.g. "#goalID
        this.filter( options.goal )[0] :
        options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if( options.heuristic != null && is.fn( options.heuristic ) ){
      var heuristic = options.heuristic;
    } else {
      var heuristic = function(){ return 0; }; // use constant if unspecified
    }

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var closedSet = [];
    var openSet = [ source.id() ];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[ source.id() ] = 0;
    fScore[ source.id() ] = heuristic( source );

    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();

    // Counter
    var steps = 0;

    // Main loop
    while( openSet.length > 0 ){
      var minPos = findMin( openSet, fScore );
      var cMin = cy.getElementById( openSet[ minPos ] );
      steps++;

      // If we've found our goal, then we are done
      if( cMin.id() == target.id() ){
        var rPath = reconstructPath( source.id(), target.id(), cameFrom, [] );
        rPath.reverse();
        return {
          found: true,
          distance: gScore[ cMin.id() ],
          path: eles.spawn( rPath ),
          steps: steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push( cMin.id() );
      // Remove cMin from boundary nodes
      openSet.splice( minPos, 1 );

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin.connectedEdges();
      if( directed ){ vwEdges = vwEdges.stdFilter( function( ele ){ return ele.data( 'source' ) === cMin.id(); } ); }
      vwEdges = vwEdges.intersect( edges );

      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];
        var w = e.connectedNodes().stdFilter( function( n ){ return n.id() !== cMin.id(); } ).intersect( nodes );

        // if node is in closedSet, ignore it
        if( closedSet.indexOf( w.id() ) != -1 ){
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[ cMin.id() ] + weightFn.apply( e, [ e ] );

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if( openSet.indexOf( w.id() ) == -1 ){
          gScore[ w.id() ] = tempScore;
          fScore[ w.id() ] = tempScore + heuristic( w );
          openSet.push( w.id() ); // Add node to openSet
          cameFrom[ w.id() ] = cMin.id();
          cameFromEdge[ w.id() ] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if( tempScore < gScore[ w.id() ] ){
          gScore[ w.id() ] = tempScore;
          fScore[ w.id() ] = tempScore + heuristic( w );
          cameFrom[ w.id() ] = cMin.id();
        }

      } // End of neighbors update

    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }

}); // elesfn


module.exports = elesfn;

},{"../../is":86}],7:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var util = require( '../../util' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  bellmanFord: function( options ){
    var eles = this;

    options = options || {};

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var source = this.filter( options.root )[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for( var i = 0; i < numNodes; i++ ){
      if( nodes[ i ].id() === source.id() ){
        cost[ i ] = 0;
      } else {
        cost[ i ] = Infinity;
      }
      predecessor[ i ] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for( var i = 1; i < numNodes; i++ ){
      flag = false;
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );

        var temp = cost[ sourceIndex ] + weight;
        if( temp < cost[ targetIndex ] ){
          cost[ targetIndex ] = temp;
          predecessor[ targetIndex ] = sourceIndex;
          predEdge[ targetIndex ] = edges[ e ];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if( !directed ){
          var temp = cost[ targetIndex ] + weight;
          if( temp < cost[ sourceIndex ] ){
            cost[ sourceIndex ] = temp;
            predecessor[ sourceIndex ] = targetIndex;
            predEdge[ sourceIndex ] = edges[ e ];
            flag = true;
          }
        }
      }

      if( !flag ){
        break;
      }
    }

    if( flag ){
      // Check for negative weight cycles
      for( var e = 0; e < edges.length; e++ ){
        var sourceIndex = id2position[ edges[ e ].source().id() ];
        var targetIndex = id2position[ edges[ e ].target().id() ];
        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );

        if( cost[ sourceIndex ] + weight < cost[ targetIndex ] ){
          util.error( 'Graph contains a negative weight cycle for Bellman-Ford' );
          return { pathTo: undefined,
               distanceTo: undefined,
               hasNegativeWeightCycle: true};
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }


    var res = {
      distanceTo: function( to ){
        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[ id2position[ toId ] ];
      },

      pathTo: function( to ){

        var reconstructPathAux = function( predecessor, fromPos, toPos, position2id, acumPath, predEdge ){
          for( ;; ){
            // Add toId to path
            acumPath.push( cy.getElementById( position2id[ toPos ] ) );
            acumPath.push( predEdge[ toPos ] );

            if( fromPos === toPos ){
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[ toPos ];
            if( typeof predPos === 'undefined' ){
              return undefined;
            }

            toPos = predPos;
          }

        };

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res =  reconstructPathAux( predecessor,
                      id2position[ source.id() ],
                      id2position[ toId ],
                      position2id,
                      path,
                      predEdge );

        // Get it in the correct order and return it
        if( res != null ){
          res.reverse();
        }

        return eles.spawn( res );
      },

      hasNegativeWeightCycle: false
    };

    return res;

  } // bellmanFord

}); // elesfn

module.exports = elesfn;

},{"../../is":86,"../../util":103}],8:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var Heap = require( '../../heap' );

var elesfn = ({

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function( options ){
    options = options || {};

    // Weight - optional
    var weighted, weightFn;
    if( is.fn( options.weight ) ){
      weightFn = options.weight;
      weighted = true;
    } else {
      weighted = false;
    }

    // Directed - default false
    var directed = options.directed != null ? options.directed : false;

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function( key, val ){
        _C[ key ] = val;

        if( val > max ){ max = val; }
      },

      get: function( key ){ return _C[ key ]; }
    };

    // A contains the neighborhoods of every node
    for( var i = 0; i < V.length; i++ ){
      var v = V[ i ];
      var vid = v.id();

      if( directed ){
        A[ vid ] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[ vid ] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set( vid, 0 );
    }

    for( var s = 0; s < V.length; s++ ){
      var sid = V[s].id();
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function( a, b ){
        return d[a] - d[b];
      }); // queue

      // init dictionaries
      for( var i = 0; i < V.length; i++ ){
        var vid = V[ i ].id();

        P[ vid ] = [];
        g[ vid ] = 0;
        d[ vid ] = Infinity;
      }

      g[ sid ] = 1; // sigma
      d[ sid ] = 0; // distance to s

      Q.push( sid );

      while( !Q.empty() ){
        var v = Q.pop();

        S.push( v );

        if( weighted ){
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j];
            var vEle = cy.getElementById( v );

            var edge;
            if( vEle.edgesTo( w ).length > 0 ){
              edge = vEle.edgesTo( w )[0];
            } else {
              edge = w.edgesTo( vEle )[0];
            }

            var edgeWeight = weightFn.apply( edge, [ edge ] );

            w = w.id();

            if( d[w] > d[v] + edgeWeight ){
              d[w] = d[v] + edgeWeight;

              if( Q.nodes.indexOf( w ) < 0 ){ //if w is not in Q
                Q.push( w );
              } else { // update position if w is in Q
                Q.updateItem( w );
              }

              g[w] = 0;
              P[w] = [];
            }

            if( d[w] == d[v] + edgeWeight ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        } else {
          for( var j = 0; j < A[v].length; j++ ){
            var w = A[v][j].id();

            if( d[w] == Infinity ){
              Q.push( w );

              d[w] = d[v] + 1;
            }

            if( d[w] == d[v] + 1 ){
              g[w] = g[w] + g[v];
              P[w].push( v );
            }
          }
        }
      }

      var e = {};
      for( var i = 0; i < V.length; i++ ){
        e[ V[ i ].id() ] = 0;
      }

      while( S.length > 0 ){
        var w = S.pop();

        for( var j = 0; j < P[w].length; j++ ){
          var v = P[w][j];

          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);

          if( w != V[s].id() ){
            C.set( w, C.get( w ) + e[w] );
          }
        }
      }
    }

    var ret = {
      betweenness: function( node ){
        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node );
      },

      betweennessNormalized: function( node ){
        if ( max == 0 )
          return 0;

        if( is.string( node ) ){
          var node = cy.filter( node ).id();
        } else {
          var node = node.id();
        }

        return C.get( node ) / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

},{"../../heap":84,"../../is":86}],9:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var defineSearch = function( params ){
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn( roots, fn, directed ){
    var options;
    var std;
    var thisArg;
    if( is.plainObject( roots ) && !is.elementOrCollection( roots ) ){
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
      std = options.std;
      thisArg = options.thisArg;
    }

    directed = arguments.length === 2 && !is.fn( fn ) ? fn : directed;
    fn = is.fn( fn ) ? fn : function(){};

    var cy = this._private.cy;
    var v = roots = is.string( roots ) ? this.filter( roots ) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for( var i = 0; i < v.length; i++ ){
      if( v[ i ].isNode() ){
        Q.unshift( v[ i ] );

        if( params.bfs ){
          V[ v[ i ].id() ] = true;

          connectedNodes.push( v[ i ] );
        }

        id2depth[ v[ i ].id() ] = 0;
      }
    }

    while( Q.length !== 0 ){
      var v = params.bfs ? Q.shift() : Q.pop();

      if( params.dfs ){
        if( V[ v.id() ] ){ continue; }

        V[ v.id() ] = true;

        connectedNodes.push( v );
      }

      var depth = id2depth[ v.id() ];
      var prevEdge = connectedBy[ v.id() ];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
      var ret;

      if( std ){
        ret = fn.call( thisArg, v, prevEdge, prevNode, j++, depth );
      } else {
        ret = fn.call( v, j++, depth, v, prevEdge, prevNode );
      }

      if( ret === true ){
        found = v;
        break;
      }

      if( ret === false ){
        break;
      }

      var vwEdges = v.connectedEdges( directed ? function(){ return this.data( 'source' ) === v.id(); } : undefined ).intersect( edges );
      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[ i ];
        var w = e.connectedNodes( function(){ return this.id() !== v.id(); } ).intersect( nodes );

        if( w.length !== 0 && !V[ w.id() ] ){
          w = w[0];

          Q.push( w );

          if( params.bfs ){
            V[ w.id() ] = true;

            connectedNodes.push( w );
          }

          connectedBy[ w.id() ] = e;

          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
        }
      }

    }

    var connectedEles = [];

    for( var i = 0; i < connectedNodes.length; i++ ){
      var node = connectedNodes[ i ];
      var edge = connectedBy[ node.id() ];

      if( edge ){
        connectedEles.push( edge );
      }

      connectedEles.push( node );
    }

    return {
      path: cy.collection( connectedEles, { unique: true } ),
      found: cy.collection( found )
    };
  };
};

// search, spanning trees, etc
var elesfn = ({
  breadthFirstSearch: defineSearch( { bfs: true } ),
  depthFirstSearch: defineSearch( { dfs: true } )
});

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

},{"../../is":86}],10:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  closenessCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall( { weight: options.weight, directed: options.directed } );

    // Compute closeness for every node and find the maximum closeness
    for( var i = 0; i < nodes.length; i++ ){
      var currCloseness = 0;
      for( var j = 0; j < nodes.length; j++ ){
        if( i != j ){
          var d = fw.distance( nodes[ i ], nodes[ j ] );

          if( harmonic ){
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if( !harmonic ){
        currCloseness = 1 / currCloseness;
      }

      if( maxCloseness < currCloseness ){
        maxCloseness = currCloseness;
      }

      closenesses[ nodes[ i ].id() ] = currCloseness;
    }

    return {
      closeness: function( node ){
        if( maxCloseness == 0 ){ return 0; }

        if( is.string( node ) ){
          // from is a selector string
          var node = (cy.filter( node )[0]).id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[ node ] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function( options ){
    options = options || {};

    // root - mandatory!
    if( options.root != null ){
      if( is.string( options.root ) ){
        // use it as a selector, e.g. "#rootID
        var root = this.filter( options.root )[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weight = options.weight;
    } else {
      var weight = function(){return 1;};
    }

    // directed - optional
    if( options.directed != null && is.bool( options.directed ) ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra( {
      root: root,
      weight: weight,
      directed: directed
    } );
    var totalDistance = 0;

    var nodes = this.nodes();
    for( var i = 0; i < nodes.length; i++ ){
      if( nodes[ i ].id() != root.id() ){
        var d = dijkstra.distanceTo( nodes[ i ] );

        if( harmonic ){
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

},{"../../is":86}],11:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var util = require( '../../util' );

var elesfn = ({

  degreeCentralityNormalized: function( options ){
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if( !directed ){
      var degrees = {};
      var maxDegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );
        if( maxDegree < currDegree.degree )
          maxDegree = currDegree.degree;

        degrees[ node.id() ] = currDegree.degree;
      }

      return {
        degree: function( node ){
          if( maxDegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[ node ] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for( var i = 0; i < numNodes; i++ ){
        var node = nodes[ i ];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );

        if( maxIndegree < currDegree.indegree )
          maxIndegree = currDegree.indegree;

        if( maxOutdegree < currDegree.outdegree )
          maxOutdegree = currDegree.outdegree;

        indegrees[ node.id() ] = currDegree.indegree;
        outdegrees[ node.id() ] = currDegree.outdegree;
      }

      return {
        indegree: function( node ){
          if ( maxIndegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[ node ] / maxIndegree;
        },
        outdegree: function( node ){
          if ( maxOutdegree == 0 )
            return 0;

          if( is.string( node ) ){
            // from is a selector string
            var node = (cy.filter( node )[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[ node ] / maxOutdegree;
        }

      };
    }

  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function( options ){
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if( options != null && options.root != null ){
      var root = is.string( options.root ) ? this.filter( options.root )[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){
        return 1;
      };
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if( options.alpha != null && is.number( options.alpha ) ){
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }


    if( !directed ){
      var connEdges = root.connectedEdges().intersection( callingEles );
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for( var i = 0; i < connEdges.length; i++ ){
        var edge = connEdges[ i ];
        s += weightFn.apply( edge, [ edge ] );
      }

      return {
        degree: Math.pow( k, 1 - alpha ) * Math.pow( s, alpha )
      };
    } else {
      var incoming = root.connectedEdges( 'edge[target = "' + root.id() + '"]' ).intersection( callingEles );
      var outgoing = root.connectedEdges( 'edge[source = "' + root.id() + '"]' ).intersection( callingEles );
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for( var i = 0; i < incoming.length; i++ ){
        var edge = incoming[ i ];
        s_in += weightFn.apply( edge, [ edge ] );
      }

      // Now, sum outgoing edge weights
      for( var i = 0; i < outgoing.length; i++ ){
        var edge = outgoing[ i ];
        s_out += weightFn.apply( edge, [ edge ] );
      }

      return {
        indegree: Math.pow( k_in, 1 - alpha ) * Math.pow( s_in, alpha ),
        outdegree: Math.pow( k_out, 1 - alpha ) * Math.pow( s_out, alpha )
      };
    }
  } // degreeCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

},{"../../is":86,"../../util":103}],12:[function(require,module,exports){
'use strict';

var is = require( '../../is' );
var Heap = require( '../../heap' );

var elesfn = ({

  dijkstra: function( root, weightFn, directed ){
    var options;
    if( is.plainObject( root ) && !is.elementOrCollection( root ) ){
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    var source = is.string( root ) ? this.filter( root )[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter( function(){ return !this.isLoop(); } );
    var nodes = this.nodes();

    var getDist = function( node ){
      return dist[ node.id() ];
    };

    var setDist = function( node, d ){
      dist[ node.id() ] = d;

      Q.updateItem( node );
    };

    var Q = new Heap( function( a, b ){
      return getDist( a ) - getDist( b );
    } );

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];

      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
      Q.push( node );
    }

    var distBetween = function( u, v ){
      var uvs = ( directed ? u.edgesTo( v ) : u.edgesWith( v ) ).intersect( edges );
      var smallestDistance = Infinity;
      var smallestEdge;

      for( var i = 0; i < uvs.length; i++ ){
        var edge = uvs[ i ];
        var weight = weightFn.apply( edge, [ edge ] );

        if( weight < smallestDistance || !smallestEdge ){
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while( Q.size() > 0 ){
      var u = Q.pop();
      var smalletsDist = getDist( u );
      var uid = u.id();

      knownDist[ uid ] = smalletsDist;

      if( smalletsDist === Math.Infinite ){
        break;
      }

      var neighbors = u.neighborhood().intersect( nodes );
      for( var i = 0; i < neighbors.length; i++ ){
        var v = neighbors[ i ];
        var vid = v.id();
        var vDist = distBetween( u, v );

        var alt = smalletsDist + vDist.dist;

        if( alt < getDist( v ) ){
          setDist( v, alt );

          prev[ vid ] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];

        return knownDist[ target.id() ];
      },

      pathTo: function( node ){
        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];
        var S = [];
        var u = target;

        if( target.length > 0 ){
          S.unshift( target );

          while( prev[ u.id() ] ){
            var p = prev[ u.id() ];

            S.unshift( p.edge );
            S.unshift( p.node );

            u = p.node;
          }
        }

        return cy.collection( S );
      }
    };
  }
});

module.exports = elesfn;

},{"../../heap":84,"../../is":86}],13:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  floydWarshall: function( options ){
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if( options.weight != null && is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    // directed - optional
    if( options.directed != null ){
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for( var i = 0; i < numNodes; i++ ){
      var newRow = new Array( numNodes );
      for( var j = 0; j < numNodes; j++ ){
        if( i == j ){
          newRow[ j ] = 0;
        } else {
          newRow[ j ] = Infinity;
        }
      }
      dist.push( newRow );
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function( next ){
      for( var i = 0; i < numNodes; i++ ){
        var newRow = new Array( numNodes );
        for( var j = 0; j < numNodes; j++ ){
          newRow[ j ] = undefined;
        }
        next.push( newRow );
      }
    };

    initMatrix( next );
    initMatrix( edgeNext );

    // Process edges
    for( var i = 0; i < edges.length ; i++ ){
      var sourceIndex = id2position[ edges[ i ].source().id() ];
      var targetIndex = id2position[ edges[ i ].target().id() ];
      var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );

      // Check if already process another edge between same 2 nodes
      if( dist[ sourceIndex ][ targetIndex ] > weight ){
        dist[ sourceIndex ][ targetIndex ] = weight;
        next[ sourceIndex ][ targetIndex ] = targetIndex;
        edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
      }
    }

    // If undirected graph, process 'reversed' edges
    if( !directed ){
      for( var i = 0; i < edges.length ; i++ ){
        var sourceIndex = id2position[ edges[ i ].target().id() ];
        var targetIndex = id2position[ edges[ i ].source().id() ];
        var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );

        // Check if already process another edge between same 2 nodes
        if( dist[ sourceIndex ][ targetIndex ] > weight ){
          dist[ sourceIndex ][ targetIndex ] = weight;
          next[ sourceIndex ][ targetIndex ] = targetIndex;
          edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];
        }
      }
    }

    // Main loop
    for( var k = 0; k < numNodes; k++ ){
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] ){
            dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];
            next[ i ][ j ] = next[ i ][ k ];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for( var i = 0; i < numNodes; i++ ){
      position2id.push( nodes[ i ].id() );
    }

    var res = {
      distance: function( from, to ){
        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[ id2position[ fromId ] ][ id2position[ toId ] ];
      },

      path: function( from, to ){
        var reconstructPathAux = function( from, to, next, position2id, edgeNext ){
          if( from === to ){
            return cy.getElementById( position2id[ from ] );
          }
          if( next[ from ][ to ] === undefined ){
            return undefined;
          }

          var path = [ cy.getElementById( position2id[ from ] ) ];
          var prev = from;
          while( from !== to ){
            prev = from;
            from = next[ from ][ to ];

            var edge = edgeNext[ prev ][ from ];
            path.push( edge );

            path.push( cy.getElementById( position2id[ from ] ) );
          }
          return path;
        };

        if( is.string( from ) ){
          // from is a selector string
          var fromId = (cy.filter( from )[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if( is.string( to ) ){
          // to is a selector string
          var toId = (cy.filter( to )[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux( id2position[ fromId ],
                      id2position[ toId ],
                      next,
                      position2id,
                      edgeNext );

        return cy.collection( pathArr );
      }
    };

    return res;

  } // floydWarshall

}); // elesfn

module.exports = elesfn;

},{"../../is":86}],14:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

var elesfn = {};

[
  require( './bfs-dfs' ),
  require( './dijkstra' ),
  require( './kruskal' ),
  require( './a-star' ),
  require( './floyd-warshall' ),
  require( './bellman-ford' ),
  require( './kerger-stein' ),
  require( './page-rank' ),
  require( './degree-centrality' ),
  require( './closeness-centrality' ),
  require( './betweenness-centrality' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = elesfn;

},{"../../util":103,"./a-star":6,"./bellman-ford":7,"./betweenness-centrality":8,"./bfs-dfs":9,"./closeness-centrality":10,"./degree-centrality":11,"./dijkstra":12,"./floyd-warshall":13,"./kerger-stein":15,"./kruskal":16,"./page-rank":17}],15:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

var elesfn = ({

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function( options ){
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function( edgeIndex, nodeMap, remainingEdges ){
      var edgeInfo = remainingEdges[ edgeIndex ];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[ sourceIn ];
      var partition2 = nodeMap[ targetIn ];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter( function( edge ){
        if( nodeMap[ edge[1] ] === partition1 && nodeMap[ edge[2] ] === partition2 ){
          return false;
        }
        if( nodeMap[ edge[1] ] === partition2 && nodeMap[ edge[2] ] === partition1 ){
          return false;
        }
        return true;
      } );

      // All edges pointing to partition2 should now point to partition1
      for( var i = 0; i < newEdges.length; i++ ){
        var edge = newEdges[ i ];
        if( edge[1] === partition2 ){ // Check source
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][1] = partition1;
        } else if( edge[2] === partition2 ){ // Check target
          newEdges[ i ] = edge.slice( 0 );
          newEdges[ i ][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for( var i = 0; i < nodeMap.length; i++ ){
        if( nodeMap[ i ] === partition2 ){
          nodeMap[ i ] = partition1;
        }
      }

      return newEdges;
    };


    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function( metaNodeMap,
                   remainingEdges,
                   size,
                   sizeLimit ){
      // Stop condition
      if( size <= sizeLimit ){
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor( (Math.random() * remainingEdges.length) );

      // Colapse graph based on edge
      var newEdges = colapse( edgeIndex, metaNodeMap, remainingEdges );

      return contractUntil( metaNodeMap,
                 newEdges,
                 size - 1,
                 sizeLimit );
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil( Math.pow( Math.log( numNodes ) / Math.LN2, 2 ) );
    var stopSize = Math.floor( numNodes / Math.sqrt( 2 ) );

    if( numNodes < 2 ){
      util.error( 'At least 2 nodes are required for Karger-Stein algorithm' );
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for( var i = 0; i < numEdges; i++ ){
      var e = edges[ i ];
      edgeIndexes.push( [ i, id2position[ e.source().id() ], id2position[ e.target().id() ] ] );
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for( var i = 0; i < numNodes; i++ ){
      originalMetaNode.push( i );
    }

    // Main loop
    for( var iter = 0; iter <= numIter; iter++ ){
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice( 0 );

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil( metaNodeMap, edgeIndexes, numNodes, stopSize );

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice( 0 );

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil( metaNodeMap, edgesState, stopSize, 2 );
      var res2 = contractUntil( metaNodeMap2, edgesState, stopSize, 2 );

      // Is any of the 2 results the best cut so far?
      if( res1.length <= res2.length && res1.length < minCutSize ){
        minCutSize = res1.length;
        minCut = [ res1, metaNodeMap ];
      } else if( res2.length <= res1.length && res2.length < minCutSize ){
        minCutSize = res2.length;
        minCut = [ res2, metaNodeMap2 ];
      }
    } // end of main loop


    // Construct result
    var resEdges = (minCut[0]).map( function( e ){ return edges[ e[0] ]; } );
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for( var i = 0; i < minCut[1].length; i++ ){
      var partitionId = minCut[1][ i ];
      if( partitionId === witnessNodePartition ){
        partition1.push( nodes[ i ] );
      } else {
        partition2.push( nodes[ i ] );
      }
    }

    var ret = {
      cut: eles.spawn( cy, resEdges ),
      partition1: eles.spawn( partition1 ),
      partition2: eles.spawn( partition2 )
    };

    return ret;
  }
}); // elesfn


module.exports = elesfn;

},{"../../util":103}],16:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

// search, spanning trees, etc
var elesfn = ({

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function( weightFn ){
    var cy = this.cy();

    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    function findSet( ele ){
      for( var i = 0; i < forest.length; i++ ){
        var eles = forest[ i ];

        if( eles.anySame( ele ) ){
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection( cy, [] );
    var forest = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      forest.push( nodes[ i ].collection() );
    }

    var edges = this.edges();
    var S = edges.toArray().sort( function( a, b ){
      var weightA = weightFn.call( a, a );
      var weightB = weightFn.call( b, b );

      return weightA - weightB;
    } );

    for( var i = 0; i < S.length; i++ ){
      var edge = S[ i ];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet( u );
      var setV = findSet( v );

      if( setU.index !== setV.index ){
        A = A.add( edge );

        // combine forests for u and v
        forest[ setU.index ] = setU.eles.add( setV.eles );
        forest.splice( setV.index, 1 );
      }
    }

    return nodes.add( A );
  }
});

module.exports = elesfn;

},{"../../is":86}],17:[function(require,module,exports){
'use strict';

var is = require( '../../is' );

var elesfn = ({

  pageRank: function( options ){
    options = options || {};

    var normalizeVector = function( vector ){
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for( var i = 0; i < length; i++ ){
        total += vector[ i ];
      }

      // Now, divide each by the sum of all elements
      for( var i = 0; i < length; i++ ){
        vector[ i ] = vector[ i ] / total;
      }
    };

    // dampingFactor - optional
    if( options != null &&
      options.dampingFactor != null ){
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if( options != null &&
      options.precision != null ){
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if( options != null &&
      options.iterations != null ){
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if( options != null &&
      options.weight != null &&
      is.fn( options.weight ) ){
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function( e ){return 1;};
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for( var i = 0; i < numNodes; i++ ){
      id2position[ nodes[ i ].id() ] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for( var i = 0; i < numNodes; i++ ){
      var newRow = [];
      for( var j = 0; j < numNodes; j++ ){
        newRow.push( 0.0 );
      }
      matrix.push( newRow );
      columnSum.push( 0.0 );
    }

    // Now, process edges
    for( var i = 0; i < numEdges; i++ ){
      var edge = edges[ i ];
      var s = id2position[ edge.source().id() ];
      var t = id2position[ edge.target().id() ];
      var w = weightFn.apply( edge, [ edge ] );

      // Update matrix
      matrix[ t ][ s ] += w;

      // Update column sum
      columnSum[ s ] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for( var j = 0; j < numNodes; j++ ){
      if( columnSum[ j ] === 0 ){
        // No 'links' out from node jth, assume equal probability for each possible node
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for( var i = 0; i < numNodes; i++ ){
          matrix[ i ][ j ] = matrix[ i ][ j ] / columnSum[ j ] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for( var i = 0; i < numNodes; i++ ){
      eigenvector.push( 1.0 );
      nullVector.push( 0.0 );
    }

    for( var iter = 0; iter < numIter; iter++ ){
      // New array with all 0's
      var temp = nullVector.slice( 0 );

      // Multiply matrix with previous result
      for( var i = 0; i < numNodes; i++ ){
        for( var j = 0; j < numNodes; j++ ){
          temp[ i ] += matrix[ i ][ j ] * eigenvector[ j ];
        }
      }

      normalizeVector( temp );
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for( var i = 0; i < numNodes; i++ ){
        diff += Math.pow( previous[ i ] - eigenvector[ i ], 2 );
      }

      // If difference is less than the desired threshold, stop iterating
      if( diff < epsilon ){
        break;
      }
    }

    // Construct result
    var res = {
      rank: function( node ){
        if( is.string( node ) ){
          // is a selector string
          var nodeId = (cy.filter( node )[0]).id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[ id2position[ nodeId ] ];
      }
    };


    return res;
  } // pageRank

}); // elesfn

module.exports = elesfn;

},{"../../is":86}],18:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var elesfn = ({
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
});

module.exports = elesfn;

},{"../define":47}],19:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var elesfn = ({
  classes: function( classes ){
    classes = ( classes || '' ).match( /\S+/g ) || [];
    var self = this;
    var changed = [];
    var classesMap = {};

    // fill in classes map
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[ i ];

      classesMap[ cls ] = true;
    }

    // check and update each ele
    for( var j = 0; j < self.length; j++ ){
      var ele = self[ j ];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[ i ];
        var eleHasClass = eleClasses[ cls ];

        if( !eleHasClass ){
          changedEle = true;
          break;
        }
      }

      // check if ele has classes outside of those passed
      if( !changedEle ){
        var classes = Object.keys( eleClasses );

        for( var i = 0; i < classes.length; i++ ){
          var eleCls = classes[i];
          var eleHasClass = eleClasses[ eleCls ];
          var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function

          if( eleHasClass && !specdClass ){
            changedEle = true;
            break;
          }
        }
      }

      if( changedEle ){
        _p.classes = util.copy( classesMap );

        changed.push( ele );
      }
    }

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  addClass: function( classes ){
    return this.toggleClass( classes, true );
  },

  hasClass: function( className ){
    var ele = this[0];
    return ( ele != null && ele._private.classes[ className ] ) ? true : false;
  },

  toggleClass: function( classesStr, toggle ){
    var classes = classesStr.match( /\S+/g ) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for( var i = 0, il = self.length; i < il; i++ ){
      var ele = self[ i ];
      var changedEle = false;

      for( var j = 0; j < classes.length; j++ ){
        var cls = classes[ j ];
        var eleClasses = ele._private.classes;
        var hasClass = eleClasses[ cls ];
        var shouldAdd = toggle || (toggle === undefined && !hasClass);

        if( shouldAdd ){
          eleClasses[ cls ] = true;

          if( !hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        } else { // then remove
          eleClasses[ cls ] = false;

          if( hasClass && !changedEle ){
            changed.push( ele );
            changedEle = true;
          }
        }

      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn( changed )
        .updateStyle()
        .trigger( 'class' )
      ;
    }

    return self;
  },

  removeClass: function( classes ){
    return this.toggleClass( classes, false );
  },

  flashClass: function( classes, duration ){
    var self = this;

    if( duration == null ){
      duration = 250;
    } else if( duration === 0 ){
      return self; // nothing to do really
    }

    self.addClass( classes );
    setTimeout( function(){
      self.removeClass( classes );
    }, duration );

    return self;
  }
});

module.exports = elesfn;

},{"../util":103}],20:[function(require,module,exports){
'use strict';

var elesfn = ({
  allAre: function( selector ){
    return this.filter( selector ).length === this.length;
  },

  is: function( selector ){
    return this.filter( selector ).length > 0;
  },

  some: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( ret ){
        return true;
      }
    }

    return false;
  },

  every: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );

      if( !ret ){
        return false;
      }
    }

    return true;
  },

  same: function( collection ){
    collection = this.cy().collection( collection );

    // cheap extra check
    if( this.length !== collection.length ){
      return false;
    }

    return this.intersect( collection ).length === this.length;
  },

  anySame: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length > 0;
  },

  allAreNeighbors: function( collection ){
    collection = this.cy().collection( collection );

    return this.neighborhood().intersect( collection ).length === collection.length;
  },

  contains: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length === collection.length;
  }
});

elesfn.allAreNeighbours = elesfn.allAreNeighbors;
elesfn.has = elesfn.contains;

module.exports = elesfn;

},{}],21:[function(require,module,exports){
'use strict';

var elesfn = ({
  parent: function( selector ){
    var parents = [];
    var cy = this._private.cy;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parent = cy.getElementById( ele._private.data.parent );

      if( parent.size() > 0 ){
        parents.push( parent );
      }
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  parents: function( selector ){
    var parents = [];

    var eles = this.parent();
    while( eles.nonempty() ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];
        parents.push( ele );
      }

      eles = eles.parent();
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  commonAncestors: function( selector ){
    var ancestors;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
    }

    return ancestors.filter( selector );
  },

  orphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isNode() && ele.parent().empty();
    } ).filter( selector );
  },

  nonorphans: function( selector ){
    return this.stdFilter( function( ele ){
      return ele.isNode() && ele.parent().nonempty();
    } ).filter( selector );
  },

  children: function( selector ){
    var children = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      children = children.concat( ele._private.children );
    }

    return this.spawn( children, { unique: true } ).filter( selector );
  },

  siblings: function( selector ){
    return this.parent().children().not( this ).filter( selector );
  },

  isParent: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.children.length !== 0;
    }
  },

  isChild: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.parent !== undefined && ele.parent().length !== 0;
    }
  },

  descendants: function( selector ){
    var elements = [];

    function add( eles ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        elements.push( ele );

        if( ele.children().nonempty() ){
          add( ele.children() );
        }
      }
    }

    add( this.children() );

    return this.spawn( elements, { unique: true } ).filter( selector );
  }
});

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

},{}],22:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var fn, elesfn;

fn = elesfn = ({

  data: define.data( {
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  removeData: define.removeData( {
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  } ),

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  } ),

  rscratch: define.data( {
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  } ),

  removeRscratch: define.removeData( {
    field: 'rscratch',
    triggerEvent: false
  } ),

  id: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.id;
    }
  }

});

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

},{"../define":47}],23:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var elesfn = {};

function defineDegreeFunction( callback ){
  return function( includeLoops ){
    var self = this;

    if( includeLoops === undefined ){
      includeLoops = true;
    }

    if( self.length === 0 ){ return; }

    if( self.isNode() && !self.removed() ){
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for( var i = 0; i < connectedEdges.length; i++ ){
        var edge = connectedEdges[ i ];

        if( !includeLoops && edge.isLoop() ){
          continue;
        }

        degree += callback( node, edge );
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend( elesfn, {
  degree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( edge.target() ) ){
      return 2;
    } else {
      return 1;
    }
  } ),

  indegree: defineDegreeFunction( function( node, edge ){
    if( edge.target().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } ),

  outdegree: defineDegreeFunction( function( node, edge ){
    if( edge.source().same( node ) ){
      return 1;
    } else {
      return 0;
    }
  } )
} );

function defineDegreeBoundsFunction( degreeFn, callback ){
  return function( includeLoops ){
    var ret;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[ i ];
      var degree = ele[ degreeFn ]( includeLoops );
      if( degree !== undefined && (ret === undefined || callback( degree, ret )) ){
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend( elesfn, {
  minDegree: defineDegreeBoundsFunction( 'degree', function( degree, min ){
    return degree < min;
  } ),

  maxDegree: defineDegreeBoundsFunction( 'degree', function( degree, max ){
    return degree > max;
  } ),

  minIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, min ){
    return degree < min;
  } ),

  maxIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, max ){
    return degree > max;
  } ),

  minOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, min ){
    return degree < min;
  } ),

  maxOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, max ){
    return degree > max;
  } )
} );

util.extend( elesfn, {
  totalDegree: function( includeLoops ){
    var total = 0;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      total += nodes[ i ].degree( includeLoops );
    }

    return total;
  }
} );

module.exports = elesfn;

},{"../util":103}],24:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var is = require( '../is' );
var util = require( '../util' );
var math = require( '../math' );
var fn, elesfn;

fn = elesfn = ({

  position: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'rtrigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      var updatedEles = eles.updateCompoundBounds();
      updatedEles.rtrigger( 'position' );
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  // position but no notification to renderer
  silentPosition: define.data( {
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: true,
    validKeys: [ 'x', 'y' ],
    onSet: function( eles ){
      eles.updateCompoundBounds();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  } ),

  positions: function( pos, silent ){
    if( is.plainObject( pos ) ){
      this.position( pos );

    } else if( is.fn( pos ) ){
      var fn = pos;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];

        var pos = fn.apply( ele, [ i, ele ] );

        if( pos && !ele.locked() && !ele.isParent() ){
          var elePos = ele._private.position;
          elePos.x = pos.x;
          elePos.y = pos.y;
        }
      }

      var updatedEles = this.updateCompoundBounds();
      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

      if( silent ){
        toTrigger.trigger( 'position' );
      } else {
        toTrigger.rtrigger( 'position' );
      }
    }

    return this; // chaining
  },

  silentPositions: function( pos ){
    return this.positions( pos, true );
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject( dim ) ? dim : undefined;
    var setting = rpos !== undefined || ( val !== undefined && is.string( dim ) );

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = ( val - pan[ dim ] ) / zoom;
          } else if( rpos !== undefined ){ // set whole position
            ele._private.position = {
              x: ( rpos.x - pan.x ) / zoom,
              y: ( rpos.y - pan.y ) / zoom
            };
          }
        }

        this.rtrigger( 'position' );
      } else { // getting
        var pos = ele._private.position;
        rpos = {
          x: pos.x * zoom + pan.x,
          y: pos.y * zoom + pan.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return rpos;
        } else { // then return the specified dimension
          return rpos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject( dim ) ? dim : undefined;
    var setting = ppos !== undefined || ( val !== undefined && is.string( dim ) );
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[ i ];
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          if( val !== undefined ){ // set one dimension
            ele._private.position[ dim ] = val + origin[ dim ];
          } else if( ppos !== undefined ){ // set whole position
            ele._private.position = {
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            };
          }
        }

        this.rtrigger( 'position' );

      } else { // getting
        var pos = ele._private.position;
        var parent = hasCompoundNodes ? ele.parent() : null;
        var hasParent = parent && parent.length > 0;
        var relativeToParent = hasParent;

        if( hasParent ){
          parent = parent[0];
        }

        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

        ppos = {
          x: pos.x - origin.x,
          y: pos.y - origin.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return ppos;
        } else { // then return the specified dimension
          return ppos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  renderedBoundingBox: function( options ){
    var bb = this.boundingBox( options );
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();

    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  },

  updateCompoundBounds: function(){
    var cy = this.cy();

    // save cycles for non compound graphs or when style disabled
    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); }

    var updated = [];

    function update( parent ){
      if( !parent.isParent() ){ return; }

      var _p = parent._private;
      var children = parent.children();
      var includeLabels = parent.pstyle( 'compound-sizing-wrt-labels' ).value === 'include';

      var min = {
        width: {
          val: parent.pstyle( 'min-width' ).pfValue,
          left: parent.pstyle( 'min-width-bias-left' ),
          right: parent.pstyle( 'min-width-bias-right' )
        },
        height: {
          val: parent.pstyle( 'min-height' ).pfValue,
          top: parent.pstyle( 'min-height-bias-top' ),
          bottom: parent.pstyle( 'min-height-bias-bottom' )
        }
      };

      var bb = children.boundingBox( {
        includeLabels: includeLabels,
        includeShadows: false,
        includeOverlays: false,

        // updating the compound bounds happens outside of the regular
        // cache cycle (i.e. before fired events)
        useCache: false
      } );
      var pos = _p.position;

      function computeBiasValues( propDiff, propBias, propBiasComplement ){
        var biasDiff = 0;
        var biasComplementDiff = 0;
        var biasTotal = propBias + propBiasComplement;

        if( propDiff > 0 && biasTotal > 0 ){
          biasDiff = ( propBias / biasTotal ) * propDiff;
          biasComplementDiff = ( propBiasComplement / biasTotal ) * propDiff;
        }
        return {
          biasDiff: biasDiff,
          biasComplementDiff: biasComplementDiff
        };
      }

      var leftVal = min.width.left.value;
      if( min.width.left.units === 'px' && min.width.val > 0 ){
        leftVal = ( leftVal * 100 ) / min.width.val;
      }
      var rightVal = min.width.right.value;
      if( min.width.right.units === 'px' && min.width.val > 0 ){
        rightVal = ( rightVal * 100 ) / min.width.val;
      }

      var topVal = min.height.top.value;
      if( min.height.top.units === 'px' && min.height.val > 0 ){
        topVal = ( topVal * 100 ) / min.height.val;
      }

      var bottomVal = min.height.bottom.value;
      if( min.height.bottom.units === 'px' && min.height.val > 0 ){
        bottomVal = ( bottomVal * 100 ) / min.height.val;
      }

      var widthBiasDiffs = computeBiasValues( min.width.val - bb.w, leftVal, rightVal );
      var diffLeft = widthBiasDiffs.biasDiff;
      var diffRight = widthBiasDiffs.biasComplementDiff;

      var heightBiasDiffs = computeBiasValues( min.height.val - bb.h, topVal, bottomVal );
      var diffTop = heightBiasDiffs.biasDiff;
      var diffBottom = heightBiasDiffs.biasComplementDiff;

      _p.autoWidth = Math.max(bb.w, min.width.val);
      pos.x = (- diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

      _p.autoHeight = Math.max(bb.h, min.height.val);
      pos.y = (- diffBottom + bb.y1 + bb.y2 + diffTop) / 2;

      updated.push( parent );
    }

    // go up, level by level
    var eles = this;
    while( eles.nonempty() ){

      // update each parent node in this level
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        update( ele );
      }

      // next level
      eles = eles.parent();
    }

    // return changed
    return this.spawn( updated );
  }
});

var noninf = function( x ){
  if( x === Infinity || x === -Infinity ){
    return 0;
  }

  return x;
};

var updateBounds = function( b, x1, y1, x2, y2 ){
  // don't update with zero area boxes
  if( x2 - x1 === 0 || y2 - y1 === 0 ){ return; }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
};

var updateBoundsFromBox = function( b, b2 ){
  return updateBounds( b, b2.x1, b2.y1, b2.x2, b2.y2 );
};

var prefixedProperty = function( obj, field, prefix ){
  return util.getPrefixedProperty( obj, field, prefix );
};

var updateBoundsFromArrow = function( bounds, ele, prefix, options ){
  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle( prefix + '-arrow-shape' ).value;
  var x;
  var y;

  if( arrowType !== 'none' ){
    if( prefix === 'source' ){
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if( prefix === 'target' ){
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    }

    updateBounds( bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW );
  }
};

var updateBoundsFromLabel = function( bounds, ele, prefix, options ){
  var prefixDash;

  if( prefix ){
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle( prefixDash + 'label' ).strValue;

  if( label ){
    var halign = ele.pstyle( 'text-halign' );
    var valign = ele.pstyle( 'text-valign' );
    var labelWidth = prefixedProperty( rstyle, 'labelWidth', prefix );
    var labelHeight = prefixedProperty( rstyle, 'labelHeight', prefix );
    var labelX = prefixedProperty( rstyle, 'labelX', prefix );
    var labelY = prefixedProperty( rstyle, 'labelY', prefix );
    var marginX = ele.pstyle( prefixDash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( prefixDash + 'text-margin-y' ).pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle( prefixDash + 'text-rotation' );
    var shadowR = ele.pstyle( 'text-shadow-blur' ).pfValue / 2;
    var shadowX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;
    var shadowY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;
    var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;
    var outlineWidth = ele.pstyle( 'text-outline-width' ).pfValue;
    var borderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle( 'text-background-padding' ).pfValue;

    var lh = labelHeight + 2 * padding;
    var lw = labelWidth + 2 * padding;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if( isEdge ){
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch( halign.value ){
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch( valign.value ){
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }

    var isAutorotate = ( isEdge && rotation.strValue === 'autorotate' );
    var isPfValue = ( rotation.pfValue != null && rotation.pfValue !== 0 );

    if( isAutorotate || isPfValue ){
      var theta = isAutorotate ? prefixedProperty( _p.rstyle, 'labelAngle', prefix ) : rotation.pfValue;
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - labelX;
        y = y - labelY;

        return {
          x: x * cos - y * sin + labelX,
          y: x * sin + y * cos + labelY
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
      ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
      ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
    }

    lx1 += marginX - Math.max( outlineWidth, halfBorderWidth );
    lx2 += marginX + Math.max( outlineWidth, halfBorderWidth );
    ly1 += marginY - Math.max( outlineWidth, halfBorderWidth );
    ly2 += marginY + Math.max( outlineWidth, halfBorderWidth );

    updateBounds( bounds, lx1, ly1, lx2, ly2 );

    if( options.includeShadows && shadowOpacity > 0 ){
      lx1 += - shadowR + shadowX;
      lx2 += + shadowR + shadowX;
      ly1 += - shadowR + shadowY;
      ly2 += + shadowR + shadowY;

      updateBounds( bounds, lx1, ly1, lx2, ly2 );
    }
  }

  return bounds;
};

// get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function( ele, options ){
  var cy = ele._private.cy;
  var cy_p = cy._private;
  var styleEnabled = cy_p.styleEnabled;

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  var _p = ele._private;
  var display = styleEnabled ? ele.pstyle( 'display' ).value : 'element';
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2, x, y;
  var displayed = display !== 'none';

  if( displayed ){
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if( styleEnabled && options.includeOverlays ){
      overlayOpacity = ele.pstyle( 'overlay-opacity' ).value;

      if( overlayOpacity !== 0 ){
        overlayPadding = ele.pstyle( 'overlay-padding' ).value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if( styleEnabled ){
      w = ele.pstyle( 'width' ).pfValue;
      wHalf = w / 2;
    }

    if( isNode && options.includeNodes ){
      var pos = _p.position;
      x = pos.x;
      y = pos.y;
      var w = ele.outerWidth();
      var halfW = w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;

      // handle node dimensions
      /////////////////////////

      ex1 = x - halfW - overlayPadding;
      ex2 = x + halfW + overlayPadding;
      ey1 = y - halfH - overlayPadding;
      ey2 = y + halfH + overlayPadding;

      updateBounds( bounds, ex1, ey1, ex2, ey2 );

    } else if( isEdge && options.includeEdges ){
      var rstyle = _p.rstyle || {};

      // handle edge dimensions (rough box estimate)
      //////////////////////////////////////////////
      if( styleEnabled ){
        ex1 = Math.min( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ex2 = Math.max( rstyle.srcX, rstyle.midX, rstyle.tgtX );
        ey1 = Math.min( rstyle.srcY, rstyle.midY, rstyle.tgtY );
        ey2 = Math.max( rstyle.srcY, rstyle.midY, rstyle.tgtY );

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        updateBounds( bounds, ex1, ey1, ex2, ey2 );
      }

      // precise haystacks
      ////////////////////
      if( styleEnabled && ele.pstyle( 'curve-style' ).strValue === 'haystack' ){
        var hpts = rstyle.haystackPts;

        ex1 = hpts[0].x;
        ey1 = hpts[0].y;
        ex2 = hpts[1].x;
        ey2 = hpts[1].y;

        if( ex1 > ex2 ){
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if( ey1 > ey2 ){
          var temp = ey1;
          ey1 = ey2;
          ey2 = temp;
        }

        updateBounds( bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf );

      // handle points along edge
      ///////////////////////////
      } else {
        var pts = rstyle.bezierPts || rstyle.linePts || [];

        for( var j = 0; j < pts.length; j++ ){
          var pt = pts[ j ];

          ex1 = pt.x - wHalf;
          ex2 = pt.x + wHalf;
          ey1 = pt.y - wHalf;
          ey2 = pt.y + wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }

        // fallback on source and target positions
        //////////////////////////////////////////
        if( pts.length === 0 ){
          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;

          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          // take into account edge width
          ex1 -= wHalf;
          ex2 += wHalf;
          ey1 -= wHalf;
          ey2 += wHalf;

          updateBounds( bounds, ex1, ey1, ex2, ey2 );
        }
      }

    } // edges

    // shadow and overlay
    /////////////////////

    if( styleEnabled ){

      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;

      if( options.includeShadows && ele.pstyle('shadow-opacity').value > 0 ){
        var r = ele.pstyle('shadow-blur').pfValue / 2;
        var ox = ele.pstyle('shadow-offset-x').pfValue;
        var oy = ele.pstyle('shadow-offset-y').pfValue;

        updateBounds( bounds, ex1 - r + ox, ey1 - r + oy, ex2 + r + ox, ey2 + r + oy );
      }

      updateBounds( bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding );
    }

    // handle edge arrow size
    /////////////////////////

    if( styleEnabled && options.includeEdges && isEdge ){
      updateBoundsFromArrow( bounds, ele, 'mid-source', options );
      updateBoundsFromArrow( bounds, ele, 'mid-target', options );
      updateBoundsFromArrow( bounds, ele, 'source', options );
      updateBoundsFromArrow( bounds, ele, 'target', options );
    }

    // handle label dimensions
    //////////////////////////

    if( styleEnabled && options.includeLabels ){
      updateBoundsFromLabel( bounds, ele, null, options );

      if( isEdge ){
        updateBoundsFromLabel( bounds, ele, 'source', options );
        updateBoundsFromLabel( bounds, ele, 'target', options );
      }
    } // style enabled for labels
  } // if displayed

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  if( bounds.w > 0 && bounds.h > 0 && displayed ){
    math.expandBoundingBox( bounds, 1 );
  }

  return bounds;
};

var tf = function( val ){
  if( val ){
    return 't';
  } else {
    return 'f';
  }
};

var getKey = function( opts ){
  var key = '';

  key += tf( opts.incudeNodes );
  key += tf( opts.includeEdges );
  key += tf( opts.includeLabels );
  key += tf( opts.includeShadows );
  key += tf( opts.includeOverlays );

  return key;
};

var cachedBoundingBoxImpl = function( ele, opts ){
  var _p = ele._private;
  var bb;
  var headless = ele.cy().headless();
  var key = opts === defBbOpts ? defBbOptsKey : getKey( opts );

  if( !opts.useCache || headless || !_p.bbCache || !_p.bbCache[key] ){
    bb = boundingBoxImpl( ele, opts );

    if( !headless ){
      _p.bbCache = _p.bbCache || {};
      _p.bbCache[key] = bb;
    }
  } else {
    bb = _p.bbCache[key];
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeShadows: true,
  includeOverlays: true,
  useCache: true
};

var defBbOptsKey = getKey( defBbOpts );

elesfn.recalculateRenderedStyle = function( useCache ){
  var cy = this.cy();
  var renderer = cy.renderer();
  var styleEnabled = cy.styleEnabled();

  if( renderer && styleEnabled ){
    renderer.recalculateRenderedStyle( this, useCache );
  }

  return this;
};

function filledBbOpts( options ){
  return {
    includeNodes: util.default( options.includeNodes, defBbOpts.includeNodes ),
    includeEdges: util.default( options.includeEdges, defBbOpts.includeEdges ),
    includeLabels: util.default( options.includeLabels, defBbOpts.includeLabels ),
    includeShadows: util.default( options.includeShadows, defBbOpts.includeShadows ),
    includeOverlays: util.default( options.includeOverlays, defBbOpts.includeOverlays ),
    useCache: util.default( options.useCache, defBbOpts.useCache )
  };
}

elesfn.boundingBox = function( options ){
  // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function
  if( this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true) ){
    if( options === undefined ){
      options = defBbOpts;
    } else {
      options = filledBbOpts( options );
    }

    return cachedBoundingBoxImpl( this[0], options );
  }

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  options = options || util.staticEmptyObject();

  var opts = filledBbOpts( options );

  var eles = this;
  var cy = eles.cy();
  var styleEnabled = cy.styleEnabled();

  if( styleEnabled ){
    this.recalculateRenderedStyle( opts.useCache );
  }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' ){
      ele.parallelEdges().recalculateRenderedStyle( opts.useCache ); // n.b. ele.parallelEdges() single is cached
    }

    updateBoundsFromBox( bounds, cachedBoundingBoxImpl( ele, opts ) );
  }

  bounds.x1 = noninf( bounds.x1 );
  bounds.y1 = noninf( bounds.y1 );
  bounds.x2 = noninf( bounds.x2 );
  bounds.y2 = noninf( bounds.y2 );
  bounds.w = noninf( bounds.x2 - bounds.x1 );
  bounds.h = noninf( bounds.y2 - bounds.y1 );

  return bounds;
};

var defineDimFns = function( opts ){
  opts.uppercaseName = util.capitalize( opts.name );
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize( opts.outerName );

  fn[ opts.name ] = function dimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        if( ele.isParent() ){
          return _p[ opts.autoName ] || 0;
        }

        var d = ele.pstyle( opts.name );

        switch( d.strValue ){
          case 'label':
            return _p.rstyle[ opts.labelName ] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var dim = ele[ opts.name ]();
        var border = ele.pstyle( 'border-width' ).pfValue; // n.b. 1/2 each side
        var padding = 2 * ele.pstyle( 'padding' ).pfValue;

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
    var ele = this[0];

    if( ele ){
      var d = ele[ opts.name ]();
      return d * this.cy().zoom();
    }
  };

  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
    var ele = this[0];

    if( ele ){
      var od = ele[ opts.outerName ]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns( {
  name: 'width'
} );

defineDimFns( {
  name: 'height'
} );

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;
fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

},{"../define":47,"../is":86,"../math":88,"../util":103}],25:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

// represents a node or an edge
var Element = function( cy, params, restore ){
  var self = this;
  restore = (restore === undefined || restore ? true : false);

  if( cy === undefined || params === undefined || !is.core( cy ) ){
    util.error( 'An element must have a core reference and parameters set' );
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if( group == null ){
    if( params.data && params.data.source != null && params.data.target != null ){
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if( group !== 'nodes' && group !== 'edges' ){
    util.error( 'An element must be of type `nodes` or `edges`; you specified `' + group + '`' );
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: {}, // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [], // array of children
    traversalCache: {} // cache of output of traversal functions
  };

  // renderedPosition overrides if specified
  if( params.renderedPosition ){
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    this._private.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  if( is.string( params.classes ) ){
    var classes = params.classes.split( /\s+/ );
    for( var i = 0, l = classes.length; i < l; i++ ){
      var cls = classes[ i ];
      if( !cls || cls === '' ){ continue; }

      self._private.classes[ cls ] = true;
    }
  }

  if( params.style || params.css ){
    cy.style().applyBypass( this, params.style || params.css );
  }

  if( restore === undefined || restore ){
    this.restore();
  }

};

module.exports = Element;

},{"../is":86,"../util":103}],26:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var elesfn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger(), // .trigger( events [, extraParams] )

  rtrigger: function( event, extraParams ){ // for internal use only
    if( this.length === 0 ){ return; } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify( {
      type: event,
      eles: this
    } );

    this.trigger( event, extraParams );
    return this;
  }
});

// aliases:
define.eventAliasesOn( elesfn );

module.exports = elesfn;

},{"../define":47}],27:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Selector = require( '../selector' );

var elesfn = ({
  nodes: function( selector ){
    return this.filter( function( i, element ){
      return element.isNode();
    } ).filter( selector );
  },

  edges: function( selector ){
    return this.filter( function( i, element ){
      return element.isEdge();
    } ).filter( selector );
  },

  filter: function( filter ){
    if( filter === undefined ){ // check this first b/c it's the most common/performant case
      return this;
    } else if( is.string( filter ) || is.elementOrCollection( filter ) ){
      return Selector( filter ).filter( this );
    } else if( is.fn( filter ) ){
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];

        if( filter.apply( ele, [ i, ele ] ) ){
          elements.push( ele );
        }
      }

      return this.spawn( elements );
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function( toRemove ){
    if( !toRemove ){
      return this;
    } else {

      if( is.string( toRemove ) ){
        toRemove = this.filter( toRemove );
      }

      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var element = this[ i ];

        var remove = toRemove._private.ids[ element.id() ];
        if( !remove ){
          elements.push( element );
        }
      }

      return this.spawn( elements );
    }

  },

  absoluteComplement: function(){
    var cy = this._private.cy;

    return cy.mutableElements().not( this );
  },

  intersect: function( other ){
    // if a selector is specified, then filter by it instead
    if( is.string( other ) ){
      var selector = other;
      return this.filter( selector );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
    var col = col1Smaller ? col1 : col2;

    for( var i = 0; i < col.length; i++ ){
      var id = col[ i ]._private.data.id;
      var ele = ids2[ id ];

      if( ele ){
        elements.push( ele );
      }
    }

    return this.spawn( elements );
  },

  xor: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( !inOther ){
          elements.push( ele );
        }
      }

    };

    add( col1, col2 );
    add( col2, col1 );

    return this.spawn( elements );
  },

  diff: function( other ){
    var cy = this._private.cy;

    if( is.string( other ) ){
      other = cy.$( other );
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other, retEles ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[ i ];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( inOther ){
          both.push( ele );
        } else {
          retEles.push( ele );
        }
      }

    };

    add( col1, col2, left );
    add( col2, col1, right );

    return {
      left: this.spawn( left, { unique: true } ),
      right: this.spawn( right, { unique: true } ),
      both: this.spawn( both, { unique: true } )
    };
  },

  add: function( toAdd ){
    var cy = this._private.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    var elements = [];

    for( var i = 0; i < this.length; i++ ){
      elements.push( this[ i ] );
    }

    for( var i = 0; i < toAdd.length; i++ ){

      var add = !this._private.ids[ toAdd[ i ].id() ];
      if( add ){
        elements.push( toAdd[ i ] );
      }
    }

    return this.spawn( elements );
  },

  // in place merge on calling collection
  merge: function( toAdd ){
    var _p = this._private;
    var cy = _p.cy;

    if( !toAdd ){
      return this;
    }

    if( toAdd && is.string( toAdd ) ){
      var selector = toAdd;
      toAdd = cy.mutableElements().filter( selector );
    }

    for( var i = 0; i < toAdd.length; i++ ){
      var toAddEle = toAdd[ i ];
      var id = toAddEle._private.data.id;
      var add = !_p.ids[ id ];

      if( add ){
        var index = this.length++;

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
        _p.indexes[ id ] = index;
      } else { // replace
        var index = _p.indexes[ id ];

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function( ele ){
    ele = ele[0];

    var _p = this._private;
    var id = ele._private.data.id;
    var i = _p.indexes[ id ];

    if( i == null ){
      return this; // no need to remove
    }

    // remove ele
    this[ i ] = undefined;
    _p.ids[ id ] = undefined;
    _p.indexes[ id ] = undefined;

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if( this.length > 1 && !unmergedLastEle ){
      var lastEleI = this.length - 1;
      var lastEle = this[ lastEleI ];
      var lastEleId = lastEle._private.data.id;

      this[ lastEleI ] = undefined;
      this[ i ] = lastEle;
      _p.indexes[ lastEleId ] = i;
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function( toRemove ){
    var cy = this._private.cy;

    if( !toRemove ){
      return this;
    }

    if( toRemove && is.string( toRemove ) ){
      var selector = toRemove;
      toRemove = cy.mutableElements().filter( selector );
    }

    for( var i = 0; i < toRemove.length; i++ ){
      this.unmergeOne( toRemove[ i ] );
    }

    return this; // chaining
  },

  map: function( mapFn, thisArg ){
    var arr = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var ret = thisArg ? mapFn.apply( thisArg, [ ele, i, eles ] ) : mapFn( ele, i, eles );

      arr.push( ret );
    }

    return arr;
  },

  reduce: function( fn, initialValue ){
    var val = initialValue;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      val = fn( val, eles[i], i, eles );
    }

    return val;
  },

  stdFilter: function( fn, thisArg ){
    var filterEles = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var include = thisArg ? fn.apply( thisArg, [ ele, i, eles ] ) : fn( ele, i, eles );

      if( include ){
        filterEles.push( ele );
      }
    }

    return this.spawn( filterEles );
  },

  max: function( valFn, thisArg ){
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val > max ){
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function( valFn, thisArg ){
    var min = Infinity;
    var minEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val < min ){
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
});

// aliases
var fn = elesfn;
fn[ 'u' ] = fn[ '|' ] = fn[ '+' ] = fn.union = fn.or = fn.add;
fn[ '\\' ] = fn[ '!' ] = fn[ '-' ] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn[ 'n' ] = fn[ '&' ] = fn[ '.' ] = fn.and = fn.intersection = fn.intersect;
fn[ '^' ] = fn[ '(+)' ] = fn[ '(-)' ] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

},{"../is":86,"../selector":90}],28:[function(require,module,exports){
'use strict';

var elesfn = ({
  isNode: function(){
    return this.group() === 'nodes';
  },

  isEdge: function(){
    return this.group() === 'edges';
  },

  isLoop: function(){
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function(){
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.group;
    }
  }
});


module.exports = elesfn;

},{}],29:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var Element = require( './element' );

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  generate: function( cy, element, tryThisId ){
    var id = tryThisId != null ? tryThisId : util.uuid();

    while( cy.hasElementWithId( id ) ){
      id = util.uuid();
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function( cy, elements, options ){
  if( cy === undefined || !is.core( cy ) ){
    util.error( 'A collection must have a reference to the core' );
    return;
  }

  var ids = {};
  var indexes = {};
  var createdElements = false;

  if( !elements ){
    elements = [];
  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = {};

    for( var i = 0, l = elements.length; i < l; i++ ){
      var json = elements[ i ];

      if( json.data == null ){
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if( data.id == null ){
        data.id = idFactory.generate( cy, json );
      } else if( cy.hasElementWithId( data.id ) || elesIds[ data.id ] ){
        continue; // can't create element if prior id already exists
      }

      var ele = new Element( cy, json, false );
      eles.push( ele );
      elesIds[ data.id ] = true;
    }

    elements = eles;
  }

  this.length = 0;

  for( var i = 0, l = elements.length; i < l; i++ ){
    var element = elements[ i ];
    if( !element ){  continue; }

    var id = element._private.data.id;

    if( !options || (options.unique && !ids[ id ] ) ){
      ids[ id ] = element;
      indexes[ id ] = this.length;

      this[ this.length ] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    ids: ids,
    indexes: indexes
  };

  // restore the elements if we created them from json
  if( createdElements ){
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function(){
  return 'collection';
};

elesfn.spawn = function( cy, eles, opts ){
  if( !is.core( cy ) ){ // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection( cy, eles, opts );
};

elesfn.spawnSelf = function(){
  return this.spawn( this );
};

elesfn.cy = function(){
  return this._private.cy;
};

elesfn.element = function(){
  return this[0];
};

elesfn.collection = function(){
  if( is.collection( this ) ){
    return this;
  } else { // an element
    return new Collection( this._private.cy, [ this ] );
  }
};

elesfn.unique = function(){
  return new Collection( this._private.cy, this, { unique: true } );
};

elesfn.hasElementWithId = function( id ){
  return !!this._private.ids[ id ];
};

elesfn.getElementById = function( id ){
  var cy = this._private.cy;
  var ele = this._private.ids[ id ];

  return ele ? ele : new Collection( cy ); // get ele or empty collection
};

elesfn.poolIndex = function(){
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this._private.data.id;

  return eles._private.indexes[ id ];
};

elesfn.json = function( obj ){
  var ele = this.element();
  var cy = this.cy();

  if( ele == null && obj ){ return this; } // can't set to no eles

  if( ele == null ){ return undefined; } // can't get from no eles

  var p = ele._private;

  if( is.plainObject( obj ) ){ // set

    cy.startBatch();

    if( obj.data ){
      ele.data( obj.data );
    }

    if( obj.position ){
      ele.position( obj.position );
    }

    // ignore group -- immutable

    var checkSwitch = function( k, trueFnName, falseFnName ){
      var obj_k = obj[ k ];

      if( obj_k != null && obj_k !== p[ k ] ){
        if( obj_k ){
          ele[ trueFnName ]();
        } else {
          ele[ falseFnName ]();
        }
      }
    };

    checkSwitch( 'removed', 'remove', 'restore' );

    checkSwitch( 'selected', 'select', 'unselect' );

    checkSwitch( 'selectable', 'selectify', 'unselectify' );

    checkSwitch( 'locked', 'lock', 'unlock' );

    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );

    if( obj.classes != null ){
      ele.classes( obj.classes );
    }

    cy.endBatch();

    return this;

  } else if( obj === undefined ){ // get

    var json = {
      data: util.copy( p.data ),
      position: util.copy( p.position ),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    json.classes = Object.keys( p.classes ).filter(function( cls ){
      return p.classes[cls];
    }).join(' ');

    return json;
  }
};

elesfn.jsons = function(){
  var jsons = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();

    jsons.push( json );
  }

  return jsons;
};

elesfn.clone = function(){
  var cy = this.cy();
  var elesArr = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[ i ];
    var json = ele.json();
    var clone = new Element( cy, json, false ); // NB no restore

    elesArr.push( clone );
  }

  return new Collection( cy, elesArr );
};
elesfn.copy = elesfn.clone;

elesfn.restore = function( notifyRenderer ){
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var nodes = [];
  var edges = [];
  var elements;
  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    if( !ele.removed() ){
      // don't need to handle this ele
      continue;
    }

    // keep nodes first in the array and edges after
    if( ele.isNode() ){ // put to front of array if node
      nodes.push( ele );
    } else { // put to end of array if edge
      edges.push( ele );
    }
  }

  elements = nodes.concat( edges );

  var i;
  var removeFromElements = function(){
    elements.splice( i, 1 );
    i--;
  };

  // now, restore each element
  for( i = 0; i < elements.length; i++ ){
    var ele = elements[ i ];

    var _private = ele._private;
    var data = _private.data;

    // the traversal cache should start fresh when ele is added
    _private.traversalCache = null;

    // set id and validate
    if( data.id === undefined ){
      data.id = idFactory.generate( cy, ele );

    } else if( is.number( data.id ) ){
      data.id = '' + data.id; // now it's a string

    } else if( is.emptyString( data.id ) || !is.string( data.id ) ){
      util.error( 'Can not create element with invalid string ID `' + data.id + '`' );

      // can't create element if it has empty string as id or non-string id
      removeFromElements();
      continue;
    } else if( cy.hasElementWithId( data.id ) ){
      util.error( 'Can not create second element with ID `' + data.id + '`' );

      // can't create element if one already has that id
      removeFromElements();
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if( ele.isNode() ){ // extra checks for nodes
      var node = ele;
      var pos = _private.position;

      // make sure the nodes have a defined position

      if( pos.x == null ){
        pos.x = 0;
      }

      if( pos.y == null ){
        pos.y = 0;
      }
    }

    if( ele.isEdge() ){ // extra checks for edges

      var edge = ele;
      var fields = [ 'source', 'target' ];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for( var j = 0; j < fieldsLength; j++ ){

        var field = fields[ j ];
        var val = data[ field ];

        if( is.number( val ) ){
          val = data[ field ] = '' + data[ field ]; // now string
        }

        if( val == null || val === '' ){
          // can't create if source or target is not defined properly
          util.error( 'Can not create edge `' + id + '` with unspecified ' + field );
          badSourceOrTarget = true;
        } else if( !cy.hasElementWithId( val ) ){
          // can't create edge if one of its nodes doesn't exist
          util.error( 'Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`' );
          badSourceOrTarget = true;
        }
      }

      if( badSourceOrTarget ){ removeFromElements(); continue; } // can't create this

      var src = cy.getElementById( data.source );
      var tgt = cy.getElementById( data.target );

      src._private.edges.push( edge );
      tgt._private.edges.push( edge );

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge

    // create mock ids / indexes maps for element so it can be used like collections
    _private.ids = {};
    _private.ids[ id ] = ele;
    _private.indexes = {};
    _private.indexes[ id ] = ele;

    _private.removed = false;
    cy.addToPool( ele );
  } // for each element

  // do compound node sanity checks
  for( var i = 0; i < nodes.length; i++ ){ // each node
    var node = nodes[ i ];
    var data = node._private.data;

    if( is.number( data.parent ) ){ // then automake string
      data.parent = '' + data.parent;
    }

    var parentId = data.parent;

    var specifiedParent = parentId != null;

    if( specifiedParent ){
      var parent = cy.getElementById( parentId );

      if( parent.empty() ){
        // non-existant parent; just remove it
        data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while( !ancestor.empty() ){
          if( node.same( ancestor ) ){
            // mark self as parent and remove from data
            selfAsParent = true;
            data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if( !selfAsParent ){
          // connect with children
          parent[0]._private.children.push( node );
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy_p.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  if( elements.length > 0 ){
    var restored = new Collection( cy, elements );

    for( var i = 0; i < restored.length; i++ ){
      var ele = restored[i];

      if( ele.isNode() ){ continue; }

      // adding an edge invalidates the traversal caches for the parallel edges
      var pedges = ele.parallelEdges();
      for( var j = 0; j < pedges.length; j++ ){
        pedges[j]._private.traversalCache = null;
      }

      // adding an edge invalidates the traversal cache for the connected nodes
      ele.source()[0]._private.traversalCache = null;
      ele.target()[0]._private.traversalCache = null;
    }

    var toUpdateStyle;

    if( cy_p.hasCompoundNodes ){
      toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.updateStyle( notifyRenderer );

    if( notifyRenderer ){
      restored.rtrigger( 'add' );
    } else {
      restored.trigger( 'add' );
    }
  }

  return self; // chainability
};

elesfn.removed = function(){
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function(){
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function( notifyRenderer ){
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges( node ){
    var edges = node._private.edges;
    for( var i = 0; i < edges.length; i++ ){
      add( edges[ i ] );
    }
  }


  // add descendant nodes
  function addChildren( node ){
    var children = node._private.children;

    for( var i = 0; i < children.length; i++ ){
      add( children[ i ] );
    }
  }

  function add( ele ){
    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
    if( alreadyAdded ){
      return;
    } else {
      elesToRemoveIds[ ele.id() ] = true;
    }

    if( ele.isNode() ){
      elesToRemove.push( ele ); // nodes are removed last

      addConnectedEdges( ele );
      addChildren( ele );
    } else {
      elesToRemove.unshift( ele ); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[ i ];

    add( ele );
  }

  function removeEdgeRef( node, edge ){
    var connectedEdges = node._private.edges;

    util.removeFromArray( connectedEdges, edge );

    // removing an edges invalidates the traversal cache for its nodes
    node._private.traversalCache = null;
  }

  function removeParallelRefs( edge ){
    // removing an edge invalidates the traversal caches for the parallel edges
    var pedges = edge.parallelEdges();
    for( var j = 0; j < pedges.length; j++ ){
      pedges[j]._private.traversalCache = null;
    }
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef( parent, ele ){
    ele = ele[0];
    parent = parent[0];

    var children = parent._private.children;
    var pid = parent.id();

    util.removeFromArray( children, ele );

    if( !alteredParents.ids[ pid ] ){
      alteredParents.ids[ pid ] = true;
      alteredParents.push( parent );
    }
  }

  // remove from core pool
  cy.removeFromPool( elesToRemove );

  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[ i ];

    // mark as removed
    ele._private.removed = true;

    // add to list of removed elements
    removed.push( ele );

    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
      var src = ele.source()[0];
      var tgt = ele.target()[0];

      removeEdgeRef( src, ele );
      removeEdgeRef( tgt, ele );
      removeParallelRefs( ele );

    } else { // remove reference to parent
      var parent = ele.parent();

      if( parent.length !== 0 ){
        removeChildRef( parent, ele );
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for( var i = 0; i < elesStillInside.length; i++ ){
    var ele = elesStillInside[ i ];

    if( ele.isParent() ){
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection( this.cy(), removed );
  if( removedElements.size() > 0 ){
    // must manually notify since trigger won't do this automatically once removed

    if( notifyRenderer ){
      this.cy().notify( {
        type: 'remove',
        eles: removedElements
      } );
    }

    removedElements.trigger( 'remove' );
  }

  // the parents who were modified by the removal need their style updated
  for( var i = 0; i < alteredParents.length; i++ ){
    var ele = alteredParents[ i ];

    if( !ele.removed() ){
      ele.updateStyle();
    }
  }

  return new Collection( cy, removed );
};

elesfn.move = function( struct ){
  var cy = this._private.cy;

  if( struct.source !== undefined || struct.target !== undefined ){
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.hasElementWithId( srcId );
    var tgtExists = cy.hasElementWithId( tgtId );

    if( srcExists || tgtExists ){
      var jsons = this.jsons();

      this.remove();

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'edges' ){
          if( srcExists ){ json.data.source = srcId; }

          if( tgtExists ){ json.data.target = tgtId; }

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons );
    }

  } else if( struct.parent !== undefined ){ // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.hasElementWithId( parentId );

    if( parentExists ){
      var jsons = this.jsons();
      var descs = this.descendants();
      var descsEtcJsons = descs.union( descs.union( this ).connectedEdges() ).jsons();

      this.remove(); // NB: also removes descendants and their connected edges

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];
        var ele = this[i];

        if( json.group === 'nodes' ){
          json.data.parent = parentId === null ? undefined : parentId;

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add( jsons.concat( descsEtcJsons ) );
    }
  }

  return this; // if nothing done
};

[
  require( './algorithms' ),
  require( './animation' ),
  require( './class' ),
  require( './comparators' ),
  require( './compounds' ),
  require( './data' ),
  require( './degree' ),
  require( './dimensions' ),
  require( './events' ),
  require( './filter' ),
  require( './group' ),
  require( './index' ),
  require( './iteration' ),
  require( './layout' ),
  require( './style' ),
  require( './switch-functions' ),
  require( './traversing' )
].forEach( function( props ){
  util.extend( elesfn, props );
} );

module.exports = Collection;

},{"../is":86,"../util":103,"./algorithms":14,"./animation":18,"./class":19,"./comparators":20,"./compounds":21,"./data":22,"./degree":23,"./dimensions":24,"./element":25,"./events":26,"./filter":27,"./group":28,"./index":29,"./iteration":30,"./layout":31,"./style":32,"./switch-functions":33,"./traversing":34}],30:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var zIndexSort = require( './zsort' );

var elesfn = ({
  each: function( fn ){
    if( is.fn( fn ) ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var ret = fn.apply( ele, [ i, ele ] );

        if( ret === false ){ break; } // exit each early on return false
      }
    }
    return this;
  },

  forEach: function( fn, thisArg ){
    if( is.fn( fn ) ){

      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

        if( ret === false ){ break; } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function(){
    var array = [];

    for( var i = 0; i < this.length; i++ ){
      array.push( this[ i ] );
    }

    return array;
  },

  slice: function( start, end ){
    var array = [];
    var thisSize = this.length;

    if( end == null ){
      end = thisSize;
    }

    if( start == null ){
      start = 0;
    }

    if( start < 0 ){
      start = thisSize + start;
    }

    if( end < 0 ){
      end = thisSize + end;
    }

    for( var i = start; i >= 0 && i < end && i < thisSize; i++ ){
      array.push( this[ i ] );
    }

    return this.spawn( array );
  },

  size: function(){
    return this.length;
  },

  eq: function( i ){
    return this[ i ] || this.spawn();
  },

  first: function(){
    return this[0] || this.spawn();
  },

  last: function(){
    return this[ this.length - 1 ] || this.spawn();
  },

  empty: function(){
    return this.length === 0;
  },

  nonempty: function(){
    return !this.empty();
  },

  sort: function( sortFn ){
    if( !is.fn( sortFn ) ){
      return this;
    }

    var sorted = this.toArray().sort( sortFn );

    return this.spawn( sorted );
  },

  sortByZIndex: function(){
    return this.sort( zIndexSort );
  },

  zDepth: function(){
    var ele = this[0];
    if( !ele ){ return undefined; }

    // var cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if( group === 'nodes' ){
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if( !ele.isParent() ){
        return Number.MAX_SAFE_INTEGER - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
    }
  }
});

module.exports = elesfn;

},{"../is":86,"./zsort":35}],31:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Promise = require('../promise');

var elesfn = ({

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function( layout, options, fn ){
    var nodes = this.nodes();
    var cy = this.cy();

    layout.trigger( { type: 'layoutstart', layout: layout } );

    layout.animations = [];

    var calculateSpacing = function( spacing, nodesBb, pos ){
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };
      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    if( options.animate ){
      var nodesBb = nodes.boundingBox();
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];

        var newPos = fn.call( node, i, node );
        var pos = node.position();

        if( !is.number( pos.x ) || !is.number( pos.y ) ){
          node.silentPosition( { x: 0, y: 0 } );
        }

        if ( options.spacingFactor && options.spacingFactor !== 1){
          var spacing = Math.abs(options.spacingFactor);
          newPos = calculateSpacing(spacing, nodesBb, newPos);
        }

        var ani = node.animation( {
          position: newPos,
          duration: options.animationDuration,
          easing: options.animationEasing
        } );

        layout.animations.push( ani );

        ani.play();
      }

      var onStep;
      cy.on( 'step.*', ( onStep = function(){
        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }
      }) );

      layout.one('layoutstop', function(){
        cy.off('step.*', onStep);
      });

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      Promise.all( layout.animations.map(function( ani ){
        return ani.promise();
      }) ).then(function(){
        cy.off('step.*', onStep);

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        }

        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }

        layout.one( 'layoutstop', options.stop );
        layout.trigger( { type: 'layoutstop', layout: layout } );
      });
    } else {
      if( options.spacingFactor && options.spacingFactor !== 1 ){
        var spacing = Math.abs( options.spacingFactor );
        nodes.positions( function( i, node ){
          var pos = fn( i, node );
          var nodesBb = nodes.boundingBox();
          return calculateSpacing( spacing, nodesBb, pos );
        });
      } else {
        nodes.positions( fn );
      }

      if( options.fit ){
        cy.fit( options.eles, options.padding );
      }

      if( options.zoom != null ){
        cy.zoom( options.zoom );
      }

      if( options.pan ){
        cy.pan( options.pan );
      }

      layout.one( 'layoutready', options.ready );
      layout.trigger( { type: 'layoutready', layout: layout } );

      layout.one( 'layoutstop', options.stop );
      layout.trigger( { type: 'layoutstop', layout: layout } );
    }

    return this; // chaining
  },

  layout: function( options ){
    var cy = this.cy();

    cy.layout( util.extend( {}, options, {
      eles: this
    } ) );

    return this;
  },

  makeLayout: function( options ){
    var cy = this.cy();

    return cy.makeLayout( util.extend( {}, options, {
      eles: this
    } ) );
  }

});

// aliases:
elesfn.createLayout = elesfn.makeLayout;

module.exports = elesfn;

},{"../is":86,"../promise":89,"../util":103}],32:[function(require,module,exports){
'use strict';

var is = require( '../is' );

var elesfn = ({

  // fully updates (recalculates) the style for the elements
  updateStyle: function( notifyRenderer ){
    var cy = this._private.cy;

    if( !cy.styleEnabled() ){ return this; }

    if( cy._private.batchingStyle ){
      var bEles = cy._private.batchStyleEles;

      bEles.merge( this );

      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;

    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( hasCompounds ){ // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge( this.descendants() ).merge( this.parents() );
    }

    style.apply( updatedEles );

    if( hasCompounds ){
      var updatedCompounds = updatedEles.updateCompoundBounds();

      // disable for performance for now
      // (as updatedCompounds would be a subset of updatedEles ayway b/c of selectors check)
      // if( updatedCompounds.length > 0 ){
      //   updatedEles.merge( updatedCompounds );
      // }
    }

    if( notifyRenderer ){
      updatedEles.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      updatedEles.trigger( 'style' ); // just fire the event
    }

    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function( notifyRenderer ){
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( !cy.styleEnabled() ){ return this; }

    style.updateMappers( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger( 'style' ); // let renderer know we changed style
    } else {
      toNotify.trigger( 'style' ); // just fire the event
    }
    return this; // chaining
  },

  // get the internal parsed style object for the specified property
  parsedStyle: function( property ){
    var ele = this[0];
    var cy = ele.cy();

    if( !cy.styleEnabled() ){ return; }

    if( ele ){
      return ele._private.style[ property ] || cy.style().getDefaultProperty( property );
    }
  },

  numericStyle: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      var pstyle = ele.pstyle( property );

      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },

  numericStyleUnits: function( property ){
    var ele = this[0];

    if( !ele.cy().styleEnabled() ){ return; }

    if( ele ){
      return ele.pstyle( property ).units;
    }
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function( property ){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return this; }

    var ele = this[0];

    if( ele ){
      return cy.style().getRenderedStyle( ele, property );
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  style: function( name, value ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();

    if( is.plainObject( name ) ){ // then extend the bypass
      var props = name;
      style.applyBypass( this, props, updateTransitions );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger( 'style' ); // let the renderer know we've updated style

    } else if( is.string( name ) ){

      if( value === undefined ){ // then get the property from the style
        var ele = this[0];

        if( ele ){
          return style.getStylePropertyValue( ele, name );
        } else { // empty collection => can't get any value
          return;
        }

      } else { // then set the bypass with the property value
        style.applyBypass( this, name, value, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger( 'style' ); // let the renderer know we've updated style
      }

    } else if( name === undefined ){
      var ele = this[0];

      if( ele ){
        return style.getRawStyle( ele );
      } else { // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeStyle: function( names ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if( names === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeAllBypasses( ele, updateTransitions );
      }
    } else {
      names = names.split( /\s+/ );

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[ i ];

        style.removeBypasses( ele, names, updateTransitions );
      }
    }

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
    toNotify.rtrigger( 'style' ); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function(){
    this.css( 'display', 'element' );
    return this; // chaining
  },

  hide: function(){
    this.css( 'display', 'none' );
    return this; // chaining
  },

  visible: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return true; }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele ){
      if(
        ele.pstyle( 'visibility' ).value !== 'visible'
        || ele.pstyle( 'display' ).value !== 'element'
        || ele.pstyle('width').pfValue === 0
      ){
        return false;
      }

      if( ele._private.group === 'nodes' ){
        if( ele.pstyle('height').pfValue === 0 ){ return false; }

        if( !hasCompoundNodes ){ return true; }

        var parents = ele._private.data.parent ? ele.parents() : null;

        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[ i ];
            var pVis = parent.pstyle( 'visibility' ).value;
            var pDis = parent.pstyle( 'display' ).value;

            if( pVis !== 'visible' || pDis !== 'element' ){
              return false;
            }
          }
        }

        return true;
      } else {
        var src = ele._private.source;
        var tgt = ele._private.target;

        return src.visible() && tgt.visible();
      }

    }
  },

  hidden: function(){
    var ele = this[0];

    if( ele ){
      return !ele.visible();
    }
  },

  effectiveOpacity: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return 1; }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if( ele ){
      var _p = ele._private;
      var parentOpacity = ele.pstyle( 'opacity' ).value;

      if( !hasCompoundNodes ){ return parentOpacity; }

      var parents = !_p.data.parent ? null : ele.parents();

      if( parents ){
        for( var i = 0; i < parents.length; i++ ){
          var parent = parents[ i ];
          var opacity = parent.pstyle( 'opacity' ).value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if( ele ){
      if( !hasCompoundNodes ){
        return ele.pstyle( 'opacity' ).value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  backgrounding: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

});


elesfn.bypass = elesfn.css = elesfn.style;
elesfn.renderedCss = elesfn.renderedStyle;
elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
elesfn.pstyle = elesfn.parsedStyle;

module.exports = elesfn;

},{"../is":86}],33:[function(require,module,exports){
'use strict';

var elesfn = {};

function defineSwitchFunction( params ){
  return function(){
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if( args.length === 2 ){
      var data = args[0];
      var handler = args[1];
      this.on( params.event, data, handler );
    }

    // e.g. cy.nodes().select( handler )
    else if( args.length === 1 ){
      var handler = args[0];
      this.on( params.event, handler );
    }

    // e.g. cy.nodes().select()
    else if( args.length === 0 ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[ i ];
        var able = !params.ableField || ele._private[ params.ableField ];
        var changed = ele._private[ params.field ] != params.value;

        if( params.overrideAble ){
          var overrideAble = params.overrideAble( ele );

          if( overrideAble !== undefined ){
            able = overrideAble;

            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
          }
        }

        if( able ){
          ele._private[ params.field ] = params.value;

          if( changed ){
            changedEles.push( ele );
          }
        }
      }

      var changedColl = this.spawn( changedEles );
      changedColl.updateStyle(); // change of state => possible change of style
      changedColl.trigger( params.event );
    }

    return this;
  };
}

function defineSwitchSet( params ){
  elesfn[ params.field ] = function(){
    var ele = this[0];

    if( ele ){
      if( params.overrideField ){
        var val = params.overrideField( ele );

        if( val !== undefined ){
          return val;
        }
      }

      return ele._private[ params.field ];
    }
  };

  elesfn[ params.on ] = defineSwitchFunction( {
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  } );

  elesfn[ params.off ] = defineSwitchFunction( {
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  } );
}

defineSwitchSet( {
  field: 'locked',
  overrideField: function( ele ){
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
} );

defineSwitchSet( {
  field: 'grabbable',
  overrideField: function( ele ){
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
} );

defineSwitchSet( {
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
} );

defineSwitchSet( {
  field: 'selectable',
  overrideField: function( ele ){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
} );

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function(){
  var ele = this[0];
  if( ele ){
    return ele._private.grabbed;
  }
};

defineSwitchSet( {
  field: 'active',
  on: 'activate',
  off: 'unactivate'
} );

elesfn.inactive = function(){
  var ele = this[0];
  if( ele ){
    return !ele._private.active;
  }
};

module.exports = elesfn;

},{}],34:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var elesfn = {};

var cache = function( fn, name ){
  return function traversalCache( arg1, arg2, arg3, arg4 ){
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if( selectorOrEles == null ){
      key = 'null';
    } else if( is.elementOrCollection( selectorOrEles ) && selectorOrEles.length === 1 ){
      key = '#' + selectorOrEles.id();
    }

    if( eles.length === 1 && key ){
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[ name ] = tch[ name ] || {};
      var cacheHit = ch[ key ];

      if( cacheHit ){
        return cacheHit;
      } else {
        return ( ch[ key ] = fn.call( eles, arg1, arg2, arg3, arg4 ) );
      }
    } else {
      return fn.call( eles, arg1, arg2, arg3, arg4 );
    }
  };
};

// DAG functions
////////////////

var defineDagExtremity = function( params ){
  return function dagExtremityImpl( selector ){
    var eles = this;
    var ret = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];
      if( !ele.isNode() ){
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if(
             ( params.noIncomingEdges && tgt === ele && src !== ele )
          || ( params.noOutgoingEdges && src === ele && tgt !== ele )
        ){
          disqualified = true;
          break;
        }
      }

      if( !disqualified ){
        ret.push( ele );
      }
    }

    return this.spawn( ret, { unique: true } ).filter( selector );
  };
};

var defineDagOneHop = function( params ){
  return function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[ i ];

      if( !ele.isNode() ){ continue; }

      var edges = ele.connectedEdges();
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        var src = edge.source();
        var tgt = edge.target();

        if( params.outgoing && src === ele ){
          oEles.push( edge );
          oEles.push( tgt );
        } else if( params.incoming && tgt === ele ){
          oEles.push( edge );
          oEles.push( src );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  };
};

var defineDagAllHops = function( params ){
  return function( selector ){
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for( ;; ){
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if( next.length === 0 ){ break; } // done if none left

      var newNext = false;
      for( var i = 0; i < next.length; i++ ){
        var n = next[ i ];
        var nid = n.id();

        if( !sElesIds[ nid ] ){
          sElesIds[ nid ] = true;
          sEles.push( n );
          newNext = true;
        }
      }

      if( !newNext ){ break; } // done if touched all outgoers already

      eles = next;
    }

    return this.spawn( sEles, { unique: true } ).filter( selector );
  };
};

util.extend( elesfn, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({ noIncomingEdges: true }),

  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({ noOutgoingEdges: true }),

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache( defineDagOneHop({ outgoing: true }) , 'outgoers' ),

  // aka DAG descendants
  successors: defineDagAllHops({ outgoing: true }),

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache( defineDagOneHop({ incoming: true }), 'incomers' ),

  // aka DAG ancestors
  predecessors: defineDagAllHops({ incoming: true })
} );


// Neighbourhood functions
//////////////////////////

util.extend( elesfn, {
  neighborhood: cache(function( selector ){
    var elements = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
      var node = nodes[ i ];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for( var j = 0; j < connectedEdges.length; j++ ){
        var edge = connectedEdges[ j ];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if( otherNode.length > 0 ){
          elements.push( otherNode[0] ); // add node 1 hop away
        }

        // add connected edge
        elements.push( edge[0] );
      }

    }

    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
  }, 'neighborhood'),

  closedNeighborhood: function( selector ){
    return this.neighborhood().add( this ).filter( selector );
  },

  openNeighborhood: function( selector ){
    return this.neighborhood( selector );
  }
} );

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend( elesfn, {
  source: cache(function sourceImpl( selector ){
    var ele = this[0];
    var src;

    if( ele ){
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter( selector ) : src;
  }, 'source'),

  target: cache(function targetImpl( selector ){
    var ele = this[0];
    var tgt;

    if( ele ){
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter( selector ) : tgt;
  }, 'target'),

  sources: defineSourceFunction( {
    attr: 'source'
  } ),

  targets: defineSourceFunction( {
    attr: 'target'
  } )
} );

function defineSourceFunction( params ){
  return function sourceImpl( selector ){
    var sources = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[ i ];
      var src = ele._private[ params.attr ];

      if( src ){
        sources.push( src );
      }
    }

    return this.spawn( sources, { unique: true } ).filter( selector );
  };
}

util.extend( elesfn, {
  edgesWith: cache( defineEdgesWithFunction(), 'edgesWith', true ),

  edgesTo: cache( defineEdgesWithFunction( {
    thisIsSrc: true
  } ), 'edgesTo', true )
} );

function defineEdgesWithFunction( params ){

  return function edgesWithImpl( otherNodes ){
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if( is.string( otherNodes ) ){
      otherNodes = cy.$( otherNodes );
    }

    var thisIds = this._private.ids;
    var otherIds = otherNodes._private.ids;

    for( var h = 0; h < otherNodes.length; h++ ){
      var edges = otherNodes[ h ]._private.edges;

      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[ i ];
        var edgeData = edge._private.data;
        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if( !edgeConnectsThisAndOther ){ continue; }

        if( p.thisIsSrc || p.thisIsTgt ){
          if( p.thisIsSrc && !thisToOther ){ continue; }

          if( p.thisIsTgt && !otherToThis ){ continue; }
        }

        elements.push( edge );
      }
    }

    return this.spawn( elements, { unique: true } );
  };
}

util.extend( elesfn, {
  connectedEdges: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var node = eles[ i ];
      if( !node.isNode() ){ continue; }

      var edges = node._private.edges;

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[ j ];
        retEles.push( edge );
      }
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedEdges'),

  connectedNodes: cache(function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var edge = eles[ i ];
      if( !edge.isEdge() ){ continue; }

      retEles.push( edge.source()[0] );
      retEles.push( edge.target()[0] );
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  }, 'connectedNodes'),

  parallelEdges: cache( defineParallelEdgesFunction(), 'parallelEdges' ),

  codirectedEdges: cache( defineParallelEdgesFunction( {
    codirected: true
  } ), 'codirectedEdges' )
} );

function defineParallelEdgesFunction( params ){
  var defaults = {
    codirected: false
  };
  params = util.extend( {}, defaults, params );

  return function parallelEdgesImpl( selector ){ // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for( var i = 0; i < edges.length; i++ ){
      var edge1 = edges[ i ];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for( var j = 0; j < srcEdges1.length; j++ ){
        var edge2 = srcEdges1[ j ];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
          elements.push( edge2 );
        }
      }
    }

    return this.spawn( elements, { unique: true } ).filter( selector );
  };

}

// Misc functions
/////////////////

util.extend( elesfn, {
  components: function(){
    var self = this;
    var cy = self.cy();
    var visited = self.spawn();
    var unvisited = self.nodes().spawnSelf();
    var components = [];

    var visitInComponent = function( node, component ){
      visited.merge( node );
      unvisited.unmerge( node );
      component.merge( node );
    };

    if( unvisited.empty() ){ return self.spawn(); }

    do {
      var component = cy.collection();
      components.push( component );

      var root = unvisited[0];
      visitInComponent( root, component );

      self.bfs({
        directed: false,
        roots: root,
        visit: function( i, depth, v, e, u ){
          visitInComponent( v, component );
        }
      } );

    } while( unvisited.length > 0 );

    return components.map(function( component ){
      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){
        return component.anySame( edge.source() ) && component.anySame( edge.target() );
      });

      return component.union( connectedEdges );
    });
  }
} );

module.exports = elesfn;

},{"../is":86,"../util":103}],35:[function(require,module,exports){
'use strict';

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */
var zIndexSort = function( a, b ){
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele){
    var style = ele.pstyle( 'z-compound-depth' );
    if ( style.value === 'auto' ){
      return hasCompoundNodes ? ele.zDepth() : 0
    } else if ( style.value === 'bottom' ){
      return -1
    } else if ( style.value === 'top' ){
      return Number.MAX_SAFE_INTEGER
    }
    // 'orphan'
    return 0
  }
  var depthDiff = getDepth(a) - getDepth(b);
  if ( depthDiff !== 0 ){
    return depthDiff
  }

  function getEleDepth(ele){
    var style = ele.pstyle( 'z-index-compare' );
    if ( style.value === 'auto' ){
      return ele.isNode() ? 1 : 0
    }
    // 'manual'
    return 0
  }
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if ( eleDiff !== 0 ){
    return eleDiff
  }

  var zDiff = a.pstyle( 'z-index' ).value - b.pstyle( 'z-index' ).value;
  if ( zDiff !== 0 ){
    return zDiff
  }
  // compare indices in the core (order added to graph w/ last on top)
  return a.poolIndex() - b.poolIndex();
};

module.exports = zIndexSort;

},{}],36:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Collection = require( '../collection' );
var Element = require( '../collection/element' );

var corefn = {
  add: function( opts ){

    var elements;
    var cy = this;

    // add the elements
    if( is.elementOrCollection( opts ) ){
      var eles = opts;

      if( eles._private.cy === cy ){ // same instance => just restore
        elements = eles.restore();

      } else { // otherwise, copy from json
        var jsons = [];

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[ i ];
          jsons.push( ele.json() );
        }

        elements = new Collection( cy, jsons );
      }
    }

    // specify an array of options
    else if( is.array( opts ) ){
      var jsons = opts;

      elements = new Collection( cy, jsons );
    }

    // specify via opts.nodes and opts.edges
    else if( is.plainObject( opts ) && (is.array( opts.nodes ) || is.array( opts.edges )) ){
      var elesByGroup = opts;
      var jsons = [];

      var grs = [ 'nodes', 'edges' ];
      for( var i = 0, il = grs.length; i < il; i++ ){
        var group = grs[ i ];
        var elesArray = elesByGroup[ group ];

        if( is.array( elesArray ) ){

          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
            var json = util.extend( { group: group }, elesArray[ j ] );

            jsons.push( json );
          }
        }
      }

      elements = new Collection( cy, jsons );
    }

    // specify options for one element
    else {
      var json = opts;
      elements = (new Element( cy, json )).collection();
    }

    return elements;
  },

  remove: function( collection ){
    if( is.elementOrCollection( collection ) ){
      // already have right ref
    } else if( is.string( collection ) ){
      var selector = collection;
      collection = this.$( selector );
    }

    return collection.remove();
  },

  load: function( elements, onload, ondone ){
    var cy = this;

    cy.notifications( false );

    // remove old elements
    var oldEles = cy.mutableElements();
    if( oldEles.length > 0 ){
      oldEles.remove();
    }

    if( elements != null ){
      if( is.plainObject( elements ) || is.array( elements ) ){
        cy.add( elements );
      }
    }

    cy.one( 'layoutready', function( e ){
      cy.notifications( true );
      cy.trigger( e ); // we missed this event by turning notifications off, so pass it on

      cy.notify( {
        type: 'load',
        eles: cy.mutableElements()
      } );

      cy.one( 'load', onload );
      cy.trigger( 'load' );
    } ).one( 'layoutstop', function(){
      cy.one( 'done', ondone );
      cy.trigger( 'done' );
    } );

    var layoutOpts = util.extend( {}, cy._private.options.layout );
    layoutOpts.eles = cy.elements();

    cy.layout( layoutOpts );

    return this;
  }
};

module.exports = corefn;

},{"../collection":29,"../collection/element":25,"../is":86,"../util":103}],37:[function(require,module,exports){
'use strict';

var define = require( '../define' );
var util = require( '../util' );
var is = require( '../is' );

var corefn = ({

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function( eles ){
    var cy = this;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    cy._private.aniEles.merge( eles );
  },

  stopAnimationLoop: function(){
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function(){
    var cy = this;

    cy._private.animationsRunning = true;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function globalAnimationStep(){
      if( !cy._private.animationsRunning ){ return; }

      util.requestAnimationFrame( function animationStep( now ){
        handleElements( now );
        globalAnimationStep();
      } );
    }

    var renderer = cy.renderer();

    if( renderer && renderer.beforeRender ){ // let the renderer schedule animations
      renderer.beforeRender( function rendererAnimationStep( willDraw, now ){
        handleElements( now );
      }, renderer.beforeRenderPriorities.animations );
    } else { // manage the animation loop ourselves
      globalAnimationStep(); // first call
    }

    function handleElements( now ){
      var eles = cy._private.aniEles;
      var doneEles = [];

      function handleElement( ele, isCore ){
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false;

        // cancel all animations on display:none ele
        if( !isCore && ele.pstyle('display').value === 'none' ){
          // put all current and queue animations in this tick's current list
          // and empty the lists for the element
          current = current.splice( 0, current.length ).concat( queue.splice( 0, queue.length ) );

          // stop all animations
          for( var i = 0; i < current.length; i++ ){ current[i].stop(); }
        }

        // if nothing currently animating, get something from the queue
        if( current.length === 0 ){
          var next = queue.shift();

          if( next ){
            current.push( next );
          }
        }

        var callbacks = function( callbacks ){
          for( var j = callbacks.length - 1; j >= 0; j-- ){
            var cb = callbacks[ j ];

            cb();
          }

          callbacks.splice( 0, callbacks.length );
        };

        // step and remove if done
        for( var i = current.length - 1; i >= 0; i-- ){
          var ani = current[ i ];
          var ani_p = ani._private;

          if( ani_p.stopped ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.frames );

            continue;
          }

          if( !ani_p.playing && !ani_p.applying ){ continue; }

          // an apply() while playing shouldn't do anything
          if( ani_p.playing && ani_p.applying ){
            ani_p.applying = false;
          }

          if( !ani_p.started ){
            startAnimation( ele, ani, now );
          }

          step( ele, ani, now, isCore );

          if( is.fn( ani_p.step ) ){
            ani_p.step.call( ele, now );
          }

          if( ani_p.applying ){
            ani_p.applying = false;
          }

          callbacks( ani_p.frames );

          if( ani.completed() ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.completes );
          }

          ranAnis = true;
        }

        if( !isCore && current.length === 0 && queue.length === 0 ){
          doneEles.push( ele );
        }

        return ranAnis;
      } // handleElement

      // handle all eles
      var ranEleAni = false;
      for( var e = 0; e < eles.length; e++ ){
        var ele = eles[ e ];
        var handledThisEle = handleElement( ele );

        ranEleAni = ranEleAni || handledThisEle;
      } // each element

      var ranCoreAni = handleElement( cy, true );

      // notify renderer
      if( ranEleAni || ranCoreAni ){
        if( eles.length > 0 ){
          var updatedEles = eles.updateCompoundBounds().spawnSelf().merge( eles );

          cy.notify({
            type: 'draw',
            eles: updatedEles
          });
        } else {
          cy.notify({
            type: 'draw'
          });
        }
      }

      // remove elements from list of currently animating if its queues are empty
      eles.unmerge( doneEles );

      cy.trigger('step');

    } // handleElements

    function startAnimation( self, ani, now ){
      var isCore = is.core( self );
      var isEles = !isCore;
      var ele = self;
      var style = cy._private.style;
      var ani_p = ani._private;

      if( isEles ){
        var pos = ele._private.position;

        ani_p.startPosition = ani_p.startPosition || {
          x: pos.x,
          y: pos.y
        };

        ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle( ele, ani_p.style );
      }

      if( isCore ){
        var pan = cy._private.pan;

        ani_p.startPan = ani_p.startPan || {
          x: pan.x,
          y: pan.y
        };

        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
      }

      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }

    function step( self, ani, now, isCore ){
      var style = cy._private.style;
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;

      if( !ani_p.easingImpl ){

        if( pEasing == null ){ // use default
          ani_p.easingImpl = easings[ 'linear' ];

        } else { // then define w/ name
          var easingVals;

          if( is.string( pEasing ) ){
            var easingProp = style.parse( 'transition-timing-function', pEasing );

            easingVals = easingProp.value;

          } else { // then assume preparsed array
            easingVals = pEasing;
          }

          var name, args;

          if( is.string( easingVals ) ){
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice( 2 ).map( function( n ){ return +n; } );
          }

          if( args.length > 0 ){ // create with args
            if( name === 'spring' ){
              args.push( ani_p.duration ); // need duration to generate spring
            }

            ani_p.easingImpl = easings[ name ].apply( null, args );
          } else { // static impl by name
            ani_p.easingImpl = easings[ name ];
          }
        }

      }

      var easing = ani_p.easingImpl;
      var percent;

      if( ani_p.duration === 0 ){
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }

      if( ani_p.applying ){
        percent = ani_p.progress;
      }

      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( ani_p.delay == null ){ // then update

        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        var pos = _p.position;
        if( endPos && isEles ){
          if( valid( startPos.x, endPos.x ) ){
            pos.x = ease( startPos.x, endPos.x, percent, easing );
          }

          if( valid( startPos.y, endPos.y ) ){
            pos.y = ease( startPos.y, endPos.y, percent, easing );
          }

          self.trigger('position');
        }

        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if( animatingPan ){
          if( valid( startPan.x, endPan.x ) ){
            pan.x = ease( startPan.x, endPan.x, percent, easing );
          }

          if( valid( startPan.y, endPan.y ) ){
            pan.y = ease( startPan.y, endPan.y, percent, easing );
          }

          self.trigger( 'pan' );
        }

        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if( animatingZoom ){
          if( valid( startZoom, endZoom ) ){
            _p.zoom = ease( startZoom, endZoom, percent, easing );
          }

          self.trigger( 'zoom' );
        }

        if( animatingPan || animatingZoom ){
          self.trigger( 'viewport' );
        }

        var props = ani_p.style;
        if( props && props.length > 0 && isEles ){
          for( var i = 0; i < props.length; i++ ){
            var prop = props[ i ];
            var name = prop.name;
            var end = prop;

            var start = ani_p.startStyle[ name ];
            var easedVal = ease( start, end, percent, easing );

            style.overrideBypass( self, name, easedVal );
          } // for props

          self.trigger('style');

        } // if

      }

      ani_p.progress = percent;

      return percent;
    }

    function valid( start, end ){
      if( start == null || end == null ){
        return false;
      }

      if( is.number( start ) && is.number( end ) ){
        return true;
      } else if( (start) && (end) ){
        return true;
      }

      return false;
    }

    // assumes p0 = 0, p3 = 1
    function evalCubicBezier( p1, p2, t ){
      var one_t = 1 - t;
      var tsq = t * t;

      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
    }

    function cubicBezier( p1, p2 ){
      return function( start, end, percent ){
        return start + (end - start) * evalCubicBezier( p1, p2, percent );
      };
    }

    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function(){
      function springAccelerationForState( state ){
        return (-state.tension * state.x) - (state.friction * state.v);
      }

      function springEvaluateStateWithDerivative( initialState, dt, derivative ){
        var state = {
          x: initialState.x + derivative.dx * dt,
          v: initialState.v + derivative.dv * dt,
          tension: initialState.tension,
          friction: initialState.friction
        };

        return { dx: state.v, dv: springAccelerationForState( state ) };
      }

      function springIntegrateState( state, dt ){
        var a = {
          dx: state.v,
          dv: springAccelerationForState( state )
        },
        b = springEvaluateStateWithDerivative( state, dt * 0.5, a ),
        c = springEvaluateStateWithDerivative( state, dt * 0.5, b ),
        d = springEvaluateStateWithDerivative( state, dt, c ),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;

        return state;
      }

      return function springRK4Factory( tension, friction, duration ){

        var initState = {
          x: -1,
          v: 0,
          tension: null,
          friction: null
        },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration, dt, last_state;

        tension = parseFloat( tension ) || 500;
        friction = parseFloat( friction ) || 20;
        duration = duration || null;

        initState.tension = tension;
        initState.friction = friction;

        have_duration = duration !== null;

        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
        if( have_duration ){
          /* Run the simulation without a duration. */
          time_lapsed = springRK4Factory( tension, friction );
          /* Compute the adjusted time delta. */
          dt = time_lapsed / duration * DT;
        } else {
          dt = DT;
        }

        while( true ){
          /* Next/step function .*/
          last_state = springIntegrateState( last_state || initState, dt );
          /* Store the position. */
          path.push( 1 + last_state.x );
          time_lapsed += 16;
          /* If the change threshold is reached, break. */
          if( !(Math.abs( last_state.x ) > tolerance && Math.abs( last_state.v ) > tolerance) ){
            break;
          }
        }

        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
           computed path and returns a snapshot of the position according to a given percentComplete. */
        return !have_duration ? time_lapsed : function( percentComplete ){ return path[ (percentComplete * (path.length - 1)) | 0 ]; };
      };
    }());

    var easings = {
      'linear': function( start, end, percent ){
        return start + (end - start) * percent;
      },

      // default easings
      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),

      // sine
      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),

      // quad
      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),

      // cubic
      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),

      // quart
      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),

      // quint
      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),

      // expo
      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),

      // circ
      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),


      // user param easings...

      'spring': function( tension, friction, duration ){
        if( duration === 0 ){ // can't get a spring w/ duration 0
          return easings.linear; // duration 0 => jump to end so impl doesn't matter
        }

        var spring = generateSpringRK4( tension, friction, duration );

        return function( start, end, percent ){
          return start + (end - start) * spring( percent );
        };
      },

      'cubic-bezier': function( x1, y1, x2, y2 ){
        return cubicBezier( x1, y1, x2, y2 );
      }
    };

    function ease( startProp, endProp, percent, easingFn ){
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      var start, end;

      if( startProp.pfValue != null || startProp.value != null ){
        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
      } else {
        start = startProp;
      }

      if( endProp.pfValue != null || endProp.value != null ){
        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
      } else {
        end = endProp;
      }

      if( is.number( start ) && is.number( end ) ){
        return easingFn( start, end, percent );

      } else if( is.array( start ) && is.array( end ) ){
        var easedArr = [];

        for( var i = 0; i < end.length; i++ ){
          var si = start[ i ];
          var ei = end[ i ];

          if( si != null && ei != null ){
            var val = easingFn( si, ei, percent );

            if( startProp.roundValue ){ val = Math.round( val ); }

            easedArr.push( val );
          } else {
            easedArr.push( ei );
          }
        }

        return easedArr;
      }

      return undefined;
    }

  }

});

module.exports = corefn;

},{"../define":47,"../is":86,"../util":103}],38:[function(require,module,exports){
'use strict';

var define = require( '../define' );

var corefn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on( { unbindSelfOnTrigger: true } ),
  once: define.on( { unbindAllBindersOnTrigger: true } ),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger() // .trigger( events [, extraParams] )
});

define.eventAliasesOn( corefn );

module.exports = corefn;

},{"../define":47}],39:[function(require,module,exports){
'use strict';

var corefn = ({

  png: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png( options );
  },

  jpg: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg( options );
  }

});

corefn.jpeg = corefn.jpg;

module.exports = corefn;

},{}],40:[function(require,module,exports){
'use strict';

var window = require( '../window' );
var util = require( '../util' );
var Collection = require( '../collection' );
var is = require( '../is' );
var Promise = require( '../promise' );
var define = require( '../define' );

var Core = function( opts ){
  var cy = this;

  opts = util.extend( {}, opts );

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if( reg && reg.cy ){
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );

  var defVal = function( def, val, altVal ){
    if( val !== undefined ){
      return val;
    } else if( altVal !== undefined ){
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    initrender: false, // has initrender has been triggered
    options: options, // cached options
    elements: new Collection( this ), // elements in the graph
    listeners: [], // list of listeners
    aniEles: new Collection( this ), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false, // whether destroy was called
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal( true, options.zoomingEnabled ),
    userZoomingEnabled: defVal( true, options.userZoomingEnabled ),
    panningEnabled: defVal( true, options.panningEnabled ),
    userPanningEnabled: defVal( true, options.userPanningEnabled ),
    boxSelectionEnabled: defVal( true, options.boxSelectionEnabled ),
    autolock: defVal( false, options.autolock, options.autolockNodes ),
    autoungrabify: defVal( false, options.autoungrabify, options.autoungrabifyNodes ),
    autounselectify: defVal( false, options.autounselectify ),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number( options.zoom ) ? options.zoom : 1,
    pan: {
      x: is.plainObject( options.pan ) && is.number( options.pan.x ) ? options.pan.x : 0,
      y: is.plainObject( options.pan ) && is.number( options.pan.y ) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  // set selection type
  var selType = options.selectionType;
  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if( is.number( options.minZoom ) && is.number( options.maxZoom ) && options.minZoom < options.maxZoom ){
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if( is.number( options.minZoom ) && options.maxZoom === undefined ){
    _p.minZoom = options.minZoom;
  } else if( is.number( options.maxZoom ) && options.minZoom === undefined ){
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function( extData, next ){
    var anyIsPromise = extData.some( is.promise );

    if( anyIsPromise ){
      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
    } else {
      next( extData ); // exec synchronously for convenience
    }
  };

  // create the renderer
  cy.initRenderer( util.extend( {
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number( options.wheelSensitivity ) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number( options.pixelRatio ) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer ) );

  loadExtData([ options.style, options.elements ], function( thens ){
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if( _p.styleEnabled ){
      cy.setStyle( initStyle );
    }

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on( 'initrender', options.initrender );
      cy.on( 'initrender', function(){
        _p.initrender = true;
      } );
    }

    // initial load
    cy.load( initEles, function(){ // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( is.fn( options.ready ) ){
        cy.on( 'ready', options.ready );
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[ i ];
        cy.on( 'ready', fn );
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.trigger( 'ready' );
    }, options.done );

  } );
};

var corefn = Core.prototype; // short alias

util.extend( corefn, {
  instanceString: function(){
    return 'core';
  },

  isReady: function(){
    return this._private.ready;
  },

  isDestroyed: function(){
    return this._private.destroyed;
  },

  ready: function( fn ){
    if( this.isReady() ){
      this.trigger( 'ready', [], fn ); // just calls fn as though triggered via ready event
    } else {
      this.on( 'ready', fn );
    }

    return this;
  },

  initrender: function(){
    return this._private.initrender;
  },

  destroy: function(){
    var cy = this;
    if( cy.isDestroyed() ) return;

    cy.stopAnimationLoop();

    cy.destroyRenderer();

    this.trigger( 'destroy' );

    cy._private.destroyed = true;

    return cy;
  },

  hasElementWithId: function( id ){
    return this._private.elements.hasElementWithId( id );
  },

  getElementById: function( id ){
    return this._private.elements.getElementById( id );
  },

  selectionType: function(){
    return this._private.selectionType;
  },

  hasCompoundNodes: function(){
    return this._private.hasCompoundNodes;
  },

  headless: function(){
    return this._private.options.renderer.name === 'null';
  },

  styleEnabled: function(){
    return this._private.styleEnabled;
  },

  addToPool: function( eles ){
    this._private.elements.merge( eles );

    return this; // chaining
  },

  removeFromPool: function( eles ){
    this._private.elements.unmerge( eles );

    return this;
  },

  container: function(){
    return this._private.container;
  },

  options: function(){
    return util.copy( this._private.options );
  },

  json: function( obj ){
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    if( is.plainObject( obj ) ){ // set

      cy.startBatch();

      if( obj.elements ){
        var idInJson = {};

        var updateEles = function( jsons, gr ){
          for( var i = 0; i < jsons.length; i++ ){
            var json = jsons[ i ];
            var id = json.data.id;
            var ele = cy.getElementById( id );

            idInJson[ id ] = true;

            if( ele.length !== 0 ){ // existing element should be updated
              ele.json( json );
            } else { // otherwise should be added
              if( gr ){
                cy.add( util.extend( { group: gr }, json ) );
              } else {
                cy.add( json );
              }
            }
          }
        };

        if( is.array( obj.elements ) ){ // elements: []
          updateEles( obj.elements );

        } else { // elements: { nodes: [], edges: [] }
          var grs = [ 'nodes', 'edges' ];
          for( var i = 0; i < grs.length; i++ ){
            var gr = grs[ i ];
            var elements = obj.elements[ gr ];

            if( is.array( elements ) ){
              updateEles( elements, gr );
            }
          }
        }

        // elements not specified in json should be removed
        eles.stdFilter( function( ele ){
          return !idInJson[ ele.id() ];
        } ).remove();
      }

      if( obj.style ){
        cy.style( obj.style );
      }

      if( obj.zoom != null && obj.zoom !== _p.zoom ){
        cy.zoom( obj.zoom );
      }

      if( obj.pan ){
        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
          cy.pan( obj.pan );
        }
      }

      var fields = [
        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
        'panningEnabled', 'userPanningEnabled',
        'boxSelectionEnabled',
        'autolock', 'autoungrabify', 'autounselectify'
      ];

      for( var i = 0; i < fields.length; i++ ){
        var f = fields[ i ];

        if( obj[ f ] != null ){
          cy[ f ]( obj[ f ] );
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if( obj === undefined ){ // get
      var json = {};

      json.elements = {};
      eles.forEach( function( ele ){
        var group = ele.group();

        if( !json.elements[ group ] ){
          json.elements[ group ] = [];
        }

        json.elements[ group ].push( ele.json() );
      } );

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy( cy._private.pan );
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy( cy._private.options.renderer );
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data( {
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  } ),

  removeScratch: define.removeData( {
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  } )

} );

[
  require( './add-remove' ),
  require( './animation' ),
  require( './events' ),
  require( './export' ),
  require( './layout' ),
  require( './notification' ),
  require( './renderer' ),
  require( './search' ),
  require( './style' ),
  require( './viewport' )
].forEach( function( props ){
  util.extend( corefn, props );
} );

module.exports = Core;

},{"../collection":29,"../define":47,"../is":86,"../promise":89,"../util":103,"../window":110,"./add-remove":36,"./animation":37,"./events":38,"./export":39,"./layout":41,"./notification":42,"./renderer":43,"./search":44,"./style":45,"./viewport":46}],41:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var corefn = ({

  layout: function( params ){
    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );

    layout.run();

    return this; // chaining
  },

  makeLayout: function( options ){
    var cy = this;

    if( options == null ){
      util.error( 'Layout options must be specified to make a layout' );
      return;
    }

    if( options.name == null ){
      util.error( 'A `name` must be specified to make a layout' );
      return;
    }

    var name = options.name;
    var Layout = cy.extension( 'layout', name );

    if( Layout == null ){
      util.error( 'Can not apply layout: No such layout `' + name + '` found; did you include its JS file?' );
      return;
    }

    var eles;
    if( is.string( options.eles ) ){
      eles = cy.$( options.eles );
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout( util.extend( {}, options, {
      cy: cy,
      eles: eles
    } ) );

    return layout;
  }

});

corefn.createLayout = corefn.makeLayout;

module.exports = corefn;

},{"../is":86,"../util":103}],42:[function(require,module,exports){
'use strict';

var corefn = ({
  notify: function( params ){
    var _p = this._private;

    if( _p.batchingNotify ){
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if( params.eles ){
        bEles.merge( params.eles );
      }

      if( !bTypes.ids[ params.type ] ){
        bTypes.push( params.type );
        bTypes.ids[ params.type ] = true;
      }

      return; // notifications are disabled during batching
    }

    if( !_p.notificationsEnabled ){ return; } // exit on disabled

    var renderer = this.renderer();

    // exit if destroy() called on core or renderer in between frames #1499 #1528
    if( this.isDestroyed() || !renderer ){ return; }

    renderer.notify( params );
  },

  notifications: function( bool ){
    var p = this._private;

    if( bool === undefined ){
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function( callback ){
    this.notifications( false );
    callback();
    this.notifications( true );
  },

  startBatch: function(){
    var _p = this._private;

    if( _p.batchCount == null ){
      _p.batchCount = 0;
    }

    if( _p.batchCount === 0 ){
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];
      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function(){
    var _p = this._private;

    _p.batchCount--;

    if( _p.batchCount === 0 ){
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify( {
        type: _p.batchNotifyTypes,
        eles: _p.batchNotifyEles
      } );
    }

    return this;
  },

  batch: function( callback ){
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function( map ){
    var cy = this;

    return this.batch( function(){
      var ids = Object.keys( map );

      for( var i = 0; i < ids.length; i++ ){
        var id = ids[i];
        var data = map[ id ];
        var ele = cy.getElementById( id );

        ele.data( data );
      }
    } );
  }
});

module.exports = corefn;

},{}],43:[function(require,module,exports){
'use strict';

var util = require( '../util' );

var corefn = ({

  renderTo: function( context, zoom, pan, pxRatio ){
    var r = this._private.renderer;

    r.renderTo( context, zoom, pan, pxRatio );
    return this;
  },

  renderer: function(){
    return this._private.renderer;
  },

  forceRender: function(){
    this.notify( {
      type: 'draw'
    } );

    return this;
  },

  resize: function(){
    this.invalidateSize();

    this.notify( {
      type: 'resize'
    } );

    this.trigger( 'resize' );

    return this;
  },

  initRenderer: function( options ){
    var cy = this;

    var RendererProto = cy.extension( 'renderer', options.name );
    if( RendererProto == null ){
      util.error( 'Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name );
      return;
    }

    var rOpts = util.extend( {}, options, {
      cy: cy
    } );

    cy._private.renderer = new RendererProto( rOpts );
  },

  destroyRenderer: function(){
    var cy = this;

    cy.notify( { type: 'destroy' } ); // destroy the renderer

    var domEle = cy.container();
    if( domEle ){
      domEle._cyreg = null;

      while( domEle.childNodes.length > 0 ){
        domEle.removeChild( domEle.childNodes[0] );
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref
  },

  onRender: function( fn ){
    return this.on('render', fn);
  },

  offRender: function( fn ){
    return this.off('render', fn);
  }

});

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

},{"../util":103}],44:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Collection = require( '../collection' );

var corefn = ({

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function( eles, opts ){

    if( is.string( eles ) ){
      return this.$( eles );

    } else if( is.elementOrCollection( eles ) ){
      return eles.collection();

    } else if( is.array( eles ) ){
      return new Collection( this, eles, opts );
    }

    return new Collection( this );
  },

  nodes: function( selector ){
    var nodes = this.$( function(){
      return this.isNode();
    } );

    if( selector ){
      return nodes.filter( selector );
    }

    return nodes;
  },

  edges: function( selector ){
    var edges = this.$( function(){
      return this.isEdge();
    } );

    if( selector ){
      return edges.filter( selector );
    }

    return edges;
  },

  // search the graph like jQuery
  $: function( selector ){
    var eles = this._private.elements;

    if( selector ){
      return eles.filter( selector );
    } else {
      return eles.spawnSelf();
    }
  },

  mutableElements: function(){
    return this._private.elements;
  }

});

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

},{"../collection":29,"../is":86}],45:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var Style = require( '../style' );

var corefn = ({

  style: function( newStyle ){
    if( newStyle ){
      var s = this.setStyle( newStyle );

      s.update();
    }

    return this._private.style;
  },

  setStyle: function( style ){
    var _p = this._private;

    if( is.stylesheet( style ) ){
      _p.style = style.generateStyle( this );

    } else if( is.array( style ) ){
      _p.style = Style.fromJson( this, style );

    } else if( is.string( style ) ){
      _p.style = Style.fromString( this, style );

    } else {
      _p.style = Style( this );
    }

    return _p.style;
  }
});

module.exports = corefn;

},{"../is":86,"../style":95}],46:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var window = require( '../window' );

var corefn = ({

  autolock: function( bool ){
    if( bool !== undefined ){
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function( bool ){
    if( bool !== undefined ){
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function( bool ){
    if( bool !== undefined ){
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function(){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch( args.length ){
    case 0: // .pan()
      return pan;

    case 1:

      if( is.string( args[0] ) ){ // .pan('x')
        dim = args[0];
        return pan[ dim ];

      } else if( is.plainObject( args[0] ) ){ // .pan({ x: 0, y: 100 })
        if( !this._private.panningEnabled ){
          return this;
        }

        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x = x;
        }

        if( is.number( y ) ){
          pan.y = y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .pan('x', 100)
      if( !this._private.panningEnabled ){
        return this;
      }

      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] = val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  panBy: function( params ){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if( !this._private.panningEnabled ){
      return this;
    }

    switch( args.length ){
    case 1:

      if( is.plainObject( args[0] ) ){ // .panBy({ x: 0, y: 100 })
        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number( x ) ){
          pan.x += x;
        }

        if( is.number( y ) ){
          pan.y += y;
        }

        this.trigger( 'pan viewport' );
      }
      break;

    case 2: // .panBy('x', 100)
      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number( val ) ){
        pan[ dim ] += val;
      }

      this.trigger( 'pan viewport' );
      break;

    default:
      break; // invalid
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  fit: function( elements, padding ){
    var viewportState = this.getFitViewport( elements, padding );

    if( viewportState ){
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.trigger( 'pan zoom viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getFitViewport: function( elements, padding ){
    if( is.number( elements ) && padding === undefined ){ // elements is optional
      padding = elements;
      elements = undefined;
    }

    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return;
    }

    var bb;

    if( is.string( elements ) ){
      var sel = elements;
      elements = this.$( sel );

    } else if( is.boundingBox( elements ) ){ // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom;
    padding = is.number( padding ) ? padding : 0;

    if( !isNaN( w ) && !isNaN( h ) && w > 0 && h > 0 && !isNaN( bb.w ) && !isNaN( bb.h ) &&  bb.w > 0 && bb.h > 0 ){
      zoom = Math.min( (w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h );

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
        y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.minZoom;
    } else if( is.number( zoom ) ){
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.maxZoom;
    } else if( is.number( zoom ) ){
      this._private.maxZoom = zoom;
    }

    return this;
  },

  zoom: function( params ){
    var pos; // in rendered px
    var zoom;

    if( params === undefined ){ // then get the zoom
      return this._private.zoom;

    } else if( is.number( params ) ){ // then set the zoom
      zoom = params;

    } else if( is.plainObject( params ) ){ // then zoom about a point
      zoom = params.level;

      if( params.position ){
        var p = params.position;
        var pan = this._private.pan;
        var z = this._private.zoom;

        pos = { // convert to rendered px
          x: p.x * z + pan.x,
          y: p.y * z + pan.y
        };
      } else if( params.renderedPosition ){
        pos = params.renderedPosition;
      }

      if( pos && !this._private.panningEnabled ){
        return this; // panning disabled
      }
    }

    if( !this._private.zoomingEnabled ){
      return this; // zooming disabled
    }

    if( !is.number( zoom ) || ( pos && (!is.number( pos.x ) || !is.number( pos.y )) ) ){
      return this; // can't zoom with invalid params
    }

    // crop zoom
    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

    if( pos ){ // set zoom about position
      var pan1 = this._private.pan;
      var zoom1 = this._private.zoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };

      this._private.zoom = zoom;
      this._private.pan = pan2;

      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
      this.trigger( ' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );

    } else { // just set the zoom
      this._private.zoom = zoom;
      this.trigger( 'zoom viewport' );
    }

    this.notify( { // notify the renderer that the viewport changed
      type: 'viewport'
    } );

    return this; // chaining
  },

  viewport: function( opts ){
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if( !opts ){ return this; }
    if( !is.number( opts.zoom ) ){ zoomDefd = false; }
    if( !is.plainObject( opts.pan ) ){ panDefd = false; }
    if( !zoomDefd && !panDefd ){ return this; }

    if( zoomDefd ){
      var z = opts.zoom;

      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
        zoomFailed = true;

      } else {
        _p.zoom = z;

        events.push( 'zoom' );
      }
    }

    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
      var p = opts.pan;

      if( is.number( p.x ) ){
        _p.pan.x = p.x;
        panFailed = false;
      }

      if( is.number( p.y ) ){
        _p.pan.y = p.y;
        panFailed = false;
      }

      if( !panFailed ){
        events.push( 'pan' );
      }
    }

    if( events.length > 0 ){
      events.push( 'viewport' );
      this.trigger( events.join( ' ' ) );

      this.notify( {
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  center: function( elements ){
    var pan = this.getCenterPan( elements );

    if( pan ){
      this._private.pan = pan;

      this.trigger( 'pan viewport' );

      this.notify( { // notify the renderer that the viewport changed
        type: 'viewport'
      } );
    }

    return this; // chaining
  },

  getCenterPan: function( elements, zoom ){
    if( !this._private.panningEnabled ){
      return;
    }

    if( is.string( elements ) ){
      var selector = elements;
      elements = this.mutableElements().filter( selector );
    } else if( !is.elementOrCollection( elements ) ){
      elements = this.mutableElements();
    }

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,
      y: (h - zoom * ( bb.y1 + bb.y2 )) / 2
    };

    return pan;
  },

  reset: function(){
    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return this;
    }

    this.viewport( {
      pan: { x: 0, y: 0 },
      zoom: 1
    } );

    return this; // chaining
  },

  invalidateSize: function(){
    this._private.sizeCache = null;
  },

  size: function(){
    var _p = this._private;
    var container = _p.container;

    return ( _p.sizeCache = _p.sizeCache || ( container ? (function(){
      var rect = container.getBoundingClientRect();
      var style = window.getComputedStyle( container );
      var val = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };

      return {
        width: rect.width - val('padding-left') - val('padding-right') - val('border-left-width') - val('border-right-width'),
        height: rect.height - val('padding-top') - val('padding-bottom') - val('border-top-width') - val('border-bottom-width')
      };
    })() : { // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    } ) );
  },

  width: function(){
    return this.size().width;
  },

  height: function(){
    return this.size().height;
  },

  extent: function(){
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: ( rb.x1 - pan.x ) / zoom,
      x2: ( rb.x2 - pan.x ) / zoom,
      y1: ( rb.y1 - pan.y ) / zoom,
      y2: ( rb.y2 - pan.y ) / zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function(){
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
});

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

},{"../is":86,"../window":110}],47:[function(require,module,exports){
'use strict';

// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// var foo = define.foo({ /* params... */ })

var util = require( './util' );
var is = require( './is' );
var Selector = require( './selector' );
var Promise = require( './promise' );
var Event = require( './event' );
var Animation = require( './animation' );

var define = {

  // access data field
  data: function( params ){
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      onSet: function( self ){},
      canSet: function( self ){ return true; }
    };
    params = util.extend( {}, defaults, params );

    return function dataImpl( name, value ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if( is.string( name ) ){ // set or get property

        // .data('foo')
        if( p.allowGetting && value === undefined ){ // get

          var ret;
          if( single ){
            ret = single._private[ p.field ][ name ];
          }
          return ret;

        // .data('foo', 'bar')
        } else if( p.allowSetting && value !== undefined ){ // set
          var valid = !p.immutableKeys[ name ];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[ i ] ) ){
                all[ i ]._private[ p.field ][ name ] = value;
              }
            }

            // update mappers if asked
            if( p.updateStyle ){ self.updateStyle(); }

            // call onSet callback
            p.onSet( self );

            if( p.settingTriggersEvent ){
              self[ p.triggerFnName ]( p.settingEvent );
            }
          }
        }

      // .data({ 'foo': 'bar' })
      } else if( p.allowSetting && is.plainObject( name ) ){ // extend
        var obj = name;
        var k, v;
        var keys = Object.keys( obj );

        for( var i = 0; i < keys.length; i++ ){
          k = keys[ i ];
          v = obj[ k ];

          var valid = !p.immutableKeys[ k ];
          if( valid ){
            for( var j = 0; j < all.length; j++ ){
              var ele = all[j];

              if( p.canSet( ele ) ){
                ele._private[ p.field ][ k ] = v;
              }
            }
          }
        }

        // update mappers if asked
        if( p.updateStyle ){ self.updateStyle(); }

        // call onSet callback
        p.onSet( self );

        if( p.settingTriggersEvent ){
          self[ p.triggerFnName ]( p.settingEvent );
        }

      // .data(function(){ ... })
      } else if( p.allowBinding && is.fn( name ) ){ // bind to event
        var fn = name;
        self.on( p.bindingEvent, fn );

      // .data()
      } else if( p.allowGetting && name === undefined ){ // get whole object
        var ret;
        if( single ){
          ret = single._private[ p.field ];
        }
        return ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function( params ){
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend( {}, defaults, params );

    return function removeDataImpl( names ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like

      // .removeData('foo bar')
      if( is.string( names ) ){ // then get the list of keys, and delete them
        var keys = names.split( /\s+/ );
        var l = keys.length;

        for( var i = 0; i < l; i++ ){ // delete each non-empty key
          var key = keys[ i ];
          if( is.emptyString( key ) ){ continue; }

          var valid = !p.immutableKeys[ key ]; // not valid if immutable
          if( valid ){
            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
              all[ i_a ]._private[ p.field ][ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }

      // .removeData()
      } else if( names === undefined ){ // then delete all keys

        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
          var _privateFields = all[ i_a ]._private[ p.field ];
          var keys = Object.keys( _privateFields );

          for( var i = 0; i < keys.length; i++ ){
            var key = keys[i];
            var validKeyToDelete = !p.immutableKeys[ key ];

            if( validKeyToDelete ){
              _privateFields[ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }
      }

      return self; // maintain chaining
    }; // function
  }, // removeData

  // event function reusable stuff
  event: {
    regex: /(\w+)(\.(?:\w+|\*))?/, // regex for matching event strings (e.g. "click.namespace")
    universalNamespace: '.*', // matches as if no namespace specified and prevents users from unbinding accidentally
    optionalTypeRegex: /(\w+)?(\.(?:\w+|\*))?/,
    falseCallback: function(){ return false; }
  },

  // event binding
  on: function( params ){
    var defaults = {
      unbindSelfOnTrigger: false,
      unbindAllBindersOnTrigger: false
    };
    params = util.extend( {}, defaults, params );

    return function onImpl( events, selector, data, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var p = params;

      if( is.plainObject( selector ) ){ // selector is actually data
        callback = data;
        data = selector;
        selector = undefined;
      } else if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        data = undefined;
        selector = undefined;
      }

      if( is.fn( data ) || data === false ){ // data is actually callback
        callback = data;
        data = undefined;
      }

      // if there isn't a callback, we can't really do anything
      // (can't speak for mapped events arg version)
      if( !(is.fn( callback ) || callback === false) && eventsIsString ){
        return self; // maintain chaining
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];
        if( callback === false ){
          callback = define.event.falseCallback;
        }

        if( !is.fn( callback ) ){ continue; }

        evts = evts.split( /\s+/ );
        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]

          if( match ){
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            var listener = {
              callback: callback, // callback to run
              data: data, // extra data in eventObj.data
              delegated: selector ? true : false, // whether the evt is delegated
              selector: selector, // the selector to match for delegated events
              selObj: new Selector( selector ), // cached selector object to save rebuilding
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
              binders: all // who bound together
            };

            for( var j = 0; j < all.length; j++ ){
              var _p = all[ j ]._private = all[ j ]._private || {};

              _p.listeners = _p.listeners || [];
              _p.listeners.push( listener );
            }
          }
        } // for events array
      } // for events map

      return self; // maintain chaining
    }; // function
  }, // on

  eventAliasesOn: function( proto ){
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.removeListener = p.unlisten = p.unbind = p.off;
    p.emit = p.trigger;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function( events, selector ){
      var self = this;
      var args = Array.prototype.slice.call( arguments, 0 );

      return new Promise( function( resolve, reject ){
        var callback = function( e ){
          self.off.apply( self, offArgs );

          resolve( e );
        };

        var onArgs = args.concat( [ callback ] );
        var offArgs = onArgs.concat( [] );

        self.on.apply( self, onArgs );
      } );
    };
  },

  off: function offImpl( params ){
    var defaults = {
    };
    params = util.extend( {}, defaults, params );

    return function( events, selector, callback ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );

      if( arguments.length === 0 ){ // then unbind all

        for( var i = 0; i < all.length; i++ ){
          all[ i ]._private = all[ i ]._private || {};

          _p.listeners = [];
        }

        return self; // maintain chaining
      }

      if( is.fn( selector ) || selector === false ){ // selector is actually callback
        callback = selector;
        selector = undefined;
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      var keys = Object.keys( events );

      for( var k = 0; k < keys.length; k++ ){
        var evts = keys[k];

        callback = events[ evts ];

        if( callback === false ){
          callback = define.event.falseCallback;
        }

        evts = evts.split( /\s+/ );
        for( var h = 0; h < evts.length; h++ ){
          var evt = evts[ h ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
          if( match ){
            var type = match[1] ? match[1] : undefined;
            var namespace = match[2] ? match[2] : undefined;

            for( var i = 0; i < all.length; i++ ){ //
              var _p = all[ i ]._private = all[ i ]._private || {};
              var listeners = _p.listeners = _p.listeners || [];

              for( var j = 0; j < listeners.length; j++ ){
                var listener = listeners[ j ];
                var nsMatches = !namespace || namespace === listener.namespace;
                var typeMatches = !type || listener.type === type;
                var cbMatches = !callback || callback === listener.callback;
                var listenerMatches = nsMatches && typeMatches && cbMatches;

                // delete listener if it matches
                if( listenerMatches ){
                  listeners.splice( j, 1 );
                  j--;
                }
              } // for listeners
            } // for all
          } // if match
        } // for events array

      } // for events map

      return self; // maintain chaining
    }; // function
  }, // off

  trigger: function( params ){
    var defaults = {};
    params = util.extend( {}, defaults, params );

    return function triggerImpl( events, extraParams, fnToTrigger ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var eventsIsString = is.string( events );
      var eventsIsObject = is.plainObject( events );
      var eventsIsEvent = is.event( events );
      var _p = this._private = this._private || {};
      var cy = _p.cy || ( is.core( this ) ? this : null );
      var hasCompounds = cy ? cy.hasCompoundNodes() : false;

      if( eventsIsString ){ // then make a plain event object for each event name
        var evts = events.split( /\s+/ );
        events = [];

        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[ i ];
          if( is.emptyString( evt ) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]
          var type = match[1];
          var namespace = match[2] ? match[2] : undefined;

          events.push( {
            type: type,
            namespace: namespace
          } );
        }
      } else if( eventsIsObject ){ // put in length 1 array
        var eventArgObj = events;

        events = [ eventArgObj ];
      }

      if( extraParams ){
        if( !is.array( extraParams ) ){ // make sure extra params are in an array if specified
          extraParams = [ extraParams ];
        }
      } else { // otherwise, we've got nothing
        extraParams = [];
      }

      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
        var evtObj = events[ i ];

        for( var j = 0; j < all.length; j++ ){ // for each
          var triggerer = all[ j ];
          var _p = triggerer._private = triggerer._private || {};
          var listeners = _p.listeners = _p.listeners || [];
          var triggererIsElement = is.element( triggerer );
          var bubbleUp = triggererIsElement || params.layout;

          // create the event for this element from the event object
          var evt;

          if( eventsIsEvent ){ // then just get the object
            evt = evtObj;

            evt.cyTarget = evt.cyTarget || triggerer;
            evt.cy = evt.cy || cy;

          } else { // then we have to make one
            evt = new Event( evtObj, {
              cyTarget: triggerer,
              cy: cy,
              namespace: evtObj.namespace
            } );
          }

          // if a layout was specified, then put it in the typed event
          if( evtObj.layout ){
            evt.layout = evtObj.layout;
          }

          // if triggered by layout, put in event
          if( params.layout ){
            evt.layout = triggerer;
          }

          // create a rendered position based on the passed position
          if( evt.cyPosition ){
            var pos = evt.cyPosition;
            var zoom = cy.zoom();
            var pan = cy.pan();

            evt.cyRenderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          if( fnToTrigger ){ // then override the listeners list with just the one we specified
            listeners = [ {
              namespace: evt.namespace,
              type: evt.type,
              callback: fnToTrigger
            } ];
          }

          for( var k = 0; k < listeners.length; k++ ){ // check each listener
            var lis = listeners[ k ];
            var nsMatches = !lis.namespace || lis.namespace === evt.namespace || lis.namespace === define.event.universalNamespace;
            var typeMatches = lis.type === evt.type;
            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element( evt.cyTarget ) && lis.selObj.matches( evt.cyTarget ) ) : (true); // we're not going to validate the hierarchy; that's too expensive
            var listenerMatches = nsMatches && typeMatches && targetMatches;

            if( listenerMatches ){ // then trigger it
              var args = [ evt ];
              args = args.concat( extraParams ); // add extra params to args list

              if( lis.data ){ // add on data plugged into binding
                evt.data = lis.data;
              } else { // or clear it in case the event obj is reused
                evt.data = undefined;
              }

              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                listeners.splice( k, 1 );
                k--;
              }

              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                var binders = lis.binders;
                for( var l = 0; l < binders.length; l++ ){
                  var binder = binders[ l ];
                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                  var binderListeners = binder._private.listeners;
                  for( var m = 0; m < binderListeners.length; m++ ){
                    var binderListener = binderListeners[ m ];

                    if( binderListener === lis ){ // delete listener from list
                      binderListeners.splice( m, 1 );
                      m--;
                    }
                  }
                }
              }

              // run the callback
              var context = lis.delegated ? evt.cyTarget : triggerer;
              var ret = lis.callback.apply( context, args );

              if( ret === false || evt.isPropagationStopped() ){
                // then don't bubble
                bubbleUp = false;

                if( ret === false ){
                  // returning false is a shorthand for stopping propagation and preventing the def. action
                  evt.stopPropagation();
                  evt.preventDefault();
                }
              }
            } // if listener matches
          } // for each listener

          // bubble up event for elements
          if( bubbleUp ){
            var parent = hasCompounds ? triggerer._private.parent : null;
            var hasParent = parent != null && parent.length !== 0;

            if( hasParent ){ // then bubble up to parent
              parent = parent[0];
              parent.trigger( evt );
            } else { // otherwise, bubble up to the core
              cy.trigger( evt );
            }
          }

        } // for each of all
      } // for each event

      return self; // maintain chaining
    }; // function
  }, // trigger

  animated: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animatedImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return false; }

      var ele = all[0];

      if( ele ){
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function clearQueueImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animate( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  delayAnimation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function delayAnimationImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animation( {
        delay: time,
        duration: time,
        complete: complete
      } );
    };
  }, // delay

  animation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animationImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if( !cy.styleEnabled() ){ return this; }

      var style = cy.style();

      properties = util.extend( {}, properties, params );

      if( properties.duration === undefined ){
        properties.duration = 400;
      }

      switch( properties.duration ){
      case 'slow':
        properties.duration = 600;
        break;
      case 'fast':
        properties.duration = 200;
        break;
      }

      var propertiesEmpty = Object.keys( properties ).length === 0;

      if( propertiesEmpty ){
        return new Animation( all[0], properties ); // nothing to animate
      }

      if( isEles ){
        properties.style = style.getPropsList( properties.style || properties.css );

        properties.css = undefined;
      }

      if( properties.renderedPosition && isEles ){
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = {
          x: ( rpos.x - pan.x ) / zoom,
          y: ( rpos.y - pan.y ) / zoom
        };
      }

      // override pan w/ panBy if set
      if( properties.panBy && isCore ){
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if( center && isCore ){
        var centerPan = cy.getCenterPan( center.eles, properties.zoom );

        if( centerPan ){
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if( properties.fit && isCore ){
        var fit = properties.fit;
        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

        if( fitVp ){
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      return new Animation( all[0], properties );
    };
  }, // animate

  animate: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function animateImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      if( params ){
        properties = util.extend( {}, properties, params );
      }

      // manually hook and run the animation
      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function( fnParams ){
    var defaults = {};
    fnParams = util.extend( {}, defaults, fnParams );

    return function stopImpl( clearQueue, jumpToEnd ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[ i ];
        var _p = ele._private;
        var anis = _p.animation.current;

        for( var j = 0; j < anis.length; j++ ){
          var ani = anis[ j ];
          var ani_p = ani._private;

          if( jumpToEnd ){
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if( clearQueue ){
          _p.animation.queue = [];
        }

        if( !jumpToEnd ){
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify( {
        eles: this,
        type: 'draw'
      } );

      return this;
    };
  } // stop

}; // define

module.exports = define;

},{"./animation":5,"./event":48,"./is":86,"./promise":89,"./selector":90,"./util":103}],48:[function(require,module,exports){
'use strict';

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function( src, props ){
  // Allow instantiation without the 'new' keyword
  if( !(this instanceof Event) ){
    return new Event( src, props );
  }

  // Event object
  if( src && src.type ){
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if( props ){
    // util.extend( this, props );

    // more efficient to manually copy fields we use
    this.type = props.type !== undefined ? props.type : this.type;
    this.cy = props.cy;
    this.cyTarget = props.cyTarget;
    this.cyPosition = props.cyPosition;
    this.cyRenderedPosition = props.cyRenderedPosition;
    this.namespace = props.namespace;
    this.layout = props.layout;
    this.data = props.data;
    this.message = props.message;
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();
};

function returnFalse(){
  return false;
}

function returnTrue(){
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function(){
    return 'event';
  },

  preventDefault: function(){
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if preventDefault exists run it on the original event
    if( e.preventDefault ){
      e.preventDefault();
    }
  },

  stopPropagation: function(){
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if( !e ){
      return;
    }

    // if stopPropagation exists run it on the original event
    if( e.stopPropagation ){
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function(){
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

},{}],49:[function(require,module,exports){
'use strict';

var util = require( './util' );
var define = require( './define' );
var Collection = require( './collection' );
var Core = require( './core' );
var incExts = require( './extensions' );
var is = require( './is' );

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension( type, name, registrant ){

  var ext = registrant;

  var overrideErr = function( field ){
    util.error( 'Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden' );
  };

  if( type === 'core' ){
    if( Core.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Core.prototype[ name ] = registrant;
    }

  } else if( type === 'collection' ){
    if( Collection.prototype[ name ] ){
      return overrideErr( name );
    } else {
      Collection.prototype[ name ] = registrant;
    }

  } else if( type === 'layout' ){
    // fill in missing layout functions in the prototype

    var Layout = function( options ){
      this.options = options;

      registrant.call( this, options );

      // make sure layout has _private for use w/ std apis like .on()
      if( !is.plainObject( this._private ) ){
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
    };

    var layoutProto = Layout.prototype = Object.create( registrant.prototype );

    var optLayoutFns = [];

    for( var i = 0; i < optLayoutFns.length; i++ ){
      var fnName = optLayoutFns[ i ];

      layoutProto[ fnName ] = layoutProto[ fnName ] || function(){ return this; };
    }

    // either .start() or .run() is defined, so autogen the other
    if( layoutProto.start && !layoutProto.run ){
      layoutProto.run = function(){ this.start(); return this; };
    } else if( !layoutProto.start && layoutProto.run ){
      layoutProto.start = function(){ this.run(); return this; };
    }

    var regStop = registrant.prototype.stop;
    layoutProto.stop = function(){
      var opts = this.options;

      if( opts && opts.animate ){
        var anis = this.animations;

        if( anis ){
          for( var i = 0; i < anis.length; i++ ){
            anis[ i ].stop();
          }
        }
      }

      if( regStop ){
        regStop.call( this );
      } else {
        this.trigger( 'layoutstop' );
      }

      return this;
    };

    if( !layoutProto.destroy ){
      layoutProto.destroy = function(){
        return this;
      };
    }

    layoutProto.on = define.on( { layout: true } );
    layoutProto.one = define.on( { layout: true, unbindSelfOnTrigger: true } );
    layoutProto.once = define.on( { layout: true, unbindAllBindersOnTrigger: true } );
    layoutProto.off = define.off( { layout: true } );
    layoutProto.trigger = define.trigger( { layout: true } );

    define.eventAliasesOn( layoutProto );

    ext = Layout; // replace with our wrapped layout

  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
    // user registered renderers inherit from base

    var BaseRenderer = getExtension( 'renderer', 'base' );
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function(){
      BaseRenderer.apply( this, arguments );
      RegistrantRenderer.apply( this, arguments );
    };

    var proto = Renderer.prototype;

    for( var pName in bProto ){
      var pVal = bProto[ pName ];
      var existsInR = rProto[ pName ] != null;

      if( existsInR ){
        return overrideErr( pName );
      }

      proto[ pName ] = pVal; // take impl from base
    }

    for( var pName in rProto ){
      proto[ pName ] = rProto[ pName ]; // take impl from registrant
    }

    bProto.clientFunctions.forEach( function( name ){
      proto[ name ] = proto[ name ] || function(){
        util.error( 'Renderer does not implement `renderer.' + name + '()` on its prototype' );
      };
    } );

    ext = Renderer;

  }

  return util.setMap( {
    map: extensions,
    keys: [ type, name ],
    value: ext
  } );
}

function getExtension( type, name ){
  return util.getMap( {
    map: extensions,
    keys: [ type, name ]
  } );
}

function setModule( type, name, moduleType, moduleName, registrant ){
  return util.setMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ],
    value: registrant
  } );
}

function getModule( type, name, moduleType, moduleName ){
  return util.getMap( {
    map: modules,
    keys: [ type, name, moduleType, moduleName ]
  } );
}

var extension = function(){
  // e.g. extension('renderer', 'svg')
  if( arguments.length === 2 ){
    return getExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if( arguments.length === 3 ){
    return setExtension.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
  else if( arguments.length === 4 ){
    return getModule.apply( null, arguments );
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
  else if( arguments.length === 5 ){
    return setModule.apply( null, arguments );
  }

  else {
    util.error( 'Invalid extension access syntax' );
  }

};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach( function( group ){
  group.extensions.forEach( function( ext ){
    setExtension( group.type, ext.name, ext.impl );
  } );
} );

module.exports = extension;

},{"./collection":29,"./core":40,"./define":47,"./extensions":50,"./is":86,"./util":103}],50:[function(require,module,exports){
'use strict';

module.exports = [
  {
    type: 'layout',
    extensions: require( './layout' )
  },

  {
    type: 'renderer',
    extensions: require( './renderer' )
  }
];

},{"./layout":56,"./renderer":81}],51:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );
var is = require( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function BreadthFirstLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

BreadthFirstLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );
  var graph = eles;

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var roots;
  if( is.elementOrCollection( options.roots ) ){
    roots = options.roots;
  } else if( is.array( options.roots ) ){
    var rootsArray = [];

    for( var i = 0; i < options.roots.length; i++ ){
      var id = options.roots[ i ];
      var ele = cy.getElementById( id );
      rootsArray.push( ele );
    }

    roots = cy.collection( rootsArray );
  } else if( is.string( options.roots ) ){
    roots = cy.$( options.roots );

  } else {
    if( options.directed ){
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      while( unhandledNodes.length > 0 ){
        var currComp = cy.collection();

        eles.bfs( {
          roots: unhandledNodes[0],
          visit: function( i, depth, node, edge, pNode ){
            currComp = currComp.add( node );
          },
          directed: false
        } );

        unhandledNodes = unhandledNodes.not( currComp );
        components.push( currComp );
      }

      roots = cy.collection();
      for( var i = 0; i < components.length; i++ ){
        var comp = components[ i ];
        var maxDegree = comp.maxDegree( false );
        var compRoots = comp.filter( function(){
          return this.degree( false ) === maxDegree;
        } );

        roots = roots.add( compRoots );
      }

    }
  }


  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs( {
    roots: roots,
    directed: options.directed,
    visit: function( i, depth, node, edge, pNode ){
      var ele = this[0];
      var id = ele.id();

      if( !depths[ depth ] ){
        depths[ depth ] = [];
      }

      depths[ depth ].push( ele );
      foundByBfs[ id ] = true;
      id2depth[ id ] = depth;
      prevNode[ id ] = pNode;
      prevEdge[ id ] = edge;

      if( pNode ){
        var prevId = pNode.id();
        var succ = successors[ prevId ] = successors[ prevId ] || [];

        succ.push( node );
      }
    }
  } );

  // check for nodes not found by bfs
  var orphanNodes = [];
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[ i ];

    if( foundByBfs[ ele.id() ] ){
      continue;
    } else {
      orphanNodes.push( ele );
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while( orphanNodes.length !== 0 && checks < maxChecks ){
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for( var i = 0; i < neighbors.length; i++ ){
      var depth = id2depth[ neighbors[ i ].id() ];

      if( depth !== undefined ){
        depths[ depth ].push( node );
        assignedDepth = true;
        break;
      }
    }

    if( !assignedDepth ){
      orphanNodes.push( node );
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while( orphanNodes.length !== 0 ){
    var node = orphanNodes.shift();
    //var subgraph = graph.bfs( node ).path;
    var assignedDepth = false;

    // for( var i = 0; i < subgraph.length; i++ ){
    //   var depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
      if( depths.length === 0 ){
        depths.push( [] );
      }

      depths[0].push( node );
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function(){
    for( var i = 0; i < depths.length; i++ ){
      var eles = depths[ i ];

      for( var j = 0; j < eles.length; j++ ){
        var ele = eles[ j ];

        ele._private.scratch.breadthfirst = {
          depth: i,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();


  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges( function(){
      return this.data( 'target' ) === node.id();
    } );
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther;
    for( var i = 0; i < edges.length; i++ ){
      var edge = edges[ i ];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

  // make maximal if so set by adjusting depths
  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

    var nDepths = depths.length;
    var elesToMove = [];
    for( var i = 0; i < nDepths; i++ ){
      var depth = depths[ i ];

      var nDepth = depth.length;
      for( var j = 0; j < nDepth; j++ ){
        var ele = depth[ j ];
        var info = ele._private.scratch.breadthfirst;
        var intEle = intersectsDepth( ele );

        if( intEle ){
          info.intEle = intEle;
          elesToMove.push( ele );
        }
      }
    }

    for( var i = 0; i < elesToMove.length; i++ ){
      var ele = elesToMove[ i ];
      var info = ele._private.scratch.breadthfirst;
      var intEle = info.intEle;
      var intInfo = intEle._private.scratch.breadthfirst;

      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while( newDepth > depths.length - 1 ){
        depths.push( [] );
      }
      depths[ newDepth ].push( ele );

      info.depth = newDepth;
      info.index = depths[ newDepth ].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if( options.avoidOverlap ){
    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[ i ];
      var nbb = n.boundingBox();
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max( minDistance, w, h );
    }
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function( ele ){
    if( cachedWeightedPercent[ ele.id() ] ){
      return cachedWeightedPercent[ ele.id() ];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not( ':parent' ).intersection(nodes);
    var percent = 0;
    var samples = 0;

    for( var i = 0; i < neighbors.length; i++ ){
      var neighbor = neighbors[ i ];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var depth = bf.depth;
      var nDepth = depths[ depth ].length;

      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max( 1, samples );
    percent = percent / samples;

    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ ele.id() ] = percent;
    return percent;
  };


  // rearrange the indices in each depth level based on connectivity

  var sortFn = function( a, b ){
    var apct = getWeightedPercent( a );
    var bpct = getWeightedPercent( b );

    return apct - bpct;
  };

  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

    for( var i = 0; i < depths.length; i++ ){
      depths[ i ] = depths[ i ].sort( sortFn );
    }
    assignDepthsToEles(); // and update

  }

  var biggestDepthSize = 0;
  for( var i = 0; i < depths.length; i++ ){
    biggestDepthSize = Math.max( depths[ i ].length, biggestDepthSize );
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };

  var getPosition = function( ele, isBottomDepth ){
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[ depth ].length;

    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
    radiusStepSize = Math.max( radiusStepSize, minDistance );

    if( !options.circle ){

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if( isBottomDepth ){
        return epos;
      }

      // var succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( var i = 0 ; i < succs.length; i++ ){
      //     var spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;

    } else {
      if( options.circle ){
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
        var theta = 2 * Math.PI / depths[ depth ].length * index;

        if( depth === 0 && depths[0].length === 1 ){
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos( theta ),
          y: center.y + radius * Math.sin( theta )
        };

      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }

  };

  // get positions in reverse depth order
  var pos = {};
  for( var i = depths.length - 1; i >= 0; i-- ){
    var depth = depths[ i ];

    for( var j = 0; j < depth.length; j++ ){
      var node = depth[ j ];

      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
    }
  }

  nodes.layoutPositions( this, options, function(){
    return pos[ this.id() ];
  } );

  return this; // chaining
};

module.exports = BreadthFirstLayout;

},{"../../is":86,"../../math":88,"../../util":103}],52:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );
var is = require( '../../is' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined, // the radius of the circle
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function CircleLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

CircleLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;

  var dTheta = sweep / ( Math.max( 1, nodes.length - 1 ) );
  var r;

  var minDistance = 0;
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max( minDistance, w, h );
  }

  if( is.number( options.radius ) ){
    r = options.radius;
  } else if( nodes.length <= 1 ){
    r = 0;
  } else {
    r = Math.min( bb.h, bb.w ) / 2 - minDistance;
  }

  // calculate the radius
  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos( dTheta ) - Math.cos( 0 );
    var dsin = Math.sin( dTheta ) - Math.sin( 0 );
    var rMin = Math.sqrt( minDistance * minDistance / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping
    r = Math.max( rMin, r );
  }

  var getPos = function( i, ele ){
    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );

    var rx = r * Math.cos( theta );
    var ry = r * Math.sin( theta );
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = CircleLayout;

},{"../../is":86,"../../math":88,"../../util":103}],53:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up  
  concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function( nodes ){ // the variation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function ConcentricLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

ConcentricLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var value;

    // calculate the node value
    value = options.concentric.apply( node, [ node ] );
    nodeValues.push( {
      value: value,
      node: node
    } );

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var nbb = node.boundingBox();

    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
  }

  // sort node values in descreasing order
  nodeValues.sort( function( a, b ){
    return b.value - a.value;
  } );

  var levelWidth = options.levelWidth( nodes );

  // put the values into levels
  var levels = [ [] ];
  var currentLevel = levels[0];
  for( var i = 0; i < nodeValues.length; i++ ){
    var val = nodeValues[ i ];

    if( currentLevel.length > 0 ){
      var diff = Math.abs( currentLevel[0].value - val.value );

      if( diff >= levelWidth ){
        currentLevel = [];
        levels.push( currentLevel );
      }
    }

    currentLevel.push( val );
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if( !options.avoidOverlap ){ // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = ( Math.min( bb.w, bb.h ) / 2 - minDist );
    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

    minDist = Math.min( minDist, rStep );
  }

  // find the metrics for each level
  var r = 0;
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / ( Math.max( 1, level.length - 1 ) );

    // calculate the radius
    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      var dcos = Math.cos( dTheta ) - Math.cos( 0 );
      var dsin = Math.sin( dTheta ) - Math.sin( 0 );
      var rMin = Math.sqrt( minDist * minDist / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping

      r = Math.max( rMin, r );
    }

    level.r = r;

    r += minDist;
  }

  if( options.equidistant ){
    var rDeltaMax = 0;
    var r = 0;

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];
      var rDelta = level.r - r;

      rDeltaMax = Math.max( rDeltaMax, rDelta );
    }

    r = 0;
    for( var i = 0; i < levels.length; i++ ){
      var level = levels[ i ];

      if( i === 0 ){
        r = level.r;
      }

      level.r = r;

      r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[ i ];
    var dTheta = level.dTheta;
    var r = level.r;

    for( var j = 0; j < level.length; j++ ){
      var val = level[ j ];
      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;

      var p = {
        x: center.x + r * Math.cos( theta ),
        y: center.y + r * Math.sin( theta )
      };

      pos[ val.node.id() ] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions( this, options, function(){
    var id = this.id();

    return pos[ id ];
  } );

  return this; // chaining
};

module.exports = ConcentricLayout;

},{"../../math":88,"../../util":103}],54:[function(require,module,exports){
'use strict';

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = require( '../../util' );
var math = require( '../../math' );
var Thread = require( '../../thread' );
var is = require( '../../is' );

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready: function(){},

  // Called on `layoutstop`
  stop: function(){},

  // Whether to animate while running the layout
  animate: true,

  // The layout animates only after this many milliseconds
  // (prevents flashing on fast runs)
  animationThreshold: 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh: 20,

  // Whether to fit the network view after when done
  fit: true,

  // Padding on fit
  padding: 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,

  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,

  // Extra spacing between components in non-compound graphs
  componentSpacing: 100,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function( node ){ return 400000; },

  // Node repulsion (overlapping) multiplier
  nodeOverlap: 10,

  // Ideal edge (non nested) length
  idealEdgeLength: function( edge ){ return 10; },

  // Divisor to compute edge forces
  edgeElasticity: function( edge ){ return 100; },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 5,

  // Gravity force (constant)
  gravity: 80,

  // Maximum number of iterations to perform
  numIter: 1000,

  // Initial temperature (maximum node displacement)
  initialTemp: 200,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.95,

  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0,

  // Whether to use threading to speed up the layout
  useMultitasking: true,

  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  spacingFactor: undefined
};


/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout( options ){
  this.options = util.extend( {}, defaults, options );

  this.options.layout = this;
}


/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function(){
  var options = this.options;
  var cy      = options.cy;
  var layout  = this;
  var thread  = this.thread;

  if( !thread || thread.stopped() ){
    thread = this.thread = Thread( { disabled: !options.useMultitasking } );
  }

  layout.stopped = false;

  layout.trigger( { type: 'layoutstart', layout: layout } );

  // Set DEBUG - Global variable
  if( true === options.debug ){
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo( cy, layout, options );

  // Show LayoutInfo contents if debugging
  if( DEBUG ){
    printLayoutInfo( layoutInfo );
  }

  // If required, randomize node positions
  if (options.randomize) {
    randomizePositions( layoutInfo, cy );
  }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function( rOpts ){
    rOpts = rOpts || {};

    if( refreshRequested && !rOpts.next ){
      return;
    }

    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame( function(){
      refreshPositions( layoutInfo, cy, options );

      // Fit the graph if necessary
      if( true === options.fit ){
        cy.fit( options.padding );
      }

      refreshRequested = false;

      if( rOpts.next ){ rOpts.next(); }
    });
  };

  thread.on( 'message', function( e ){
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  } );

  thread.pass( {
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  } ).run( function( pass ){
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function( layoutInfo, options, step ){
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces( layoutInfo, options );
      // Calculate edge forces
      calculateEdgeForces( layoutInfo, options );
      // Calculate gravity forces
      calculateGravityForces( layoutInfo, options );
      // Propagate forces from parent to child
      propagateForces( layoutInfo, options );
      // Update positions based on calculated forces
      updatePositions( layoutInfo, options );
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function( layoutInfo, options ){
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for( var j = 0; j < numNodes; j++ ){
          var node1 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];

          for( var k = j + 1; k < numNodes; k++ ){
            var node2 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ k ] ] ];

            nodeRepulsion( node1, node2, layoutInfo, options );
          }
        }
      }
    };

    var randomDistance = function( max ){
      return -max + 2 * max * Math.random();
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function( node1, node2, layoutInfo, options ){
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if( 0 === directionX && 0 === directionY ){
        directionX = randomDistance( maxRandDist );
        directionY = randomDistance( maxRandDist );
      }

      var overlap = nodesOverlap( node1, node2, directionX, directionY );

      if( overlap > 0 ){
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force    = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt( directionX * directionX + directionY * directionY );
        // s += "\nDistance: " + distance;
        var forceX   = force * directionX / distance;
        var forceY   = force * directionY / distance;

      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint( node1, directionX, directionY );
        var point2 = findClippingPoint( node2, -1 * directionX, -1 * directionY );

        // Use clipping points to compute distance
        var distanceX   = point2.x - point1.x;
        var distanceY   = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance    = Math.sqrt( distanceSqr );
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if( !node1.isLocked ){
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if( !node2.isLocked ){
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function( node1, node2, dX, dY ){

      if( dX > 0 ){
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if( dY > 0 ){
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if( overlapX >= 0 && overlapY >= 0 ){
        return Math.sqrt( overlapX * overlapX + overlapY * overlapY );
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function( node, dX, dY ){

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope     = dY / dX;
      var nodeSlope    = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};
      do {
        // Case: Vertical direction (up)
        if( 0 === dX && 0 < dY ){
          res.x = X;
          // s += "\nUp direction";
          res.y = Y + H / 2;
          break;
        }

        // Case: Vertical direction (down)
        if( 0 === dX && 0 > dY ){
          res.x = X;
          res.y = Y + H / 2;
          // s += "\nDown direction";
          break;
        }

        // Case: Intersects the right border
        if( 0 < dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope ){
          res.x = X + W / 2;
          res.y = Y + (W * dY / 2 / dX);
          // s += "\nRightborder";
          break;
        }

        // Case: Intersects the left border
        if( 0 > dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope ){
          res.x = X - W / 2;
          res.y = Y - (W * dY / 2 / dX);
          // s += "\nLeftborder";
          break;
        }

        // Case: Intersects the top border
        if( 0 < dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope ) ){
          res.x = X + (H * dX / 2 / dY);
          res.y = Y + H / 2;
          // s += "\nTop border";
          break;
        }

        // Case: Intersects the bottom border
        if( 0 > dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope ) ){
          res.x = X - (H * dX / 2 / dY);
          res.y = Y - H / 2;
          // s += "\nBottom border";
          break;
        }

      } while( false);

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function( layoutInfo, options ){
      // Iterate over all edges
      for( var i = 0; i < layoutInfo.edgeSize; i++ ){
        // Get edge, source & target nodes
        var edge     = layoutInfo.layoutEdges[ i ];
        var sourceIx = layoutInfo.idToIndex[ edge.sourceId ];
        var source   = layoutInfo.layoutNodes[ sourceIx ];
        var targetIx = layoutInfo.idToIndex[ edge.targetId ];
        var target   = layoutInfo.layoutNodes[ targetIx ];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if( 0 === directionX && 0 === directionY ){
          return;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint( source, directionX, directionY );
        var point2 = findClippingPoint( target, -1 * directionX, -1 * directionY );


        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l  = Math.sqrt( lx * lx + ly * ly );

        var force  = Math.pow( edge.idealLength - l, 2 ) / edge.elasticity;

        if( 0 !== l ){
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if( !source.isLocked ){
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if( !target.isLocked ){
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function( layoutInfo, options ){
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){
        var graph    = layoutInfo.graphSet[ i ];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if( 0 === i ){
          var centerX   = layoutInfo.clientHeight / 2;
          var centerY   = layoutInfo.clientWidth  / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp    = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[0] ] ];
          var parent  = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ temp.parentId ] ];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for( var j = 0; j < numNodes; j++ ){
          var node = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];
          // s = "Node: " + node.id;

          if( node.isLocked ){ continue; }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d  = Math.sqrt( dx * dx + dy * dy );
          if( d > distThreshold ){
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {
            // s += ": skypped since it's too close to center";
          }
          // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function( layoutInfo, options ){
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0;   // Points to the start the queue
      var end   = -1;  // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply( queue, layoutInfo.graphSet[0] );
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while( start <= end ){
        // Get the node to visit and remove it from queue
        var nodeId    = queue[ start++ ];
        var nodeIndex = layoutInfo.idToIndex[ nodeId ];
        var node      = layoutInfo.layoutNodes[ nodeIndex ];
        var children  = node.children;

        // We only need to process the node if it's compound
        if( 0 < children.length && !node.isLocked ){
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for( var i = 0; i < children.length; i++ ){
            var childNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ children[ i ] ] ];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[ ++end ] = children[ i ];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }

      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function( layoutInfo, options ){
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length ){
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length || n.isLocked ){
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce( n.offsetX, n.offsetY, layoutInfo.temperature );
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX    = n.positionX - n.width;
        n.maxX    = n.positionX + n.width;
        n.minY    = n.positionY - n.height;
        n.maxY    = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries( n, layoutInfo );
      }

      // Update size, position of compund nodes
      for( var i = 0; i < layoutInfo.nodeSize; i++ ){
        var n = layoutInfo.layoutNodes[ i ];
        if( 0 < n.children.length && !n.isLocked ){
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width     = n.maxX - n.minX;
          n.height    = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function( forceX, forceY, max ){
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt( forceX * forceX + forceY * forceY );

      if( force > max ){
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };

      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function( node, layoutInfo ){
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if( null == parentId ){
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ parentId ] ];
      var flag = false;

      // MaxX
      if( null == p.maxX || node.maxX + p.padRight > p.maxX ){
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if( null == p.minX || node.minX - p.padLeft < p.minX ){
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if( null == p.maxY || node.maxY + p.padBottom > p.maxY ){
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if( null == p.minY || node.minY - p.padTop < p.minY ){
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if( flag ){
        // logDebug(s);
        return updateAncestryBoundaries( p, layoutInfo );
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function( layutInfo, options ){
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var cid = node.cmptId;
        var component = components[ cid ] = components[ cid ] || [];

        component.push( node );
      }

      var totalA = 0;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          c.x1 = Math.min( c.x1, n.positionX - n.width / 2 );
          c.x2 = Math.max( c.x2, n.positionX + n.width / 2 );
          c.y1 = Math.min( c.y1, n.positionY - n.height / 2 );
          c.y2 = Math.max( c.y2, n.positionY + n.height / 2 );
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort( function( c1, c2 ){
        return c2.w * c2.h - c1.w * c1.h;
      } );

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for( var i = 0; i < components.length; i++ ){
        var c = components[ i ];

        if( !c ){ continue; }

        for( var j = 0; j < c.length; j++ ){
          var n = c[ j ];

          if( !n.isLocked ){
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max( rowH, c.h );

        if( usedW > maxRowW ){
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function( i ){
      if( stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step( layoutInfo, options, i );

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if( layoutInfo.temperature < options.minTemp ){
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while( f < options.refresh && i < options.numIter ){
        var loopRet = mainLoop( i );
        if( !loopRet ){ break; }

        f++;
        i++;
      }

      if( options.animate ){
        broadcast( layoutInfo.layoutNodes ); // eslint-disable-line no-undef
      }

    } while( loopRet && i + 1 < options.numIter );

    separateComponents( layoutInfo, options );

    return layoutInfo;
  } ).then( function( layoutInfoUpdated ){
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  } );

  var done = function(){
    refresh({
      force: true,
      next: function(){
        // Layout has finished
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }
    });
  };

  return this; // chaining
};


/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function(){
  this.stopped = true;

  if( this.thread ){
    this.thread.stop();
  }

  this.trigger( 'layoutstop' );

  return this; // chaining
};

CoseLayout.prototype.destroy = function(){
  if( this.thread ){
    this.thread.stop();
  }

  return this; // chaining
};


/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function( cy, layout, options ){
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo   = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
                   } )
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for( var i = 0; i < components.length; i++ ){
    var component = components[ i ];

    for( var j = 0; j < component.length; j++ ){
      var node = component[ j ];

      id2cmptId[ node.id() ] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = nodes[ i ];
    var nbb = n.boundingBox();

    var tempNode        = {};
    tempNode.isLocked   = n.locked();
    tempNode.id         = n.data( 'id' );
    tempNode.parentId   = n.data( 'parent' );
    tempNode.cmptId     = id2cmptId[ n.id() ];
    tempNode.children   = [];
    tempNode.positionX  = n.position( 'x' );
    tempNode.positionY  = n.position( 'y' );
    tempNode.offsetX    = 0;
    tempNode.offsetY    = 0;
    tempNode.height     = nbb.w;
    tempNode.width      = nbb.h;
    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft    = parseFloat( n.style( 'padding' ) );
    tempNode.padRight   = parseFloat( n.style( 'padding' ) );
    tempNode.padTop     = parseFloat( n.style( 'padding' ) );
    tempNode.padBottom  = parseFloat( n.style( 'padding' ) );

    // forces
    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push( tempNode );
    // Add entry to id-index map
    layoutInfo.idToIndex[ tempNode.id ] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0;   // Points to the start the queue
  var end   = -1;  // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if( null != p_id ){
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[ layoutInfo.idToIndex[ p_id ] ].children.push( n.id );
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[ ++end ] = n.id;
      tempGraph.push( n.id );
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push( tempGraph );

  // Traverse the graph, level by level,
  while( start <= end ){
    // Get the node to visit and remove it from queue
    var node_id  = queue[ start++ ];
    var node_ix  = layoutInfo.idToIndex[ node_id ];
    var node     = layoutInfo.layoutNodes[ node_ix ];
    var children = node.children;
    if( children.length > 0 ){
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push( children );
      // Add children to que queue to be visited
      for( var i = 0; i < children.length; i++ ){
        queue[ ++end ] = children[ i ];
      }
    }
  }

  // Create indexToGraph map
  for( var i = 0; i < layoutInfo.graphSet.length; i++ ){
    var graph = layoutInfo.graphSet[ i ];
    for( var j = 0; j < graph.length; j++ ){
      var index = layoutInfo.idToIndex[ graph[ j ] ];
      layoutInfo.indexToGraph[ index ] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for( var i = 0; i < layoutInfo.edgeSize; i++ ){
    var e = edges[ i ];
    var tempEdge = {};
    tempEdge.id       = e.data( 'id' );
    tempEdge.sourceId = e.data( 'source' );
    tempEdge.targetId = e.data( 'target' );

    // Compute ideal length
    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;
    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx    = layoutInfo.idToIndex[ tempEdge.sourceId ];
    var targetIx    = layoutInfo.idToIndex[ tempEdge.targetId ];
    var sourceGraph = layoutInfo.indexToGraph[ sourceIx ];
    var targetGraph = layoutInfo.indexToGraph[ targetIx ];

    if( sourceGraph != targetGraph ){
      // Find lowest common graph ancestor
      var lca = findLCA( tempEdge.sourceId, tempEdge.targetId, layoutInfo );

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[ lca ];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[ sourceIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[ targetIx ];
      while( -1 === lcaGraph.indexOf( tempNode.id ) ){
        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push( tempEdge );
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};


/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function( node1, node2, layoutInfo ){
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux( node1, node2, 0, layoutInfo );
  if( 2 > res.count ){
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};


/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function( node1, node2, graphIx, layoutInfo ){
  var graph = layoutInfo.graphSet[ graphIx ];
  // If both nodes belongs to graphIx
  if( -1 < graph.indexOf( node1 ) && -1 < graph.indexOf( node2 ) ){
    return {count: 2, graph: graphIx};
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for( var i = 0; i < graph.length; i++ ){
    var nodeId   = graph[ i ];
    var nodeIx   = layoutInfo.idToIndex[ nodeId ];
    var children = layoutInfo.layoutNodes[ nodeIx ].children;

    // If the node has no child, skip it
    if( 0 === children.length ){
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[ layoutInfo.idToIndex[ children[0] ] ];
    var result = findLCA_aux( node1, node2, childGraphIx, layoutInfo );
    if( 0 === result.count ){
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if( 1 === result.count ){
      // One of (node1, node2) is present in this subgraph
      c++;
      if( 2 === c ){
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {count: c, graph: graphIx};
};


/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function( layoutInfo ){
  /* eslint-disable */

  if( !DEBUG ){
    return;
  }
  console.debug( 'layoutNodes:' );
  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];
    var s =
    '\nindex: '     + i +
    '\nId: '        + n.id +
    '\nChildren: '  + n.children.toString() +
    '\nparentId: '  + n.parentId  +
    '\npositionX: ' + n.positionX +
    '\npositionY: ' + n.positionY +
    '\nOffsetX: ' + n.offsetX +
    '\nOffsetY: ' + n.offsetY +
    '\npadLeft: ' + n.padLeft +
    '\npadRight: ' + n.padRight +
    '\npadTop: ' + n.padTop +
    '\npadBottom: ' + n.padBottom;

    console.debug( s );
  }

  console.debug( 'idToIndex' );
  for( var i in layoutInfo.idToIndex ){
    console.debug( 'Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[ i ] );
  }

  console.debug( 'Graph Set' );
  var set = layoutInfo.graphSet;
  for( var i = 0; i < set.length; i ++ ){
    console.debug( 'Set : ' + i + ': ' + set[ i ].toString() );
  }

  var s = 'IndexToGraph';
  for( var i = 0; i < layoutInfo.indexToGraph.length; i ++ ){
    s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[ i ];
  }
  console.debug( s );

  s = 'Layout Edges';
  for( var i = 0; i < layoutInfo.layoutEdges.length; i++ ){
    var e = layoutInfo.layoutEdges[ i ];
    s += '\nEdge Index: ' + i + ' ID: ' + e.id +
    ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId +
    ' Ideal Length: ' + e.idealLength;
  }
  console.debug( s );

  s =  'nodeSize: ' + layoutInfo.nodeSize;
  s += '\nedgeSize: ' + layoutInfo.edgeSize;
  s += '\ntemperature: ' + layoutInfo.temperature;
  console.debug( s );

  return;
  /* eslint-enable */
};


/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function( layoutInfo, cy ){
  var width     = layoutInfo.clientWidth;
  var height    = layoutInfo.clientHeight;

  for( var i = 0; i < layoutInfo.nodeSize; i++ ){
    var n = layoutInfo.layoutNodes[ i ];

    // No need to randomize compound nodes or locked nodes
    if( 0 === n.children.length && !n.isLocked ){
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};


/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function( layoutInfo, cy, options ){
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if( options.boundingBox ){
    nodes.forEach( function( node ){
      var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ node.data( 'id' ) ] ];

      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
    } );

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions( function( i, ele ){
    var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ ele.data( 'id' ) ] ];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if( options.boundingBox ){ // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  } );

  // Trigger layoutReady only on first call
  if( true !== layoutInfo.ready ){
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one( 'layoutready', options.ready );
    layout.trigger( { type: 'layoutready', layout: this } );
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

},{"../../is":86,"../../math":88,"../../thread":101,"../../util":103}],55:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function( node ){}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function GridLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

GridLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  if( bb.h === 0 || bb.w === 0 ){
    nodes.layoutPositions( this, options, function(){
      return { x: bb.x1, y: bb.y1 };
    } );

  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt( cells * bb.h / bb.w );
    var rows = Math.round( splits );
    var cols = Math.round( bb.w / bb.h * splits );

    var small = function( val ){
      if( val == null ){
        return Math.min( rows, cols );
      } else {
        var min = Math.min( rows, cols );
        if( min == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function( val ){
      if( val == null ){
        return Math.max( rows, cols );
      } else {
        var max = Math.max( rows, cols );
        if( max == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if( oRows != null && oCols != null ){
      rows = oRows;
      cols = oCols;
    } else if( oRows != null && oCols == null ){
      rows = oRows;
      cols = Math.ceil( cells / rows );
    } else if( oRows == null && oCols != null ){
      cols = oCols;
      rows = Math.ceil( cells / cols );
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if( cols * rows > cells ){
      var sm = small();
      var lg = large();

      // reducing the small side takes away the most cells, so try it first
      if( (sm - 1) * lg >= cells ){
        small( sm - 1 );
      } else if( (lg - 1) * sm >= cells ){
        large( lg - 1 );
      }
    } else {

      // if rounding was too low, add rows or columns
      while( cols * rows < cells ){
        var sm = small();
        var lg = large();

        // try to add to larger side first (adds less in multiplication)
        if( (lg + 1) * sm >= cells ){
          large( lg + 1 );
        } else {
          small( sm + 1 );
        }
      }
    }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if( options.condense ){
      cellWidth = 0;
      cellHeight = 0;
    }

    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[ i ];
        var pos = node._private.position;

        if( pos.x == null || pos.y == null ){ // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.boundingBox();
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max( cellWidth, w );
        cellHeight = Math.max( cellHeight, h );
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function( row, col ){
      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;
    };

    var use = function( row, col ){
      cellUsed[ 'c-' + row + '-' + col ] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function(){
      col++;
      if( col >= cols ){
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[ i ];
      var rcPos = options.position( node );

      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
        var pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if( pos.col === undefined ){ // find unused col
          pos.col = 0;

          while( used( pos.row, pos.col ) ){
            pos.col++;
          }
        } else if( pos.row === undefined ){ // find unused row
          pos.row = 0;

          while( used( pos.row, pos.col ) ){
            pos.row++;
          }
        }

        id2manPos[ node.id() ] = pos;
        use( pos.row, pos.col );
      }
    }

    var getPos = function( i, element ){
      var x, y;

      if( element.locked() || element.isParent() ){
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[ element.id() ];
      if( rcPos ){
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;

      } else { // otherwise set automatically

        while( used( row, col ) ){
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use( row, col );

        moveToNextCell();
      }

      return { x: x, y: y };

    };

    nodes.layoutPositions( this, options, getPos );
  }

  return this; // chaining

};

module.exports = GridLayout;

},{"../../math":88,"../../util":103}],56:[function(require,module,exports){
'use strict';

module.exports = [
  { name: 'breadthfirst', impl: require( './breadthfirst' ) },
  { name: 'circle', impl: require( './circle' ) },
  { name: 'concentric',impl: require( './concentric' ) },
  { name: 'cose', impl: require( './cose' ) },
  { name: 'grid', impl: require( './grid' ) },
  { name: 'null', impl: require( './null' ) },
  { name: 'preset', impl: require( './preset' ) },
  { name: 'random', impl: require( './random' ) }
];

},{"./breadthfirst":51,"./circle":52,"./concentric":53,"./cose":54,"./grid":55,"./null":57,"./preset":58,"./random":59}],57:[function(require,module,exports){
'use strict';

var util = require( '../../util' );

// default layout options
var defaults = {
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

// runs the layout
NullLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.trigger( 'layoutstart' );

  // puts all nodes at (0, 0)
  eles.nodes().positions( function(){
    return {
      x: 0,
      y: 0
    };
  } );

  // trigger layoutready when each node has had its position set at least once
  layout.one( 'layoutready', options.ready );
  layout.trigger( 'layoutready' );

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one( 'layoutstop', options.stop );
  layout.trigger( 'layoutstop' );

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function(){
  return this; // chaining
};

module.exports = NullLayout;

},{"../../util":103}],58:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var is = require( '../../is' );

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function PresetLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

PresetLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn( options.positions );

  function getPosition( node ){
    if( options.positions == null ){
      return null;
    }

    if( posIsFn ){
      return options.positions.apply( node, [ node ] );
    }

    var pos = options.positions[ node._private.data.id ];

    if( pos == null ){
      return null;
    }

    return pos;
  }

  nodes.layoutPositions( this, options, function( i, node ){
    var position = getPosition( node );

    if( node.locked() || position == null ){
      return false;
    }

    return position;
  } );

  return this; // chaining
};

module.exports = PresetLayout;

},{"../../is":86,"../../util":103}],59:[function(require,module,exports){
'use strict';

var util = require( '../../util' );
var math = require( '../../math' );

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function RandomLayout( options ){
  this.options = util.extend( {}, defaults, options );
}

RandomLayout.prototype.run = function(){
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not( ':parent' );

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var getPos = function( i, node ){
    return {
      x: bb.x1 + Math.round( Math.random() * bb.w ),
      y: bb.y1 + Math.round( Math.random() * bb.h )
    };
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = RandomLayout;

},{"../../math":88,"../../util":103}],60:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var is = require( '../../../is' );
var util = require( '../../../util' );

var BRp = {};

BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function(){
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function( x, y, size, angle, translation, padding ){
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;

    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);

    return inside;
  };

  var transform = function( x, y, size, angle, translation ){
    var xRotated = x * Math.cos( angle ) - y * Math.sin( angle );
    var yRotated = x * Math.sin( angle ) + y * Math.cos( angle );

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function( pts, size, angle, translation ){
    var retPts = [];

    for( var i = 0; i < pts.length; i += 2 ){
      var x = pts[ i ];
      var y = pts[ i + 1];

      retPts.push( transform( x, y, size, angle, translation ) );
    }

    return retPts;
  };

  var pointsToArr = function( pts ){
    var ret = [];

    for( var i = 0; i < pts.length; i++ ){
      var p = pts[ i ];

      ret.push( p.x, p.y );
    }

    return ret;
  };

  var standardGap = function( edge ) {
    return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).pfValue * 2;
  };

  var defineArrowShape = function( name, defn ){
    if( is.string( defn ) ){
      defn = arrowShapes[ defn ];
    }

    arrowShapes[ name ] = util.extend( {
      name: name,

      points: [
        -0.15, -0.3,
        0.15, -0.3,
        0.15, 0.3,
        -0.15, 0.3
      ],

      collide: function( x, y, size, angle, translation, padding ){
        var points = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
        var inside = math.pointInsidePolygonPoints( x, y, points );

        return inside;
      },

      roughCollide: bbCollide,

      draw: function( context, size, angle, translation ){
        var points = transformPoints( this.points, size, angle, translation );

        renderer.arrowShapeImpl( 'polygon' )( context, points );
      },

      spacing: function( edge ){
        return 0;
      },

      gap: standardGap
    }, defn );
  };

  defineArrowShape( 'none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  } );

  defineArrowShape( 'triangle', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ]
  } );

  defineArrowShape( 'arrow', 'triangle' );

  defineArrowShape( 'triangle-backcurve', {
    points: arrowShapes[ 'triangle' ].points,

    controlPoint: [ 0, -0.15 ],

    roughCollide: bbCollide,

    draw: function( context, size, angle, translation ){
      var ptsTrans = transformPoints( this.points, size, angle, translation );
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
    },

    gap: function( edge ) {
      return standardGap(edge) * 0.985;
    }
  } );


  defineArrowShape( 'triangle-tee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      var triPts = transformPoints( this.points, size, angle, translation );
      var teePts = transformPoints( this.pointsTee, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
    }
  } );

  defineArrowShape( 'triangle-cross', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    crossLinePoints: [
      -0.24175, -0.4,
      0.24175, -0.4,
    ],

    forceStroke: true,

    matchEdgeWidth: true,

    scaleCoord: function ( constant, size, edgeWidth ){
     return constant + ( edgeWidth * 0.012 ) + ( math.log2( size - 28.95 ) * 0.001 );
    },

   scaleCrossLineXCoord: function( size, edgeWidth ){
      return this.scaleCoord( 0.42, size, edgeWidth );
    },

    scaleCrossLineYCoord: function( size, edgeWidth ){
      return this.scaleCoord( -0.01, size, edgeWidth );
    },

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );
      var crossLinePts = pointsToArr( transformPoints( this.crossLinePoints, size + 2 * padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts )
      || math.inLineVicinity( x, y,
        crossLinePts[0], crossLinePts[1], crossLinePts[2], crossLinePts[3], padding );

      return inside;
    },

    draw: function( context, size, angle, translation, edgeWidth ){
      var scaledCrossLine = [
        this.crossLinePoints[0] + this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[1] - this.scaleCrossLineYCoord( size, edgeWidth ),
        this.crossLinePoints[2] - this.scaleCrossLineXCoord( size, edgeWidth ),
        this.crossLinePoints[3] - this.scaleCrossLineYCoord( size, edgeWidth )
      ];
      var triPts = transformPoints( this.points, size, angle, translation );
      var crossLinePts = transformPoints( scaledCrossLine, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, crossLinePts );
    }
  } );

  defineArrowShape( 'vee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      0, -0.15
    ],

    gap: function( edge ){
      return standardGap(edge) * 0.985;
    }
  } );

  defineArrowShape( 'circle', {
    radius: 0.15,

    collide: function( x, y, size, angle, translation, padding ){
      var t = translation;
      var inside = ( Math.pow( t.x - x, 2 ) + Math.pow( t.y - y, 2 ) <= Math.pow( (size + 2 * padding) * this.radius, 2 ) );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
    },

    spacing: function( edge ){
      return renderer.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.radius;
    }
  } );

  defineArrowShape( 'inhibitor', {
    points: [
      -0.15, 0,
      -0.15, -0.1,
      0.15, -0.1,
      0.15, 0
    ],

    spacing: function( edge ){
      return 1;
    },

    gap: function( edge ){
      return 1;
    }
  } );

  defineArrowShape( 'tee', 'inhibitor' );

  defineArrowShape( 'square', {
    points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ]
  } );

  defineArrowShape( 'diamond', {
    points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    gap: function( edge ){
      return edge.pstyle( 'width' ).pfValue * edge.pstyle( 'arrow-scale' ).value;
    }
  } );

};

module.exports = BRp;

},{"../../../is":86,"../../../math":88,"../../../util":103}],61:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var is = require( '../../../is' );
var util = require( '../../../util' );
var zIndexSort = require( '../../../collection/zsort' );
var window = require( '../../../window' );

var BRp = {};

BRp.registerCalculationListeners = function(){
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function( eles, e ){
    elesToUpdate.merge( eles );

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var rstyle = _p.rstyle;

      rstyle.clean = false;
      _p.bbCache = null;

      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

      if( !evts[ e.type ] ){
        evts[ e.type ] = true;
        evts.length++;
//
        // elesToUpdate.merge( ele );
      }
    }
  };

  r.binder( cy )
    // nodes

    .on('position.* style.* free.*', 'node', function onDirtyModNode( e ){
      var node = e.cyTarget;

      enqueue( node, e );
      enqueue( node.connectedEdges(), e );

      if( cy.hasCompoundNodes() ){
        var parents = node.parents();

        enqueue( parents, e );
        enqueue( parents.connectedEdges(), e );
      }
    })

    .on('add.* background.*', 'node', function onDirtyAddNode( e ){
      var ele = e.cyTarget;

      enqueue( ele, e );
    })

    // edges

    .on('add.* style.*', 'edge', function onDirtyEdge( e ){
      var edge = e.cyTarget;

      enqueue( edge, e );
      enqueue( edge.parallelEdges(), e );
    })

    .on('remove.*', 'edge', function onDirtyRemoveEdge( e ){
      var edge = e.cyTarget;
      var pEdges = edge.parallelEdges();

      for( var i = 0; i < pEdges.length; i++ ){
        var pEdge = pEdges[i];

        if( !pEdge.removed() ){
          enqueue( pEdge, e );
        }
      }
    })
  ;

  var updateEleCalcs = function( willDraw ){
    if( willDraw ){
      var fns = r.onUpdateEleCalcsFns;

      if( fns ){ for( var i = 0; i < fns.length; i++ ){
        var fn = fns[i];

        fn( willDraw, elesToUpdate );
      } }

      r.recalculateRenderedStyle( elesToUpdate, false );

      for( var i = 0; i < elesToUpdate.length; i++ ){
        elesToUpdate[i]._private.rstyle.dirtyEvents = null;
      }

      elesToUpdate = cy.collection();
    }
  };

  r.beforeRender( updateEleCalcs, r.beforeRenderPriorities.eleCalcs );
};

BRp.onUpdateEleCalcs = function( fn ){
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

  fns.push( fn );
};

BRp.recalculateRenderedStyle = function( eles, useCache ){
  var edges = [];
  var nodes = [];

  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  if( this.destroyed ){ return; }

  // use cache by default for perf
  if( useCache === undefined ){ useCache = true; }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;

    // only update if dirty and in graph
    if( (useCache && rstyle.clean) || ele.removed() ){ continue; }

    // only update if not display: none
    if( ele.pstyle('display').value === 'none' ){ continue; }

    if( _p.group === 'nodes' ){
      nodes.push( ele );
    } else { // edges
      edges.push( ele );
    }

    rstyle.clean = true;
    // rstyle.dirtyEvents = null;
  }

  // update node data from projections
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = _p.position;

    this.recalculateNodeLabelProjection( ele );

    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle( 'width' ).pfValue;
    rstyle.nodeH = ele.pstyle( 'height' ).pfValue;
  }

  this.recalculateEdgeProjections( edges );

  // update edge data from projections
  for( var i = 0; i < edges.length; i++ ){
    var ele = edges[ i ];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch;

    this.recalculateEdgeLabelProjections( ele );

    // update rstyle positions
    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

// Project mouse
BRp.projectIntoViewport = function( clientX, clientY ){
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var pan = cy.pan();
  var zoom = cy.zoom();

  var x = ( clientX - offsetLeft - pan.x ) / zoom;
  var y = ( clientY - offsetTop - pan.y ) / zoom;

  return [ x, y ];
};

BRp.findContainerClientCoords = function(){
  if( this.containerBB ){
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window.getComputedStyle( container );
  var styleValue = function( name ){ return parseFloat( style.getPropertyValue( name ) ); };
  var extra = {
    left: styleValue('padding-left') + styleValue('border-left-width'),
    right: styleValue('padding-right') + styleValue('border-right-width'),
    top: styleValue('padding-top') + styleValue('border-top-width'),
    bottom: styleValue('padding-bottom') + styleValue('border-bottom-width')
  };

  return ( this.containerBB = [ // x, y, w, h
    rect.left + extra.left,
    rect.top + extra.top,
    rect.right - rect.left - extra.left - extra.right,
    rect.bottom - rect.top - extra.top - extra.bottom
  ] );
};

BRp.invalidateContainerClientCoordsCache = function(){
  this.containerBB = null;
};

BRp.findNearestElement = function( x, y, isTouch ){
  return this.findNearestElements( x, y, isTouch )[0];
};

BRp.findNearestElements = function( x, y, isTouch ){
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  function addEle( ele, sqDist ){
    if( ele.isNode() ){
      if( nearNode ){
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push( ele );
      }
    }

    if( ele.isEdge() && ( sqDist == null || sqDist < minSqDist ) ){
      if( nearEdge ){ // then replace existing edge
        // can replace only if same z-index
        if( nearEdge.pstyle( 'z-index' ).value === ele.pstyle('z-index').value ){
          for( var i = 0; i < near.length; i++ ){
            if( near[i].isEdge() ){
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push( ele );
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode( node ){
    var _p = node._private;

    if( node.pstyle( 'events' ).strValue === 'no' ){ return; }

    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = _p.position;

    if(
      pos.x - hw <= x && x <= pos.x + hw // bb check x
        &&
      pos.y - hh <= y && y <= pos.y + hh // bb check y
    ){
      var shape = r.nodeShapes[ self.getNodeShape( node ) ];

      if(
        shape.checkPoint( x, y, 0, width, height, pos.x, pos.y )
      ){
        addEle( node, 0 );
        return true;
      }

    }
  }

  function checkEdge( edge ){
    var _p = edge._private;

    if( edge.pstyle('events').strValue === 'no' ){ return; }

    var rs = _p.rscratch;
    var styleWidth = edge.pstyle( 'width' ).pfValue;
    var scale = edge.pstyle( 'arrow-scale' ).value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
      var pts = rs.allpts;

      for( var i = 0; i + 3 < pts.length; i += 2 ){
        if(
          (inEdgeBB = math.inLineVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], width2 ))
            &&
          widthSq > ( sqDist = math.sqdistToFiniteLine( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] ) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }

    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
      var pts = rs.allpts;
      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
        if(
          (inEdgeBB = math.inBezierVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5], width2 ))
            &&
          (widthSq > (sqDist = math.sqdistToQuadraticBezier( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5] )) )
        ){
          addEle( edge, sqDist );
          return true;
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows

    var src = src || _p.source;
    var tgt = tgt || _p.target;

    var arSize = self.getArrowWidth( styleWidth, scale );

    var arrows = [
      { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
      { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
      { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
      { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
    ];

    for( var i = 0; i < arrows.length; i++ ){
      var ar = arrows[ i ];
      var shape = r.arrowShapes[ edge.pstyle( ar.name + '-arrow-shape' ).value ];

      if(
        shape.roughCollide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
         &&
        shape.collide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )
      ){
        addEle( edge );
        return true;
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if( hasCompounds && near.length > 0 ){
      checkNode( src );
      checkNode( tgt );
    }
  }

  function preprop( obj, name, pre ){
    return util.getPrefixedProperty( obj, name, pre );
  }

  function checkLabel( ele, prefix ){
    var _p = ele._private;
    var th = labelThreshold;

    var prefixDash;
    if( prefix ){
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    var text = ele.pstyle( prefixDash + 'label' ).value;
    var eventsEnabled = ele.pstyle( 'text-events' ).strValue === 'yes';

    if( !eventsEnabled || !text ){ return; }

    var rstyle = _p.rstyle;
    var bw = ele.pstyle('text-border-width').pfValue;
    var pw = ele.pstyle('text-background-padding').pfValue;
    var lw = preprop( rstyle, 'labelWidth', prefix ) + bw + 2*th + 2*pw;
    var lh = preprop( rstyle, 'labelHeight', prefix ) + bw + 2*th + 2*pw;
    var lx = preprop( rstyle, 'labelX', prefix );
    var ly = preprop( rstyle, 'labelY', prefix );

    var theta = preprop( _p.rscratch, 'labelAngle', prefix );

    var lx1 = lx - lw / 2;
    var lx2 = lx + lw / 2;
    var ly1 = ly - lh / 2;
    var ly2 = ly + lh / 2;

    if( theta ){
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - lx;
        y = y - ly;

        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      var points = [
        px1y1.x, px1y1.y,
        px2y1.x, px2y1.y,
        px2y2.x, px2y2.y,
        px1y2.x, px1y2.y
      ];

      if( math.pointInsidePolygonPoints( x, y, points ) ){
        addEle( ele );
        return true;
      }
    } else { // do a cheaper bb check
      var bb = {
        w: lw,
        h: lh,
        x1: lx1,
        x2: lx2,
        y1: ly1,
        y2: ly2
      };

      if( math.inBoundingBox( bb, x, y ) ){
        addEle( ele );
        return true;
      }
    }

  }

  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
    var ele = eles[ i ];

    if( ele.isNode() ){
      checkNode( ele ) || checkLabel( ele );

    } else { // then edge
      checkEdge( ele ) || checkLabel( ele ) || checkLabel( ele, 'source' ) || checkLabel( ele, 'target' );
    }
  }

  return near;
};

// 'Give me everything from this box'
BRp.getAllInBox = function( x1, y1, x2, y2 ){
  var eles = this.getCachedZSortedEles();
  var nodes = eles.nodes;
  var edges = eles.edges;
  var box = [];

  var x1c = Math.min( x1, x2 );
  var x2c = Math.max( x1, x2 );
  var y1c = Math.min( y1, y2 );
  var y2c = Math.max( y1, y2 );

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox( {
    x1: x1, y1: y1,
    x2: x2, y2: y2
  } );

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[ i ];
    var nodeBb = node.boundingBox( {
      includeNodes: true,
      includeEdges: false,
      includeLabels: false,
      includeShadows: false
    } );

    if( math.boundingBoxesIntersect( boxBb, nodeBb ) ){
      box.push( nodes[ i ] );
    }
  }

  for( var e = 0; e < edges.length; e++ ){
    var edge = edges[ e ];
    var _p = edge._private;
    var rs = _p.rscratch;

    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }

    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){

      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
      var allInside = true;

      for( var i = 0; i < pts.length; i++ ){
        if( !math.pointInBoundingBox( boxBb, pts[ i ] ) ){
          allInside = false;
          break;
        }
      }

      if( allInside ){
        box.push( edge );
      }

    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
      box.push( edge );
    }

  }

  return box;
};


/**
 * Returns the shape of the given node. If the height or width of the given node
 * is set to auto, the node is considered to be a compound.
 *
 * @param node          a node
 * @return {String}     shape of the node
 */
BRp.getNodeShape = function( node ){
  var r = this;
  var shape = node.pstyle( 'shape' ).value;

  if( node.isParent() ){
    if( shape === 'rectangle' || shape === 'roundrectangle' ){
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if( shape === 'polygon' ){
    var points = node.pstyle( 'shape-polygon-points' ).value;

    return r.nodeShapes.makePolygon( points ).name;
  }

  return shape;
};

BRp.updateCachedGrabbedEles = function(){
  var eles = this.cachedZSortedEles;

  if( !eles ){
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];

  var grabTargets = [];

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.grabbed() && !ele.isParent() ){
      grabTargets.push( ele );
    } else if( rs.inDragLayer ){
      eles.drag.push( ele );
    } else {
      eles.nondrag.push( ele );
    }
  }

  // put the grab target nodes last so it's on top of its neighbourhood
  for( var i = 0; i < grabTargets.length; i++ ){
    var ele = grabTargets[i];

    eles.drag.push( ele );
  }
};

BRp.invalidateCachedZSortedEles = function(){
  this.cachedZSortedEles = null;
};

BRp.getCachedZSortedEles = function( forceRecalc ){
  if( forceRecalc || !this.cachedZSortedEles ){
    var cyEles = this.cy.mutableElements();
    var eles = [];

    eles.nodes = [];
    eles.edges = [];

    for( var i = 0; i < cyEles.length; i++ ){
      var ele = cyEles[i];

      if( ele.animated() || (ele.visible() && !ele.transparent()) ){
        eles.push( ele );

        if( ele.isNode() ){
          eles.nodes.push( ele );
        } else {
          eles.edges.push( ele );
        }
      }
    }

    eles.sort( zIndexSort );

    this.cachedZSortedEles = eles;

    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

function pushBezierPts( r, edge, pts ){
  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt( p1, p2, p3, t ); };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for( var i = 0; i < r.bezierProjPcts.length; i++ ){
    var p = r.bezierProjPcts[i];

    bpts.push( {
      x: qbezierAt( pts[0], pts[2], pts[4], p ),
      y: qbezierAt( pts[1], pts[3], pts[5], p )
    } );
  }
}

BRp.projectLines = function( edge ){
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  // clear the cached points state
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      pushBezierPts( this, edge, rs.allpts.slice( i, i + 6 ) );
    }
  } else if(  et === 'segments' ){
    var lpts = _p.rstyle.linePts = [];

    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
      lpts.push( {
        x: rs.allpts[ i ],
        y: rs.allpts[ i + 1]
      } );
    }
  } else if( et === 'haystack' ){
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [
      { x: hpts[0], y: hpts[1] },
      { x: hpts[2], y: hpts[3] }
    ];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth( edge.pstyle('width').pfValue, edge.pstyle( 'arrow-scale' ).value )
    * this.arrowShapeWidth;
};

BRp.projectBezier = BRp.projectLines;

BRp.recalculateNodeLabelProjection = function( node ){
  var content = node.pstyle( 'label' ).strValue;

  if( is.emptyString(content) ){ return; }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.pstyle('padding').pfValue;
  var nodePos = _p.position;
  var textHalign = node.pstyle( 'text-halign' ).strValue;
  var textValign = node.pstyle( 'text-valign' ).strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch( textHalign ){
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default: // e.g. center
      textX = nodePos.x;
  }

  switch( textValign ){
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default: // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( node );
};

BRp.recalculateEdgeLabelProjections = function( edge ){
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if( content.mid || content.source || content.target ){
    // then we have to calculate...
  } else {
    return; // no labels => no calcs
  }

  // add center point to style so bounding box calculations can use it
  //
  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function( propName, prefix, value ){
    util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
    util.setPrefixedProperty( _p.rstyle, propName, prefix, value );
  };

  setRs( 'labelX', null, p.x );
  setRs( 'labelY', null, p.y );

  var createControlPointInfo = function(){
    if( createControlPointInfo.cache ){ return createControlPointInfo.cache; } // use cache so only 1x per edge

    var ctrlpts = [];

    // store each ctrlpt info init
    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      var p0 = { x: rs.allpts[i], y: rs.allpts[i+1] };
      var p1 = { x: rs.allpts[i+2], y: rs.allpts[i+3] }; // ctrlpt
      var p2 = { x: rs.allpts[i+4], y: rs.allpts[i+5] };

      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment( cp, p0, p1, t0, t1 ){
      var length = math.dist( p0, p1 );
      var prevSegment = cp.segments[ cp.segments.length - 1 ];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };

      cp.segments.push( segment );

      cp.length += length;
    }

    // update each ctrlpt with segment info
    for( var i = 0; i < ctrlpts.length; i++ ){
      var cp = ctrlpts[i];
      var prevCp = ctrlpts[i - 1];

      if( prevCp ){
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(
        cp,
        cp.p0,   bpts[ i * nProjs ],
        0,       r.bezierProjPcts[ 0 ]
      ); // first

      for( var j = 0; j < nProjs - 1; j++ ){
        addSegment(
          cp,
          bpts[ i * nProjs + j ],   bpts[ i * nProjs + j + 1 ],
          r.bezierProjPcts[ j ],    r.bezierProjPcts[ j + 1 ]
        );
      }

      addSegment(
        cp,
        bpts[ i * nProjs + nProjs - 1 ],   cp.p2,
        r.bezierProjPcts[ nProjs - 1 ],    1
      ); // last
    }

    return ( createControlPointInfo.cache = ctrlpts );
  };

  var calculateEndProjection = function( prefix ){
    var angle;
    var isSrc = prefix === 'source';

    if( !content[ prefix ] ){ return; }

    var offset = edge.pstyle(prefix+'-text-offset').pfValue;

    var lineAngle = function( p0, p1 ){
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;

      return Math.atan( dy / dx );
    };

    var bezierAngle = function( p0, p1, p2, t ){
      var t0 = math.bound( 0, t - 0.001, 1 );
      var t1 = math.bound( 0, t + 0.001, 1 );

      var lp0 = math.qbezierPtAt( p0, p1, p2, t0 );
      var lp1 = math.qbezierPtAt( p0, p1, p2, t1 );

      return lineAngle( lp0, lp1 );
    };

    switch( rs.edgeType ){
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        var cps = createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;

        // find the segment we're on
        for( var i = 0; i < cps.length; i++ ){
          var cp = cps[ isSrc ? i : cps.length - 1 - i ];

          for( var j = 0; j < cp.segments.length; j++ ){
            var seg = cp.segments[ isSrc ? j : cp.segments.length - 1 - j ];
            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

            startDist = totalDist;
            totalDist += seg.length;

            if( totalDist >= offset || lastSeg ){
              selected = { cp: cp, segment: seg };
              break;
            }
          }

          if( selected ){ break; }
        }

        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = ( offset - startDist ) / ( seg.length );
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

        t = math.bound( 0, t, 1 );
        p = math.qbezierPtAt( cp.p0, cp.p1, cp.p2, t );
        angle = bezierAngle( cp.p0, cp.p1, cp.p2, t, p );

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        var d = 0, di, d0;
        var p0, p1;
        var l = rs.allpts.length;

        for( var i = 0; i + 3 < l; i += 2 ){
          if( isSrc ){
            p0 = { x: rs.allpts[i],     y: rs.allpts[i+1] };
            p1 = { x: rs.allpts[i+2],   y: rs.allpts[i+3] };
          } else {
            p0 = { x: rs.allpts[l-2-i], y: rs.allpts[l-1-i] };
            p1 = { x: rs.allpts[l-4-i], y: rs.allpts[l-3-i] };
          }

          di = math.dist( p0, p1 );
          d0 = d;
          d += di;

          if( d >= offset ){ break; }
        }

        var pD = offset - d0;
        var t = pD / di;

        t  = math.bound( 0, t, 1 );
        p = math.lineAt( p0, p1, t );
        angle = lineAngle( p0, p1 );

        break;
    }

    setRs( 'labelX', prefix, p.x );
    setRs( 'labelY', prefix, p.y );
    setRs( 'labelAutoAngle', prefix, angle );
  };

  calculateEndProjection( 'source' );
  calculateEndProjection( 'target' );

  this.applyLabelDimensions( edge );
};

BRp.applyLabelDimensions = function( ele ){
  this.applyPrefixedLabelDimensions( ele );

  if( ele.isEdge() ){
    this.applyPrefixedLabelDimensions( ele, 'source' );
    this.applyPrefixedLabelDimensions( ele, 'target' );
  }
};

BRp.applyPrefixedLabelDimensions = function( ele, prefix ){
  var _p = ele._private;

  var text = this.getLabelText( ele, prefix );
  var labelDims = this.calculateLabelDimensions( ele, text );

  util.setPrefixedProperty( _p.rstyle,   'labelWidth', prefix, labelDims.width );
  util.setPrefixedProperty( _p.rscratch, 'labelWidth', prefix, labelDims.width );

  util.setPrefixedProperty( _p.rstyle,   'labelHeight', prefix, labelDims.height );
  util.setPrefixedProperty( _p.rscratch, 'labelHeight', prefix, labelDims.height );
};

BRp.getLabelText = function( ele, prefix ){
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle( pfd + 'label' ).strValue;
  var textTransform = ele.pstyle( 'text-transform' ).value;
  var rscratch = function( propName, value ){
    if( value ){
      util.setPrefixedProperty( _p.rscratch, propName, prefix, value );
      return value;
    } else {
      return util.getPrefixedProperty( _p.rscratch, propName, prefix );
    }
  };

  if( textTransform == 'none' ){
    // passthrough
  } else if( textTransform == 'uppercase' ){
    text = text.toUpperCase();
  } else if( textTransform == 'lowercase' ){
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle( 'text-wrap' ).value;

  if( wrapStyle === 'wrap' ){
    //console.log('wrap');

    var labelKey = rscratch( 'labelKey' );

    // save recalc if the label is the same as before
    if( labelKey && rscratch( 'labelWrapKey' ) === labelKey ){
      // console.log('wrap cache hit');
      return rscratch( 'labelWrapCachedText' );
    }
    // console.log('wrap cache miss');

    var lines = text.split( '\n' );
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var wrappedLines = [];

    for( var l = 0; l < lines.length; l++ ){
      var line = lines[ l ];
      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
      var lineW = lineDims.width;

      if( lineW > maxW ){ // line is too long
        var words = line.split( /\s+/ ); // NB: assume collapsed whitespace into single space
        var subline = '';

        for( var w = 0; w < words.length; w++ ){
          var word = words[ w ];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
          var testW = testDims.width;

          if( testW <= maxW ){ // word fits on current line
            subline += word + ' ';
          } else { // word starts new line
            wrappedLines.push( subline );
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if( !subline.match( /^\s+$/ ) ){
          wrappedLines.push( subline );
        }
      } else { // line is already short enough
        wrappedLines.push( line );
      }
    } // for

    rscratch( 'labelWrapCachedLines', wrappedLines );
    text = rscratch( 'labelWrapCachedText', wrappedLines.join( '\n' ) );
    rscratch( 'labelWrapKey', labelKey );

    // console.log(text)
  } else if( wrapStyle === 'ellipsis' ){
    var maxW = ele.pstyle( 'text-max-width' ).pfValue;
    var ellipsized = '';
    var ellipsis = '\u2026';
    var incLastCh = false;

    for( var i = 0; i < text.length; i++ ){
      var widthWithNextCh = this.calculateLabelDimensions( ele, ellipsized + text[i] + ellipsis ).width;

      if( widthWithNextCh > maxW ){ break; }

      ellipsized += text[i];

      if( i === text.length - 1 ){ incLastCh = true; }
    }

    if( !incLastCh ){
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize

  return text;
};

BRp.calculateLabelDimensions = function( ele, text, extraKey ){
  var r = this;

  var cacheKey = ele._private.labelStyleKey + '$@$' + text;

  if( extraKey ){
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if( cache[ cacheKey ] ){
    return cache[ cacheKey ];
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ( sizeMult * ele.pstyle( 'font-size' ).pfValue ) + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;

  var div = this.labelCalcDiv;

  if( !div ){
    div = this.labelCalcDiv = document.createElement( 'div' ); // eslint-disable-line no-undef
    document.body.appendChild( div ); // eslint-disable-line no-undef
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[ cacheKey ] = {
    width: Math.ceil( div.clientWidth / sizeMult ),
    height: Math.ceil( div.clientHeight / sizeMult )
  };

  return cache[ cacheKey ];
};

BRp.recalculateEdgeProjections = function( edges ){
  this.findEdgeControlPoints( edges );
};


// Find edge control points
BRp.findEdgeControlPoints = function( edges ){
  if( !edges || edges.length === 0 ){ return; }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for( var i = 0; i < edges.length; i++ ){
    var edge = edges[ i ];
    var _p = edge._private;
    var data = _p.data;
    var curveStyle = edge.pstyle( 'curve-style' ).value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( edge.pstyle( 'display').value === 'none' ){
      continue;
    }

    if( curveStyle === 'haystack' ){
      haystackEdges.push( edge );
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ?
      tgtId + '$-$' + srcId :
      srcId + '$-$' + tgtId ;

    if( edgeIsUnbundled ){
      pairId = 'unbundled' + '$-$' + data.id;
    }

    if( hashTable[ pairId ] == null ){
      hashTable[ pairId ] = [];
      pairIds.push( pairId );
    }

    hashTable[ pairId ].push( edge );

    if( edgeIsUnbundled ){
      hashTable[ pairId ].hasUnbundled = true;
    }
  }

  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for( var p = 0; p < pairIds.length; p++ ){
    pairId = pairIds[ p ];
    var pairEdges = hashTable[ pairId ];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort( function( edge1, edge2 ){
      return edge1.poolIndex() - edge2.poolIndex();
    } );

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    // make sure src/tgt distinction is consistent for bundled edges
    if( !pairEdges.hasUnbundled && src.id() > tgt.id() ){
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    src_p = src._private;
    tgt_p = tgt._private;

    srcPos = src_p.position;
    tgtPos = tgt_p.position;

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[ this.getNodeShape( src ) ];
    tgtShape = r.nodeShapes[ this.getNodeShape( tgt ) ];

    badBezier = false;


    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

      // pt outside src shape to calc distance/displacement from src to tgt
      var srcOutside = srcShape.intersectLine(
        srcPos.x,
        srcPos.y,
        srcW,
        srcH,
        tgtPos.x,
        tgtPos.y,
        0
      );

      // pt outside tgt shape to calc distance/displacement from src to tgt
      var tgtOutside = tgtShape.intersectLine(
        tgtPos.x,
        tgtPos.y,
        tgtW,
        tgtH,
        srcPos.x,
        srcPos.y,
        0
      );

      var midptSrcPts = {
        x1: srcOutside[0],
        x2: tgtOutside[0],
        y1: srcOutside[1],
        y2: tgtOutside[1]
      };

      var posPts = {
        x1: srcPos.x,
        x2: tgtPos.x,
        y1: srcPos.y,
        y2: tgtPos.y
      };

      var dy = ( tgtOutside[1] - srcOutside[1] );
      var dx = ( tgtOutside[0] - srcOutside[0] );
      var l = Math.sqrt( dx * dx + dy * dy );

      var vector = {
        x: dx,
        y: dy
      };

      var vectorNorm = {
        x: vector.x / l,
        y: vector.y / l
      };
      vectorNormInverse = {
        x: -vectorNorm.y,
        y: vectorNorm.x
      };


      // if node shapes overlap, then no ctrl pts to draw
      if(
        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  &&
        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
      ){
        vectorNormInverse = {};
        badBezier = true;
      }

    }

    var edge;
    var edge_p;
    var rs;

    var dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    for( var i = 0; i < pairEdges.length; i++ ){
      edge = pairEdges[ i ];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;
      var numEdges2 = pairEdges.length;

      var curveStyle = edge.pstyle( 'curve-style' ).value;
      var ctrlptDists = edge.pstyle( 'control-point-distances' );

      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;

      var ctrlptWs = edge.pstyle( 'control-point-weights' );
      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
      var stepSize = edge.pstyle( 'control-point-step-size' ).pfValue;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      var srcX1 = rs.lastSrcCtlPtX;
      var srcX2 = srcPos.x;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcY2 = srcPos.y;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcW2 = src.outerWidth();
      var srcH1 = rs.lastSrcCtlPtH;
      var srcH2 = src.outerHeight();

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtX2 = tgtPos.x;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtY2 = tgtPos.y;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtW2 = tgt.outerWidth();
      var tgtH1 = rs.lastTgtCtlPtH;
      var tgtH2 = tgt.outerHeight();

      var width1 = rs.lastW;
      var width2 = edge.pstyle( 'control-point-step-size' ).pfValue;

      var edgeDistances = edge.pstyle('edge-distances').value;

      if( badBezier ){
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
      &&  width1 === width2
      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
        // console.log('edge ctrl pt cache HIT')
        continue; // then the control points haven't changed and we can skip calculating them
      } else {
        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastWidth = width2;
        // console.log('edge ctrl pt cache MISS')
      }

      if( src === tgt ){
        // Self-edge

        rs.edgeType = 'self';

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var outAngle =  loopDir - loopSwp / 2;
        var inAngle  =  loopDir + loopSwp / 2;

        // increase by step size for overlapping loops, keyed on direction and sweep values
        var dc = String(loopDir + '_' + loopSwp);
        j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

        rs.ctrlpts = [
          srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),
          srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)
        ];

      } else if(
        hasCompounds &&
        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
        ( src.parents().anySame( tgt ) || tgt.parents().anySame( src ) )
      ){
        // Compound edge

        rs.edgeType = 'compound';

        // because the line approximation doesn't apply for compound beziers
        // (loop/self edges are already elided b/c of cheap src==tgt check)
        rs.badBezier = false;

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var loopW = 50;

        var loopaPos = {
          x: srcPos.x - srcW / 2,
          y: srcPos.y - srcH / 2
        };

        var loopbPos = {
          x: tgtPos.x - tgtW / 2,
          y: tgtPos.y - tgtH / 2
        };

        var loopPos = {
          x: Math.min( loopaPos.x, loopbPos.x ),
          y: Math.min( loopaPos.y, loopbPos.y )
        };

        // avoids cases with impossible beziers
        var minCompoundStretch = 0.5;
        var compoundStretchA = Math.max( minCompoundStretch, Math.log( srcW * 0.01 ) );
        var compoundStretchB = Math.max( minCompoundStretch, Math.log( tgtW * 0.01 ) );

        rs.ctrlpts = [
          loopPos.x,
          loopPos.y - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,

          loopPos.x - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
          loopPos.y
        ];

      } else if( curveStyle === 'segments' ){
        // Segments (multiple straight lines)

        rs.edgeType = 'segments';
        rs.segpts = [];

        var segmentWs = edge.pstyle( 'segment-weights' ).pfValue;
        var segmentDs = edge.pstyle( 'segment-distances' ).pfValue;
        var segmentsN = Math.min( segmentWs.length, segmentDs.length );

        for( var s = 0; s < segmentsN; s++ ){
          var w = segmentWs[ s ];
          var d = segmentDs[ s ];

          var w1 = 1 - w;
          var w2 = w;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.segpts.push(
            adjustedMidpt.x + vectorNormInverse.x * d,
            adjustedMidpt.y + vectorNormInverse.y * d
          );
        }

      // Straight edge
      } else if(
        pairEdges.length % 2 === 1
        && i === Math.floor( pairEdges.length / 2 )
        && !edgeIsUnbundled
      ){

        rs.edgeType = 'straight';

      } else {
        // (Multi)bezier

        var multi = edgeIsUnbundled;

        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for( var b = 0; b < bezierN; b++ ){
          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manctrlptDist;
          var sign = math.signum( normctrlptDist );

          if( multi ){
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[ b ] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[ b ];
          }

          if( edgeIsUnbundled ){ // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

          var w1 = 1 - ctrlptWeight;
          var w2 = ctrlptWeight;

          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

          var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };

          rs.ctrlpts.push(
            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
          );
        }

      }

      // find endpts for edge
      this.findEndpoints( edge );

      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );

      var minCpADistFactor = 3;
      var arrowW = this.getArrowWidth( edge.pstyle( 'width' ).pfValue, edge.pstyle( 'arrow-scale' ).value )
        * this.arrowShapeWidth;
      var minCpADist = minCpADistFactor * arrowW;

      if( rs.edgeType === 'bezier' ){
        var startACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        var overlapping = false;

        if( badStart || badAStart || closeStartACp ){
          overlapping = true;

          // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var srcCtrlPtIntn = srcShape.intersectLine(
            srcPos.x,
            srcPos.y,
            srcW,
            srcH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeStartACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }

        if( badEnd || badAEnd || closeEndACp ){
          overlapping = true;

          // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max( srcW, srcH );
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var tgtCtrlPtIntn = tgtShape.intersectLine(
            tgtPos.x,
            tgtPos.y,
            tgtW,
            tgtH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeEndACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
          }

        }

        if( overlapping ){
          // recalc endpts
          this.findEndpoints( edge );
        }

      }

      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.allpts = [];

        rs.allpts.push( rs.startX, rs.startY );

        for( var b = 0; b + 1 < rs.ctrlpts.length; b += 2 ){
          // ctrl pt itself
          rs.allpts.push( rs.ctrlpts[ b ], rs.ctrlpts[ b + 1] );

          // the midpt between ctrlpts as intermediate destination pts
          if( b + 3 < rs.ctrlpts.length ){
            rs.allpts.push( (rs.ctrlpts[ b ] + rs.ctrlpts[ b + 2]) / 2, (rs.ctrlpts[ b + 1] + rs.ctrlpts[ b + 3]) / 2 );
          }
        }

        rs.allpts.push( rs.endX, rs.endY );

        var m, mt;
        if( rs.ctrlpts.length / 2 % 2 === 0 ){
          m = rs.allpts.length / 2 - 1;

          rs.midX = rs.allpts[ m ];
          rs.midY = rs.allpts[ m + 1];
        } else {
          m = rs.allpts.length / 2 - 3;
          mt = 0.5;

          rs.midX = math.qbezierAt( rs.allpts[ m ], rs.allpts[ m + 2], rs.allpts[ m + 4], mt );
          rs.midY = math.qbezierAt( rs.allpts[ m + 1], rs.allpts[ m + 3], rs.allpts[ m + 5], mt );
        }

      } else if( rs.edgeType === 'straight' ){
        // need to calc these after endpts
        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];

        // default midpt for labels etc
        rs.midX = ( rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX ) / 4;
        rs.midY = ( rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY ) / 4;

      } else if( rs.edgeType === 'segments' ){
        rs.allpts = [];
        rs.allpts.push( rs.startX, rs.startY );
        rs.allpts.push.apply( rs.allpts, rs.segpts );
        rs.allpts.push( rs.endX, rs.endY );

        if( rs.segpts.length % 4 === 0 ){
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;

          rs.midX = ( rs.segpts[ i1 ] + rs.segpts[ i2 ] ) / 2;
          rs.midY = ( rs.segpts[ i1 + 1] + rs.segpts[ i2 + 1] ) / 2;
        } else {
          var i1 = rs.segpts.length / 2 - 1;

          rs.midX = rs.segpts[ i1 ];
          rs.midY = rs.segpts[ i1 + 1];
        }


      }

      this.projectLines( edge );
      this.calculateArrowAngles( edge );
      this.recalculateEdgeLabelProjections( edge );
      this.calculateLabelAngles( edge );

    } // for pair edges
  } // for pair ids

  for( var i = 0; i < haystackEdges.length; i++ ){
    var edge = haystackEdges[ i ];
    var _p = edge._private;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if( !rscratch.haystack ){
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos( angle ),
        y: Math.sin( angle )
      };

    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src._private.position;
    var tgtPos = tgt._private.position;
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle( 'haystack-radius' ).value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [
      rs.source.x * srcW * halfRadius + srcPos.x,
      rs.source.y * srcH * halfRadius + srcPos.y,
      rs.target.x * tgtW * halfRadius + tgtPos.x,
      rs.target.y * tgtH * halfRadius + tgtPos.y
    ];

    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = 'haystack';
    rscratch.haystack = true;

    this.projectLines( edge );
    this.calculateArrowAngles( edge );
    this.recalculateEdgeLabelProjections( edge );
    this.calculateLabelAngles( edge );
  }

  return hashTable;
};

var getAngleFromDisp = function( dispX, dispY ){
  return Math.atan2( dispY, dispX ) - Math.PI / 2;
};

BRp.calculateArrowAngles = function( edge ){
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  var srcPos = edge._private.source._private.position;
  var tgtPos = edge._private.target._private.position;

  if( isHaystack ){
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY;

  // source
  //

  if( isSegments ){
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var bX = math.qbezierAt( pts[0], pts[2], pts[4], 0.1 );
    var bY = math.qbezierAt( pts[1], pts[3], pts[5], 0.1 );

    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if( isHaystack ){
    midX = ( startX + endX ) / 2;
    midY = ( startY + endY ) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if( isSelf ){
    dispX = -1;
    dispY = 1;
  } else if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = ( pts[ i2 ] - pts[ i1 ] );
      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );
    }
  } else if( isMultibezier || isCompound ){
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if( cpts.length / 2 % 2 === 0 ){
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0001 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0001 );
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.4999 );
      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.4999 );

      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.5 );
      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.5 );
    }

    dispX = ( bp1x - bp0x );
    dispY = ( bp1y - bp0y );
  }

  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -( pts[ i3 ] - pts[ i2 ] );
      dispY = -( pts[ i3 + 1] - pts[ i2 + 1] );
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );

  // target
  //

  if( isSegments ){
    dispX = endX - rs.segpts[ rs.segpts.length - 2 ];
    dispY = endY - rs.segpts[ rs.segpts.length - 1 ];
  } else if( isMultibezier || isCompound || isSelf || isBezier ){
    var pts = rs.allpts;
    var l = pts.length;
    var bX = math.qbezierAt( pts[l-6], pts[l-4], pts[l-2], 0.9 );
    var bY = math.qbezierAt( pts[l-5], pts[l-3], pts[l-1], 0.9 );

    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
};

BRp.calculateLabelAngles = function( ele ){
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var rot = ele.pstyle( 'text-rotation' );
  var rotStr = rot.strValue;

  if( rotStr === 'none' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else if( isEdge && rotStr === 'autorotate' ){
    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
    rs.targetLabelAngle = rs.targetLabelAutoAngle;
  } else if( rotStr === 'autorotate' ){
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
  }
};

BRp.manualEndptToPx = function( node, prop ){
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if( prop.value.length === 2 ){
    var p = [
      prop.pfValue[0],
      prop.pfValue[1]
    ];

    if( prop.units[0] === '%' ){
      p[0] = p[0] * w;
    }

    if( prop.units[1] === '%' ){
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;

    return p;
  } else {
    var angle = prop.pfValue[0];

    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max( w, h );

    var p = [
      npos.x + Math.cos( angle ) * l,
      npos.y + Math.sin( angle ) * l
    ];

    return r.nodeShapes[ this.getNodeShape( node ) ].intersectLine(
      npos.x, npos.y,
      w, h,
      p[0], p[1],
      0
    );
  }
};

BRp.findEndpoints = function( edge ){
  var r = this;
  var intersect;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var src_p = source._private;
  var tgt_p = target._private;

  var srcPos = src_p.position;
  var tgtPos = tgt_p.position;

  var tgtArShape = edge.pstyle( 'target-arrow-shape' ).value;
  var srcArShape = edge.pstyle( 'source-arrow-shape' ).value;

  var tgtDist = edge.pstyle( 'target-distance-from-node' ).pfValue;
  var srcDist = edge.pstyle( 'source-distance-from-node' ).pfValue;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var tgtManEndpt = edge.pstyle('target-endpoint');

  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;

  var p1; // last known point of edge on target side
  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape
  var p2_i; // point to intersect with source shape

  if( bezier ){
    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
    var cpEnd = multi ? [ rs.ctrlpts[ rs.ctrlpts.length - 2], rs.ctrlpts[ rs.ctrlpts.length - 1] ] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if( lines ){
    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if( tgtManEndpt.value === 'inside-to-node' ){
    intersect = [ tgtPos.x, tgtPos.y ];
  } else if( tgtManEndpt.units ){
    intersect = this.manualEndptToPx( target, tgtManEndpt );
  } else {
    if( tgtManEndpt.value === 'outside-to-node' ){
      p1_i = p1;
    } else if( tgtManEndpt.value === 'outside-to-line' ){
      p1_i = [ srcPos.x, srcPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( target ) ].intersectLine(
      tgtPos.x,
      tgtPos.y,
      target.outerWidth(),
      target.outerHeight(),
      p1_i[0],
      p1_i[1],
      0
    );
  }

  var arrowEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].spacing( edge ) + tgtDist
  );
  var edgeEnd = math.shortenIntersection(
    intersect,
    p1,
    r.arrowShapes[ tgtArShape ].gap( edge ) + tgtDist
  );

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if( srcManEndpt.value === 'inside-to-node' ){
    intersect = [ srcPos.x, srcPos.y ];
  } else if( srcManEndpt.units ){
    intersect = this.manualEndptToPx( source, srcManEndpt );
  } else {
    if( srcManEndpt.value === 'outside-to-node' ){
      p2_i = p2;
    } else if( srcManEndpt.value === 'outside-to-line' ){
      p2_i = [ tgtPos.x, tgtPos.y ];
    }

    intersect = r.nodeShapes[ this.getNodeShape( source ) ].intersectLine(
      srcPos.x,
      srcPos.y,
      source.outerWidth(),
      source.outerHeight(),
      p2_i[0],
      p2_i[1],
      0
    );
  }

  var arrowStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].spacing( edge ) + srcDist
  );
  var edgeStart = math.shortenIntersection(
    intersect,
    p2,
    r.arrowShapes[ srcArShape ].gap( edge ) + srcDist
  );

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if( hasEndpts ){
    if( !is.number( rs.startX ) || !is.number( rs.startY ) || !is.number( rs.endX ) || !is.number( rs.endY ) ){
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getArrowWidth = BRp.getArrowHeight = function( edgeWidth, scale ){
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[ edgeWidth + ', ' + scale ];
  if( cachedVal ){
    return cachedVal;
  }

  cachedVal =  Math.max( Math.pow( edgeWidth * 13.37, 0.9 ), 29 ) * scale;
  cache[ edgeWidth + ', ' + scale ] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

},{"../../../collection/zsort":35,"../../../is":86,"../../../math":88,"../../../util":103,"../../../window":110}],62:[function(require,module,exports){
'use strict';

var BRp = {};

BRp.getCachedImage = function( url, crossOrigin, onLoad ){
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[ url ];

  if( cache ){
    if( !cache.image.complete ){
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[ url ] = imageCache[ url ] || {};

    var image = cache.image = new Image(); // eslint-disable-line no-undef
    image.addEventListener('load', onLoad);

    // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978
    var dataUriPrefix = 'data:';
    var isDataUri = url.substring( 0, dataUriPrefix.length ).toLowerCase() === dataUriPrefix;
    if( !isDataUri ){
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;

    return image;
  }
};

module.exports = BRp;

},{}],63:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );
var util = require( '../../../util' );

var BaseRenderer = function( options ){ this.init( options ); };
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];

BRp.init = function( options ){
  var r = this;

  r.options = options;

  r.cy = options.cy;

  r.container = options.cy.container();

  r.selection = [ undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [ 0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95 ];

  //--Pointer-related data
  r.hoverData = {down: null, last: null,
      downTime: null, triggerMode: null,
      dragging: false,
      initialPan: [ null, null ], capture: false};

  r.dragData = {possibleDragElements: []};

  r.touchData = {
    start: null, capture: false,

    // These 3 fields related to tap, taphold events
    startPosition: [ null, null, null, null, null, null ],
    singleTouchStartTime: null,
    singleTouchMoved: true,

    now: [ null, null, null, null, null, null ],
    earlier: [ null, null, null, null, null, null ]
  };

  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = options.motionBlur; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = { // higher priority execs before lower one
    animations:   400,
    eleCalcs:     300,
    eleTxrDeq:    200,
    lyrTxrDeq:    100
  };

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
  r.load();
};

BRp.notify = function( params ){
  var types;
  var r = this;

  // the renderer can't be notified after it's destroyed
  if( this.destroyed ){ return; }

  if( is.array( params.type ) ){
    types = params.type;

  } else {
    types = [ params.type ];
  }

  var has = {};
  for( var i = 0; i < types.length; i++ ){
    var type = types[ i ];

    has[ type ] = true;
  } // for

  if( has['destroy'] ){
    r.destroy();
    return;
  }

  if( has['add'] || has['remove'] || has['load'] || has['zorder'] ){
    r.invalidateCachedZSortedEles();
  }

  if( has['viewport'] ){
    r.redrawHint( 'select', true );
  }

  if( has['load'] || has['resize'] ){
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize( r.container );
  }

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function(){
  var r = this;

  r.destroyed = true;

  r.cy.stopAnimationLoop();

  for( var i = 0; i < r.bindings.length; i++ ){
    var binding = r.bindings[ i ];
    var b = binding;
    var tgt = b.target;

    ( tgt.off || tgt.removeEventListener ).apply( tgt, b.args );
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if( r.removeObserver ){
    r.removeObserver.disconnect();
  }

  if( r.styleObserver ){
    r.styleObserver.disconnect();
  }

  if( r.labelCalcDiv ){
    try {
      document.body.removeChild( r.labelCalcDiv ); // eslint-disable-line no-undef
    } catch( e ){
      // ie10 issue #1014
    }
  }
};

[
  require( './arrow-shapes' ),
  require( './coord-ele-math' ),
  require( './images' ),
  require( './load-listeners' ),
  require( './node-shapes' ),
  require( './redraw' )
].forEach( function( props ){
  util.extend( BRp, props );
} );

module.exports = BR;

},{"../../../is":86,"../../../util":103,"./arrow-shapes":60,"./coord-ele-math":61,"./images":62,"./load-listeners":64,"./node-shapes":65,"./redraw":66}],64:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );
var util = require( '../../../util' );
var math = require( '../../../math' );
var Event = require( '../../../event' );

var BRp = {};

BRp.registerBinding = function( target, event, handler, useCapture ){
  var args = Array.prototype.slice.apply( arguments, [1] ); // copy
  var b = this.binder( target );

  return b.on.apply( b, args );
};

BRp.binder = function( tgt ){
  var r = this;

  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement( tgt );

  if( r.supportsPassiveEvents == null ){

    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty( {}, 'passive', {
        get: function(){
          supportsPassive = true;
        }
      } );

      window.addEventListener( 'test', null, opts );
    } catch( err ){}

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function( event, handler, useCapture ){
    var args = Array.prototype.slice.call( arguments );

    if( tgtIsDom && r.supportsPassiveEvents ){ // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });

    ( tgt.addEventListener || tgt.on ).apply( tgt, args );

    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp.nodeIsDraggable = function( node ){
  return (
    node
    && node.isNode()
    && !node.locked()
    && node.grabbable()
  );
};

BRp.nodeIsGrabbable = function( node ){
  return (
    this.nodeIsDraggable( node )
    && node.pstyle( 'opacity' ).value !== 0
    && node.pstyle( 'visibility' ).value === 'visible'
    && node.pstyle( 'display' ).value === 'element'
  );
};

BRp.load = function(){
  var r = this;

  var triggerEvents = function( target, names, e, props ){
    if( target == null ){
      target = r.cy;
    }

    for( var i = 0; i < names.length; i++ ){
      var name = names[ i ];

      var event = new Event( e, util.extend( { type: name }, props ) );
      target.trigger( event );
    }
  };

  var isMultSelKeyDown = function( e ){
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function( down, downs ){
    var allowPassthrough = true;

    if( r.cy.hasCompoundNodes() && down && down.isEdge() ){
      // a compound node below the edge => no passthrough panning
      for( var i = 0; downs && i < downs.length; i++ ){
        var down = downs[i];

        if( down.isNode() && down.isParent() ){
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var getDragListIds = function( opts ){
    var listHasId;

    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for( var i = 0; i < opts.addToList.length; i++ ){
          var ele = opts.addToList[ i ];

          opts.addToList.hasId[ ele.id() ] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  var setGrabbed = function( ele ){
    ele[0]._private.grabbed = true;
  };

  var setFreed = function( ele ){
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function( ele ){
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function( ele ){
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function( ele, opts ){
    var listHasId = getDragListIds( opts );

    if( !listHasId[ ele.id() ] ){
      opts.addToList.push( ele );
      listHasId[ ele.id() ] = true;

      setGrabbed( ele );
    }
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function( node, opts ){
    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    var innerNodes = node.descendants();

    if( opts.inDragLayer ){
      innerNodes.forEach( setInDragLayer );
      innerNodes.connectedEdges().forEach( setInDragLayer );
    }

    if( opts.addToList ){
      innerNodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  // adds the given nodes and its neighbourhood to the drag layer
  var addNodesToDrag = function( nodes, opts ){
    opts = opts || {};

    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if( opts.inDragLayer ){
      nodes.forEach( setInDragLayer );

      nodes.neighborhood().stdFilter(function( ele ){
        return !hasCompoundNodes || ele.isEdge();
      }).forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }

    addDescendantsToDrag( nodes, opts ); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer( nodes, {
      inDragLayer: opts.inDragLayer
    } );

    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function( grabbedEles ){
    if( !grabbedEles ){ return; }

    grabbedEles.hasId = {}; // clear the id list

    // just go over all elements rather than doing a bunch of (possibly expensive) traversals
    r.getCachedZSortedEles().forEach(function( ele ){
      setFreed( ele );
      setOutDragLayer( ele );
      removeGrabTarget( ele );
    });

    r.updateCachedGrabbedEles();
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function( node, opts ){

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    if( !node.cy().hasCompoundNodes() ){
      return;
    }

    // find top-level parent
    var parent = node.ancestors().orphans();

    // no parent node: no nodes to add to the drag layer
    if( parent.same( node ) ){
      return;
    }

    var nodes = parent.descendants().spawnSelf()
      .merge( parent )
      .unmerge( node )
      .unmerge( node.descendants() )
    ;

    var edges = nodes.connectedEdges();

    if( opts.inDragLayer ){
      edges.forEach( setInDragLayer );
      nodes.forEach( setInDragLayer );
    }

    if( opts.addToList ){
      nodes.forEach(function( ele ){
        addToDragList( ele, opts );
      });
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';

  // watch for when the cy container is removed from the dom
  if( haveMutationsApi ){
    r.removeObserver = new MutationObserver( function( mutns ){ // eslint-disable-line no-undef
      for( var i = 0; i < mutns.length; i++ ){
        var mutn = mutns[ i ];
        var rNodes = mutn.removedNodes;

        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
          var rNode = rNodes[ j ];

          if( rNode === r.container ){
            r.destroy();
            break;
          }
        } }
      }
    } );

    if( r.container.parentNode ){
      r.removeObserver.observe( r.container.parentNode, { childList: true } );
    }
  } else {
    r.registerBinding( r.container, 'DOMNodeRemoved', function( e ){
      r.destroy();
    } );
  }

  var onResize = util.debounce( function(){
    r.cy.invalidateSize();
    r.invalidateContainerClientCoordsCache();

    r.matchCanvasSize( r.container );
    r.redrawHint( 'eles', true );
    r.redrawHint( 'drag', true );
    r.redraw();
  }, 100 );

  if( haveMutationsApi ){
    r.styleObserver = new MutationObserver( onResize ); // eslint-disable-line no-undef

    r.styleObserver.observe( r.container, { attributes: true } );
  }

  // auto resize
  r.registerBinding( window, 'resize', onResize ); // eslint-disable-line no-undef

  var invalCtnrBBOnScroll = function( domEle ){
    r.registerBinding( domEle, 'scroll', function( e ){
      r.invalidateContainerClientCoordsCache();
    } );
  };

  var bbCtnr = r.cy.container();

  for( ;; ){

    invalCtnrBBOnScroll( bbCtnr );

    if( bbCtnr.parentNode ){
      bbCtnr = bbCtnr.parentNode;
    } else {
      break;
    }

  }

  // stop right click menu from appearing on cy
  r.registerBinding( r.container, 'contextmenu', function( e ){
    e.preventDefault();
  } );

  var inBoxSelection = function(){
    return r.selection[4] !== 0;
  };

  var eventInContainer = function( e ){
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];

    var positions = e.touches ? e.touches : [ e ];
    var atLeastOnePosInside = false;

    for( var i = 0; i < positions.length; i++ ){
      var p = positions[i];

      if( x <= p.clientX && p.clientX <= x + width
        && y <= p.clientY && p.clientY <= y + height
      ){
        atLeastOnePosInside = true;
        break;
      }
    }

    if( !atLeastOnePosInside ){ return false; }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while( tParent ){
      if( tParent === container ){
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if( !containerIsTarget ){ return false; } // if target is outisde cy container, then this event is not for us

    return true;
  };

  // Primary key
  r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){
    if( !eventInContainer(e) ){ return; }

    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var select = r.selection;
    var nears = r.findNearestElements( pos[0], pos[1], false );
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout( function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.trigger( new Event( e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          } else {
            cy.trigger( new Event( e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }
        }

      }, r.tapholdDuration );
    };

    // Right click button
    if( e.which == 3 ){

      r.hoverData.cxtStarted = true;

      var cxtEvt = new Event( e, {
        type: 'cxttapstart',
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( near ){
        near.activate();
        near.trigger( cxtEvt );

        r.hoverData.down = near;
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.downTime = (new Date()).getTime();
      r.hoverData.cxtDragged = false;

    // Primary button
    } else if( e.which == 1 ){

      if( near ){
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if( near != null ){

          if( r.nodeIsGrabbable( near ) ){

            var grabEvent = new Event( e, {
              type: 'grab',
              cyPosition: { x: pos[0], y: pos[1] }
            } );

            setGrabTarget( near );

            if( !near.selected() ){

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag( near, { addToList: draggedElements } );

              near.trigger( grabEvent );

            } else if( near.selected() ){
              draggedElements = r.dragData.possibleDragElements = [  ];

              var selectedNodes = cy.$( function(){ return this.isNode() && this.selected() && r.nodeIsGrabbable( this ); } );

              addNodesToDrag( selectedNodes, { addToList: draggedElements } );

              near.trigger( grabEvent );
            }

            r.redrawHint( 'eles', true );
            r.redrawHint( 'drag', true );

          }

        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = (new Date()).getTime();
      }

      triggerEvents( near, [ 'mousedown', 'tapstart', 'vmousedown' ], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( near == null ){
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );

        r.redraw();
      } else if( near.isEdge() ){
        select[4] = 1; // for future pan
      }

      checkForTaphold();

    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];

  }, false );

  r.registerBinding( window, 'mousemove', function mousemoveHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;

    var near = null;
    if( !r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting ){
      near = r.findNearestElement( pos[0], pos[1], false );
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [ pos[0] - select[2], pos[1] - select[3] ];

    var draggedElements = r.dragData.possibleDragElements;

    var isOverThresholdDrag;

    if( mdownGPos ){
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown( e );

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function(){
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if( dragDelta.length === 0 ){
        dragDelta.push( disp[0] );
        dragDelta.push( disp[1] );
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };


    preventDefault = true;

    triggerEvents( near, [ 'mousemove', 'vmousemove', 'tapdrag' ], e, {
      cyPosition: { x: pos[0], y: pos[1] }
    } );

    var goIntoBoxMode = function(){
      r.data.bgActivePosistion = undefined;

      if( !r.hoverData.selecting ){
        cy.trigger('boxstart');
      }

      select[4] = 1;
      r.hoverData.selecting = true;

      r.redrawHint( 'select', true );
      r.redraw();
    };

    // trigger context drag if rmouse down
    if( r.hoverData.which === 3 ){
      // but only if over threshold
      if( isOverThresholdDrag ){
        var cxtEvt = new Event( e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new Event( e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new Event( e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            } ) );
          }

        }
      }

    // Check if we are drag panning the entire graph
    } else if( r.hoverData.dragging ){
      preventDefault = true;

      if( cy.panningEnabled() && cy.userPanningEnabled() ){
        var deltaP;

        if( r.hoverData.justStartedPan ){
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: ( pos[0] - mdPos[0] ) * zoom,
            y: ( pos[1] - mdPos[1] ) * zoom
          };

          r.hoverData.justStartedPan = false;

        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };

        }

        cy.panBy( deltaP );

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport( e.clientX, e.clientY );

    // Checks primary button down & out of time & mouse not moved much
    } else if(
        select[4] == 1 && (down == null || down.isEdge())
    ){

      if( isOverThresholdDrag ){

        if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
          goIntoBoxMode();

        } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
          var allowPassthrough = allowPanningPassthrough( down, r.hoverData.downs );

          if( allowPassthrough ){
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;

            r.data.bgActivePosistion = math.array2point( mdownPos );

            r.redrawHint( 'select', true );
            r.redraw();
          }
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      }

    } else {
      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      if( ( !down || !down.grabbed() ) && near != last ){

        if( last ){
          triggerEvents( last, [ 'mouseout', 'tapdragout' ], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        if( near ){
          triggerEvents( near, [ 'mouseover', 'tapdragover' ], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        r.hoverData.last = near;
      }

      if( down && r.nodeIsDraggable( down ) ){

        if( isOverThresholdDrag ){ // then we can take action

          if( cy.boxSelectionEnabled() && multSelKeyDown ){ // then selection overrides
            if( down && down.grabbed() ){
              freeDraggedElements( draggedElements );

              down.trigger('free');
            }

            goIntoBoxMode();

          } else { // otherwise drag
            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ){
              r.redrawHint( 'eles', true );
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            // now, add the elements to the drag layer if not done already
            if( !r.hoverData.draggingEles ){
              addNodesToDrag( cy.collection( draggedElements ), { inDragLayer: true } );
            }

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[ i ];

              // Locked nodes not draggable, as well as non-visible nodes
              if( r.nodeIsDraggable( dEle ) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( is.number( disp[0] ) && is.number( disp[1] ) ){
                  var updatePos = !dEle.isParent();

                  if( updatePos ){
                    dPos.x += disp[0];
                    dPos.y += disp[1];
                  }

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = cy.collection( toTrigger );

            tcol.updateCompoundBounds();
            tcol.trigger( 'position drag' );

            r.redrawHint( 'drag', true );
            r.redraw();
          }

        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0]; select[3] = pos[1];

    if( preventDefault ){
      if( e.stopPropagation ) e.stopPropagation();
      if( e.preventDefault ) e.preventDefault();
      return false;
    }
  }, false );

  r.registerBinding( window, 'mouseup', function mouseupHandler( e ){ // eslint-disable-line no-undef
    var capture = r.hoverData.capture;
    if( !capture ){ return; }
    r.hoverData.capture = false;

    var cy = r.cy; var pos = r.projectIntoViewport( e.clientX, e.clientY ); var select = r.selection;
    var near = r.findNearestElement( pos[0], pos[1], false );
    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown( e );

    if( r.data.bgActivePosistion ){
      r.redrawHint( 'select', true );
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if( down ){
      down.unactivate();
    }

    if( r.hoverData.which === 3 ){
      var cxtEvt = new Event( e, {
        type: 'cxttapend',
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( !r.hoverData.cxtDragged ){
        var cxtTap = new Event( e, {
          type: 'cxttap',
          cyPosition: { x: pos[0], y: pos[1] }
        } );

        if( down ){
          down.trigger( cxtTap );
        } else {
          cy.trigger( cxtTap );
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;

    } else if( r.hoverData.which === 1 ){

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if( (down == null) // not mousedown on node
        && !r.dragData.didDrag // didn't move the node around
        && !r.hoverData.selecting // not box selection
        && !r.hoverData.dragged // didn't pan
        && !isMultSelKeyDown( e )
      ){

        cy.$( function(){
          return this.selected();
        } ).unselect();

        if( draggedElements.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents( near, [ 'mouseup', 'tapend', 'vmouseup' ], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if(
        !r.dragData.didDrag // didn't move a node around
        && !r.hoverData.dragged // didn't pan
        && !r.hoverData.selecting // not box selection
      ){
        triggerEvents( down, ['click', 'tap', 'vclick'], e, {
          cyPosition: { x: pos[0], y: pos[1] }
        } );
      }

      // Single selection
      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
        if( near != null && near._private.selectable ){

          if( r.hoverData.dragging ){
            // if panning, don't change selection state
          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
            if( near.selected() ){
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if( !multSelKeyDown ){
              cy.$( ':selected' ).unmerge( near ).unselect();
              near.select();
            }
          }

          r.redrawHint( 'eles', true );
        }
      }

      if( r.hoverData.selecting ){
        var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

        r.redrawHint( 'select', true );

        if( box.length > 0 ){
          r.redrawHint( 'eles', true );
        }

        cy.trigger('boxend');

        var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

        if( cy.selectionType() === 'additive' ){
          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        } else {
          if( !multSelKeyDown ){
            cy.$( ':selected' ).unmerge( box ).unselect();
          }

          box
            .trigger('box')
            .stdFilter( eleWouldBeSelected )
              .select()
              .trigger('boxselect')
          ;
        }

        // always need redraw in case eles unselectable
        r.redraw();

      }

      // Cancel drag pan
      if( r.hoverData.dragging ){
        r.hoverData.dragging = false;

        r.redrawHint( 'select', true );
        r.redrawHint( 'eles', true );

        r.redraw();
      }

      if( !select[4] ) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        var downWasGrabbed = down && down.grabbed();

        freeDraggedElements( draggedElements );

        if( downWasGrabbed ){ down.trigger('free'); }
      }

    } // else not right mouse

    select[4] = 0; r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;

  }, false );

  var wheelHandler = function( e ){


    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport( e.clientX, e.clientY );
    var rpos = [ pos[0] * cy.zoom() + cy.pan().x,
                  pos[1] * cy.zoom() + cy.pan().y ];

    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout( r.data.wheelTimeout );
      r.data.wheelTimeout = setTimeout( function(){
        r.data.wheelZooming = false;

        r.redrawHint( 'eles', true );
        r.redraw();
      }, 150 );

      var diff;

      if( e.deltaY != null ){
        diff = e.deltaY / -250;
      } else if( e.wheelDeltaY != null ){
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom( {
        level: cy.zoom() * Math.pow( 10, diff ),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      } );
    }

  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding( r.container, 'wheel', wheelHandler, true );

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding( window, 'scroll', function scrollHandler( e ){ // eslint-disable-line no-undef
    r.scrollingPage = true;

    clearTimeout( r.scrollingPageTimeout );
    r.scrollingPageTimeout = setTimeout( function(){
      r.scrollingPage = false;
    }, 250 );
  }, true );

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container
  r.registerBinding( r.container, 'mouseout', function mouseOutHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseout',
      cyPosition: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  r.registerBinding( r.container, 'mouseover', function mouseOverHandler( e ){
    var pos = r.projectIntoViewport( e.clientX, e.clientY );

    r.cy.trigger( new Event( e, {
      type: 'mouseover',
      cyPosition: { x: pos[0], y: pos[1] }
    } ) );
  }, false );

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function( x1, y1, x2, y2 ){
    return Math.sqrt( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) );
  };

  var distanceSq = function( x1, y1, x2, y2 ){
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding( r.container, 'touchstart', touchstartHandler = function( e ){
    if( !eventInContainer(e) ){ return; }

    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    // record starting points for pinch-to-zoom
    if( e.touches[1] ){

      freeDraggedElements( r.dragData.touchDragEles );

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside =
           0 <= f1x1 && f1x1 <= containerWidth
        && 0 <= f2x1 && f2x1 <= containerWidth
        && 0 <= f1y1 && f1y1 <= containerHeight
        && 0 <= f2y1 && f2y1 <= containerHeight
      ;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
      center1 = [ (f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2 ];
      modelCenter1 = [
        (center1[0] - pan.x) / zoom,
        (center1[1] - pan.y) / zoom
      ];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

        var near1 = r.findNearestElement( now[0], now[1], true );
        var near2 = r.findNearestElement( now[2], now[3], true );

        if( near1 && near1.isNode() ){
          near1.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near1;

        } else if( near2 && near2.isNode() ){
          near2.activate().trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
          r.touchData.start = near2;

        } else {
          cy.trigger( new Event( e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;

      }

    }

    if( e.touches[2] ){
      // ignore
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      var nears = r.findNearestElements( now[0], now[1], true );
      var near = nears[0];

      if( near != null ){
        near.activate();

        r.touchData.start = near;
        r.touchData.starts = nears;

        if( r.nodeIsGrabbable( near ) ){

          var draggedEles = r.dragData.touchDragEles = [];

          r.redrawHint( 'eles', true );
          r.redrawHint( 'drag', true );

          if( near.selected() ){
            // reset drag elements, since near will be added again

            var selectedNodes = cy.$( function(){
              return this.selected() && r.nodeIsGrabbable( this );
            } );

            addNodesToDrag( selectedNodes, { addToList: draggedEles } );
          } else {
            addNodeToDrag( near, { addToList: draggedEles } );
          }

          setGrabTarget( near );

          near.trigger( new Event( e, {
            type: 'grab',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }
      }

      triggerEvents( near, [ 'touchstart', 'tapstart', 'vmousedown' ], e, {
        cyPosition: { x: now[0], y: now[1] }
      } );

      if( near == null ){
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint( 'select', true );
        r.redraw();
      }


      // Tap, taphold
      // -----

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout( r.touchData.tapholdTimeout );
      r.touchData.tapholdTimeout = setTimeout( function(){
        if(
            r.touchData.singleTouchMoved === false
            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
            && !r.touchData.selecting // box selection shouldn't allow taphold through
        ){
          triggerEvents( r.touchData.start, [ 'taphold' ], e, {
            cyPosition: { x: now[0], y: now[1] }
          } );

          if( !r.touchData.start ){
            cy.$( ':selected' ).unselect();
          }

        }
      }, r.tapholdDuration );
    }

    if( e.touches.length >= 1 ){
      var sPos = r.touchData.startPosition = [];

      for( var i = 0; i < now.length; i++ ){
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];

      r.touchData.startGPosition = [ touch0.clientX, touch0.clientY ];
    }

  }, false );

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) { // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if( !capture && !eventInContainer(e) ){ return; }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if( capture && e.touches[0] && startGPos ){
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    }

    // context swipe cancelling
    if( capture && r.touchData.cxt ){
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
        r.touchData.cxt = false;

        r.data.bgActivePosistion = undefined;

        r.redrawHint( 'select', true );

        var cxtEvt = new Event( e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( r.touchData.start ){
          r.touchData.start
            .unactivate()
            .trigger( cxtEvt )
          ;

          r.touchData.start = null;
        } else {
          cy.trigger( cxtEvt );
        }
      }

    }

    // context swipe
    if( capture && r.touchData.cxt ){
      var cxtEvt = new Event( e, {
        type: 'cxtdrag',
        cyPosition: { x: now[0], y: now[1] }
      } );
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      if( r.touchData.start ){
        r.touchData.start.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement( now[0], now[1], true );

      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

        if( r.touchData.cxtOver ){
          r.touchData.cxtOver.trigger( new Event( e, {
            type: 'cxtdragout',
            cyPosition: { x: now[0], y: now[1] }
          } ) );
        }

        r.touchData.cxtOver = near;

        if( near ){
          near.trigger( new Event( e, {
            type: 'cxtdragover',
            cyPosition: { x: now[0], y: now[1] }
          } ) );

        }

      }

    // box selection
    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();

      if( !r.touchData.selecting ){
        cy.trigger('boxstart');
      }

      r.touchData.selecting = true;

      r.redrawHint( 'select', true );

      if( !select || select.length === 0 || select[0] === undefined ){
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

    // pinch to zoom
    } else if( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ){ // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;
      if( draggedEles ){
        r.redrawHint( 'drag', true );

        for( var i = 0; i < draggedEles.length; i++ ){
          var de_p = draggedEles[i]._private;

          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;


      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if( twoFingersStartInside ){
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if( r.touchData.start && r.touchData.start.active() ){
          var draggedEles = r.dragData.touchDragEles;

          freeDraggedElements( draggedEles );

          r.redrawHint( 'drag', true );
          r.redrawHint( 'eles', true );

          r.touchData.start
            .unactivate()
            .trigger( 'free' )
          ;
        }

        cy.viewport( {
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        } );

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
      if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
      if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    } else if( e.touches[0] ){
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near;

      if( !r.hoverData.draggingEles && !r.swipePanning ){
        near = r.findNearestElement( now[0], now[1], true );
      }

      if( capture && start != null ){
        e.preventDefault();
      }

      // dragging nodes
      if( capture && start != null && r.nodeIsDraggable( start ) ){

        if( isOverThresholdDrag ){ // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          if( justStartedDrag ){
            addNodesToDrag( cy.collection( draggedEles ), { inDragLayer: true } );
          }

          for( var k = 0; k < draggedEles.length; k++ ){
            var draggedEle = draggedEles[ k ];

            if( r.nodeIsDraggable( draggedEle ) && draggedEle.grabbed() ){
              r.dragData.didDrag = true;
              var dPos = draggedEle._private.position;
              var updatePos = !draggedEle.isParent();

              if( updatePos && is.number( disp[0] ) && is.number( disp[1] ) ){
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if( justStartedDrag ){
                r.redrawHint( 'eles', true );

                var dragDelta = r.touchData.dragDelta;

                if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }

              }
            }
          }

          var tcol = cy.collection( draggedEles );

          tcol.updateCompoundBounds();
          tcol.trigger( 'position drag' );

          r.hoverData.draggingEles = true;

          r.redrawHint( 'drag', true );

          if(
               r.touchData.startPosition[0] == earlier[0]
            && r.touchData.startPosition[1] == earlier[1]
          ){

            r.redrawHint( 'eles', true );
          }

          r.redraw();
        } else { // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if( dragDelta.length === 0 ){
            dragDelta.push( disp[0] );
            dragDelta.push( disp[1] );
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents( (start || near), [ 'touchmove', 'tapdrag', 'vmousemove' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( ( !start || !start.grabbed() ) && near != last ){
          if( last ){ last.trigger( new Event( e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } } ) ); }
          if( near ){ near.trigger( new Event( e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } } ) ); }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      if( capture ){
        for( var i = 0; i < now.length; i++ ){
          if( now[ i ]
            && r.touchData.startPosition[ i ]
            && isOverThresholdDrag ){

            r.touchData.singleTouchMoved = true;
          }
        }
      }

      // panning
      if(
          capture
          && ( start == null || start.isEdge() )
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){

        var allowPassthrough = allowPanningPassthrough( start, r.touchData.starts );

        if( allowPassthrough ){
          e.preventDefault();

          if( r.swipePanning ){
            cy.panBy( {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            } );

          } else if( isOverThresholdDrag ){
            r.swipePanning = true;

            cy.panBy( {
              x: dx * zoom,
              y: dy * zoom
            } );

            if( start ){
              start.unactivate();

              if( !r.data.bgActivePosistion ){
                r.data.bgActivePosistion = math.array2point( r.touchData.startPosition );
              }

              r.redrawHint( 'select', true );

              r.touchData.start = null;
            }
          }

        }

        // Re-project
        var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY );
        now[0] = pos[0]; now[1] = pos[1];
      }
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }
    //r.redraw();

  }, false );

  var touchcancelHandler;
  r.registerBinding( window, 'touchcancel', touchcancelHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    r.touchData.capture = false;

    if( start ){
      start.unactivate();
    }
  } );

  var touchendHandler;
  r.registerBinding( window, 'touchend', touchendHandler = function( e ){ // eslint-disable-line no-undef
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if( capture ){
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }
    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }
    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }

    if( start ){
      start.unactivate();
    }

    var ctxTapend;
    if( r.touchData.cxt ){
      ctxTapend = new Event( e, {
        type: 'cxttapend',
        cyPosition: { x: now[0], y: now[1] }
      } );

      if( start ){
        start.trigger( ctxTapend );
      } else {
        cy.trigger( ctxTapend );
      }

      if( !r.touchData.cxtDragged ){
        var ctxTap = new Event( e, {
          type: 'cxttap',
          cyPosition: { x: now[0], y: now[1] }
        } );

        if( start ){
          start.trigger( ctxTap );
        } else {
          cy.trigger( ctxTap );
        }

      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
      r.touchData.selecting = false;

      var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint( 'select', true );

      cy.trigger('boxend');

      var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };

      box
        .trigger('box')
        .stdFilter( eleWouldBeSelected )
          .select()
          .trigger('boxselect')
      ;

      if( box.nonempty() ){
        r.redrawHint( 'eles', true );
      }

      r.redraw();
    }

    if( start != null ){
      start.unactivate();
    }

    if( e.touches[2] ){
      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );
    } else if( e.touches[1] ){
      // ignore
    } else if( e.touches[0] ){
      // ignore

    // Last touch released
    } else if( !e.touches[0] ){

      r.data.bgActivePosistion = undefined;
      r.redrawHint( 'select', true );

      var draggedEles = r.dragData.touchDragEles;

      if( start != null ){

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements( draggedEles );

        r.redrawHint( 'drag', true );
        r.redrawHint( 'eles', true );

        if( startWasGrabbed ){
          start.trigger( 'free' );
        }

        triggerEvents( start, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        start.unactivate();

        r.touchData.start = null;

      } else {
        var near = r.findNearestElement( now[0], now[1], true );

        triggerEvents( near, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if( start != null
          && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable
          && rdist2 < r.touchTapThreshold2
          && !r.pinching // pinch to zoom should not affect selection
      ){

        if( cy.selectionType() === 'single' ){
          cy.$( ':selected' ).unmerge( start ).unselect();
          start.select();
        } else {
          if( start.selected() ){
            start.unselect();
          } else {
            start.select();
          }
        }

        r.redrawHint( 'eles', true );
      }

      // Tap event, roughly same as mouse click event for touch
      if( !r.touchData.singleTouchMoved ){
        triggerEvents( start, [ 'tap', 'vclick' ], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );
      }

      r.touchData.singleTouchMoved = true;
    }

    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }

    r.dragData.didDrag = false; // reset for next mousedown

    if( e.touches.length === 0 ){
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
    }

    if( e.touches.length < 2 ){
      r.pinching = false;
      r.redrawHint( 'eles', true );
      r.redraw();
    }

    //r.redraw();

  }, false );

  // fallback compatibility layer for ms pointer events
  if( typeof TouchEvent === 'undefined' ){

    var pointers = [];

    var makeTouch = function( e ){
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function( e ){
      return {
        event: e,
        touch: makeTouch( e )
      };
    };

    var addPointer = function( e ){
      pointers.push( makePointer( e ) );
    };

    var removePointer = function( e ){
      for( var i = 0; i < pointers.length; i++ ){
        var p = pointers[ i ];

        if( p.event.pointerId === e.pointerId ){
          pointers.splice( i, 1 );
          return;
        }
      }
    };

    var updatePointer = function( e ){
      var p = pointers.filter( function( p ){
        return p.event.pointerId === e.pointerId;
      } )[0];

      p.event = e;
      p.touch = makeTouch( e );
    };

    var addTouchesToEvent = function( e ){
      e.touches = pointers.map( function( p ){
        return p.touch;
      } );
    };

    r.registerBinding( r.container, 'pointerdown', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      addPointer( e );

      addTouchesToEvent( e );
      touchstartHandler( e );
    } );

    r.registerBinding( r.container, 'pointerup', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchendHandler( e );
    } );

    r.registerBinding( r.container, 'pointercancel', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchcancelHandler( e );
    } );

    r.registerBinding( r.container, 'pointermove', function( e ){
      if( e.pointerType === 'mouse' ){ return; } // mouse already handled

      e.preventDefault();

      updatePointer( e );

      addTouchesToEvent( e );
      touchmoveHandler( e );
    } );

  }
};

module.exports = BRp;

},{"../../../event":48,"../../../is":86,"../../../math":88,"../../../util":103}],65:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var BRp = {};

BRp.generatePolygon = function( name, points ){
  return ( this.nodeShapes[ name ] = {
    renderer: this,

    name: name,

    points: points,

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( 'polygon', context, centerX, centerY, width, height, this.points );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.polygonIntersectLine(
          x, y,
          this.points,
          nodeX,
          nodeY,
          width / 2, height / 2,
          padding )
        ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      return math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height, [0, -1], padding )
      ;
    }
  } );
};

BRp.generateEllipse = function(){
  return ( this.nodeShapes['ellipse'] = {
    renderer: this,

    name: 'ellipse',

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding )
      ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      x -= centerX;
      y -= centerY;

      x /= (width / 2 + padding);
      y /= (height / 2 + padding);

      return x * x + y * y <= 1;
    }
  } );
};

BRp.generateRoundRectangle = function(){
  return ( this.nodeShapes['roundrectangle'] = {
    renderer: this,

    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),

    draw: function( context, centerX, centerY, width, height ){
      this.renderer.nodeShapeImpl( this.name, context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding )
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius( width, height );

      // Check hBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){
        return true;
      }

      // Check vBox
      if( math.pointInsidePolygon( x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x * x + y * y <= 1);
      };


      // Check top left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check top right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom right quarter circle
      if( checkInEllipse( x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      // Check bottom left quarter circle
      if( checkInEllipse( x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding ) ){

        return true;
      }

      return false;
    }
  } );
};

BRp.registerNodeShapes = function(){
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  this.generateEllipse();

  this.generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare( 3, 0 ) );

  this.generatePolygon( 'rectangle', math.generateUnitNgonPointsFitToSquare( 4, 0 ) );
  nodeShapes[ 'square' ] = nodeShapes[ 'rectangle' ];

  this.generateRoundRectangle();

  this.generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );

  this.generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare( 5, 0 ) );

  this.generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare( 6, 0 ) );

  this.generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare( 7, 0 ) );

  this.generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare( 8, 0 ) );

  var star5Points = new Array( 20 );
  {
    var outerPoints = math.generateUnitNgonPoints( 5, 0 );
    var innerPoints = math.generateUnitNgonPoints( 5, Math.PI / 5 );

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt( 5 ));
    innerRadius *= 1.57;

    for( var i = 0;i < innerPoints.length / 2;i++ ){
      innerPoints[ i * 2] *= innerRadius;
      innerPoints[ i * 2 + 1] *= innerRadius;
    }

    for( var i = 0;i < 20 / 4;i++ ){
      star5Points[ i * 4] = outerPoints[ i * 2];
      star5Points[ i * 4 + 1] = outerPoints[ i * 2 + 1];

      star5Points[ i * 4 + 2] = innerPoints[ i * 2];
      star5Points[ i * 4 + 3] = innerPoints[ i * 2 + 1];
    }
  }

  star5Points = math.fitPolygonToSquare( star5Points );

  this.generatePolygon( 'star', star5Points );

  this.generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );

  this.generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

  nodeShapes.makePolygon = function( points ){

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join( '$' );
    var name = 'polygon-' + key;
    var shape;

    if( (shape = this[ name ]) ){ // got cached shape
      return shape;
    }

    // create and cache new shape
    return renderer.generatePolygon( name, points );
  };

};

module.exports = BRp;

},{"../../../math":88}],66:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );

var BRp = {};

BRp.timeToRender = function(){
  return this.redrawTotalTime / this.redrawCount;
};

BRp.redraw = function( options ){
  options = options || util.staticEmptyObject();

  var r = this;

  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }
  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp.beforeRender = function( fn, priority ){
  // the renderer can't add tick callbacks when destroyed
  if( this.destroyed ){ return; }

  priority = priority || 0;

  var cbs = this.beforeRenderCallbacks;

  cbs.push({ fn: fn, priority: priority });

  // higher priority callbacks executed first
  cbs.sort(function( a, b ){ return b.priority - a.priority; });
};

var beforeRenderCallbacks = function( r, willDraw, startTime ){
  var cbs = r.beforeRenderCallbacks;

  for( var i = 0; i < cbs.length; i++ ){
    cbs[i].fn( willDraw, startTime );
  }
};

BRp.startRenderLoop = function(){
  var r = this;

  if( r.renderLoopStarted ){
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function( requestTime ){
    if( r.destroyed ){ return; }

    if( r.requestedFrame && !r.skipFrame ){
      beforeRenderCallbacks( r, true, requestTime );

      var startTime = util.performanceNow();

      r.render( r.renderOptions );

      var endTime = r.lastDrawTime = util.performanceNow();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks( r, false, requestTime );
    }

    r.skipFrame = false;

    util.requestAnimationFrame( renderFn );
  };

  util.requestAnimationFrame( renderFn );

};

module.exports = BRp;

},{"../../../util":103}],67:[function(require,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.arrowShapeImpl = function( name ){
  return ( impl || (impl = {
    'polygon': function( context, points ){
      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        context.lineTo( pt.x, pt.y );
      }
    },

    'triangle-backcurve': function( context, points, controlPoint ){
      var firstPt;

      for( var i = 0; i < points.length; i++ ){
        var pt = points[ i ];

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo( pt.x, pt.y );
      }

      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
    },

    'triangle-tee': function( context, trianglePoints, teePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }

      if( context.beginPath ){ context.beginPath(); }

        var teePts = teePoints;
        var firstTeePt = teePoints[0];
        context.moveTo( firstTeePt.x, firstTeePt.y );

        for( var i = 0; i < teePts.length; i++ ){
          var pt = teePts[ i ];

          context.lineTo( pt.x, pt.y );
        }
      if( context.closePath ){ context.closePath(); }
    },

    'triangle-cross': function( context, trianglePoints, crossLinePoints ){
      if( context.beginPath ){ context.beginPath(); }

        var triPts = trianglePoints;
        for( var i = 0; i < triPts.length; i++ ){
          var pt = triPts[ i ];

          context.lineTo( pt.x, pt.y );
        }

      if( context.closePath ){ context.closePath(); }


      if( context.beginPath ){ context.beginPath(); }

      var crossLinePts = crossLinePoints;
      var firstTeePt = crossLinePoints[0];
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for( var i = 0; i < crossLinePts.length; i++ ){
        var pt = crossLinePts[ i ];

        context.lineTo( pt.x, pt.y );
      }
      if( context.closePath ){ context.closePath(); }
    },

    'circle': function( context, rx, ry, r ){
      context.arc( rx, ry, r, 0, Math.PI * 2, false );
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],68:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.drawEdge = function( context, edge, shiftToOriginWithBb, drawLabel, drawOverlayInstead ){
  var rs = edge._private.rscratch;
  var usePaths = this.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if( rs.badLine || isNaN(rs.allpts[0]) ){ // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  if( !edge.visible() ){ return; }

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  var overlayPadding = edge.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = edge.pstyle( 'overlay-opacity' ).value;
  var overlayColor = edge.pstyle( 'overlay-color' ).value;

  // Edge color & opacity
  if( drawOverlayInstead ){

    if( overlayOpacity === 0 ){ // exit early if no overlay
      return;
    }

    this.strokeStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );
    context.lineCap = 'round';

    if( rs.edgeType == 'self' && !usePaths ){
      context.lineCap = 'butt';
    }

  } else {
    var lineColor = edge.pstyle( 'line-color' ).value;

    this.strokeStyle( context, lineColor[0], lineColor[1], lineColor[2], edge.pstyle( 'opacity' ).value );

    context.lineCap = 'butt';
  }

  context.lineJoin = 'round';

  var edgeWidth = edge.pstyle( 'width' ).pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
  var lineStyle = drawOverlayInstead ? 'solid' : edge.pstyle( 'line-style' ).value;
  context.lineWidth = edgeWidth;

  var shadowBlur = edge.pstyle( 'shadow-blur' ).pfValue;
  var shadowOpacity = edge.pstyle( 'shadow-opacity' ).value;
  var shadowColor = edge.pstyle( 'shadow-color' ).value;
  var shadowOffsetX = edge.pstyle( 'shadow-offset-x' ).pfValue;
  var shadowOffsetY = edge.pstyle( 'shadow-offset-y' ).pfValue;

  this.shadowStyle( context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );

  this.drawEdgePath(
    edge,
    context,
    rs.allpts,
    lineStyle,
    edgeWidth
  );

  this.drawArrowheads( context, edge, drawOverlayInstead );

  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy

  if( !drawOverlayInstead ){
    this.drawEdge( context, edge, false, drawLabel, true );
  }

  this.drawElementText( context, edge, drawLabel );

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }
};


CRp.drawEdgePath = function( edge, context, pts, type, width ){
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if( usePaths ){
    var pathCacheKey = pts.join( '$' );
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if( keyMatches ){
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( canvasCxt.setLineDash ){ // for very outofdate browsers
    switch( type ){
      case 'dotted':
        canvasCxt.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        canvasCxt.setLineDash( [ 6, 3 ] );
        break;

      case 'solid':
        canvasCxt.setLineDash( [ ] );
        break;
    }
  }

  if( !pathCacheHit && !rs.badLine ){
    if( context.beginPath ){ context.beginPath(); }
    context.moveTo( pts[0], pts[1] );

    switch( rs.edgeType ){
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for( var i = 2; i + 3 < pts.length; i += 4 ){
          context.quadraticCurveTo( pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] );
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for( var i = 2; i + 1 < pts.length; i += 2 ){
          context.lineTo( pts[ i ], pts[ i + 1] );
        }
        break;
    }
  }

  context = canvasCxt;
  if( usePaths ){
    context.stroke( path );
  } else {
    context.stroke();
  }

  // reset any line dashes
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

};

CRp.drawArrowheads = function( context, edge, drawOverlayInstead ){
  if( drawOverlayInstead ){ return; } // don't do anything for overlays

  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
  }

  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );

  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
  }
};

CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
  if( isNaN( x ) || x == null || isNaN( y ) || y == null || isNaN( angle ) || angle == null ){ return; }

  var self = this;
  var arrowShape = edge.pstyle( prefix + '-arrow-shape' ).value;
  if( arrowShape === 'none' ) { return; }

  var arrowClearFill = edge.pstyle( prefix + '-arrow-fill' ).value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle( prefix + '-arrow-fill' ).value;
  var edgeWidth = edge.pstyle( 'width' ).pfValue;
  var opacity = edge.pstyle( 'opacity' ).value;

  var gco = context.globalCompositeOperation;

  var shapeImpl = self.arrowShapes[ arrowShape ];

  // check if the shape needs both fill and stroke operations to be drawn
  if( shapeImpl.forceStroke && arrowFill === 'filled' ){
    arrowFill = 'both';
  }

  if( opacity !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle( context, 255, 255, 255, 1 );
    self.strokeStyle( context, 255, 255, 255, 1 );

    self.drawArrowShape( edge, prefix, context,
      arrowClearFill, edgeWidth, arrowShape, x, y, angle
    );

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = edge.pstyle( prefix + '-arrow-color' ).value;
  self.fillStyle( context, color[0], color[1], color[2], opacity );
  self.strokeStyle( context, color[0], color[1], color[2], opacity );

  self.drawArrowShape( edge, prefix, context,
    arrowFill, edgeWidth, arrowShape, x, y, angle
  );
};

CRp.drawArrowShape = function( edge, arrowType, context, fill, edgeWidth, shape, x, y, angle ){
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var scale = edge.pstyle( 'arrow-scale' ).value;
  var size = this.getArrowWidth( edgeWidth, scale );
  var shapeImpl = r.arrowShapes[ shape ];

  if( usePaths ){
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[ arrowType ] === pathCacheKey;
    if( alreadyCached ){
      path = context = rs.arrowPathCache[ arrowType ];
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.arrowPathCacheKey[ arrowType ] = pathCacheKey;
      rs.arrowPathCache[ arrowType ] = path;
    }
  }

  if( context.beginPath ){ context.beginPath(); }

  if( !pathCacheHit ){
    shapeImpl.draw( context, size, angle, translation, edgeWidth );
  }

  if( !shapeImpl.leavePathOpen && context.closePath ){
    context.closePath();
  }

  context = canvasContext;

  if( fill === 'filled' || fill === 'both' ){
    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  if( fill === 'hollow' || fill === 'both' ){
    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
    context.lineJoin = 'miter';

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  }
};

module.exports = CRp;

},{}],69:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var CRp = {};

CRp.drawElement = function( context, ele, shiftToOriginWithBb, showLabel ){
  var r = this;

  if( ele.isNode() ){
    r.drawNode( context, ele, shiftToOriginWithBb, showLabel );
  } else {
    r.drawEdge( context, ele, shiftToOriginWithBb, showLabel );
  }
};

CRp.drawCachedElement = function( context, ele, pxRatio, extent ){
  var r = this;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  if( !extent || math.boundingBoxesIntersect( bb, extent ) ){
    var cache = r.data.eleTxrCache.getElement( ele, bb, pxRatio );

    if( cache ){
      context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );
    } else { // if the element is not cacheable, then draw directly
      r.drawElement( context, ele );
    }
  }
};

CRp.drawElements = function( context, eles ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawElement( context, ele );
  }
};

CRp.drawCachedElements = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawCachedNodes = function( context, eles, pxRatio, extent ){
  var r = this;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];

    if( !ele.isNode() ){ continue; }

    r.drawCachedElement( context, ele, pxRatio, extent );
  }
};

CRp.drawLayeredElements = function( context, eles, pxRatio, extent ){
  var r = this;

  var layers = r.data.lyrTxrCache.getLayers( eles, pxRatio );

  if( layers ){
    for( var i = 0; i < layers.length; i++ ){
      var layer = layers[i];
      var bb = layer.bb;

      if( bb.w === 0 || bb.h === 0 ){ continue; }

      context.drawImage( layer.canvas, bb.x1, bb.y1, bb.w, bb.h );
    }
  } else { // fall back on plain caching if no layers
    r.drawCachedElements( context, eles, pxRatio, extent );
  }
};

CRp.drawDebugPoints = function( context, eles ){
  var draw = function( x, y, color ){
    context.fillStyle = color;
    context.fillRect( x - 1, y - 1, 3, 3 );
  }

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if( ele.isNode() ){
      var p = ele.position();

      draw( p.x, p.y, 'magenta' );
    } else {
      var pts = rs.allpts;

      for( var j = 0; j + 1 < pts.length; j += 2 ){
        var x = pts[ j ];
        var y = pts[ j + 1 ];

        draw( x, y, 'cyan' );
      }

      draw( rs.midX, rs.midY, 'yellow' );
    }
  }
};

module.exports = CRp;

},{"../../../math":88}],70:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
  var r = this;

  try {
    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
  } catch( e ){
    r.redrawHint( 'eles', true );
    r.redrawHint( 'drag', true );

    r.drawingImage = true;

    r.redraw();
  }
};

CRp.drawInscribedImage = function( context, img, node ){
  var r = this;
  var nodeX = node._private.position.x;
  var nodeY = node._private.position.y;
  var fit = node.pstyle( 'background-fit' ).value;
  var xPos = node.pstyle( 'background-position-x' );
  var yPos = node.pstyle( 'background-position-y' );
  var repeat = node.pstyle( 'background-repeat' ).value;
  var nodeW = node.width();
  var nodeH = node.height();
  var rs = node._private.rscratch;
  var clip = node.pstyle( 'background-clip' ).value;
  var shouldClip = clip === 'node';
  var imgOpacity = node.pstyle( 'background-image-opacity' ).value;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if( null == imgW || null == imgH ){
    document.body.appendChild( img ); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild( img ); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  var bgW = node.pstyle( 'background-width' );
  if( bgW.value !== 'auto' ){
    if( bgW.units === '%' ){
      w = bgW.pfValue * nodeW;
    } else {
      w = bgW.pfValue;
    }
  }

  var bgH = node.pstyle( 'background-height' );
  if( bgH.value !== 'auto' ){
    if( bgH.units === '%' ){
      h = bgH.pfValue * nodeH;
    } else {
      h = bgH.pfValue;
    }
  }

  if( w === 0 || h === 0 ){
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if( fit === 'contain' ){
    var scale = Math.min( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;

  } else if( fit === 'cover' ){
    var scale = Math.max( nodeW / w, nodeH / h );

    w *= scale;
    h *= scale;
  }

  var x = (nodeX - nodeW / 2); // left
  if( xPos.units === '%' ){
    x += (nodeW - w) * xPos.pfValue;
  } else {
    x += xPos.pfValue;
  }

  var y = (nodeY - nodeH / 2); // top
  if( yPos.units === '%' ){
    y += (nodeH - h) * yPos.pfValue;
  } else {
    y += yPos.pfValue;
  }

  if( rs.pathCache ){
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if( repeat === 'no-repeat' ){

    if( shouldClip ){
      context.save();

      if( rs.pathCache ){
        context.clip( rs.pathCache );
      } else {
        r.nodeShapes[ r.getNodeShape( node ) ].draw(
          context,
          nodeX, nodeY,
          nodeW, nodeH );

        context.clip();
      }
    }

    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );

    if( shouldClip ){
      context.restore();
    }
  } else {
    var pattern = context.createPattern( img, repeat );
    context.fillStyle = pattern;

    r.nodeShapes[ r.getNodeShape( node ) ].draw(
        context,
        nodeX, nodeY,
        nodeW, nodeH );

    context.translate( x, y );
    context.fill();
    context.translate( -x, -y );
  }

  context.globalAlpha = gAlpha;

};

module.exports = CRp;

},{}],71:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );
var math = require( '../../../math' );

var CRp = {};

CRp.eleTextBiggerThanMin = function( ele, scale ){
  if( !scale ){
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil( math.log2( zoom * pxRatio ) ); // the effective texture level

    scale = Math.pow( 2, lvl );
  }

  var computedSize = ele.pstyle( 'font-size' ).pfValue * scale;
  var minSize = ele.pstyle( 'min-zoomed-font-size' ).pfValue;

  if( computedSize < minSize ){
    return false;
  }

  return true;
};

CRp.drawElementText = function( context, ele, force ){
  var r = this;

  if( force === undefined ){
    if( !r.eleTextBiggerThanMin( ele ) ){ return; }
  } else {
    if( !force ){ return; }
  }

  if( ele.isNode() ){
    var label = ele.pstyle( 'label' );

    if( !label || !label.value ){ return; }

    var textHalign = ele.pstyle( 'text-halign' ).strValue;
    var textValign = ele.pstyle( 'text-valign' ).strValue;

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    context.textBaseline = 'bottom';
  } else {
    var label = ele.pstyle( 'label' );
    var srcLabel = ele.pstyle( 'source-label' );
    var tgtLabel = ele.pstyle( 'target-label' );

    if(
      ( !label || !label.value )
      && ( !srcLabel || !srcLabel.value )
      && ( !tgtLabel || !tgtLabel.value )
    ){
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }


  r.drawText( context, ele );

  if( ele.isEdge() ){
    r.drawText( context, ele, 'source' );

    r.drawText( context, ele, 'target' );
  }
};

CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

CRp.getFontCache = function( context ){
  var cache;

  this.fontCaches = this.fontCaches || [];

  for( var i = 0; i < this.fontCaches.length; i++ ){
    cache = this.fontCaches[ i ];

    if( cache.context === context ){
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push( cache );

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function( context, ele ){
  // Font style
  var parentOpacity = ele.effectiveOpacity();
  var labelStyle = ele.pstyle( 'font-style' ).strValue;
  var labelSize = ele.pstyle( 'font-size' ).pfValue + 'px';
  var labelFamily = ele.pstyle( 'font-family' ).strValue;
  var labelWeight = ele.pstyle( 'font-weight' ).strValue;
  var opacity = ele.pstyle( 'text-opacity' ).value * ele.pstyle( 'opacity' ).value * parentOpacity;
  var outlineOpacity = ele.pstyle( 'text-outline-opacity' ).value * opacity;
  var color = ele.pstyle( 'color' ).value;
  var outlineColor = ele.pstyle( 'text-outline-color' ).value;
  var shadowBlur = ele.pstyle( 'text-shadow-blur' ).pfValue;
  var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;
  var shadowColor = ele.pstyle( 'text-shadow-color' ).value;
  var shadowOffsetX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;
  var shadowOffsetY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;

  var fontCacheKey = ele._private.fontKey;
  var cache = this.getFontCache( context );

  if( cache.key !== fontCacheKey ){
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle( context, color[ 0 ], color[ 1 ], color[ 2 ], opacity );

  this.strokeStyle( context, outlineColor[ 0 ], outlineColor[ 1 ], outlineColor[ 2 ], outlineOpacity );

  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );
};

function roundRect( ctx, x, y, width, height, radius ){
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo( x + radius, y );
  ctx.lineTo( x + width - radius, y );
  ctx.quadraticCurveTo( x + width, y, x + width, y + radius );
  ctx.lineTo( x + width, y + height - radius );
  ctx.quadraticCurveTo( x + width, y + height, x + width - radius, y + height );
  ctx.lineTo( x + radius, y + height );
  ctx.quadraticCurveTo( x, y + height, x, y + height - radius );
  ctx.lineTo( x, y + radius );
  ctx.quadraticCurveTo( x, y, x + radius, y );
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function( context, ele, prefix ){
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = ele.effectiveOpacity();
  if( parentOpacity === 0 || ele.pstyle( 'text-opacity' ).value === 0 ){
    return;
  }

  var textX = util.getPrefixedProperty( rscratch, 'labelX', prefix );
  var textY = util.getPrefixedProperty( rscratch, 'labelY', prefix );
  var text = this.getLabelText( ele, prefix );

  if( text != null && text !== '' && !isNaN( textX ) && !isNaN( textY ) ){
    this.setupTextStyle( context, ele );

    var pdash = prefix ? prefix + '-' : '';
    var textW = util.getPrefixedProperty( rscratch, 'labelWidth', prefix );
    var textH = util.getPrefixedProperty( rscratch, 'labelHeight', prefix );
    var textAngle = util.getPrefixedProperty( rscratch, 'labelAngle', prefix );
    var marginX = ele.pstyle( pdash + 'text-margin-x' ).pfValue;
    var marginY = ele.pstyle( pdash + 'text-margin-y' ).pfValue;

    var isEdge = ele.isEdge();
    var isNode = ele.isNode();

    var halign = ele.pstyle( 'text-halign' ).value;
    var valign = ele.pstyle( 'text-valign' ).value;

    if( isEdge ){
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;

    var rotation = ele.pstyle( 'text-rotation' );
    var theta;

    if( rotation.strValue === 'autorotate' ){
      theta = isEdge ? textAngle : 0;
    } else if( rotation.strValue === 'none' ){
      theta = 0;
    } else {
      theta = rotation.pfValue;
    }

    if( theta !== 0 ){
      var orgTextX = textX;
      var orgTextY = textY;

      context.translate( orgTextX, orgTextY );
      context.rotate( theta );

      textX = 0;
      textY = 0;
    }

    switch( valign ){
      case 'top':
        break;
      case 'center':
        textY += textH / 2;
        break;
      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle( 'text-background-opacity' ).value;
    var borderOpacity = ele.pstyle( 'text-border-opacity' ).value;
    var textBorderWidth = ele.pstyle( 'text-border-width' ).pfValue;
    var backgroundPadding = ele.pstyle( 'text-background-padding' ).pfValue;

    if( backgroundOpacity > 0 || ( textBorderWidth > 0 && borderOpacity > 0 ) ){
      var bgX = textX - backgroundPadding;

      switch( halign ){
        case 'left':
          bgX -= textW;
          break;
        case 'center':
          bgX -= textW / 2;
          break;
        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2*backgroundPadding;
      var bgH = textH + 2*backgroundPadding;

      if( backgroundOpacity > 0 ){
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle( 'text-background-color' ).value;

        context.fillStyle = 'rgba(' + textBackgroundColor[ 0 ] + ',' + textBackgroundColor[ 1 ] + ',' + textBackgroundColor[ 2 ] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle( 'text-background-shape' ).strValue;
        if( styleShape == 'roundrectangle' ){
          roundRect( context, bgX, bgY, bgW, bgH, 2 );
        } else {
          context.fillRect( bgX, bgY, bgW, bgH );
        }
        context.fillStyle = textFill;
      }

      if( textBorderWidth > 0 && borderOpacity > 0 ){
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle( 'text-border-color' ).value;
        var textBorderStyle = ele.pstyle( 'text-border-style' ).value;

        context.strokeStyle = 'rgba(' + textBorderColor[ 0 ] + ',' + textBorderColor[ 1 ] + ',' + textBorderColor[ 2 ] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if( context.setLineDash ){ // for very outofdate browsers
          switch( textBorderStyle ){
            case 'dotted':
              context.setLineDash( [ 1, 1 ] );
              break;
            case 'dashed':
              context.setLineDash( [ 4, 2 ] );
              break;
            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
              context.setLineDash( [] );
              break;
            case 'solid':
              context.setLineDash( [] );
              break;
          }
        }

        context.strokeRect( bgX, bgY, bgW, bgH );

        if( textBorderStyle === 'double' ){
          var whiteWidth = textBorderWidth / 2;

          context.strokeRect( bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2 );
        }

        if( context.setLineDash ){ // for very outofdate browsers
          context.setLineDash( [] );
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }

    }

    var lineWidth = 2 * ele.pstyle( 'text-outline-width' ).pfValue; // *2 b/c the stroke is drawn centred on the middle

    if( lineWidth > 0 ){
      context.lineWidth = lineWidth;
    }

    if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){
      var lines = util.getPrefixedProperty( rscratch, 'labelWrapCachedLines', prefix );
      var lineHeight = textH / lines.length;

      switch( valign ){
        case 'top':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
        case 'center':
        case 'bottom':
          textY -= ( lines.length - 1 ) * lineHeight;
          break;
      }

      for( var l = 0; l < lines.length; l++ ){
        if( lineWidth > 0 ){
          context.strokeText( lines[ l ], textX, textY );
        }

        context.fillText( lines[ l ], textX, textY );

        textY += lineHeight;
      }

    } else {
      if( lineWidth > 0 ){
        context.strokeText( text, textX, textY );
      }

      context.fillText( text, textX, textY );
    }

    if( theta !== 0 ){
      context.rotate( -theta );
      context.translate( -orgTextX, -orgTextY );
    }

    this.shadowStyle( context, 'transparent', 0 ); // reset for next guy
  }
};

module.exports = CRp;

},{"../../../math":88,"../../../util":103}],72:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );

var CRp = {};

CRp.drawNode = function( context, node, shiftToOriginWithBb, drawLabel ){
  var r = this;
  var nodeWidth, nodeHeight;
  var rs = node._private.rscratch;
  var _p = node._private;
  var pos = pos || _p.position;

  if( !is.number( pos.x ) || !is.number( pos.y ) ){
    return; // can't draw node with undefined position
  }

  if( !node.visible() ){ return; }

  var parentOpacity = node.effectiveOpacity();

  var usePaths = this.usePaths();
  var path;
  var pathCacheHit = false;

  var padding = node.pstyle('padding').pfValue;

  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;

  context.lineWidth = node.pstyle( 'border-width' ).pfValue;

  //
  // setup shift

  var bb;
  if( shiftToOriginWithBb ){
    bb = shiftToOriginWithBb;

    context.translate( -bb.x1, -bb.y1 );
  }

  //
  // load bg image

  var bgImgProp = node.pstyle( 'background-image' );
  var url = bgImgProp.value[2] || bgImgProp.value[1];
  var image;

  if( url !== undefined ){

    var bgImgCrossOrigin = node.pstyle( 'background-image-crossorigin' );

    // get image, and if not loaded then ask to redraw when later loaded
    image = this.getCachedImage( url, bgImgCrossOrigin, function(){
      node.trigger('background');

      r.redrawHint( 'eles', true );
      r.redrawHint( 'drag', true );

      r.drawingImage = true;

      r.redraw();
    } );

    var prevBging = _p.backgrounding;
    _p.backgrounding = !image.complete;

    if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
      node.updateStyle( false );
    }
  }

  //
  // setup styles

  var bgColor = node.pstyle( 'background-color' ).value;
  var borderColor = node.pstyle( 'border-color' ).value;
  var borderStyle = node.pstyle( 'border-style' ).value;

  this.fillStyle( context, bgColor[0], bgColor[1], bgColor[2], node.pstyle( 'background-opacity' ).value * parentOpacity );

  this.strokeStyle( context, borderColor[0], borderColor[1], borderColor[2], node.pstyle( 'border-opacity' ).value * parentOpacity );

  var shadowBlur = node.pstyle( 'shadow-blur' ).pfValue;
  var shadowOpacity = node.pstyle( 'shadow-opacity' ).value;
  var shadowColor = node.pstyle( 'shadow-color' ).value;
  var shadowOffsetX = node.pstyle( 'shadow-offset-x' ).pfValue;
  var shadowOffsetY = node.pstyle( 'shadow-offset-y' ).pfValue;

  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );

  context.lineJoin = 'miter'; // so borders are square with the node shape

  if( context.setLineDash ){ // for very outofdate browsers
    switch( borderStyle ){
      case 'dotted':
        context.setLineDash( [ 1, 1 ] );
        break;

      case 'dashed':
        context.setLineDash( [ 4, 2 ] );
        break;

      case 'solid':
      case 'double':
        context.setLineDash( [ ] );
        break;
    }
  }


  //
  // draw shape

  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if( usePaths ){
    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + ( styleShape === 'polygon' ? '$' + shapePts.join('$') : '' );

    context.translate( pos.x, pos.y );

    if( rs.pathCacheKey === pathCacheKey ){
      path = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( !pathCacheHit ){

    var npos = pos;

    if( usePaths ){
      npos = {
        x: 0,
        y: 0
      };
    }

    r.nodeShapes[ this.getNodeShape( node ) ].draw(
          ( path || context ),
          npos.x,
          npos.y,
          nodeWidth,
          nodeHeight );
  }

  if( usePaths ){
    context.fill( path );
  } else {
    context.fill();
  }

  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy

  //
  // bg image

  if( url !== undefined ){
    if( image.complete ){
      this.drawInscribedImage( context, image, node );
    }
  }

  //
  // pie

  var darkness = node.pstyle( 'background-blacken' ).value;
  var borderWidth = node.pstyle( 'border-width' ).pfValue;

  if( this.hasPie( node ) ){
    this.drawPie( context, node, parentOpacity );

    // redraw path for blacken and border
    if( darkness !== 0 || borderWidth !== 0 ){

      if( !usePaths ){
        r.nodeShapes[ this.getNodeShape( node ) ].draw(
            context,
            pos.x,
            pos.y,
            nodeWidth,
            nodeHeight );
      }
    }
  }

  //
  // darken/lighten

  if( darkness > 0 ){
    this.fillStyle( context, 0, 0, 0, darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }

  } else if( darkness < 0 ){
    this.fillStyle( context, 255, 255, 255, -darkness );

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  //
  // border

  if( borderWidth > 0 ){

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }

    if( borderStyle === 'double' ){
      context.lineWidth = node.pstyle( 'border-width' ).pfValue / 3;

      var gco = context.globalCompositeOperation;
      context.globalCompositeOperation = 'destination-out';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }

      context.globalCompositeOperation = gco;
    }

  }

  if( usePaths ){
    context.translate( -pos.x, -pos.y );
  }

  // reset in case we changed the border style
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash( [ ] );
  }

  //
  // label

  r.drawElementText( context, node, drawLabel );

  //
  // overlay

  var overlayPadding = node.pstyle( 'overlay-padding' ).pfValue;
  var overlayOpacity = node.pstyle( 'overlay-opacity' ).value;
  var overlayColor = node.pstyle( 'overlay-color' ).value;

  if( overlayOpacity > 0 ){
    this.fillStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );

    r.nodeShapes[ 'roundrectangle' ].draw(
      context,
      node._private.position.x,
      node._private.position.y,
      nodeWidth + overlayPadding * 2,
      nodeHeight + overlayPadding * 2
    );

    context.fill();
  }

  //
  // clean up shift

  if( shiftToOriginWithBb ){
    context.translate( bb.x1, bb.y1 );
  }

};

// does the node have at least one pie piece?
CRp.hasPie = function( node ){
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function( context, node, nodeOpacity, pos ){
  node = node[0]; // ensure ele ref

  var _p = node._private;
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle( 'pie-size' );
  var nodeW = node.width();
  var nodeH = node.height();
  var pos = pos || _p.position;
  var x = pos.x;
  var y = pos.y;
  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if( usePaths ){
    x = 0;
    y = 0;
  }

  if( pieSize.units === '%' ){
    radius = radius * pieSize.pfValue;
  } else if( pieSize.pfValue !== undefined ){
    radius = pieSize.pfValue / 2;
  }

  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
    var size = node.pstyle( 'pie-' + i + '-background-size' ).value;
    var color = node.pstyle( 'pie-' + i + '-background-color' ).value;
    var opacity = node.pstyle( 'pie-' + i + '-background-opacity' ).value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if( percent + lastPercent > 1 ){
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
      continue;
    }

    context.beginPath();
    context.moveTo( x, y );
    context.arc( x, y, radius, angleStart, angleEnd );
    context.closePath();

    this.fillStyle( context, color[0], color[1], color[2], opacity );

    context.fill();

    lastPercent += percent;
  }

};


module.exports = CRp;

},{"../../../is":86}],73:[function(require,module,exports){
'use strict';

var CRp = {};

var util = require( '../../../util' );

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function(){
  var context = this.data.contexts[0];

  if( this.forcedPixelRatio != null ){
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp.paintCache = function( context ){
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for( var i = 0; i < caches.length; i++ ){
    cache = caches[ i ];

    if( cache.context === context ){
      needToCreateCache = false;
      break;
    }
  }

  if( needToCreateCache ){
    cache = {
      context: context
    };
    caches.push( cache );
  }

  return cache;
};

CRp.fillStyle = function( context, r, g, b, a ){
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function( context, r, g, b, a ){
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp.shadowStyle = function( context, color, opacity, blur, offsetX, offsetY ){
  var zoom = this.cy.zoom();

  // var cache = this.paintCache( context );
  //
  // // don't make expensive changes to the shadow style if it's not used
  // if( cache.shadowOpacity === 0 && opacity === 0 ){
  //   return;
  // }
  //
  // cache.shadowOpacity = opacity;

  if( opacity > 0 ){
    context.shadowBlur = blur * zoom;
    context.shadowColor = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + opacity + ')';
    context.shadowOffsetX = offsetX * zoom;
    context.shadowOffsetY = offsetY * zoom;
  } else {
    context.shadowBlur = 0;
    context.shadowColor = 'transparent';
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
};

// Resize canvas
CRp.matchCanvasSize = function( container ){
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if(
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ] ||
    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ]
  ){
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for( var i = 0; i < r.CANVAS_LAYERS; i++ ){

    canvas = data.canvases[ i ];

    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  for( var i = 0; i < r.BUFFER_COUNT; i++ ){

    canvas = data.bufferCanvases[ i ];

    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  r.textureMult = 1;
  if( pixelRatio <= 1 ){
    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;

};

CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
  this.render( {
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  } );
};

CRp.render = function( options ){
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy; var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if( !forcedContext ){
    if( r.prevPxRatio !== pixelRatio ){
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize( r.container );

      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if( !forcedContext && r.motionBlurTimeout ){
    clearTimeout( r.motionBlurTimeout );
  }

  if( motionBlur ){
    if( r.mbFrames == null ){
      r.mbFrames = 0;
    }

    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
      r.mbFrames++;
    }

    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if( r.mbFrames > r.minMbLowQualFrames ){
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if( r.clearingMotionBlur ){
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if( r.textureDrawLastFrame && !textureDraw ){
    needDraw[ r.NODE ] = true;
    needDraw[ r.SELECT_BOX ] = true;
  }

  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
    r.motionBlurPxRatio = 1;
  }

  if( forcedPan ){
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = r.getCachedZSortedEles();

  function mbclear( context, x, y, w, h ){
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
    context.fillRect( x, y, w, h );

    context.globalCompositeOperation = gco;
  }

  function setContextTransform( context, clear ){
    var ePan, eZoom, w, h;

    if( !r.clearingMotionBlur && (context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] || context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ]) ){
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( clear === 'motionBlur' ){
      mbclear( context, 0, 0, w, h );
    } else if( !forcedContext && (clear === undefined || clear) ){
      context.clearRect( 0, 0, w, h );
    }

    if( !drawAllLayers ){
      context.translate( ePan.x, ePan.y );
      context.scale( eZoom, eZoom );
    }
    if( forcedPan ){
      context.translate( forcedPan.x, forcedPan.y );
    }
    if( forcedZoom ){
      context.scale( forcedZoom, forcedZoom );
    }
  }

  if( !textureDraw ){
    r.textureDrawLastFrame = false;
  }

  if( textureDraw ){
    r.textureDrawLastFrame = true;

    var bb;

    if( !r.textureCache ){
      r.textureCache = {};

      bb = r.textureCache.bb = cy.mutableElements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];

      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];

      cxt.setTransform( 1, 0, 0, 1, 0, 0 );
      cxt.clearRect( 0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult );

      r.render( {
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      } );

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[ r.DRAG ] = false;
    needDraw[ r.NODE ] = false;

    var context = data.contexts[ r.NODE ];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform( 1, 0, 0, 1, 0, 0 );

    if( motionBlur ){
      mbclear( context, 0, 0, vp.width, vp.height );
    } else {
      context.clearRect( 0, 0, vp.width, vp.height );
    }

    var outsideBgColor = coreStyle[ 'outside-texture-bg-color' ].value;
    var outsideBgOpacity = coreStyle[ 'outside-texture-bg-opacity' ].value;
    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
    context.fillRect( 0, 0, vp.width, vp.height );

    var zoom = cy.zoom();

    setContextTransform( context, false );

    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );
    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );

  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
  var hideEdges = r.hideEdgesOnViewport && vpManip;

  var needMbClear = [];

  needMbClear[ r.NODE ] = !needDraw[ r.NODE ] && motionBlur && !r.clearedForMotionBlur[ r.NODE ] || r.clearingMotionBlur;
  if( needMbClear[ r.NODE ] ){ r.clearedForMotionBlur[ r.NODE ] = true; }

  needMbClear[ r.DRAG ] = !needDraw[ r.DRAG ] && motionBlur && !r.clearedForMotionBlur[ r.DRAG ] || r.clearingMotionBlur;
  if( needMbClear[ r.DRAG ] ){ r.clearedForMotionBlur[ r.DRAG ] = true; }

  if( needDraw[ r.NODE ] || drawAllLayers || drawOnlyNodeLayer || needMbClear[ r.NODE ] ){
    var useBuffer = motionBlur && !needMbClear[ r.NODE ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[ r.NODE ] );
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform( context, clear );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.nondrag, pixelRatio, extent );
    } else {
      r.drawLayeredElements( context, eles.nondrag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.nondrag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.NODE ] = false;
    }
  }

  if( !drawOnlyNodeLayer && (needDraw[ r.DRAG ] || drawAllLayers || needMbClear[ r.DRAG ]) ){
    var useBuffer = motionBlur && !needMbClear[ r.DRAG ] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[ r.DRAG ] );

    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );

    if( hideEdges ){
      r.drawCachedNodes( context, eles.drag, pixelRatio, extent );
    } else {
      r.drawCachedElements( context, eles.drag, pixelRatio, extent );
    }

    if( r.debug ){
      r.drawDebugPoints( context, eles.drag );
    }

    if( !drawAllLayers && !motionBlur ){
      needDraw[ r.DRAG ] = false;
    }
  }

  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[ r.SELECT_BOX ] && !drawAllLayers)) ){
    var context = forcedContext || data.contexts[ r.SELECT_BOX ];

    setContextTransform( context );

    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle[ 'selection-box-border-width' ].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba('
        + coreStyle[ 'selection-box-color' ].value[0] + ','
        + coreStyle[ 'selection-box-color' ].value[1] + ','
        + coreStyle[ 'selection-box-color' ].value[2] + ','
        + coreStyle[ 'selection-box-opacity' ].value + ')';

      context.fillRect(
        r.selection[0],
        r.selection[1],
        r.selection[2] - r.selection[0],
        r.selection[3] - r.selection[1] );

      if( borderWidth > 0 ){
        context.strokeStyle = 'rgba('
          + coreStyle[ 'selection-box-border-color' ].value[0] + ','
          + coreStyle[ 'selection-box-border-color' ].value[1] + ','
          + coreStyle[ 'selection-box-border-color' ].value[2] + ','
          + coreStyle[ 'selection-box-opacity' ].value + ')';

        context.strokeRect(
          r.selection[0],
          r.selection[1],
          r.selection[2] - r.selection[0],
          r.selection[3] - r.selection[1] );
      }
    }

    if( data.bgActivePosistion && !r.hoverData.selecting ){
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = 'rgba('
        + coreStyle[ 'active-bg-color' ].value[0] + ','
        + coreStyle[ 'active-bg-color' ].value[1] + ','
        + coreStyle[ 'active-bg-color' ].value[2] + ','
        + coreStyle[ 'active-bg-opacity' ].value + ')';

      context.beginPath();
      context.arc( pos.x, pos.y, coreStyle[ 'active-bg-size' ].pfValue / zoom, 0, 2 * Math.PI );
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if( r.showFps && timeToRender ){
      timeToRender = Math.round( timeToRender );
      var fps = Math.round( 1000 / timeToRender );

      context.setTransform( 1, 0, 0, 1, 0, 0 );

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20 );

      var maxFps = 60;
      context.strokeRect( 0, 30, 250, 20 );
      context.fillRect( 0, 30, 250 * Math.min( fps / maxFps, 1 ), 20 );
    }

    if( !drawAllLayers ){
      needDraw[ r.SELECT_BOX ] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if( motionBlur && mbPxRatio !== 1 ){
    var cxtNode = data.contexts[ r.NODE ];
    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];

    var cxtDrag = data.contexts[ r.DRAG ];
    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];

    var drawMotionBlur = function( cxt, txt, needClear ){
      cxt.setTransform( 1, 0, 0, 1, 0, 0 );

      if( needClear || !motionBlurFadeEffect ){
        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
      } else {
        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
      }

      var pxr = mbPxRatio;

      cxt.drawImage(
        txt, // img
        0, 0, // sx, sy
        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
        0, 0, // x, y
        r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if( needDraw[ r.NODE ] || needMbClear[ r.NODE ] ){
      drawMotionBlur( cxtNode, txtNode, needMbClear[ r.NODE ] );
      needDraw[ r.NODE ] = false;
    }

    if( needDraw[ r.DRAG ] || needMbClear[ r.DRAG ] ){
      drawMotionBlur( cxtDrag, txtDrag, needMbClear[ r.DRAG ] );
      needDraw[ r.DRAG ] = false;
    }
  }

  r.prevViewport = vp;

  if( r.clearingMotionBlur ){
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if( motionBlur ){
    r.motionBlurTimeout = setTimeout( function(){
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[ r.NODE ] = false;
      r.clearedForMotionBlur[ r.DRAG ] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[ r.NODE ] = true;
      needDraw[ r.DRAG ] = true;

      r.redraw();
    }, motionBlurDelay );
  }

  r.drawingImage = false;


  if( !forcedContext && !r.initrender ){
    r.initrender = true;
    cy.trigger( 'initrender' );
  }

  if( !forcedContext ){
    cy.trigger('render');
  }

};

module.exports = CRp;

},{"../../../util":103}],74:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );

var CRp = {};

// @O Polygon drawing
CRp.drawPolygonPath = function(
  context, x, y, width, height, points ){

  var halfW = width / 2;
  var halfH = height / 2;

  if( context.beginPath ){ context.beginPath(); }

  context.moveTo( x + halfW * points[0], y + halfH * points[1] );

  for( var i = 1; i < points.length / 2; i++ ){
    context.lineTo( x + halfW * points[ i * 2], y + halfH * points[ i * 2 + 1] );
  }

  context.closePath();
};

// Round rectangle drawing
CRp.drawRoundRectanglePath = function(
  context, x, y, width, height ){

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius( width, height );

  if( context.beginPath ){ context.beginPath(); }

  // Start at top middle
  context.moveTo( x, y - halfHeight );
  // Arc from middle top to right side
  context.arcTo( x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius );
  // Arc from right side to bottom
  context.arcTo( x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius );
  // Arc from bottom to left side
  context.arcTo( x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius );
  // Arc from left side to topBorder
  context.arcTo( x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius );
  // Join line
  context.lineTo( x, y - halfHeight );


  context.closePath();
};

var sin0 = Math.sin( 0 );
var cos0 = Math.cos( 0 );

var sin = {};
var cos = {};

var ellipseStepSize = Math.PI / 40;

for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
  sin[ i ] = Math.sin( i );
  cos[ i ] = Math.cos( i );
}

CRp.drawEllipsePath = function( context, centerX, centerY, width, height ){
    if( context.beginPath ){ context.beginPath(); }

    if( context.ellipse ){
      context.ellipse( centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI );
    } else {
      var xPos, yPos;
      var rw = width / 2;
      var rh = height / 2;
      for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){
        xPos = centerX - (rw * sin[ i ]) * sin0 + (rw * cos[ i ]) * cos0;
        yPos = centerY + (rh * cos[ i ]) * sin0 + (rh * sin[ i ]) * cos0;

        if( i === 0 ){
          context.moveTo( xPos, yPos );
        } else {
          context.lineTo( xPos, yPos );
        }
      }
    }

    context.closePath();
  };

module.exports = CRp;

},{"../../../math":88}],75:[function(require,module,exports){
'use strict';

var math = require( '../../../math' );
var util = require( '../../../util' );
var Heap = require( '../../../heap' );
var defs = require( './texture-cache-defs' );

var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024;  // the maximum height of a texture
var minUtility = 0.5; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};

var ElementTextureCache = function( renderer ){
  var self = this;

  self.renderer = renderer;
  self.onDequeues = [];

  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;

ETCp.reasons = getTxrReasons;

// the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function( txrH ){
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};

  return ( self.eleImgCaches[ txrH ] = self.eleImgCaches[ txrH ] || [] );
};

// the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function( txrH ){
  var self = this;

  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[ txrH ] = rtxtrQs[ txrH ] || [];

  return rtxtrQ;
};

// queue of element draw requests at different scale levels
ETCp.getElementQueue = function(){
  var self = this;

  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function( a, b ){
    return b.reqs - a.reqs;
  });

  return q;
};

// queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementIdToQueue = function(){
  var self = this;

  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

  return id2q;
};

ETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){
  var self = this;
  var r = this.renderer;
  var rs = ele._private.rscratch;
  var zoom = r.cy.zoom();

  if( bb.w === 0 || bb.h === 0 ){ return null; }

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );
  }

  if( lvl < minLvl ){
    lvl = minLvl;
  } else if( zoom >= maxZoom || lvl > maxLvl ){
    return null;
  }

  var scale = Math.pow( 2, lvl );
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var caches = rs.imgCaches = rs.imgCaches || {};
  var eleCache = caches[lvl];

  if( eleCache ){
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if( eleScaledH <= minTxrH ){
    txrH = minTxrH;
  } else if( eleScaledH <= txrStepH ){
    txrH = txrStepH;
  } else {
    txrH = Math.ceil( eleScaledH / txrStepH ) * txrStepH;
  }

  if(
    eleScaledH > maxTxrH
    || eleScaledW > maxTxrW
    || ( !allowEdgeTxrCaching && ele.isEdge() )
    || ( !allowParentTxrCaching && ele.isParent() )
  ){
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue( txrH );

  // first try the second last one in case it has space at the end
  var txr = txrQ[ txrQ.length - 2 ];

  var addNewTxr = function(){
    return self.recycleTexture( txrH, eleScaledW ) || self.addTexture( txrH, eleScaledW );
  };

  // try the last one if there is no second last one
  if( !txr ){
    txr = txrQ[ txrQ.length - 1 ];
  }

  // if the last one doesn't exist, we need a first one
  if( !txr ){
    txr = addNewTxr();
  }

  // if there's no room in the current texture, we need a new one
  if( txr.width - txr.usedWidth < eleScaledW ){
    txr = addNewTxr();
  }

  var scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );
  var scalableFrom = function( otherCache ){
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;

  var higherCache; // the nearest cache with a higher level
  for( var l = lvl + 1; l <= maxLvl; l++ ){
    var c = caches[l];

    if( c ){ higherCache = c; break; }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function(){
    txr.context.drawImage(
      oneUpCache.texture.canvas,
      oneUpCache.x, 0,
      oneUpCache.width, oneUpCache.height,
      txr.usedWidth, 0,
      eleScaledW, eleScaledH
    );
  };

  if( scalableFrom(oneUpCache) ){
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();

  } else if( scalableFrom(higherCache) ){
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level

    if( highQualityReq ){
      for( var l = higherCache.level; l > lvl; l-- ){
        oneUpCache = self.getElement( ele, bb, pxRatio, l, getTxrReasons.downscale );
      }

      downscale();

    } else {
      self.queueElement( ele, bb, higherCache.level - 1 );

      return higherCache;
    }
  } else {

    var lowerCache; // the nearest cache with a lower level
    if( !deqing && !highQualityReq && !downscaleReq ){
      for( var l = lvl - 1; l >= minLvl; l-- ){
        var c = caches[l];

        if( c ){ lowerCache = c; break; }
      }
    }

    if( scalableFrom(lowerCache) ){
      // then use the lower quality cache for now and queue the better one for later

      self.queueElement( ele, bb, lvl );

      return lowerCache;
    }

    txr.context.translate( txr.usedWidth, 0 );
    txr.context.scale( scale, scale );

    r.drawElement( txr.context, ele, bb, scaledLabelShown );

    txr.context.scale( 1/scale, 1/scale );
    txr.context.translate( -txr.usedWidth, 0 );
  }

  eleCache = caches[lvl] = {
    ele: ele,
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };

  txr.usedWidth += Math.ceil( eleScaledW + eleTxrSpacing );

  txr.eleCaches.push( eleCache );

  self.checkTextureFullness( txr );

  return eleCache;
};

ETCp.invalidateElement = function( ele ){
  var self = this;
  var caches = ele._private.rscratch.imgCaches;

  if( caches ){
    for( var lvl = minLvl; lvl <= maxLvl; lvl++ ){
      var cache = caches[ lvl ];

      if( cache ){
        var txr = cache.texture;

        // remove space from the texture it belongs to
        txr.invalidatedWidth += cache.width;

        // remove refs with the element
        caches[ lvl ] = null;
        util.removeFromArray( txr.eleCaches, cache );

        // might have to remove the entire texture if it's not efficiently using its space
        self.checkTextureUtility( txr );
      }
    }
  }
};

ETCp.checkTextureUtility = function( txr ){
  // invalidate all entries in the cache if the cache size is small
  if( txr.invalidatedWidth >= minUtility * txr.width ){
    this.retireTexture( txr );
  }
};

ETCp.checkTextureFullness = function( txr ){
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things

  var self = this;
  var txrQ = self.getTextureQueue( txr.height );

  if( txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks ){
    util.removeFromArray( txrQ, txr );
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function( txr ){
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue( txrH );

  // retire the texture from the active / searchable queue:

  util.removeFromArray( txrQ, txr );

  txr.retired = true;

  // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for( var i = 0; i < eleCaches.length; i++ ){
    var eleCache = eleCaches[i];
    var ele = eleCache.ele;
    var lvl = eleCache.level;
    var imgCaches = ele._private.rscratch.imgCaches;

    if( imgCaches ){
      imgCaches[ lvl ] = null;
    }
  }

  util.clearArray( eleCaches );

  // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  rtxtrQ.push( txr );
};

ETCp.addTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var txr = {};

  txrQ.push( txr );

  txr.eleCaches = [];

  txr.height = txrH;
  txr.width = Math.max( defTxrWidth, minW );
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;

  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  txr.canvas.width = txr.width;
  txr.canvas.height = txr.height;

  txr.context = txr.canvas.getContext('2d');

  return txr;
};

ETCp.recycleTexture = function( txrH, minW ){
  var self = this;
  var txrQ = self.getTextureQueue( txrH );
  var rtxtrQ = self.getRetiredTextureQueue( txrH );

  for( var i = 0; i < rtxtrQ.length; i++ ){
    var txr = rtxtrQ[i];

    if( txr.width >= minW ){
      txr.retired = false;

      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;

      util.clearArray( txr.eleCaches );

      txr.context.clearRect( 0, 0, txr.width, txr.height );

      util.removeFromArray( rtxtrQ, txr );
      txrQ.push( txr );

      return txr;
    }
  }
};

ETCp.queueElement = function( ele, bb, lvl ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var id = ele.id();
  var existingReq = id2q[ id ];

  if( existingReq ){ // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max( existingReq.level, lvl );
    existingReq.reqs++;

    q.updateItem( existingReq );
  } else {
    var req = {
      ele: ele,
      bb: bb,
      position: math.copyPosition( ele.position() ),
      level: lvl,
      reqs: 1
    };

    if( ele.isEdge() ){
      req.positions = {
        source: math.copyPosition( ele.source().position() ),
        target: math.copyPosition( ele.target().position() )
      };
    }

    q.push( req );

    id2q[ id ] = req;
  }
};

ETCp.dequeue = function( pxRatio, extent ){
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var dequeued = [];

  for( var i = 0; i < maxDeqSize; i++ ){
    if( q.size() > 0 ){
      var req = q.pop();

      id2q[ req.ele.id() ] = null;

      dequeued.push( req );

      var ele = req.ele;
      var bb;

      if(
        ( ele.isEdge()
          && (
            !math.arePositionsSame( ele.source().position(), req.positions.source )
            || !math.arePositionsSame( ele.target().position(), req.positions.target )
          )
        )
        || ( !math.arePositionsSame( ele.position(), req.position ) )
      ){
        bb = ele.boundingBox();
      } else {
        bb = req.bb;
      }

      self.getElement( req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue );
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.onDequeue = function( fn ){ this.onDequeues.push( fn ); };
ETCp.offDequeue = function( fn ){ util.removeFromArray( this.onDequeues, fn ); };

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio, extent ){
    return self.dequeue( pxRatio, extent );
  },
  onDeqd: function( self, deqd ){
    for( var i = 0; i < self.onDequeues.length; i++ ){
      var fn = self.onDequeues[i];

      fn( deqd );
    }
  },
  shouldRedraw: function( self, deqd, pxRatio, extent ){
    for( var i = 0; i < deqd.length; i++ ){
      var bb = deqd[i].bb;

      if( math.boundingBoxesIntersect( bb, extent ) ){
        return true;
      }
    }

    return false;
  },
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

module.exports = ElementTextureCache;

},{"../../../heap":84,"../../../math":88,"../../../util":103,"./texture-cache-defs":80}],76:[function(require,module,exports){
'use strict';

var is = require( '../../../is' );

var CRp = {};

CRp.createBuffer = function( w, h ){
  var buffer = document.createElement( 'canvas' ); // eslint-disable-line no-undef
  buffer.width = w;
  buffer.height = h;

  return [ buffer, buffer.getContext( '2d' ) ];
};

CRp.bufferCanvasImage = function( options ){
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil( bb.w ) : ctrRect[2];
  var height = options.full ? Math.ceil( bb.h ) : ctrRect[3];
  var specdMaxDims = is.number( options.maxWidth ) || is.number( options.maxHeight );
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if( options.scale !== undefined ){
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if( specdMaxDims ){
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if( is.number( options.maxWidth ) ){
      maxScaleW = scale * options.maxWidth / width;
    }

    if( is.number( options.maxHeight ) ){
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min( maxScaleW, maxScaleH );

    width *= scale;
    height *= scale;
  }

  if( !specdMaxDims ){
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement( 'canvas' ); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext( '2d' );

  // Rasterize the layers, but only if container has nonzero size
  if( width > 0 && height > 0 ){

    buffCxt.clearRect( 0, 0, width, height );

    if( options.bg ){
      buffCxt.fillStyle = options.bg;
      buffCxt.rect( 0, 0, width, height );
      buffCxt.fill();
    }

    buffCxt.globalCompositeOperation = 'source-over';

    var zsortedEles = this.getCachedZSortedEles();

    if( options.full ){ // draw the full bounds of the graph
      buffCxt.translate( -bb.x1 * scale, -bb.y1 * scale );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    } else { // draw the current view
      var pan = cy.pan();

      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };

      scale *= cy.zoom();

      buffCxt.translate( translation.x, translation.y );
      buffCxt.scale( scale, scale );

      this.drawElements( buffCxt, zsortedEles );
    }
  }

  return buffCanvas;
};

function b64ToBlob( b64, mimeType ){
  var bytes = atob( b64 );
  var buff = new ArrayBuffer( bytes.length );
  var buffUint8 = new Uint8Array( buff );

  for( var i = 0; i < bytes.length; i++ ){
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob( [buff], { type: mimeType } );
}

function b64UriToB64( b64uri ){
  var i = b64uri.indexOf(',');

  return b64uri.substr( i + 1 );
};

function output( options, canvas, mimeType ){
  var b64Uri = canvas.toDataURL( mimeType, options.quality );

  switch( options.output ){
    case 'blob':
      return b64ToBlob( b64UriToB64( b64Uri ), mimeType );

    case 'base64':
      return b64UriToB64( b64Uri );

    case 'base64uri':
    default:
      return b64Uri;
  }
}

CRp.png = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/png' );
};

CRp.jpg = function( options ){
  return output( options, this.bufferCanvasImage( options ), 'image/jpeg' );
};

module.exports = CRp;

},{"../../../is":86}],77:[function(require,module,exports){
/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

'use strict';

var util = require( '../../../util' );
var is = require( '../../../is' );
var ElementTextureCache = require('./ele-texture-cache');
var LayeredTextureCache = require('./layered-texture-cache');

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer( options ){
  var r = this;

  r.data = {
    canvases: new Array( CRp.CANVAS_LAYERS ),
    contexts: new Array( CRp.CANVAS_LAYERS ),
    canvasNeedsRedraw: new Array( CRp.CANVAS_LAYERS ),

    bufferCanvases: new Array( CRp.BUFFER_COUNT ),
    bufferContexts: new Array( CRp.CANVAS_LAYERS ),
  };

  r.data.canvasContainer = document.createElement( 'div' ); // eslint-disable-line no-undef
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute( 'style', '-webkit-tap-highlight-color: rgba(0,0,0,0);' );
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild( r.data.canvasContainer );
  container.setAttribute( 'style', ( container.getAttribute( 'style' ) || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);' );

  for( var i = 0; i < CRp.CANVAS_LAYERS; i++ ){
    var canvas = r.data.canvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.contexts[ i ] = canvas.getContext( '2d' );
    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
    canvas.style.position = 'absolute';
    canvas.setAttribute( 'data-id', 'layer' + i );
    canvas.style.zIndex = String( CRp.CANVAS_LAYERS - i );
    r.data.canvasContainer.appendChild( canvas );

    r.data.canvasNeedsRedraw[ i ] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[ CRp.NODE ].setAttribute( 'data-id', 'layer' + CRp.NODE + '-node' );
  r.data.canvases[ CRp.SELECT_BOX ].setAttribute( 'data-id', 'layer' + CRp.SELECT_BOX + '-selectbox' );
  r.data.canvases[ CRp.DRAG ].setAttribute( 'data-id', 'layer' + CRp.DRAG + '-drag' );

  for( var i = 0; i < CRp.BUFFER_COUNT; i++ ){
    r.data.bufferCanvases[ i ] = document.createElement( 'canvas' );  // eslint-disable-line no-undef
    r.data.bufferContexts[ i ] = r.data.bufferCanvases[ i ].getContext( '2d' );
    r.data.bufferCanvases[ i ].style.position = 'absolute';
    r.data.bufferCanvases[ i ].setAttribute( 'data-id', 'buffer' + i );
    r.data.bufferCanvases[ i ].style.zIndex = String( -i - 1 );
    r.data.bufferCanvases[ i ].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;

  r.data.eleTxrCache = new ElementTextureCache( r );
  r.data.lyrTxrCache = new LayeredTextureCache( r, r.data.eleTxrCache );

  r.onUpdateEleCalcs(function invalidateTextureCaches( willDraw, eles ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var rs = ele._private.rstyle;
      var de = rs.dirtyEvents;

      if( ele.isNode() && de && de.length === 1 && de['position'] ){
        // then keep cached ele texture
      } else {
        r.data.eleTxrCache.invalidateElement( ele );
      }
    }

    if( eles.length > 0 ){
      r.data.lyrTxrCache.invalidateElements( eles );
    }
  });
}

CRp.redrawHint = function( group, bool ){
  var r = this;

  switch( group ){
    case 'eles':
      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function( on ){
  if( on === undefined ){
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function(){
  return pathsImpld && this.pathsEnabled;
};

[
  require( './arrow-shapes' ),
  require( './drawing-elements' ),
  require( './drawing-edges' ),
  require( './drawing-images' ),
  require( './drawing-label-text' ),
  require( './drawing-nodes' ),
  require( './drawing-redraw' ),
  require( './drawing-shapes' ),
  require( './export-image' ),
  require( './node-shapes' )
].forEach( function( props ){
  util.extend( CRp, props );
} );

module.exports = CR;

},{"../../../is":86,"../../../util":103,"./arrow-shapes":67,"./drawing-edges":68,"./drawing-elements":69,"./drawing-images":70,"./drawing-label-text":71,"./drawing-nodes":72,"./drawing-redraw":73,"./drawing-shapes":74,"./ele-texture-cache":75,"./export-image":76,"./layered-texture-cache":78,"./node-shapes":79}],78:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );
var math = require( '../../../math' );
var Heap = require( '../../../heap' );
var is = require( '../../../is' );
var defs = require( './texture-cache-defs' );

var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function( renderer, eleTxrCache ){
  var self = this;

  var r = self.renderer = renderer;

  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;

  self.lastInvalidationTime = util.performanceNow() - 2*invalidThreshold;

  self.skipping = false;

  r.beforeRender(function( willDraw, now ){
    if( now - self.lastInvalidationTime <= invalidThreshold ){
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  });

  var qSort = function(a, b){
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap( qSort );

  self.eleTxrCache = eleTxrCache;

  self.setupEleCacheInvalidation();

  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;

var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;

LTCp.makeLayer = function( bb, lvl ){
  var scale = Math.pow( 2, lvl );

  var w = Math.ceil( bb.w * scale );
  var h = Math.ceil( bb.h * scale );

  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

  canvas.width = w;
  canvas.height = h;

  var layer = {
    id: (layerIdPool = ++layerIdPool % MAX_INT ),
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  };

  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;

  // do the transform on creation to save cycles (it's the same for all eles)
  cxt.scale( scale, scale );
  cxt.translate( dx, dy );

  return layer;
};

LTCp.getLayers = function( eles, pxRatio, lvl ){
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;

  self.firstGet = false;

  // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if( lvl == null ){
    lvl = Math.ceil( math.log2( zoom * pxRatio ) );

    if( lvl < minLvl ){
      lvl = minLvl;
    } else if( zoom >= maxZoom || lvl > maxLvl ){
      return null;
    }
  }

  self.validateLayersElesOrdering( lvl, eles );

  var layersByLvl = self.layersByLevel;
  var scale = Math.pow( 2, lvl );
  var layers = layersByLvl[ lvl ] = layersByLvl[ lvl ] || [];
  var bb;

  var lvlComplete = self.levelIsComplete( lvl, eles );
  var tmpLayers;

  var checkTempLevels = function(){
    var canUseAsTmpLvl = function( l ){
      self.validateLayersElesOrdering( l, eles );

      if( self.levelIsComplete( l, eles ) ){
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function( dir ){
      if( tmpLayers ){ return; }

      for( var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir ){
        if( canUseAsTmpLvl(l) ){ break; }
      }
    };

    checkLvls( +1 );
    checkLvls( -1 );

    // remove the invalid layers; they will be replaced as needed later in this function
    for( var i = layers.length - 1; i >= 0; i-- ){
      var layer = layers[i];

      if( layer.invalid ){
        util.removeFromArray( layers, layer );
      }
    }
  };

  if( !lvlComplete ){
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon

    checkTempLevels();

  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function(){
    if( !bb ){
      bb = math.makeBoundingBox();

      for( var i = 0; i < eles.length; i++ ){
        math.updateBoundingBox( bb, eles[i].boundingBox() );
      }
    }

    return bb;
  };

  var makeLayer = function( opts ){
    opts = opts || {};

    var after = opts.after;

    getBb();

    var area = ( bb.w * scale ) * ( bb.h * scale );

    if( area > maxLayerArea ){
      return null;
    }

    var layer = self.makeLayer( bb, lvl );

    if( after != null ){
      var index = layers.indexOf( after ) + 1;

      layers.splice( index, 0, layer );
    } else if( opts.insert === undefined || opts.insert ){
      // no after specified => first layer made so put at start
      layers.unshift( layer );
    }

    // if( tmpLayers ){
      //self.queueLayer( layer );
    // }

    return layer;
  };

  if( self.skipping && !firstGet ){
    // log('skip layers');
    return null;
  }

  // log('do layers');

  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = alwaysQueue && !firstGet;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    // log('look at ele', ele.id());

    var existingLayer = caches[ lvl ];

    if( existingLayer ){
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if(
      !layer
      || layer.eles.length >= maxElesPerLayer
      || !math.boundingBoxInBoundingBox( layer.bb, ele.boundingBox() )
    ){
      // log('make new layer for ele %s', ele.id());

      layer = makeLayer({ insert: true, after: layer });

      // if now layer can be built then we can't use layers at this level
      if( !layer ){ return null; }

      // log('new layer with id %s', layer.id);
    }

    if( tmpLayers || allowLazyQueueing ){
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer( layer, ele );
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer( layer, ele, lvl, pxRatio );
    }

    layer.eles.push( ele );

    caches[ lvl ] = layer;
  }

  // log('--');

  if( tmpLayers ){ // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if( allowLazyQueueing ){
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
};

// a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function( lvl, pxRatio ){
  return lvl;
};

function imgSmoothing( context, bool ){
  if( context.imageSmoothingEnabled != null ){
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
}

LTCp.drawEleInLayer = function( layer, ele, lvl, pxRatio ){
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if( bb.w === 0 || bb.h === 0 ){ return; }

  var eleCache = self.eleTxrCache;
  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

  lvl = self.getEleLevelForLayerLevel( lvl, pxRatio );

  var cache = useEleTxrCaching ? eleCache.getElement( ele, bb, null, lvl, reason ) : null;

  if( cache ){
    if( disableEleImgSmoothing ){ imgSmoothing( context, false ); }

    context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );

    if( disableEleImgSmoothing ){ imgSmoothing( context, true ); }
  } else { // if the element is not cacheable, then draw directly
    r.drawElement( context, ele );
  }
};

LTCp.levelIsComplete = function( lvl, eles ){
  var self = this;
  var layers = self.layersByLevel[ lvl ];

  if( !layers || layers.length === 0 ){ return false; }

  var numElesInLayers = 0;

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];

    // if there are any eles needed to be drawn yet, the level is not complete
    if( layer.reqs > 0 ){ return false; }

    // if the layer is invalid, the level is not complete
    if( layer.invalid ){ return false; }

    numElesInLayers += layer.eles.length;
  }

  // we should have exactly the number of eles passed in to be complete
  if( numElesInLayers !== eles.length ){ return false; }

  return true;
};

LTCp.validateLayersElesOrdering = function( lvl, eles ){
  var layers = this.layersByLevel[ lvl ];

  if( !layers ){ return; }

  // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)

  for( var i = 0; i < layers.length; i++ ){
    var layer = layers[i];
    var offset = -1;

    // find the offset
    for( var j = 0; j < eles.length; j++ ){
      if( layer.eles[0] === eles[j] ){
        offset = j;
        break;
      }
    }

    if( offset < 0 ){
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer( layer );
      continue;
    }

    // the eles in the layer must be in the same continuous order, else the layer is invalid

    var o = offset;

    for( var j = 0; j < layer.eles.length; j++ ){
      if( layer.eles[j] !== eles[o+j] ){
        // log('invalidate based on ordering', layer.id);

        this.invalidateLayer( layer );
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function( eles, update ){
  var self = this;
  var isEles = is.element( eles[0] );

  // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way
  for( var i = 0; i < eles.length; i++ ){
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for( var l = minLvl; l <= maxLvl; l++ ){
      var layer = caches[l];

      if( !layer ){ continue; }

      // if update is a request from the ele cache, then it affects only
      // the matching level
      if( req && self.getEleLevelForLayerLevel( layer.level ) !== req.level ){
        continue;
      }

      update( layer, ele, req );
    }
  }
};

LTCp.haveLayers = function(){
  var self = this;
  var haveLayers = false;

  for( var l = minLvl; l <= maxLvl; l++ ){
    var layers = self.layersByLevel[l];

    if( layers && layers.length > 0 ){
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function( eles ){
  var self = this;

  self.lastInvalidationTime = util.performanceNow();

  // log('update invalidate layer time from eles');

  if( eles.length === 0 || !self.haveLayers() ){ return; }

  self.updateElementsInLayers( eles, function invalAssocLayers( layer, ele, req ){
    self.invalidateLayer( layer );
  } );
};

LTCp.invalidateLayer = function( layer ){
  // log('update invalidate layer time');

  this.lastInvalidationTime = util.performanceNow();

  if( layer.invalid ){ return; } // save cycles

  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[ lvl ];

   // log('invalidate layer', layer.id );

  util.removeFromArray( layers, layer );
  // layer.eles = [];

  layer.elesQueue = [];

  layer.invalid = true;

  if( layer.replacement ){
    layer.replacement.invalid = true;
  }

  for( var i = 0; i < eles.length; i++ ){
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if( caches ){
      caches[ lvl ] = null;
    }
  }
};

LTCp.refineElementTextures = function( eles ){
  var self = this;

  // log('refine', eles.length);

  self.updateElementsInLayers( eles, function refineEachEle( layer, ele, req ){
    var rLyr = layer.replacement;

    if( !rLyr ){
      rLyr = layer.replacement = self.makeLayer( layer.bb, layer.level );
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;

       // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if( !rLyr.reqs ){
      for( var i = 0; i < rLyr.eles.length; i++ ){
        self.queueLayer( rLyr, rLyr.eles[i] );
      }

       // log('queue replacement layer refinement', rLyr.id);
    }
  } );
};

LTCp.setupEleCacheInvalidation = function(){
  var self = this;
  var eleDeqs = [];

  if( !useEleTxrCaching ){ return; }

  var updatedElesInLayers = util.debounce( function(){
    self.refineElementTextures( eleDeqs );

    eleDeqs = [];
  }, refineEleDebounceTime );

  self.eleTxrCache.onDequeue(function( reqs ){
    for( var i = 0; i < reqs.length; i++ ){
      eleDeqs.push( reqs[i] );
    }

    updatedElesInLayers();
  });
};

LTCp.queueLayer = function( layer, ele ){
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};

  // if a layer is going to be replaced, queuing is a waste of time
  if( layer.replacement ){ return; }

  if( ele ){
    if( hasId[ ele.id() ] ){
      return;
    }

    elesQ.push( ele );
    hasId[ ele.id() ] = true;
  }

  if( layer.reqs ){
    layer.reqs++;

    q.updateItem( layer );
  } else {
    layer.reqs = 1;

    q.push( layer );
  }
};

LTCp.dequeue = function( pxRatio ){
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while( eleDeqs < maxDeqSize ){
    if( q.size() === 0 ){ break; }

    var layer = q.peek();

    // if a layer has been or will be replaced, then don't waste time with it
    if( layer.replacement ){
       // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    }

    // if this is a replacement layer that has been superceded, then forget it
    if( layer.replaces && layer !== layer.replaces.replacement ){
       // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if( layer.invalid ){
       // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if( ele ){
       // log('dequeue layer %s', layer.id);

      self.drawEleInLayer( layer, ele, layer.level, pxRatio );

      eleDeqs++;
    }

    if( deqd.length === 0 ){
      // we need only one entry in deqd to queue redrawing etc
      deqd.push( true );
    }

    // if the layer has all its eles done, then remove from the queue
    if( layer.elesQueue.length === 0 ){
      q.pop();

      layer.reqs = 0;

       // log('dequeue of layer %s complete', layer.id);

      // when a replacement layer is dequeued, it replaces the old layer in the level
      if( layer.replaces ){
        self.applyLayerReplacement( layer );
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function( layer ){
  var self = this;
  var layersInLevel = self.layersByLevel[ layer.level ];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf( replaced );

  // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)
  if( index < 0 || replaced.invalid ){
     // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[ index ] = layer; // replace level ref

  // replace refs in eles
  for( var i = 0; i < layer.eles.length; i++ ){
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if( cache ){
      cache[ layer.level ] = layer;
    }
  }

   // log('apply replacement layer %s over %s', layer.id, replaced.id);

  self.requestRedraw();
};

LTCp.requestRedraw = util.debounce( function(){
  var r = this.renderer;

  r.redrawHint( 'eles', true );
  r.redrawHint( 'drag', true );
  r.redraw();
}, 100 );

LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function( self, pxRatio ){
    return self.dequeue( pxRatio );
  },
  onDeqd: util.noop,
  shouldRedraw: util.trueify,
  priority: function( self ){
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

module.exports = LayeredTextureCache;

},{"../../../heap":84,"../../../is":86,"../../../math":88,"../../../util":103,"./texture-cache-defs":80}],79:[function(require,module,exports){
'use strict';

var CRp = {};

CRp.nodeShapeImpl = function( name, context, centerX, centerY, width, height, points ){
  switch( name ){
    case 'ellipse':
      return this.drawEllipsePath( context, centerX, centerY, width, height );
    case 'polygon':
      return this.drawPolygonPath( context, centerX, centerY, width, height, points );
    case 'roundrectangle':
      return this.drawRoundRectanglePath( context, centerX, centerY, width, height );
  }
};

module.exports = CRp;

},{}],80:[function(require,module,exports){
'use strict';

var util = require( '../../../util' );

var fullFpsTime = 1000/60; // assume 60 frames per second

module.exports = {
  setupDequeueing: function( opts ){
    return function setupDequeueingImpl(){
      var self = this;
      var r = this.renderer;

      if( self.dequeueingSetup ){
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util.debounce( function(){
        r.redrawHint( 'eles', true );
        r.redrawHint( 'drag', true );

        r.redraw();
      }, opts.deqRedrawThreshold );

      var dequeue = function( willDraw, frameStartTime ){
        var startTime = util.performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio();

        while( true ){
          var now = util.performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if( renderTime < fullFpsTime ){
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time

            var timeAvailable = fullFpsTime - ( willDraw ? avgRenderTime : 0 );

            if( frameDuration >= opts.deqFastCost * timeAvailable ){
              break;
            }
          } else {
            if( willDraw ){
              if(
                   duration >= opts.deqCost * renderTime
                || duration >= opts.deqAvgCost * avgRenderTime
              ){
                break;
              }
            } else if( frameDuration >= opts.deqNoDrawCost * fullFpsTime ){
              break;
            }
          }

          var thisDeqd = opts.deq( self, pixelRatio, extent );

          if( thisDeqd.length > 0 ){
            for( var i = 0; i < thisDeqd.length; i++ ){
              deqd.push( thisDeqd[i] );
            }
          } else {
            break;
          }
        }

        // callbacks on dequeue
        if( deqd.length > 0 ){
          opts.onDeqd( self, deqd );

          if( !willDraw && opts.shouldRedraw( self, deqd, pixelRatio, extent ) ){
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || util.noop;

      r.beforeRender( dequeue, priority( self ) );
    };
  }
};

},{"../../../util":103}],81:[function(require,module,exports){
'use strict';

module.exports = [
  { name: 'null', impl: require( './null' ) },
  { name: 'base', impl: require( './base' ) },
  { name: 'canvas', impl: require( './canvas' ) }
];

},{"./base":63,"./canvas":77,"./null":82}],82:[function(require,module,exports){
'use strict';

function NullRenderer( options ){
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function(){};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function(){ this.notifications++; },
  init: noop
};

module.exports = NullRenderer;

},{}],83:[function(require,module,exports){
/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */

'use strict';

var is = require('./is');
var util = require('./util');
var Thread = require('./thread');
var Promise = require('./promise');
var define = require('./define');

var Fabric = function( N ){
  if( !(this instanceof Fabric) ){
    return new Fabric( N );
  }

  this._private = {
    pass: []
  };

  var defN = 4;

  if( is.number(N) ){
    // then use the specified number of threads
  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
    N = navigator.hardwareConcurrency;
  } else {
    try{
      N = require('os').cpus().length;
    } catch( err ){
      N = defN;
    }
  } // TODO could use an estimation here but would the additional expense be worth it?

  for( var i = 0; i < N; i++ ){
    this[i] = new Thread();
  }

  this.length = N;
};

var fabfn = Fabric.prototype; // short alias

util.extend(fabfn, {

  instanceString: function(){ return 'fabric'; },

  // require fn in all threads
  require: function( fn, as ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.require( fn, as );
    }

    return this;
  },

  // get a random thread
  random: function(){
    var i = Math.round( (this.length - 1) * Math.random() );
    var thread = this[i];

    return thread;
  },

  // run on random thread
  run: function( fn ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass ).run( fn );
  },

  // sends a random thread a message
  message: function( m ){
    return this.random().message( m );
  },

  // send all threads a message
  broadcast: function( m ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.message( m );
    }

    return this; // chaining
  },

  // stop all threads
  stop: function(){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.stop();
    }

    return this; // chaining
  },

  // pass data to be used with .spread() etc.
  pass: function( data ){
    var pass = this._private.pass;

    if( is.array(data) ){
      pass.push( data );
    } else {
      throw 'Only arrays may be used with fabric.pass()';
    }

    return this; // chaining
  },

  spreadSize: function(){
    var subsize =  Math.ceil( this._private.pass[0].length / this.length );

    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

    return subsize;
  },

  // split the data into slices to spread the data equally among threads
  spread: function( fn ){
    var self = this;
    var _p = self._private;
    var subsize = self.spreadSize(); // number of pass eles to handle in each thread
    var pass = _p.pass.shift().concat([]); // keep a copy
    var runPs = [];

    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];
      var slice = pass.splice( 0, subsize );

      var runP = thread.pass( slice ).run( fn );

      runPs.push( runP );

      var doneEarly = pass.length === 0;
      if( doneEarly ){ break; }
    }

    return Promise.all( runPs ).then(function( thens ){
      var postpass = [];
      var p = 0;

      // fill postpass with the total result joined from all threads
      for( var i = 0; i < thens.length; i++ ){
        var then = thens[i]; // array result from thread i

        for( var j = 0; j < then.length; j++ ){
          var t = then[j]; // array element

          postpass[ p++ ] = t;
        }
      }

      return postpass;
    });
  },

  // parallel version of array.map()
  map: function( fn ){
    var self = this;

    self.require( fn, '_$_$_fabmap' );

    return self.spread(function( split ){
      var mapped = [];
      var origResolve = resolve; // jshint ignore:line

      resolve = function( val ){ // jshint ignore:line
        mapped.push( val );
      };

      for( var i = 0; i < split.length; i++ ){
        var oldLen = mapped.length;
        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line
        var nothingInsdByResolve = oldLen === mapped.length;

        if( nothingInsdByResolve ){
          mapped.push( ret );
        }
      }

      resolve = origResolve; // jshint ignore:line

      return mapped;
    });

  },

  // parallel version of array.filter()
  filter: function( fn ){
    var _p = this._private;
    var pass = _p.pass[0];

    return this.map( fn ).then(function( include ){
      var ret = [];

      for( var i = 0; i < pass.length; i++ ){
        var datum = pass[i];
        var incDatum = include[i];

        if( incDatum ){
          ret.push( datum );
        }
      }

      return ret;
    });
  },

  // sorts the passed array using a divide and conquer strategy
  sort: function( cmp ){
    var self = this;
    var P = this._private.pass[0].length;
    var subsize = this.spreadSize();

    cmp = cmp || function( a, b ){ // default comparison function
      if( a < b ){
        return -1;
      } else if( a > b ){
        return 1;
      }

      return 0;
    };

    self.require( cmp, '_$_$_cmp' );

    return self.spread(function( split ){ // sort each split normally
      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line
      resolve( sortedSplit ); // jshint ignore:line

    }).then(function( joined ){
      // do all the merging in the main thread to minimise data transfer

      // TODO could do merging in separate threads but would incur add'l cost of data transfer
      // for each level of the merge

      var merge = function( i, j, max ){
        // don't overflow array
        j = Math.min( j, P );
        max = Math.min( max, P );

        // left and right sides of merge
        var l = i;
        var r = j;

        var sorted = [];

        for( var k = l; k < max; k++ ){

          var eleI = joined[i];
          var eleJ = joined[j];

          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
            sorted.push( eleI );
            i++;
          } else {
            sorted.push( eleJ );
            j++;
          }

        }

        // in the array proper, put the sorted values
        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
          var index = l + k;

          joined[ index ] = sorted[k];
        }
      };

      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

        for( var i = 0; i < P; i += 2*splitL ){
          merge( i, i + splitL, i + 2*splitL );
        }

      }

      return joined;
    });
  }


});

var defineRandomPasser = function( opts ){
  opts = opts || {};

  return function( fn, arg1 ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
  };
};

util.extend(fabfn, {
  randomMap: defineRandomPasser({ threadFn: 'map' }),

  reduce: defineRandomPasser({ threadFn: 'reduce' }),

  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
});

// aliases
var fn = fabfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(fabfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( fabfn );

module.exports = Fabric;

},{"./define":47,"./is":86,"./promise":89,"./thread":101,"./util":103,"os":113}],84:[function(require,module,exports){
/*!
Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;

PSF LICENSE AGREEMENT FOR PYTHON 2.7.2

1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
*/

'use strict';
// Generated by CoffeeScript 1.8.0

var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

floor = Math.floor, min = Math.min;


/*
Default comparison function to be used
 */

defaultCmp = function( x, y ){
  if( x < y ){
    return -1;
  }
  if( x > y ){
    return 1;
  }
  return 0;
};


/*
Insert item x in list a, and keep it sorted assuming a is sorted.

If x is already in a, insert it to the right of the rightmost x.

Optional args lo (default 0) and hi (default a.length) bound the slice
of a to be searched.
 */

insort = function( a, x, lo, hi, cmp ){
  var mid;
  if( lo == null ){
    lo = 0;
  }
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( lo < 0 ){
    throw new Error( 'lo must be non-negative' );
  }
  if( hi == null ){
    hi = a.length;
  }
  while( lo < hi ){
    mid = floor( (lo + hi) / 2 );
    if( cmp( x, a[ mid ] ) < 0 ){
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return ([].splice.apply( a, [ lo, lo - lo ].concat( x ) ), x);
};


/*
Push item onto heap, maintaining the heap invariant.
 */

heappush = function( array, item, cmp ){
  if( cmp == null ){
    cmp = defaultCmp;
  }
  array.push( item );
  return _siftdown( array, 0, array.length - 1, cmp );
};


/*
Pop the smallest item off the heap, maintaining the heap invariant.
 */

heappop = function( array, cmp ){
  var lastelt, returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if( array.length ){
    returnitem = array[0];
    array[0] = lastelt;
    _siftup( array, 0, cmp );
  } else {
    returnitem = lastelt;
  }
  return returnitem;
};


/*
Pop and return the current smallest value, and add the new item.

This is more efficient than heappop() followed by heappush(), and can be
more appropriate when using a fixed size heap. Note that the value
returned may be larger than item! That constrains reasonable use of
this routine unless written as part of a conditional replacement:
    if item > array[0]
      item = heapreplace(array, item)
 */

heapreplace = function( array, item, cmp ){
  var returnitem;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup( array, 0, cmp );
  return returnitem;
};


/*
Fast version of a heappush followed by a heappop.
 */

heappushpop = function( array, item, cmp ){
  var _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( array.length && cmp( array[0], item ) < 0 ){
    _ref = [ array[0], item ], item = _ref[0], array[0] = _ref[1];
    _siftup( array, 0, cmp );
  }
  return item;
};


/*
Transform list into a heap, in-place, in O(array.length) time.
 */

heapify = function( array, cmp ){
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  _ref1 = (function(){
    _results1 = [];
    for( var _j = 0, _ref = floor( array.length / 2 ); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j-- ){ _results1.push( _j ); }
    return _results1;
  }).apply( this ).reverse();
  _results = [];
  for( _i = 0, _len = _ref1.length; _i < _len; _i++ ){
    i = _ref1[ _i ];
    _results.push( _siftup( array, i, cmp ) );
  }
  return _results;
};


/*
Update the position of the given item in the heap.
This function should be called every time the item is being modified.
 */

updateItem = function( array, item, cmp ){
  var pos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  pos = array.indexOf( item );
  if( pos === -1 ){
    return;
  }
  _siftdown( array, 0, pos, cmp );
  return _siftup( array, pos, cmp );
};


/*
Find the n largest elements in a dataset.
 */

nlargest = function( array, n, cmp ){
  var elem, result, _i, _len, _ref;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  result = array.slice( 0, n );
  if( !result.length ){
    return result;
  }
  heapify( result, cmp );
  _ref = array.slice( n );
  for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
    elem = _ref[ _i ];
    heappushpop( result, elem, cmp );
  }
  return result.sort( cmp ).reverse();
};


/*
Find the n smallest elements in a dataset.
 */

nsmallest = function( array, n, cmp ){
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  if( n * 10 <= array.length ){
    result = array.slice( 0, n ).sort( cmp );
    if( !result.length ){
      return result;
    }
    los = result[ result.length - 1];
    _ref = array.slice( n );
    for( _i = 0, _len = _ref.length; _i < _len; _i++ ){
      elem = _ref[ _i ];
      if( cmp( elem, los ) < 0 ){
        insort( result, elem, 0, null, cmp );
        result.pop();
        los = result[ result.length - 1];
      }
    }
    return result;
  }
  heapify( array, cmp );
  _results = [];
  for( i = _j = 0, _ref1 = min( n, array.length ); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j ){
    _results.push( heappop( array, cmp ) );
  }
  return _results;
};

_siftdown = function( array, startpos, pos, cmp ){
  var newitem, parent, parentpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  newitem = array[ pos ];
  while( pos > startpos ){
    parentpos = (pos - 1) >> 1;
    parent = array[ parentpos ];
    if( cmp( newitem, parent ) < 0 ){
      array[ pos ] = parent;
      pos = parentpos;
      continue;
    }
    break;
  }
  return array[ pos ] = newitem;
};

_siftup = function( array, pos, cmp ){
  var childpos, endpos, newitem, rightpos, startpos;
  if( cmp == null ){
    cmp = defaultCmp;
  }
  endpos = array.length;
  startpos = pos;
  newitem = array[ pos ];
  childpos = 2 * pos + 1;
  while( childpos < endpos ){
    rightpos = childpos + 1;
    if( rightpos < endpos && !(cmp( array[ childpos ], array[ rightpos ] ) < 0) ){
      childpos = rightpos;
    }
    array[ pos ] = array[ childpos ];
    pos = childpos;
    childpos = 2 * pos + 1;
  }
  array[ pos ] = newitem;
  return _siftdown( array, startpos, pos, cmp );
};

Heap = (function(){
  Heap.push = heappush;

  Heap.pop = heappop;

  Heap.replace = heapreplace;

  Heap.pushpop = heappushpop;

  Heap.heapify = heapify;

  Heap.updateItem = updateItem;

  Heap.nlargest = nlargest;

  Heap.nsmallest = nsmallest;

  function Heap( cmp ){
    this.cmp = cmp != null ? cmp : defaultCmp;
    this.nodes = [];
  }

  Heap.prototype.push = function( x ){
    return heappush( this.nodes, x, this.cmp );
  };

  Heap.prototype.pop = function(){
    return heappop( this.nodes, this.cmp );
  };

  Heap.prototype.peek = function(){
    return this.nodes[0];
  };

  Heap.prototype.contains = function( x ){
    return this.nodes.indexOf( x ) !== -1;
  };

  Heap.prototype.replace = function( x ){
    return heapreplace( this.nodes, x, this.cmp );
  };

  Heap.prototype.pushpop = function( x ){
    return heappushpop( this.nodes, x, this.cmp );
  };

  Heap.prototype.heapify = function(){
    return heapify( this.nodes, this.cmp );
  };

  Heap.prototype.updateItem = function( x ){
    return updateItem( this.nodes, x, this.cmp );
  };

  Heap.prototype.clear = function(){
    return this.nodes = [];
  };

  Heap.prototype.empty = function(){
    return this.nodes.length === 0;
  };

  Heap.prototype.size = function(){
    return this.nodes.length;
  };

  Heap.prototype.clone = function(){
    var heap;
    heap = new Heap();
    heap.nodes = this.nodes.slice( 0 );
    return heap;
  };

  Heap.prototype.toArray = function(){
    return this.nodes.slice( 0 );
  };

  Heap.prototype.insert = Heap.prototype.push;

  Heap.prototype.top = Heap.prototype.peek;

  Heap.prototype.front = Heap.prototype.peek;

  Heap.prototype.has = Heap.prototype.contains;

  Heap.prototype.copy = Heap.prototype.clone;

  return Heap;

})();

module.exports = Heap;

},{}],85:[function(require,module,exports){
'use strict';

require('./-preamble');

var window = require( './window' );
var is = require( './is' );
var Core = require( './core' );
var extension = require( './extension' );
var registerJquery = require( './jquery-plugin' );
var Stylesheet = require( './stylesheet' );
var Thread = require( './thread' );
var Fabric = require( './fabric' );

var cytoscape = function( options ){ // jshint ignore:line
  // if no options specified, use default
  if( options === undefined ){
    options = {};
  }

  // create instance
  if( is.plainObject( options ) ){
    return new Core( options );
  }

  // allow for registration of extensions
  else if( is.string( options ) ){
    return extension.apply( extension, arguments );
  }
};

// replaced by build system
cytoscape.version = require('./version');

// try to register w/ jquery
if( window && window.jQuery ){
  registerJquery( window.jQuery, cytoscape );
}

// expose register api
cytoscape.registerJquery = function( jQuery ){
  registerJquery( jQuery, cytoscape );
};

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
cytoscape.thread = cytoscape.Thread = Thread;
cytoscape.fabric = cytoscape.Fabric = Fabric;

module.exports = cytoscape;

},{"./-preamble":4,"./core":40,"./extension":49,"./fabric":83,"./is":86,"./jquery-plugin":87,"./stylesheet":100,"./thread":101,"./version":109,"./window":110}],86:[function(require,module,exports){
'use strict';

/*global HTMLElement DocumentTouch */

var window = require( './window' );
var navigator = window ? window.navigator : null;
var document = window ? window.document : null;

var typeofstr = typeof '';
var typeofobj = typeof {};
var typeoffn = typeof function(){};
var typeofhtmlele = typeof HTMLElement;

var instanceStr = function( obj ){
  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
};

var is = {
  defined: function( obj ){
    return obj != null; // not undefined or null
  },

  string: function( obj ){
    return obj != null && typeof obj == typeofstr;
  },

  fn: function( obj ){
    return obj != null && typeof obj === typeoffn;
  },

  array: function( obj ){
    return Array.isArray ? Array.isArray( obj ) : obj != null && obj instanceof Array;
  },

  plainObject: function( obj ){
    return obj != null && typeof obj === typeofobj && !is.array( obj ) && obj.constructor === Object;
  },

  object: function( obj ){
    return obj != null && typeof obj === typeofobj;
  },

  number: function( obj ){
    return obj != null && typeof obj === typeof 1 && !isNaN( obj );
  },

  integer: function( obj ){
    return is.number( obj ) && Math.floor( obj ) === obj;
  },

  bool: function( obj ){
    return obj != null && typeof obj === typeof true;
  },

  htmlElement: function( obj ){
    if( 'undefined' === typeofhtmlele ){
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function( obj ){
    return is.element( obj ) || is.collection( obj );
  },

  element: function( obj ){
    return instanceStr( obj ) === 'collection' && obj._private.single;
  },

  collection: function( obj ){
    return instanceStr( obj ) === 'collection' && !obj._private.single;
  },

  core: function( obj ){
    return instanceStr( obj ) === 'core';
  },

  style: function( obj ){
    return instanceStr( obj ) === 'style';
  },

  stylesheet: function( obj ){
    return instanceStr( obj ) === 'stylesheet';
  },

  event: function( obj ){
    return instanceStr( obj ) === 'event';
  },

  thread: function( obj ){
    return instanceStr( obj ) === 'thread';
  },

  fabric: function( obj ){
    return instanceStr( obj ) === 'fabric';
  },

  emptyString: function( obj ){
    if( obj === undefined || obj === null ){ // null is empty
      return true;
    } else if( obj === '' || obj.match( /^\s+$/ ) ){
      return true; // empty string is empty
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function( obj ){
    if( obj && is.string( obj ) && obj !== '' && !obj.match( /^\s+$/ ) ){
      return true;
    }

    return false;
  },

  domElement: function( obj ){
    if( typeof HTMLElement === 'undefined' ){
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function( obj ){
    return is.plainObject( obj ) &&
      is.number( obj.x1 ) && is.number( obj.x2 ) &&
      is.number( obj.y1 ) && is.number( obj.y2 )
    ;
  },

  promise: function( obj ){
    return is.object( obj ) && is.fn( obj.then );
  },

  touch: function(){
    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
  },

  gecko: function(){
    return window && ( typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style) );
  },

  webkit: function(){
    return window && ( typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style) );
  },

  chromium: function(){
    return window && ( typeof chrome !== 'undefined' );
  },

  khtml: function(){
    return navigator && navigator.vendor.match( /kde/i ); // probably a better way to detect this...
  },

  khtmlEtc: function(){
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function(){
    return navigator && navigator.userAgent.match( /msie|trident|edge/i ); // probably a better way to detect this...
  },

  windows: function(){
    return navigator && navigator.appVersion.match( /Win/i );
  },

  mac: function(){
    return navigator && navigator.appVersion.match( /Mac/i );
  },

  linux: function(){
    return navigator && navigator.appVersion.match( /Linux/i );
  },

  unix: function(){
    return navigator && navigator.appVersion.match( /X11/i );
  }
};

module.exports = is;

},{"./window":110}],87:[function(require,module,exports){
'use strict';

var is = require( './is' );

var cyReg = function( $ele ){
  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

  return d;
};

var registerJquery = function( $, cytoscape ){
  if( !$ ){ return; } // no jquery => don't need this

  if( $.fn.cytoscape ){ return; } // already registered

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function( opts ){
    var $this = $( this );

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }

    // bind to ready
    else if( is.fn( opts ) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;

      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger( 'ready', [], ready );

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      }

    }

    // proxy to create instance
    else if( is.plainObject( opts ) ){
      return $this.each( function(){
        var options = $.extend( {}, opts, {
          container: $( this )[0]
        } );

        cytoscape( options );
      } );
    }
  };

  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;

  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
};

module.exports = registerJquery;

},{"./is":86}],88:[function(require,module,exports){
'use strict';

var math = {};

math.arePositionsSame = function( p1, p2 ){
  return p1.x === p2.x && p1.y === p2.y;
};

math.copyPosition = function( p ){
  return { x: p.x, y: p.y };
};

math.array2point = function( arr ){
  return {
    x: arr[0],
    y: arr[1]
  };
};

math.deg2rad = function( deg ){
  return Math.PI * deg / 180;
};

math.log2 = Math.log2 || function( n ){
  return Math.log( n ) / Math.log( 2 );
};

math.signum = function( x ){
  if( x > 0 ){
    return 1;
  } else if( x < 0 ){
    return -1;
  } else {
    return 0;
  }
};

math.dist = function( p1, p2 ){
  return Math.sqrt( math.sqdist( p1, p2 ) );
};

math.sqdist = function( p1, p2 ){
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx * dx + dy * dy;
};

// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
math.qbezierAt = function( p0, p1, p2, t ){
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};

math.qbezierPtAt = function( p0, p1, p2, t ){
  return {
    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
  };
};

math.lineAt = function( p0, p1, t, d ){
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };

  var vecDist = math.dist( p0, p1 );

  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };

  t = t == null ? 0 : t;

  var d = d != null ? d : t * vecDist;

  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};

math.lineAtDist = function( p0, p1, d ){
  return math.lineAt( p0, p1, undefined, d );
};

// get angle at A via cosine law
math.triangleAngle = function( A, B, C ){
  var a = math.dist( B, C );
  var b = math.dist( A, C );
  var c = math.dist( A, B );

  return Math.acos( (a*a + b*b - c*c)/(2*a*b) );
};

math.bound = function( min, val, max ){
  return Math.max( min, Math.min( max, val ) );
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function( bb ){
  if( bb == null ){
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if( bb.x1 != null && bb.y1 != null ){
    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.updateBoundingBox = function( bb1, bb2 ){
  // update bb1 with bb2 bounds

  bb1.x1 = Math.min( bb1.x1, bb2.x1 );
  bb1.x2 = Math.max( bb1.x2, bb2.x2 );
  bb1.w = bb1.x2 - bb1.x1;

  bb1.y1 = Math.min( bb1.y1, bb2.y1 );
  bb1.y2 = Math.max( bb1.y2, bb2.y2 );
  bb1.h = bb1.y2 - bb1.y1;
};

math.expandBoundingBox = function( bb, padding ){
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;

  return bb;
};

math.boundingBoxesIntersect = function( bb1, bb2 ){
  // case: one bb to right of other
  if( bb1.x1 > bb2.x2 ){ return false; }
  if( bb2.x1 > bb1.x2 ){ return false; }

  // case: one bb to left of other
  if( bb1.x2 < bb2.x1 ){ return false; }
  if( bb2.x2 < bb1.x1 ){ return false; }

  // case: one bb above other
  if( bb1.y2 < bb2.y1 ){ return false; }
  if( bb2.y2 < bb1.y1 ){ return false; }

  // case: one bb below other
  if( bb1.y1 > bb2.y2 ){ return false; }
  if( bb2.y1 > bb1.y2 ){ return false; }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function( bb, x, y ){
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function( bb, pt ){
  return this.inBoundingBox( bb, pt.x, pt.y );
};

math.boundingBoxInBoundingBox = function( bb1, bb2 ){
  return (
       math.inBoundingBox( bb1, bb2.x1, bb2.y1 )
    && math.inBoundingBox( bb1, bb2.x2, bb2.y2 )
  );
};

math.roundRectangleIntersectLine = function(
  x, y, nodeX, nodeY, width, height, padding ){

  var cornerRadius = this.getRoundRectangleRadius( width, height );

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false );

    if( straightLineIntersections.length > 0 ){
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topLeftCenterX, topLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= topLeftCenterX
      && arcIntersections[1] <= topLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topRightCenterX, topRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= topRightCenterX
      && arcIntersections[1] <= topRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] >= bottomRightCenterX
      && arcIntersections[1] >= bottomRightCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding );

    // Ensure the intersection is on the desired quarter of the circle
    if( arcIntersections.length > 0
      && arcIntersections[0] <= bottomLeftCenterX
      && arcIntersections[1] >= bottomLeftCenterY ){
      return [ arcIntersections[0], arcIntersections[1] ];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function( x, y, lx1, ly1, lx2, ly2, tolerance ){
  var t = tolerance;

  var x1 = Math.min( lx1, lx2 );
  var x2 = Math.max( lx1, lx2 );
  var y1 = Math.min( ly1, ly2 );
  var y2 = Math.max( ly1, ly2 );

  return x1 - t <= x && x <= x2 + t
    && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function(
  x, y, x1, y1, x2, y2, x3, y3, tolerance ){

  var bb = {
    x1: Math.min( x1, x3, x2 ) - tolerance,
    x2: Math.max( x1, x3, x2 ) + tolerance,
    y1: Math.min( y1, y3, y2 ) - tolerance,
    y2: Math.max( y1, y3, y2 ) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }

};

math.solveCubic = function( a, b, c, d, result ){

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant, q, r, dum1, s, t, term1, r13;

  q = (3.0 * c - (b * b)) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = (b / 3.0);

  if( discriminant > 0 ){
    s = r + Math.sqrt( discriminant );
    s = ((s < 0) ? -Math.pow( -s, (1.0 / 3.0) ) : Math.pow( s, (1.0 / 3.0) ));
    t = r - Math.sqrt( discriminant );
    t = ((t < 0) ? -Math.pow( -t, (1.0 / 3.0) ) : Math.pow( t, (1.0 / 3.0) ));
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt( 3.0 ) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if( discriminant === 0 ){
    r13 = ((r < 0) ? -Math.pow( -r, (1.0 / 3.0) ) : Math.pow( r, (1.0 / 3.0) ));
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos( r / Math.sqrt( dum1 ) );
  r13 = 2.0 * Math.sqrt( q );
  result[0] = -term1 + r13 * Math.cos( dum1 / 3.0 );
  result[2] = -term1 + r13 * Math.cos( (dum1 + 2.0 * Math.PI) / 3.0 );
  result[4] = -term1 + r13 * Math.cos( (dum1 + 4.0 * Math.PI) / 3.0 );

  return;
};

math.sqdistToQuadraticBezier = function(
  x, y, x1, y1, x2, y2, x3, y3 ){

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3
    + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3
    + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x
    + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x
    + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic( a, b, c, d, roots );

  var zeroThreshold = 0.0000001;

  var params = [];

  for( var index = 0; index < 6; index += 2 ){
    if( Math.abs( roots[ index + 1] ) < zeroThreshold
        && roots[ index ] >= 0
        && roots[ index ] <= 1.0 ){
      params.push( roots[ index ] );
    }
  }

  params.push( 1.0 );
  params.push( 0.0 );

  var minDistanceSquared = -1;
  var closestParam;

  var curX, curY, distSquared;
  for( var i = 0; i < params.length; i++ ){
    curX = Math.pow( 1.0 - params[ i ], 2.0 ) * x1
      + 2.0 * (1 - params[ i ]) * params[ i ] * x2
      + params[ i ] * params[ i ] * x3;

    curY = Math.pow( 1 - params[ i ], 2.0 ) * y1
      + 2 * (1.0 - params[ i ]) * params[ i ] * y2
      + params[ i ] * params[ i ] * y3;

    distSquared = Math.pow( curX - x, 2 ) + Math.pow( curY - y, 2 );
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if( minDistanceSquared >= 0 ){
      if( distSquared < minDistanceSquared ){
        minDistanceSquared = distSquared;
        closestParam = params[ i ];
      }
    } else {
      minDistanceSquared = distSquared;
      closestParam = params[ i ];
    }
  }

  return minDistanceSquared;
};

math.sqdistToFiniteLine = function( x, y, x1, y1, x2, y2 ){
  var offset = [ x - x1, y - y1 ];
  var line = [ x2 - x1, y2 - y1 ];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if( dotProduct < 0 ){
    return hypSq;
  }

  if( adjSq > lineSq ){
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function( x, y, points ){
  var x1, y1, x2, y2;
  var y3;

  // Intersect with vertical line through (x, y)
  var up = 0;
  var down = 0;
  for( var i = 0; i < points.length / 2; i++ ){

    x1 = points[ i * 2];
    y1 = points[ i * 2 + 1];

    if( i + 1 < points.length / 2 ){
      x2 = points[ (i + 1) * 2];
      y2 = points[ (i + 1) * 2 + 1];
    } else {
      x2 = points[ (i + 1 - points.length / 2) * 2];
      y2 = points[ (i + 1 - points.length / 2) * 2 + 1];
    }

    if( x1 == x && x2 == x ){
      // then ignore
    } else if( (x1 >= x && x >= x2)
      || (x1 <= x && x <= x2) ){

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if( y3 > y ){
        up++;
      }

      if( y3 < y ){
        down++;
      }

    } else {
      continue;
    }

  }

  if( up % 2 === 0 ){
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function(
  x, y, basePoints, centerX, centerY, width, height, direction, padding ){

  //var direction = arguments[6];
  var transformedPoints = new Array( basePoints.length );

  // Gives negative angle
  var angle;

  if( direction[0] != null ){
    angle = Math.atan( direction[1] / direction[0] );

    if( direction[0] < 0 ){
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos( -angle );
  var sin = Math.sin( -angle );

  //    console.log("base: " + basePoints);
  for( var i = 0; i < transformedPoints.length / 2; i++ ){
    transformedPoints[ i * 2] =
      width / 2 * (basePoints[ i * 2] * cos
        - basePoints[ i * 2 + 1] * sin);

    transformedPoints[ i * 2 + 1] =
      height / 2 * (basePoints[ i * 2 + 1] * cos
        + basePoints[ i * 2] * sin);

    transformedPoints[ i * 2] += centerX;
    transformedPoints[ i * 2 + 1] += centerY;
  }

  var points;

  if( padding > 0 ){
    var expandedLineSet = this.expandPolygon(
      transformedPoints,
      -padding );

    points = this.joinLines( expandedLineSet );
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints( x, y, points );
};

math.joinLines = function( lineSet ){

  var vertices = new Array( lineSet.length / 2 );

  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for( var i = 0; i < lineSet.length / 4; i++ ){
    currentLineStartX = lineSet[ i * 4];
    currentLineStartY = lineSet[ i * 4 + 1];
    currentLineEndX = lineSet[ i * 4 + 2];
    currentLineEndY = lineSet[ i * 4 + 3];

    if( i < lineSet.length / 4 - 1 ){
      nextLineStartX = lineSet[ (i + 1) * 4];
      nextLineStartY = lineSet[ (i + 1) * 4 + 1];
      nextLineEndX = lineSet[ (i + 1) * 4 + 2];
      nextLineEndY = lineSet[ (i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(
      currentLineStartX, currentLineStartY,
      currentLineEndX, currentLineEndY,
      nextLineStartX, nextLineStartY,
      nextLineEndX, nextLineEndY,
      true );

    vertices[ i * 2] = intersection[0];
    vertices[ i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function( points, pad ){

  var expandedLineSet = new Array( points.length * 2 );

  var currentPointX, currentPointY, nextPointX, nextPointY;

  for( var i = 0; i < points.length / 2; i++ ){
    currentPointX = points[ i * 2];
    currentPointY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextPointX = points[ (i + 1) * 2];
      nextPointY = points[ (i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = (nextPointY - currentPointY);
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt( offsetX * offsetX + offsetY * offsetY );
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[ i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[ i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[ i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function(
  x, y, centerX, centerY, ellipseWradius, ellipseHradius ){

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt( dispX * dispX + dispY * dispY );

  var newLength = len - 1;

  if( newLength < 0 ){
    return [];
  }

  var lenProportion = newLength / len;

  return [ (centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y ];
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function(
  x1, y1, x2, y2, centerX, centerY, radius ){

  // Calculate d, direction vector of line
  var d = [ x2 - x1, y2 - y1 ]; // Direction vector of line
  var c = [ centerX, centerY ]; // Center of circle
  var f = [ x1 - centerX, y1 - centerY ];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;

  var discriminant = b * b - 4 * a * c;

  if( discriminant < 0 ){
    return [];
  }

  var t1 = (-b + Math.sqrt( discriminant )) / (2 * a);
  var t2 = (-b - Math.sqrt( discriminant )) / (2 * a);

  var tMin = Math.min( t1, t2 );
  var tMax = Math.max( t1, t2 );
  var inRangeParams = [];

  if( tMin >= 0 && tMin <= 1 ){
    inRangeParams.push( tMin );
  }

  if( tMax >= 0 && tMax <= 1 ){
    inRangeParams.push( tMax );
  }

  if( inRangeParams.length === 0 ){
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if( inRangeParams.length > 1 ){

    if( inRangeParams[0] == inRangeParams[1] ){
      return [ nearIntersectionX, nearIntersectionY ];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [ nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY ];
    }

  } else {
    return [ nearIntersectionX, nearIntersectionY ];
  }

};

math.findCircleNearPoint = function( centerX, centerY,
  radius, farX, farY ){

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt( displacementX * displacementX
    + displacementY * displacementY );

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [ centerX + unitDisplacementX * radius,
    centerY + unitDisplacementY * radius ];
};

math.findMaxSqDistanceToOrigin = function( points ){
  var maxSqDistance = 0.000001;
  var sqDistance;

  for( var i = 0; i < points.length / 2; i++ ){

    sqDistance = points[ i * 2] * points[ i * 2]
      + points[ i * 2 + 1] * points[ i * 2 + 1];

    if( sqDistance > maxSqDistance ){
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.midOfThree = function( a, b, c ){
  if( (b <= a && a <= c) || (c <= a && a <= b) ){
    return a;
  } else if( (a <= b && b <= c) || (c <= b && b <= a) ){
    return b;
  } else {
    return c;
  }
};

math.finiteLinesIntersect = function( x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines ){

  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;

  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;

  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b  = dy43 * dx21 - dx43 * dy21;

  if( u_b !== 0 ){
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    var flptThreshold = 0.001;
    var min = 0 - flptThreshold;
    var max = 1 + flptThreshold;

    if( min <= ua && ua <= max && min <= ub && ub <= max ){
      return [ x1 + ua * dx21, y1 + ua * dy21 ];

    } else {
      if( !infiniteLines ){
        return [];
      } else {
        return [ x1 + ua * dx21, y1 + ua * dy21 ];
      }
    }
  } else {
    if( ua_t === 0 || ub_t === 0 ){

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if( this.midOfThree( x1, x2, x4 ) === x4 ){
        return [ x4, y4 ];
      }

      // Check start point of second line
      if( this.midOfThree( x1, x2, x3 ) === x3 ){
        return [ x3, y3 ];
      }

      // Endpoint of first line
      if( this.midOfThree( x3, x4, x2 ) === x2 ){
        return [ x2, y2 ];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

math.polygonIntersectLine = function(
  x, y, basePoints, centerX, centerY, width, height, padding ){

  var intersections = [];
  var intersection;

  var transformedPoints = new Array( basePoints.length );

  for( var i = 0; i < transformedPoints.length / 2; i++ ){
    transformedPoints[ i * 2] = basePoints[ i * 2] * width + centerX;
    transformedPoints[ i * 2 + 1] = basePoints[ i * 2 + 1] * height + centerY;
  }

  var points;

  if( padding > 0 ){
    var expandedLineSet = math.expandPolygon(
      transformedPoints,
      -padding );

    points = math.joinLines( expandedLineSet );
  } else {
    points = transformedPoints;
  }
  // var points = transformedPoints;

  var currentX, currentY, nextX, nextY;

  for( var i = 0; i < points.length / 2; i++ ){

    currentX = points[ i * 2];
    currentY = points[ i * 2 + 1];

    if( i < points.length / 2 - 1 ){
      nextX = points[ (i + 1) * 2];
      nextY = points[ (i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(
      x, y, centerX, centerY,
      currentX, currentY,
      nextX, nextY );

    if( intersection.length !== 0 ){
      intersections.push( intersection[0], intersection[1] );
    }
  }

  return intersections;
};

math.shortenIntersection = function(
  intersection, offset, amount ){

  var disp = [ intersection[0] - offset[0], intersection[1] - offset[1] ];

  var length = Math.sqrt( disp[0] * disp[0] + disp[1] * disp[1] );

  var lenRatio = (length - amount) / length;

  if( lenRatio < 0 ){
    lenRatio = 0.00001;
  }

  return [ offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1] ];
};

math.generateUnitNgonPointsFitToSquare = function( sides, rotationRadians ){
  var points = math.generateUnitNgonPoints( sides, rotationRadians );
  points = math.fitPolygonToSquare( points );

  return points;
};

math.fitPolygonToSquare = function( points ){
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ];
    y = points[2 * i + 1];

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for( var i = 0; i < sides; i++ ){
    x = points[2 * i ] = points[2 * i ] * sx;
    y = points[2 * i + 1] = points[2 * i + 1] * sy;

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  if( minY < -1 ){
    for( var i = 0; i < sides; i++ ){
      y = points[2 * i + 1] = points[2 * i + 1] + (-1 - minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function( sides, rotationRadians ){

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ?
    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  //    console.log(nodeShapes['square']);
  startAngle += rotationRadians;

  var points = new Array( sides * 2 );

  var currentAngle, x, y;
  for( var i = 0; i < sides; i++ ){
    currentAngle = i * increment + startAngle;

    x = points[2 * i ] = Math.cos( currentAngle );// * (1 + i/2);
    y = points[2 * i + 1] = Math.sin( -currentAngle );//  * (1 + i/2);
  }

  return points;
};

math.getRoundRectangleRadius = function( width, height ){

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min( width / 4, height / 4, 8 );
};

module.exports = math;

},{}],89:[function(require,module,exports){
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

'use strict';

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function( executor ){
  /*  optionally support non-constructor/plain-function call  */
  if( !(this instanceof api) )
    return new api( executor );

  /*  initialize object  */
  this.id           = 'Thenable/1.0.7';
  this.state        = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled  = [];            /*  initial handlers  */
  this.onRejected   = [];            /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind( this )
  };

  /*  support optional executor function  */
  if( typeof executor === 'function' )
    executor.call( this, this.fulfill.bind( this ), this.reject.bind( this ) );
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function( value ){ return deliver( this, STATE_FULFILLED, 'fulfillValue', value ); },
  reject:  function( value ){ return deliver( this, STATE_REJECTED,  'rejectReason', value ); },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function( onFulfilled, onRejected ){
    var curr = this;
    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(
      resolver( onFulfilled, next, 'fulfill' ) );             /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(
      resolver( onRejected,  next, 'reject' ) );             /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute( curr );
    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function( curr, state, name, value ){
  if( curr.state === STATE_PENDING ){
    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[ name ] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute( curr );
  }
  return curr;
};

/*  execute all handlers  */
var execute = function( curr ){
  if( curr.state === STATE_FULFILLED )
    execute_handlers( curr, 'onFulfilled', curr.fulfillValue );
  else if( curr.state === STATE_REJECTED )
    execute_handlers( curr, 'onRejected',  curr.rejectReason );
};

/*  execute particular set of handlers  */
var execute_handlers = function( curr, name, value ){
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if( curr[ name ].length === 0 )
    return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[ name ];
  curr[ name ] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function(){
    for( var i = 0; i < handlers.length; i++ )
      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
  if( typeof setImmediate === 'function' )
    setImmediate( func );
  else
    setTimeout( func, 0 );
};

/*  generate a resolver function  */
var resolver = function( cb, next, method ){
  return function( value ){
    if( typeof cb !== 'function' )                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[ method ].call( next, value );                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
      var result;
      try { result = cb( value ); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
      catch( e ){
        next.reject( e );                                  /*  [Promises/A+ 2.2.7.2]  */
        return;
      }
      resolve( next, result );                               /*  [Promises/A+ 2.2.7.1]  */
    }
  };
};

/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
var resolve = function( promise, x ){
  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
  if( promise === x || promise.proxy === x ){
    promise.reject( new TypeError( 'cannot resolve promise with itself' ) );
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if( (typeof x === 'object' && x !== null) || typeof x === 'function' ){
    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch( e ){
      promise.reject( e );                                   /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if( typeof then === 'function' ){
    var resolved = false;
    try {
      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
      then.call( x,
        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
        function( y ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          if( y === x )                                 /*  [Promises/A+ 3.6]  */
            promise.reject( new TypeError( 'circular thenable chain' ) );
          else
            resolve( promise, y );
        },

        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
        function( r ){
          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject( r );
        }
      );
    }
    catch( e ){
      if( !resolved )                                       /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject( e );                               /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill( x );                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// so we always have Promise.all()
api.all = function( ps ){
  return new api(function( resolveAll, rejectAll ){
    var vals = new Array( ps.length );
    var doneCount = 0;

    var fulfill = function( i, val ){
      vals[ i ] = val;
      doneCount++;

      if( doneCount === ps.length ){
        resolveAll( vals );
      }
    };

    for( var i = 0; i < ps.length; i++ ){
      (function( i ){
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if( isPromise ){
          p.then( function( val ){
            fulfill( i, val );
          }, function( err ){
            rejectAll( err );
          } );
        } else {
          var val = p;
          fulfill( i, val );
        }
      })( i );
    }

  } );
};

api.resolve = function( val ){
  return new api(function( resolve, reject ){ resolve( val ); });
};

api.reject = function( val ){
  return new api(function( resolve, reject ){ reject( val ); });
};

module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

},{}],90:[function(require,module,exports){
'use strict';

var is = require( './is' );
var util = require( './util' );

var Selector = function( selector ){

  if( !(this instanceof Selector) ){
    return new Selector( selector );
  }

  var self = this;

  self._private = {
    selectorText: null,
    invalid: true
  };

  // storage for parsed queries
  var newQuery = function(){
    return {
      classes: [],
      colonSelectors: [],
      data: [],
      group: null,
      ids: [],
      meta: [],

      // fake selectors
      collection: null, // a collection to match against
      filter: null, // filter function

      // these are defined in the upward direction rather than down (e.g. child)
      // because we need to go up in Selector.filter()
      parent: null, // parent query obj
      ancestor: null, // ancestor query obj
      subject: null, // defines subject in compound query (subject query obj; points to self if subject)

      // use these only when subject has been defined
      child: null,
      descendant: null
    };
  };

  if( !selector || ( is.string( selector ) && selector.match( /^\s*$/ ) ) ){

    self.length = 0;

  } else if( selector === '*' || selector === 'edge' || selector === 'node' ){

    // make single, group-only selectors cheap to make and cheap to filter

    self[0] = newQuery();
    self[0].group = selector === '*' ? selector : selector + 's';
    self[0].groupOnly = true;
    self._private.invalid = false;
    self._private.selectorText = selector;
    self.length = 1;

  } else if( is.elementOrCollection( selector ) ){

    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self.length = 1;

  } else if( is.fn( selector ) ){

    self[0] = newQuery();
    self[0].filter = selector;
    self.length = 1;

  } else if( is.string( selector ) ){

    // the current subject in the query
    var currentSubject = null;

    // tokens in the query language
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
    tokens.className = tokens.variable; // a class name (follows variable conventions)
    tokens.id = tokens.variable; // an element id (follows variable conventions)

    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
    // so that values get compared properly in Selector.filter()
    var cleanMetaChars = function( str ){
      return str.replace( new RegExp( '\\\\(' + tokens.metaChar + ')', 'g' ), function( match, $1, offset, original ){
        return $1;
      } );
    };

    // add @ variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];
      tokens.comparatorOp += '|@' + op;
    }

    // add ! variants to comparatorOp
    var ops = tokens.comparatorOp.split( '|' );
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[ i ];

      if( op.indexOf( '!' ) >= 0 ){ continue; } // skip ops that explicitly contain !
      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

      tokens.comparatorOp += '|\\!' + op;
    }

    // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
    // - when you add something here, also add to Selector.toString()
    var exprs = [
      {
        name: 'group',
        query: true,
        regex: '(node|edge|\\*)',
        populate: function( group ){
          this.group = group === '*' ? group : group + 's';
        }
      },

      {
        name: 'state',
        query: true,
        // NB: if one colon selector is a substring of another from its start, place the longer one first
        // e.g. :foobar|:foo
        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
        populate: function( state ){
          this.colonSelectors.push( state );
        }
      },

      {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function( id ){
          this.ids.push( cleanMetaChars( id ) );
        }
      },

      {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function( className ){
          this.classes.push( cleanMetaChars( className ) );
        }
      },

      {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( variable ){
          this.data.push( {
            field: cleanMetaChars( variable )
          } );
        }
      },

      {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function( variable, comparatorOp, value ){
          var valueIsString = new RegExp( '^' + tokens.string + '$' ).exec( value ) != null;

          if( valueIsString ){
            value = value.substring( 1, value.length - 1 );
          } else {
            value = parseFloat( value );
          }

          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: comparatorOp,
            value: value
          } );
        }
      },

      {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function( boolOp, variable ){
          this.data.push( {
            field: cleanMetaChars( variable ),
            operator: boolOp
          } );
        }
      },

      {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function( meta, comparatorOp, number ){
          this.meta.push( {
            field: cleanMetaChars( meta ),
            operator: comparatorOp,
            value: parseFloat( number )
          } );
        }
      },

      {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function(){
          // go on to next query
          self[ ++i ] = newQuery();
          currentSubject = null;
        }
      },

      {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function(){
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = this;
          childQuery.subject = currentSubject;

          // we're now populating the child query with expressions that follow
          self[ i ] = childQuery;
        }
      },

      {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function(){
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = this;
          descendantQuery.subject = currentSubject;

          // we're now populating the descendant query with expressions that follow
          self[ i ] = descendantQuery;
        }
      },

      {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function(){
          if( currentSubject != null && this.subject != this ){
            util.error( 'Redefinition of subject in selector `' + selector + '`' );
            return false;
          }

          currentSubject = this;
          this.subject = this;
        }

      }
    ];

    self._private.selectorText = selector;
    var remaining = selector;
    var i = 0;

    // of all the expressions, find the first match in the remaining text
    var consumeExpr = function( expectation ){
      var expr;
      var match;
      var name;

      for( var j = 0; j < exprs.length; j++ ){
        var e = exprs[ j ];
        var n = e.name;

        // ignore this expression if it doesn't meet the expectation function
        if( is.fn( expectation ) && !expectation( n, e ) ){ continue; }

        var m = remaining.match( new RegExp( '^' + e.regex ) );

        if( m != null ){
          match = m;
          expr = e;
          name = n;

          var consumed = m[0];
          remaining = remaining.substring( consumed.length );

          break; // we've consumed one expr, so we can return now
        }
      }

      return {
        expr: expr,
        match: match,
        name: name
      };
    };

    // consume all leading whitespace
    var consumeWhitespace = function(){
      var match = remaining.match( /^\s+/ );

      if( match ){
        var consumed = match[0];
        remaining = remaining.substring( consumed.length );
      }
    };

    self[0] = newQuery(); // get started

    consumeWhitespace(); // get rid of leading whitespace
    for( ;; ){
      var check = consumeExpr();

      if( check.expr == null ){
        util.error( 'The selector `' + selector + '`is invalid' );
        return;
      } else {
        var args = [];
        for( var j = 1; j < check.match.length; j++ ){
          args.push( check.match[ j ] );
        }

        // let the token populate the selector object (i.e. in self[i])
        var ret = check.expr.populate.apply( self[ i ], args );

        if( ret === false ){ return; } // exit if population failed
      }

      // we're done when there's nothing left to parse
      if( remaining.match( /^\s*$/ ) ){
        break;
      }
    }

    self.length = i + 1;

    // adjust references for subject
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( query.subject != null ){
        // go up the tree until we reach the subject
        for( ;; ){
          if( query.subject == query ){ break; } // done if subject is self

          if( query.parent != null ){ // swap parent/child reference
            var parent = query.parent;
            var child = query;

            child.parent = null;
            parent.child = child;

            query = parent; // go up the tree
          } else if( query.ancestor != null ){ // swap ancestor/descendant
            var ancestor = query.ancestor;
            var descendant = query;

            descendant.ancestor = null;
            ancestor.descendant = descendant;

            query = ancestor; // go up the tree
          } else {
            util.error( 'When adjusting references for the selector `' + query + '`, neither parent nor ancestor was found' );
            break;
          }
        } // for

        self[ j ] = query.subject; // subject should be the root query
      } // if
    } // for

  } else {
    util.error( 'A selector must be created from a string; found ' + selector );
    return;
  }

  self._private.invalid = false;

};

var selfn = Selector.prototype;

selfn.size = function(){
  return this.length;
};

selfn.eq = function( i ){
  return this[ i ];
};

var queryMatches = function( query, ele ){
  var ele_p = ele._private;

  // make single group-only selectors really cheap to check since they're the most common ones
  if( query.groupOnly ){
    return query.group === '*' || query.group === ele_p.group;
  }

  // check group
  if( query.group != null && query.group != '*' && query.group != ele_p.group ){
    return false;
  }

  var cy = ele.cy();

  // check colon selectors
  var allColonSelectorsMatch = true;
  for( var k = 0; k < query.colonSelectors.length; k++ ){
    var sel = query.colonSelectors[ k ];

    switch( sel ){
      case ':selected':
        allColonSelectorsMatch = ele.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !ele.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = ele.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !ele.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = ele.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !ele.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = ele.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !ele.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = ele.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = ele.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !ele.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = ele.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !ele.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = ele.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !ele.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = ele.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !ele.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = ele.isNode() && ele.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = ele.isNode() && ele.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = ele.isNode() && ele.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) === ele.data( 'target' );
        break;
      case ':simple':
        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) !== ele.data( 'target' );
        break;
      case ':active':
        allColonSelectorsMatch = ele.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !ele.active();
        break;
      case ':touch':
        allColonSelectorsMatch = is.touch();
        break;
      case ':backgrounding':
        allColonSelectorsMatch = ele.backgrounding();
        break;
      case ':nonbackgrounding':
        allColonSelectorsMatch = !ele.backgrounding();
        break;
    }

    if( !allColonSelectorsMatch ) break;
  }
  if( !allColonSelectorsMatch ) return false;

  // check id
  var allIdsMatch = true;
  for( var k = 0; k < query.ids.length; k++ ){
    var id = query.ids[ k ];
    var actualId = ele_p.data.id;

    allIdsMatch = allIdsMatch && (id == actualId);

    if( !allIdsMatch ) break;
  }
  if( !allIdsMatch ) return false;

  // check classes
  var allClassesMatch = true;
  for( var k = 0; k < query.classes.length; k++ ){
    var cls = query.classes[ k ];

    allClassesMatch = allClassesMatch && ele.hasClass( cls );

    if( !allClassesMatch ) break;
  }
  if( !allClassesMatch ) return false;

  // generic checking for data/metadata
  var operandsMatch = function( params ){
    var allDataMatches = true;
    for( var k = 0; k < query[ params.name ].length; k++ ){
      var data = query[ params.name ][ k ];
      var operator = data.operator;
      var value = data.value;
      var field = data.field;
      var matches;

      if( operator != null && value != null ){

        var fieldVal = params.fieldValue( field );
        var fieldStr = !is.string( fieldVal ) && !is.number( fieldVal ) ? '' : '' + fieldVal;
        var valStr = '' + value;

        var caseInsensitive = false;
        if( operator.indexOf( '@' ) >= 0 ){
          fieldStr = fieldStr.toLowerCase();
          valStr = valStr.toLowerCase();

          operator = operator.replace( '@', '' );
          caseInsensitive = true;
        }

        var notExpr = false;
        if( operator.indexOf( '!' ) >= 0 ){
          operator = operator.replace( '!', '' );
          notExpr = true;
        }

        // if we're doing a case insensitive comparison, then we're using a STRING comparison
        // even if we're comparing numbers
        if( caseInsensitive ){
          value = valStr.toLowerCase();
          fieldVal = fieldStr.toLowerCase();
        }

        var isIneqCmp = false;

        switch( operator ){
        case '*=':
          matches = fieldStr.indexOf( valStr ) >= 0;
          break;
        case '$=':
          matches = fieldStr.indexOf( valStr, fieldStr.length - valStr.length ) >= 0;
          break;
        case '^=':
          matches = fieldStr.indexOf( valStr ) === 0;
          break;
        case '=':
          matches = fieldVal === value;
          break;
        case '>':
          isIneqCmp = true;
          matches = fieldVal > value;
          break;
        case '>=':
          isIneqCmp = true;
          matches = fieldVal >= value;
          break;
        case '<':
          isIneqCmp = true;
          matches = fieldVal < value;
          break;
        case '<=':
          isIneqCmp = true;
          matches = fieldVal <= value;
          break;
        default:
          matches = false;
          break;
        }

        // apply the not op, but null vals for inequalities should always stay non-matching
        if( notExpr && ( fieldVal != null || !isIneqCmp ) ){
          matches = !matches;
        }
      } else if( operator != null ){
        switch( operator ){
        case '?':
          matches = params.fieldTruthy( field );
          break;
        case '!':
          matches = !params.fieldTruthy( field );
          break;
        case '^':
          matches = params.fieldUndefined( field );
          break;
        }
      } else {
        matches = !params.fieldUndefined( field );
      }

      if( !matches ){
        allDataMatches = false;
        break;
      }
    } // for

    return allDataMatches;
  }; // operandsMatch

  // check data matches
  var allDataMatches = operandsMatch( {
    name: 'data',
    fieldValue: function( field ){
      return ele_p.data[ field ];
    },
    fieldUndefined: function( field ){
      return ele_p.data[ field ] === undefined;
    },
    fieldTruthy: function( field ){
      if( ele_p.data[ field ] ){
        return true;
      }
      return false;
    }
  } );

  if( !allDataMatches ){
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch( {
    name: 'meta',
    fieldValue: function( field ){
      return ele[ field ]();
    },
    fieldUndefined: function( field ){
      return ele[ field ]() == null;
    },
    fieldTruthy: function( field ){
      if( ele[ field ]() ){
        return true;
      }
      return false;
    }
  } );

  if( !allMetaMatches ){
    return false;
  }

  // check collection
  if( query.collection != null ){
    var matchesAny = query.collection.hasElementWithId( ele.id() );

    if( !matchesAny ){
      return false;
    }
  }

  // check filter function
  if( query.filter != null && ele.collection().filter( query.filter ).size() === 0 ){
    return false;
  }

  // check parent/child relations
  var confirmRelations = function( query, eles ){
    if( query != null ){
      var matches = false;

      if( !cy.hasCompoundNodes() ){
        return false;
      }

      eles = eles(); // save cycles if query == null

      // query must match for at least one element (may be recursive)
      for( var i = 0; i < eles.length; i++ ){
        if( queryMatches( query, eles[ i ] ) ){
          matches = true;
          break;
        }
      }

      return matches;
    } else {
      return true;
    }
  };

  if( !confirmRelations( query.parent, function(){
    return ele.parent();
  } ) ){ return false; }

  if( !confirmRelations( query.ancestor, function(){
    return ele.parents();
  } ) ){ return false; }

  if( !confirmRelations( query.child, function(){
    return ele.children();
  } ) ){ return false; }

  if( !confirmRelations( query.descendant, function(){
    return ele.descendants();
  } ) ){ return false; }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
selfn.filter = function( collection ){
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return cy.collection();
  }

  var selectorFunction = function( i, element ){
    for( var j = 0; j < self.length; j++ ){
      var query = self[ j ];

      if( queryMatches( query, element ) ){
        return true;
      }
    }

    return false;
  };

  if( self._private.selectorText == null ){
    selectorFunction = function(){ return true; };
  }

  var filteredCollection = collection.filter( selectorFunction );

  return filteredCollection;
}; // filter

// does selector match a single element?
selfn.matches = function( ele ){
  var self = this;

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return false;
  }

  for( var j = 0; j < self.length; j++ ){
    var query = self[ j ];

    if( queryMatches( query, ele ) ){
      return true;
    }
  }

  return false;
}; // filter

// ith query to string
selfn.toString = selfn.selector = function(){

  var str = '';

  var clean = function( obj ){
    if( obj == null ){
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function( val ){
    if( is.string( val ) ){
      return '"' + val + '"';
    } else {
      return clean( val );
    }
  };

  var space = function( val ){
    return ' ' + val + ' ';
  };

  var queryToString = function( query ){
    var str = '';

    if( query.subject === query ){
      str += '$';
    }

    var group = clean( query.group );
    str += group.substring( 0, group.length - 1 );

    for( var j = 0; j < query.data.length; j++ ){
      var data = query.data[ j ];

      if( data.value ){
        str += '[' + data.field + space( clean( data.operator ) ) + cleanVal( data.value ) + ']';
      } else {
        str += '[' + clean( data.operator ) + data.field + ']';
      }
    }

    for( var j = 0; j < query.meta.length; j++ ){
      var meta = query.meta[ j ];
      str += '[[' + meta.field + space( clean( meta.operator ) ) + cleanVal( meta.value ) + ']]';
    }

    for( var j = 0; j < query.colonSelectors.length; j++ ){
      var sel = query.colonSelectors[ i ];
      str += sel;
    }

    for( var j = 0; j < query.ids.length; j++ ){
      var sel = '#' + query.ids[ i ];
      str += sel;
    }

    for( var j = 0; j < query.classes.length; j++ ){
      var sel = '.' + query.classes[ j ];
      str += sel;
    }

    if( query.parent != null ){
      str = queryToString( query.parent ) + ' > ' + str;
    }

    if( query.ancestor != null ){
      str = queryToString( query.ancestor ) + ' ' + str;
    }

    if( query.child != null ){
      str += ' > ' + queryToString( query.child );
    }

    if( query.descendant != null ){
      str += ' ' + queryToString( query.descendant );
    }

    return str;
  };

  for( var i = 0; i < this.length; i++ ){
    var query = this[ i ];

    str += queryToString( query );

    if( this.length > 1 && i < this.length - 1 ){
      str += ', ';
    }
  }

  return str;
};

module.exports = Selector;

},{"./is":86,"./util":103}],91:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function( eles ){
  var self = this;
  var _p = self._private;

  if( _p.newStyle ){ // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};

    self.cleanElements( eles, true );
  }

  for( var ie = 0; ie < eles.length; ie++ ){
    var ele = eles[ ie ];

    var cxtMeta = self.getContextMeta( ele );
    var cxtStyle = self.getContextStyle( cxtMeta );
    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

    self.updateTransitions( ele, app.diffProps );
    self.updateStyleHints( ele );

  } // for elements

  _p.newStyle = false;
};

styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[ dualCxtKey ];

  if( cachedVal ){
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var oldHasCxt = oldCxtKey[ i ] === 't';
    var newHasCxt = newCxtKey[ i ] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if( cxtHasDiffed || cxtHasMappedProps ){
      var props;

      if( cxtHasDiffed && cxtHasMappedProps ){
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if( cxtHasDiffed ){
        props = cxt.properties; // need to check them all
      } else if( cxtHasMappedProps ){
        props = cxt.mappedProperties; // only need to check mapped
      }

      for( var j = 0; j < props.length; j++ ){
        var prop = props[ j ];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for( var k = i + 1; k < self.length; k++ ){
          var laterCxt = self[ k ];
          var hasLaterCxt = newCxtKey[ k ] === 't';

          if( !hasLaterCxt ){ continue; } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
        }

        if( !addedProp[ name ] && !laterCxtOverrides ){
          addedProp[ name ] = true;
          diffProps.push( name );
        }
      } // for props
    } // if

  } // for contexts

  cache[ dualCxtKey ] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function( ele ){
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if( self._private.newStyle ){
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for( var i = 0; i < self.length; i++ ){
    var context = self[ i ];
    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

    if( contextSelectorMatches ){
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff( prevKey, cxtKey );

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function( cxtMeta ){
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if( cxtStyles[ cxtKey ] ){ return cxtStyles[ cxtKey ]; }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[ i ];
    var hasCxt = cxtKey[ i ] === 't';

    if( !hasCxt ){ continue; }

    for( var j = 0; j < cxt.properties.length; j++ ){
      var prop = cxt.properties[ j ];

      style[ prop.name ] = prop;
    }
  }

  cxtStyles[ cxtKey ] = style;
  return style;
};

styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for( var i = 0; i < diffProps.length; i++ ){
    var diffPropName = diffProps[ i ];
    var cxtProp = cxtStyle[ diffPropName ];
    var eleProp = ele.pstyle( diffPropName );

    if( !cxtProp ){ // no context prop means delete
      if( !eleProp ){
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if( eleProp.bypass ){
        cxtProp = { name: diffPropName, deleteBypassed: true };
      } else {
        cxtProp = { name: diffPropName, delete: true };
      }
    }

    // save cycles when the context prop doesn't need to be applied
    if( eleProp === cxtProp ){ continue; }

    var retDiffProp = retDiffProps[ diffPropName ] = {
      prev: eleProp
    };

    self.applyParsedProperty( ele, cxtProp );

    retDiffProp.next = ele.pstyle( diffPropName );

    if( retDiffProp.next && retDiffProp.next.bypass ){
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function(ele){
  var _p = ele._private;
  var self = this;

  if( ele.removed() ){ return; }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if( _p.group === 'nodes' ){
    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
      var size = ele.pstyle( 'pie-' + i + '-background-size' ).value;

      if( size > 0 ){
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = ele.pstyle( 'text-transform' ).strValue;
  var content = ele.pstyle( 'label' ).strValue;
  var srcContent = ele.pstyle( 'source-label' ).strValue;
  var tgtContent = ele.pstyle( 'target-label' ).strValue;
  var fStyle = ele.pstyle( 'font-style' ).strValue;
  var size = ele.pstyle( 'font-size' ).pfValue + 'px';
  var family = ele.pstyle( 'font-family' ).strValue;
  // var variant = style['font-variant'].strValue;
  var weight = ele.pstyle( 'font-weight' ).strValue;
  var valign = ele.pstyle( 'text-valign' ).strValue;
  var halign = ele.pstyle( 'text-valign' ).strValue;
  var oWidth = ele.pstyle( 'text-outline-width' ).pfValue;
  var wrap = ele.pstyle( 'text-wrap' ).strValue;
  var wrapW = ele.pstyle( 'text-max-width' ).pfValue;
  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
  _p.labelStyleKey = labelStyleKey;
  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
  _p.labelKey = labelStyleKey + '$' + content;
  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function( ele, parsedProp ){
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal, flatProp;
  var types = self.types;
  var type = self.properties[ prop.name ].type;
  var propIsBypass = prop.bypass;
  var origProp = style[ prop.name ];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  // edges connected to compound nodes can not be haystacks
  if(
    parsedProp.name === 'curve-style'
    && parsedProp.value === 'haystack'
    && ele.isEdge()
    && ( ele.isLoop() || ele.source().isParent() || ele.target().isParent() )
  ){
    prop = parsedProp = this.parse( parsedProp.name, 'bezier', propIsBypass );
  }

  if( prop.delete ){ // delete the property and use the default value on falsey value
    style[ prop.name ] = undefined;

    return true;
  }

  if( prop.deleteBypassed ){ // delete the property that the
    if( !origProp ){
      return true; // can't delete if no prop

    } else if( origProp.bypass ){ // delete bypassed
      origProp.bypassed = undefined;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  }

  // check if we need to delete the current bypass
  if( prop.deleteBypass ){ // then this property is just here to indicate we need to delete
    if( !origProp ){
      return true; // property is already not defined

    } else if( origProp.bypass ){ // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[ prop.name ] = origProp.bypassed;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function(){
    util.error( 'Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined' );
  };

  // put the property in the style objects
  switch( prop.mapped ){ // flatten the property if mapped
  case types.mapData:
  case types.mapLayoutData:
  case types.mapScratch:

    var isLayout = prop.mapped === types.mapLayoutData;
    var isScratch = prop.mapped === types.mapScratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    for( var i = 0; i < fields.length && fieldVal; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    }

    var percent;
    if( !is.number( fieldVal ) ){ // then keep the mapping but assume 0% for now
      percent = 0;
    } else {
      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
    }

    // make sure to bound percent value
    if( percent < 0 ){
      percent = 0;
    } else if( percent > 1 ){
      percent = 1;
    }

    if( type.color ){
      var r1 = prop.valueMin[0];
      var r2 = prop.valueMax[0];
      var g1 = prop.valueMin[1];
      var g2 = prop.valueMax[1];
      var b1 = prop.valueMin[2];
      var b2 = prop.valueMax[2];
      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

      var clr = [
        Math.round( r1 + (r2 - r1) * percent ),
        Math.round( g1 + (g2 - g1) * percent ),
        Math.round( b1 + (b2 - b1) * percent ),
        Math.round( a1 + (a2 - a1) * percent )
      ];

      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
        name: prop.name,
        value: clr,
        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
      };

    } else if( type.number ){
      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
      flatProp = this.parse( prop.name, calcValue, prop.bypass, flatPropMapping );

    } else {
      return false; // can only map to colours and numbers
    }

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  // direct mapping
  case types.data:
  case types.layoutData:
  case types.scratch:
    var isLayout = prop.mapped === types.layoutData;
    var isScratch = prop.mapped === types.scratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split( '.' );
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
      var field = fields[ i ];
      fieldVal = fieldVal[ field ];
    } }

    flatProp = this.parse( prop.name, fieldVal, prop.bypass, flatPropMapping );

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      var flatPropVal = origProp ? origProp.strValue : '';

      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, flatPropMapping );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case types.fn:
    var fn = prop.value;
    var fnRetVal = fn( ele );

    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, flatPropMapping );
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case undefined:
    break; // just set the property

  default:
    return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if( propIsBypass ){
    if( origPropIsBypass ){ // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else { // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[ prop.name ] = prop; // and set

  } else { // prop is not bypass
    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else { // then just replace the old prop with the new one
      style[ prop.name ] = prop;
    }
  }

  this.checkZOrderTrigger( ele, prop.name, origProp ? origProp.value : null, prop.value );

  return true;
};

styfn.cleanElements = function( eles, keepBypasses ){
  var self = this;
  var props = self.properties;

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];

    if( !keepBypasses ){
      ele._private.style = {};
    } else {
      var style = ele._private.style;

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        var eleProp = style[ prop.name ];

        if( eleProp ){
          if( eleProp.bypass ){
            eleProp.bypassed = null;
          } else {
            style[ prop.name ] = null;
          }
        }
      }
    }
  }
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function(){
  var cy = this._private.cy;
  var eles = cy.mutableElements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function( eles ){
  var self = this;

  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var style = ele._private.style;

    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
      var prop = self.properties[ j ];
      var propInStyle = style[ prop.name ];

      if( propInStyle && propInStyle.mapping ){
        var mapping = propInStyle.mapping;
        this.applyParsedProperty( ele, mapping ); // reapply the mapping property
      }
    }

    this.updateStyleHints( ele );
  }
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function( ele, diffProps, isBypass ){
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle( 'transition-property' ).value;
  var duration = ele.pstyle( 'transition-duration' ).pfValue;
  var delay = ele.pstyle( 'transition-delay' ).pfValue;

  if( props.length > 0 && duration > 0 ){

    var css = {};

    // build up the style to animate towards
    var anyPrev = false;
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      var styProp = ele.pstyle( prop );
      var diffProp = diffProps[ prop ];

      if( !diffProp ){ continue; }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if( !fromProp ){ continue; }

      // consider px values
      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

      // consider numerical values
      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

      // consider colour values
      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
        diff = fromProp.value[0] !== toProp.value[0]
          || fromProp.value[1] !== toProp.value[1]
          || fromProp.value[2] !== toProp.value[2]
        ;

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if( diff ){
        css[ prop ] = toProp.strValue; // to val
        this.applyBypass( ele, prop, initVal ); // from val
        anyPrev = true;
      }

    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if( !anyPrev ){ return; }

    _p.transitioning = true;

    ele.stop();

    if( delay > 0 ){
      ele.delay( delay );
    }

    ele.animate( {
      css: css
    }, {
      duration: duration,
      easing: ele.pstyle( 'transition-timing-function' ).value,
      queue: false,
      complete: function(){
        if( !isBypass ){
          self.removeBypasses( ele, props );
        }

        _p.transitioning = false;
      }
    } );

  } else if( _p.transitioning ){
    ele.stop();

    this.removeBypasses( ele, props );

    _p.transitioning = false;
  }
};

styfn.checkZOrderTrigger = function( ele, name, fromValue, toValue ){
  var prop = this.properties[ name ];

  if( prop.triggersZOrder && ( fromValue == null || prop.triggersZOrder( fromValue, toValue ) ) ){
    this._private.cy.notify({
      type: 'zorder',
      eles: ele
    });
  }
};

module.exports = styfn;

},{"../is":86,"../util":103}],92:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function( eles, name, value, updateTransitions ){
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if( name === '*' || name === '**' ){ // apply to all property names

    if( value !== undefined ){
      for( var i = 0; i < self.properties.length; i++ ){
        var prop = self.properties[ i ];
        var name = prop.name;

        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }

  } else if( is.string( name ) ){ // then parse the single property
    var parsedProp = this.parse( name, value, true );

    if( parsedProp ){
      props.push( parsedProp );
    }
  } else if( is.plainObject( name ) ){ // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var name = prop.name;
      var value = specifiedProps[ name ];

      if( value === undefined ){ // try camel case name too
        value = specifiedProps[ util.dash2camel( name ) ];
      }

      if( value !== undefined ){
        var parsedProp = this.parse( name, value, true );

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }
  } else { // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if( props.length === 0 ){ return false; }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[ i ];
    var diffProps = {};
    var diffProp;

    for( var j = 0; j < props.length; j++ ){ // for each prop
      var prop = props[ j ];

      if( updateTransitions ){
        var prevProp = ele.pstyle( prop.name );
        diffProp = diffProps[ prop.name ] = { prev: prevProp };
      }

      ret = this.applyParsedProperty( ele, prop ) || ret;

      if( updateTransitions ){
        diffProp.next = ele.pstyle( prop.name );
      }

    } // for props

    if( ret ){
      this.updateStyleHints( ele );
    }

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function( eles, name, value ){
  name = util.camel2dash( name );

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[ i ];
    var prop = ele._private.style[ name ];
    var type = this.properties[ name ].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if( !prop || !prop.bypass ){ // need a bypass if one doesn't exist
      this.applyBypass( ele, name, value );
      continue;
    }

    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

    prop.value = value;

    if( prop.pfValue != null ){
      prop.pfValue = value;
    }

    if( isColor ){
      prop.strValue = 'rgb(' + value.join( ',' ) + ')';
    } else if( isMulti ){
      prop.strValue = value.join( ' ' );
    } else {
      prop.strValue = '' + value;
    }

    this.checkZOrderTrigger( ele, name, oldValue, value );
  }
};

styfn.removeAllBypasses = function( eles, updateTransitions ){
  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
};

styfn.removeBypasses = function( eles, props, updateTransitions ){
  var isBypass = true;

  for( var j = 0; j < eles.length; j++ ){
    var ele = eles[ j ];
    var diffProps = {};

    for( var i = 0; i < props.length; i++ ){
      var name = props[ i ];
      var prop = this.properties[ name ];
      var prevProp = ele.pstyle( prop.name );

      if( !prevProp || !prevProp.bypass ){
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass
      var parsedProp = this.parse( name, value, true );
      var diffProp = diffProps[ prop.name ] = { prev: prevProp };

      this.applyParsedProperty( ele, parsedProp );

      diffProp.next = ele.pstyle( prop.name );
    } // for props

    this.updateStyleHints( ele );

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles
};

module.exports = styfn;

},{"../is":86,"../util":103}],93:[function(require,module,exports){
'use strict';

var window = require( '../window' );

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function(){
  var px = this.containerCss( 'font-size' );

  if( px != null ){
    return parseFloat( px );
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function( propName ){
  var cy = this._private.cy;
  var domElement = cy.container();

  if( window && domElement && window.getComputedStyle ){
    return window.getComputedStyle( domElement ).getPropertyValue( propName );
  }
};

module.exports = styfn;

},{"../window":110}],94:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function( ele, prop ){
  if( prop ){
    return this.getStylePropertyValue( ele, prop, true );
  } else {
    return this.getRawStyle( ele, true );
  }
};

// gets the raw style for an element
styfn.getRawStyle = function( ele, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var rstyle = {};

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );

      if( val != null ){
        rstyle[ prop.name ] = val;
        rstyle[ util.dash2camel( prop.name ) ] = val;
      }
    }

    return rstyle;
  }
};

styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var prop = self.properties[ propName ];

    if( prop.alias ){
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle( prop.name );
    var zoom = ele.cy().zoom();

    if( styleProp ){
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat( styleProp.pfValue ).map( function( pfValue ){
        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
      } ).join( ' ' ) : styleProp.strValue;

      return val;
    }
  }
};

styfn.getAnimationStartStyle = function( ele, aniProps ){
  var rstyle = {};

  for( var i = 0; i < aniProps.length; i++ ){
    var aniProp = aniProps[ i ];
    var name = aniProp.name;

    var styleProp = ele.pstyle( name );

    if( styleProp !== undefined ){ // then make a prop of it
      if( is.plainObject( styleProp ) ){
        styleProp = this.parse( name, styleProp.strValue );
      } else {
        styleProp = this.parse( name, styleProp );
      }
    }

    if( styleProp ){
      rstyle[ name ] = styleProp;
    }
  }

  return rstyle;
};

styfn.getPropsList = function( propsObj ){
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if( style ){
    var names = Object.keys( style );

    for( var i = 0; i < names.length; i++ ){
      var name = names[i];
      var val = style[ name ];
      var prop = props[ name ] || props[ util.camel2dash( name ) ];
      var styleProp = this.parse( prop.name, val );

      rstyle.push( styleProp );
    }
  }

  return rstyle;
};

module.exports = styfn;

},{"../is":86,"../util":103}],95:[function(require,module,exports){
'use strict';

var is = require( '../is' );
var util = require( '../util' );
var Selector = require( '../selector' );

var Style = function( cy ){

  if( !(this instanceof Style) ){
    return new Style( cy );
  }

  if( !is.core( cy ) ){
    util.error( 'A style must have a core reference' );
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };

  this.length = 0;

  this.resetToDefault();
};

var styfn = Style.prototype;

styfn.instanceString = function(){
  return 'style';
};

// remove all contexts
styfn.clear = function(){
  for( var i = 0; i < this.length; i++ ){
    this[ i ] = undefined;
  }
  this.length = 0;

  var _p = this._private;

  _p.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function(){
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function(){
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function( selectorStr ){
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );

  var i = this.length++; // new context means new index
  this[ i ] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function(){
  var self = this;
  var args = arguments;

  switch( args.length ){
  case 1:
    var map = args[0];

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[ i ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        this.cssRule( prop.name, mapVal );
      }
    }

    break;

  case 2:
    this.cssRule( args[0], args[1] );
    break;

  default:
    break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function( name, value ){
  // name-value pair
  var property = this.parse( name, value );

  // add property to current context if valid
  if( property ){
    var i = this.length - 1;
    this[ i ].properties.push( property );
    this[ i ].properties[ property.name ] = property; // allow access by name as well

    if( property.name.match( /pie-(\d+)-background-size/ ) && property.value ){
      this._private.hasPie = true;
    }

    if( property.mapped ){
      this[ i ].mappedProperties.push( property );
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[ i ].selector;
    if( currentSelectorIsCore ){
      this._private.coreStyle[ property.name ] = property;
    }
  }

  return this; // chaining
};

// static function
Style.fromJson = function( cy, json ){
  var style = new Style( cy );

  style.fromJson( json );

  return style;
};

Style.fromString = function( cy, string ){
  return new Style( cy ).fromString( string );
};

[
  require( './apply' ),
  require( './bypass' ),
  require( './container' ),
  require( './get-for-ele' ),
  require( './json' ),
  require( './string-sheet' ),
  require( './properties' ),
  require( './parse' )
].forEach( function( props ){
  util.extend( styfn, props );
} );


Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

},{"../is":86,"../selector":90,"../util":103,"./apply":91,"./bypass":92,"./container":93,"./get-for-ele":94,"./json":96,"./parse":97,"./properties":98,"./string-sheet":99}],96:[function(require,module,exports){
'use strict';

var styfn = {};

styfn.applyFromJson = function( json ){
  var style = this;

  for( var i = 0; i < json.length; i++ ){
    var context = json[ i ];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys( props );

    style.selector( selector ); // apply selector

    for( var j = 0; j < names.length; j++ ){
      var name = names[j];
      var value = props[ name ];

      style.css( name, value ); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function( json ){
  var style = this;

  style.resetToDefault();
  style.applyFromJson( json );

  return style;
};

// get json from cy.style() api
styfn.json = function(){
  var json = [];

  for( var i = this.defaultLength; i < this.length; i++ ){
    var cxt = this[ i ];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];
      css[ prop.name ] = prop.strValue;
    }

    json.push( {
      selector: !selector ? 'core' : selector.toString(),
      style: css
    } );
  }

  return json;
};

module.exports = styfn;

},{}],97:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );
var math = require( '../math' );

var styfn = {};

// a caching layer for property parsing
styfn.parse = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  if( is.fn( value ) ){
    return self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  var flatKey = ( propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ) ? 'dontcare' : propIsFlat;
  var argHash = [ name, value, propIsBypass, flatKey ].join( '$' );
  var propCache = self.propCache = self.propCache || {};
  var ret;

  if( !(ret = propCache[ argHash ]) ){
    ret = propCache[ argHash ] = self.parseImplWarn( name, value, propIsBypass, propIsFlat );
  }

  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element
  if( propIsBypass || propIsFlat === 'mapping' ){
    // need a copy since props are mutated later in their lifecycles
    ret = util.copy( ret );

    if( ret ){
      ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn.parseImplWarn = function( name, value, propIsBypass, propIsFlat ){
  var prop = this.parseImpl( name, value, propIsBypass, propIsFlat );

  if( !prop && value != null ){
    util.error('The style property `%s: %s` is invalid', name, value);
  }

  return prop;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn.parseImpl = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[ name ];
  var passedValue = value;
  var types = self.types;

  if( !property ){ return null; } // return null on property of unknown name
  if( value === undefined || value === null ){ return null; } // can't assign null

  // the property may be an alias
  if( property.alias ){
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string( value );
  if( valueIsString ){ // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if( !type ){ return null; } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if( propIsBypass && (value === '' || value === null) ){
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if( is.fn( value ) ){
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
  if( !valueIsString || propIsFlat ){
    // then don't bother to do the expensive regex checks

  } else if(
    ( data = new RegExp( types.data.regex ).exec( value ) ) ||
    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass

    var mapped;
    if( data ){
      mapped = types.data;
    } else if( layoutData ){
      mapped = types.layoutData;
    } else {
      mapped = types.scratch;
    }

    data = data || layoutData || scratch;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };

  } else if(
    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass
    if( type.multiple ){ return false; } // impossible to map to num

    var mapped;
    if( mapData ){
      mapped = types.mapData;
    } else if( mapLayoutData ){
      mapped = types.mapLayoutData;
    } else {
      mapped = types.mapScratch;
    }

    mapData = mapData || mapLayoutData || mapScratch;

    // we can map only if the type is a colour or a number
    if( !(type.color || type.number) ){ return false; }

    var valueMin = this.parse( name, mapData[4] ); // parse to validate
    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

    var valueMax = this.parse( name, mapData[5] ); // parse to validate
    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if( valueMin.value === valueMax.value ){
      return false; // can't make much of a mapper without a range

    } else if( type.color ){
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
        && c1[1] === c2[1] // green
        && c1[2] === c2[2] // blue
        && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (
            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
            &&
            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          )
        )
      ;

      if( same ){ return false; } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: mapped,
      field: mapData[1],
      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
      fieldMax: parseFloat( mapData[3] ),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if( type.multiple && propIsFlat !== 'multiple' ){
    var vals;

    if( valueIsString ){
      vals = value.split( /\s+/ );
    } else if( is.array( value ) ){
      vals = value;
    } else {
      vals = [ value ];
    }

    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var hasEnum = false;

    for( var i = 0; i < vals.length; i++ ){
      var p = self.parse( name, vals[i], propIsBypass, 'multiple' );

      hasEnum = hasEnum || is.string( p.value );

      valArr.push( p.value );
      pfValArr.push( p.pfValue != null ? p.pfValue : p.value );
      unitsArr.push( p.units );
    }

    if( type.validate && !type.validate( valArr, unitsArr ) ){
      return null;
    }

    if( type.singleEnum && hasEnum ){
      if( valArr.length === 1 && is.string( valArr[0] ) ){
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: valArr.join( ' ' ),
      bypass: propIsBypass,
      units: unitsArr
    };
  }

  // several types also allow enums
  var checkEnums = function(){
    for( var i = 0; i < type.enums.length; i++ ){
      var en = type.enums[ i ];

      if( en === value ){
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if( type.number ){
    var units;
    var implicitUnits = 'px'; // not set => px

    if( type.units ){ // use specified units if set
      units = type.units;
    }

    if( type.implicitUnits ){
      implicitUnits = type.implicitUnits;
    }

    if( !type.unitless ){
      if( valueIsString ){
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if( units ){ unitsRegex = units; } // only allow explicit units if so set
        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );

        if( match ){
          value = match[1];
          units = match[2] || implicitUnits;
        }

      } else if( !units || type.implicitUnits ){
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat( value );

    // if not a number and enums not allowed, then the value is invalid
    if( isNaN( value ) && type.enums === undefined ){
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if( isNaN( value ) && type.enums !== undefined ){
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if( type.integer && !is.integer( value ) ){
      return null;
    }

    // check value is within range
    if( ( type.min !== undefined && ( value < type.min || (type.strictMin && value === type.min) ) )
    ||  ( type.max !== undefined && ( value > type.max || (type.strictMax && value === type.max) ) )
    ){
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if( type.unitless || (units !== 'px' && units !== 'em') ){
      ret.pfValue = value;
    } else {
      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
    }

    // normalise value in ms
    if( units === 'ms' || units === 's' ){
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if( units === 'deg' || units === 'rad' ){
      ret.pfValue = units === 'rad' ? value : math.deg2rad( value );
    }

    // normalize value in %
    if( units === '%' ){
      ret.pfValue = value / 100;
    }

    return ret;

  } else if( type.propList ){

    var props = [];
    var propsStr = '' + value;

    if( propsStr === 'none' ){
      // leave empty

    } else { // go over each prop

      var propsSplit = propsStr.split( ',' );
      for( var i = 0; i < propsSplit.length; i++ ){
        var propName = propsSplit[ i ].trim();

        if( self.properties[ propName ] ){
          props.push( propName );
        }
      }

      if( props.length === 0 ){ return null; }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join( ', ' ),
      bypass: propIsBypass
    };

  } else if( type.color ){
    var tuple = util.color2tuple( value );

    if( !tuple ){ return null; }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: '' + value,
      bypass: propIsBypass,
      roundValue: true
    };

  } else if( type.regex || type.regexes ){

    // first check enums
    if( type.enums ){
      var enumProp = checkEnums();

      if( enumProp ){ return enumProp; }
    }

    var regexes = type.regexes ? type.regexes : [ type.regex ];

    for( var i = 0; i < regexes.length; i++ ){
      var regex = new RegExp( regexes[ i ] ); // make a regex from the type string
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };

      }
    }

    return null; // didn't match any

  } else if( type.string ){
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };

  } else if( type.enums ){ // check enums last because it's a combo type in others
    return checkEnums();

  } else {
    return null; // not a type we can handle
  }

};

module.exports = styfn;

},{"../is":86,"../math":88,"../util":103}],98:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var is = require( '../is' );

var styfn = {};

(function(){
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
  var mapData = function( prefix ){
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: [ 'parent', 'origin' ] },
    nodeSize: { number: true, min: 0, enums: [ 'label' ] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    sizeMaybePercent: { number: true, min: 0, allowPercent: true },
    bgWH: { number: true, min: 0, allowPercent: true, enums: [ 'auto' ] },
    bgPos: { number: true, allowPercent: true },
    bgRepeat: { enums: [ 'repeat', 'repeat-x', 'repeat-y', 'no-repeat' ] },
    bgFit: { enums: [ 'none', 'contain', 'cover' ] },
    bgCrossOrigin: { enums: [ 'anonymous', 'use-credentials' ] },
    bgClip: { enums: [ 'none', 'node' ] },
    color: { color: true },
    bool: { enums: [ 'yes', 'no' ] },
    lineStyle: { enums: [ 'solid', 'dotted', 'dashed' ] },
    borderStyle: { enums: [ 'solid', 'dotted', 'dashed', 'double' ] },
    curveStyle: { enums: [ 'bezier', 'unbundled-bezier', 'haystack', 'segments' ] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontVariant: { enums: [ 'small-caps', 'normal' ] },
    fontStyle: { enums: [ 'italic', 'normal', 'oblique' ] },
    fontWeight: { enums: [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900 ] },
    textDecoration: { enums: [ 'none', 'underline', 'overline', 'line-through' ] },
    textTransform: { enums: [ 'none', 'uppercase', 'lowercase' ] },
    textWrap: { enums: [ 'none', 'wrap', 'ellipsis' ] },
    textBackgroundShape: { enums: [ 'rectangle', 'roundrectangle' ]},
    nodeShape: { enums: [ 'rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon' ] },
    compoundIncludeLabels: { enums: [ 'include', 'exclude' ] },
    arrowShape: { enums: [ 'tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none' ] },
    arrowFill: { enums: [ 'filled', 'hollow' ] },
    display: { enums: [ 'element', 'none' ] },
    visibility: { enums: [ 'hidden', 'visible' ] },
    zCompoundDepth: { enums: [ 'bottom', 'orphan', 'auto', 'top' ] },
    zIndexCompare: { enums: [ 'auto', 'manual' ] },
    valign: { enums: [ 'top', 'center', 'bottom' ] },
    halign: { enums: [ 'left', 'center', 'right' ] },
    text: { string: true },
    data: { mapping: true, regex: data( 'data' ) },
    layoutData: { mapping: true, regex: data( 'layoutData' ) },
    scratch: { mapping: true, regex: data( 'scratch' ) },
    mapData: { mapping: true, regex: mapData( 'mapData' ) },
    mapLayoutData: { mapping: true, regex: mapData( 'mapLayoutData' ) },
    mapScratch: { mapping: true, regex: mapData( 'mapScratch' ) },
    fn: { mapping: true, fn: true },
    url: { regex: 'url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)|none|(.+)$' },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: [ 'none', 'autorotate' ] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    edgeDistances: { enums: ['intersection', 'node-position'] },
    edgeEndpoint: {
      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
      enums: [ 'inside-to-node', 'outside-to-node', 'outside-to-line' ], singleEnum: true,
      validate: function( valArr, unitsArr ){
        switch( valArr.length ){
          case 2: // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
          case 1: // can be enum, deg, or rad only
            return is.string( valArr[0] ) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
          default:
            return false;
        }
      }
    },
    easing: {
      regexes: [
        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
      ],
      enums: [
        'linear',
        'ease', 'ease-in', 'ease-out', 'ease-in-out',
        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
      ]
    }
  };

  var zOrderDiff = {
    zeroNonZero: function( val1, val2 ){
      if( val1 === 0 && val2 !== 0 ){
        return true;
      } else if( val1 !== 0 && val2 === 0 ){
        return true;
      } else {
        return false;
      }
    },
    anyDiff: function( val1, val2 ){
      return val1 !== val2;
    }
  };

  var zd = zOrderDiff;

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
    // main label
    { name: 'label', type: t.text },
    { name: 'text-rotation', type: t.textRotation },
    { name: 'text-margin-x', type: t.bidirectionalSize },
    { name: 'text-margin-y', type: t.bidirectionalSize },

    // source label
    { name: 'source-label', type: t.text },
    { name: 'source-text-rotation', type: t.textRotation },
    { name: 'source-text-margin-x', type: t.bidirectionalSize },
    { name: 'source-text-margin-y', type: t.bidirectionalSize },
    { name: 'source-text-offset', type: t.size },

    // target label
    { name: 'target-label', type: t.text },
    { name: 'target-text-rotation', type: t.textRotation },
    { name: 'target-text-margin-x', type: t.bidirectionalSize },
    { name: 'target-text-margin-y', type: t.bidirectionalSize },
    { name: 'target-text-offset', type: t.size },

    // common label style
    { name: 'text-valign', type: t.valign },
    { name: 'text-halign', type: t.halign },
    { name: 'color', type: t.color },
    { name: 'text-outline-color', type: t.color },
    { name: 'text-outline-width', type: t.size },
    { name: 'text-outline-opacity', type: t.zeroOneNumber },
    { name: 'text-opacity', type: t.zeroOneNumber },
    { name: 'text-background-color', type: t.color },
    { name: 'text-background-opacity', type: t.zeroOneNumber },
    { name: 'text-background-padding', type: t.size },
    { name: 'text-border-opacity', type: t.zeroOneNumber },
    { name: 'text-border-color', type: t.color },
    { name: 'text-border-width', type: t.size },
    { name: 'text-border-style', type: t.borderStyle },
    { name: 'text-background-shape', type: t.textBackgroundShape},
    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
    { name: 'text-transform', type: t.textTransform },
    { name: 'text-wrap', type: t.textWrap },
    { name: 'text-max-width', type: t.size },
    { name: 'text-events', type: t.bool },
    { name: 'font-family', type: t.fontFamily },
    { name: 'font-style', type: t.fontStyle },
    // { name: 'font-variant', type: t.fontVariant }, // not useful
    { name: 'font-weight', type: t.fontWeight },
    { name: 'font-size', type: t.size },
    { name: 'min-zoomed-font-size', type: t.size },

    // behaviour
    { name: 'events', type: t.bool },

    // visibility
    { name: 'display', type: t.display, triggersZOrder: zd.anyDiff },
    { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff },
    { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero },
    { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff },
    { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff },
    { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

    // overlays
    { name: 'overlay-padding', type: t.size },
    { name: 'overlay-color', type: t.color },
    { name: 'overlay-opacity', type: t.zeroOneNumber },

    // shadows
    { name: 'shadow-blur', type: t.size },
    { name: 'shadow-color', type: t.color },
    { name: 'shadow-opacity', type: t.zeroOneNumber },
    { name: 'shadow-offset-x', type: t.bidirectionalSize },
    { name: 'shadow-offset-y', type: t.bidirectionalSize },

    // label shadows
    { name: 'text-shadow-blur', type: t.size },
    { name: 'text-shadow-color', type: t.color },
    { name: 'text-shadow-opacity', type: t.zeroOneNumber },
    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },
    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },

    // transition anis
    { name: 'transition-property', type: t.propList },
    { name: 'transition-duration', type: t.time },
    { name: 'transition-delay', type: t.time },
    { name: 'transition-timing-function', type: t.easing },

    // node body
    { name: 'height', type: t.nodeSize },
    { name: 'width', type: t.nodeSize },
    { name: 'shape', type: t.nodeShape },
    { name: 'shape-polygon-points', type: t.polygonPointList },
    { name: 'background-color', type: t.color },
    { name: 'background-opacity', type: t.zeroOneNumber },
    { name: 'background-blacken', type: t.nOneOneNumber },
    { name: 'padding', type: t.size },

    // node border
    { name: 'border-color', type: t.color },
    { name: 'border-opacity', type: t.zeroOneNumber },
    { name: 'border-width', type: t.size },
    { name: 'border-style', type: t.borderStyle },

    // node background images
    { name: 'background-image', type: t.url },
    { name: 'background-image-crossorigin', type: t.bgCrossOrigin },
    { name: 'background-image-opacity', type: t.zeroOneNumber },
    { name: 'background-position-x', type: t.bgPos },
    { name: 'background-position-y', type: t.bgPos },
    { name: 'background-repeat', type: t.bgRepeat },
    { name: 'background-fit', type: t.bgFit },
    { name: 'background-clip', type: t.bgClip },
    { name: 'background-width', type: t.bgWH },
    { name: 'background-height', type: t.bgWH },

    // compound props
    { name: 'position', type: t.position },
    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },
    { name: 'min-width', type: t.size },
    { name: 'min-width-bias-left', type: t.sizeMaybePercent },
    { name: 'min-width-bias-right', type: t.sizeMaybePercent },
    { name: 'min-height', type: t.size },
    { name: 'min-height-bias-top', type: t.sizeMaybePercent },
    { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

    // edge line
    { name: 'line-style', type: t.lineStyle },
    { name: 'line-color', type: t.color },
    { name: 'curve-style', type: t.curveStyle },
    { name: 'haystack-radius', type: t.zeroOneNumber },
    { name: 'source-endpoint', type: t.edgeEndpoint },
    { name: 'target-endpoint', type: t.edgeEndpoint },
    { name: 'control-point-step-size', type: t.size },
    { name: 'control-point-distances', type: t.bidirectionalSizes },
    { name: 'control-point-weights', type: t.numbers },
    { name: 'segment-distances', type: t.bidirectionalSizes },
    { name: 'segment-weights', type: t.numbers },
    { name: 'edge-distances', type: t.edgeDistances },
    { name: 'arrow-scale', type: t.positiveNumber },
    { name: 'loop-direction', type: t.angle },
    { name: 'loop-sweep', type: t.angle },
    { name: 'source-distance-from-node', type: t.size },
    { name: 'target-distance-from-node', type: t.size },

    // these are just for the core
    { name: 'selection-box-color', type: t.color },
    { name: 'selection-box-opacity', type: t.zeroOneNumber },
    { name: 'selection-box-border-color', type: t.color },
    { name: 'selection-box-border-width', type: t.size },
    { name: 'active-bg-color', type: t.color },
    { name: 'active-bg-opacity', type: t.zeroOneNumber },
    { name: 'active-bg-size', type: t.size },
    { name: 'outside-texture-bg-color', type: t.color },
    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
  ];

  // define aliases
  var aliases = styfn.aliases = [
    { name: 'content', pointsTo: 'label' },
    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
    { name: 'control-point-weight', pointsTo: 'control-point-weights' },
    { name: 'edge-text-rotation', pointsTo: 'text-rotation' },
    { name: 'padding-left', pointsTo: 'padding' },
    { name: 'padding-right', pointsTo: 'padding' },
    { name: 'padding-top', pointsTo: 'padding' },
    { name: 'padding-bottom', pointsTo: 'padding' }
  ];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push( { name: 'pie-size', type: t.sizeMaybePercent } );
  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
    props.push( { name: 'pie-' + i + '-background-color', type: t.color } );
    props.push( { name: 'pie-' + i + '-background-size', type: t.percent } );
    props.push( { name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber } );
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = [ 'source', 'mid-source', 'target', 'mid-target' ];
  [
    { name: 'arrow-shape', type: t.arrowShape },
    { name: 'arrow-color', type: t.color },
    { name: 'arrow-fill', type: t.arrowFill }
  ].forEach( function( prop ){
    arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push( { name: name, type: type } );
    } );
  }, {} );

  // list of property names
  styfn.propertyNames = props.map( function( p ){ return p.name; } );

  // allow access of properties by name ( e.g. style.properties.height )
  for( var i = 0; i < props.length; i++ ){
    var prop = props[ i ];

    props[ prop.name ] = prop; // allow lookup by name
  }

  // map aliases
  for( var i = 0; i < aliases.length; i++ ){
    var alias = aliases[ i ];
    var pointsToProp = props[ alias.pointsTo ];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push( aliasProp );

    props[ alias.name ] = aliasProp; // allow lookup by name
  }
})();

styfn.getDefaultProperty = function( name ){
  return this.getDefaultProperties()[ name ];
};

styfn.getDefaultProperties = util.memoize( function(){
  var rawProps = util.extend( {
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    // 'font-variant': fontVariant,
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'shadow-opacity': 0,
    'shadow-color': '#000',
    'shadow-blur': 10,
    'shadow-offset-x': 0,
    'shadow-offset-y': 0,
    'text-shadow-opacity': 0,
    'text-shadow-color': '#000',
    'text-shadow-blur': 5,
    'text-shadow-offset-x': 0,
    'text-shadow-offset-y': 0,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',

    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

    // compound props
    'padding': 0,
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [
    { name: 'pie-{{i}}-background-color', value: 'black' },
    { name: 'pie-{{i}}-background-size', value: '0%' },
    { name: 'pie-{{i}}-background-opacity', value: 1 }
  ].reduce( function( css, prop ){
    for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
      var name = prop.name.replace( '{{i}}', i );
      var val = prop.value;

      css[ name ] = val;
    }

    return css;
  }, {} ), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'edge-distances': 'intersection',
    'curve-style': 'bezier',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-135deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node'
  }, [
    { name: 'arrow-shape', value: 'none' },
    { name: 'arrow-color', value: '#999' },
    { name: 'arrow-fill', value: 'filled' }
  ].reduce( function( css, prop ){
    styfn.arrowPrefixes.forEach( function( prefix ){
      var name = prefix + '-' + prop.name;
      var val = prop.value;

      css[ name ] = val;
    } );

    return css;
  }, {} ) );

  var parsedProps = {};

  for( var i = 0; i < this.properties.length; i++ ){
    var prop = this.properties[i];

    if( prop.pointsTo ){ continue; }

    var name = prop.name;
    var val = rawProps[ name ];
    var parsedProp = this.parse( name, val );

    parsedProps[ name ] = parsedProp;
  }

  return parsedProps;
} );

styfn.addDefaultStylesheet = function(){
  this
    .selector( '$node > node' ) // compound (parent) node properties
      .css( {
        'shape': 'rectangle',
        'padding': 10,
        'background-color': '#eee',
        'border-color': '#ccc',
        'border-width': 1
      } )
    .selector( 'edge' ) // just edge properties
      .css( {
        'width': 3,
        'curve-style': 'haystack'
      } )
    .selector( ':selected' )
      .css( {
        'background-color': '#0169D9',
        'line-color': '#0169D9',
        'source-arrow-color': '#0169D9',
        'target-arrow-color': '#0169D9',
        'mid-source-arrow-color': '#0169D9',
        'mid-target-arrow-color': '#0169D9'
      } )
    .selector( 'node:parent:selected' )
      .css( {
        'background-color': '#CCE1F9',
        'border-color': '#aec8e5'
      } )
    .selector( ':active' )
      .css( {
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      } )
    .selector( 'core' ) // just core properties
      .css( {
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125
      } )
  ;

  this.defaultLength = this.length;
};

module.exports = styfn;

},{"../is":86,"../util":103}],99:[function(require,module,exports){
'use strict';

var util = require( '../util' );
var Selector = require( '../selector' );

var styfn = {};

styfn.applyFromString = function( string ){
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;

  // remove comments from the style string
  remaining = remaining.replace( /[/][*](\s|.)+?[*][/]/g, '' );

  function removeSelAndBlockFromRemaining(){
    // remove the parsed selector and block from the remaining text to parse
    if( remaining.length > selAndBlockStr.length ){
      remaining = remaining.substr( selAndBlockStr.length );
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem(){
    // remove the parsed property and value from the remaining block text to parse
    if( blockRem.length > propAndValStr.length ){
      blockRem = blockRem.substr( propAndValStr.length );
    } else {
      blockRem = '';
    }
  }

  while( true ){
    var nothingLeftToParse = remaining.match( /^\s*$/ );
    if( nothingLeftToParse ){ break; }

    var selAndBlock = remaining.match( /^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/ );

    if( !selAndBlock ){
      util.error( 'Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining );
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if( selectorStr !== 'core' ){
      var selector = new Selector( selectorStr );
      if( selector._private.invalid ){
        util.error( 'Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr );

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while( true ){
      var nothingLeftToParse = blockRem.match( /^\s*$/ );
      if( nothingLeftToParse ){ break; }

      var propAndVal = blockRem.match( /^\s*(.+?)\s*:\s*(.+?)\s*;/ );

      if( !propAndVal ){
        util.error( 'Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr );
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[ propStr ];
      if( !prop ){
        util.error( 'Skipping property: Invalid property name in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse( propStr, valStr );

      if( !parsedProp ){
        util.error( 'Skipping property: Invalid property definition in: ' + propAndValStr );

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push( {
        name: propStr,
        val: valStr
      } );
      removePropAndValFromRem();
    }

    if( invalidBlock ){
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector( selectorStr );
    for( var i = 0; i < props.length; i++ ){
      var prop = props[ i ];
      style.css( prop.name, prop.val );
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function( string ){
  var style = this;

  style.resetToDefault();
  style.applyFromString( string );

  return style;
};

module.exports = styfn;

},{"../selector":90,"../util":103}],100:[function(require,module,exports){
'use strict';

var is = require( './is' );
var util = require( './util' );
var Style = require( './style' );

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function(){
  if( !(this instanceof Stylesheet) ){
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function(){
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function( selector ){
  var i = this.length++;

  this[ i ] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function( name, value ){
  var i = this.length - 1;

  if( is.string( name ) ){
    this[ i ].properties.push( {
      name: name,
      value: value
    } );
  } else if( is.plainObject( name ) ){
    var map = name;

    for( var j = 0; j < Style.properties.length; j++ ){
      var prop = Style.properties[ j ];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){ // also try camel case name
        mapVal = map[ util.dash2camel( prop.name ) ];
      }

      if( mapVal !== undefined ){
        var name = prop.name;
        var value = mapVal;

        this[ i ].properties.push( {
          name: name,
          value: value
        } );
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function( cy ){
  var style = new Style( cy );

  for( var i = 0; i < this.length; i++ ){
    var context = this[ i ];
    var selector = context.selector;
    var props = context.properties;

    style.selector( selector ); // apply selector

    for( var j = 0; j < props.length; j++ ){
      var prop = props[ j ];

      style.css( prop.name, prop.value ); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

},{"./is":86,"./style":95,"./util":103}],101:[function(require,module,exports){
(function (__dirname){
/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */

// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

'use strict';

var window = require('./window');
var util = require('./util');
var Promise = require('./promise');
var Event = require('./event');
var define = require('./define');
var is = require('./is');

var Thread = function( opts ){
  if( !(this instanceof Thread) ){
    return new Thread( opts );
  }

  var _p = this._private = {
    requires: [],
    files: [],
    queue: null,
    pass: [],
    disabled: false
  };

  if( is.plainObject(opts) ){
    if( opts.disabled != null ){
      _p.disabled = !!opts.disabled;
    }
  }

};

var thdfn = Thread.prototype; // short alias

var stringifyFieldVal = function( val ){
  var valStr = is.fn( val ) ? val.toString() : "JSON.parse('" + JSON.stringify(val) + "')";

  return valStr;
};

// allows for requires with prototypes and subobjs etc
var fnAsRequire = function( fn ){
  var req;
  var fnName;

  if( is.object(fn) && fn.fn ){ // manual fn
    req = fnAs( fn.fn, fn.name );
    fnName = fn.name;
    fn = fn.fn;
  } else if( is.fn(fn) ){ // auto fn
    req = fn.toString();
    fnName = fn.name;
  } else if( is.string(fn) ){ // stringified fn
    req = fn;
  } else if( is.object(fn) ){ // plain object
    if( fn.proto ){
      req = '';
    } else {
      req = fn.name + ' = {};';
    }

    fnName = fn.name;
    fn = fn.obj;
  }

  req += '\n';

  var protoreq = function( val, subname ){
    if( val.prototype ){
      var protoNonempty = false;
      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line

      if( protoNonempty ){
        req += fnAsRequire( {
          name: subname,
          obj: val,
          proto: true
        }, val );
      }
    }
  };

  // pull in prototype
  if( fn.prototype && fnName != null ){

    for( var name in fn.prototype ){
      var protoStr = '';

      var val = fn.prototype[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '.prototype.' + name;

      protoStr += subname + ' = ' + valStr + ';\n';

      if( protoStr ){
        req += protoStr;
      }

      protoreq( val, subname ); // subobject with prototype
    }

  }

  // pull in properties for obj/fns
  if( !is.string(fn) ){ for( var name in fn ){
    var propsStr = '';

    if( fn.hasOwnProperty(name) ){
      var val = fn[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '["' + name + '"]';

      propsStr += subname + ' = ' + valStr + ';\n';
    }

    if( propsStr ){
      req += propsStr;
    }

    protoreq( val, subname ); // subobject with prototype
  } }

  return req;
};

var isPathStr = function( str ){
  return is.string(str) && str.match(/\.js$/);
};

util.extend(thdfn, {

  instanceString: function(){ return 'thread'; },

  require: function( fn, as ){
    var requires = this._private.requires;

    if( isPathStr(fn) ){
      this._private.files.push( fn );

      return this;
    }

    if( as ){
      if( is.fn(fn) ){
        fn = { name: as, fn: fn };
      } else {
        fn = { name: as, obj: fn };
      }
    } else {
      if( is.fn(fn) ){
        if( !fn.name ){
          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, "someFunction" )';
        }

        fn = { name: fn.name, fn: fn };
      }
    }

    requires.push( fn );

    return this; // chaining
  },

  pass: function( data ){
    this._private.pass.push( data );

    return this; // chaining
  },

  run: function( fn, pass ){ // fn used like main()
    var self = this;
    var _p = this._private;
    pass = pass || _p.pass.shift();

    if( _p.stopped ){
      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';
    }

    if( _p.running ){
      return ( _p.queue = _p.queue.then(function(){ // inductive step
        return self.run( fn, pass );
      }) );
    }

    var useWW = window != null && !_p.disabled;
    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;

    self.trigger('run');

    var runP = new Promise(function( resolve, reject ){

      _p.running = true;

      var threadTechAlreadyExists = _p.ran;

      var fnImplStr = is.string( fn ) ? fn : fn.toString();

      // worker code to exec
      var fnStr = '\n' + ( _p.requires.map(function( r ){
        return fnAsRequire( r );
      }) ).concat( _p.files.map(function( f ){
        if( useWW ){
          var wwifyFile = function( file ){
            if( file.match(/^\.\//) || file.match(/^\.\./) ){
              return window.location.origin + window.location.pathname + file;
            } else if( file.match(/^\//) ){
              return window.location.origin + '/' + file;
            }
            return file;
          };

          return 'importScripts("' + wwifyFile(f) + '");';
        } else if( useNode ) {
          return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
        } else {
          throw 'External file `' + f + '` can not be required without any threading technology.';
        }
      }) ).concat([
        '( function(){',
          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
        '} )()\n'
      ]).join('\n');

      // because we've now consumed the requires, empty the list so we don't dupe on next run()
      _p.requires = [];
      _p.files = [];

      if( useWW ){
        var fnBlob, fnUrl;

        // add normalised thread api functions
        if( !threadTechAlreadyExists ){
          var fnPre = fnStr + '';

          fnStr = [
            'function _ref_(o){ return eval(o); };',
            'function broadcast(m){ return message(m); };', // alias
            'function message(m){ postMessage(m); };',
            'function listen(fn){',
            '  self.addEventListener("message", function(m){ ',
            '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
            '    } else { ',
            '      fn( m.data );',
            '    }',
            '  });',
            '};',
            'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
            'function resolve(v){ postMessage({ $$resolve: v }); };',
            'function reject(v){ postMessage({ $$reject: v }); };'
          ].join('\n');

          fnStr += fnPre;

          fnBlob = new Blob([ fnStr ], {
            type: 'application/javascript'
          });
          fnUrl = window.URL.createObjectURL( fnBlob );
        }
        // create webworker and let it exec the serialised code
        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

        if( threadTechAlreadyExists ){ // then just exec new run() code
          ww.postMessage({
            $$eval: fnStr
          });
        }

        // worker messages => events
        var cb;
        ww.addEventListener('message', cb = function( m ){
          var isObject = is.object(m) && is.object( m.data );

          if( isObject && ('$$resolve' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c resolve()

            resolve( m.data.$$resolve );
          } else if( isObject && ('$$reject' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c reject()

            reject( m.data.$$reject );
          } else {
            self.trigger( new Event(m, { type: 'message', message: m.data }) );
          }
        }, false);

        if( !threadTechAlreadyExists ){
          ww.postMessage('$$start'); // start up the worker
        }

      } else if( useNode ){
        // create a new process

        if( !_p.child ){
          _p.child = ( require('child_process').fork( require('path').join(__dirname, 'thread-node-fork') ) );
        }

        var child = _p.child;

        // child process messages => events
        var cb;
        child.on('message', cb = function( m ){
          if( is.object(m) && ('$$resolve' in m) ){
            child.removeListener('message', cb); // done listening b/c resolve()

            resolve( m.$$resolve );
          } else if( is.object(m) && ('$$reject' in m) ){
            child.removeListener('message', cb); // done listening b/c reject()

            reject( m.$$reject );
          } else {
            self.trigger( new Event({}, { type: 'message', message: m }) );
          }
        });

        // ask the child process to eval the worker code
        child.send({
          $$eval: fnStr
        });

      } else { // use a fallback mechanism using a timeout

        var promiseResolve = resolve;
        var promiseReject = reject;

        var timer = _p.timer = _p.timer || {

          listeners: [],

          exec: function(){
            // as a string so it can't be mangled by minifiers and processors
            fnStr = [
              'function _ref_(o){ return eval(o); };',
              'function broadcast(m){ return message(m); };',
              'function message(m){ self.trigger( new Event({}, { type: "message", message: m }) ); };',
              'function listen(fn){ timer.listeners.push( fn ); };',
              'function resolve(v){ promiseResolve(v); };',
              'function reject(v){ promiseReject(v); };'
            ].join('\n') + fnStr;

            // the .run() code
            eval( fnStr ); // jshint ignore:line
          },

          message: function( m ){
            var ls = timer.listeners;

            for( var i = 0; i < ls.length; i++ ){
              var fn = ls[i];

              fn( m );
            }
          }

        };

        timer.exec();
      }

    }).then(function( v ){
      _p.running = false;
      _p.ran = true;

      self.trigger('ran');

      return v;
    });

    if( _p.queue == null ){
      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
    }

    return runP;
  },

  // send the thread a message
  message: function( m ){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.postMessage( m );
    }

    if( _p.child ){
      _p.child.send( m );
    }

    if( _p.timer ){
      _p.timer.message( m );
    }

    return this; // chaining
  },

  stop: function(){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.terminate();
    }

    if( _p.child ){
      _p.child.kill();
    }

    if( _p.timer ){
      // nothing we can do if we've run a timeout
    }

    _p.stopped = true;

    return this.trigger('stop'); // chaining
  },

  stopped: function(){
    return this._private.stopped;
  }

});

// turns a stringified function into a (re)named function
var fnAs = function( fn, name ){
  var fnStr = fn.toString();
  fnStr = fnStr.replace(/function\s*?\S*?\s*?\(/, 'function ' + name + '(');

  return fnStr;
};

var defineFnal = function( opts ){
  opts = opts || {};

  return function fnalImpl( fn, arg1 ){
    var fnStr = fnAs( fn, '_$_$_' + opts.name );

    this.require( fnStr );

    return this.run( [
      'function( data ){',
      '  var origResolve = resolve;',
      '  var res = [];',
      '  ',
      '  resolve = function( val ){',
      '    res.push( val );',
      '  };',
      '  ',
      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
      '  ',
      '  resolve = origResolve;',
      '  resolve( res.length > 0 ? res : ret );',
      '}'
    ].join('\n') );
  };
};

util.extend(thdfn, {
  reduce: defineFnal({ name: 'reduce' }),

  reduceRight: defineFnal({ name: 'reduceRight' }),

  map: defineFnal({ name: 'map' })
});

// aliases
var fn = thdfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(thdfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( thdfn );

module.exports = Thread;

}).call(this,"/node_modules/cytoscape/src")

},{"./define":47,"./event":48,"./is":86,"./promise":89,"./util":103,"./window":110,"child_process":3,"path":114}],102:[function(require,module,exports){
'use strict';

var is = require( '../is' );

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function( hex ){
    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== '#' ){ return; }

    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;

    if( shortHex ){
      r = parseInt( hex[1] + hex[1], base );
      g = parseInt( hex[2] + hex[2], base );
      b = parseInt( hex[3] + hex[3], base );
    } else {
      r = parseInt( hex[1] + hex[2], base );
      g = parseInt( hex[3] + hex[4], base );
      b = parseInt( hex[5] + hex[6], base );
    }

    return [ r, g, b ];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function( hsl ){
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb( p, q, t ){
      if( t < 0 ) t += 1;
      if( t > 1 ) t -= 1;
      if( t < 1 / 6 ) return p + (q - p) * 6 * t;
      if( t < 1 / 2 ) return q;
      if( t < 2 / 3 ) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    var m = new RegExp( '^' + this.regex.hsla + '$' ).exec( hsl );
    if( m ){

      // get hue
      h = parseInt( m[1] );
      if( h < 0 ){
        h = ( 360 - (-1 * h % 360) ) % 360;
      } else if( h > 360 ){
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat( m[2] );
      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
      s = s / 100; // normalise on [0, 1]

      l = parseFloat( m[3] );
      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
      l = l / 100; // normalise on [0, 1]

      a = m[4];
      if( a !== undefined ){
        a = parseFloat( a );

        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if( s === 0 ){
        r = g = b = Math.round( l * 255 ); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round( 255 * hue2rgb( p, q, h + 1 / 3 ) );
        g = Math.round( 255 * hue2rgb( p, q, h ) );
        b = Math.round( 255 * hue2rgb( p, q, h - 1 / 3 ) );
      }

      ret = [ r, g, b, a ];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function( rgb ){
    var ret;

    var m = new RegExp( '^' + this.regex.rgba + '$' ).exec( rgb );
    if( m ){
      ret = [];

      var isPct = [];
      for( var i = 1; i <= 3; i++ ){
        var channel = m[ i ];

        if( channel[ channel.length - 1 ] === '%' ){
          isPct[ i ] = true;
        }
        channel = parseFloat( channel );

        if( isPct[ i ] ){
          channel = channel / 100 * 255; // normalise to [0, 255]
        }

        if( channel < 0 || channel > 255 ){ return; } // invalid channel value

        ret.push( Math.floor( channel ) );
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

      var alpha = m[4];
      if( alpha !== undefined ){
        alpha = parseFloat( alpha );

        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

        ret.push( alpha );
      }
    }

    return ret;
  },

  colorname2tuple: function( color ){
    return this.colors[ color.toLowerCase() ];
  },

  color2tuple: function( color ){
    return ( is.array( color ) ? color : null )
      || this.colorname2tuple( color )
      || this.hex2tuple( color )
      || this.rgb2tuple( color )
      || this.hsl2tuple( color );
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [ 240, 248, 255 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [0, 0, 0],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 135 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    cyan: [0, 255, 255 ],
    darkblue: [0, 0, 139 ],
    darkcyan: [0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [0, 100, 0],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    grey: [ 128, 128, 128 ],
    green: [0, 128, 0],
    greenyellow: [ 173, 255, 47 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [0, 255, 0],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    magenta: [ 255, 0, 255 ],
    maroon: [ 128, 0, 0],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0],
    orangered: [ 255, 69, 0],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    red: [ 255, 0, 0],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 192 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0],
    yellowgreen: [ 154, 205, 50 ]
  }
};

},{"../is":86}],103:[function(require,module,exports){
'use strict';

/*global console */

var is = require( '../is' );
var math = require( '../math' );

var util = {

  trueify: function(){ return true; },

  falsify: function(){ return false; },

  zeroify: function(){ return 0; },

  noop: function(){},

  error: function( msg ){
    /* eslint-disable */
    if( console.error ){
      console.error.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    } else {
      console.log.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    }
    /* eslint-enable */
  },

  clone: function( obj ){
    return this.extend( {}, obj );
  },

  // gets a shallow copy of the argument
  copy: function( obj ){
    if( obj == null ){
      return obj;
    } if( is.array( obj ) ){
      return obj.slice();
    } else if( is.plainObject( obj ) ){
      return this.clone( obj );
    } else {
      return obj;
    }
  },

  uuid: function(
      a,b                // placeholders
  ){
      for(               // loop :)
          b=a='';        // b - result , a - numeric variable
          a++<36;        //
          b+=a*51&52  // if "a" is not 9 or 14 or 19 or 24
                      ?  //  return a random number or 4
             (
               a^15      // if "a" is not 15
                  ?      // genetate a random number from 0 to 15
               8^Math.random()*
               (a^20?16:4)  // unless "a" is 20, in which case a random number from 8 to 11
                  :
               4            //  otherwise 4
               ).toString(16)
                      :
             '-'            //  in other cases (if "a" is 9,14,19,24) insert "-"
          );
      return b;
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind( math );

util._staticEmptyObject = {};

util.staticEmptyObject = function(){
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign : function( tgt ){
  var args = arguments;

  for( var i = 1; i < args.length; i++ ){
    var obj = args[ i ];

    if( !obj ){ continue; }

    var keys = Object.keys( obj );

    for( var j = 0; j < keys.length; j++ ){
      var k = keys[j];

      tgt[ k ] = obj[ k ];
    }
  }

  return tgt;
};

util.default = function( val, def ){
  if( val === undefined ){
    return def;
  } else {
    return val;
  }
};

util.removeFromArray = function( arr, ele, manyCopies ){
  for( var i = arr.length; i >= 0; i-- ){
    if( arr[i] === ele ){
      arr.splice( i, 1 );

      if( !manyCopies ){ break; }
    }
  }
};

util.clearArray = function( arr ){
  arr.splice( 0, arr.length );
};

util.getPrefixedProperty = function( obj, propName, prefix ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[ propName ];
};

util.setPrefixedProperty = function( obj, propName, prefix, value ){
  if( prefix ){
    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[ propName ] = value;
};

[
  require( './colors' ),
  require( './maps' ),
  { memoize: require( './memoize' ) },
  require( './regex' ),
  require( './strings' ),
  require( './timing' )
].forEach( function( req ){
  util.extend( util, req );
} );

module.exports = util;

},{"../is":86,"../math":88,"./colors":102,"./maps":104,"./memoize":105,"./regex":106,"./strings":107,"./timing":108}],104:[function(require,module,exports){
'use strict';

var is = require( '../is' );

module.exports = {
  // has anything been set in the map
  mapEmpty: function( map ){
    var empty = true;

    if( map != null ){
      return Object.keys( map ).length === 0;
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function( options ){
    var array = this.getMap( options );

    if( array == null ){ // if empty, put initial array
      this.setMap( this.extend( {}, options, {
        value: [ options.value ]
      } ) );
    } else {
      array.push( options.value );
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function( options ){
    var obj = options.map;
    var key;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to set map with object key' );
      }

      if( i < keys.length - 1 ){

        // extend the map if necessary
        if( obj[ key ] == null ){
          obj[ key ] = {};
        }

        obj = obj[ key ];
      } else {
        // set the value
        obj[ key ] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to get map with object key' );
      }

      obj = obj[ key ];

      if( obj == null ){
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for( var i = 0; i < l; i++ ){
      var key = keys[ i ];

      if( is.plainObject( key ) ){
        this.error( 'Tried to delete map with object key' );
      }

      var lastKey = i === options.keys.length - 1;
      if( lastKey ){

        if( keepChildren ){ // then only delete child fields not in keepChildren
          var children = Object.keys( obj );

          for( var j = 0; j < children.length; j++ ){
            var child = children[j];

            if( !keepChildren[ child ] ){
              obj[ child ] = undefined;
            }
          }
        } else {
          obj[ key ] = undefined;
        }

      } else {
        obj = obj[ key ];
      }
    }
  }
};

},{"../is":86}],105:[function(require,module,exports){
'use strict';

module.exports = function memoize( fn, keyFn ){
  if( !keyFn ){
    keyFn = function(){
      if( arguments.length === 1 ){
        return arguments[0];
      } else if( arguments.length === 0 ){
        return 'undefined';
      }

      var args = [];

      for( var i = 0; i < arguments.length; i++ ){
        args.push( arguments[ i ] );
      }

      return args.join( '$' );
    };
  }

  var memoizedFn = function(){
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply( self, args );
    var cache = memoizedFn.cache;

    if( !(ret = cache[ k ]) ){
      ret = cache[ k ] = fn.apply( self, args );
    }

    return ret;
  };

  memoizedFn.cache = {};

  return memoizedFn;
};

},{}],106:[function(require,module,exports){
'use strict';

var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

},{}],107:[function(require,module,exports){
'use strict';

var memoize = require( './memoize' );
var is = require( '../is' );

module.exports = {

  camel2dash: memoize( function( str ){
    return str.replace( /([A-Z])/g, function( v ){
      return '-' + v.toLowerCase();
    } );
  } ),

  dash2camel: memoize( function( str ){
    return str.replace( /(-\w)/g, function( v ){
      return v[1].toUpperCase();
    } );
  } ),

  prependCamel: memoize( function( prefix, str ){
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function( prefix, str ){
    return prefix + '$' + str;
  } ),

  capitalize: function( str ){
    if( is.emptyString( str ) ){
      return str;
    }

    return str.charAt( 0 ).toUpperCase() + str.substring( 1 );
  }

};

},{"../is":86,"./memoize":105}],108:[function(require,module,exports){
'use strict';

var window = require( '../window' );
var is = require( '../is' );
var performance = window ? window.performance : null;

var util = {};

var raf = !window ? function( fn ){
  if( fn ){
    setTimeout( function(){
      fn( pnow() );
    }, 1000 / 60 );
  }
} : (function(){
  if( window.requestAnimationFrame ){
    return function( fn ){ window.requestAnimationFrame( fn ); };
  } else if( window.mozRequestAnimationFrame ){
    return function( fn ){ window.mozRequestAnimationFrame( fn ); };
  } else if( window.webkitRequestAnimationFrame ){
    return function( fn ){ window.webkitRequestAnimationFrame( fn ); };
  } else if( window.msRequestAnimationFrame ){
    return function( fn ){ window.msRequestAnimationFrame( fn ); };
  }
})();

util.requestAnimationFrame = function( fn ){
  raf( fn );
};

var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };

util.performanceNow = pnow;

// ported lodash throttle function
util.throttle = function( func, wait, options ){
  var leading = true,
      trailing = true;

  if( options === false ){
    leading = false;
  } else if( is.plainObject( options ) ){
    leading = 'leading' in options ? options.leading : leading;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  options = options || {};
  options.leading = leading;
  options.maxWait = wait;
  options.trailing = trailing;

  return util.debounce( func, wait, options );
};

util.now = function(){
  return Date.now();
};

util.debounce = function( func, wait, options ){ // ported lodash debounce function
  var util = this;
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if( !is.fn( func ) ){
    return;
  }
  wait = Math.max( 0, wait ) || 0;
  if( options === true ){
    var leading = true;
    trailing = false;
  } else if( is.plainObject( options ) ){
    leading = options.leading;
    maxWait = 'maxWait' in options && (Math.max( wait, options.maxWait ) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function(){
    var remaining = wait - (util.now() - stamp);
    if( remaining <= 0 ){
      if( maxTimeoutId ){
        clearTimeout( maxTimeoutId );
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if( isCalled ){
        lastCalled = util.now();
        result = func.apply( thisArg, args );
        if( !timeoutId && !maxTimeoutId ){
          args = thisArg = null;
        }
      }
    } else {
      timeoutId = setTimeout( delayed, remaining );
    }
  };

  var maxDelayed = function(){
    if( timeoutId ){
      clearTimeout( timeoutId );
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if( trailing || (maxWait !== wait) ){
      lastCalled = util.now();
      result = func.apply( thisArg, args );
      if( !timeoutId && !maxTimeoutId ){
        args = thisArg = null;
      }
    }
  };

  return function(){
    args = arguments;
    stamp = util.now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if( maxWait === false ){
      var leadingCall = leading && !timeoutId;
    } else {
      if( !maxTimeoutId && !leading ){
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0;

      if( isCalled ){
        if( maxTimeoutId ){
          maxTimeoutId = clearTimeout( maxTimeoutId );
        }
        lastCalled = stamp;
        result = func.apply( thisArg, args );
      }
      else if( !maxTimeoutId ){
        maxTimeoutId = setTimeout( maxDelayed, remaining );
      }
    }
    if( isCalled && timeoutId ){
      timeoutId = clearTimeout( timeoutId );
    }
    else if( !timeoutId && wait !== maxWait ){
      timeoutId = setTimeout( delayed, wait );
    }
    if( leadingCall ){
      isCalled = true;
      result = func.apply( thisArg, args );
    }
    if( isCalled && !timeoutId && !maxTimeoutId ){
      args = thisArg = null;
    }
    return result;
  };
};

module.exports = util;

},{"../is":86,"../window":110}],109:[function(require,module,exports){
module.exports = "2.7.14";

},{}],110:[function(require,module,exports){
module.exports = ( typeof window === 'undefined' ? null : window ); // eslint-disable-line no-undef

},{}],111:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("FileSaver.js", function() {
    return saveAs;
  });
}

},{}],112:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = baseKeysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function mergeDefaults(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, mergeDefaults);
  return apply(mergeWith, undefined, args);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with seven arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = defaultsDeep;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],113:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],114:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":115}],115:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],116:[function(require,module,exports){
var converter = require('./sbgnmlConverter');

module.exports = function (text) {
  return converter.convert(text);
};

},{"./sbgnmlConverter":117}],117:[function(require,module,exports){
/* jslint browser: true */
/* global ActiveXObject: false */

var sbgnmlConverter = {
  loadXMLFromString: function (text) {
    var doc;
    if (window.ActiveXObject) {
      doc = new ActiveXObject('Microsoft.XMLDOM');
      doc.async = 'false';
      doc.loadXML(text);
    } else {
      var parser = new DOMParser();
      doc = parser.parseFromString(text, 'text/xml');
    }

    var parseError = doc.getElementsByTagName('parsererror');
    if (parseError.length > 0) {
      throw new Error('Could not convert the following text to xml: ' + JSON.stringify(text));
    }

    return doc;
  },
  sbgnmlTags: {
    'unspecified entity': true,
    'simple chemical': true,
    'macromolecule': true,
    'nucleic acid feature': true,
    'perturbing agent': true,
    'source and sink': true,
    'complex': true,
    'process': true,
    'omitted process': true,
    'uncertain process': true,
    'association': true,
    'dissociation': true,
    'phenotype': true,
    'tag': true,
    'consumption': true,
    'production': true,
    'modulation': true,
    'stimulation': true,
    'catalysis': true,
    'inhibition': true,
    'necessary stimulation': true,
    'logic arc': true,
    'equivalence arc': true,
    'and operator': true,
    'or operator': true,
    'not operator': true,
    'and': true,
    'or': true,
    'not': true,
    'nucleic acid feature multimer': true,
    'macromolecule multimer': true,
    'simple chemical multimer': true,
    'complex multimer': true,
    'compartment': true
  },
  insertedNodes: {},
  getAllCompartments: function (xmlObject) {
    var compartments = [];

    var compartmentEls = xmlObject.querySelectorAll("glyph[class='compartment']");

    for (var i = 0; i < compartmentEls.length; i++) {
      var compartment = compartmentEls[i];
      var bbox = this.findChildNode(compartment, 'bbox');
      compartments.push({
        'x': parseFloat(bbox.getAttribute('x')),
        'y': parseFloat(bbox.getAttribute('y')),
        'w': parseFloat(bbox.getAttribute('w')),
        'h': parseFloat(bbox.getAttribute('h')),
        'id': compartment.getAttribute('id')
      });
    }

    compartments.sort(function (c1, c2) {
      if (c1.h * c1.w < c2.h * c2.w) {
        return -1;
      }
      if (c1.h * c1.w > c2.h * c2.w) {
        return 1;
      }
      return 0;
    });

    return compartments;
  },
  isInBoundingBox: function (bbox1, bbox2) {
    if (bbox1.x > bbox2.x &&
        bbox1.y > bbox2.y &&
        bbox1.x + bbox1.w < bbox2.x + bbox2.w &&
        bbox1.y + bbox1.h < bbox2.y + bbox2.h) {
      return true;
    }
    return false;
  },
  bboxProp: function (ele) {
    var bbox = {};
    var bboxEl = ele.querySelector('bbox');

    bbox.x = bboxEl.getAttribute('x');
    bbox.y = bboxEl.getAttribute('y');
    bbox.w = bboxEl.getAttribute('w');
    bbox.h = bboxEl.getAttribute('h');
    // set positions as center
    bbox.x = parseFloat(bbox.x) + parseFloat(bbox.w) / 2;
    bbox.y = parseFloat(bbox.y) + parseFloat(bbox.h) / 2;

    return bbox;
  },
  stateAndInfoBboxProp: function (ele, parentBbox) {
    var xPos = parseFloat(parentBbox.x);
    var yPos = parseFloat(parentBbox.y);

    var bbox = {};
    var bboxEl = ele.querySelector('bbox');

    bbox.x = bboxEl.getAttribute('x');
    bbox.y = bboxEl.getAttribute('y');
    bbox.w = bboxEl.getAttribute('w');
    bbox.h = bboxEl.getAttribute('h');

    // set positions as center
    bbox.x = parseFloat(bbox.x) + parseFloat(bbox.w) / 2 - xPos;
    bbox.y = parseFloat(bbox.y) + parseFloat(bbox.h) / 2 - yPos;

    bbox.x = bbox.x / parseFloat(parentBbox.w) * 100;
    bbox.y = bbox.y / parseFloat(parentBbox.h) * 100;

    return bbox;
  },
  findChildNodes: function (ele, childTagName) {
    // find child nodes at depth level of 1 relative to the element
    var children = [];
    for (var i = 0; i < ele.childNodes.length; i++) {
      var child = ele.childNodes[i];
      if (child.nodeType === 1 && child.tagName === childTagName) {
        children.push(child);
      }
    }
    return children;
  },
  findChildNode: function (ele, childTagName) {
    var nodes = this.findChildNodes(ele, childTagName);
    return nodes.length > 0 ? nodes[0] : undefined;
  },
  stateAndInfoProp: function (ele, parentBbox) {
    var self = this;
    var stateAndInfoArray = [];

    var childGlyphs = this.findChildNodes(ele, 'glyph');

    for (var i = 0; i < childGlyphs.length; i++) {
      var glyph = childGlyphs[i];
      var info = {};

      if (glyph.className === 'unit of information') {
        info.id = glyph.getAttribute('id') || undefined;
        info.clazz = glyph.className || undefined;
        var label = glyph.querySelector('label');
        info.label = {
          'text': (label && label.getAttribute('text')) || undefined
        };
        info.bbox = self.stateAndInfoBboxProp(glyph, parentBbox);
        stateAndInfoArray.push(info);
      } else if (glyph.className === 'state variable') {
        info.id = glyph.getAttribute('id') || undefined;
        info.clazz = glyph.className || undefined;
        var state = glyph.querySelector('state');
        var value = (state && state.getAttribute('value')) || undefined;
        var variable = (state && state.getAttribute('variable')) || undefined;
        info.state = {
          'value': value,
          'variable': variable
        };
        info.bbox = self.stateAndInfoBboxProp(glyph, parentBbox);
        stateAndInfoArray.push(info);
      }
    }


    return stateAndInfoArray;
  },
  addParentInfoToNode: function (ele, nodeObj, parent, compartments) {
    var self = this;
    var compartmentRef = ele.getAttribute('compartmentRef');

    if (parent) {
      nodeObj.parent = parent;
      return;
    }

    if (compartmentRef) {
      nodeObj.parent = compartmentRef;
    } else {
      nodeObj.parent = '';

      // add compartment according to geometry
      for (var i = 0; i < compartments.length; i++) {
        var bboxEl = self.findChildNode(ele, 'bbox');
        var bbox = {
          'x': parseFloat(bboxEl.getAttribute('x')),
          'y': parseFloat(bboxEl.getAttribute('y')),
          'w': parseFloat(bboxEl.getAttribute('w')),
          'h': parseFloat(bboxEl.getAttribute('h')),
          'id': ele.getAttribute('id')
        };
        if (self.isInBoundingBox(bbox, compartments[i])) {
          nodeObj.parent = compartments[i].id;
          break;
        }
      }
    }
  },
  addCytoscapeJsNode: function (ele, jsonArray, parent, compartments) {
    var self = this;
    var nodeObj = {};

    // add id information
    nodeObj.id = ele.getAttribute('id');
    // add node bounding box information
    nodeObj.bbox = self.bboxProp(ele);
    // add class information
    nodeObj.class = ele.className;
    // add label information
    var label = self.findChildNode(ele, 'label');
    nodeObj.label = (label && label.getAttribute('text')) || undefined;
    // add state and info box information
    nodeObj.statesandinfos = self.stateAndInfoProp(ele, nodeObj.bbox);
    // adding parent information
    self.addParentInfoToNode(ele, nodeObj, parent, compartments);

    // add clone information
    var cloneMarkers = self.findChildNodes(ele, 'clone');
    if (cloneMarkers.length > 0) {
      nodeObj.clonemarker = true;
    } else {
      nodeObj.clonemarker = undefined;
    }

    // add port information
    var ports = [];
    var portElements = ele.querySelectorAll('port');

    for (var i = 0; i < portElements.length; i++) {
      var portEl = portElements[i];
      var id = portEl.getAttribute('id');
      var relativeXPos = parseFloat(portEl.getAttribute('x')) - nodeObj.bbox.x;
      var relativeYPos = parseFloat(portEl.getAttribute('y')) - nodeObj.bbox.y;

      relativeXPos = relativeXPos / parseFloat(nodeObj.bbox.w) * 100;
      relativeYPos = relativeYPos / parseFloat(nodeObj.bbox.h) * 100;

      ports.push({
        id: id,
        x: relativeXPos,
        y: relativeYPos
      });
    }

    nodeObj.ports = ports;

    var cytoscapeJsNode = {data: nodeObj};
    jsonArray.push(cytoscapeJsNode);
  },
  traverseNodes: function (ele, jsonArray, parent, compartments) {
    var elId = ele.getAttribute('id');
    if (!this.sbgnmlTags[ele.className]) {
      return;
    }
    this.insertedNodes[elId] = true;
    var self = this;
    // add complex nodes here

    var eleClass = ele.className;

    if (eleClass === 'complex' || eleClass === 'submap') {
      self.addCytoscapeJsNode(ele, jsonArray, parent, compartments);

      var childGlyphs = self.findChildNodes(ele, 'glyph');
      for (var i = 0; i < childGlyphs.length; i++) {
        var glyph = childGlyphs[i];
        var glyphClass = glyph.className;
        if (glyphClass !== 'state variable' && glyphClass !== 'unit of information') {
          self.traverseNodes(glyph, jsonArray, elId, compartments);
        }
      }
    } else {
      self.addCytoscapeJsNode(ele, jsonArray, parent, compartments);
    }
  },
  getPorts: function (xmlObject) {
    return ( xmlObject._cachedPorts = xmlObject._cachedPorts || xmlObject.querySelectorAll('port'));
  },
  getGlyphs: function (xmlObject) {
    var glyphs = xmlObject._cachedGlyphs;

    if (!glyphs) {
      glyphs = xmlObject._cachedGlyphs = xmlObject._cachedGlyphs || xmlObject.querySelectorAll('glyph');

      var id2glyph = xmlObject._id2glyph = {};

      for ( var i = 0; i < glyphs.length; i++ ) {
        var g = glyphs[i];
        var id = g.getAttribute('id');

        id2glyph[ id ] = g;
      }
    }

    return glyphs;
  },
  getGlyphById: function (xmlObject, id) {
    this.getGlyphs(xmlObject); // make sure cache is built

    return xmlObject._id2glyph[id];
  },
  getArcSourceAndTarget: function (arc, xmlObject) {
    // source and target can be inside of a port
    var source = arc.getAttribute('source');
    var target = arc.getAttribute('target');
    var sourceNodeId;
    var targetNodeId;

    var sourceExists = this.getGlyphById(xmlObject, source);
    var targetExists = this.getGlyphById(xmlObject, target);

    if (sourceExists) {
      sourceNodeId = source;
    }

    if (targetExists) {
      targetNodeId = target;
    }


    var i;
    var portEls = this.getPorts(xmlObject);
    var port;
    if (sourceNodeId === undefined) {
      for (i = 0; i < portEls.length; i++ ) {
        port = portEls[i];
        if (port.getAttribute('id') === source) {
          sourceNodeId = port.parentElement.getAttribute('id');
        }
      }
    }

    if (targetNodeId === undefined) {
      for (i = 0; i < portEls.length; i++) {
        port = portEls[i];
        if (port.getAttribute('id') === target) {
          targetNodeId = port.parentElement.getAttribute('id');
        }
      }
    }

    return {'source': sourceNodeId, 'target': targetNodeId};
  },

  getArcBendPointPositions: function (ele) {
    var bendPointPositions = [];

    var children = this.findChildNodes(ele, 'next');

    for (var i = 0; i < children.length; i++) {
      var posX = children[i].getAttribute('x');
      var posY = children[i].getAttribute('y');

      bendPointPositions.push({
        x: posX,
        y: posY
      });
    }

    return bendPointPositions;
  },
  addCytoscapeJsEdge: function (ele, jsonArray, xmlObject) {
    if (!this.sbgnmlTags[ele.className]) {
      return;
    }

    var self = this;
    var sourceAndTarget = self.getArcSourceAndTarget(ele, xmlObject);

    if (!this.insertedNodes[sourceAndTarget.source] || !this.insertedNodes[sourceAndTarget.target]) {
      return;
    }

    var edgeObj = {};
    var bendPointPositions = self.getArcBendPointPositions(ele);

    edgeObj.id = ele.getAttribute('id') || undefined;
    edgeObj.class = ele.className;
    edgeObj.bendPointPositions = bendPointPositions;

    var glyphChildren = self.findChildNodes(ele, 'glyph');
    var glyphDescendents = ele.querySelectorAll('glyph');
    if (glyphDescendents.length <= 0) {
      edgeObj.cardinality = 0;
    } else {
      for (var i = 0; i < glyphChildren.length; i++) {
        if (glyphChildren[i].className === 'cardinality') {
          var label = glyphChildren[i].querySelector('label');
          edgeObj.cardinality = label.getAttribute('text') || undefined;
        }
      }
    }

    edgeObj.source = sourceAndTarget.source;
    edgeObj.target = sourceAndTarget.target;

    edgeObj.portsource = ele.getAttribute('source');
    edgeObj.porttarget = ele.getAttribute('target');

    var cytoscapeJsEdge = {data: edgeObj};
    jsonArray.push(cytoscapeJsEdge);
  },
  convert: function (sbgnmlText) {
    var self = this;
    var cytoscapeJsNodes = [];
    var cytoscapeJsEdges = [];

    var xmlObject = this.loadXMLFromString(sbgnmlText);

    var compartments = self.getAllCompartments(xmlObject);

    var glyphs = self.findChildNodes(xmlObject.querySelector('map'), 'glyph');
    var arcs = self.findChildNodes(xmlObject.querySelector('map'), 'arc');

    var i;
    for (i = 0; i < glyphs.length; i++) {
      var glyph = glyphs[i];
      self.traverseNodes(glyph, cytoscapeJsNodes, '', compartments);
    }

    for (i = 0; i < arcs.length; i++) {
      var arc = arcs[i];
      self.addCytoscapeJsEdge(arc, cytoscapeJsEdges, xmlObject);
    }

    var cytoscapeJsGraph = {};
    cytoscapeJsGraph.nodes = cytoscapeJsNodes;
    cytoscapeJsGraph.edges = cytoscapeJsEdges;

    this.insertedNodes = {};

    return cytoscapeJsGraph;
  }
};

module.exports = sbgnmlConverter;

},{}],118:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cytoscape = require('cytoscape');
var defaultsDeep = require('lodash.defaultsdeep');

var sbgnStyleSheet = require('./sbgnStyle/graph');

var defaultOptions = {
  style: sbgnStyleSheet(Cytoscape),
  boxSelectionEnabled: true,
  showOverlay: false,
  minZoom: false,
  maxZoom: false,
  motionBlur: false,
  wheelSensitivity: 0.1
};

var SBGNRenderer = function (_Cytoscape) {
  _inherits(SBGNRenderer, _Cytoscape);

  function SBGNRenderer(options) {
    _classCallCheck(this, SBGNRenderer);

    return _possibleConstructorReturn(this, (SBGNRenderer.__proto__ || Object.getPrototypeOf(SBGNRenderer)).call(this, defaultsDeep({}, defaultOptions, options)));
  }
  //   TODO: Initial sbgn-renderer api
  //   sbgn (kdfkd) { // the function that can possibly turned into an extension
  //   ...; // style sheet can be set in here
  //   ...; // accept sbngml file or string, promise to resolve to string (fetch support), possibly always treat it as a promise
  //   ...; // export  to sbgnml file or picture
  //  }


  return SBGNRenderer;
}(Cytoscape);

module.exports = SBGNRenderer;

},{"./sbgnStyle/graph":125,"cytoscape":85,"lodash.defaultsdeep":112}],119:[function(require,module,exports){
'use strict';

var elementStyle = {};

elementStyle.sbgnShape = function (node) {
  var sbgnClass = node.data('class');
  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'phenotype') {
    return 'hexagon';
  }

  if (sbgnClass == 'process') {
    return 'square';
  }

  if (sbgnClass == 'perturbing agent' || sbgnClass == 'tag' || sbgnClass == 'source and sink' || sbgnClass == 'compartment' || sbgnClass == 'complex') {
    return 'polygon';
  }

  if (sbgnClass == 'dissociation') {
    return 'ellipse';
  }

  if (sbgnClass == 'nucleic acid feature' || sbgnClass == 'macromolecule') {
    return 'roundrectangle';
  }
  return 'ellipse';
};

elementStyle.sbgnArrowShape = function (edge) {
  var sbgnClass = edge.data('class');
  if (sbgnClass == 'necessary stimulation') {
    return 'triangle-cross';
  }
  if (sbgnClass == 'inhibition') {
    return 'tee';
  }
  if (sbgnClass == 'catalysis') {
    return 'circle';
  }
  if (sbgnClass == 'stimulation' || sbgnClass == 'production') {
    return 'triangle';
  }
  if (sbgnClass == 'modulation') {
    return 'diamond';
  }
  return 'none';
};

elementStyle.sbgnContent = function (node) {
  var sbgnClass = node.data('class');
  var content = '';

  if (sbgnClass.endsWith(' multimer')) {
    sbgnClass = sbgnClass.replace(' multimer', '');
  }

  if (sbgnClass == 'macromolecule' || sbgnClass == 'simple chemical' || sbgnClass == 'phenotype' || sbgnClass == 'unspecified entity' || sbgnClass == 'nucleic acid feature' || sbgnClass == 'perturbing agent' || sbgnClass == 'tag') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'compartment') {
    content = node.data('label') ? node.data('label') : '';
  } else if (sbgnClass == 'complex') {
    if (node.children().length == 0) {
      if (node.data('label')) {
        content = node.data('label');
      } else if (node.data('infoLabel')) {
        content = node.data('infoLabel');
      } else {
        content = '';
      }
    } else {
      content = '';
    }
  } else if (sbgnClass == 'and') {
    content = 'AND';
  } else if (sbgnClass == 'or') {
    content = 'OR';
  } else if (sbgnClass == 'not') {
    content = 'NOT';
  } else if (sbgnClass == 'omitted process') {
    content = '\\\\';
  } else if (sbgnClass == 'uncertain process') {
    content = '?';
  }

  return content;
};

var dynamicLabelTextSize = function dynamicLabelTextSize(nodeHeight) {
  var sizeCoefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return nodeHeight / 2.45 * sizeCoefficient;
};

elementStyle.labelTextSize = function (node) {
  var sbgnClass = node.data('class');
  var nh = node.height();

  // Dirty legacy hack.  These types of nodes are not supposed to have labels
  // but apparently they need to have a text size
  if (sbgnClass === 'association' || sbgnClass === 'dissociation') {
    return 20;
  }

  if (sbgnClass === 'and' || sbgnClass === 'or' || sbgnClass === 'not') {
    return dynamicLabelTextSize(nh, 1);
  }

  if (sbgnClass.endsWith('process')) {
    return dynamicLabelTextSize(nh, 1.5);
  }

  if (sbgnClass === 'complex' || sbgnClass === 'compartment') {
    return 16;
  }

  return dynamicLabelTextSize(nh);
};

elementStyle.cardinalityDistance = function (edge) {
  var srcPos = edge.source().position();
  var tgtPos = edge.target().position();

  var distance = Math.sqrt(Math.pow(srcPos.x - tgtPos.x, 2) + Math.pow(srcPos.y - tgtPos.y, 2));
  return distance * 0.15;
};

module.exports = elementStyle;

},{}],120:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var baseShapes = {
  styleMap2Str: function styleMap2Str(styleMap) {
    return '' + [].concat(_toConsumableArray(styleMap)).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return k + ': ' + v + ';';
    }).join(' ');
  },
  baseRectangle: function baseRectangle(x, y, w, h, r1, r2, r3, r4, styleMap) {
    return '\n    <path style=\'' + this.styleMap2Str(styleMap) + '\' d=\'\n      M ' + (x + r1) + ' ' + y + '\n      L ' + (x + w - r2) + ' ' + y + ' Q ' + (x + w) + ' ' + y + ' ' + (x + w) + ' ' + (y + r2) + '\n      L ' + (x + w) + ' ' + (y + h - r3) + ' Q ' + (x + w) + ' ' + (y + h) + ' ' + (x + w - r3) + ' ' + (y + h) + '\n      L ' + (x + r4) + ' ' + (y + h) + ' Q ' + x + ' ' + (y + h) + ' ' + x + ' ' + (y + h - r4) + '\n      L ' + x + ' ' + (y + r1) + ' Q ' + x + ' ' + y + ' ' + (x + r1) + ' ' + y + '\n      Z\'\n    />\n    ';
  },
  barrel: function barrel(width, height, styleMap) {
    return '\n\n    <g style="' + this.styleMap2Str(styleMap) + '">\n      <path d="M ' + 0 * width + ' ' + .03 * height + ' L ' + 0 * width + ' ' + .97 * height + ' Q ' + 0.06 * width + ' ' + height + ' ' + 0.25 * width + ' ' + height + '"/>\n\n      <path d="M ' + 0.25 * width + ' ' + height + ' L ' + 0.75 * width + ' ' + height + ' Q ' + 0.95 * width + ' ' + height + ' ' + width + ' ' + 0.95 * height + '"/>\n\n      <path d="M ' + width + ' ' + .95 * height + ' L ' + width + ' ' + 0.05 * height + ' Q ' + width + ' ' + 0 * height + ' ' + 0.75 * width + ' ' + 0 * height + '"/>\n\n      <path d="M ' + 0.75 * width + ' ' + 0 * height + ' L ' + 0.25 * width + ' ' + 0 * height + ' Q ' + 0.06 * width + ' ' + 0 * height + ' ' + 0 * width + ' ' + 0.03 * height + '"/>\n    </g>\n\n    ';
  },
  circle: function circle(cx, cy, r, styleMap) {
    return '<circle cx=\'' + cx + '\' cy=\'' + cy + '\' r=\'' + r + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />';
  },
  concaveHexagon: function concaveHexagon(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'' + 0 + ', ' + 0 + ', ' + width + ', ' + 0 + ', ' + 0.85 * width + ', ' + 0.5 * height + ', ' + width + ', ' + height + ', ' + 0 + ', ' + height + ', ' + 0.15 * width + ', ' + 0.5 * height + '\'\n    />';
  },
  cutRectangle: function cutRectangle(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'\n      ' + 0 * width + ' ' + 0.05 * height + ' ' + 0.05 * width + ' ' + 0 * height + ' ' + 0.95 * width + ' ' + 0 * height + ' ' + width + ' ' + 0.05 * height + '\n      ' + width + ' ' + 0.95 * height + ' ' + 0.95 * width + ' ' + height + ' ' + 0.05 * width + ' ' + height + ' ' + 0 * width + ' ' + 0.95 * height + '\n      \'\n    />\n    ';
  },
  ellipse: function ellipse(cx, cy, rx, ry, styleMap) {
    return '\n      <ellipse cx=\'' + cx + '\' cy=\'' + cy + '\' rx=\'' + rx + '\' ry=\'' + ry + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />\n    ';
  },
  hexagon: function hexagon(width, height, styleMap) {
    return '\n    <polygon style=\'' + this.styleMap2Str(styleMap) + '\'\n      points=\'' + 0 + ', ' + 0.5 * height + ', ' + 0.25 * width + ', ' + 0 * height + ', ' + 0.75 * width + ', ' + 0 * height + ', ' + width + ', ' + 0.5 * height + ', ' + 0.75 * width + ', ' + height + ', ' + 0.25 * width + ', ' + height + '\'\n    />';
  },
  line: function line(x1, y1, x2, y2, styleMap) {
    return '<line x1=\'' + x1 + '\' y1=\'' + y1 + '\' x2=\'' + x2 + '\' y2=\'' + y2 + '\' style=\'' + this.styleMap2Str(styleMap) + '\' />';
  },
  rectangle: function rectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, 0, 0, 0, 0, styleMap);
  },
  roundBottomRectangle: function roundBottomRectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, 0, 0, .3 * height, .3 * height, styleMap);
  },
  roundRectangle: function roundRectangle(x, y, width, height, styleMap) {
    return this.baseRectangle(x, y, width, height, .3 * height, .3 * height, .3 * height, .3 * height, styleMap);
  },
  square: function square(x, y, length, styleMap) {
    return this.baseRectangle(x, y, length, length, 0, 0, 0, 0, styleMap);
  },
  text: function text(t, x, y, textAnchor, styleMap) {
    return '<text x=\'' + x + '\' y=\'' + y + '\' textAnchor=\'' + textAnchor + '\' style=\'' + this.styleMap2Str(styleMap) + '\'>' + t + '</text>';
  }
};

module.exports = baseShapes;

},{}],121:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');
var svgStr = require('../util/svg.js');

var containerNodes = {
  compartment: function compartment(node) {
    var nh = node.outerHeight();
    var nw = node.outerWidth();

    var style = new Map().set('stroke-width', '3.75').set('fill', 'none').set('stroke', '#6A6A6A');

    var compartmentSvg = '\n      ' + baseShapes.barrel(nw, nh, style) + '\n    ';
    return svgStr(compartmentSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = containerNodes;

},{"../util/svg.js":126,"./baseShapes.js":120}],122:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');
var svgStr = require('../util/svg.js');

var entityPoolNodes = {
  unspecifiedEntity: function unspecifiedEntity(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var unspecEntitySvg = '\n      ' + baseShapes.ellipse(nw / 2, nh / 2, (nh - 2) / 2, (nw - 2) / 2, styleMap) + '\n    ';
    return svgStr(unspecEntitySvg, nw, nh, 0, 0, nw, nh);
  },
  simpleChemical: function simpleChemical(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var simpleChemicalSvg = '\n      ' + baseShapes.circle(nw / 2, nh / 2, (Math.min(nw, nh) - 2) / 2, styleMap) + '\n    ';
    return svgStr(simpleChemicalSvg, nw, nh, 0, 0, nw, nh);
  },
  macromolecule: function macromolecule(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var macromoleculeSvg = '\n      ' + baseShapes.roundRectangle(0, 0, nw, nh, styleMap) + '\n    ';
    return svgStr(macromoleculeSvg, nw, nh, 0, 0, nw, nh);
  },
  nucleicAcidFeature: function nucleicAcidFeature(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var nucleicAcidFeatureSvg = '\n      ' + baseShapes.roundBottomRectangle(0, 0, nw, nh, styleMap) + '\n    ';
    return svgStr(nucleicAcidFeatureSvg, nw, nh, 0, 0, nw, nh);
  },
  complex: function complex(node) {
    var nw = node.outerWidth();
    var nh = node.outerHeight();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var complexSvg = '\n      ' + baseShapes.cutRectangle(nw, nh, styleMap) + '\n    ';
    return svgStr(complexSvg, nw, nh, 0, 0, nw, nh);
  },
  sourceAndSink: function sourceAndSink(node) {
    var nodeCenterX = node.width() / 2;
    var nodeCenterY = node.height() / 2;
    var circleRadius = (node.width() - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-linecap', 'square').set('stroke-width', '1.5').set('fill', 'none');

    var sourceAndSinkSvg = '\n      ' + baseShapes.circle(nodeCenterX, nodeCenterY, circleRadius, styleMap) + '\n      ' + baseShapes.line(0, node.height(), node.width(), 0, styleMap) + '\n    ';
    return svgStr(sourceAndSinkSvg, node.width(), node.height(), 0, 0, node.width(), node.height());
  },
  perturbingAgent: function perturbingAgent(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var perturbingAgentSvg = '\n      ' + baseShapes.concaveHexagon(nw, nh, styleMap) + '\n    ';
    return svgStr(perturbingAgentSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = entityPoolNodes;

},{"../util/svg.js":126,"./baseShapes.js":120}],123:[function(require,module,exports){
'use strict';

var containerNodes = require('./containerNodeShapes.js');
var entityPoolNodes = require('./entityPoolNodeShapes.js');
var processNodes = require('./processNodeShapes.js');

var sbgnNodeShapeMap = new Map()
// process nodes
.set('process', processNodes.process).set('omitted process', processNodes.process).set('uncertain process', processNodes.process).set('association', processNodes.association).set('dissociation', processNodes.dissociation).set('phenotype', processNodes.phenotype)

// entity pool nodes
.set('source and sink', entityPoolNodes.sourceAndSink).set('unspecified entity', entityPoolNodes.unspecifiedEntity).set('simple chemical', entityPoolNodes.simpleChemical).set('macromolecule', entityPoolNodes.macromolecule).set('nucleic acid feature', entityPoolNodes.nucleicAcidFeature).set('complex', entityPoolNodes.complex).set('perturbing agent', entityPoolNodes.perturbingAgent)

// container nodes
.set('compartment', containerNodes.compartment);

var draw = function draw(sbgnClass, node) {
  var shapeFn = sbgnNodeShapeMap.get(sbgnClass);
  if (shapeFn === undefined) {
    throw new TypeError(sbgnClass + ' does not have a shape implementation');
  }
  return shapeFn(node);
};

module.exports = {
  draw: draw
};

},{"./containerNodeShapes.js":121,"./entityPoolNodeShapes.js":122,"./processNodeShapes.js":124}],124:[function(require,module,exports){
'use strict';

var baseShapes = require('./baseShapes.js');
var svgStr = require('../util/svg.js');

var processNodes = {
  process: function process(node) {
    var nw = node.width();
    var nh = node.height();

    var lineStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '1').set('fill', 'none');

    var squareStyle = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var line = baseShapes.line(0, nh / 2, nw, nh / 2, lineStyle);

    var processSvg = '\n      ' + baseShapes.square(0, 0, Math.max(nw, nh), squareStyle) + '\n    ';
    return svgStr(processSvg, nw, nh, 0, 0, nw, nh);
  },
  association: function association(node) {
    var nw = node.width();
    var nh = node.height();

    var centerX = nw / 2;
    var centerY = nh / 2;
    var radius = (Math.min(nw, nh) - 2) / 2;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', '#6A6A6A').set('fill-opacity', '0');

    var line = baseShapes.line(0, nh / 2, nw, nh / 2, styleMap);

    var associationSvg = '\n      ' + baseShapes.circle(centerX, centerY, radius, styleMap) + '\n    ';
    return svgStr(associationSvg, nw, nh, 0, 0, nw, nh);
  },
  dissociation: function dissociation(node) {
    var nw = node.width();
    var nh = node.height();

    var centerX = node.width() / 2;
    var centerY = node.height() / 2;
    var outerRadius = (Math.min(nw, nh) - 2) / 2;
    var innerRadius = (Math.min(nw, nh) - 2) / 3;

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '2').set('fill', 'none');

    var dissociationSvg = '\n      ' + baseShapes.circle(centerX, centerY, outerRadius, styleMap) + '\n      ' + baseShapes.circle(centerX, centerY, innerRadius, styleMap) + '\n    ';
    return svgStr(dissociationSvg, nw, nh, 0, 0, nw, nh);
  },
  phenotype: function phenotype(node) {
    var nw = node.width();
    var nh = node.height();

    var styleMap = new Map().set('stroke', '#6A6A6A').set('stroke-width', '3').set('fill', 'none');

    var phenotypeSvg = '\n      ' + baseShapes.hexagon(nw, nh, styleMap) + '\n    ';
    return svgStr(phenotypeSvg, nw, nh, 0, 0, nw, nh);
  }
};

module.exports = processNodes;

},{"../util/svg.js":126,"./baseShapes.js":120}],125:[function(require,module,exports){
'use strict';

var elementStyle = require('./element.js');
var sbgnShapes = require('./glyph');

// A function that creates a cytoscape style sheet from a given
// cytoscape instance
var sbgnStyleSheet = function sbgnStyleSheet(cytoscape) {

  return cytoscape.stylesheet().selector('node').css({
    'content': function content(node) {
      return elementStyle.sbgnContent(node);
    },
    'font-size': function fontSize(node) {
      return elementStyle.labelTextSize(node);
    },
    'text-valign': 'center',
    'text-halign': 'center',
    'border-width': 1.5,
    'border-color': '#555',
    'background-color': '#f6f6f6',
    'background-opacity': 0.5,
    'text-opacity': 1,
    'opacity': 1,
    'text-wrap': 'wrap',
    'text-max-width': 100
  }).selector('node[class]').css({
    'shape': function shape(node) {
      return elementStyle.sbgnShape(node);
    }
  }).selector('node[class="process"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'shape': 'square',
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="uncertain process"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'shape': 'square',
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="omitted process"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'padding': function padding(node) {
      return Math.max(node.width(), node.height()) * 0.1;
    },
    'shape': 'square',
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="association"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'shape': 'ellipse',
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0,
    'background-opacity': 1
  }).selector('node[class="dissociation"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="phenotype"]').css({
    'shape': 'hexagon',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="source and sink"]').css({
    'shape-polygon-points': '-0.86, 0.5, -0.75, 0.65, -1, 0.95, -0.95, 1, -0.65, 0.75, -0.5, 0.86, 0, 1, 0.5, 0.86, 0.71, 0.71, 0.86, 0.5, 1, 0, 0.86, -0.5, 0.75, -0.65, 1, -0.95, 0.95, -1, 0.65, -0.75, 0.5, -0.86, 0, -1, -0.5, -0.86, -0.71, -0.71, -0.86, -0.5, -1, 0',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="nucleic acid feature"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="perturbing agent"]').css({
    'shape-polygon-points': '-1, -1,   -0.5, 0,  -1, 1,   1, 1,   0.5, 0, 1, -1',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="macromolecule"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="simple chemical"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="unspecified entity"]').css({
    'shape': 'ellipse',
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'background-fit': 'none',
    'background-width': '100%',
    'background-height': '100%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0
  }).selector('node[class="complex"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'padding': function padding(node) {
      return Math.min(node.height(), node.width()) * .055;
    },
    'background-opacity': .2,
    'background-fit': 'none',
    'background-width': '110%',
    'background-height': '110%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0,
    'text-valign': 'bottom',
    'text-halign': 'center',
    'min-height': function minHeight(node) {
      return node.width() * .75;
    },
    'min-height-bias-top': '50%',
    'min-height-bias-bottom': '50%'
  }).selector('node[class="compartment"]').css({
    'background-image': function backgroundImage(node) {
      return sbgnShapes.draw(node.data('class'), node);
    },
    'padding': function padding(node) {
      return Math.max(node.height(), node.width()) * .1;
    },
    'background-fit': 'none',
    'background-width': '110%',
    'background-height': '110%',
    'background-clip': 'none',
    'background-repeat': 'no-repeat',
    'border-width': 0,
    'background-opacity': .2,
    'text-valign': 'bottom',
    'text-halign': 'center',
    'min-height': 100,
    'min-height-bias-top': '50%',
    'min-height-bias-bottom': '50%',
    'min-width': 175,
    'min-width-bias-right': '50%',
    'min-width-bias-left': '50%'
  }).selector('node[class="tag"]').css({
    'shape-polygon-points': '-1, -1,   0.25, -1,   1, 0,    0.25, 1,    -1, 1'
  }).selector('node[class="association"]').css({
    'background-color': '#6B6B6B'
  }).selector('node[bbox][class][class!="complex"][class!="compartment"][class!="submap"]').css({
    'width': 'data(bbox.w)',
    'height': 'data(bbox.h)'
  }).selector('node:selected').css({
    'background-color': '#d67614',
    'target-arrow-color': '#000',
    'text-outline-color': '#000'
  }).selector('node:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '14'
  }).selector('edge').css({
    'curve-style': 'bezier',
    'line-color': '#555',
    'target-arrow-fill': 'hollow',
    'source-arrow-fill': 'hollow',
    'width': 1.5,
    'target-arrow-color': '#555',
    'source-arrow-color': '#555',
    'text-border-color': function textBorderColor(edge) {
      if (edge.selected()) {
        return '#d67614';
      }
      return edge.css('line-color');
    },
    'color': function color(edge) {
      if (edge.selected()) {
        return '#d67614';
      }
      return edge.css('line-color');
    }
  }).selector('edge:selected').css({
    'line-color': '#d67614',
    'source-arrow-color': '#d67614',
    'target-arrow-color': '#d67614'
  }).selector('edge:active').css({
    'background-opacity': 0.7, 'overlay-color': '#d67614',
    'overlay-padding': '8'
  }).selector('edge[cardinality > 0]').css({
    'text-rotation': 'autorotate',
    'text-background-shape': 'rectangle',
    'text-border-opacity': '1',
    'text-border-width': '1',
    'text-background-color': 'white',
    'text-background-opacity': '1'
  }).selector('edge[class="consumption"][cardinality > 0]').css({
    'source-label': function sourceLabel(edge) {
      return '' + edge.data('cardinality');
    },
    'source-text-margin-y': '-10',
    'source-text-offset': function sourceTextOffset(edge) {
      return elementStyle.cardinalityDistance(edge);
    }
  }).selector('edge[class="production"][cardinality > 0]').css({
    'target-label': function targetLabel(edge) {
      return '' + edge.data('cardinality');
    },
    'target-text-margin-y': '-10',
    'target-text-offset': function targetTextOffset(edge) {
      return elementStyle.cardinalityDistance(edge);
    }
  }).selector('edge[class]').css({
    'target-arrow-shape': function targetArrowShape(edge) {
      return elementStyle.sbgnArrowShape(edge);
    },
    'source-arrow-shape': 'none'
  }).selector('edge[class="inhibition"]').css({
    'target-arrow-fill': 'filled'
  }).selector('edge[class="production"]').css({
    'target-arrow-fill': 'filled'
  }).selector('core').css({
    'selection-box-color': '#d67614',
    'selection-box-opacity': '0.2', 'selection-box-border-color': '#d67614'
  });
};

module.exports = sbgnStyleSheet;

},{"./element.js":119,"./glyph":123}],126:[function(require,module,exports){
'use strict';

var parser = new DOMParser();

var svg = function svg(svgStr) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var vbX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var vbY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var vbWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
  var vbHeight = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 100;

  var svgText = '\n    <svg xmlns=\'http://www.w3.org/2000/svg\' version=\'1.1\' width=\'' + width + '\' height=\'' + height + '\' viewBox=\'' + vbX + ' ' + vbY + ' ' + vbWidth + ' ' + vbHeight + '\'>\n    ' + svgStr + '\n    </svg>\n  ';
  return parser.parseFromString(svgText, 'text/xml').documentElement;
};

var svgb64Str = function svgb64Str(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight) {
  var svgEl = svg(svgText, viewPortWidth, viewPortHeight, viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight);
  var b64Data = 'data:image/svg+xml;base64,' + btoa(svgEl.outerHTML);

  return b64Data;
};

module.exports = svgb64Str;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vL2Jyb3dzZXJpZnktZW50cnkuanMiLCJkZW1vL3Rlc3QtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy8tcHJlYW1ibGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvYS1zdGFyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2JlbGxtYW4tZm9yZC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vYWxnb3JpdGhtcy9iZXR3ZWVubmVzcy1jZW50cmFsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2Jmcy1kZnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvY2xvc2VuZXNzLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGVncmVlLWNlbnRyYWxpdHkuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZGlqa3N0cmEuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvZmxveWQtd2Fyc2hhbGwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMva2VyZ2VyLXN0ZWluLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2tydXNrYWwuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvcGFnZS1yYW5rLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9jb21wYXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vY29tcG91bmRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9kZWdyZWUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2RpbWVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2VsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9ncm91cC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb2xsZWN0aW9uL2l0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vbGF5b3V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29sbGVjdGlvbi9zdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vc3dpdGNoLWZ1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24vdHJhdmVyc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvbGxlY3Rpb24venNvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FkZC1yZW1vdmUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2FuaW1hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvY29yZS9sYXlvdXQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL25vdGlmaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3NlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2NvcmUvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9jb3JlL3ZpZXdwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXZlbnQuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvYnJlYWR0aGZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY29uY2VudHJpYy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvbGF5b3V0L2Nvc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9ncmlkLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL2xheW91dC9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcHJlc2V0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9iYXNlL2Fycm93LXNoYXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9jb29yZC1lbGUtbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9pbWFnZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvbG9hZC1saXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2Uvbm9kZS1zaGFwZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvcmVkcmF3LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvYXJyb3ctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1lZGdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctZWxlbWVudHMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLWltYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbGFiZWwtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbm9kZXMuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9kcmF3aW5nLXJlZHJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZWxlLXRleHR1cmUtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9leHBvcnQtaW1hZ2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9leHRlbnNpb25zL3JlbmRlcmVyL2NhbnZhcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2xheWVyZWQtdGV4dHVyZS1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL25vZGUtc2hhcGVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvdGV4dHVyZS1jYWNoZS1kZWZzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvbnVsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2ZhYnJpYy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2hlYXAuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL2lzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvanF1ZXJ5LXBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL21hdGguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2J5cGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3N0eWxlL2dldC1mb3ItZWxlLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy9zdHlsZS9wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGUvc3RyaW5nLXNoZWV0LmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvc3R5bGVzaGVldC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3RocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9zcmMvdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvbWFwcy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3V0aWwvcmVnZXguanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy91dGlsL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy91dGlsL3RpbWluZy5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvc3JjL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvY3l0b3NjYXBlL3NyYy93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvZmlsZS1zYXZlci9GaWxlU2F2ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmRlZmF1bHRzZGVlcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYmdubWwtdG8tY3l0b3NjYXBlL3NyYy9zYmdubWxDb252ZXJ0ZXIuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvc2JnblN0eWxlL2VsZW1lbnQuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2Jhc2VTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2NvbnRhaW5lck5vZGVTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dseXBoL2VudGl0eVBvb2xOb2RlU2hhcGVzLmpzIiwic3JjL3NiZ25TdHlsZS9nbHlwaC9pbmRleC5qcyIsInNyYy9zYmduU3R5bGUvZ2x5cGgvcHJvY2Vzc05vZGVTaGFwZXMuanMiLCJzcmMvc2JnblN0eWxlL2dyYXBoLmpzIiwic3JjL3NiZ25TdHlsZS91dGlsL3N2Zy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDRUE7Ozs7OztBQUVBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEIsQyxDQUpBOztBQUtBLElBQUksU0FBUyxRQUFRLFlBQVIsRUFBc0IsTUFBbkM7O0FBRUEsSUFBSSxjQUFjLFFBQVEsYUFBUixDQUFsQjs7QUFFQSxJQUFJLGVBQWUsU0FBZixZQUFlLENBQVUsV0FBVixFQUF1QjtBQUN4QyxNQUFJLEtBQUo7QUFDQSxNQUFJLE9BQU8sY0FBWCxFQUEyQjtBQUN6QixZQUFRLElBQUksY0FBSixFQUFSO0FBQ0QsR0FGRCxNQUdLO0FBQ0gsWUFBUSxJQUFJLGFBQUosQ0FBa0IsbUJBQWxCLENBQVI7QUFDRDtBQUNELFFBQU0sSUFBTixDQUFXLEtBQVgsRUFBa0IsV0FBbEIsRUFBK0IsS0FBL0I7QUFDQSxRQUFNLElBQU47QUFDQSxTQUFPLE1BQU0sWUFBYjtBQUNELENBWEQ7O0FBYUEsSUFBSSxXQUFXLFNBQVgsUUFBVyxDQUFVLFFBQVYsRUFBb0IsSUFBcEIsRUFBMEI7QUFDdkMsTUFBSSxTQUFTLElBQUksVUFBSixFQUFiOztBQUVBLFNBQU8sTUFBUCxHQUFnQixVQUFVLENBQVYsRUFBYTtBQUMzQixRQUFJLFFBQVEsY0FBYyxFQUFFLE1BQUYsQ0FBUyxNQUF2QixDQUFaO0FBQ0EsZ0JBQVksUUFBWixFQUFzQixLQUF0QjtBQUVELEdBSkQ7O0FBTUEsU0FBTyxVQUFQLENBQWtCLElBQWxCO0FBQ0QsQ0FWRDs7QUFZQSxJQUFJLGNBQWMsU0FBZCxXQUFjLENBQVUsRUFBVixFQUFjLE9BQWQsRUFBdUI7QUFDdkMsS0FBRyxVQUFIO0FBQ0EsS0FBRyxNQUFILENBQVUsR0FBVjtBQUNBLEtBQUcsR0FBSCxDQUFPLE9BQVA7O0FBRUEsTUFBSSxnQkFBZ0IsRUFBcEI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxLQUFSLENBQWMsTUFBbEMsRUFBMEMsR0FBMUMsRUFBK0M7QUFDN0MsUUFBSSxPQUFPLFFBQVEsS0FBUixDQUFjLENBQWQsRUFBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBMkIsQ0FBdEM7QUFDQSxRQUFJLE9BQU8sUUFBUSxLQUFSLENBQWMsQ0FBZCxFQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUEyQixDQUF0QztBQUNBLGtCQUFjLFFBQVEsS0FBUixDQUFjLENBQWQsRUFBaUIsSUFBakIsQ0FBc0IsRUFBcEMsSUFBMEMsRUFBQyxLQUFLLElBQU4sRUFBWSxLQUFLLElBQWpCLEVBQTFDO0FBQ0Q7O0FBRUQsS0FBRyxNQUFILENBQVU7QUFDUixVQUFNLFFBREU7QUFFUixlQUFXLGFBRkg7QUFHUixTQUFLLElBSEc7QUFJUixhQUFTO0FBSkQsR0FBVjs7QUFPQSxLQUFHLFFBQUg7QUFDQSxLQUFHLEtBQUgsR0FBVyxNQUFYO0FBQ0QsQ0FyQkQ7O0FBdUJBLElBQUksWUFBWSxTQUFaLFNBQVksQ0FBVSxPQUFWLEVBQW1CLFdBQW5CLEVBQWdDLFNBQWhDLEVBQTJDO0FBQ3pELGdCQUFjLGVBQWUsRUFBN0I7QUFDQSxjQUFZLGFBQWEsR0FBekI7O0FBRUEsTUFBSSxpQkFBaUIsS0FBSyxPQUFMLENBQXJCO0FBQ0EsTUFBSSxhQUFhLEVBQWpCOztBQUVBLE9BQUssSUFBSSxTQUFTLENBQWxCLEVBQXFCLFNBQVMsZUFBZSxNQUE3QyxFQUFxRCxVQUFVLFNBQS9ELEVBQTBFO0FBQ3hFLFFBQUksUUFBUSxlQUFlLEtBQWYsQ0FBcUIsTUFBckIsRUFBNkIsU0FBUyxTQUF0QyxDQUFaOztBQUVBLFFBQUksY0FBYyxJQUFJLEtBQUosQ0FBVSxNQUFNLE1BQWhCLENBQWxCO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDckMsa0JBQVksQ0FBWixJQUFpQixNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsQ0FBakI7QUFDRDs7QUFFRCxRQUFJLFlBQVksSUFBSSxVQUFKLENBQWUsV0FBZixDQUFoQjs7QUFFQSxlQUFXLElBQVgsQ0FBZ0IsU0FBaEI7QUFDRDs7QUFFRCxNQUFJLE9BQU8sSUFBSSxJQUFKLENBQVMsVUFBVCxFQUFxQixFQUFDLE1BQU0sV0FBUCxFQUFyQixDQUFYO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0F0QkQ7O0FBd0JBLElBQUksT0FBTyxTQUFQLElBQU8sQ0FBVSxRQUFWLEVBQW9CLFFBQXBCLEVBQThCO0FBQ3ZDLE1BQUksa0JBQWtCLFNBQVMsR0FBVCxDQUFhLEVBQUMsT0FBTyxDQUFSLEVBQVcsTUFBTSxJQUFqQixFQUFiLENBQXRCOztBQUVBLE1BQUksVUFBVSxnQkFBZ0IsTUFBaEIsQ0FBdUIsZ0JBQWdCLE9BQWhCLENBQXdCLEdBQXhCLElBQStCLENBQXRELENBQWQ7QUFDQSxTQUFPLFVBQVUsT0FBVixFQUFtQixXQUFuQixDQUFQLEVBQXdDLFFBQXhDO0FBQ0QsQ0FMRDs7QUFPQSxFQUFFLFFBQUYsRUFBWSxLQUFaLENBQWtCLFlBQVk7O0FBRTVCLE1BQUksWUFBWSxFQUFFLHlCQUFGLENBQWhCOztBQUVBLE1BQUksV0FBVyxvQkFBaUI7QUFDOUIsZUFBVztBQURtQixHQUFqQixDQUFmOztBQUlBLFNBQU8sQ0FBUCxHQUFXLE9BQU8sRUFBUCxHQUFZLFFBQXZCO0FBQ0EsY0FBWSxRQUFaLEVBQXNCLFdBQXRCOztBQUVBLElBQUUsYUFBRixFQUFpQixLQUFqQixDQUF1QixZQUFZO0FBQ2pDLE1BQUUsY0FBRixFQUFrQixPQUFsQixDQUEwQixPQUExQjtBQUNELEdBRkQ7O0FBSUEsSUFBRSxjQUFGLEVBQWtCLE1BQWxCLENBQXlCLFlBQVk7QUFDbkMsUUFBSSxFQUFFLElBQUYsRUFBUSxHQUFSLE1BQWlCLEVBQXJCLEVBQXlCO0FBQ3ZCLFVBQUksT0FBTyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQVg7O0FBRUEsZUFBUyxRQUFULEVBQW1CLElBQW5CO0FBQ0Q7QUFDRixHQU5EOztBQVFBLElBQUUsYUFBRixFQUFpQixLQUFqQixDQUF1QixZQUFZO0FBQ2pDLFNBQUssUUFBTCxFQUFlLE9BQWY7QUFDRCxHQUZEOztBQUlBLElBQUUsY0FBRixFQUFrQixLQUFsQixDQUF3QixZQUFZO0FBQ2xDLFFBQUksV0FBVyxhQUFhLGFBQWEsRUFBRSxJQUFGLEVBQVEsQ0FBUixFQUFXLFNBQXhCLEdBQW9DLE1BQWpELENBQWY7QUFDQSxRQUFJLFlBQVksY0FBYyxRQUFkLENBQWhCO0FBQ0EsZ0JBQVksUUFBWixFQUFzQixTQUF0QjtBQUNELEdBSkQ7QUFNRCxDQWpDRDs7Ozs7QUN4RkEsSUFBSSxrQkFBa0I7QUFDdEIsYUFBUyxDQUNMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0FESyxFQWtCTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBbEJLLEVBbUNMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0FuQ0ssRUFvREw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsaUJBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUosMkJBQWUsSUFaWDtBQWFKLHFCQUFTO0FBYkw7QUFEWixLQXBESyxFQXFFTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssZ0JBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBckVLLEVBc0ZMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGlCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0F0RkssRUF1R0w7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGtCQUREO0FBRUoscUJBQUssaUJBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFNBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTO0FBQ0wsNkJBQVM7QUFESixpQkFIYjtBQU1JLHdCQUFRO0FBQ0oseUJBQUssQ0FERDtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQU5aLGFBRGMsQ0FWZDtBQXlCSixzQkFBVSxFQXpCTjtBQTBCSixxQkFBUztBQTFCTDtBQURaLEtBdkdLLEVBcUlMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxnQkFERDtBQUVKLHFCQUFLLGlCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0FySUssRUFzSkw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsaUJBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUosMkJBQWUsSUFaWDtBQWFKLHFCQUFTO0FBYkw7QUFEWixLQXRKSyxFQXVLTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxpQkFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsRUFWZDtBQVdKLHNCQUFVLEVBWE47QUFZSiwyQkFBZSxJQVpYO0FBYUoscUJBQVM7QUFiTDtBQURaLEtBdktLLEVBd0xMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssTUFIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGlCQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLDJCQUFlLElBWlg7QUFhSixxQkFBUztBQWJMO0FBRFosS0F4TEssRUF5TUw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssZ0JBRkQ7QUFHSixxQkFBSyxPQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsZUFSTDtBQVNKLHFCQUFTLEtBVEw7QUFVSiw4QkFBa0IsQ0FDZDtBQUNJLHNCQUFNLFVBRFY7QUFFSSx5QkFBUyxnQkFGYjtBQUdJLHlCQUFTO0FBQ0wsNkJBQVM7QUFESixpQkFIYjtBQU1JLHdCQUFRO0FBQ0oseUJBQUssQ0FERDtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQU5aLGFBRGMsQ0FWZDtBQXlCSixzQkFBVSxFQXpCTjtBQTBCSixxQkFBUztBQTFCTDtBQURaLEtBek1LLEVBdU9MO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGVBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLENBQ2Q7QUFDSSxzQkFBTSxVQURWO0FBRUkseUJBQVMsZ0JBRmI7QUFHSSx5QkFBUztBQUNMLDZCQUFTO0FBREosaUJBSGI7QUFNSSx3QkFBUTtBQUNKLHlCQUFLLENBQUMsRUFERjtBQUVKLHlCQUFLLEVBRkQ7QUFHSix5QkFBSyxNQUhEO0FBSUoseUJBQUs7QUFKRDtBQU5aLGFBRGMsQ0FWZDtBQXlCSixzQkFBVSxFQXpCTjtBQTBCSixxQkFBUztBQTFCTDtBQURaLEtBdk9LLEVBcVFMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGdCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLEtBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLEVBVmQ7QUFXSixzQkFBVSxFQVhOO0FBWUoscUJBQVM7QUFaTDtBQURaLEtBclFLLEVBcVJMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxRQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxrQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGVBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLENBQ2Q7QUFDSSxzQkFBTSxTQURWO0FBRUkseUJBQVMsZ0JBRmI7QUFHSSx5QkFBUztBQUNMLDZCQUFTO0FBREosaUJBSGI7QUFNSSx3QkFBUTtBQUNKLHlCQUFLLENBREQ7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQXJSSyxFQW1UTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sUUFERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssa0JBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxLQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixFQVZkO0FBV0osc0JBQVUsRUFYTjtBQVlKLHFCQUFTO0FBWkw7QUFEWixLQW5USyxFQW1VTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxrQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVM7QUFDTCw2QkFBUztBQURKLGlCQUhiO0FBTUksd0JBQVE7QUFDSix5QkFBSyxDQUFDLEVBREY7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQW5VSyxFQWlXTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxTQVJMO0FBU0osOEJBQWtCLEVBVGQ7QUFVSixzQkFBVSxFQVZOO0FBV0oscUJBQVM7QUFYTDtBQURaLEtBaldLLEVBZ1hMO0FBQ0ksZ0JBQVE7QUFDSixrQkFBTSxTQURGO0FBRUosb0JBQVE7QUFDSixxQkFBSyxpQkFERDtBQUVKLHFCQUFLLGtCQUZEO0FBR0oscUJBQUssT0FIRDtBQUlKLHFCQUFLO0FBSkQsYUFGSjtBQVFKLHFCQUFTLGVBUkw7QUFTSixxQkFBUyxLQVRMO0FBVUosOEJBQWtCLENBQ2Q7QUFDSSxzQkFBTSxVQURWO0FBRUkseUJBQVMsZ0JBRmI7QUFHSSx5QkFBUyxFQUhiO0FBSUksd0JBQVE7QUFDSix5QkFBSyxDQUREO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBSlosYUFEYyxDQVZkO0FBdUJKLHNCQUFVLEVBdkJOO0FBd0JKLHFCQUFTO0FBeEJMO0FBRFosS0FoWEssRUE0WUw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGtCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsU0FSTDtBQVNKLDhCQUFrQixFQVRkO0FBVUosc0JBQVUsRUFWTjtBQVdKLHFCQUFTO0FBWEw7QUFEWixLQTVZSyxFQTJaTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVMsRUFIYjtBQUlJLHdCQUFRO0FBQ0oseUJBQUssQ0FBQyxFQURGO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBSlosYUFEYyxDQVZkO0FBdUJKLHNCQUFVLEVBdkJOO0FBd0JKLHFCQUFTO0FBeEJMO0FBRFosS0EzWkssRUF1Ykw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFFBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsU0FSTDtBQVNKLDhCQUFrQixFQVRkO0FBVUosc0JBQVUsRUFWTjtBQVdKLHFCQUFTO0FBWEw7QUFEWixLQXZiSyxFQXNjTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVMsRUFIYjtBQUlJLHdCQUFRO0FBQ0oseUJBQUssQ0FBQyxFQURGO0FBRUoseUJBQUssRUFGRDtBQUdKLHlCQUFLLE1BSEQ7QUFJSix5QkFBSztBQUpEO0FBSlosYUFEYyxDQVZkO0FBdUJKLHNCQUFVLEVBdkJOO0FBd0JKLHFCQUFTO0FBeEJMO0FBRFosS0F0Y0ssRUFrZUw7QUFDSSxnQkFBUTtBQUNKLGtCQUFNLFNBREY7QUFFSixvQkFBUTtBQUNKLHFCQUFLLGlCQUREO0FBRUoscUJBQUssa0JBRkQ7QUFHSixxQkFBSyxNQUhEO0FBSUoscUJBQUs7QUFKRCxhQUZKO0FBUUoscUJBQVMsU0FSTDtBQVNKLDhCQUFrQixFQVRkO0FBVUosc0JBQVUsRUFWTjtBQVdKLHFCQUFTO0FBWEw7QUFEWixLQWxlSyxFQWlmTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE1BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxTQVJMO0FBU0osOEJBQWtCLEVBVGQ7QUFVSixzQkFBVSxFQVZOO0FBV0oscUJBQVM7QUFYTDtBQURaLEtBamZLLEVBZ2dCTDtBQUNJLGdCQUFRO0FBQ0osa0JBQU0sU0FERjtBQUVKLG9CQUFRO0FBQ0oscUJBQUssaUJBREQ7QUFFSixxQkFBSyxpQkFGRDtBQUdKLHFCQUFLLE9BSEQ7QUFJSixxQkFBSztBQUpELGFBRko7QUFRSixxQkFBUyxlQVJMO0FBU0oscUJBQVMsS0FUTDtBQVVKLDhCQUFrQixDQUNkO0FBQ0ksc0JBQU0sVUFEVjtBQUVJLHlCQUFTLGdCQUZiO0FBR0kseUJBQVM7QUFDTCw2QkFBUztBQURKLGlCQUhiO0FBTUksd0JBQVE7QUFDSix5QkFBSyxDQUFDLEVBREY7QUFFSix5QkFBSyxFQUZEO0FBR0oseUJBQUssTUFIRDtBQUlKLHlCQUFLO0FBSkQ7QUFOWixhQURjLENBVmQ7QUF5Qkosc0JBQVUsRUF6Qk47QUEwQkoscUJBQVM7QUExQkw7QUFEWixLQWhnQkssQ0FEYTtBQWdpQnRCLGFBQVMsQ0FDTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FESyxFQVlMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQVpLLEVBdUJMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXZCSyxFQWtDTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsV0FETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FsQ0ssRUE2Q0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBN0NLLEVBd0RMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFFBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsUUFOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXhESyxFQW1FTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FuRUssRUE4RUw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBOUVLLEVBeUZMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxRQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXpGSyxFQW9HTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsV0FETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FwR0ssRUErR0w7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFdBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBL0dLLEVBMEhMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxZQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTFISyxFQXFJTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsWUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FySUssRUFnSkw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBaEpLLEVBMkpMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTNKSyxFQXNLTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0F0S0ssRUFpTEw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFdBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBakxLLEVBNExMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxXQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQTVMSyxFQXVNTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsaUJBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBdk1LLEVBa05MO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxpQkFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxRQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFFBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FsTkssRUE2Tkw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsUUFKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxRQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBN05LLEVBd09MO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXhPSyxFQW1QTDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsUUFMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FuUEssRUE4UEw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLGFBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFFBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBOVBLLEVBeVFMO0FBQ0ksZ0JBQVE7QUFDSixxQkFBUyxhQURMO0FBRUosa0NBQXNCLEVBRmxCO0FBR0osMkJBQWUsQ0FIWDtBQUlKLHNCQUFVLFNBSk47QUFLSixzQkFBVSxTQUxOO0FBTUosMEJBQWMsU0FOVjtBQU9KLDBCQUFjO0FBUFY7QUFEWixLQXpRSyxFQW9STDtBQUNJLGdCQUFRO0FBQ0oscUJBQVMsYUFETDtBQUVKLGtDQUFzQixFQUZsQjtBQUdKLDJCQUFlLENBSFg7QUFJSixzQkFBVSxTQUpOO0FBS0osc0JBQVUsU0FMTjtBQU1KLDBCQUFjLFNBTlY7QUFPSiwwQkFBYztBQVBWO0FBRFosS0FwUkssRUErUkw7QUFDSSxnQkFBUTtBQUNKLHFCQUFTLFlBREw7QUFFSixrQ0FBc0IsRUFGbEI7QUFHSiwyQkFBZSxDQUhYO0FBSUosc0JBQVUsU0FKTjtBQUtKLHNCQUFVLFNBTE47QUFNSiwwQkFBYyxTQU5WO0FBT0osMEJBQWM7QUFQVjtBQURaLEtBL1JLO0FBaGlCYSxDQUF0Qjs7QUE2MEJBLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7O0FDNzBCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4L0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNobkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3JjQSxJQUFJLFlBQVksUUFBUSxXQUFSLENBQWhCO0FBQ0EsSUFBSSxlQUFlLFFBQVEscUJBQVIsQ0FBbkI7O0FBRUEsSUFBSSxpQkFBaUIsUUFBUSxtQkFBUixDQUFyQjs7QUFFQSxJQUFJLGlCQUFpQjtBQUNuQixTQUFPLGVBQWUsU0FBZixDQURZO0FBRW5CLHVCQUFxQixJQUZGO0FBR25CLGVBQWEsS0FITTtBQUluQixXQUFTLEtBSlU7QUFLbkIsV0FBUyxLQUxVO0FBTW5CLGNBQVksS0FOTztBQU9uQixvQkFBa0I7QUFQQyxDQUFyQjs7SUFVTSxZOzs7QUFDSix3QkFBYSxPQUFiLEVBQXNCO0FBQUE7O0FBQUEsdUhBQ2IsYUFBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBRGE7QUFFckI7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7RUFUMkIsUzs7QUFZM0IsT0FBTyxPQUFQLEdBQWlCLFlBQWpCOzs7OztBQzNCQSxJQUFJLGVBQWUsRUFBbkI7O0FBRUEsYUFBYSxTQUFiLEdBQXlCLFVBQUMsSUFBRCxFQUFVO0FBQ2pDLE1BQUksWUFBWSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCO0FBQ0EsTUFBSSxVQUFVLFFBQVYsQ0FBbUIsV0FBbkIsQ0FBSixFQUFxQztBQUNuQyxnQkFBWSxVQUFVLE9BQVYsQ0FBa0IsV0FBbEIsRUFBK0IsRUFBL0IsQ0FBWjtBQUNEOztBQUVELE1BQUksYUFBYSxXQUFqQixFQUE4QjtBQUM1QixXQUFPLFNBQVA7QUFDRDs7QUFFRCxNQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDMUIsV0FBTyxRQUFQO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLGtCQUFiLElBQW1DLGFBQWEsS0FBaEQsSUFDQyxhQUFhLGlCQURkLElBQ21DLGFBQWEsYUFEaEQsSUFDaUUsYUFBYSxTQURsRixFQUM2RjtBQUMzRixXQUFPLFNBQVA7QUFDRDs7QUFFRCxNQUFJLGFBQWEsY0FBakIsRUFBaUM7QUFDL0IsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSyxhQUFhLHNCQUFiLElBQXVDLGFBQWEsZUFBekQsRUFBMEU7QUFDeEUsV0FBTyxnQkFBUDtBQUNEO0FBQ0QsU0FBTyxTQUFQO0FBQ0QsQ0EzQkQ7O0FBNkJBLGFBQWEsY0FBYixHQUE4QixVQUFDLElBQUQsRUFBVTtBQUN0QyxNQUFJLFlBQVksS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQjtBQUNBLE1BQUksYUFBYSx1QkFBakIsRUFBMEM7QUFDeEMsV0FBTyxnQkFBUDtBQUNEO0FBQ0QsTUFBSSxhQUFhLFlBQWpCLEVBQStCO0FBQzdCLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSSxhQUFhLFdBQWpCLEVBQThCO0FBQzVCLFdBQU8sUUFBUDtBQUNEO0FBQ0QsTUFBSSxhQUFhLGFBQWIsSUFBOEIsYUFBYSxZQUEvQyxFQUE2RDtBQUMzRCxXQUFPLFVBQVA7QUFDRDtBQUNELE1BQUksYUFBYSxZQUFqQixFQUErQjtBQUM3QixXQUFPLFNBQVA7QUFDRDtBQUNELFNBQU8sTUFBUDtBQUNELENBbEJEOztBQW9CQSxhQUFhLFdBQWIsR0FBMkIsVUFBQyxJQUFELEVBQVU7QUFDbkMsTUFBSSxZQUFZLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEI7QUFDQSxNQUFJLFVBQVUsRUFBZDs7QUFFQSxNQUFJLFVBQVUsUUFBVixDQUFtQixXQUFuQixDQUFKLEVBQXFDO0FBQ25DLGdCQUFZLFVBQVUsT0FBVixDQUFrQixXQUFsQixFQUErQixFQUEvQixDQUFaO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLGVBQWIsSUFBZ0MsYUFBYSxpQkFBN0MsSUFDRyxhQUFhLFdBRGhCLElBRUcsYUFBYSxvQkFGaEIsSUFFd0MsYUFBYSxzQkFGckQsSUFHRyxhQUFhLGtCQUhoQixJQUdzQyxhQUFhLEtBSHZELEVBRzhEO0FBQzVELGNBQVUsS0FBSyxJQUFMLENBQVUsT0FBVixJQUFxQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQXJCLEdBQTBDLEVBQXBEO0FBQ0QsR0FMRCxNQU1LLElBQUcsYUFBYSxhQUFoQixFQUE4QjtBQUNqQyxjQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsSUFBcUIsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFyQixHQUEwQyxFQUFwRDtBQUNELEdBRkksTUFHQSxJQUFHLGFBQWEsU0FBaEIsRUFBMEI7QUFDN0IsUUFBRyxLQUFLLFFBQUwsR0FBZ0IsTUFBaEIsSUFBMEIsQ0FBN0IsRUFBK0I7QUFDN0IsVUFBRyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQUgsRUFBc0I7QUFDcEIsa0JBQVUsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFWO0FBQ0QsT0FGRCxNQUdLLElBQUcsS0FBSyxJQUFMLENBQVUsV0FBVixDQUFILEVBQTBCO0FBQzdCLGtCQUFVLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBVjtBQUNELE9BRkksTUFHRDtBQUNGLGtCQUFVLEVBQVY7QUFDRDtBQUNGLEtBVkQsTUFXSTtBQUNGLGdCQUFVLEVBQVY7QUFDRDtBQUNGLEdBZkksTUFnQkEsSUFBSSxhQUFhLEtBQWpCLEVBQXdCO0FBQzNCLGNBQVUsS0FBVjtBQUNELEdBRkksTUFHQSxJQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDMUIsY0FBVSxJQUFWO0FBQ0QsR0FGSSxNQUdBLElBQUksYUFBYSxLQUFqQixFQUF3QjtBQUMzQixjQUFVLEtBQVY7QUFDRCxHQUZJLE1BR0EsSUFBSSxhQUFhLGlCQUFqQixFQUFvQztBQUN2QyxjQUFVLE1BQVY7QUFDRCxHQUZJLE1BR0EsSUFBSSxhQUFhLG1CQUFqQixFQUFzQztBQUN6QyxjQUFVLEdBQVY7QUFDRDs7QUFFRCxTQUFPLE9BQVA7QUFDRCxDQWxERDs7QUFvREEsSUFBTSx1QkFBdUIsU0FBdkIsb0JBQXVCLENBQUMsVUFBRCxFQUFxQztBQUFBLE1BQXhCLGVBQXdCLHVFQUFOLENBQU07O0FBQ2hFLFNBQVEsYUFBYSxJQUFkLEdBQXNCLGVBQTdCO0FBQ0QsQ0FGRDs7QUFJQSxhQUFhLGFBQWIsR0FBNkIsVUFBQyxJQUFELEVBQVU7QUFDckMsTUFBTSxZQUFZLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBbEI7QUFDQSxNQUFNLEtBQUssS0FBSyxNQUFMLEVBQVg7O0FBRUE7QUFDQTtBQUNBLE1BQUksY0FBYyxhQUFkLElBQStCLGNBQWMsY0FBakQsRUFBaUU7QUFDL0QsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSSxjQUFjLEtBQWQsSUFBdUIsY0FBYyxJQUFyQyxJQUE2QyxjQUFjLEtBQS9ELEVBQXNFO0FBQ3BFLFdBQU8scUJBQXFCLEVBQXJCLEVBQXlCLENBQXpCLENBQVA7QUFDRDs7QUFFRCxNQUFJLFVBQVUsUUFBVixDQUFtQixTQUFuQixDQUFKLEVBQW1DO0FBQ2pDLFdBQU8scUJBQXFCLEVBQXJCLEVBQXlCLEdBQXpCLENBQVA7QUFDRDs7QUFFRCxNQUFJLGNBQWMsU0FBZCxJQUEyQixjQUFjLGFBQTdDLEVBQTREO0FBQzFELFdBQU8sRUFBUDtBQUNEOztBQUVELFNBQU8scUJBQXFCLEVBQXJCLENBQVA7QUFDRCxDQXZCRDs7QUF5QkEsYUFBYSxtQkFBYixHQUFtQyxVQUFDLElBQUQsRUFBVTtBQUMzQyxNQUFNLFNBQVMsS0FBSyxNQUFMLEdBQWMsUUFBZCxFQUFmO0FBQ0EsTUFBTSxTQUFTLEtBQUssTUFBTCxHQUFjLFFBQWQsRUFBZjs7QUFFQSxNQUFNLFdBQVcsS0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLENBQVUsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUE1QixFQUFnQyxDQUFoQyxJQUFxQyxLQUFLLEdBQUwsQ0FBVSxPQUFPLENBQVAsR0FBVyxPQUFPLENBQTVCLEVBQWdDLENBQWhDLENBQS9DLENBQWpCO0FBQ0EsU0FBTyxXQUFXLElBQWxCO0FBQ0QsQ0FORDs7QUFRQSxPQUFPLE9BQVAsR0FBaUIsWUFBakI7Ozs7Ozs7OztBQzVJQSxJQUFNLGFBQWE7QUFDakIsY0FEaUIsd0JBQ0gsUUFERyxFQUNPO0FBQ3RCLGdCQUFVLDZCQUFJLFFBQUosR0FBYyxHQUFkLENBQWtCO0FBQUE7QUFBQSxVQUFFLENBQUY7QUFBQSxVQUFLLENBQUw7O0FBQUEsYUFBZSxDQUFmLFVBQXFCLENBQXJCO0FBQUEsS0FBbEIsRUFBNkMsSUFBN0MsQ0FBa0QsR0FBbEQsQ0FBVjtBQUNELEdBSGdCO0FBS2pCLGVBTGlCLHlCQUtGLENBTEUsRUFLQyxDQUxELEVBS0ksQ0FMSixFQUtPLENBTFAsRUFLVSxFQUxWLEVBS2MsRUFMZCxFQUtrQixFQUxsQixFQUtzQixFQUx0QixFQUswQixRQUwxQixFQUtvQztBQUNuRCxvQ0FDZSxLQUFLLFlBQUwsQ0FBa0IsUUFBbEIsQ0FEZiwwQkFFTSxJQUFJLEVBRlYsVUFFZ0IsQ0FGaEIsbUJBR00sSUFBSSxDQUFKLEdBQVEsRUFIZCxVQUdvQixDQUhwQixZQUcyQixJQUFJLENBSC9CLFVBR29DLENBSHBDLFVBR3lDLElBQUksQ0FIN0MsV0FHa0QsSUFBSSxFQUh0RCxvQkFJTSxJQUFJLENBSlYsV0FJZ0IsSUFBSSxDQUFKLEdBQVEsRUFKeEIsYUFJZ0MsSUFBSSxDQUpwQyxXQUl5QyxJQUFJLENBSjdDLFdBSWtELElBQUksQ0FBSixHQUFRLEVBSjFELFdBSWdFLElBQUksQ0FKcEUsb0JBS00sSUFBSSxFQUxWLFdBS2dCLElBQUksQ0FMcEIsWUFLMkIsQ0FMM0IsVUFLZ0MsSUFBSSxDQUxwQyxVQUt5QyxDQUx6QyxVQUs4QyxJQUFJLENBQUosR0FBUSxFQUx0RCxtQkFNTSxDQU5OLFVBTVcsSUFBSSxFQU5mLFlBTXVCLENBTnZCLFNBTTRCLENBTjVCLFVBTWlDLElBQUksRUFOckMsVUFNMkMsQ0FOM0M7QUFVRCxHQWhCZ0I7QUFrQmpCLFFBbEJpQixrQkFrQlQsS0FsQlMsRUFrQkYsTUFsQkUsRUFrQk0sUUFsQk4sRUFrQmdCO0FBQy9CLGtDQUVZLEtBQUssWUFBTCxDQUFrQixRQUFsQixDQUZaLDZCQUdlLElBQUUsS0FIakIsU0FHMEIsTUFBSSxNQUg5QixXQUcwQyxJQUFFLEtBSDVDLFNBR3FELE1BQUksTUFIekQsV0FHcUUsT0FBSyxLQUgxRSxTQUdtRixNQUhuRixTQUc2RixPQUFLLEtBSGxHLFNBRzJHLE1BSDNHLGdDQUtlLE9BQUssS0FMcEIsU0FLNkIsTUFMN0IsV0FLeUMsT0FBSyxLQUw5QyxTQUt1RCxNQUx2RCxXQUttRSxPQUFLLEtBTHhFLFNBS2lGLE1BTGpGLFNBSzJGLEtBTDNGLFNBS29HLE9BQUssTUFMekcsZ0NBT2UsS0FQZixTQU93QixNQUFJLE1BUDVCLFdBT3dDLEtBUHhDLFNBT2lELE9BQUssTUFQdEQsV0FPa0UsS0FQbEUsU0FPMkUsSUFBRSxNQVA3RSxTQU91RixPQUFLLEtBUDVGLFNBT3FHLElBQUUsTUFQdkcsZ0NBU2UsT0FBSyxLQVRwQixTQVM2QixJQUFFLE1BVC9CLFdBUzJDLE9BQUssS0FUaEQsU0FTeUQsSUFBRSxNQVQzRCxXQVN1RSxPQUFLLEtBVDVFLFNBU3FGLElBQUUsTUFUdkYsU0FTaUcsSUFBRSxLQVRuRyxTQVM0RyxPQUFLLE1BVGpIO0FBYUQsR0FoQ2dCO0FBa0NqQixRQWxDaUIsa0JBa0NULEVBbENTLEVBa0NMLEVBbENLLEVBa0NELENBbENDLEVBa0NFLFFBbENGLEVBa0NZO0FBQzNCLDZCQUFzQixFQUF0QixnQkFBaUMsRUFBakMsZUFBMkMsQ0FBM0MsbUJBQXdELEtBQUssWUFBTCxDQUFrQixRQUFsQixDQUF4RDtBQUNELEdBcENnQjtBQXNDakIsZ0JBdENpQiwwQkFzQ0QsS0F0Q0MsRUFzQ00sTUF0Q04sRUFzQ2MsUUF0Q2QsRUFzQ3dCO0FBQ3ZDLHVDQUNrQixLQUFLLFlBQUwsQ0FBa0IsUUFBbEIsQ0FEbEIsMkJBRVksQ0FGWixVQUVrQixDQUZsQixVQUV3QixLQUZ4QixVQUVrQyxDQUZsQyxVQUV3QyxPQUFLLEtBRjdDLFVBRXVELE1BQUksTUFGM0QsVUFFc0UsS0FGdEUsVUFFZ0YsTUFGaEYsVUFFMkYsQ0FGM0YsVUFFaUcsTUFGakcsVUFFNEcsT0FBSyxLQUZqSCxVQUUySCxNQUFJLE1BRi9IO0FBSUQsR0EzQ2dCO0FBNkNqQixjQTdDaUIsd0JBNkNILEtBN0NHLEVBNkNJLE1BN0NKLEVBNkNZLFFBN0NaLEVBNkNzQjtBQUNyQyx1Q0FDa0IsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGxCLG1DQUdJLElBQUUsS0FITixTQUdlLE9BQUssTUFIcEIsU0FHOEIsT0FBSyxLQUhuQyxTQUc0QyxJQUFFLE1BSDlDLFNBR3dELE9BQUssS0FIN0QsU0FHc0UsSUFBRSxNQUh4RSxTQUdrRixLQUhsRixTQUcyRixPQUFLLE1BSGhHLGdCQUlJLEtBSkosU0FJYSxPQUFLLE1BSmxCLFNBSTRCLE9BQUssS0FKakMsU0FJMEMsTUFKMUMsU0FJb0QsT0FBSyxLQUp6RCxTQUlrRSxNQUpsRSxTQUk0RSxJQUFFLEtBSjlFLFNBSXVGLE9BQUssTUFKNUY7QUFRRCxHQXREZ0I7QUF3RGpCLFNBeERpQixtQkF3RFIsRUF4RFEsRUF3REosRUF4REksRUF3REEsRUF4REEsRUF3REksRUF4REosRUF3RFEsUUF4RFIsRUF3RGtCO0FBQ2pDLHNDQUNpQixFQURqQixnQkFDNEIsRUFENUIsZ0JBQ3VDLEVBRHZDLGdCQUNrRCxFQURsRCxtQkFDZ0UsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGhFO0FBR0QsR0E1RGdCO0FBOERqQixTQTlEaUIsbUJBOERSLEtBOURRLEVBOERELE1BOURDLEVBOERPLFFBOURQLEVBOERpQjtBQUNoQyx1Q0FDa0IsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBRGxCLDJCQUVZLENBRlosVUFFa0IsTUFBSSxNQUZ0QixVQUVpQyxPQUFLLEtBRnRDLFVBRWdELElBQUUsTUFGbEQsVUFFNkQsT0FBSyxLQUZsRSxVQUU0RSxJQUFFLE1BRjlFLFVBRXlGLEtBRnpGLFVBRW1HLE1BQUksTUFGdkcsVUFFa0gsT0FBSyxLQUZ2SCxVQUVpSSxNQUZqSSxVQUU0SSxPQUFLLEtBRmpKLFVBRTJKLE1BRjNKO0FBSUQsR0FuRWdCO0FBcUVqQixNQXJFaUIsZ0JBcUVYLEVBckVXLEVBcUVQLEVBckVPLEVBcUVILEVBckVHLEVBcUVDLEVBckVELEVBcUVLLFFBckVMLEVBcUVlO0FBQzlCLDJCQUFvQixFQUFwQixnQkFBK0IsRUFBL0IsZ0JBQTBDLEVBQTFDLGdCQUFxRCxFQUFyRCxtQkFBbUUsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBQW5FO0FBQ0QsR0F2RWdCO0FBeUVqQixXQXpFaUIscUJBeUVOLENBekVNLEVBeUVILENBekVHLEVBeUVBLEtBekVBLEVBeUVPLE1BekVQLEVBeUVlLFFBekVmLEVBeUV5QjtBQUN4QyxXQUFPLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRCxFQUFvRCxRQUFwRCxDQUFQO0FBQ0QsR0EzRWdCO0FBNkVqQixzQkE3RWlCLGdDQTZFSyxDQTdFTCxFQTZFUSxDQTdFUixFQTZFVyxLQTdFWCxFQTZFa0IsTUE3RWxCLEVBNkUwQixRQTdFMUIsRUE2RW9DO0FBQ25ELFdBQU8sS0FBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLEtBQXpCLEVBQWdDLE1BQWhDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLEtBQUcsTUFBakQsRUFBeUQsS0FBRyxNQUE1RCxFQUFvRSxRQUFwRSxDQUFQO0FBQ0QsR0EvRWdCO0FBaUZqQixnQkFqRmlCLDBCQWlGRCxDQWpGQyxFQWlGRSxDQWpGRixFQWlGSyxLQWpGTCxFQWlGWSxNQWpGWixFQWlGb0IsUUFqRnBCLEVBaUY4QjtBQUM3QyxXQUFPLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxFQUF3QyxLQUFHLE1BQTNDLEVBQW1ELEtBQUcsTUFBdEQsRUFBOEQsS0FBRyxNQUFqRSxFQUF5RSxLQUFHLE1BQTVFLEVBQW9GLFFBQXBGLENBQVA7QUFDRCxHQW5GZ0I7QUFxRmpCLFFBckZpQixrQkFxRlQsQ0FyRlMsRUFxRk4sQ0FyRk0sRUFxRkgsTUFyRkcsRUFxRkssUUFyRkwsRUFxRmU7QUFDOUIsV0FBTyxLQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsRUFBaUMsTUFBakMsRUFBeUMsQ0FBekMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QsQ0FBbEQsRUFBcUQsUUFBckQsQ0FBUDtBQUNELEdBdkZnQjtBQXlGakIsTUF6RmlCLGdCQXlGWCxDQXpGVyxFQXlGUixDQXpGUSxFQXlGTCxDQXpGSyxFQXlGRixVQXpGRSxFQXlGVSxRQXpGVixFQXlGb0I7QUFDbkMsMEJBQW1CLENBQW5CLGVBQTRCLENBQTVCLHdCQUE4QyxVQUE5QyxtQkFBb0UsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBQXBFLFdBQW9HLENBQXBHO0FBQ0Q7QUEzRmdCLENBQW5COztBQWdHQSxPQUFPLE9BQVAsR0FBaUIsVUFBakI7Ozs7O0FDaEdBLElBQU0sYUFBYSxRQUFRLGlCQUFSLENBQW5CO0FBQ0EsSUFBTSxTQUFTLFFBQVEsZ0JBQVIsQ0FBZjs7QUFFQSxJQUFNLGlCQUFpQjtBQUVyQixhQUZxQix1QkFFUixJQUZRLEVBRUY7QUFDakIsUUFBTSxLQUFLLEtBQUssV0FBTCxFQUFYO0FBQ0EsUUFBTSxLQUFLLEtBQUssVUFBTCxFQUFYOztBQUVBLFFBQU0sUUFBUSxJQUFJLEdBQUosR0FDWCxHQURXLENBQ1AsY0FETyxFQUNTLE1BRFQsRUFFWCxHQUZXLENBRVAsTUFGTyxFQUVDLE1BRkQsRUFHWCxHQUhXLENBR1AsUUFITyxFQUdHLFNBSEgsQ0FBZDs7QUFLQSxRQUFNLDhCQUVGLFdBQVcsTUFBWCxDQUFrQixFQUFsQixFQUFzQixFQUF0QixFQUEwQixLQUExQixDQUZFLFdBQU47QUFJQSxXQUFPLE9BQU8sY0FBUCxFQUF1QixFQUF2QixFQUEyQixFQUEzQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxDQUFQO0FBQ0Q7QUFoQm9CLENBQXZCOztBQW1CQSxPQUFPLE9BQVAsR0FBaUIsY0FBakI7Ozs7O0FDdEJBLElBQU0sYUFBYSxRQUFRLGlCQUFSLENBQW5CO0FBQ0EsSUFBTSxTQUFTLFFBQVEsZ0JBQVIsQ0FBZjs7QUFFQSxJQUFNLGtCQUFrQjtBQUV0QixtQkFGc0IsNkJBRUgsSUFGRyxFQUVHO0FBQ3ZCLFFBQUksS0FBSyxLQUFLLEtBQUwsRUFBVDtBQUNBLFFBQUksS0FBSyxLQUFLLE1BQUwsRUFBVDs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGNBRlUsRUFFTSxHQUZOLEVBR2QsR0FIYyxDQUdWLE1BSFUsRUFHRixNQUhFLENBQWY7O0FBS0EsUUFBSSwrQkFFQSxXQUFXLE9BQVgsQ0FBbUIsS0FBSyxDQUF4QixFQUEyQixLQUFLLENBQWhDLEVBQW1DLENBQUUsS0FBSyxDQUFQLElBQWEsQ0FBaEQsRUFBbUQsQ0FBRSxLQUFLLENBQVAsSUFBYSxDQUFoRSxFQUFtRSxRQUFuRSxDQUZBLFdBQUo7QUFJQSxXQUFPLE9BQU8sZUFBUCxFQUF3QixFQUF4QixFQUE0QixFQUE1QixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxFQUF0QyxFQUEwQyxFQUExQyxDQUFQO0FBQ0QsR0FoQnFCO0FBa0J0QixnQkFsQnNCLDBCQWtCTixJQWxCTSxFQWtCQTtBQUNwQixRQUFJLEtBQUssS0FBSyxLQUFMLEVBQVQ7QUFDQSxRQUFJLEtBQUssS0FBSyxNQUFMLEVBQVQ7O0FBRUEsUUFBSSxXQUFXLElBQUksR0FBSixHQUNkLEdBRGMsQ0FDVixRQURVLEVBQ0EsU0FEQSxFQUVkLEdBRmMsQ0FFVixjQUZVLEVBRU0sR0FGTixFQUdkLEdBSGMsQ0FHVixNQUhVLEVBR0YsTUFIRSxDQUFmOztBQUtBLFFBQUksaUNBRUEsV0FBVyxNQUFYLENBQWtCLEtBQUssQ0FBdkIsRUFBMEIsS0FBSyxDQUEvQixFQUFrQyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQTNELEVBQThELFFBQTlELENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxpQkFBUCxFQUEwQixFQUExQixFQUE4QixFQUE5QixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxFQUF4QyxFQUE0QyxFQUE1QyxDQUFQO0FBQ0QsR0FoQ3FCO0FBa0N0QixlQWxDc0IseUJBa0NQLElBbENPLEVBa0NEO0FBQ25CLFFBQUksS0FBSyxLQUFLLEtBQUwsRUFBVDtBQUNBLFFBQUksS0FBSyxLQUFLLE1BQUwsRUFBVDs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGNBRlUsRUFFTSxHQUZOLEVBR2QsR0FIYyxDQUdWLE1BSFUsRUFHRixNQUhFLENBQWY7O0FBS0EsUUFBSSxnQ0FFQSxXQUFXLGNBQVgsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsRUFBaEMsRUFBb0MsRUFBcEMsRUFBd0MsUUFBeEMsQ0FGQSxXQUFKO0FBSUEsV0FBTyxPQUFPLGdCQUFQLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDLEVBQXVDLEVBQXZDLEVBQTJDLEVBQTNDLENBQVA7QUFDRCxHQWhEcUI7QUFrRHRCLG9CQWxEc0IsOEJBa0RGLElBbERFLEVBa0RJO0FBQ3hCLFFBQUksS0FBSyxLQUFLLEtBQUwsRUFBVDtBQUNBLFFBQUksS0FBSyxLQUFLLE1BQUwsRUFBVDs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGNBRlUsRUFFTSxHQUZOLEVBR2QsR0FIYyxDQUdWLE1BSFUsRUFHRixNQUhFLENBQWY7O0FBS0EsUUFBSSxxQ0FFQSxXQUFXLG9CQUFYLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLEVBQXRDLEVBQTBDLEVBQTFDLEVBQThDLFFBQTlDLENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxxQkFBUCxFQUE4QixFQUE5QixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxFQUE1QyxFQUFnRCxFQUFoRCxDQUFQO0FBQ0QsR0FoRXFCO0FBa0V0QixTQWxFc0IsbUJBa0ViLElBbEVhLEVBa0VQO0FBQ2IsUUFBSSxLQUFLLEtBQUssVUFBTCxFQUFUO0FBQ0EsUUFBSSxLQUFLLEtBQUssV0FBTCxFQUFUOztBQUVBLFFBQUksV0FBVyxJQUFJLEdBQUosR0FDZCxHQURjLENBQ1YsUUFEVSxFQUNBLFNBREEsRUFFZCxHQUZjLENBRVYsY0FGVSxFQUVNLEdBRk4sRUFHZCxHQUhjLENBR1YsTUFIVSxFQUdGLE1BSEUsQ0FBZjs7QUFLQSxRQUFJLDBCQUVBLFdBQVcsWUFBWCxDQUF3QixFQUF4QixFQUE0QixFQUE1QixFQUFnQyxRQUFoQyxDQUZBLFdBQUo7QUFJQSxXQUFPLE9BQU8sVUFBUCxFQUFtQixFQUFuQixFQUF1QixFQUF2QixFQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQyxFQUFqQyxFQUFxQyxFQUFyQyxDQUFQO0FBQ0QsR0FoRnFCO0FBa0Z0QixlQWxGc0IseUJBa0ZQLElBbEZPLEVBa0ZEO0FBQ25CLFFBQUksY0FBYyxLQUFLLEtBQUwsS0FBZSxDQUFqQztBQUNBLFFBQUksY0FBYyxLQUFLLE1BQUwsS0FBZ0IsQ0FBbEM7QUFDQSxRQUFJLGVBQWUsQ0FBQyxLQUFLLEtBQUwsS0FBZSxDQUFoQixJQUFxQixDQUF4Qzs7QUFFQSxRQUFJLFdBQVcsSUFBSSxHQUFKLEdBQ2QsR0FEYyxDQUNWLFFBRFUsRUFDQSxTQURBLEVBRWQsR0FGYyxDQUVWLGdCQUZVLEVBRVEsUUFGUixFQUdkLEdBSGMsQ0FHVixjQUhVLEVBR00sS0FITixFQUlkLEdBSmMsQ0FJVixNQUpVLEVBSUYsTUFKRSxDQUFmOztBQU1BLFFBQU0sZ0NBRUYsV0FBVyxNQUFYLENBQWtCLFdBQWxCLEVBQStCLFdBQS9CLEVBQTRDLFlBQTVDLEVBQTBELFFBQTFELENBRkUsZ0JBR0YsV0FBVyxJQUFYLENBQWdCLENBQWhCLEVBQW1CLEtBQUssTUFBTCxFQUFuQixFQUFrQyxLQUFLLEtBQUwsRUFBbEMsRUFBZ0QsQ0FBaEQsRUFBbUQsUUFBbkQsQ0FIRSxXQUFOO0FBS0EsV0FBTyxPQUFPLGdCQUFQLEVBQXlCLEtBQUssS0FBTCxFQUF6QixFQUF1QyxLQUFLLE1BQUwsRUFBdkMsRUFBc0QsQ0FBdEQsRUFBeUQsQ0FBekQsRUFBNEQsS0FBSyxLQUFMLEVBQTVELEVBQTBFLEtBQUssTUFBTCxFQUExRSxDQUFQO0FBQ0QsR0FuR3FCO0FBcUd0QixpQkFyR3NCLDJCQXFHTCxJQXJHSyxFQXFHQztBQUNyQixRQUFJLEtBQUssS0FBSyxLQUFMLEVBQVQ7QUFDQSxRQUFJLEtBQUssS0FBSyxNQUFMLEVBQVQ7O0FBRUEsUUFBSSxXQUFXLElBQUksR0FBSixHQUNkLEdBRGMsQ0FDVixRQURVLEVBQ0EsU0FEQSxFQUVkLEdBRmMsQ0FFVixjQUZVLEVBRU0sR0FGTixFQUdkLEdBSGMsQ0FHVixNQUhVLEVBR0YsTUFIRSxDQUFmOztBQUtBLFFBQUksa0NBRUEsV0FBVyxjQUFYLENBQTBCLEVBQTFCLEVBQThCLEVBQTlCLEVBQWtDLFFBQWxDLENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxrQkFBUCxFQUEyQixFQUEzQixFQUErQixFQUEvQixFQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxFQUF6QyxFQUE2QyxFQUE3QyxDQUFQO0FBQ0Q7QUFuSHFCLENBQXhCOztBQXNIQSxPQUFPLE9BQVAsR0FBaUIsZUFBakI7Ozs7O0FDekhBLElBQU0saUJBQWlCLFFBQVEsMEJBQVIsQ0FBdkI7QUFDQSxJQUFNLGtCQUFrQixRQUFRLDJCQUFSLENBQXhCO0FBQ0EsSUFBTSxlQUFlLFFBQVEsd0JBQVIsQ0FBckI7O0FBRUEsSUFBTSxtQkFBbUIsSUFBSSxHQUFKO0FBQ3pCO0FBRHlCLENBRXhCLEdBRndCLENBRXBCLFNBRm9CLEVBRVQsYUFBYSxPQUZKLEVBR3hCLEdBSHdCLENBR3BCLGlCQUhvQixFQUdELGFBQWEsT0FIWixFQUl4QixHQUp3QixDQUlwQixtQkFKb0IsRUFJQyxhQUFhLE9BSmQsRUFLeEIsR0FMd0IsQ0FLcEIsYUFMb0IsRUFLTCxhQUFhLFdBTFIsRUFNeEIsR0FOd0IsQ0FNcEIsY0FOb0IsRUFNSixhQUFhLFlBTlQsRUFPeEIsR0FQd0IsQ0FPcEIsV0FQb0IsRUFPUCxhQUFhLFNBUE47O0FBU3pCO0FBVHlCLENBVXhCLEdBVndCLENBVXBCLGlCQVZvQixFQVVELGdCQUFnQixhQVZmLEVBV3hCLEdBWHdCLENBV3BCLG9CQVhvQixFQVdFLGdCQUFnQixpQkFYbEIsRUFZeEIsR0Fad0IsQ0FZcEIsaUJBWm9CLEVBWUQsZ0JBQWdCLGNBWmYsRUFheEIsR0Fid0IsQ0FhcEIsZUFib0IsRUFhSCxnQkFBZ0IsYUFiYixFQWN4QixHQWR3QixDQWNwQixzQkFkb0IsRUFjSSxnQkFBZ0Isa0JBZHBCLEVBZXhCLEdBZndCLENBZXBCLFNBZm9CLEVBZVQsZ0JBQWdCLE9BZlAsRUFnQnhCLEdBaEJ3QixDQWdCcEIsa0JBaEJvQixFQWdCQSxnQkFBZ0IsZUFoQmhCOztBQWtCekI7QUFsQnlCLENBbUJ4QixHQW5Cd0IsQ0FtQnBCLGFBbkJvQixFQW1CTCxlQUFlLFdBbkJWLENBQXpCOztBQXNCQSxJQUFNLE9BQU8sU0FBUCxJQUFPLENBQVUsU0FBVixFQUFxQixJQUFyQixFQUEyQjtBQUN0QyxNQUFJLFVBQVUsaUJBQWlCLEdBQWpCLENBQXFCLFNBQXJCLENBQWQ7QUFDQSxNQUFJLFlBQVksU0FBaEIsRUFBMkI7QUFDekIsVUFBTSxJQUFJLFNBQUosQ0FBaUIsU0FBakIsMkNBQU47QUFDRDtBQUNELFNBQU8sUUFBUSxJQUFSLENBQVA7QUFDRCxDQU5EOztBQVFBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFFBQU07QUFEUyxDQUFqQjs7Ozs7QUNsQ0EsSUFBTSxhQUFhLFFBQVEsaUJBQVIsQ0FBbkI7QUFDQSxJQUFNLFNBQVMsUUFBUSxnQkFBUixDQUFmOztBQUVBLElBQU0sZUFBZTtBQUVuQixTQUZtQixtQkFFVixJQUZVLEVBRUo7QUFDYixRQUFNLEtBQUssS0FBSyxLQUFMLEVBQVg7QUFDQSxRQUFNLEtBQUssS0FBSyxNQUFMLEVBQVg7O0FBRUEsUUFBTSxZQUFZLElBQUksR0FBSixHQUNqQixHQURpQixDQUNiLFFBRGEsRUFDSCxTQURHLEVBRWpCLEdBRmlCLENBRWIsY0FGYSxFQUVHLEdBRkgsRUFHakIsR0FIaUIsQ0FHYixNQUhhLEVBR0wsTUFISyxDQUFsQjs7QUFLQSxRQUFNLGNBQWMsSUFBSSxHQUFKLEdBQ25CLEdBRG1CLENBQ2YsUUFEZSxFQUNMLFNBREssRUFFbkIsR0FGbUIsQ0FFZixjQUZlLEVBRUMsR0FGRCxFQUduQixHQUhtQixDQUdmLE1BSGUsRUFHUCxNQUhPLENBQXBCOztBQUtBLFFBQU0sT0FBTyxXQUFXLElBQVgsQ0FBZ0IsQ0FBaEIsRUFBbUIsS0FBSyxDQUF4QixFQUEyQixFQUEzQixFQUErQixLQUFLLENBQXBDLEVBQXVDLFNBQXZDLENBQWI7O0FBRUEsUUFBTSwwQkFFRixXQUFXLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBeEIsRUFBMEMsV0FBMUMsQ0FGRSxXQUFOO0FBSUEsV0FBTyxPQUFPLFVBQVAsRUFBbUIsRUFBbkIsRUFBdUIsRUFBdkIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsQ0FBUDtBQUNELEdBdkJrQjtBQXlCbkIsYUF6Qm1CLHVCQXlCTixJQXpCTSxFQXlCQTtBQUNqQixRQUFNLEtBQUssS0FBSyxLQUFMLEVBQVg7QUFDQSxRQUFNLEtBQUssS0FBSyxNQUFMLEVBQVg7O0FBRUEsUUFBTSxVQUFVLEtBQUssQ0FBckI7QUFDQSxRQUFNLFVBQVUsS0FBSyxDQUFyQjtBQUNBLFFBQU0sU0FBUyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQXhDOztBQUVBLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLFNBSEksRUFJaEIsR0FKZ0IsQ0FJWixjQUpZLEVBSUksR0FKSixDQUFqQjs7QUFPQSxRQUFNLE9BQU8sV0FBVyxJQUFYLENBQWdCLENBQWhCLEVBQW1CLEtBQUssQ0FBeEIsRUFBMkIsRUFBM0IsRUFBK0IsS0FBSyxDQUFwQyxFQUF1QyxRQUF2QyxDQUFiOztBQUVBLFFBQU0sOEJBRUYsV0FBVyxNQUFYLENBQWtCLE9BQWxCLEVBQTJCLE9BQTNCLEVBQW9DLE1BQXBDLEVBQTRDLFFBQTVDLENBRkUsV0FBTjtBQUlBLFdBQU8sT0FBTyxjQUFQLEVBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLENBQVA7QUFDRCxHQS9Da0I7QUFpRG5CLGNBakRtQix3QkFpREwsSUFqREssRUFpREM7QUFDbEIsUUFBTSxLQUFLLEtBQUssS0FBTCxFQUFYO0FBQ0EsUUFBTSxLQUFLLEtBQUssTUFBTCxFQUFYOztBQUVBLFFBQU0sVUFBVSxLQUFLLEtBQUwsS0FBZSxDQUEvQjtBQUNBLFFBQU0sVUFBVSxLQUFLLE1BQUwsS0FBZ0IsQ0FBaEM7QUFDQSxRQUFNLGNBQWMsQ0FBQyxLQUFLLEdBQUwsQ0FBUyxFQUFULEVBQWEsRUFBYixJQUFtQixDQUFwQixJQUF5QixDQUE3QztBQUNBLFFBQU0sY0FBYyxDQUFDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxFQUFiLElBQW1CLENBQXBCLElBQXlCLENBQTdDOztBQUVBLFFBQU0sV0FBVyxJQUFJLEdBQUosR0FDaEIsR0FEZ0IsQ0FDWixRQURZLEVBQ0YsU0FERSxFQUVoQixHQUZnQixDQUVaLGNBRlksRUFFSSxHQUZKLEVBR2hCLEdBSGdCLENBR1osTUFIWSxFQUdKLE1BSEksQ0FBakI7O0FBS0EsUUFBTSwrQkFFRixXQUFXLE1BQVgsQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsRUFBb0MsV0FBcEMsRUFBaUQsUUFBakQsQ0FGRSxnQkFHRixXQUFXLE1BQVgsQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsRUFBb0MsV0FBcEMsRUFBaUQsUUFBakQsQ0FIRSxXQUFOO0FBS0EsV0FBTyxPQUFPLGVBQVAsRUFBd0IsRUFBeEIsRUFBNEIsRUFBNUIsRUFBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0MsRUFBdEMsRUFBMEMsRUFBMUMsQ0FBUDtBQUNELEdBckVrQjtBQXVFbkIsV0F2RW1CLHFCQXVFUixJQXZFUSxFQXVFRjtBQUNmLFFBQU0sS0FBSyxLQUFLLEtBQUwsRUFBWDtBQUNBLFFBQU0sS0FBSyxLQUFLLE1BQUwsRUFBWDs7QUFFQSxRQUFNLFdBQVcsSUFBSSxHQUFKLEdBQ2hCLEdBRGdCLENBQ1osUUFEWSxFQUNGLFNBREUsRUFFaEIsR0FGZ0IsQ0FFWixjQUZZLEVBRUksR0FGSixFQUdoQixHQUhnQixDQUdaLE1BSFksRUFHSixNQUhJLENBQWpCOztBQUtBLFFBQUksNEJBRUEsV0FBVyxPQUFYLENBQW1CLEVBQW5CLEVBQXVCLEVBQXZCLEVBQTJCLFFBQTNCLENBRkEsV0FBSjtBQUlBLFdBQU8sT0FBTyxZQUFQLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDLEVBQW1DLEVBQW5DLEVBQXVDLEVBQXZDLENBQVA7QUFDRDtBQXJGa0IsQ0FBckI7O0FBd0ZBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7Ozs7QUMzRkEsSUFBTSxlQUFlLFFBQVEsY0FBUixDQUFyQjtBQUNBLElBQU0sYUFBYSxRQUFRLFNBQVIsQ0FBbkI7O0FBRUE7QUFDQTtBQUNBLElBQUksaUJBQWlCLFNBQWpCLGNBQWlCLENBQVUsU0FBVixFQUFxQjs7QUFFeEMsU0FBTyxVQUFVLFVBQVYsR0FDQSxRQURBLENBQ1MsTUFEVCxFQUVBLEdBRkEsQ0FFSTtBQUNILGVBQVcsaUJBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxXQUFiLENBQXlCLElBQXpCLENBQVY7QUFBQSxLQURSO0FBRUgsaUJBQWEsa0JBQUMsSUFBRDtBQUFBLGFBQVUsYUFBYSxhQUFiLENBQTJCLElBQTNCLENBQVY7QUFBQSxLQUZWO0FBR0gsbUJBQWUsUUFIWjtBQUlILG1CQUFlLFFBSlo7QUFLSCxvQkFBZ0IsR0FMYjtBQU1ILG9CQUFnQixNQU5iO0FBT0gsd0JBQW9CLFNBUGpCO0FBUUgsMEJBQXNCLEdBUm5CO0FBU0gsb0JBQWdCLENBVGI7QUFVSCxlQUFXLENBVlI7QUFXSCxpQkFBYSxNQVhWO0FBWUgsc0JBQWtCO0FBWmYsR0FGSixFQWdCQSxRQWhCQSxDQWdCUyxhQWhCVCxFQWlCQSxHQWpCQSxDQWlCSTtBQUNILGFBQVMsZUFBQyxJQUFEO0FBQUEsYUFBVSxhQUFhLFNBQWIsQ0FBdUIsSUFBdkIsQ0FBVjtBQUFBO0FBRE4sR0FqQkosRUFvQkEsUUFwQkEsQ0FvQlMsdUJBcEJULEVBcUJBLEdBckJBLENBcUJJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQURqQjtBQUVILGFBQVMsUUFGTjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0FyQkosRUErQkEsUUEvQkEsQ0ErQlMsaUNBL0JULEVBZ0NBLEdBaENBLENBZ0NJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQURqQjtBQUVILGFBQVMsUUFGTjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0FoQ0osRUEwQ0EsUUExQ0EsQ0EwQ1MsK0JBMUNULEVBMkNBLEdBM0NBLENBMkNJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQURqQjtBQUVILGVBQVcsaUJBQUMsSUFBRDtBQUFBLGFBQVUsS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLEVBQVQsRUFBdUIsS0FBSyxNQUFMLEVBQXZCLElBQXdDLEdBQWxEO0FBQUEsS0FGUjtBQUdILGFBQVMsUUFITjtBQUlILHNCQUFrQixNQUpmO0FBS0gsd0JBQW9CLE1BTGpCO0FBTUgseUJBQXFCLE1BTmxCO0FBT0gsdUJBQW1CLE1BUGhCO0FBUUgseUJBQXFCLFdBUmxCO0FBU0gsb0JBQWdCO0FBVGIsR0EzQ0osRUFzREEsUUF0REEsQ0FzRFMsMkJBdERULEVBdURBLEdBdkRBLENBdURJO0FBQ0gsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQURqQjtBQUVILGFBQVMsU0FGTjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCLENBUmI7QUFTSCwwQkFBc0I7QUFUbkIsR0F2REosRUFrRUEsUUFsRUEsQ0FrRVMsNEJBbEVULEVBbUVBLEdBbkVBLENBbUVJO0FBQ0gsYUFBUyxTQUROO0FBRUgsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0FuRUosRUE2RUEsUUE3RUEsQ0E2RVMseUJBN0VULEVBOEVBLEdBOUVBLENBOEVJO0FBQ0gsYUFBUyxTQUROO0FBRUgsd0JBQW9CLHlCQUFDLElBQUQ7QUFBQSxhQUFVLFdBQVcsSUFBWCxDQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWhCLEVBQW9DLElBQXBDLENBQVY7QUFBQSxLQUZqQjtBQUdILHNCQUFrQixNQUhmO0FBSUgsd0JBQW9CLE1BSmpCO0FBS0gseUJBQXFCLE1BTGxCO0FBTUgsdUJBQW1CLE1BTmhCO0FBT0gseUJBQXFCLFdBUGxCO0FBUUgsb0JBQWdCO0FBUmIsR0E5RUosRUF3RkEsUUF4RkEsQ0F3RlMsK0JBeEZULEVBeUZBLEdBekZBLENBeUZJO0FBQ0gsNEJBQXdCLGdQQURyQjtBQUVILHdCQUFvQix5QkFBQyxJQUFEO0FBQUEsYUFBVSxXQUFXLElBQVgsQ0FBZ0IsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQixFQUFvQyxJQUFwQyxDQUFWO0FBQUEsS0FGakI7QUFHSCxzQkFBa0IsTUFIZjtBQUlILHdCQUFvQixNQUpqQjtBQUtILHlCQUFxQixNQUxsQjtBQU1ILHVCQUFtQixNQU5oQjtBQU9ILHlCQUFxQixXQVBsQjtBQVFILG9CQUFnQjtBQVJiLEdBekZKLEVBbUdBLFFBbkdBLENBbUdTLG9DQW5HVCxFQW9HQSxHQXBHQSxDQW9HSTtBQUNILHdCQUFvQix5QkFBQyxJQUFEO0FBQUEsYUFBVSxXQUFXLElBQVgsQ0FBZ0IsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQixFQUFvQyxJQUFwQyxDQUFWO0FBQUEsS0FEakI7QUFFSCxzQkFBa0IsTUFGZjtBQUdILHdCQUFvQixNQUhqQjtBQUlILHlCQUFxQixNQUpsQjtBQUtILHVCQUFtQixNQUxoQjtBQU1ILHlCQUFxQixXQU5sQjtBQU9ILG9CQUFnQjtBQVBiLEdBcEdKLEVBNkdBLFFBN0dBLENBNkdTLGdDQTdHVCxFQThHQSxHQTlHQSxDQThHSTtBQUNILDRCQUF3QixvREFEckI7QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEIsRUFBb0MsSUFBcEMsQ0FBVjtBQUFBLEtBRmpCO0FBR0gsc0JBQWtCLE1BSGY7QUFJSCx3QkFBb0IsTUFKakI7QUFLSCx5QkFBcUIsTUFMbEI7QUFNSCx1QkFBbUIsTUFOaEI7QUFPSCx5QkFBcUIsV0FQbEI7QUFRSCxvQkFBZ0I7QUFSYixHQTlHSixFQXdIQSxRQXhIQSxDQXdIUyw2QkF4SFQsRUF5SEEsR0F6SEEsQ0F5SEk7QUFDSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEIsRUFBb0MsSUFBcEMsQ0FBVjtBQUFBLEtBRGpCO0FBRUgsc0JBQWtCLE1BRmY7QUFHSCx3QkFBb0IsTUFIakI7QUFJSCx5QkFBcUIsTUFKbEI7QUFLSCx1QkFBbUIsTUFMaEI7QUFNSCx5QkFBcUIsV0FObEI7QUFPSCxvQkFBZ0I7QUFQYixHQXpISixFQWtJQSxRQWxJQSxDQWtJUywrQkFsSVQsRUFtSUEsR0FuSUEsQ0FtSUk7QUFDSCxhQUFTLFNBRE47QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEIsRUFBb0MsSUFBcEMsQ0FBVjtBQUFBLEtBRmpCO0FBR0gsc0JBQWtCLE1BSGY7QUFJSCx3QkFBb0IsTUFKakI7QUFLSCx5QkFBcUIsTUFMbEI7QUFNSCx1QkFBbUIsTUFOaEI7QUFPSCx5QkFBcUIsV0FQbEI7QUFRSCxvQkFBZ0I7QUFSYixHQW5JSixFQTZJQSxRQTdJQSxDQTZJUyxrQ0E3SVQsRUE4SUEsR0E5SUEsQ0E4SUk7QUFDSCxhQUFTLFNBRE47QUFFSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEIsRUFBb0MsSUFBcEMsQ0FBVjtBQUFBLEtBRmpCO0FBR0gsc0JBQWtCLE1BSGY7QUFJSCx3QkFBb0IsTUFKakI7QUFLSCx5QkFBcUIsTUFMbEI7QUFNSCx1QkFBbUIsTUFOaEI7QUFPSCx5QkFBcUIsV0FQbEI7QUFRSCxvQkFBZ0I7QUFSYixHQTlJSixFQXdKQSxRQXhKQSxDQXdKUyx1QkF4SlQsRUF5SkEsR0F6SkEsQ0F5Skk7QUFDSCx3QkFBb0IseUJBQUMsSUFBRDtBQUFBLGFBQVUsV0FBVyxJQUFYLENBQWdCLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBaEIsRUFBb0MsSUFBcEMsQ0FBVjtBQUFBLEtBRGpCO0FBRUgsZUFBVyxpQkFBQyxJQUFEO0FBQUEsYUFBVSxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQUwsRUFBVCxFQUF3QixLQUFLLEtBQUwsRUFBeEIsSUFBd0MsSUFBbEQ7QUFBQSxLQUZSO0FBR0gsMEJBQXNCLEVBSG5CO0FBSUgsc0JBQWtCLE1BSmY7QUFLSCx3QkFBb0IsTUFMakI7QUFNSCx5QkFBcUIsTUFObEI7QUFPSCx1QkFBbUIsTUFQaEI7QUFRSCx5QkFBcUIsV0FSbEI7QUFTSCxvQkFBZ0IsQ0FUYjtBQVVILG1CQUFlLFFBVlo7QUFXSCxtQkFBZSxRQVhaO0FBWUgsa0JBQWMsbUJBQUMsSUFBRDtBQUFBLGFBQVUsS0FBSyxLQUFMLEtBQWUsR0FBekI7QUFBQSxLQVpYO0FBYUgsMkJBQXVCLEtBYnBCO0FBY0gsOEJBQTBCO0FBZHZCLEdBekpKLEVBeUtBLFFBektBLENBeUtTLDJCQXpLVCxFQTBLQSxHQTFLQSxDQTBLSTtBQUNILHdCQUFvQix5QkFBQyxJQUFEO0FBQUEsYUFBVSxXQUFXLElBQVgsQ0FBZ0IsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFoQixFQUFvQyxJQUFwQyxDQUFWO0FBQUEsS0FEakI7QUFFSCxlQUFXLGlCQUFDLElBQUQ7QUFBQSxhQUFVLEtBQUssR0FBTCxDQUFTLEtBQUssTUFBTCxFQUFULEVBQXdCLEtBQUssS0FBTCxFQUF4QixJQUF3QyxFQUFsRDtBQUFBLEtBRlI7QUFHSCxzQkFBa0IsTUFIZjtBQUlILHdCQUFvQixNQUpqQjtBQUtILHlCQUFxQixNQUxsQjtBQU1ILHVCQUFtQixNQU5oQjtBQU9ILHlCQUFxQixXQVBsQjtBQVFILG9CQUFnQixDQVJiO0FBU0gsMEJBQXNCLEVBVG5CO0FBVUgsbUJBQWUsUUFWWjtBQVdILG1CQUFlLFFBWFo7QUFZSCxrQkFBYyxHQVpYO0FBYUgsMkJBQXVCLEtBYnBCO0FBY0gsOEJBQTBCLEtBZHZCO0FBZUgsaUJBQWEsR0FmVjtBQWdCSCw0QkFBd0IsS0FoQnJCO0FBaUJILDJCQUF1QjtBQWpCcEIsR0ExS0osRUE2TEEsUUE3TEEsQ0E2TFMsbUJBN0xULEVBOExBLEdBOUxBLENBOExJO0FBQ0gsNEJBQXdCO0FBRHJCLEdBOUxKLEVBaU1BLFFBak1BLENBaU1TLDJCQWpNVCxFQWtNQSxHQWxNQSxDQWtNSTtBQUNILHdCQUFvQjtBQURqQixHQWxNSixFQXFNQSxRQXJNQSxDQXFNUyw0RUFyTVQsRUFzTUEsR0F0TUEsQ0FzTUk7QUFDSCxhQUFTLGNBRE47QUFFSCxjQUFVO0FBRlAsR0F0TUosRUEwTUEsUUExTUEsQ0EwTVMsZUExTVQsRUEyTUEsR0EzTUEsQ0EyTUk7QUFDSCx3QkFBb0IsU0FEakI7QUFFSCwwQkFBc0IsTUFGbkI7QUFHSCwwQkFBc0I7QUFIbkIsR0EzTUosRUFnTkEsUUFoTkEsQ0FnTlMsYUFoTlQsRUFpTkEsR0FqTkEsQ0FpTkk7QUFDSCwwQkFBc0IsR0FEbkIsRUFDd0IsaUJBQWlCLFNBRHpDO0FBRUgsdUJBQW1CO0FBRmhCLEdBak5KLEVBcU5BLFFBck5BLENBcU5TLE1Bck5ULEVBc05BLEdBdE5BLENBc05JO0FBQ0gsbUJBQWUsUUFEWjtBQUVILGtCQUFjLE1BRlg7QUFHSCx5QkFBcUIsUUFIbEI7QUFJSCx5QkFBcUIsUUFKbEI7QUFLSCxhQUFTLEdBTE47QUFNSCwwQkFBc0IsTUFObkI7QUFPSCwwQkFBc0IsTUFQbkI7QUFRSCx5QkFBcUIseUJBQUMsSUFBRCxFQUFVO0FBQzdCLFVBQUksS0FBSyxRQUFMLEVBQUosRUFBcUI7QUFDbkIsZUFBTyxTQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssR0FBTCxDQUFTLFlBQVQsQ0FBUDtBQUNELEtBYkU7QUFjSCxhQUFTLGVBQUMsSUFBRCxFQUFVO0FBQ2pCLFVBQUksS0FBSyxRQUFMLEVBQUosRUFBcUI7QUFDbkIsZUFBTyxTQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssR0FBTCxDQUFTLFlBQVQsQ0FBUDtBQUNEO0FBbkJFLEdBdE5KLEVBMk9BLFFBM09BLENBMk9TLGVBM09ULEVBNE9BLEdBNU9BLENBNE9JO0FBQ0gsa0JBQWMsU0FEWDtBQUVILDBCQUFzQixTQUZuQjtBQUdILDBCQUFzQjtBQUhuQixHQTVPSixFQWlQQSxRQWpQQSxDQWlQUyxhQWpQVCxFQWtQQSxHQWxQQSxDQWtQSTtBQUNILDBCQUFzQixHQURuQixFQUN3QixpQkFBaUIsU0FEekM7QUFFSCx1QkFBbUI7QUFGaEIsR0FsUEosRUFzUEEsUUF0UEEsQ0FzUFMsdUJBdFBULEVBdVBBLEdBdlBBLENBdVBJO0FBQ0gscUJBQWlCLFlBRGQ7QUFFSCw2QkFBeUIsV0FGdEI7QUFHSCwyQkFBdUIsR0FIcEI7QUFJSCx5QkFBcUIsR0FKbEI7QUFLSCw2QkFBeUIsT0FMdEI7QUFNSCwrQkFBMkI7QUFOeEIsR0F2UEosRUErUEEsUUEvUEEsQ0ErUFMsNENBL1BULEVBZ1FBLEdBaFFBLENBZ1FJO0FBQ0gsb0JBQWdCLHFCQUFDLElBQUQ7QUFBQSxhQUFVLEtBQUssS0FBSyxJQUFMLENBQVUsYUFBVixDQUFmO0FBQUEsS0FEYjtBQUVILDRCQUF3QixLQUZyQjtBQUdILDBCQUFzQiwwQkFBQyxJQUFEO0FBQUEsYUFBVSxhQUFhLG1CQUFiLENBQWlDLElBQWpDLENBQVY7QUFBQTtBQUhuQixHQWhRSixFQXFRQSxRQXJRQSxDQXFRUywyQ0FyUVQsRUFzUUEsR0F0UUEsQ0FzUUk7QUFDSCxvQkFBZ0IscUJBQUMsSUFBRDtBQUFBLGFBQVUsS0FBSyxLQUFLLElBQUwsQ0FBVSxhQUFWLENBQWY7QUFBQSxLQURiO0FBRUgsNEJBQXdCLEtBRnJCO0FBR0gsMEJBQXNCLDBCQUFDLElBQUQ7QUFBQSxhQUFVLGFBQWEsbUJBQWIsQ0FBaUMsSUFBakMsQ0FBVjtBQUFBO0FBSG5CLEdBdFFKLEVBMlFBLFFBM1FBLENBMlFTLGFBM1FULEVBNFFBLEdBNVFBLENBNFFJO0FBQ0gsMEJBQXNCLDBCQUFDLElBQUQ7QUFBQSxhQUFVLGFBQWEsY0FBYixDQUE0QixJQUE1QixDQUFWO0FBQUEsS0FEbkI7QUFFSCwwQkFBc0I7QUFGbkIsR0E1UUosRUFnUkEsUUFoUkEsQ0FnUlMsMEJBaFJULEVBaVJBLEdBalJBLENBaVJJO0FBQ0gseUJBQXFCO0FBRGxCLEdBalJKLEVBb1JBLFFBcFJBLENBb1JTLDBCQXBSVCxFQXFSQSxHQXJSQSxDQXFSSTtBQUNILHlCQUFxQjtBQURsQixHQXJSSixFQXdSQSxRQXhSQSxDQXdSUyxNQXhSVCxFQXlSQSxHQXpSQSxDQXlSSTtBQUNILDJCQUF1QixTQURwQjtBQUVILDZCQUF5QixLQUZ0QixFQUU2Qiw4QkFBOEI7QUFGM0QsR0F6UkosQ0FBUDtBQTZSRCxDQS9SRDs7QUFpU0EsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7OztBQ3RTQSxJQUFNLFNBQVMsSUFBSSxTQUFKLEVBQWY7O0FBRUEsSUFBTSxNQUFNLFNBQU4sR0FBTSxDQUFDLE1BQUQsRUFBd0Y7QUFBQSxNQUEvRSxLQUErRSx1RUFBdkUsR0FBdUU7QUFBQSxNQUFsRSxNQUFrRSx1RUFBekQsR0FBeUQ7QUFBQSxNQUFwRCxHQUFvRCx1RUFBOUMsQ0FBOEM7QUFBQSxNQUEzQyxHQUEyQyx1RUFBckMsQ0FBcUM7QUFBQSxNQUFsQyxPQUFrQyx1RUFBeEIsR0FBd0I7QUFBQSxNQUFuQixRQUFtQix1RUFBUixHQUFROztBQUNsRyxNQUFJLHVGQUU2RCxLQUY3RCxvQkFFK0UsTUFGL0UscUJBRW1HLEdBRm5HLFNBRTBHLEdBRjFHLFNBRWlILE9BRmpILFNBRTRILFFBRjVILGlCQUdBLE1BSEEscUJBQUo7QUFNQSxTQUFPLE9BQU8sZUFBUCxDQUF1QixPQUF2QixFQUFnQyxVQUFoQyxFQUE0QyxlQUFuRDtBQUNELENBUkQ7O0FBVUEsSUFBTSxZQUFZLFNBQVosU0FBWSxDQUFDLE9BQUQsRUFBVSxhQUFWLEVBQXlCLGNBQXpCLEVBQXlDLFFBQXpDLEVBQW1ELFFBQW5ELEVBQTZELFlBQTdELEVBQTJFLGFBQTNFLEVBQTZGO0FBQzdHLE1BQUksUUFBUSxJQUFJLE9BQUosRUFBYSxhQUFiLEVBQTRCLGNBQTVCLEVBQTRDLFFBQTVDLEVBQXNELFFBQXRELEVBQWdFLFlBQWhFLEVBQThFLGFBQTlFLENBQVo7QUFDQSxNQUFJLHlDQUF1QyxLQUFLLE1BQU0sU0FBWCxDQUEzQzs7QUFFQSxTQUFPLE9BQVA7QUFDRCxDQUxEOztBQU9BLE9BQU8sT0FBUCxHQUFpQixTQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiBnbG9iYWwgJCAqL1xuXG5pbXBvcnQgU0JHTlJlbmRlcmVyIGZyb20gJy4uL3NyYy9pbmRleCc7XG5cbnZhciBjb252ZXJ0U2Jnbm1sID0gcmVxdWlyZSgnc2Jnbm1sLXRvLWN5dG9zY2FwZScpO1xudmFyIHNhdmVBcyA9IHJlcXVpcmUoJ2ZpbGUtc2F2ZXInKS5zYXZlQXM7XG5cbnZhciBkZWZhdWx0RGF0YSA9IHJlcXVpcmUoJy4vdGVzdC1kYXRhJyk7XG5cbnZhciBsb2FkRmlsZVRleHQgPSBmdW5jdGlvbiAoYWJzRmlsZVBhdGgpIHtcbiAgdmFyIHhodHRwO1xuICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgeGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB4aHR0cCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICB9XG4gIHhodHRwLm9wZW4oJ0dFVCcsIGFic0ZpbGVQYXRoLCBmYWxzZSk7XG4gIHhodHRwLnNlbmQoKTtcbiAgcmV0dXJuIHhodHRwLnJlc3BvbnNlVGV4dDtcbn07XG5cbnZhciByZWFkRmlsZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgZmlsZSkge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ3JhcGggPSBjb252ZXJ0U2Jnbm1sKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgcmVuZGVyR3JhcGgocmVuZGVyZXIsIGdyYXBoKTtcblxuICB9O1xuXG4gIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xufTtcblxudmFyIHJlbmRlckdyYXBoID0gZnVuY3Rpb24gKGN5LCBjeUdyYXBoKSB7XG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgY3kucmVtb3ZlKCcqJyk7XG4gIGN5LmFkZChjeUdyYXBoKTtcblxuICB2YXIgbm9kZVBvc2l0aW9ucyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGN5R3JhcGgubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeFBvcyA9IGN5R3JhcGgubm9kZXNbaV0uZGF0YS5iYm94Lng7XG4gICAgdmFyIHlQb3MgPSBjeUdyYXBoLm5vZGVzW2ldLmRhdGEuYmJveC55O1xuICAgIG5vZGVQb3NpdGlvbnNbY3lHcmFwaC5ub2Rlc1tpXS5kYXRhLmlkXSA9IHsneCc6IHhQb3MsICd5JzogeVBvc307XG4gIH1cblxuICBjeS5sYXlvdXQoe1xuICAgIG5hbWU6ICdwcmVzZXQnLFxuICAgIHBvc2l0aW9uczogbm9kZVBvc2l0aW9ucyxcbiAgICBmaXQ6IHRydWUsXG4gICAgcGFkZGluZzogNTBcbiAgfSk7XG5cbiAgY3kuZW5kQmF0Y2goKTtcbiAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbn07XG5cbnZhciBiNjR0b0Jsb2IgPSBmdW5jdGlvbiAoYjY0RGF0YSwgY29udGVudFR5cGUsIHNsaWNlU2l6ZSkge1xuICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8ICcnO1xuICBzbGljZVNpemUgPSBzbGljZVNpemUgfHwgNTEyO1xuXG4gIHZhciBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYjY0RGF0YSk7XG4gIHZhciBieXRlQXJyYXlzID0gW107XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYnl0ZUNoYXJhY3RlcnMubGVuZ3RoOyBvZmZzZXQgKz0gc2xpY2VTaXplKSB7XG4gICAgdmFyIHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzbGljZVNpemUpO1xuXG4gICAgdmFyIGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KHNsaWNlLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZU51bWJlcnNbaV0gPSBzbGljZS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG5cbiAgICBieXRlQXJyYXlzLnB1c2goYnl0ZUFycmF5KTtcbiAgfVxuXG4gIHZhciBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG4gIHJldHVybiBibG9iO1xufTtcblxudmFyIHNhdmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGZpbGVuYW1lKSB7XG4gIHZhciBncmFwaEZpbGVTdHJpbmcgPSByZW5kZXJlci5wbmcoe3NjYWxlOiAzLCBmdWxsOiB0cnVlfSk7XG5cbiAgdmFyIGI2NERhdGEgPSBncmFwaEZpbGVTdHJpbmcuc3Vic3RyKGdyYXBoRmlsZVN0cmluZy5pbmRleE9mKCcsJykgKyAxKTtcbiAgc2F2ZUFzKGI2NHRvQmxvYihiNjREYXRhLCAnaW1hZ2UvcG5nJyksIGZpbGVuYW1lKTtcbn07XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgY29udGFpbmVyID0gJCgnI3NiZ24tbmV0d29yay1jb250YWluZXInKTtcblxuICB2YXIgcmVuZGVyZXIgPSBuZXcgU0JHTlJlbmRlcmVyKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9KTtcblxuICB3aW5kb3cuciA9IHdpbmRvdy5jeSA9IHJlbmRlcmVyO1xuICByZW5kZXJHcmFwaChyZW5kZXJlciwgZGVmYXVsdERhdGEpO1xuXG4gICQoJyNncmFwaC1sb2FkJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICQoJyNncmFwaC1pbnB1dCcpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gIH0pO1xuXG4gICQoJyNncmFwaC1pbnB1dCcpLmNoYW5nZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQodGhpcykudmFsKCkgIT0gJycpIHtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1swXTtcblxuICAgICAgcmVhZEZpbGUocmVuZGVyZXIsIGZpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgJCgnI2dyYXBoLXNhdmUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2F2ZShyZW5kZXJlciwgJ2dyYXBoJyk7XG4gIH0pO1xuXG4gICQoJy5zYW1wbGUtZmlsZScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsZVRleHQgPSBsb2FkRmlsZVRleHQoJ3NhbXBsZXMvJyArICQodGhpcylbMF0uaW5uZXJUZXh0ICsgJy54bWwnKTtcbiAgICB2YXIgZ3JhcGhKc29uID0gY29udmVydFNiZ25tbChmaWxlVGV4dCk7XG4gICAgcmVuZGVyR3JhcGgocmVuZGVyZXIsIGdyYXBoSnNvbik7XG4gIH0pO1xuXG59KTtcbiIsInZhciBtYXBrQ2FzY2FkZURhdGEgPSB7XG5cIm5vZGVzXCI6IFtcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGg0XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiAzMTguMTU4OTE2NTg4NTA2NyxcbiAgICAgICAgICAgICAgICBcInlcIjogMTYyLjU5ODk4Njc5OTczMzMyLFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjYwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwic2ltcGxlIGNoZW1pY2FsXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiQVRQXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwiY2xvbmVtYXJrZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoNVwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogMzY4LjcxNTA2OTgwMzI3NjUsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDM1My4zNDI1MzExMzMyMTQ3LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjYwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwic2ltcGxlIGNoZW1pY2FsXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiQURQXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwiY2xvbmVtYXJrZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoN1wiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNDIzLjQ2MDEyNDcwODY5MjEsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDEwMy42ODE0NDY5OTczNzA1OSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFUUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDZcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDUxNC44Mjg2NTY0ODA0MTYyLFxuICAgICAgICAgICAgICAgIFwieVwiOiA0MC4xNjE2OTcxODY0Njc1NixcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFEUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDEwXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA1ODguNzc1NjkzMjczMDM3LFxuICAgICAgICAgICAgICAgIFwieVwiOiA0MTAuNTMxODA4NzkwNjE0NCxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFUUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDlcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDQ5Ny42ODU5NDI4MDM3MjM3LFxuICAgICAgICAgICAgICAgIFwieVwiOiAzNTIuMjI0MTY0NjEzNzY5MixcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFEUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDJcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDQ2Ny4xODMwMjIxMzIwOTI0NSxcbiAgICAgICAgICAgICAgICBcInlcIjogMjQwLjI4NzMwNjQ4NzM5MDMsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMTAwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwibWFjcm9tb2xlY3VsZVwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlJBRlwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyYVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiUFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjI1LjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIyLjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE4XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA5NDQuMDQwOTQ5MTc2MzYxLFxuICAgICAgICAgICAgICAgIFwieVwiOiAyODQuMDY1NzQ0Njg2ODQwNixcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFEUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE2XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA2ODkuMTMxNDU4NTMwMzc2NyxcbiAgICAgICAgICAgICAgICBcInlcIjogNDgyLjQ0NDY3MTAwNTg0NzQ1LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjYwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwic2ltcGxlIGNoZW1pY2FsXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiQURQXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwiY2xvbmVtYXJrZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTVcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDg4Mi44NDQzMzI2Mjk0NTQ2LFxuICAgICAgICAgICAgICAgIFwieVwiOiA0ODIuNTI0NjI2ODEyODA0MyxcbiAgICAgICAgICAgICAgICBcIndcIjogXCI2MC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInNpbXBsZSBjaGVtaWNhbFwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkFUUFwiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcImNsb25lbWFya2VyXCI6IHRydWUsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE3XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA3NTkuOTgxMDQwODkwMjEyOSxcbiAgICAgICAgICAgICAgICBcInlcIjogMjIwLjU4NTQwNDQxMDE0NTc3LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjYwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwic2ltcGxlIGNoZW1pY2FsXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiQVRQXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwiY2xvbmVtYXJrZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTJcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDcyMi41MjQwMDg4NzYyNzIxLFxuICAgICAgICAgICAgICAgIFwieVwiOiAzNTIuNzcwMDY5MzY1NDc4LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJNRUtcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTJhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCIyUFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjMyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIyLjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDE5XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA4ODcuMDMxMjk1NTkyOTY5OSxcbiAgICAgICAgICAgICAgICBcInlcIjogMTg4LjAxMTA0MzIwODk5OTI0LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJFUktcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMTlhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCIyUFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogLTI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3XCI6IFwiMzIuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoXCI6IFwiMjIuMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjBcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDk3MS4wNTY3MTc2NTA3MTkxLFxuICAgICAgICAgICAgICAgIFwieVwiOiA4NC42Njg1MjcyNzM5NzE5LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInRhZ1wiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkVSS1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDFcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDIxMy41NTA1NjEzMjcwNjg2NCxcbiAgICAgICAgICAgICAgICBcInlcIjogMjM2LjE4OTMzMjEzMzA2NjA1LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJSQVNcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMWFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjbGF6elwiOiBcInN0YXRlIHZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcImFjdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjUwLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjI2LjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDBcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDYwLjEzNDM4OTUxMjI4ODYzNSxcbiAgICAgICAgICAgICAgICBcInlcIjogMjAwLjAyNTg3MjI0NTQxNjA1LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInRhZ1wiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlJBU1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDI0XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA2MDcuNTU4NDg2Mjk1Mzc4OCxcbiAgICAgICAgICAgICAgICBcInlcIjogMjE2LjM2NDY2NDg5MTg0NzE2LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJNRUtcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjRhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJQXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiAtMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyNS4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNTkyLjYxODUyMzA2NTY2NTIsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDMxMy40NTAyMDg1MjI1OTI5LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjIwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCIyMC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvY2Vzc1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDI1XCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiAyNDcuNDQzMTk2NTMxOTIzNixcbiAgICAgICAgICAgICAgICBcInlcIjogMzM4LjI5NTY1MjM2NTU4NDgzLFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJSQUZcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjVhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiAzMzcuNzc5MTgwMjUxMTI5MzMsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDI1OS4xMzQ1NDUzMjg0NjkyNCxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiMjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2Nlc3NcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyM1wiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNjMxLjM2NjU4MTA3OTYyNDcsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDkzLjYxNDQ1NzUwMzA1MzM2LFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjEwMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiNjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIm1hY3JvbW9sZWN1bGVcIixcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJNRUtcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjNhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhenpcIjogXCJzdGF0ZSB2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IC0yNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjIwLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIyLjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDUxNi45MjUyMzE1ODQyMjgyLFxuICAgICAgICAgICAgICAgIFwieVwiOiAxNDIuMDEyOTA4NDA0Mjk2MTMsXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMjAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9jZXNzXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtdLFxuICAgICAgICAgICAgXCJwYXJlbnRcIjogXCJcIixcbiAgICAgICAgICAgIFwicG9ydHNcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJpZFwiOiBcImdseXBoMjJcIixcbiAgICAgICAgICAgIFwiYmJveFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IDc4Ni4xNjAyNzY4NTczNTczLFxuICAgICAgICAgICAgICAgIFwieVwiOiA1NTcuNDUzNDkwNDMyODk5MSxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIxMDAuMFwiLFxuICAgICAgICAgICAgICAgIFwiaFwiOiBcIjYwLjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJtYWNyb21vbGVjdWxlXCIsXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiRVJLXCIsXG4gICAgICAgICAgICBcInN0YXRlc2FuZGluZm9zXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDIyYVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXp6XCI6IFwic3RhdGUgdmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiAtMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhcIjogXCIyMi4wXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogODQ0LjQzMDAyODg5MzkwOTYsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDI4NC44NzE2NTgyMzc1MDM1NCxcbiAgICAgICAgICAgICAgICBcIndcIjogXCIyMC4wXCIsXG4gICAgICAgICAgICAgICAgXCJoXCI6IFwiMjAuMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2Nlc3NcIixcbiAgICAgICAgICAgIFwic3RhdGVzYW5kaW5mb3NcIjogW10sXG4gICAgICAgICAgICBcInBhcmVudFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJwb3J0c1wiOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJiYm94XCI6IHtcbiAgICAgICAgICAgICAgICBcInhcIjogNzgzLjc0MDIwNDY4MDg0NDMsXG4gICAgICAgICAgICAgICAgXCJ5XCI6IDQ1My4xNTAxNTA1NTAxNTkxLFxuICAgICAgICAgICAgICAgIFwid1wiOiBcIjIwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCIyMC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvY2Vzc1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiaWRcIjogXCJnbHlwaDIxXCIsXG4gICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgIFwieFwiOiA4NzIuMTUxNzMzNDE2MjUzMSxcbiAgICAgICAgICAgICAgICBcInlcIjogMzc4LjU2ODA5NzI3MzIwMzksXG4gICAgICAgICAgICAgICAgXCJ3XCI6IFwiMTAwLjBcIixcbiAgICAgICAgICAgICAgICBcImhcIjogXCI2MC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwibWFjcm9tb2xlY3VsZVwiLFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkVSS1wiLFxuICAgICAgICAgICAgXCJzdGF0ZXNhbmRpbmZvc1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiZ2x5cGgyMWFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjbGF6elwiOiBcInN0YXRlIHZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImJib3hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IC0yNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiOiBcIjI1LjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaFwiOiBcIjIyLjBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicGFyZW50XCI6IFwiXCIsXG4gICAgICAgICAgICBcInBvcnRzXCI6IFtdXG4gICAgICAgIH1cbiAgICB9XG5dLFxuXCJlZGdlc1wiOiBbXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgyXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoNFwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoNFwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGg1XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDNcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoNVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjYXRhbHlzaXNcIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDFcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgzXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDFcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoM1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoN1wiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoN1wiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGg4XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGg2XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoNlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTBcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxMFwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDEyXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDExXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDEyXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDExXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoOVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxMVwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGg5XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNhdGFseXNpc1wiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMlwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDExXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDJcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2F0YWx5c2lzXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgyXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoOFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgyXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDhcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxOVwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxOVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDE4XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDEzXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDE4XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDE0XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTZcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTZcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDE1XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTRcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTVcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTRcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDE3XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTNcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTdcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTNcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2F0YWx5c2lzXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxMlwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDEzXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDEyXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDEzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNhdGFseXNpc1wiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMTJcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxMlwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxNFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJlcXVpdmFsZW5jZSBhcmNcIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDE5XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMjBcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMTlcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMjBcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiZXF1aXZhbGVuY2UgYXJjXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxXCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgxXCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDBcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoOFwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDI0XCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMjRcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDI0XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoMTFcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMjRcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY29uc3VtcHRpb25cIixcbiAgICAgICAgICAgIFwiYmVuZFBvaW50UG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgXCJjYXJkaW5hbGl0eVwiOiAwLFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJnbHlwaDI1XCIsXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcImdseXBoM1wiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgyNVwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNvbnN1bXB0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgyM1wiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDhcIixcbiAgICAgICAgICAgIFwicG9ydHNvdXJjZVwiOiBcImdseXBoMjNcIixcbiAgICAgICAgICAgIFwicG9ydHRhcmdldFwiOiBcImdseXBoOFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMjJcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgyMlwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxNFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjb25zdW1wdGlvblwiLFxuICAgICAgICAgICAgXCJiZW5kUG9pbnRQb3NpdGlvbnNcIjogW10sXG4gICAgICAgICAgICBcImNhcmRpbmFsaXR5XCI6IDAsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcImdseXBoMjFcIixcbiAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZ2x5cGgxM1wiLFxuICAgICAgICAgICAgXCJwb3J0c291cmNlXCI6IFwiZ2x5cGgyMVwiLFxuICAgICAgICAgICAgXCJwb3J0dGFyZ2V0XCI6IFwiZ2x5cGgxM1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgICAgICBcImJlbmRQb2ludFBvc2l0aW9uc1wiOiBbXSxcbiAgICAgICAgICAgIFwiY2FyZGluYWxpdHlcIjogMCxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwiZ2x5cGgxNFwiLFxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJnbHlwaDIxXCIsXG4gICAgICAgICAgICBcInBvcnRzb3VyY2VcIjogXCJnbHlwaDE0XCIsXG4gICAgICAgICAgICBcInBvcnR0YXJnZXRcIjogXCJnbHlwaDIxXCJcbiAgICAgICAgfVxuICAgIH1cbl1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwa0Nhc2NhZGVEYXRhO1xuIiwiIiwiXG4vKiFcblxuQ3l0b3NjYXBlLmpzIHt7VkVSU0lPTn19IChNSVQgbGljZW5zZWQpXG5cbkNvcHlyaWdodCAoYykgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbnRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxudGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xudXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbm9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCDigJxBUyBJU+KAnSwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoICcuL3Byb21pc2UnICk7XG5cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiggdGFyZ2V0LCBvcHRzLCBvcHRzMiApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgQW5pbWF0aW9uKSApe1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCB0YXJnZXQsIG9wdHMsIG9wdHMyICk7XG4gIH1cblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gdXRpbC5leHRlbmQoIHtcbiAgICBkdXJhdGlvbjogMTAwMFxuICB9LCBvcHRzLCBvcHRzMiApO1xuXG4gIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgX3AucGxheWluZyA9IGZhbHNlO1xuICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgX3AucHJvZ3Jlc3MgPSAwO1xuICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgX3AuZnJhbWVzID0gW107XG5cbiAgaWYoIF9wLmNvbXBsZXRlICYmIGlzLmZuKCBfcC5jb21wbGV0ZSApICl7XG4gICAgX3AuY29tcGxldGVzLnB1c2goIF9wLmNvbXBsZXRlICk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxudXRpbC5leHRlbmQoIGFuaWZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAnYW5pbWF0aW9uJzsgfSxcblxuICBob29rOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggIV9wLmhvb2tlZCApe1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiggX3AucXVldWUgKXtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKCB0aGlzICk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIF9wLnRhcmdldCApICl7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbCggX3AudGFyZ2V0ICk7XG4gICAgICB9XG5cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmKCBfcC5wcm9ncmVzcyA9PT0gMSApe1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheWluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFwcGx5aW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJld2luZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyggMCApO1xuICB9LFxuXG4gIGZhc3Rmb3J3YXJkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKCAxICk7XG4gIH0sXG5cbiAgdGltZTogZnVuY3Rpb24oIHQgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIHQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzICogX3AuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKCB0IC8gX3AuZHVyYXRpb24gKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uKCBwICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiggcCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiggd2FzUGxheWluZyApe1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb21wbGV0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG5cbiAgcmV2ZXJzZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiggYSwgYiApe1xuICAgICAgdmFyIF9wYSA9IF9wWyBhIF07XG5cbiAgICAgIF9wWyBhIF0gPSBfcFsgYiBdO1xuICAgICAgX3BbIGIgXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCggJ3pvb20nLCAnc3RhcnRab29tJyApO1xuICAgIHN3YXAoICdwYW4nLCAnc3RhcnRQYW4nICk7XG4gICAgc3dhcCggJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nICk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbIGkgXTtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVsgbmFtZSBdO1xuXG4gICAgICBfcC5zdGFydFN0eWxlWyBuYW1lIF0gPSBwcm9wO1xuICAgICAgX3Auc3R5bGVbIGkgXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgIH1cblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwcm9taXNlOiBmdW5jdGlvbiggdHlwZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgYXJyLnB1c2goIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gKTtcbiAgICB9ICk7XG4gIH1cblxufSApO1xuXG5hbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGFTdGFyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgdmFyIHJlY29uc3RydWN0UGF0aCA9IGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBjYW1lRnJvbU1hcCwgcGF0aEFjdW0gKXtcbiAgICAgIC8vIEJhc2UgY2FzZVxuICAgICAgaWYoIHN0YXJ0ID09IGVuZCApe1xuICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZCggZW5kICkgKTtcbiAgICAgICAgcmV0dXJuIHBhdGhBY3VtO1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kIGluIGNhbWVGcm9tTWFwICl7XG4gICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNhbWVGcm9tTWFwWyBlbmQgXTtcbiAgICAgICAgdmFyIHByZXZpb3VzRWRnZSA9IGNhbWVGcm9tRWRnZVsgZW5kIF07XG5cbiAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoIGVuZCApICk7XG4gICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKCBwcmV2aW91c0VkZ2UgKSApO1xuXG5cbiAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0UGF0aCggc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgICAgICAgICAgICAgIGNhbWVGcm9tTWFwLFxuICAgICAgICAgICAgICAgICAgICAgcGF0aEFjdW0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugc2hvdWxkIG5vdCByZWFjaCBoZXJlIVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gb3BlblNldCB3aGljaCBoYXMgbWluaW11bSBmU2NvcmVcbiAgICB2YXIgZmluZE1pbiA9IGZ1bmN0aW9uKCBvcGVuU2V0LCBmU2NvcmUgKXtcbiAgICAgIGlmKCBvcGVuU2V0Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgYmUgdGhlIGNhc2VcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Qb3MgPSAwO1xuICAgICAgdmFyIHRlbXBTY29yZSA9IGZTY29yZVsgb3BlblNldFswXSBdO1xuICAgICAgZm9yKCB2YXIgaSA9IDE7IGkgPCBvcGVuU2V0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBzID0gZlNjb3JlWyBvcGVuU2V0WyBpIF0gXTtcbiAgICAgICAgaWYoIHMgPCB0ZW1wU2NvcmUgKXtcbiAgICAgICAgICB0ZW1wU2NvcmUgPSBzO1xuICAgICAgICAgIG1pblBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5Qb3M7XG4gICAgfTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmKCBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwgKXtcbiAgICAgIHZhciBzb3VyY2UgPSBpcy5zdHJpbmcoIG9wdGlvbnMucm9vdCApID9cbiAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICAgIHRoaXMuZmlsdGVyKCBvcHRpb25zLnJvb3QgKVswXSA6XG4gICAgICAgIG9wdGlvbnMucm9vdFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBnb2FsIC0gbWFuZGF0b3J5IVxuICAgIGlmKCBvcHRpb25zLmdvYWwgIT0gbnVsbCApe1xuICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyggb3B0aW9ucy5nb2FsICkgP1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNnb2FsSURcbiAgICAgICAgdGhpcy5maWx0ZXIoIG9wdGlvbnMuZ29hbCApWzBdIDpcbiAgICAgICAgb3B0aW9ucy5nb2FsWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEhldXJpc3RpYyBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuaGV1cmlzdGljICE9IG51bGwgJiYgaXMuZm4oIG9wdGlvbnMuaGV1cmlzdGljICkgKXtcbiAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhldXJpc3RpYyA9IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9OyAvLyB1c2UgY29uc3RhbnQgaWYgdW5zcGVjaWZpZWRcbiAgICB9XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oIGUgKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VkU2V0ID0gW107XG4gICAgdmFyIG9wZW5TZXQgPSBbIHNvdXJjZS5pZCgpIF07XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG5cbiAgICBnU2NvcmVbIHNvdXJjZS5pZCgpIF0gPSAwO1xuICAgIGZTY29yZVsgc291cmNlLmlkKCkgXSA9IGhldXJpc3RpYyggc291cmNlICk7XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAvLyBDb3VudGVyXG4gICAgdmFyIHN0ZXBzID0gMDtcblxuICAgIC8vIE1haW4gbG9vcFxuICAgIHdoaWxlKCBvcGVuU2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgIHZhciBtaW5Qb3MgPSBmaW5kTWluKCBvcGVuU2V0LCBmU2NvcmUgKTtcbiAgICAgIHZhciBjTWluID0gY3kuZ2V0RWxlbWVudEJ5SWQoIG9wZW5TZXRbIG1pblBvcyBdICk7XG4gICAgICBzdGVwcysrO1xuXG4gICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgaWYoIGNNaW4uaWQoKSA9PSB0YXJnZXQuaWQoKSApe1xuICAgICAgICB2YXIgclBhdGggPSByZWNvbnN0cnVjdFBhdGgoIHNvdXJjZS5pZCgpLCB0YXJnZXQuaWQoKSwgY2FtZUZyb20sIFtdICk7XG4gICAgICAgIHJQYXRoLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgICBkaXN0YW5jZTogZ1Njb3JlWyBjTWluLmlkKCkgXSxcbiAgICAgICAgICBwYXRoOiBlbGVzLnNwYXduKCByUGF0aCApLFxuICAgICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgIGNsb3NlZFNldC5wdXNoKCBjTWluLmlkKCkgKTtcbiAgICAgIC8vIFJlbW92ZSBjTWluIGZyb20gYm91bmRhcnkgbm9kZXNcbiAgICAgIG9wZW5TZXQuc3BsaWNlKCBtaW5Qb3MsIDEgKTtcblxuICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICBpZiggZGlyZWN0ZWQgKXsgdndFZGdlcyA9IHZ3RWRnZXMuc3RkRmlsdGVyKCBmdW5jdGlvbiggZWxlICl7IHJldHVybiBlbGUuZGF0YSggJ3NvdXJjZScgKSA9PT0gY01pbi5pZCgpOyB9ICk7IH1cbiAgICAgIHZ3RWRnZXMgPSB2d0VkZ2VzLmludGVyc2VjdCggZWRnZXMgKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1sgaSBdO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5zdGRGaWx0ZXIoIGZ1bmN0aW9uKCBuICl7IHJldHVybiBuLmlkKCkgIT09IGNNaW4uaWQoKTsgfSApLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG4gICAgICAgIGlmKCBjbG9zZWRTZXQuaW5kZXhPZiggdy5pZCgpICkgIT0gLTEgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlWyBjTWluLmlkKCkgXSArIHdlaWdodEZuLmFwcGx5KCBlLCBbIGUgXSApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgLy8gT1JcbiAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuXG4gICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcbiAgICAgICAgaWYoIG9wZW5TZXQuaW5kZXhPZiggdy5pZCgpICkgPT0gLTEgKXtcbiAgICAgICAgICBnU2NvcmVbIHcuaWQoKSBdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVsgdy5pZCgpIF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWMoIHcgKTtcbiAgICAgICAgICBvcGVuU2V0LnB1c2goIHcuaWQoKSApOyAvLyBBZGQgbm9kZSB0byBvcGVuU2V0XG4gICAgICAgICAgY2FtZUZyb21bIHcuaWQoKSBdID0gY01pbi5pZCgpO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVsgdy5pZCgpIF0gPSBlLmlkKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgIGlmKCB0ZW1wU2NvcmUgPCBnU2NvcmVbIHcuaWQoKSBdICl7XG4gICAgICAgICAgZ1Njb3JlWyB3LmlkKCkgXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbIHcuaWQoKSBdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKCB3ICk7XG4gICAgICAgICAgY2FtZUZyb21bIHcuaWQoKSBdID0gY01pbi5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcblxuICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG5cbn0pOyAvLyBlbGVzZm5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbiggb3B0aW9ucy53ZWlnaHQgKSApe1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKCBlICl7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiggb3B0aW9ucy5yb290ICE9IG51bGwgKXtcbiAgICAgIGlmKCBpcy5zdHJpbmcoIG9wdGlvbnMucm9vdCApICl7XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5maWx0ZXIoIG9wdGlvbnMucm9vdCApWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoIGZ1bmN0aW9uKCBlICl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSApO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZDJwb3NpdGlvblsgbm9kZXNbIGkgXS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemF0aW9uc1xuICAgIHZhciBjb3N0ID0gW107XG4gICAgdmFyIHByZWRlY2Vzc29yID0gW107XG4gICAgdmFyIHByZWRFZGdlID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIGlmKCBub2Rlc1sgaSBdLmlkKCkgPT09IHNvdXJjZS5pZCgpICl7XG4gICAgICAgIGNvc3RbIGkgXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3N0WyBpIF0gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHByZWRlY2Vzc29yWyBpIF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gRWRnZXMgcmVsYXhhdGlvblxuICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgZm9yKCB2YXIgaSA9IDE7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrICl7XG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgZSBdLnNvdXJjZSgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBlIF0udGFyZ2V0KCkuaWQoKSBdO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2VzWyBlIF0sIFsgZWRnZXNbIGUgXSBdICk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBjb3N0WyBzb3VyY2VJbmRleCBdICsgd2VpZ2h0O1xuICAgICAgICBpZiggdGVtcCA8IGNvc3RbIHRhcmdldEluZGV4IF0gKXtcbiAgICAgICAgICBjb3N0WyB0YXJnZXRJbmRleCBdID0gdGVtcDtcbiAgICAgICAgICBwcmVkZWNlc3NvclsgdGFyZ2V0SW5kZXggXSA9IHNvdXJjZUluZGV4O1xuICAgICAgICAgIHByZWRFZGdlWyB0YXJnZXRJbmRleCBdID0gZWRnZXNbIGUgXTtcbiAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgIGlmKCAhZGlyZWN0ZWQgKXtcbiAgICAgICAgICB2YXIgdGVtcCA9IGNvc3RbIHRhcmdldEluZGV4IF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgaWYoIHRlbXAgPCBjb3N0WyBzb3VyY2VJbmRleCBdICl7XG4gICAgICAgICAgICBjb3N0WyBzb3VyY2VJbmRleCBdID0gdGVtcDtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yWyBzb3VyY2VJbmRleCBdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBwcmVkRWRnZVsgc291cmNlSW5kZXggXSA9IGVkZ2VzWyBlIF07XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFmbGFnICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBmbGFnICl7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGUgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgZSBdLnRhcmdldCgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlc1sgZSBdLCBbIGVkZ2VzWyBlIF0gXSApO1xuXG4gICAgICAgIGlmKCBjb3N0WyBzb3VyY2VJbmRleCBdICsgd2VpZ2h0IDwgY29zdFsgdGFyZ2V0SW5kZXggXSApe1xuICAgICAgICAgIHV0aWwuZXJyb3IoICdHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWdodCBjeWNsZSBmb3IgQmVsbG1hbi1Gb3JkJyApO1xuICAgICAgICAgIHJldHVybiB7IHBhdGhUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgZGlzdGFuY2VUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0XG4gICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBwb3NpdGlvbjJpZC5wdXNoKCBub2Rlc1sgaSBdLmlkKCkgKTtcbiAgICB9XG5cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiggdG8gKXtcbiAgICAgICAgaWYoIGlzLnN0cmluZyggdG8gKSApe1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKCB0byApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3N0WyBpZDJwb3NpdGlvblsgdG9JZCBdIF07XG4gICAgICB9LFxuXG4gICAgICBwYXRoVG86IGZ1bmN0aW9uKCB0byApe1xuXG4gICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbiggcHJlZGVjZXNzb3IsIGZyb21Qb3MsIHRvUG9zLCBwb3NpdGlvbjJpZCwgYWN1bVBhdGgsIHByZWRFZGdlICl7XG4gICAgICAgICAgZm9yKCA7OyApe1xuICAgICAgICAgICAgLy8gQWRkIHRvSWQgdG8gcGF0aFxuICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkWyB0b1BvcyBdICkgKTtcbiAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIHByZWRFZGdlWyB0b1BvcyBdICk7XG5cbiAgICAgICAgICAgIGlmKCBmcm9tUG9zID09PSB0b1BvcyApe1xuICAgICAgICAgICAgICAvLyByZWFjaGVkIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdW1QYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBwYXRoIGV4aXN0cywgZGlzY2FydCBhY3VtdWxhdGVkIHBhdGggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIHZhciBwcmVkUG9zID0gcHJlZGVjZXNzb3JbIHRvUG9zIF07XG4gICAgICAgICAgICBpZiggdHlwZW9mIHByZWRQb3MgPT09ICd1bmRlZmluZWQnICl7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvUG9zID0gcHJlZFBvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXMuc3RyaW5nKCB0byApICl7XG4gICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIoIHRvIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gW107XG5cbiAgICAgICAgLy8gVGhpcyByZXR1cm5zIGEgcmV2ZXJzZWQgcGF0aFxuICAgICAgICB2YXIgcmVzID0gIHJlY29uc3RydWN0UGF0aEF1eCggcHJlZGVjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bIHNvdXJjZS5pZCgpIF0sXG4gICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bIHRvSWQgXSxcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIHByZWRFZGdlICk7XG5cbiAgICAgICAgLy8gR2V0IGl0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCByZXR1cm4gaXRcbiAgICAgICAgaWYoIHJlcyAhPSBudWxsICl7XG4gICAgICAgICAgcmVzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKCByZXMgKTtcbiAgICAgIH0sXG5cbiAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiByZXM7XG5cbiAgfSAvLyBiZWxsbWFuRm9yZFxuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG52YXIgSGVhcCA9IHJlcXVpcmUoICcuLi8uLi9oZWFwJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gdGhlIHBhcGVyIFwiT24gVmFyaWFudHMgb2YgU2hvcnRlc3QtUGF0aCBCZXR3ZWVubmVzcyBDZW50cmFsaXR5IGFuZCB0aGVpciBHZW5lcmljIENvbXB1dGF0aW9uXCIgYnkgVWxyaWsgQnJhbmRlc1xuICBiZXR3ZWVubmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBXZWlnaHQgLSBvcHRpb25hbFxuICAgIHZhciB3ZWlnaHRlZCwgd2VpZ2h0Rm47XG4gICAgaWYoIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgd2VpZ2h0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ZWlnaHRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERpcmVjdGVkIC0gZGVmYXVsdCBmYWxzZVxuICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCA/IG9wdGlvbnMuZGlyZWN0ZWQgOiBmYWxzZTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAvLyBzdGFydGluZ1xuICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBBID0ge307XG4gICAgdmFyIF9DID0ge307XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIEMgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKCBrZXksIHZhbCApe1xuICAgICAgICBfQ1sga2V5IF0gPSB2YWw7XG5cbiAgICAgICAgaWYoIHZhbCA+IG1heCApeyBtYXggPSB2YWw7IH1cbiAgICAgIH0sXG5cbiAgICAgIGdldDogZnVuY3Rpb24oIGtleSApeyByZXR1cm4gX0NbIGtleSBdOyB9XG4gICAgfTtcblxuICAgIC8vIEEgY29udGFpbnMgdGhlIG5laWdoYm9yaG9vZHMgb2YgZXZlcnkgbm9kZVxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHYgPSBWWyBpIF07XG4gICAgICB2YXIgdmlkID0gdi5pZCgpO1xuXG4gICAgICBpZiggZGlyZWN0ZWQgKXtcbiAgICAgICAgQVsgdmlkIF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbIHZpZCBdID0gdi5vcGVuTmVpZ2hib3Job29kKCkubm9kZXMoKTsgLy8gZ2V0IG5laWdoYm9ycyBvZiBldmVyeSBub2RlXG4gICAgICB9XG5cbiAgICAgIEMuc2V0KCB2aWQsIDAgKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBzID0gMDsgcyA8IFYubGVuZ3RoOyBzKysgKXtcbiAgICAgIHZhciBzaWQgPSBWW3NdLmlkKCk7XG4gICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuICAgICAgdmFyIFAgPSB7fTtcbiAgICAgIHZhciBnID0ge307XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiggYSwgYiApe1xuICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICB9KTsgLy8gcXVldWVcblxuICAgICAgLy8gaW5pdCBkaWN0aW9uYXJpZXNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdmlkID0gVlsgaSBdLmlkKCk7XG5cbiAgICAgICAgUFsgdmlkIF0gPSBbXTtcbiAgICAgICAgZ1sgdmlkIF0gPSAwO1xuICAgICAgICBkWyB2aWQgXSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBnWyBzaWQgXSA9IDE7IC8vIHNpZ21hXG4gICAgICBkWyBzaWQgXSA9IDA7IC8vIGRpc3RhbmNlIHRvIHNcblxuICAgICAgUS5wdXNoKCBzaWQgKTtcblxuICAgICAgd2hpbGUoICFRLmVtcHR5KCkgKXtcbiAgICAgICAgdmFyIHYgPSBRLnBvcCgpO1xuXG4gICAgICAgIFMucHVzaCggdiApO1xuXG4gICAgICAgIGlmKCB3ZWlnaHRlZCApe1xuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgQVt2XS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHcgPSBBW3ZdW2pdO1xuICAgICAgICAgICAgdmFyIHZFbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggdiApO1xuXG4gICAgICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgICAgIGlmKCB2RWxlLmVkZ2VzVG8oIHcgKS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAgIGVkZ2UgPSB2RWxlLmVkZ2VzVG8oIHcgKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSB3LmVkZ2VzVG8oIHZFbGUgKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcblxuICAgICAgICAgICAgdyA9IHcuaWQoKTtcblxuICAgICAgICAgICAgaWYoIGRbd10gPiBkW3ZdICsgZWRnZVdlaWdodCApe1xuICAgICAgICAgICAgICBkW3ddID0gZFt2XSArIGVkZ2VXZWlnaHQ7XG5cbiAgICAgICAgICAgICAgaWYoIFEubm9kZXMuaW5kZXhPZiggdyApIDwgMCApeyAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICBRLnB1c2goIHcgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgIFEudXBkYXRlSXRlbSggdyApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ1t3XSA9IDA7XG4gICAgICAgICAgICAgIFBbd10gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRbd10gPT0gZFt2XSArIGVkZ2VXZWlnaHQgKXtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goIHYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBBW3ZdLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgdyA9IEFbdl1bal0uaWQoKTtcblxuICAgICAgICAgICAgaWYoIGRbd10gPT0gSW5maW5pdHkgKXtcbiAgICAgICAgICAgICAgUS5wdXNoKCB3ICk7XG5cbiAgICAgICAgICAgICAgZFt3XSA9IGRbdl0gKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZFt3XSA9PSBkW3ZdICsgMSApe1xuICAgICAgICAgICAgICBnW3ddID0gZ1t3XSArIGdbdl07XG4gICAgICAgICAgICAgIFBbd10ucHVzaCggdiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVbIFZbIGkgXS5pZCgpIF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSggUy5sZW5ndGggPiAwICl7XG4gICAgICAgIHZhciB3ID0gUy5wb3AoKTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IFBbd10ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgdiA9IFBbd11bal07XG5cbiAgICAgICAgICBlW3ZdID0gZVt2XSArIChnW3ZdIC8gZ1t3XSkgKiAoMSArIGVbd10pO1xuXG4gICAgICAgICAgaWYoIHcgIT0gVltzXS5pZCgpICl7XG4gICAgICAgICAgICBDLnNldCggdywgQy5nZXQoIHcgKSArIGVbd10gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgIHZhciBub2RlID0gY3kuZmlsdGVyKCBub2RlICkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDLmdldCggbm9kZSApO1xuICAgICAgfSxcblxuICAgICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICBpZiAoIG1heCA9PSAwIClcbiAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBpZiggaXMuc3RyaW5nKCBub2RlICkgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IGN5LmZpbHRlciggbm9kZSApLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQy5nZXQoIG5vZGUgKSAvIG1heDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWxpYXNcbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcblxuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gYmV0d2Vlbm5lc3NDZW50cmFsaXR5XG5cbn0pOyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmJjID0gZWxlc2ZuLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTtcblxuICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbiggcm9vdHMsIGZuLCBkaXJlY3RlZCApe1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciBzdGQ7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KCByb290cyApICYmICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCByb290cyApICl7XG4gICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHMgfHwgb3B0aW9ucy5yb290O1xuICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgc3RkID0gb3B0aW9ucy5zdGQ7XG4gICAgICB0aGlzQXJnID0gb3B0aW9ucy50aGlzQXJnO1xuICAgIH1cblxuICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhaXMuZm4oIGZuICkgPyBmbiA6IGRpcmVjdGVkO1xuICAgIGZuID0gaXMuZm4oIGZuICkgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IGlzLnN0cmluZyggcm9vdHMgKSA/IHRoaXMuZmlsdGVyKCByb290cyApIDogcm9vdHM7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgViA9IHt9O1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgZm91bmQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcblxuICAgIC8vIGVucXVldWUgdlxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyApe1xuICAgICAgaWYoIHZbIGkgXS5pc05vZGUoKSApe1xuICAgICAgICBRLnVuc2hpZnQoIHZbIGkgXSApO1xuXG4gICAgICAgIGlmKCBwYXJhbXMuYmZzICl7XG4gICAgICAgICAgVlsgdlsgaSBdLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB2WyBpIF0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkMmRlcHRoWyB2WyBpIF0uaWQoKSBdID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSggUS5sZW5ndGggIT09IDAgKXtcbiAgICAgIHZhciB2ID0gcGFyYW1zLmJmcyA/IFEuc2hpZnQoKSA6IFEucG9wKCk7XG5cbiAgICAgIGlmKCBwYXJhbXMuZGZzICl7XG4gICAgICAgIGlmKCBWWyB2LmlkKCkgXSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIFZbIHYuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB2ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyB2LmlkKCkgXTtcbiAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5WyB2LmlkKCkgXTtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2RWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdCggdiApWzBdO1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYoIHN0ZCApe1xuICAgICAgICByZXQgPSBmbi5jYWxsKCB0aGlzQXJnLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwoIHYsIGorKywgZGVwdGgsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggcmV0ID09PSB0cnVlICl7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoIGRpcmVjdGVkID8gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YSggJ3NvdXJjZScgKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkICkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1sgaSBdO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlkKCkgIT09IHYuaWQoKTsgfSApLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICBpZiggdy5sZW5ndGggIT09IDAgJiYgIVZbIHcuaWQoKSBdICl7XG4gICAgICAgICAgdyA9IHdbMF07XG5cbiAgICAgICAgICBRLnB1c2goIHcgKTtcblxuICAgICAgICAgIGlmKCBwYXJhbXMuYmZzICl7XG4gICAgICAgICAgICBWWyB3LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25uZWN0ZWRCeVsgdy5pZCgpIF0gPSBlO1xuXG4gICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbIGkgXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICBpZiggZWRnZSApe1xuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKCBmb3VuZCApXG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiA9ICh7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKCB7IGJmczogdHJ1ZSB9ICksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCggeyBkZnM6IHRydWUgfSApXG59KTtcblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmJmcyA9IGVsZXNmbi5icmVhZHRoRmlyc3RTZWFyY2g7XG5lbGVzZm4uZGZzID0gZWxlc2ZuLmRlcHRoRmlyc3RTZWFyY2g7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICBpZiggaGFybW9uaWMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgaGFybW9uaWMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgIHZhciBtYXhDbG9zZW5lc3MgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoIHsgd2VpZ2h0OiBvcHRpb25zLndlaWdodCwgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQgfSApO1xuXG4gICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICBpZiggaSAhPSBqICl7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZSggbm9kZXNbIGkgXSwgbm9kZXNbIGogXSApO1xuXG4gICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhaGFybW9uaWMgKXtcbiAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiggbWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcyApe1xuICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBjbG9zZW5lc3Nlc1sgbm9kZXNbIGkgXS5pZCgpIF0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIGlmKCBtYXhDbG9zZW5lc3MgPT0gMCApeyByZXR1cm4gMDsgfVxuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIoIG5vZGUgKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzWyBub2RlIF0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMucm9vdCAhPSBudWxsICl7XG4gICAgICBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3QgKSApe1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmZpbHRlciggb3B0aW9ucy5yb290IClbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcm9vdCA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyB3ZWlnaHQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3ZWlnaHQgPSBmdW5jdGlvbigpe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgJiYgaXMuYm9vbCggb3B0aW9ucy5kaXJlY3RlZCApICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBoYXJtb25pYyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSgge1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSApO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBpZiggbm9kZXNbIGkgXS5pZCgpICE9IHJvb3QuaWQoKSApe1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8oIG5vZGVzWyBpIF0gKTtcblxuICAgICAgICBpZiggaGFybW9uaWMgKXtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbn0pOyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuZWxlc2ZuLmNjID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHk7XG5lbGVzZm4uY2NuID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCApe1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmKCAhZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtyb290OiBub2RlfSApICk7XG4gICAgICAgIGlmKCBtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSApXG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgZGVncmVlc1sgbm9kZS5pZCgpIF0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIGlmKCBtYXhEZWdyZWUgPT0gMCApXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVncmVlc1sgbm9kZSBdIC8gbWF4RGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heEluZGVncmVlID0gMDtcbiAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkoIHV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9ICkgKTtcblxuICAgICAgICBpZiggbWF4SW5kZWdyZWUgPCBjdXJyRGVncmVlLmluZGVncmVlIClcbiAgICAgICAgICBtYXhJbmRlZ3JlZSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG5cbiAgICAgICAgaWYoIG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlIClcbiAgICAgICAgICBtYXhPdXRkZWdyZWUgPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcblxuICAgICAgICBpbmRlZ3JlZXNbIG5vZGUuaWQoKSBdID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1sgbm9kZS5pZCgpIF0gPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgaWYgKCBtYXhJbmRlZ3JlZSA9PSAwIClcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgICAgaWYoIGlzLnN0cmluZyggbm9kZSApICl7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIoIG5vZGUgKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbIG5vZGUgXSAvIG1heEluZGVncmVlO1xuICAgICAgICB9LFxuICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgaWYgKCBtYXhPdXRkZWdyZWUgPT0gMCApXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKCBub2RlIClbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlc1sgbm9kZSBdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJvb3QgIT0gbnVsbCApe1xuICAgICAgdmFyIHJvb3QgPSBpcy5zdHJpbmcoIG9wdGlvbnMucm9vdCApID8gdGhpcy5maWx0ZXIoIG9wdGlvbnMucm9vdCApWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHdlaWdodCAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgKXtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5hbHBoYSAhPSBudWxsICYmIGlzLm51bWJlciggb3B0aW9ucy5hbHBoYSApICl7XG4gICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgfVxuXG5cbiAgICBpZiggIWRpcmVjdGVkICl7XG4gICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5FZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5FZGdlc1sgaSBdO1xuICAgICAgICBzICs9IHdlaWdodEZuLmFwcGx5KCBlZGdlLCBbIGVkZ2UgXSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWdyZWU6IE1hdGgucG93KCBrLCAxIC0gYWxwaGEgKSAqIE1hdGgucG93KCBzLCBhbHBoYSApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5jb21pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCAnZWRnZVt0YXJnZXQgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJyApLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgIHZhciBvdXRnb2luZyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoICdlZGdlW3NvdXJjZSA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nICkuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgdmFyIGtfaW4gPSBpbmNvbWluZy5sZW5ndGg7XG4gICAgICB2YXIga19vdXQgPSBvdXRnb2luZy5sZW5ndGg7XG4gICAgICB2YXIgc19pbiA9IDA7XG4gICAgICB2YXIgc19vdXQgPSAwO1xuXG4gICAgICAvLyBOb3csIHN1bSBpbmNvbWluZyBlZGdlIHdlaWdodHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5jb21pbmcubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBpbmNvbWluZ1sgaSBdO1xuICAgICAgICBzX2luICs9IHdlaWdodEZuLmFwcGx5KCBlZGdlLCBbIGVkZ2UgXSApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHN1bSBvdXRnb2luZyBlZGdlIHdlaWdodHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3V0Z29pbmcubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBvdXRnb2luZ1sgaSBdO1xuICAgICAgICBzX291dCArPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KCBrX2luLCAxIC0gYWxwaGEgKSAqIE1hdGgucG93KCBzX2luLCBhbHBoYSApLFxuICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KCBrX291dCwgMSAtIGFscGhhICkgKiBNYXRoLnBvdyggc19vdXQsIGFscGhhIClcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uZGMgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbi5kY24gPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG52YXIgSGVhcCA9IHJlcXVpcmUoICcuLi8uLi9oZWFwJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICBkaWprc3RyYTogZnVuY3Rpb24oIHJvb3QsIHdlaWdodEZuLCBkaXJlY3RlZCApe1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggcm9vdCApICYmICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCByb290ICkgKXtcbiAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB3ZWlnaHRGbiA9IGlzLmZuKCB3ZWlnaHRGbiApID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgdmFyIHNvdXJjZSA9IGlzLnN0cmluZyggcm9vdCApID8gdGhpcy5maWx0ZXIoIHJvb3QgKVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5maWx0ZXIoIGZ1bmN0aW9uKCl7IHJldHVybiAhdGhpcy5pc0xvb3AoKTsgfSApO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgIHJldHVybiBkaXN0WyBub2RlLmlkKCkgXTtcbiAgICB9O1xuXG4gICAgdmFyIHNldERpc3QgPSBmdW5jdGlvbiggbm9kZSwgZCApe1xuICAgICAgZGlzdFsgbm9kZS5pZCgpIF0gPSBkO1xuXG4gICAgICBRLnVwZGF0ZUl0ZW0oIG5vZGUgKTtcbiAgICB9O1xuXG4gICAgdmFyIFEgPSBuZXcgSGVhcCggZnVuY3Rpb24oIGEsIGIgKXtcbiAgICAgIHJldHVybiBnZXREaXN0KCBhICkgLSBnZXREaXN0KCBiICk7XG4gICAgfSApO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXG4gICAgICBkaXN0WyBub2RlLmlkKCkgXSA9IG5vZGUuc2FtZSggc291cmNlICkgPyAwIDogSW5maW5pdHk7XG4gICAgICBRLnB1c2goIG5vZGUgKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbiggdSwgdiApe1xuICAgICAgdmFyIHV2cyA9ICggZGlyZWN0ZWQgPyB1LmVkZ2VzVG8oIHYgKSA6IHUuZWRnZXNXaXRoKCB2ICkgKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICB2YXIgc21hbGxlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSB1dnNbIGkgXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlLCBbIGVkZ2UgXSApO1xuXG4gICAgICAgIGlmKCB3ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UgKXtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSggUS5zaXplKCkgPiAwICl7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCggdSApO1xuICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcblxuICAgICAga25vd25EaXN0WyB1aWQgXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBub2RlcyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbIGkgXTtcbiAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4oIHUsIHYgKTtcblxuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiggYWx0IDwgZ2V0RGlzdCggdiApICl7XG4gICAgICAgICAgc2V0RGlzdCggdiwgYWx0ICk7XG5cbiAgICAgICAgICBwcmV2WyB2aWQgXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9IC8vIHdoaWxlXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyggbm9kZSApID8gbm9kZXMuZmlsdGVyKCBub2RlIClbMF0gOiBub2RlWzBdO1xuXG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbIHRhcmdldC5pZCgpIF07XG4gICAgICB9LFxuXG4gICAgICBwYXRoVG86IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcoIG5vZGUgKSA/IG5vZGVzLmZpbHRlciggbm9kZSApWzBdIDogbm9kZVswXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYoIHRhcmdldC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgUy51bnNoaWZ0KCB0YXJnZXQgKTtcblxuICAgICAgICAgIHdoaWxlKCBwcmV2WyB1LmlkKCkgXSApe1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2WyB1LmlkKCkgXTtcblxuICAgICAgICAgICAgUy51bnNoaWZ0KCBwLmVkZ2UgKTtcbiAgICAgICAgICAgIFMudW5zaGlmdCggcC5ub2RlICk7XG5cbiAgICAgICAgICAgIHUgPSBwLm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oIFMgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmKCBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKCBvcHRpb25zLndlaWdodCApICl7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oIGUgKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICl7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgaWQycG9zaXRpb25bIG5vZGVzWyBpIF0uaWQoKSBdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBkaXN0ID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KCBudW1Ob2RlcyApO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgIGlmKCBpID09IGogKXtcbiAgICAgICAgICBuZXdSb3dbIGogXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um93WyBqIF0gPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzdC5wdXNoKCBuZXdSb3cgKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgbmV4dCA9IFtdO1xuICAgIHZhciBlZGdlTmV4dCA9IFtdO1xuXG4gICAgdmFyIGluaXRNYXRyaXggPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkoIG51bU5vZGVzICk7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIG5ld1Jvd1sgaiBdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG5leHQucHVzaCggbmV3Um93ICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRNYXRyaXgoIG5leHQgKTtcbiAgICBpbml0TWF0cml4KCBlZGdlTmV4dCApO1xuXG4gICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrICl7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS5zb3VyY2UoKS5pZCgpIF07XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvblsgZWRnZXNbIGkgXS50YXJnZXQoKS5pZCgpIF07XG4gICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2VzWyBpIF0sIFsgZWRnZXNbIGkgXSBdICk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgIGlmKCBkaXN0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID4gd2VpZ2h0ICl7XG4gICAgICAgIGRpc3RbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSB3ZWlnaHQ7XG4gICAgICAgIG5leHRbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgZWRnZU5leHRbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSBlZGdlc1sgaSBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlc1xuICAgIGlmKCAhZGlyZWN0ZWQgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrICl7XG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uWyBlZGdlc1sgaSBdLnRhcmdldCgpLmlkKCkgXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bIGVkZ2VzWyBpIF0uc291cmNlKCkuaWQoKSBdO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2VzWyBpIF0sIFsgZWRnZXNbIGkgXSBdICk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgICBpZiggZGlzdFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA+IHdlaWdodCApe1xuICAgICAgICAgIGRpc3RbIHNvdXJjZUluZGV4IF1bIHRhcmdldEluZGV4IF0gPSB3ZWlnaHQ7XG4gICAgICAgICAgbmV4dFsgc291cmNlSW5kZXggXVsgdGFyZ2V0SW5kZXggXSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgIGVkZ2VOZXh0WyBzb3VyY2VJbmRleCBdWyB0YXJnZXRJbmRleCBdID0gZWRnZXNbIGkgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciggdmFyIGsgPSAwOyBrIDwgbnVtTm9kZXM7IGsrKyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIGlmKCBkaXN0WyBpIF1bIGsgXSArIGRpc3RbIGsgXVsgaiBdIDwgZGlzdFsgaSBdWyBqIF0gKXtcbiAgICAgICAgICAgIGRpc3RbIGkgXVsgaiBdID0gZGlzdFsgaSBdWyBrIF0gKyBkaXN0WyBrIF1bIGogXTtcbiAgICAgICAgICAgIG5leHRbIGkgXVsgaiBdID0gbmV4dFsgaSBdWyBrIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdFxuICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgcG9zaXRpb24yaWQucHVzaCggbm9kZXNbIGkgXS5pZCgpICk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiggZnJvbSwgdG8gKXtcbiAgICAgICAgaWYoIGlzLnN0cmluZyggZnJvbSApICl7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciBmcm9tSWQgPSAoY3kuZmlsdGVyKCBmcm9tIClbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGlzLnN0cmluZyggdG8gKSApe1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKCB0byApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0WyBpZDJwb3NpdGlvblsgZnJvbUlkIF0gXVsgaWQycG9zaXRpb25bIHRvSWQgXSBdO1xuICAgICAgfSxcblxuICAgICAgcGF0aDogZnVuY3Rpb24oIGZyb20sIHRvICl7XG4gICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbiggZnJvbSwgdG8sIG5leHQsIHBvc2l0aW9uMmlkLCBlZGdlTmV4dCApe1xuICAgICAgICAgIGlmKCBmcm9tID09PSB0byApe1xuICAgICAgICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFsgZnJvbSBdICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCBuZXh0WyBmcm9tIF1bIHRvIF0gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGF0aCA9IFsgY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkWyBmcm9tIF0gKSBdO1xuICAgICAgICAgIHZhciBwcmV2ID0gZnJvbTtcbiAgICAgICAgICB3aGlsZSggZnJvbSAhPT0gdG8gKXtcbiAgICAgICAgICAgIHByZXYgPSBmcm9tO1xuICAgICAgICAgICAgZnJvbSA9IG5leHRbIGZyb20gXVsgdG8gXTtcblxuICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlTmV4dFsgcHJldiBdWyBmcm9tIF07XG4gICAgICAgICAgICBwYXRoLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICAgICAgcGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbIGZyb20gXSApICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIGZyb20gKSApe1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlciggZnJvbSApWzBdKS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIHRvICkgKXtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlciggdG8gKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aEFyciA9IHJlY29uc3RydWN0UGF0aEF1eCggaWQycG9zaXRpb25bIGZyb21JZCBdLFxuICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uWyB0b0lkIF0sXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCxcbiAgICAgICAgICAgICAgICAgICAgICBlZGdlTmV4dCApO1xuXG4gICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCBwYXRoQXJyICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZXM7XG5cbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbn0pOyAvLyBlbGVzZm5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxuW1xuICByZXF1aXJlKCAnLi9iZnMtZGZzJyApLFxuICByZXF1aXJlKCAnLi9kaWprc3RyYScgKSxcbiAgcmVxdWlyZSggJy4va3J1c2thbCcgKSxcbiAgcmVxdWlyZSggJy4vYS1zdGFyJyApLFxuICByZXF1aXJlKCAnLi9mbG95ZC13YXJzaGFsbCcgKSxcbiAgcmVxdWlyZSggJy4vYmVsbG1hbi1mb3JkJyApLFxuICByZXF1aXJlKCAnLi9rZXJnZXItc3RlaW4nICksXG4gIHJlcXVpcmUoICcuL3BhZ2UtcmFuaycgKSxcbiAgcmVxdWlyZSggJy4vZGVncmVlLWNlbnRyYWxpdHknICksXG4gIHJlcXVpcmUoICcuL2Nsb3NlbmVzcy1jZW50cmFsaXR5JyApLFxuICByZXF1aXJlKCAnLi9iZXR3ZWVubmVzcy1jZW50cmFsaXR5JyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggZWxlc2ZuLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gRnVuY3Rpb24gd2hpY2ggY29sYXBzZXMgMiAobWV0YSkgbm9kZXMgaW50byBvbmVcbiAgICAvLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuICAgIC8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcbiAgICB2YXIgY29sYXBzZSA9IGZ1bmN0aW9uKCBlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzICl7XG4gICAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1sgZWRnZUluZGV4IF07XG4gICAgICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgICAgIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICAgICAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwWyBzb3VyY2VJbiBdO1xuICAgICAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwWyB0YXJnZXRJbiBdO1xuXG4gICAgICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICAgICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXMuZmlsdGVyKCBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICBpZiggbm9kZU1hcFsgZWRnZVsxXSBdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbIGVkZ2VbMl0gXSA9PT0gcGFydGl0aW9uMiApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiggbm9kZU1hcFsgZWRnZVsxXSBdID09PSBwYXJ0aXRpb24yICYmIG5vZGVNYXBbIGVkZ2VbMl0gXSA9PT0gcGFydGl0aW9uMSApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gKTtcblxuICAgICAgLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5ld0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gbmV3RWRnZXNbIGkgXTtcbiAgICAgICAgaWYoIGVkZ2VbMV0gPT09IHBhcnRpdGlvbjIgKXsgLy8gQ2hlY2sgc291cmNlXG4gICAgICAgICAgbmV3RWRnZXNbIGkgXSA9IGVkZ2Uuc2xpY2UoIDAgKTtcbiAgICAgICAgICBuZXdFZGdlc1sgaSBdWzFdID0gcGFydGl0aW9uMTtcbiAgICAgICAgfSBlbHNlIGlmKCBlZGdlWzJdID09PSBwYXJ0aXRpb24yICl7IC8vIENoZWNrIHRhcmdldFxuICAgICAgICAgIG5ld0VkZ2VzWyBpIF0gPSBlZGdlLnNsaWNlKCAwICk7XG4gICAgICAgICAgbmV3RWRnZXNbIGkgXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZU1hcC5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggbm9kZU1hcFsgaSBdID09PSBwYXJ0aXRpb24yICl7XG4gICAgICAgICAgbm9kZU1hcFsgaSBdID0gcGFydGl0aW9uMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3RWRnZXM7XG4gICAgfTtcblxuXG4gICAgLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG4gICAgdmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbiggbWV0YU5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRWRnZXMsXG4gICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICBzaXplTGltaXQgKXtcbiAgICAgIC8vIFN0b3AgY29uZGl0aW9uXG4gICAgICBpZiggc2l6ZSA8PSBzaXplTGltaXQgKXtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xuICAgICAgfVxuXG4gICAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoIChNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKSApO1xuXG4gICAgICAvLyBDb2xhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcbiAgICAgIHZhciBuZXdFZGdlcyA9IGNvbGFwc2UoIGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzICk7XG5cbiAgICAgIHJldHVybiBjb250cmFjdFVudGlsKCBtZXRhTm9kZU1hcCxcbiAgICAgICAgICAgICAgICAgbmV3RWRnZXMsXG4gICAgICAgICAgICAgICAgIHNpemUgLSAxLFxuICAgICAgICAgICAgICAgICBzaXplTGltaXQgKTtcbiAgICB9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbCggTWF0aC5wb3coIE1hdGgubG9nKCBudW1Ob2RlcyApIC8gTWF0aC5MTjIsIDIgKSApO1xuICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IoIG51bU5vZGVzIC8gTWF0aC5zcXJ0KCAyICkgKTtcblxuICAgIGlmKCBudW1Ob2RlcyA8IDIgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyLVN0ZWluIGFsZ29yaXRobScgKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG51bWVyaWNhbCBpZGVudGlmaWVycyBmb3IgZWFjaCBub2RlXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIC8vIGZvciByZXZlcnNlIG1hcHBpbmcsIHNpbXBseSB1c2Ugbm9kZXMgYXJyYXlcbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIGlkMnBvc2l0aW9uWyBub2Rlc1sgaSBdLmlkKCkgXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrICl7XG4gICAgICB2YXIgZSA9IGVkZ2VzWyBpIF07XG4gICAgICBlZGdlSW5kZXhlcy5wdXNoKCBbIGksIGlkMnBvc2l0aW9uWyBlLnNvdXJjZSgpLmlkKCkgXSwgaWQycG9zaXRpb25bIGUudGFyZ2V0KCkuaWQoKSBdIF0gKTtcbiAgICB9XG5cbiAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG4gICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluQ3V0O1xuXG4gICAgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgdmFyIG9yaWdpbmFsTWV0YU5vZGUgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIG9yaWdpbmFsTWV0YU5vZGUucHVzaCggaSApO1xuICAgIH1cblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciggdmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKyApe1xuICAgICAgLy8gQ3JlYXRlIG5ldyBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICB2YXIgbWV0YU5vZGVNYXAgPSBvcmlnaW5hbE1ldGFOb2RlLnNsaWNlKCAwICk7XG5cbiAgICAgIC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKCBtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMsIG51bU5vZGVzLCBzdG9wU2l6ZSApO1xuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuICAgICAgdmFyIG1ldGFOb2RlTWFwMiA9IG1ldGFOb2RlTWFwLnNsaWNlKCAwICk7XG5cbiAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbCggbWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyICk7XG4gICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwoIG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIgKTtcblxuICAgICAgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cbiAgICAgIGlmKCByZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUgKXtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICBtaW5DdXQgPSBbIHJlczEsIG1ldGFOb2RlTWFwIF07XG4gICAgICB9IGVsc2UgaWYoIHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSApe1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgIG1pbkN1dCA9IFsgcmVzMiwgbWV0YU5vZGVNYXAyIF07XG4gICAgICB9XG4gICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG5cblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgcmVzRWRnZXMgPSAobWluQ3V0WzBdKS5tYXAoIGZ1bmN0aW9uKCBlICl7IHJldHVybiBlZGdlc1sgZVswXSBdOyB9ICk7XG4gICAgdmFyIHBhcnRpdGlvbjEgPSBbXTtcbiAgICB2YXIgcGFydGl0aW9uMiA9IFtdO1xuXG4gICAgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG4gICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0WzFdWzBdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbWluQ3V0WzFdLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcGFydGl0aW9uSWQgPSBtaW5DdXRbMV1bIGkgXTtcbiAgICAgIGlmKCBwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24gKXtcbiAgICAgICAgcGFydGl0aW9uMS5wdXNoKCBub2Rlc1sgaSBdICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0aXRpb24yLnB1c2goIG5vZGVzWyBpIF0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBlbGVzLnNwYXduKCBjeSwgcmVzRWRnZXMgKSxcbiAgICAgIHBhcnRpdGlvbjE6IGVsZXMuc3Bhd24oIHBhcnRpdGlvbjEgKSxcbiAgICAgIHBhcnRpdGlvbjI6IGVsZXMuc3Bhd24oIHBhcnRpdGlvbjIgKVxuICAgIH07XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59KTsgLy8gZWxlc2ZuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxuLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGtydXNrYWw6IGZ1bmN0aW9uKCB3ZWlnaHRGbiApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHdlaWdodEZuID0gaXMuZm4oIHdlaWdodEZuICkgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICBmdW5jdGlvbiBmaW5kU2V0KCBlbGUgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGVzID0gZm9yZXN0WyBpIF07XG5cbiAgICAgICAgaWYoIGVsZXMuYW55U2FtZSggZWxlICkgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlczogZWxlcyxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBBID0gY3kuY29sbGVjdGlvbiggY3ksIFtdICk7XG4gICAgdmFyIGZvcmVzdCA9IFtdO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGZvcmVzdC5wdXNoKCBub2Rlc1sgaSBdLmNvbGxlY3Rpb24oKSApO1xuICAgIH1cblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgUyA9IGVkZ2VzLnRvQXJyYXkoKS5zb3J0KCBmdW5jdGlvbiggYSwgYiApe1xuICAgICAgdmFyIHdlaWdodEEgPSB3ZWlnaHRGbi5jYWxsKCBhLCBhICk7XG4gICAgICB2YXIgd2VpZ2h0QiA9IHdlaWdodEZuLmNhbGwoIGIsIGIgKTtcblxuICAgICAgcmV0dXJuIHdlaWdodEEgLSB3ZWlnaHRCO1xuICAgIH0gKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgUy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBTWyBpIF07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VSA9IGZpbmRTZXQoIHUgKTtcbiAgICAgIHZhciBzZXRWID0gZmluZFNldCggdiApO1xuXG4gICAgICBpZiggc2V0VS5pbmRleCAhPT0gc2V0Vi5pbmRleCApe1xuICAgICAgICBBID0gQS5hZGQoIGVkZ2UgKTtcblxuICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgZm9yZXN0WyBzZXRVLmluZGV4IF0gPSBzZXRVLmVsZXMuYWRkKCBzZXRWLmVsZXMgKTtcbiAgICAgICAgZm9yZXN0LnNwbGljZSggc2V0Vi5pbmRleCwgMSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlcy5hZGQoIEEgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIHBhZ2VSYW5rOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG5vcm1hbGl6ZVZlY3RvciA9IGZ1bmN0aW9uKCB2ZWN0b3IgKXtcbiAgICAgIHZhciBsZW5ndGggPSB2ZWN0b3IubGVuZ3RoO1xuXG4gICAgICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRvdGFsICs9IHZlY3RvclsgaSBdO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZlY3RvclsgaSBdID0gdmVjdG9yWyBpIF0gLyB0b3RhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZGFtcGluZ0ZhY3RvciAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5kYW1waW5nRmFjdG9yICE9IG51bGwgKXtcbiAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gb3B0aW9ucy5kYW1waW5nRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IDAuODsgLy8gRGVmYXVsdCBkYW1waW5nIGZhY3RvclxuICAgIH1cblxuICAgIC8vIGRlc2lyZWQgcHJlY2lzaW9uIC0gb3B0aW9uYWxcbiAgICBpZiggb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICBvcHRpb25zLnByZWNpc2lvbiAhPSBudWxsICl7XG4gICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDAxOyAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIH1cblxuICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5pdGVyYXRpb25zICE9IG51bGwgKXtcbiAgICAgIHZhciBudW1JdGVyID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbnVtSXRlciA9IDIwMDsgLy8gRGVmYXVsdCBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgIH1cblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYoIG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJlxuICAgICAgaXMuZm4oIG9wdGlvbnMud2VpZ2h0ICkgKXtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiggZSApe3JldHVybiAxO307XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKCBmdW5jdGlvbiggZSApeyByZXR1cm4gIWUuaXNMb29wKCk7IH0gKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICBpZDJwb3NpdGlvblsgbm9kZXNbIGkgXS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICB2YXIgbWF0cml4ID0gW107XG4gICAgdmFyIGNvbHVtblN1bSA9IFtdO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpY1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApe1xuICAgICAgdmFyIG5ld1JvdyA9IFtdO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgIG5ld1Jvdy5wdXNoKCAwLjAgKTtcbiAgICAgIH1cbiAgICAgIG1hdHJpeC5wdXNoKCBuZXdSb3cgKTtcbiAgICAgIGNvbHVtblN1bS5wdXNoKCAwLjAgKTtcbiAgICB9XG5cbiAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbIGkgXTtcbiAgICAgIHZhciBzID0gaWQycG9zaXRpb25bIGVkZ2Uuc291cmNlKCkuaWQoKSBdO1xuICAgICAgdmFyIHQgPSBpZDJwb3NpdGlvblsgZWRnZS50YXJnZXQoKS5pZCgpIF07XG4gICAgICB2YXIgdyA9IHdlaWdodEZuLmFwcGx5KCBlZGdlLCBbIGVkZ2UgXSApO1xuXG4gICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICBtYXRyaXhbIHQgXVsgcyBdICs9IHc7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG4gICAgICBjb2x1bW5TdW1bIHMgXSArPSB3O1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICBpZiggY29sdW1uU3VtWyBqIF0gPT09IDAgKXtcbiAgICAgICAgLy8gTm8gJ2xpbmtzJyBvdXQgZnJvbSBub2RlIGp0aCwgYXNzdW1lIGVxdWFsIHByb2JhYmlsaXR5IGZvciBlYWNoIHBvc3NpYmxlIG5vZGVcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgICAgbWF0cml4WyBpIF1bIGogXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgICAgICBtYXRyaXhbIGkgXVsgaiBdID0gbWF0cml4WyBpIF1bIGogXSAvIGNvbHVtblN1bVsgaiBdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgIHZhciBlaWdlbnZlY3RvciA9IFtdO1xuICAgIHZhciBudWxsVmVjdG9yID0gW107XG4gICAgdmFyIHByZXZpb3VzO1xuXG4gICAgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXtcbiAgICAgIGVpZ2VudmVjdG9yLnB1c2goIDEuMCApO1xuICAgICAgbnVsbFZlY3Rvci5wdXNoKCAwLjAgKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpdGVyID0gMDsgaXRlciA8IG51bUl0ZXI7IGl0ZXIrKyApe1xuICAgICAgLy8gTmV3IGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgdmFyIHRlbXAgPSBudWxsVmVjdG9yLnNsaWNlKCAwICk7XG5cbiAgICAgIC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIHRlbXBbIGkgXSArPSBtYXRyaXhbIGkgXVsgaiBdICogZWlnZW52ZWN0b3JbIGogXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub3JtYWxpemVWZWN0b3IoIHRlbXAgKTtcbiAgICAgIHByZXZpb3VzID0gZWlnZW52ZWN0b3I7XG4gICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG5cbiAgICAgIHZhciBkaWZmID0gMDtcbiAgICAgIC8vIENvbXB1dGUgZGlmZmVyZW5jZSAoc3F1YXJlZCBtb2R1bGUpIG9mIGJvdGggdmVjdG9yc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7XG4gICAgICAgIGRpZmYgKz0gTWF0aC5wb3coIHByZXZpb3VzWyBpIF0gLSBlaWdlbnZlY3RvclsgaSBdLCAyICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcbiAgICAgIGlmKCBkaWZmIDwgZXBzaWxvbiApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHJhbms6IGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIGlmKCBpcy5zdHJpbmcoIG5vZGUgKSApe1xuICAgICAgICAgIC8vIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIG5vZGVJZCA9IChjeS5maWx0ZXIoIG5vZGUgKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIG5vZGUgb2JqZWN0XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3JbIGlkMnBvc2l0aW9uWyBub2RlSWQgXSBdO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHJldHVybiByZXM7XG4gIH0gLy8gcGFnZVJhbmtcblxufSk7IC8vIGVsZXNmblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lLnN0b3AoKVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgY2xhc3NlczogZnVuY3Rpb24oIGNsYXNzZXMgKXtcbiAgICBjbGFzc2VzID0gKCBjbGFzc2VzIHx8ICcnICkubWF0Y2goIC9cXFMrL2cgKSB8fCBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICB2YXIgY2xhc3Nlc01hcCA9IHt9O1xuXG4gICAgLy8gZmlsbCBpbiBjbGFzc2VzIG1hcFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNscyA9IGNsYXNzZXNbIGkgXTtcblxuICAgICAgY2xhc3Nlc01hcFsgY2xzIF0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGFuZCB1cGRhdGUgZWFjaCBlbGVcbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmWyBqIF07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IF9wLmNsYXNzZXM7XG4gICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGFsbCBvZiB0aGUgcGFzc2VkIGNsYXNzZXNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1sgaSBdO1xuICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzWyBjbHMgXTtcblxuICAgICAgICBpZiggIWVsZUhhc0NsYXNzICl7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG4gICAgICBpZiggIWNoYW5nZWRFbGUgKXtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBPYmplY3Qua2V5cyggZWxlQ2xhc3NlcyApO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGVDbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXNbIGVsZUNscyBdO1xuICAgICAgICAgIHZhciBzcGVjZENsYXNzID0gY2xhc3Nlc01hcFsgZWxlQ2xzIF07IC8vIGkuZS4gdGhpcyBjbGFzcyBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXG5cbiAgICAgICAgICBpZiggZWxlSGFzQ2xhc3MgJiYgIXNwZWNkQ2xhc3MgKXtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBjaGFuZ2VkRWxlICl7XG4gICAgICAgIF9wLmNsYXNzZXMgPSB1dGlsLmNvcHkoIGNsYXNzZXNNYXAgKTtcblxuICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgIHRoaXMuc3Bhd24oIGNoYW5nZWQgKVxuICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAudHJpZ2dlciggJ2NsYXNzJyApXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzICl7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoIGNsYXNzZXMsIHRydWUgKTtcbiAgfSxcblxuICBoYXNDbGFzczogZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiAoIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzWyBjbGFzc05hbWUgXSApID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggY2xhc3Nlc1N0ciwgdG9nZ2xlICl7XG4gICAgdmFyIGNsYXNzZXMgPSBjbGFzc2VzU3RyLm1hdGNoKCAvXFxTKy9nICkgfHwgW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHNlbGZbIGkgXTtcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1sgaiBdO1xuICAgICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzWyBjbHMgXTtcbiAgICAgICAgdmFyIHNob3VsZEFkZCA9IHRvZ2dsZSB8fCAodG9nZ2xlID09PSB1bmRlZmluZWQgJiYgIWhhc0NsYXNzKTtcblxuICAgICAgICBpZiggc2hvdWxkQWRkICl7XG4gICAgICAgICAgZWxlQ2xhc3Nlc1sgY2xzIF0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYoICFoYXNDbGFzcyAmJiAhY2hhbmdlZEVsZSApe1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZW1vdmVcbiAgICAgICAgICBlbGVDbGFzc2VzWyBjbHMgXSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYoIGhhc0NsYXNzICYmICFjaGFuZ2VkRWxlICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgIH0gLy8gZm9yIGkgZWxlc1xuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgdGhpcy5zcGF3biggY2hhbmdlZCApXG4gICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgIC50cmlnZ2VyKCAnY2xhc3MnIClcbiAgICAgIDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICByZW1vdmVDbGFzczogZnVuY3Rpb24oIGNsYXNzZXMgKXtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyggY2xhc3NlcywgZmFsc2UgKTtcbiAgfSxcblxuICBmbGFzaENsYXNzOiBmdW5jdGlvbiggY2xhc3NlcywgZHVyYXRpb24gKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggZHVyYXRpb24gPT0gbnVsbCApe1xuICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgfSBlbHNlIGlmKCBkdXJhdGlvbiA9PT0gMCApe1xuICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgfVxuXG4gICAgc2VsZi5hZGRDbGFzcyggY2xhc3NlcyApO1xuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc2VzICk7XG4gICAgfSwgZHVyYXRpb24gKTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBhbGxBcmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlciggc2VsZWN0b3IgKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICB9LFxuXG4gIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMDtcbiAgfSxcblxuICBzb21lOiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzWyBpIF0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbIGkgXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgIGlmKCByZXQgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGV2ZXJ5OiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzWyBpIF0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbIGkgXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgIGlmKCAhcmV0ICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBzYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgLy8gY2hlYXAgZXh0cmEgY2hlY2tcbiAgICBpZiggdGhpcy5sZW5ndGggIT09IGNvbGxlY3Rpb24ubGVuZ3RoICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSB0aGlzLmxlbmd0aDtcbiAgfSxcblxuICBhbnlTYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID4gMDtcbiAgfSxcblxuICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxufSk7XG5cbmVsZXNmbi5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuLmFsbEFyZU5laWdoYm9ycztcbmVsZXNmbi5oYXMgPSBlbGVzZm4uY29udGFpbnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgcGFyZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCApO1xuXG4gICAgICBpZiggcGFyZW50LnNpemUoKSA+IDAgKXtcbiAgICAgICAgcGFyZW50cy5wdXNoKCBwYXJlbnQgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBwYXJlbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgIHdoaWxlKCBlbGVzLm5vbmVtcHR5KCkgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgICBwYXJlbnRzLnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KCBwYXJlbnRzICk7IC8vIGN1cnJlbnQgbGlzdCBtdXN0IGJlIGNvbW1vbiB3aXRoIGN1cnJlbnQgZWxlIHBhcmVudHMgc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgb3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKCBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5lbXB0eSgpO1xuICAgIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgbm9ub3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKCBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgY2hpbGRyZW46IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbiApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBjaGlsZHJlbiwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBzaWJsaW5nczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG5cbiAgaXNDaGlsZDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBlbGUucGFyZW50KCkubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcblxuICBkZXNjZW5kYW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmdW5jdGlvbiBhZGQoIGVsZXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuXG4gICAgICAgIGlmKCBlbGUuY2hpbGRyZW4oKS5ub25lbXB0eSgpICl7XG4gICAgICAgICAgYWRkKCBlbGUuY2hpbGRyZW4oKSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkKCB0aGlzLmNoaWxkcmVuKCkgKTtcblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbmVsZXNmbi5hbmNlc3RvcnMgPSBlbGVzZm4ucGFyZW50cztcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xudmFyIGZuLCBlbGVzZm47XG5cbmZuID0gZWxlc2ZuID0gKHtcblxuICBkYXRhOiBkZWZpbmUuZGF0YSgge1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0gKSxcblxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSgge1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0gKSxcblxuICBzY3JhdGNoOiBkZWZpbmUuZGF0YSgge1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0gKSxcblxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSgge1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0gKSxcblxuICByc2NyYXRjaDogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0gKSxcblxuICByZW1vdmVSc2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoIHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0gKSxcblxuICBpZDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICB9XG4gIH1cblxufSk7XG5cbi8vIGFsaWFzZXNcbmZuLmF0dHIgPSBmbi5kYXRhO1xuZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCBpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiggc2VsZi5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkgKXtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzWyBpIF07XG5cbiAgICAgICAgaWYoICFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSApe1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKCBub2RlLCBlZGdlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbiggZnVuY3Rpb24oIG5vZGUsIGVkZ2UgKXtcbiAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKCBlZGdlLnRhcmdldCgpICkgKXtcbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gKSxcblxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oIGZ1bmN0aW9uKCBub2RlLCBlZGdlICl7XG4gICAgaWYoIGVkZ2UudGFyZ2V0KCkuc2FtZSggbm9kZSApICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9ICksXG5cbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbiggZnVuY3Rpb24oIG5vZGUsIGVkZ2UgKXtcbiAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKCBub2RlICkgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0gKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggZGVncmVlRm4sIGNhbGxiYWNrICl7XG4gIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbIGkgXTtcbiAgICAgIHZhciBkZWdyZWUgPSBlbGVbIGRlZ3JlZUZuIF0oIGluY2x1ZGVMb29wcyApO1xuICAgICAgaWYoIGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayggZGVncmVlLCByZXQgKSkgKXtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ2RlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1pbiApe1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0gKSxcblxuICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCAnZGVncmVlJywgZnVuY3Rpb24oIGRlZ3JlZSwgbWF4ICl7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSApLFxuXG4gIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ2luZGVncmVlJywgZnVuY3Rpb24oIGRlZ3JlZSwgbWluICl7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSApLFxuXG4gIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ2luZGVncmVlJywgZnVuY3Rpb24oIGRlZ3JlZSwgbWF4ICl7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSApLFxuXG4gIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oICdvdXRkZWdyZWUnLCBmdW5jdGlvbiggZGVncmVlLCBtaW4gKXtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9ICksXG5cbiAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiggJ291dGRlZ3JlZScsIGZ1bmN0aW9uKCBkZWdyZWUsIG1heCApe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0gKVxufSApO1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB0b3RhbCArPSBub2Rlc1sgaSBdLmRlZ3JlZSggaW5jbHVkZUxvb3BzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4uL2RlZmluZScgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi9tYXRoJyApO1xudmFyIGZuLCBlbGVzZm47XG5cbmZuID0gZWxlc2ZuID0gKHtcblxuICBwb3NpdGlvbjogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3J0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdmFsaWRLZXlzOiBbICd4JywgJ3knIF0sXG4gICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB1cGRhdGVkRWxlcy5ydHJpZ2dlciggJ3Bvc2l0aW9uJyApO1xuICAgIH0sXG4gICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCk7XG4gICAgfVxuICB9ICksXG5cbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lLmRhdGEoIHtcbiAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyAneCcsICd5JyBdLFxuICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgZWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIH0sXG4gICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCk7XG4gICAgfVxuICB9ICksXG5cbiAgcG9zaXRpb25zOiBmdW5jdGlvbiggcG9zLCBzaWxlbnQgKXtcbiAgICBpZiggaXMucGxhaW5PYmplY3QoIHBvcyApICl7XG4gICAgICB0aGlzLnBvc2l0aW9uKCBwb3MgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuZm4oIHBvcyApICl7XG4gICAgICB2YXIgZm4gPSBwb3M7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuXG4gICAgICAgIHZhciBwb3MgPSBmbi5hcHBseSggZWxlLCBbIGksIGVsZSBdICk7XG5cbiAgICAgICAgaWYoIHBvcyAmJiAhZWxlLmxvY2tlZCgpICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICAgIHZhciBlbGVQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgZWxlUG9zLnggPSBwb3MueDtcbiAgICAgICAgICBlbGVQb3MueSA9IHBvcy55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b1RyaWdnZXIgPSB1cGRhdGVkRWxlcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRFbGVzICkgOiB0aGlzO1xuXG4gICAgICBpZiggc2lsZW50ICl7XG4gICAgICAgIHRvVHJpZ2dlci50cmlnZ2VyKCAncG9zaXRpb24nICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1RyaWdnZXIucnRyaWdnZXIoICdwb3NpdGlvbicgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MgKXtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMoIHBvcywgdHJ1ZSApO1xuICB9LFxuXG4gIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBycG9zID0gaXMucGxhaW5PYmplY3QoIGRpbSApID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgaXMuc3RyaW5nKCBkaW0gKSApO1xuXG4gICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uWyBkaW0gXSA9ICggdmFsIC0gcGFuWyBkaW0gXSApIC8gem9vbTtcbiAgICAgICAgICB9IGVsc2UgaWYoIHJwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC8gem9vbSxcbiAgICAgICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC8gem9vbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ0cmlnZ2VyKCAncG9zaXRpb24nICk7XG4gICAgICB9IGVsc2UgeyAvLyBnZXR0aW5nXG4gICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHJwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggZGltID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3NbIGRpbSBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCAhc2V0dGluZyApe1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgcmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBwcG9zID0gaXMucGxhaW5PYmplY3QoIGRpbSApID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgaXMuc3RyaW5nKCBkaW0gKSApO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbIGkgXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bIGRpbSBdID0gdmFsICsgb3JpZ2luWyBkaW0gXTtcbiAgICAgICAgICB9IGVsc2UgaWYoIHBwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnRyaWdnZXIoICdwb3NpdGlvbicgKTtcblxuICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBvcmlnaW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBwcG9zWyBkaW0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW5kZXJlZEJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goIG9wdGlvbnMgKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTE6IHkxLFxuICAgICAgeTI6IHkyLFxuICAgICAgdzogeDIgLSB4MSxcbiAgICAgIGg6IHkyIC0geTFcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZUNvbXBvdW5kQm91bmRzOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIC8vIHNhdmUgY3ljbGVzIGZvciBub24gY29tcG91bmQgZ3JhcGhzIG9yIHdoZW4gc3R5bGUgZGlzYWJsZWRcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTsgfVxuXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSggcGFyZW50ICl7XG4gICAgICBpZiggIXBhcmVudC5pc1BhcmVudCgpICl7IHJldHVybjsgfVxuXG4gICAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gcGFyZW50LnBzdHlsZSggJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJyApLnZhbHVlID09PSAnaW5jbHVkZSc7XG5cbiAgICAgIHZhciBtaW4gPSB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCAnbWluLXdpZHRoJyApLnBmVmFsdWUsXG4gICAgICAgICAgbGVmdDogcGFyZW50LnBzdHlsZSggJ21pbi13aWR0aC1iaWFzLWxlZnQnICksXG4gICAgICAgICAgcmlnaHQ6IHBhcmVudC5wc3R5bGUoICdtaW4td2lkdGgtYmlhcy1yaWdodCcgKVxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoICdtaW4taGVpZ2h0JyApLnBmVmFsdWUsXG4gICAgICAgICAgdG9wOiBwYXJlbnQucHN0eWxlKCAnbWluLWhlaWdodC1iaWFzLXRvcCcgKSxcbiAgICAgICAgICBib3R0b206IHBhcmVudC5wc3R5bGUoICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJyApXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KCB7XG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsXG4gICAgICAgIGluY2x1ZGVTaGFkb3dzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcblxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgY29tcG91bmQgYm91bmRzIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgcmVndWxhclxuICAgICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICAgIH0gKTtcbiAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZUJpYXNWYWx1ZXMoIHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50ICl7XG4gICAgICAgIHZhciBiaWFzRGlmZiA9IDA7XG4gICAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG5cbiAgICAgICAgaWYoIHByb3BEaWZmID4gMCAmJiBiaWFzVG90YWwgPiAwICl7XG4gICAgICAgICAgYmlhc0RpZmYgPSAoIHByb3BCaWFzIC8gYmlhc1RvdGFsICkgKiBwcm9wRGlmZjtcbiAgICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSAoIHByb3BCaWFzQ29tcGxlbWVudCAvIGJpYXNUb3RhbCApICogcHJvcERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiaWFzRGlmZjogYmlhc0RpZmYsXG4gICAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnRWYWwgPSBtaW4ud2lkdGgubGVmdC52YWx1ZTtcbiAgICAgIGlmKCBtaW4ud2lkdGgubGVmdC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCApe1xuICAgICAgICBsZWZ0VmFsID0gKCBsZWZ0VmFsICogMTAwICkgLyBtaW4ud2lkdGgudmFsO1xuICAgICAgfVxuICAgICAgdmFyIHJpZ2h0VmFsID0gbWluLndpZHRoLnJpZ2h0LnZhbHVlO1xuICAgICAgaWYoIG1pbi53aWR0aC5yaWdodC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCApe1xuICAgICAgICByaWdodFZhbCA9ICggcmlnaHRWYWwgKiAxMDAgKSAvIG1pbi53aWR0aC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3BWYWwgPSBtaW4uaGVpZ2h0LnRvcC52YWx1ZTtcbiAgICAgIGlmKCBtaW4uaGVpZ2h0LnRvcC51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDAgKXtcbiAgICAgICAgdG9wVmFsID0gKCB0b3BWYWwgKiAxMDAgKSAvIG1pbi5oZWlnaHQudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm90dG9tVmFsID0gbWluLmhlaWdodC5ib3R0b20udmFsdWU7XG4gICAgICBpZiggbWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwICl7XG4gICAgICAgIGJvdHRvbVZhbCA9ICggYm90dG9tVmFsICogMTAwICkgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoQmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMoIG1pbi53aWR0aC52YWwgLSBiYi53LCBsZWZ0VmFsLCByaWdodFZhbCApO1xuICAgICAgdmFyIGRpZmZMZWZ0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgICB2YXIgZGlmZlJpZ2h0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuXG4gICAgICB2YXIgaGVpZ2h0Qmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMoIG1pbi5oZWlnaHQudmFsIC0gYmIuaCwgdG9wVmFsLCBib3R0b21WYWwgKTtcbiAgICAgIHZhciBkaWZmVG9wID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgICAgdmFyIGRpZmZCb3R0b20gPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuXG4gICAgICBfcC5hdXRvV2lkdGggPSBNYXRoLm1heChiYi53LCBtaW4ud2lkdGgudmFsKTtcbiAgICAgIHBvcy54ID0gKC0gZGlmZkxlZnQgKyBiYi54MSArIGJiLngyICsgZGlmZlJpZ2h0KSAvIDI7XG5cbiAgICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgICBwb3MueSA9ICgtIGRpZmZCb3R0b20gKyBiYi55MSArIGJiLnkyICsgZGlmZlRvcCkgLyAyO1xuXG4gICAgICB1cGRhdGVkLnB1c2goIHBhcmVudCApO1xuICAgIH1cblxuICAgIC8vIGdvIHVwLCBsZXZlbCBieSBsZXZlbFxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG5cbiAgICAgIC8vIHVwZGF0ZSBlYWNoIHBhcmVudCBub2RlIGluIHRoaXMgbGV2ZWxcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgICAgIHVwZGF0ZSggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQgbGV2ZWxcbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBjaGFuZ2VkXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHVwZGF0ZWQgKTtcbiAgfVxufSk7XG5cbnZhciBub25pbmYgPSBmdW5jdGlvbiggeCApe1xuICBpZiggeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5ICl7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiggYiwgeDEsIHkxLCB4MiwgeTIgKXtcbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gIGlmKCB4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgYi54MSA9IHgxIDwgYi54MSA/IHgxIDogYi54MTtcbiAgYi54MiA9IHgyID4gYi54MiA/IHgyIDogYi54MjtcbiAgYi55MSA9IHkxIDwgYi55MSA/IHkxIDogYi55MTtcbiAgYi55MiA9IHkyID4gYi55MiA/IHkyIDogYi55Mjtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24oIGIsIGIyICl7XG4gIHJldHVybiB1cGRhdGVCb3VuZHMoIGIsIGIyLngxLCBiMi55MSwgYjIueDIsIGIyLnkyICk7XG59O1xuXG52YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIGZpZWxkLCBwcmVmaXggKXtcbiAgcmV0dXJuIHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggb2JqLCBmaWVsZCwgcHJlZml4ICk7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24oIGJvdW5kcywgZWxlLCBwcmVmaXgsIG9wdGlvbnMgKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgaGFsZkFyVyA9IHJzdHlsZS5hcnJvd1dpZHRoIC8gMjtcbiAgdmFyIGFycm93VHlwZSA9IGVsZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctc2hhcGUnICkudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiggYXJyb3dUeXBlICE9PSAnbm9uZScgKXtcbiAgICBpZiggcHJlZml4ID09PSAnc291cmNlJyApe1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiggcHJlZml4ID09PSAndGFyZ2V0JyApe1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfVxuXG4gICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIHggLSBoYWxmQXJXLCB5IC0gaGFsZkFyVywgeCArIGhhbGZBclcsIHkgKyBoYWxmQXJXICk7XG4gIH1cbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiggYm91bmRzLCBlbGUsIHByZWZpeCwgb3B0aW9ucyApe1xuICB2YXIgcHJlZml4RGFzaDtcblxuICBpZiggcHJlZml4ICl7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAnbGFiZWwnICkuc3RyVmFsdWU7XG5cbiAgaWYoIGxhYmVsICl7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LWhhbGlnbicgKTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtdmFsaWduJyApO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eSggcnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCApO1xuICAgIHZhciBsYWJlbEhlaWdodCA9IHByZWZpeGVkUHJvcGVydHkoIHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4ICk7XG4gICAgdmFyIGxhYmVsWCA9IHByZWZpeGVkUHJvcGVydHkoIHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCApO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KCByc3R5bGUsICdsYWJlbFknLCBwcmVmaXggKTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcgKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZSggcHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JyApLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKCBwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nICk7XG4gICAgdmFyIHNoYWRvd1IgPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctYmx1cicgKS5wZlZhbHVlIC8gMjtcbiAgICB2YXIgc2hhZG93WCA9IGVsZS5wc3R5bGUoICd0ZXh0LXNoYWRvdy1vZmZzZXQteCcgKS5wZlZhbHVlO1xuICAgIHZhciBzaGFkb3dZID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LW9mZnNldC15JyApLnBmVmFsdWU7XG4gICAgdmFyIHNoYWRvd09wYWNpdHkgPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctb3BhY2l0eScgKS52YWx1ZTtcbiAgICB2YXIgb3V0bGluZVdpZHRoID0gZWxlLnBzdHlsZSggJ3RleHQtb3V0bGluZS13aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LWJvcmRlci13aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgdmFyIHBhZGRpbmcgPSBlbGUucHN0eWxlKCAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnICkucGZWYWx1ZTtcblxuICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0ICsgMiAqIHBhZGRpbmc7XG4gICAgdmFyIGx3ID0gbGFiZWxXaWR0aCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBsd18yID0gbHcgLyAyO1xuICAgIHZhciBsaF8yID0gbGggLyAyO1xuICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG5cbiAgICBpZiggaXNFZGdlICl7XG4gICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2goIGhhbGlnbi52YWx1ZSApe1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWDtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKCB2YWxpZ24udmFsdWUgKXtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaDtcbiAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzQXV0b3JvdGF0ZSA9ICggaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScgKTtcbiAgICB2YXIgaXNQZlZhbHVlID0gKCByb3RhdGlvbi5wZlZhbHVlICE9IG51bGwgJiYgcm90YXRpb24ucGZWYWx1ZSAhPT0gMCApO1xuXG4gICAgaWYoIGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUgKXtcbiAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoIF9wLnJzdHlsZSwgJ2xhYmVsQW5nbGUnLCBwcmVmaXggKSA6IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiggeCwgeSApe1xuICAgICAgICB4ID0geCAtIGxhYmVsWDtcbiAgICAgICAgeSA9IHkgLSBsYWJlbFk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGxhYmVsWCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGxhYmVsWVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKCBseDEsIGx5MSApO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKCBseDEsIGx5MiApO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKCBseDIsIGx5MSApO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKCBseDIsIGx5MiApO1xuXG4gICAgICBseDEgPSBNYXRoLm1pbiggcHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCApO1xuICAgICAgbHgyID0gTWF0aC5tYXgoIHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLnggKTtcbiAgICAgIGx5MSA9IE1hdGgubWluKCBweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55ICk7XG4gICAgICBseTIgPSBNYXRoLm1heCggcHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSApO1xuICAgIH1cblxuICAgIGx4MSArPSBtYXJnaW5YIC0gTWF0aC5tYXgoIG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoICk7XG4gICAgbHgyICs9IG1hcmdpblggKyBNYXRoLm1heCggb3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGggKTtcbiAgICBseTEgKz0gbWFyZ2luWSAtIE1hdGgubWF4KCBvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCApO1xuICAgIGx5MiArPSBtYXJnaW5ZICsgTWF0aC5tYXgoIG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoICk7XG5cbiAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgbHgxLCBseTEsIGx4MiwgbHkyICk7XG5cbiAgICBpZiggb3B0aW9ucy5pbmNsdWRlU2hhZG93cyAmJiBzaGFkb3dPcGFjaXR5ID4gMCApe1xuICAgICAgbHgxICs9IC0gc2hhZG93UiArIHNoYWRvd1g7XG4gICAgICBseDIgKz0gKyBzaGFkb3dSICsgc2hhZG93WDtcbiAgICAgIGx5MSArPSAtIHNoYWRvd1IgKyBzaGFkb3dZO1xuICAgICAgbHkyICs9ICsgc2hhZG93UiArIHNoYWRvd1k7XG5cbiAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTtcblxuLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG52YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24oIGVsZSwgb3B0aW9ucyApe1xuICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeV9wLnN0eWxlRW5hYmxlZDtcblxuICB2YXIgYm91bmRzID0ge1xuICAgIHgxOiBJbmZpbml0eSxcbiAgICB5MTogSW5maW5pdHksXG4gICAgeDI6IC1JbmZpbml0eSxcbiAgICB5MjogLUluZmluaXR5XG4gIH07XG5cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlRW5hYmxlZCA/IGVsZS5wc3R5bGUoICdkaXNwbGF5JyApLnZhbHVlIDogJ2VsZW1lbnQnO1xuICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyLCB4LCB5O1xuICB2YXIgZGlzcGxheWVkID0gZGlzcGxheSAhPT0gJ25vbmUnO1xuXG4gIGlmKCBkaXNwbGF5ZWQgKXtcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IDA7XG5cbiAgICBpZiggc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzICl7XG4gICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoICdvdmVybGF5LW9wYWNpdHknICkudmFsdWU7XG5cbiAgICAgIGlmKCBvdmVybGF5T3BhY2l0eSAhPT0gMCApe1xuICAgICAgICBvdmVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoICdvdmVybGF5LXBhZGRpbmcnICkudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciB3SGFsZiA9IDA7XG5cbiAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICB3ID0gZWxlLnBzdHlsZSggJ3dpZHRoJyApLnBmVmFsdWU7XG4gICAgICB3SGFsZiA9IHcgLyAyO1xuICAgIH1cblxuICAgIGlmKCBpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMgKXtcbiAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcbiAgICAgIHZhciB3ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBoYWxmVyA9IHcgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyO1xuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVyAtIG92ZXJsYXlQYWRkaW5nO1xuICAgICAgZXgyID0geCArIGhhbGZXICsgb3ZlcmxheVBhZGRpbmc7XG4gICAgICBleTEgPSB5IC0gaGFsZkggLSBvdmVybGF5UGFkZGluZztcbiAgICAgIGV5MiA9IHkgKyBoYWxmSCArIG92ZXJsYXlQYWRkaW5nO1xuXG4gICAgICB1cGRhdGVCb3VuZHMoIGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzRWRnZSAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyApe1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZSB8fCB7fTtcblxuICAgICAgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICBleDEgPSBNYXRoLm1pbiggcnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCApO1xuICAgICAgICBleDIgPSBNYXRoLm1heCggcnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCApO1xuICAgICAgICBleTEgPSBNYXRoLm1pbiggcnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSApO1xuICAgICAgICBleTIgPSBNYXRoLm1heCggcnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSApO1xuXG4gICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcbiAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgZXkyICs9IHdIYWxmO1xuXG4gICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlY2lzZSBoYXlzdGFja3NcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICBpZiggc3R5bGVFbmFibGVkICYmIGVsZS5wc3R5bGUoICdjdXJ2ZS1zdHlsZScgKS5zdHJWYWx1ZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgICB2YXIgaHB0cyA9IHJzdHlsZS5oYXlzdGFja1B0cztcblxuICAgICAgICBleDEgPSBocHRzWzBdLng7XG4gICAgICAgIGV5MSA9IGhwdHNbMF0ueTtcbiAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICBleTIgPSBocHRzWzFdLnk7XG5cbiAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSAtIHdIYWxmLCBleTEgLSB3SGFsZiwgZXgyICsgd0hhbGYsIGV5MiArIHdIYWxmICk7XG5cbiAgICAgIC8vIGhhbmRsZSBwb2ludHMgYWxvbmcgZWRnZVxuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHRzID0gcnN0eWxlLmJlemllclB0cyB8fCByc3R5bGUubGluZVB0cyB8fCBbXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBwdCA9IHB0c1sgaiBdO1xuXG4gICAgICAgICAgZXgxID0gcHQueCAtIHdIYWxmO1xuICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgZXkyID0gcHQueSArIHdIYWxmO1xuXG4gICAgICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5MiApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICBpZiggcHRzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIHZhciBuMSA9IF9wLnNvdXJjZTtcbiAgICAgICAgICB2YXIgbjFfcCA9IG4xLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBuMXBvcyA9IG4xX3AucG9zaXRpb247XG5cbiAgICAgICAgICB2YXIgbjIgPSBfcC50YXJnZXQ7XG4gICAgICAgICAgdmFyIG4yX3AgPSBuMi5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgbjJwb3MgPSBuMl9wLnBvc2l0aW9uO1xuXG4gICAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICAgIGlmKCBleDEgPiBleDIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZXkxID4gZXkyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV5MTtcbiAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgIGV5MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuICAgICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICAgIGV5MiArPSB3SGFsZjtcblxuICAgICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSAvLyBlZGdlc1xuXG4gICAgLy8gc2hhZG93IGFuZCBvdmVybGF5XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBpZiggc3R5bGVFbmFibGVkICl7XG5cbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcblxuICAgICAgaWYoIG9wdGlvbnMuaW5jbHVkZVNoYWRvd3MgJiYgZWxlLnBzdHlsZSgnc2hhZG93LW9wYWNpdHknKS52YWx1ZSA+IDAgKXtcbiAgICAgICAgdmFyIHIgPSBlbGUucHN0eWxlKCdzaGFkb3ctYmx1cicpLnBmVmFsdWUgLyAyO1xuICAgICAgICB2YXIgb3ggPSBlbGUucHN0eWxlKCdzaGFkb3ctb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgb3kgPSBlbGUucHN0eWxlKCdzaGFkb3ctb2Zmc2V0LXknKS5wZlZhbHVlO1xuXG4gICAgICAgIHVwZGF0ZUJvdW5kcyggYm91bmRzLCBleDEgLSByICsgb3gsIGV5MSAtIHIgKyBveSwgZXgyICsgciArIG94LCBleTIgKyByICsgb3kgKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQm91bmRzKCBib3VuZHMsIGV4MSAtIG92ZXJsYXlQYWRkaW5nLCBleTEgLSBvdmVybGF5UGFkZGluZywgZXgyICsgb3ZlcmxheVBhZGRpbmcsIGV5MiArIG92ZXJsYXlQYWRkaW5nICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlICl7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coIGJvdW5kcywgZWxlLCAnbWlkLXNvdXJjZScsIG9wdGlvbnMgKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyggYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jywgb3B0aW9ucyApO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KCBib3VuZHMsIGVsZSwgJ3NvdXJjZScsIG9wdGlvbnMgKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyggYm91bmRzLCBlbGUsICd0YXJnZXQnLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVMYWJlbHMgKXtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbCggYm91bmRzLCBlbGUsIG51bGwsIG9wdGlvbnMgKTtcblxuICAgICAgaWYoIGlzRWRnZSApe1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoIGJvdW5kcywgZWxlLCAnc291cmNlJywgb3B0aW9ucyApO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoIGJvdW5kcywgZWxlLCAndGFyZ2V0Jywgb3B0aW9ucyApO1xuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cbiAgYm91bmRzLngxID0gbm9uaW5mKCBib3VuZHMueDEgKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKCBib3VuZHMueTEgKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKCBib3VuZHMueDIgKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKCBib3VuZHMueTIgKTtcbiAgYm91bmRzLncgPSBub25pbmYoIGJvdW5kcy54MiAtIGJvdW5kcy54MSApO1xuICBib3VuZHMuaCA9IG5vbmluZiggYm91bmRzLnkyIC0gYm91bmRzLnkxICk7XG5cbiAgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG4gIGlmKCBib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCApe1xuICAgIG1hdGguZXhwYW5kQm91bmRpbmdCb3goIGJvdW5kcywgMSApO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbnZhciB0ZiA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgaWYoIHZhbCApe1xuICAgIHJldHVybiAndCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdmJztcbiAgfVxufTtcblxudmFyIGdldEtleSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIHZhciBrZXkgPSAnJztcblxuICBrZXkgKz0gdGYoIG9wdHMuaW5jdWRlTm9kZXMgKTtcbiAga2V5ICs9IHRmKCBvcHRzLmluY2x1ZGVFZGdlcyApO1xuICBrZXkgKz0gdGYoIG9wdHMuaW5jbHVkZUxhYmVscyApO1xuICBrZXkgKz0gdGYoIG9wdHMuaW5jbHVkZVNoYWRvd3MgKTtcbiAga2V5ICs9IHRmKCBvcHRzLmluY2x1ZGVPdmVybGF5cyApO1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG52YXIgY2FjaGVkQm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24oIGVsZSwgb3B0cyApe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBiYjtcbiAgdmFyIGhlYWRsZXNzID0gZWxlLmN5KCkuaGVhZGxlc3MoKTtcbiAgdmFyIGtleSA9IG9wdHMgPT09IGRlZkJiT3B0cyA/IGRlZkJiT3B0c0tleSA6IGdldEtleSggb3B0cyApO1xuXG4gIGlmKCAhb3B0cy51c2VDYWNoZSB8fCBoZWFkbGVzcyB8fCAhX3AuYmJDYWNoZSB8fCAhX3AuYmJDYWNoZVtrZXldICl7XG4gICAgYmIgPSBib3VuZGluZ0JveEltcGwoIGVsZSwgb3B0cyApO1xuXG4gICAgaWYoICFoZWFkbGVzcyApe1xuICAgICAgX3AuYmJDYWNoZSA9IF9wLmJiQ2FjaGUgfHwge307XG4gICAgICBfcC5iYkNhY2hlW2tleV0gPSBiYjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmIgPSBfcC5iYkNhY2hlW2tleV07XG4gIH1cblxuICByZXR1cm4gYmI7XG59O1xuXG52YXIgZGVmQmJPcHRzID0ge1xuICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVNoYWRvd3M6IHRydWUsXG4gIGluY2x1ZGVPdmVybGF5czogdHJ1ZSxcbiAgdXNlQ2FjaGU6IHRydWVcbn07XG5cbnZhciBkZWZCYk9wdHNLZXkgPSBnZXRLZXkoIGRlZkJiT3B0cyApO1xuXG5lbGVzZm4ucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIHVzZUNhY2hlICl7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gIGlmKCByZW5kZXJlciAmJiBzdHlsZUVuYWJsZWQgKXtcbiAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIHRoaXMsIHVzZUNhY2hlICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZpbGxlZEJiT3B0cyggb3B0aW9ucyApe1xuICByZXR1cm4ge1xuICAgIGluY2x1ZGVOb2RlczogdXRpbC5kZWZhdWx0KCBvcHRpb25zLmluY2x1ZGVOb2RlcywgZGVmQmJPcHRzLmluY2x1ZGVOb2RlcyApLFxuICAgIGluY2x1ZGVFZGdlczogdXRpbC5kZWZhdWx0KCBvcHRpb25zLmluY2x1ZGVFZGdlcywgZGVmQmJPcHRzLmluY2x1ZGVFZGdlcyApLFxuICAgIGluY2x1ZGVMYWJlbHM6IHV0aWwuZGVmYXVsdCggb3B0aW9ucy5pbmNsdWRlTGFiZWxzLCBkZWZCYk9wdHMuaW5jbHVkZUxhYmVscyApLFxuICAgIGluY2x1ZGVTaGFkb3dzOiB1dGlsLmRlZmF1bHQoIG9wdGlvbnMuaW5jbHVkZVNoYWRvd3MsIGRlZkJiT3B0cy5pbmNsdWRlU2hhZG93cyApLFxuICAgIGluY2x1ZGVPdmVybGF5czogdXRpbC5kZWZhdWx0KCBvcHRpb25zLmluY2x1ZGVPdmVybGF5cywgZGVmQmJPcHRzLmluY2x1ZGVPdmVybGF5cyApLFxuICAgIHVzZUNhY2hlOiB1dGlsLmRlZmF1bHQoIG9wdGlvbnMudXNlQ2FjaGUsIGRlZkJiT3B0cy51c2VDYWNoZSApXG4gIH07XG59XG5cbmVsZXNmbi5ib3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIC8vIHRoZSBtYWluIHVzZWNhc2UgaXMgZWxlLmJvdW5kaW5nQm94KCkgZm9yIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBuby9kZWYgb3B0aW9uc1xuICAvLyBzcGVjaWZpZWQgcy50LiB0aGUgY2FjaGUgaXMgdXNlZCwgc28gY2hlY2sgZm9yIHRoaXMgY2FzZSB0byBtYWtlIGl0IGZhc3RlciBieVxuICAvLyBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uXG4gIGlmKCB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLl9wcml2YXRlLmJiQ2FjaGUgJiYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdHJ1ZSkgKXtcbiAgICBpZiggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBvcHRpb25zID0gZGVmQmJPcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmlsbGVkQmJPcHRzKCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZEJvdW5kaW5nQm94SW1wbCggdGhpc1swXSwgb3B0aW9ucyApO1xuICB9XG5cbiAgdmFyIGJvdW5kcyA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeTE6IEluZmluaXR5LFxuICAgIHgyOiAtSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyggb3B0aW9ucyApO1xuXG4gIHZhciBlbGVzID0gdGhpcztcbiAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCBvcHRzLnVzZUNhY2hlICk7XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgZWxlLmlzRWRnZSgpICYmIGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykuc3RyVmFsdWUgPT09ICdiZXppZXInICl7XG4gICAgICBlbGUucGFyYWxsZWxFZGdlcygpLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggb3B0cy51c2VDYWNoZSApOyAvLyBuLmIuIGVsZS5wYXJhbGxlbEVkZ2VzKCkgc2luZ2xlIGlzIGNhY2hlZFxuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goIGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKCBlbGUsIG9wdHMgKSApO1xuICB9XG5cbiAgYm91bmRzLngxID0gbm9uaW5mKCBib3VuZHMueDEgKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKCBib3VuZHMueTEgKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKCBib3VuZHMueDIgKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKCBib3VuZHMueTIgKTtcbiAgYm91bmRzLncgPSBub25pbmYoIGJvdW5kcy54MiAtIGJvdW5kcy54MSApO1xuICBib3VuZHMuaCA9IG5vbmluZiggYm91bmRzLnkyIC0gYm91bmRzLnkxICk7XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbnZhciBkZWZpbmVEaW1GbnMgPSBmdW5jdGlvbiggb3B0cyApe1xuICBvcHRzLnVwcGVyY2FzZU5hbWUgPSB1dGlsLmNhcGl0YWxpemUoIG9wdHMubmFtZSApO1xuICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSB1dGlsLmNhcGl0YWxpemUoIG9wdHMub3V0ZXJOYW1lICk7XG5cbiAgZm5bIG9wdHMubmFtZSBdID0gZnVuY3Rpb24gZGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICByZXR1cm4gX3BbIG9wdHMuYXV0b05hbWUgXSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGQgPSBlbGUucHN0eWxlKCBvcHRzLm5hbWUgKTtcblxuICAgICAgICBzd2l0Y2goIGQuc3RyVmFsdWUgKXtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlWyBvcHRzLmxhYmVsTmFtZSBdIHx8IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsgJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZSBdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgIHZhciBkaW0gPSBlbGVbIG9wdHMubmFtZSBdKCk7XG4gICAgICAgIHZhciBib3JkZXIgPSBlbGUucHN0eWxlKCAnYm9yZGVyLXdpZHRoJyApLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuICAgICAgICB2YXIgcGFkZGluZyA9IDIgKiBlbGUucHN0eWxlKCAncGFkZGluZycgKS5wZlZhbHVlO1xuXG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuWyAncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lIF0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBkID0gZWxlWyBvcHRzLm5hbWUgXSgpO1xuICAgICAgcmV0dXJuIGQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcblxuICBmblsgJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lIF0gPSBmdW5jdGlvbiByZW5kZXJlZE91dGVyRGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIG9kID0gZWxlWyBvcHRzLm91dGVyTmFtZSBdKCk7XG4gICAgICByZXR1cm4gb2QgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmRlZmluZURpbUZucygge1xuICBuYW1lOiAnd2lkdGgnXG59ICk7XG5cbmRlZmluZURpbUZucygge1xuICBuYW1lOiAnaGVpZ2h0J1xufSApO1xuXG4vLyBhbGlhc2VzXG5mbi5tb2RlbFBvc2l0aW9uID0gZm4ucG9pbnQgPSBmbi5wb3NpdGlvbjtcbmZuLm1vZGVsUG9zaXRpb25zID0gZm4ucG9pbnRzID0gZm4ucG9zaXRpb25zO1xuZm4ucmVuZGVyZWRQb2ludCA9IGZuLnJlbmRlcmVkUG9zaXRpb247XG5mbi5yZWxhdGl2ZVBvaW50ID0gZm4ucmVsYXRpdmVQb3NpdGlvbjtcbmZuLmJvdW5kaW5nYm94ID0gZm4uYm91bmRpbmdCb3g7XG5mbi5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4ucmVuZGVyZWRCb3VuZGluZ0JveDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbi8vIHJlcHJlc2VudHMgYSBub2RlIG9yIGFuIGVkZ2VcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oIGN5LCBwYXJhbXMsIHJlc3RvcmUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXN0b3JlID0gKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlID8gdHJ1ZSA6IGZhbHNlKTtcblxuICBpZiggY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhaXMuY29yZSggY3kgKSApe1xuICAgIHV0aWwuZXJyb3IoICdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ3JvdXAgPSBwYXJhbXMuZ3JvdXA7XG5cbiAgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG4gIGlmKCBncm91cCA9PSBudWxsICl7XG4gICAgaWYoIHBhcmFtcy5kYXRhICYmIHBhcmFtcy5kYXRhLnNvdXJjZSAhPSBudWxsICYmIHBhcmFtcy5kYXRhLnRhcmdldCAhPSBudWxsICl7XG4gICAgICBncm91cCA9ICdlZGdlcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gJ25vZGVzJztcbiAgICB9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBncm91cFxuICBpZiggZ3JvdXAgIT09ICdub2RlcycgJiYgZ3JvdXAgIT09ICdlZGdlcycgKXtcbiAgICB1dGlsLmVycm9yKCAnQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgZ3JvdXAgKyAnYCcgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcblxuICAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIHNpbmdsZTogdHJ1ZSwgLy8gaW5kaWNhdGVzIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LCAvLyBkYXRhIG9iamVjdFxuICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge30sIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgbGlzdGVuZXJzOiBbXSwgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgIHN0eWxlOiB7fSwgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgcnN0eWxlOiB7fSwgLy8gcHJvcGVydGllcyBmb3Igc3R5bGUgc2VudCBmcm9tIHRoZSByZW5kZXJlciB0byB0aGUgY29yZVxuICAgIHN0eWxlQ3h0czogW10sIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgcmVtb3ZlZDogdHJ1ZSwgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgIHNlbGVjdGVkOiBwYXJhbXMuc2VsZWN0ZWQgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RlZFxuICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogKCBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICBncmFiYmVkOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBncmFiYmVkIGJ5IHRoZSBtb3VzZTsgcmVuZGVyZXIgc2V0cyB0aGlzIHByaXZhdGVseVxuICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgYWN0aXZlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgY2xhc3Nlczoge30sIC8vIG1hcCAoIGNsYXNzTmFtZSA9PiB0cnVlIClcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgcnNjcmF0Y2g6IHt9LCAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgIHNjcmF0Y2g6IHBhcmFtcy5zY3JhdGNoIHx8IHt9LCAvLyBzY3JhdGNoIG9iamVjdHNcbiAgICBlZGdlczogW10sIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgIGNoaWxkcmVuOiBbXSwgLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICB0cmF2ZXJzYWxDYWNoZToge30gLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgfTtcblxuICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgdmFyIHJwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICB0aGlzLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH1cblxuICBpZiggaXMuc3RyaW5nKCBwYXJhbXMuY2xhc3NlcyApICl7XG4gICAgdmFyIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCggL1xccysvICk7XG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGNscyA9IGNsYXNzZXNbIGkgXTtcbiAgICAgIGlmKCAhY2xzIHx8IGNscyA9PT0gJycgKXsgY29udGludWU7IH1cblxuICAgICAgc2VsZi5fcHJpdmF0ZS5jbGFzc2VzWyBjbHMgXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYoIHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzICl7XG4gICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3MgKTtcbiAgfVxuXG4gIGlmKCByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSApe1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBvbjogZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgb25lOiBkZWZpbmUub24oIHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9uY2U6IGRlZmluZS5vbiggeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0gKSxcbiAgb2ZmOiBkZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpLCAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG5cbiAgcnRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZXh0cmFQYXJhbXMgKXsgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYoIHRoaXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgdGhpcy5jeSgpLm5vdGlmeSgge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSApO1xuXG4gICAgdGhpcy50cmlnZ2VyKCBldmVudCwgZXh0cmFQYXJhbXMgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXM6XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oIGVsZXNmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSggJy4uL3NlbGVjdG9yJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oIGksIGVsZW1lbnQgKXtcbiAgICAgIHJldHVybiBlbGVtZW50LmlzTm9kZSgpO1xuICAgIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oIGksIGVsZW1lbnQgKXtcbiAgICAgIHJldHVybiBlbGVtZW50LmlzRWRnZSgpO1xuICAgIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiggZmlsdGVyICl7XG4gICAgaWYoIGZpbHRlciA9PT0gdW5kZWZpbmVkICl7IC8vIGNoZWNrIHRoaXMgZmlyc3QgYi9jIGl0J3MgdGhlIG1vc3QgY29tbW9uL3BlcmZvcm1hbnQgY2FzZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoIGZpbHRlciApIHx8IGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGZpbHRlciApICl7XG4gICAgICByZXR1cm4gU2VsZWN0b3IoIGZpbHRlciApLmZpbHRlciggdGhpcyApO1xuICAgIH0gZWxzZSBpZiggaXMuZm4oIGZpbHRlciApICl7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG5cbiAgICAgICAgaWYoIGZpbHRlci5hcHBseSggZWxlLCBbIGksIGVsZSBdICkgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bigpOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICB9LFxuXG4gIG5vdDogZnVuY3Rpb24oIHRvUmVtb3ZlICl7XG4gICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYoIGlzLnN0cmluZyggdG9SZW1vdmUgKSApe1xuICAgICAgICB0b1JlbW92ZSA9IHRoaXMuZmlsdGVyKCB0b1JlbW92ZSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1sgaSBdO1xuXG4gICAgICAgIHZhciByZW1vdmUgPSB0b1JlbW92ZS5fcHJpdmF0ZS5pZHNbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgICBpZiggIXJlbW92ZSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgICB9XG5cbiAgfSxcblxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QoIHRoaXMgKTtcbiAgfSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgaWYoIGlzLnN0cmluZyggb3RoZXIgKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgLy8gdmFyIGlkczEgPSBjb2wxU21hbGxlciA/IGNvbDEuX3ByaXZhdGUuaWRzIDogY29sMi5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIGlkczIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUuaWRzIDogY29sMS5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGlkID0gY29sWyBpIF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBlbGUgPSBpZHMyWyBpZCBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cyApO1xuICB9LFxuXG4gIHhvcjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCBpcy5zdHJpbmcoIG90aGVyICkgKXtcbiAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiggY29sLCBvdGhlciApe1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gY29sWyBpIF07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgICAgICBpZiggIWluT3RoZXIgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGFkZCggY29sMSwgY29sMiApO1xuICAgIGFkZCggY29sMiwgY29sMSApO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gIH0sXG5cbiAgZGlmZjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCBpcy5zdHJpbmcoIG90aGVyICkgKXtcbiAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICB9XG5cbiAgICB2YXIgbGVmdCA9IFtdO1xuICAgIHZhciByaWdodCA9IFtdO1xuICAgIHZhciBib3RoID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIsIHJldEVsZXMgKXtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFsgaSBdO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5fcHJpdmF0ZS5pZHNbIGlkIF07XG5cbiAgICAgICAgaWYoIGluT3RoZXIgKXtcbiAgICAgICAgICBib3RoLnB1c2goIGVsZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBhZGQoIGNvbDEsIGNvbDIsIGxlZnQgKTtcbiAgICBhZGQoIGNvbDIsIGNvbDEsIHJpZ2h0ICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5zcGF3biggbGVmdCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgcmlnaHQ6IHRoaXMuc3Bhd24oIHJpZ2h0LCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICBib3RoOiB0aGlzLnNwYXduKCBib3RoLCB7IHVuaXF1ZTogdHJ1ZSB9IClcbiAgICB9O1xuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24oIHRvQWRkICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCAhdG9BZGQgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmKCBpcy5zdHJpbmcoIHRvQWRkICkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVsZW1lbnRzLnB1c2goIHRoaXNbIGkgXSApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKysgKXtcblxuICAgICAgdmFyIGFkZCA9ICF0aGlzLl9wcml2YXRlLmlkc1sgdG9BZGRbIGkgXS5pZCgpIF07XG4gICAgICBpZiggYWRkICl7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goIHRvQWRkWyBpIF0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgfSxcblxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG5cbiAgICBpZiggIXRvQWRkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggdG9BZGQgJiYgaXMuc3RyaW5nKCB0b0FkZCApICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkWyBpIF07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIGFkZCA9ICFfcC5pZHNbIGlkIF07XG5cbiAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcblxuICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG4gICAgICAgIF9wLmlkc1sgaWQgXSA9IHRvQWRkRWxlO1xuICAgICAgICBfcC5pbmRleGVzWyBpZCBdID0gaW5kZXg7XG4gICAgICB9IGVsc2UgeyAvLyByZXBsYWNlXG4gICAgICAgIHZhciBpbmRleCA9IF9wLmluZGV4ZXNbIGlkIF07XG5cbiAgICAgICAgdGhpc1sgaW5kZXggXSA9IHRvQWRkRWxlO1xuICAgICAgICBfcC5pZHNbIGlkIF0gPSB0b0FkZEVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZU9uZTogZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZSA9IGVsZVswXTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIGkgPSBfcC5pbmRleGVzWyBpZCBdO1xuXG4gICAgaWYoIGkgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVsZVxuICAgIHRoaXNbIGkgXSA9IHVuZGVmaW5lZDtcbiAgICBfcC5pZHNbIGlkIF0gPSB1bmRlZmluZWQ7XG4gICAgX3AuaW5kZXhlc1sgaWQgXSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG4gICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiAhdW5tZXJnZWRMYXN0RWxlICl7XG4gICAgICB2YXIgbGFzdEVsZUkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbGFzdEVsZSA9IHRoaXNbIGxhc3RFbGVJIF07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgICB0aGlzWyBsYXN0RWxlSSBdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpc1sgaSBdID0gbGFzdEVsZTtcbiAgICAgIF9wLmluZGV4ZXNbIGxhc3RFbGVJZCBdID0gaTtcbiAgICB9XG5cbiAgICAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZTogZnVuY3Rpb24oIHRvUmVtb3ZlICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmKCB0b1JlbW92ZSAmJiBpcy5zdHJpbmcoIHRvUmVtb3ZlICkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgdG9SZW1vdmUgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy51bm1lcmdlT25lKCB0b1JlbW92ZVsgaSBdICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiggbWFwRm4sIHRoaXNBcmcgKXtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogbWFwRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBhcnIucHVzaCggcmV0ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcblxuICByZWR1Y2U6IGZ1bmN0aW9uKCBmbiwgaW5pdGlhbFZhbHVlICl7XG4gICAgdmFyIHZhbCA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhbCA9IGZuKCB2YWwsIGVsZXNbaV0sIGksIGVsZXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9LFxuXG4gIHN0ZEZpbHRlcjogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgdmFyIGZpbHRlckVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogZm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICBmaWx0ZXJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBmaWx0ZXJFbGVzICk7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggdmFsID4gbWF4ICl7XG4gICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWF4LFxuICAgICAgZWxlOiBtYXhFbGVcbiAgICB9O1xuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggdmFsIDwgbWluICl7XG4gICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWluLFxuICAgICAgZWxlOiBtaW5FbGVcbiAgICB9O1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xudmFyIGZuID0gZWxlc2ZuO1xuZm5bICd1JyBdID0gZm5bICd8JyBdID0gZm5bICcrJyBdID0gZm4udW5pb24gPSBmbi5vciA9IGZuLmFkZDtcbmZuWyAnXFxcXCcgXSA9IGZuWyAnIScgXSA9IGZuWyAnLScgXSA9IGZuLmRpZmZlcmVuY2UgPSBmbi5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbi5zdWJ0cmFjdCA9IGZuLm5vdDtcbmZuWyAnbicgXSA9IGZuWyAnJicgXSA9IGZuWyAnLicgXSA9IGZuLmFuZCA9IGZuLmludGVyc2VjdGlvbiA9IGZuLmludGVyc2VjdDtcbmZuWyAnXicgXSA9IGZuWyAnKCspJyBdID0gZm5bICcoLSknIF0gPSBmbi5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4uc3ltZGlmZiA9IGZuLnhvcjtcbmZuLmZuRmlsdGVyID0gZm4uZmlsdGVyRm4gPSBmbi5zdGRGaWx0ZXI7XG5mbi5jb21wbGVtZW50ID0gZm4uYWJzY29tcCA9IGZuLmFic29sdXRlQ29tcGxlbWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBpc05vZGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcblxuICBpc0VkZ2U6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcblxuICBpc0xvb3A6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpID09PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gIH0sXG5cbiAgaXNTaW1wbGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpICE9PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gIH0sXG5cbiAgZ3JvdXA6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyb3VwO1xuICAgIH1cbiAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJy4vZWxlbWVudCcgKTtcblxuLy8gZmFjdG9yeSBmb3IgZ2VuZXJhdGluZyBlZGdlIGlkcyB3aGVuIG5vIGlkIGlzIHNwZWNpZmllZCBmb3IgYSBuZXcgZWxlbWVudFxudmFyIGlkRmFjdG9yeSA9IHtcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKCBjeSwgZWxlbWVudCwgdHJ5VGhpc0lkICl7XG4gICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB1dGlsLnV1aWQoKTtcblxuICAgIHdoaWxlKCBjeS5oYXNFbGVtZW50V2l0aElkKCBpZCApICl7XG4gICAgICBpZCA9IHV0aWwudXVpZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxufTtcblxuLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24oIGN5LCBlbGVtZW50cywgb3B0aW9ucyApe1xuICBpZiggY3kgPT09IHVuZGVmaW5lZCB8fCAhaXMuY29yZSggY3kgKSApe1xuICAgIHV0aWwuZXJyb3IoICdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZHMgPSB7fTtcbiAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gIGlmKCAhZWxlbWVudHMgKXtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgIWlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlO1xuXG4gICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1sgaSBdO1xuXG4gICAgICBpZigganNvbi5kYXRhID09IG51bGwgKXtcbiAgICAgICAganNvbi5kYXRhID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0ganNvbi5kYXRhO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuICAgICAgaWYoIGRhdGEuaWQgPT0gbnVsbCApe1xuICAgICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwganNvbiApO1xuICAgICAgfSBlbHNlIGlmKCBjeS5oYXNFbGVtZW50V2l0aElkKCBkYXRhLmlkICkgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgZWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgIGVsZXNJZHNbIGRhdGEuaWQgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1sgaSBdO1xuICAgIGlmKCAhZWxlbWVudCApeyAgY29udGludWU7IH1cblxuICAgIHZhciBpZCA9IGVsZW1lbnQuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgIGlmKCAhb3B0aW9ucyB8fCAob3B0aW9ucy51bmlxdWUgJiYgIWlkc1sgaWQgXSApICl7XG4gICAgICBpZHNbIGlkIF0gPSBlbGVtZW50O1xuICAgICAgaW5kZXhlc1sgaWQgXSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICB0aGlzWyB0aGlzLmxlbmd0aCBdID0gZWxlbWVudDtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgaWRzOiBpZHMsXG4gICAgaW5kZXhlczogaW5kZXhlc1xuICB9O1xuXG4gIC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cbiAgaWYoIGNyZWF0ZWRFbGVtZW50cyApe1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8ga2VlcCB0aGUgcHJvdG90eXBlcyBpbiBzeW5jIChhbiBlbGVtZW50IGhhcyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgYSBjb2xsZWN0aW9uKVxuLy8gYW5kIHVzZSBlbGVmbiBhbmQgZWxlc2ZuIGFzIHNob3J0aGFuZHMgdG8gdGhlIHByb3RvdHlwZXNcbnZhciBlbGVzZm4gPSBFbGVtZW50LnByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG5lbGVzZm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcblxuZWxlc2ZuLnNwYXduID0gZnVuY3Rpb24oIGN5LCBlbGVzLCBvcHRzICl7XG4gIGlmKCAhaXMuY29yZSggY3kgKSApeyAvLyBjeSBpcyBvcHRpb25hbFxuICAgIG9wdHMgPSBlbGVzO1xuICAgIGVsZXMgPSBjeTtcbiAgICBjeSA9IHRoaXMuY3koKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggY3ksIGVsZXMsIG9wdHMgKTtcbn07XG5cbmVsZXNmbi5zcGF3blNlbGYgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5zcGF3biggdGhpcyApO1xufTtcblxuZWxlc2ZuLmN5ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcblxuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICBpZiggaXMuY29sbGVjdGlvbiggdGhpcyApICl7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7IC8vIGFuIGVsZW1lbnRcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIFsgdGhpcyBdICk7XG4gIH1cbn07XG5cbmVsZXNmbi51bmlxdWUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbn07XG5cbmVsZXNmbi5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24oIGlkICl7XG4gIHJldHVybiAhIXRoaXMuX3ByaXZhdGUuaWRzWyBpZCBdO1xufTtcblxuZWxlc2ZuLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oIGlkICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICByZXR1cm4gZWxlID8gZWxlIDogbmV3IENvbGxlY3Rpb24oIGN5ICk7IC8vIGdldCBlbGUgb3IgZW1wdHkgY29sbGVjdGlvblxufTtcblxuZWxlc2ZuLnBvb2xJbmRleCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIHZhciBpZCA9IHRoaXMuX3ByaXZhdGUuZGF0YS5pZDtcblxuICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5pbmRleGVzWyBpZCBdO1xufTtcblxuZWxlc2ZuLmpzb24gPSBmdW5jdGlvbiggb2JqICl7XG4gIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gIGlmKCBlbGUgPT0gbnVsbCAmJiBvYmogKXsgcmV0dXJuIHRoaXM7IH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuICBpZiggZWxlID09IG51bGwgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyBjYW4ndCBnZXQgZnJvbSBubyBlbGVzXG5cbiAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG5cbiAgaWYoIGlzLnBsYWluT2JqZWN0KCBvYmogKSApeyAvLyBzZXRcblxuICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgIGlmKCBvYmouZGF0YSApe1xuICAgICAgZWxlLmRhdGEoIG9iai5kYXRhICk7XG4gICAgfVxuXG4gICAgaWYoIG9iai5wb3NpdGlvbiApe1xuICAgICAgZWxlLnBvc2l0aW9uKCBvYmoucG9zaXRpb24gKTtcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgZ3JvdXAgLS0gaW1tdXRhYmxlXG5cbiAgICB2YXIgY2hlY2tTd2l0Y2ggPSBmdW5jdGlvbiggaywgdHJ1ZUZuTmFtZSwgZmFsc2VGbk5hbWUgKXtcbiAgICAgIHZhciBvYmpfayA9IG9ialsgayBdO1xuXG4gICAgICBpZiggb2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFsgayBdICl7XG4gICAgICAgIGlmKCBvYmpfayApe1xuICAgICAgICAgIGVsZVsgdHJ1ZUZuTmFtZSBdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlWyBmYWxzZUZuTmFtZSBdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tTd2l0Y2goICdyZW1vdmVkJywgJ3JlbW92ZScsICdyZXN0b3JlJyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdzZWxlY3RlZCcsICdzZWxlY3QnLCAndW5zZWxlY3QnICk7XG5cbiAgICBjaGVja1N3aXRjaCggJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5JyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdsb2NrZWQnLCAnbG9jaycsICd1bmxvY2snICk7XG5cbiAgICBjaGVja1N3aXRjaCggJ2dyYWJiYWJsZScsICdncmFiaWZ5JywgJ3VuZ3JhYmlmeScgKTtcblxuICAgIGlmKCBvYmouY2xhc3NlcyAhPSBudWxsICl7XG4gICAgICBlbGUuY2xhc3Nlcyggb2JqLmNsYXNzZXMgKTtcbiAgICB9XG5cbiAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSBlbHNlIGlmKCBvYmogPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgIHZhciBqc29uID0ge1xuICAgICAgZGF0YTogdXRpbC5jb3B5KCBwLmRhdGEgKSxcbiAgICAgIHBvc2l0aW9uOiB1dGlsLmNvcHkoIHAucG9zaXRpb24gKSxcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgcmVtb3ZlZDogcC5yZW1vdmVkLFxuICAgICAgc2VsZWN0ZWQ6IHAuc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RhYmxlOiBwLnNlbGVjdGFibGUsXG4gICAgICBsb2NrZWQ6IHAubG9ja2VkLFxuICAgICAgZ3JhYmJhYmxlOiBwLmdyYWJiYWJsZSxcbiAgICAgIGNsYXNzZXM6IG51bGxcbiAgICB9O1xuXG4gICAganNvbi5jbGFzc2VzID0gT2JqZWN0LmtleXMoIHAuY2xhc3NlcyApLmZpbHRlcihmdW5jdGlvbiggY2xzICl7XG4gICAgICByZXR1cm4gcC5jbGFzc2VzW2Nsc107XG4gICAgfSkuam9pbignICcpO1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5cbmVsZXNmbi5qc29ucyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBqc29ucyA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuXG4gICAganNvbnMucHVzaCgganNvbiApO1xuICB9XG5cbiAgcmV0dXJuIGpzb25zO1xufTtcblxuZWxlc2ZuLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgZWxlc0FyciA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KCBjeSwganNvbiwgZmFsc2UgKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgZWxlc0Fyci5wdXNoKCBjbG9uZSApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgZWxlc0FyciApO1xufTtcbmVsZXNmbi5jb3B5ID0gZWxlc2ZuLmNsb25lO1xuXG5lbGVzZm4ucmVzdG9yZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgdmFyIGN5X3AgPSBjeS5fcHJpdmF0ZTtcblxuICBpZiggbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCApe1xuICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzO1xuICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHNlbGZbIGkgXTtcblxuICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGtlZXAgbm9kZXMgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBlZGdlcyBhZnRlclxuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXsgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSB7IC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoIGVkZ2VzICk7XG5cbiAgdmFyIGk7XG4gIHZhciByZW1vdmVGcm9tRWxlbWVudHMgPSBmdW5jdGlvbigpe1xuICAgIGVsZW1lbnRzLnNwbGljZSggaSwgMSApO1xuICAgIGktLTtcbiAgfTtcblxuICAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG4gIGZvciggaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVtZW50c1sgaSBdO1xuXG4gICAgdmFyIF9wcml2YXRlID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBkYXRhID0gX3ByaXZhdGUuZGF0YTtcblxuICAgIC8vIHRoZSB0cmF2ZXJzYWwgY2FjaGUgc2hvdWxkIHN0YXJ0IGZyZXNoIHdoZW4gZWxlIGlzIGFkZGVkXG4gICAgX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuXG4gICAgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuICAgIGlmKCBkYXRhLmlkID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBlbGUgKTtcblxuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCBkYXRhLmlkICkgKXtcbiAgICAgIGRhdGEuaWQgPSAnJyArIGRhdGEuaWQ7IC8vIG5vdyBpdCdzIGEgc3RyaW5nXG5cbiAgICB9IGVsc2UgaWYoIGlzLmVtcHR5U3RyaW5nKCBkYXRhLmlkICkgfHwgIWlzLnN0cmluZyggZGF0YS5pZCApICl7XG4gICAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyApO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmKCBjeS5oYXNFbGVtZW50V2l0aElkKCBkYXRhLmlkICkgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgZGF0YS5pZCArICdgJyApO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBkYXRhLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG5cbiAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3Igbm9kZXNcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIHBvcyA9IF9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIG5vZGVzIGhhdmUgYSBkZWZpbmVkIHBvc2l0aW9uXG5cbiAgICAgIGlmKCBwb3MueCA9PSBudWxsICl7XG4gICAgICAgIHBvcy54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYoIHBvcy55ID09IG51bGwgKXtcbiAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuXG4gICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbICdzb3VyY2UnLCAndGFyZ2V0JyBdO1xuICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKysgKXtcblxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbIGogXTtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFbIGZpZWxkIF07XG5cbiAgICAgICAgaWYoIGlzLm51bWJlciggdmFsICkgKXtcbiAgICAgICAgICB2YWwgPSBkYXRhWyBmaWVsZCBdID0gJycgKyBkYXRhWyBmaWVsZCBdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiggdmFsID09IG51bGwgfHwgdmFsID09PSAnJyApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkICk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoICFjeS5oYXNFbGVtZW50V2l0aElkKCB2YWwgKSApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcgKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGJhZFNvdXJjZU9yVGFyZ2V0ICl7IHJlbW92ZUZyb21FbGVtZW50cygpOyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG4gICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuXG4gICAgLy8gY3JlYXRlIG1vY2sgaWRzIC8gaW5kZXhlcyBtYXBzIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5pZHMgPSB7fTtcbiAgICBfcHJpdmF0ZS5pZHNbIGlkIF0gPSBlbGU7XG4gICAgX3ByaXZhdGUuaW5kZXhlcyA9IHt9O1xuICAgIF9wcml2YXRlLmluZGV4ZXNbIGlkIF0gPSBlbGU7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgY3kuYWRkVG9Qb29sKCBlbGUgKTtcbiAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG5cbiAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXsgLy8gZWFjaCBub2RlXG4gICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgIHZhciBkYXRhID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgaWYoIGlzLm51bWJlciggZGF0YS5wYXJlbnQgKSApeyAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgZGF0YS5wYXJlbnQgPSAnJyArIGRhdGEucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZCA9IGRhdGEucGFyZW50O1xuXG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICBpZiggc3BlY2lmaWVkUGFyZW50ICl7XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgIGlmKCBwYXJlbnQuZW1wdHkoKSApe1xuICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICB3aGlsZSggIWFuY2VzdG9yLmVtcHR5KCkgKXtcbiAgICAgICAgICBpZiggbm9kZS5zYW1lKCBhbmNlc3RvciApICl7XG4gICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFzZWxmQXNQYXJlbnQgKXtcbiAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaCggbm9kZSApO1xuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgICAgICAgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG4gICAgICAgICAgY3lfcC5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbHNlXG4gICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG4gIH0gLy8gZm9yIGVhY2ggbm9kZVxuXG4gIGlmKCBlbGVtZW50cy5sZW5ndGggPiAwICl7XG4gICAgdmFyIHJlc3RvcmVkID0gbmV3IENvbGxlY3Rpb24oIGN5LCBlbGVtZW50cyApO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZXN0b3JlZC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHJlc3RvcmVkW2ldO1xuXG4gICAgICBpZiggZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICAgIHZhciBwZWRnZXMgPSBlbGUucGFyYWxsZWxFZGdlcygpO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgcGVkZ2VzW2pdLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgdGhlIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgZWxlLnNvdXJjZSgpWzBdLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgICAgIGVsZS50YXJnZXQoKVswXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG5cbiAgICBpZiggY3lfcC5oYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQuYWRkKCByZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpICkuYWRkKCByZXN0b3JlZC5wYXJlbnQoKSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQ7XG4gICAgfVxuXG4gICAgdG9VcGRhdGVTdHlsZS51cGRhdGVTdHlsZSggbm90aWZ5UmVuZGVyZXIgKTtcblxuICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgcmVzdG9yZWQucnRyaWdnZXIoICdhZGQnICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVkLnRyaWdnZXIoICdhZGQnICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxufTtcblxuZWxlc2ZuLnJlbW92ZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5cbmVsZXNmbi5pbnNpZGUgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4ucmVtb3ZlID0gZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gIHZhciBjeSA9IHNlbGYuX3ByaXZhdGUuY3k7XG5cbiAgaWYoIG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgKXtcbiAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gIH1cblxuICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG4gIGZ1bmN0aW9uIGFkZENvbm5lY3RlZEVkZ2VzKCBub2RlICl7XG4gICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICBhZGQoIGVkZ2VzWyBpIF0gKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gIGZ1bmN0aW9uIGFkZENoaWxkcmVuKCBub2RlICl7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKysgKXtcbiAgICAgIGFkZCggY2hpbGRyZW5bIGkgXSApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCggZWxlICl7XG4gICAgdmFyIGFscmVhZHlBZGRlZCA9ICBlbGVzVG9SZW1vdmVJZHNbIGVsZS5pZCgpIF07XG4gICAgaWYoIGFscmVhZHlBZGRlZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGVsZXNUb1JlbW92ZS5wdXNoKCBlbGUgKTsgLy8gbm9kZXMgYXJlIHJlbW92ZWQgbGFzdFxuXG4gICAgICBhZGRDb25uZWN0ZWRFZGdlcyggZWxlICk7XG4gICAgICBhZGRDaGlsZHJlbiggZWxlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KCBlbGUgKTsgLy8gZWRnZXMgYXJlIHJlbW92ZWQgZmlyc3RcbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cbiAgZm9yKCB2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgIHZhciBlbGUgPSBzZWxmWyBpIF07XG5cbiAgICBhZGQoIGVsZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZiggbm9kZSwgZWRnZSApe1xuICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheSggY29ubmVjdGVkRWRnZXMsIGVkZ2UgKTtcblxuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuICAgIG5vZGUuX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUGFyYWxsZWxSZWZzKCBlZGdlICl7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgdmFyIHBlZGdlcyA9IGVkZ2UucGFyYWxsZWxFZGdlcygpO1xuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICBwZWRnZXNbal0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZiggcGFyZW50LCBlbGUgKXtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuICAgIHZhciBwaWQgPSBwYXJlbnQuaWQoKTtcblxuICAgIHV0aWwucmVtb3ZlRnJvbUFycmF5KCBjaGlsZHJlbiwgZWxlICk7XG5cbiAgICBpZiggIWFsdGVyZWRQYXJlbnRzLmlkc1sgcGlkIF0gKXtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1sgcGlkIF0gPSB0cnVlO1xuICAgICAgYWx0ZXJlZFBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGZyb20gY29yZSBwb29sXG4gIGN5LnJlbW92ZUZyb21Qb29sKCBlbGVzVG9SZW1vdmUgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbIGkgXTtcblxuICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgIGVsZS5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICByZW1vdmVFZGdlUmVmKCB0Z3QsIGVsZSApO1xuICAgICAgcmVtb3ZlUGFyYWxsZWxSZWZzKCBlbGUgKTtcblxuICAgIH0gZWxzZSB7IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpO1xuXG4gICAgICBpZiggcGFyZW50Lmxlbmd0aCAhPT0gMCApe1xuICAgICAgICByZW1vdmVDaGlsZFJlZiggcGFyZW50LCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlWyBpIF07XG5cbiAgICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCB0aGlzLmN5KCksIHJlbW92ZWQgKTtcbiAgaWYoIHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwICl7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG5cbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHRoaXMuY3koKS5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIGVsZXM6IHJlbW92ZWRFbGVtZW50c1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJlbW92ZWRFbGVtZW50cy50cmlnZ2VyKCAncmVtb3ZlJyApO1xuICB9XG5cbiAgLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgYWx0ZXJlZFBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gYWx0ZXJlZFBhcmVudHNbIGkgXTtcblxuICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgZWxlLnVwZGF0ZVN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgcmVtb3ZlZCApO1xufTtcblxuZWxlc2ZuLm1vdmUgPSBmdW5jdGlvbiggc3RydWN0ICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICB2YXIgc3JjSWQgPSBzdHJ1Y3Quc291cmNlO1xuICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgdmFyIHNyY0V4aXN0cyA9IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHNyY0lkICk7XG4gICAgdmFyIHRndEV4aXN0cyA9IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHRndElkICk7XG5cbiAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgICAgaWYoIHNyY0V4aXN0cyApeyBqc29uLmRhdGEuc291cmNlID0gc3JjSWQ7IH1cblxuICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG5cbiAgICAgICAgICBqc29uLnNjcmF0Y2ggPSBlbGUuX3ByaXZhdGUuc2NyYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApO1xuICAgIH1cblxuICB9IGVsc2UgaWYoIHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApeyAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgIHZhciBwYXJlbnRJZCA9IHN0cnVjdC5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5Lmhhc0VsZW1lbnRXaXRoSWQoIHBhcmVudElkICk7XG5cbiAgICBpZiggcGFyZW50RXhpc3RzICl7XG4gICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG4gICAgICB2YXIgZGVzY3MgPSB0aGlzLmRlc2NlbmRhbnRzKCk7XG4gICAgICB2YXIgZGVzY3NFdGNKc29ucyA9IGRlc2NzLnVuaW9uKCBkZXNjcy51bmlvbiggdGhpcyApLmNvbm5lY3RlZEVkZ2VzKCkgKS5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpOyAvLyBOQjogYWxzbyByZW1vdmVzIGRlc2NlbmRhbnRzIGFuZCB0aGVpciBjb25uZWN0ZWQgZWRnZXNcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuXG4gICAgICAgICAganNvbi5zY3JhdGNoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMuY29uY2F0KCBkZXNjc0V0Y0pzb25zICkgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG59O1xuXG5bXG4gIHJlcXVpcmUoICcuL2FsZ29yaXRobXMnICksXG4gIHJlcXVpcmUoICcuL2FuaW1hdGlvbicgKSxcbiAgcmVxdWlyZSggJy4vY2xhc3MnICksXG4gIHJlcXVpcmUoICcuL2NvbXBhcmF0b3JzJyApLFxuICByZXF1aXJlKCAnLi9jb21wb3VuZHMnICksXG4gIHJlcXVpcmUoICcuL2RhdGEnICksXG4gIHJlcXVpcmUoICcuL2RlZ3JlZScgKSxcbiAgcmVxdWlyZSggJy4vZGltZW5zaW9ucycgKSxcbiAgcmVxdWlyZSggJy4vZXZlbnRzJyApLFxuICByZXF1aXJlKCAnLi9maWx0ZXInICksXG4gIHJlcXVpcmUoICcuL2dyb3VwJyApLFxuICByZXF1aXJlKCAnLi9pbmRleCcgKSxcbiAgcmVxdWlyZSggJy4vaXRlcmF0aW9uJyApLFxuICByZXF1aXJlKCAnLi9sYXlvdXQnICksXG4gIHJlcXVpcmUoICcuL3N0eWxlJyApLFxuICByZXF1aXJlKCAnLi9zd2l0Y2gtZnVuY3Rpb25zJyApLFxuICByZXF1aXJlKCAnLi90cmF2ZXJzaW5nJyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggZWxlc2ZuLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB6SW5kZXhTb3J0ID0gcmVxdWlyZSggJy4venNvcnQnICk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBlYWNoOiBmdW5jdGlvbiggZm4gKXtcbiAgICBpZiggaXMuZm4oIGZuICkgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApO1xuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9yRWFjaDogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgaWYoIGlzLmZuKCBmbiApICl7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgdGhpcyBdICkgOiBmbiggZWxlLCBpLCB0aGlzICk7XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGFycmF5LnB1c2goIHRoaXNbIGkgXSApO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24oIHN0YXJ0LCBlbmQgKXtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmKCBlbmQgPT0gbnVsbCApe1xuICAgICAgZW5kID0gdGhpc1NpemU7XG4gICAgfVxuXG4gICAgaWYoIHN0YXJ0ID09IG51bGwgKXtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggc3RhcnQgPCAwICl7XG4gICAgICBzdGFydCA9IHRoaXNTaXplICsgc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYoIGVuZCA8IDAgKXtcbiAgICAgIGVuZCA9IHRoaXNTaXplICsgZW5kO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSBzdGFydDsgaSA+PSAwICYmIGkgPCBlbmQgJiYgaSA8IHRoaXNTaXplOyBpKysgKXtcbiAgICAgIGFycmF5LnB1c2goIHRoaXNbIGkgXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBhcnJheSApO1xuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9LFxuXG4gIGVxOiBmdW5jdGlvbiggaSApe1xuICAgIHJldHVybiB0aGlzWyBpIF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWyB0aGlzLmxlbmd0aCAtIDEgXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIG5vbmVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuXG4gIHNvcnQ6IGZ1bmN0aW9uKCBzb3J0Rm4gKXtcbiAgICBpZiggIWlzLmZuKCBzb3J0Rm4gKSApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoIHNvcnRGbiApO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNvcnRlZCApO1xuICB9LFxuXG4gIHNvcnRCeVpJbmRleDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5zb3J0KCB6SW5kZXhTb3J0ICk7XG4gIH0sXG5cbiAgekRlcHRoOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmKCAhZWxlICl7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIC8vIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgIGlmKCBncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgIGlmKCAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIC0gMTsgLy8gY2hpbGRsZXNzIG5vZGVzIGFsd2F5cyBvbiB0b3BcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcmNEZXB0aCA9IHNyYy56RGVwdGgoKTtcbiAgICAgIHZhciB0Z3REZXB0aCA9IHRndC56RGVwdGgoKTtcblxuICAgICAgcmV0dXJuIE1hdGgubWF4KCBzcmNEZXB0aCwgdGd0RGVwdGgsIDAgKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24oIGxheW91dCwgb3B0aW9ucywgZm4gKXtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24oIHNwYWNpbmcsIG5vZGVzQmIsIHBvcyApe1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogbm9kZXNCYi54MSArIG5vZGVzQmIudyAvIDIsXG4gICAgICAgIHk6IG5vZGVzQmIueTEgKyBub2Rlc0JiLmggLyAyXG4gICAgICB9O1xuICAgICAgdmFyIHNwYWNpbmdWZWN0b3IgPSB7IC8vIHNjYWxlIGZyb20gY2VudGVyIG9mIGJvdW5kaW5nIGJveCAobm90IG5lY2Vzc2FyaWx5IDAsMClcbiAgICAgICAgeDogKHBvcy54IC0gY2VudGVyLngpICogc3BhY2luZyxcbiAgICAgICAgeTogKHBvcy55IC0gY2VudGVyLnkpICogc3BhY2luZ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgc3BhY2luZ1ZlY3Rvci54LFxuICAgICAgICB5OiBjZW50ZXIueSArIHNwYWNpbmdWZWN0b3IueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgdmFyIG5vZGVzQmIgPSBub2Rlcy5ib3VuZGluZ0JveCgpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG5cbiAgICAgICAgdmFyIG5ld1BvcyA9IGZuLmNhbGwoIG5vZGUsIGksIG5vZGUgKTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICBpZiggIWlzLm51bWJlciggcG9zLnggKSB8fCAhaXMubnVtYmVyKCBwb3MueSApICl7XG4gICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbiggeyB4OiAwLCB5OiAwIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb3B0aW9ucy5zcGFjaW5nRmFjdG9yICYmIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAhPT0gMSl7XG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICAgIG5ld1BvcyA9IGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgbm9kZXNCYiwgbmV3UG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmkgPSBub2RlLmFuaW1hdGlvbigge1xuICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9ICk7XG5cbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCggYW5pICk7XG5cbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9uU3RlcDtcbiAgICAgIGN5Lm9uKCAnc3RlcC4qJywgKCBvblN0ZXAgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgIH0pICk7XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBmdW5jdGlvbigpe1xuICAgICAgICBjeS5vZmYoJ3N0ZXAuKicsIG9uU3RlcCk7XG4gICAgICB9KTtcblxuICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSApO1xuXG4gICAgICBQcm9taXNlLmFsbCggbGF5b3V0LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCBhbmkgKXtcbiAgICAgICAgcmV0dXJuIGFuaS5wcm9taXNlKCk7XG4gICAgICB9KSApLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgY3kub2ZmKCdzdGVwLionLCBvblN0ZXApO1xuXG4gICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0Lm9uZSggJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3AgKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoIHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9ICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDEgKXtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyggb3B0aW9ucy5zcGFjaW5nRmFjdG9yICk7XG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyggZnVuY3Rpb24oIGksIG5vZGUgKXtcbiAgICAgICAgICB2YXIgcG9zID0gZm4oIGksIG5vZGUgKTtcbiAgICAgICAgICB2YXIgbm9kZXNCYiA9IG5vZGVzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVNwYWNpbmcoIHNwYWNpbmcsIG5vZGVzQmIsIHBvcyApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyggZm4gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQub25lKCAnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5ICk7XG4gICAgICBsYXlvdXQudHJpZ2dlciggeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9ICk7XG5cbiAgICAgIGxheW91dC5vbmUoICdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wICk7XG4gICAgICBsYXlvdXQudHJpZ2dlciggeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBsYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgY3kubGF5b3V0KCB1dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9ICkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoIHV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgZWxlczogdGhpc1xuICAgIH0gKSApO1xuICB9XG5cbn0pO1xuXG4vLyBhbGlhc2VzOlxuZWxlc2ZuLmNyZWF0ZUxheW91dCA9IGVsZXNmbi5tYWtlTGF5b3V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuXG4gICAgICBiRWxlcy5tZXJnZSggdGhpcyApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgIH1cblxuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzO1xuXG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYoIGhhc0NvbXBvdW5kcyApeyAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSggdGhpcy5kZXNjZW5kYW50cygpICkubWVyZ2UoIHRoaXMucGFyZW50cygpICk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwbHkoIHVwZGF0ZWRFbGVzICk7XG5cbiAgICBpZiggaGFzQ29tcG91bmRzICl7XG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHVwZGF0ZWRFbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG5cbiAgICAgIC8vIGRpc2FibGUgZm9yIHBlcmZvcm1hbmNlIGZvciBub3dcbiAgICAgIC8vIChhcyB1cGRhdGVkQ29tcG91bmRzIHdvdWxkIGJlIGEgc3Vic2V0IG9mIHVwZGF0ZWRFbGVzIGF5d2F5IGIvYyBvZiBzZWxlY3RvcnMgY2hlY2spXG4gICAgICAvLyBpZiggdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwICl7XG4gICAgICAvLyAgIHVwZGF0ZWRFbGVzLm1lcmdlKCB1cGRhdGVkQ29tcG91bmRzICk7XG4gICAgICAvLyB9XG4gICAgfVxuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB1cGRhdGVkRWxlcy5ydHJpZ2dlciggJ3N0eWxlJyApOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWRFbGVzLnRyaWdnZXIoICdzdHlsZScgKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gIHVwZGF0ZU1hcHBlcnM6IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcblxuICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICB0b05vdGlmeS50cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlWyBwcm9wZXJ0eSBdIHx8IGN5LnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KCBwcm9wZXJ0eSApO1xuICAgIH1cbiAgfSxcblxuICBudW1lcmljU3R5bGU6IGZ1bmN0aW9uKCBwcm9wZXJ0eSApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoICFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH1cblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKCBwcm9wZXJ0eSApO1xuXG4gICAgICByZXR1cm4gcHN0eWxlLnBmVmFsdWUgIT09IHVuZGVmaW5lZCA/IHBzdHlsZS5wZlZhbHVlIDogcHN0eWxlLnZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBudW1lcmljU3R5bGVVbml0czogZnVuY3Rpb24oIHByb3BlcnR5ICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfVxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoIHByb3BlcnR5ICkudW5pdHM7XG4gICAgfVxuICB9LFxuXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24oIHByb3BlcnR5ICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZSggZWxlLCBwcm9wZXJ0eSApO1xuICAgIH1cbiAgfSxcblxuICAvLyByZWFkIHRoZSBjYWxjdWxhdGVkIGNzcyBzdHlsZSBvZiB0aGUgZWxlbWVudCBvciBvdmVycmlkZSB0aGUgc3R5bGUgKHZpYSBhIGJ5cGFzcylcbiAgc3R5bGU6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3QoIG5hbWUgKSApeyAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBuYW1lICkgKXtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIG5hbWUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoICdzdHlsZScgKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggbmFtZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoIGVsZSApO1xuICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24oIG5hbWVzICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBpZiggbmFtZXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoIGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCggL1xccysvICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuXG4gICAgICAgIHN0eWxlLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCAnc3R5bGUnICk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCAnZGlzcGxheScsICdlbGVtZW50JyApO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jc3MoICdkaXNwbGF5JywgJ25vbmUnICk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdmlzaWJsZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZihcbiAgICAgICAgZWxlLnBzdHlsZSggJ3Zpc2liaWxpdHknICkudmFsdWUgIT09ICd2aXNpYmxlJ1xuICAgICAgICB8fCBlbGUucHN0eWxlKCAnZGlzcGxheScgKS52YWx1ZSAhPT0gJ2VsZW1lbnQnXG4gICAgICAgIHx8IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSA9PT0gMFxuICAgICAgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBlbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlID09PSAwICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzID0gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzWyBpIF07XG4gICAgICAgICAgICB2YXIgcFZpcyA9IHBhcmVudC5wc3R5bGUoICd2aXNpYmlsaXR5JyApLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHBEaXMgPSBwYXJlbnQucHN0eWxlKCAnZGlzcGxheScgKS52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIHBWaXMgIT09ICd2aXNpYmxlJyB8fCBwRGlzICE9PSAnZWxlbWVudCcgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiBzcmMudmlzaWJsZSgpICYmIHRndC52aXNpYmxlKCk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG5cbiAgaGlkZGVuOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfSxcblxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWU7XG5cbiAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApeyByZXR1cm4gcGFyZW50T3BhY2l0eTsgfVxuXG4gICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuXG4gICAgICBpZiggcGFyZW50cyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1sgaSBdO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSggJ29wYWNpdHknICkudmFsdWU7XG5cbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoICdvcGFjaXR5JyApLnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG59KTtcblxuXG5lbGVzZm4uYnlwYXNzID0gZWxlc2ZuLmNzcyA9IGVsZXNmbi5zdHlsZTtcbmVsZXNmbi5yZW5kZXJlZENzcyA9IGVsZXNmbi5yZW5kZXJlZFN0eWxlO1xuZWxlc2ZuLnJlbW92ZUJ5cGFzcyA9IGVsZXNmbi5yZW1vdmVDc3MgPSBlbGVzZm4ucmVtb3ZlU3R5bGU7XG5lbGVzZm4ucHN0eWxlID0gZWxlc2ZuLnBhcnNlZFN0eWxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZXNmbiA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBjaGFuZ2VkRWxlcyA9IFtdO1xuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgaWYoIGFyZ3MubGVuZ3RoID09PSAyICl7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm9uKCBwYXJhbXMuZXZlbnQsIGRhdGEsIGhhbmRsZXIgKTtcbiAgICB9XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgdGhpcy5vbiggcGFyYW1zLmV2ZW50LCBoYW5kbGVyICk7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1sgaSBdO1xuICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmFibGVGaWVsZCBdO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF0gIT0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVBYmxlICl7XG4gICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoIGVsZSApO1xuXG4gICAgICAgICAgaWYoIG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuXG4gICAgICAgICAgICBpZiggIW92ZXJyaWRlQWJsZSApeyByZXR1cm4gdGhpczsgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBhYmxlICl7XG4gICAgICAgICAgZWxlLl9wcml2YXRlWyBwYXJhbXMuZmllbGQgXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgIGlmKCBjaGFuZ2VkICl7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWRDb2xsID0gdGhpcy5zcGF3biggY2hhbmdlZEVsZXMgKTtcbiAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcbiAgICAgIGNoYW5nZWRDb2xsLnRyaWdnZXIoIHBhcmFtcy5ldmVudCApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQoIHBhcmFtcyApe1xuICBlbGVzZm5bIHBhcmFtcy5maWVsZCBdID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVGaWVsZCApe1xuICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoIGVsZSApO1xuXG4gICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF07XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmblsgcGFyYW1zLm9uIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbigge1xuICAgIGV2ZW50OiBwYXJhbXMub24sXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiB0cnVlXG4gIH0gKTtcblxuICBlbGVzZm5bIHBhcmFtcy5vZmYgXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKCB7XG4gICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiBmYWxzZVxuICB9ICk7XG59XG5cbmRlZmluZVN3aXRjaFNldCgge1xuICBmaWVsZDogJ2xvY2tlZCcsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0gKTtcblxuZGVmaW5lU3dpdGNoU2V0KCB7XG4gIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oIGVsZSApe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdncmFiaWZ5JyxcbiAgb2ZmOiAndW5ncmFiaWZ5J1xufSApO1xuXG5kZWZpbmVTd2l0Y2hTZXQoIHtcbiAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3QnLFxuICBvZmY6ICd1bnNlbGVjdCdcbn0gKTtcblxuZGVmaW5lU3dpdGNoU2V0KCB7XG4gIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3RpZnknLFxuICBvZmY6ICd1bnNlbGVjdGlmeSdcbn0gKTtcblxuZWxlc2ZuLmRlc2VsZWN0ID0gZWxlc2ZuLnVuc2VsZWN0O1xuXG5lbGVzZm4uZ3JhYmJlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiggZWxlICl7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuXG5kZWZpbmVTd2l0Y2hTZXQoIHtcbiAgZmllbGQ6ICdhY3RpdmUnLFxuICBvbjogJ2FjdGl2YXRlJyxcbiAgb2ZmOiAndW5hY3RpdmF0ZSdcbn0gKTtcblxuZWxlc2ZuLmluYWN0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmKCBlbGUgKXtcbiAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5hY3RpdmU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbnZhciBjYWNoZSA9IGZ1bmN0aW9uKCBmbiwgbmFtZSApe1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKXtcbiAgICB2YXIgc2VsZWN0b3JPckVsZXMgPSBhcmcxO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIga2V5O1xuXG4gICAgaWYoIHNlbGVjdG9yT3JFbGVzID09IG51bGwgKXtcbiAgICAgIGtleSA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIHNlbGVjdG9yT3JFbGVzICkgJiYgc2VsZWN0b3JPckVsZXMubGVuZ3RoID09PSAxICl7XG4gICAgICBrZXkgPSAnIycgKyBzZWxlY3Rvck9yRWxlcy5pZCgpO1xuICAgIH1cblxuICAgIGlmKCBlbGVzLmxlbmd0aCA9PT0gMSAmJiBrZXkgKXtcbiAgICAgIHZhciBfcCA9IGVsZXNbMF0uX3ByaXZhdGU7XG4gICAgICB2YXIgdGNoID0gX3AudHJhdmVyc2FsQ2FjaGUgPSBfcC50cmF2ZXJzYWxDYWNoZSB8fCB7fTtcbiAgICAgIHZhciBjaCA9IHRjaFsgbmFtZSBdID0gdGNoWyBuYW1lIF0gfHwge307XG4gICAgICB2YXIgY2FjaGVIaXQgPSBjaFsga2V5IF07XG5cbiAgICAgIGlmKCBjYWNoZUhpdCApe1xuICAgICAgICByZXR1cm4gY2FjaGVIaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKCBjaFsga2V5IF0gPSBmbi5jYWxsKCBlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0ICkgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoIGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBEQUcgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZpbmVEYWdFeHRyZW1pdHkgPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiBkYWdFeHRyZW1pdHlJbXBsKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgICBpZiggIWVsZS5pc05vZGUoKSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3F1YWxpZmllZCA9IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgICAgICggcGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSApXG4gICAgICAgICAgfHwgKCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlIClcbiAgICAgICAgKXtcbiAgICAgICAgICBkaXNxdWFsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZGlzcXVhbGlmaWVkICl7XG4gICAgICAgIHJldC5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcmV0LCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ09uZUhvcCA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbIGogXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmKCBwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUgKXtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgb0VsZXMucHVzaCggdGd0ICk7XG4gICAgICAgIH0gZWxzZSBpZiggcGFyYW1zLmluY29taW5nICYmIHRndCA9PT0gZWxlICl7XG4gICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgIG9FbGVzLnB1c2goIHNyYyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHNFbGVzID0gW107XG4gICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICBmb3IoIDs7ICl7XG4gICAgICB2YXIgbmV4dCA9IHBhcmFtcy5vdXRnb2luZyA/IGVsZXMub3V0Z29lcnMoKSA6IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgaWYoIG5leHQubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm9uZSBsZWZ0XG5cbiAgICAgIHZhciBuZXdOZXh0ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG4gPSBuZXh0WyBpIF07XG4gICAgICAgIHZhciBuaWQgPSBuLmlkKCk7XG5cbiAgICAgICAgaWYoICFzRWxlc0lkc1sgbmlkIF0gKXtcbiAgICAgICAgICBzRWxlc0lkc1sgbmlkIF0gPSB0cnVlO1xuICAgICAgICAgIHNFbGVzLnB1c2goIG4gKTtcbiAgICAgICAgICBuZXdOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIW5ld05leHQgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgIGVsZXMgPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBzRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcbn07XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vSW5jb21pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vT3V0Z29pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZSggZGVmaW5lRGFnT25lSG9wKHsgb3V0Z29pbmc6IHRydWUgfSkgLCAnb3V0Z29lcnMnICksXG5cbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHsgb3V0Z29pbmc6IHRydWUgfSksXG5cbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZSggZGVmaW5lRGFnT25lSG9wKHsgaW5jb21pbmc6IHRydWUgfSksICdpbmNvbWVycycgKSxcblxuICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICBwcmVkZWNlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoeyBpbmNvbWluZzogdHJ1ZSB9KVxufSApO1xuXG5cbi8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZCggZWxlc2ZuLCB7XG4gIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbIGogXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjO1xuXG4gICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgIGlmKCBvdGhlck5vZGUubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIG90aGVyTm9kZVswXSApOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcbiAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZVswXSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICggdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSwgJ25laWdoYm9yaG9vZCcpLFxuXG4gIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuYWRkKCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCggc2VsZWN0b3IgKTtcbiAgfVxufSApO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4ubmVpZ2hib3VyaG9vZCA9IGVsZXNmbi5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4uY2xvc2VkTmVpZ2hib3VyaG9vZCA9IGVsZXNmbi5jbG9zZWROZWlnaGJvcmhvb2Q7XG5lbGVzZm4ub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4ub3Blbk5laWdoYm9yaG9vZDtcblxuLy8gRWRnZSBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlciggc2VsZWN0b3IgKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuXG4gIHRhcmdldDogY2FjaGUoZnVuY3Rpb24gdGFyZ2V0SW1wbCggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldCB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoIHNlbGVjdG9yICkgOiB0Z3Q7XG4gIH0sICd0YXJnZXQnKSxcblxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbigge1xuICAgIGF0dHI6ICdzb3VyY2UnXG4gIH0gKSxcblxuICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbigge1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0gKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKCBzZWxlY3RvciApe1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWyBpIF07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlWyBwYXJhbXMuYXR0ciBdO1xuXG4gICAgICBpZiggc3JjICl7XG4gICAgICAgIHNvdXJjZXMucHVzaCggc3JjICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNvdXJjZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgZWRnZXNXaXRoOiBjYWNoZSggZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcsIHRydWUgKSxcblxuICBlZGdlc1RvOiBjYWNoZSggZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oIHtcbiAgICB0aGlzSXNTcmM6IHRydWVcbiAgfSApLCAnZWRnZXNUbycsIHRydWUgKVxufSApO1xuXG5mdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiggcGFyYW1zICl7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwoIG90aGVyTm9kZXMgKXtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgaWYoIGlzLnN0cmluZyggb3RoZXJOb2RlcyApICl7XG4gICAgICBvdGhlck5vZGVzID0gY3kuJCggb3RoZXJOb2RlcyApO1xuICAgIH1cblxuICAgIHZhciB0aGlzSWRzID0gdGhpcy5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIG90aGVySWRzID0gb3RoZXJOb2Rlcy5fcHJpdmF0ZS5pZHM7XG5cbiAgICBmb3IoIHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKysgKXtcbiAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXNbIGggXS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzWyBpIF07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpc0lkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgb3RoZXJJZHNbIGVkZ2VEYXRhLnRhcmdldCBdO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlcklkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgdGhpc0lkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgIHZhciBlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgPSB0aGlzVG9PdGhlciB8fCBvdGhlclRvVGhpcztcblxuICAgICAgICBpZiggIWVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmKCBwLnRoaXNJc1NyYyB8fCBwLnRoaXNJc1RndCApe1xuICAgICAgICAgIGlmKCBwLnRoaXNJc1NyYyAmJiAhdGhpc1RvT3RoZXIgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGlmKCBwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMgKXsgY29udGludWU7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbiAgfTtcbn1cblxudXRpbC5leHRlbmQoIGVsZXNmbiwge1xuICBjb25uZWN0ZWRFZGdlczogY2FjaGUoZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gZWxlc1sgaSBdO1xuICAgICAgaWYoICFub2RlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1sgaiBdO1xuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSwgJ2Nvbm5lY3RlZEVkZ2VzJyksXG5cbiAgY29ubmVjdGVkTm9kZXM6IGNhY2hlKGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciByZXRFbGVzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWRnZSA9IGVsZXNbIGkgXTtcbiAgICAgIGlmKCAhZWRnZS5pc0VkZ2UoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICByZXRFbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgIHJldEVsZXMucHVzaCggZWRnZS50YXJnZXQoKVswXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LCAnY29ubmVjdGVkTm9kZXMnKSxcblxuICBwYXJhbGxlbEVkZ2VzOiBjYWNoZSggZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyApLFxuXG4gIGNvZGlyZWN0ZWRFZGdlczogY2FjaGUoIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigge1xuICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgfSApLCAnY29kaXJlY3RlZEVkZ2VzJyApXG59ICk7XG5cbmZ1bmN0aW9uIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbiggcGFyYW1zICl7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICB9O1xuICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcGFyYWxsZWxFZGdlc0ltcGwoIHNlbGVjdG9yICl7IC8vIG1pY3JvLW9wdGltaXNlZCBmb3IgcmVuZGVyZXJcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgdmFyIHAgPSBwYXJhbXM7XG5cbiAgICAvLyBsb29rIGF0IGFsbCB0aGUgZWRnZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWRnZTEgPSBlZGdlc1sgaSBdO1xuICAgICAgdmFyIGVkZ2UxX3AgPSBlZGdlMS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzcmMxID0gZWRnZTFfcC5zb3VyY2U7XG4gICAgICB2YXIgc3JjaWQxID0gc3JjMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIHRndGlkMSA9IGVkZ2UxX3AuZGF0YS50YXJnZXQ7XG4gICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxWyBqIF07XG4gICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG5cbiAgICAgICAgaWYoIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCkgfHwgKCFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2UyICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG5cbn1cblxuLy8gTWlzYyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKCBlbGVzZm4sIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIHZhciB2aXNpdGVkID0gc2VsZi5zcGF3bigpO1xuICAgIHZhciB1bnZpc2l0ZWQgPSBzZWxmLm5vZGVzKCkuc3Bhd25TZWxmKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgIHZhciB2aXNpdEluQ29tcG9uZW50ID0gZnVuY3Rpb24oIG5vZGUsIGNvbXBvbmVudCApe1xuICAgICAgdmlzaXRlZC5tZXJnZSggbm9kZSApO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2UoIG5vZGUgKTtcbiAgICAgIGNvbXBvbmVudC5tZXJnZSggbm9kZSApO1xuICAgIH07XG5cbiAgICBpZiggdW52aXNpdGVkLmVtcHR5KCkgKXsgcmV0dXJuIHNlbGYuc3Bhd24oKTsgfVxuXG4gICAgZG8ge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaCggY29tcG9uZW50ICk7XG5cbiAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgdmlzaXRJbkNvbXBvbmVudCggcm9vdCwgY29tcG9uZW50ICk7XG5cbiAgICAgIHNlbGYuYmZzKHtcbiAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICByb290czogcm9vdCxcbiAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uKCBpLCBkZXB0aCwgdiwgZSwgdSApe1xuICAgICAgICAgIHZpc2l0SW5Db21wb25lbnQoIHYsIGNvbXBvbmVudCApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG5cbiAgICB9IHdoaWxlKCB1bnZpc2l0ZWQubGVuZ3RoID4gMCApO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uKCBjb21wb25lbnQgKXtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IGNvbXBvbmVudC5jb25uZWN0ZWRFZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LmFueVNhbWUoIGVkZ2Uuc291cmNlKCkgKSAmJiBjb21wb25lbnQuYW55U2FtZSggZWRnZS50YXJnZXQoKSApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjb21wb25lbnQudW5pb24oIGNvbm5lY3RlZEVkZ2VzICk7XG4gICAgfSk7XG4gIH1cbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogIEVsZW1lbnRzIGFyZSBkcmF3biBpbiBhIHNwZWNpZmljIG9yZGVyIGJhc2VkIG9uIGNvbXBvdW5kIGRlcHRoIChsb3cgdG8gaGlnaCksIHRoZSBlbGVtZW50IHR5cGUgKG5vZGVzIGFib3ZlIGVkZ2VzKSxcbiAqICBhbmQgei1pbmRleCAobG93IHRvIGhpZ2gpLiAgVGhlc2Ugc3R5bGVzIGFmZmVjdCBob3cgdGhpcyBhcHBsaWVzOlxuICpcbiAqICB6LWNvbXBvdW5kLWRlcHRoOiBNYXkgYmUgYGJvdHRvbSB8IG9ycGhhbiB8IGF1dG8gfCB0b3BgLiAgVGhlIGZpcnN0IGRyYXduIGlzIGBib3R0b21gLCB0aGVuIGBvcnBoYW5gIHdoaWNoIGlzIHRoZVxuICogICAgICBzYW1lIGRlcHRoIGFzIHRoZSByb290IG9mIHRoZSBjb21wb3VuZCBncmFwaCwgZm9sbG93ZWQgYnkgdGhlIGRlZmF1bHQgdmFsdWUgYGF1dG9gIHdoaWNoIGRyYXdzIGluIG9yZGVyIGZyb21cbiAqICAgICAgcm9vdCB0byBsZWF2ZXMgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLiAgVGhlIGxhc3QgZHJhd24gaXMgYHRvcGAuXG4gKiAgei1pbmRleC1jb21wYXJlOiBNYXkgYmUgYGF1dG8gfCBtYW51YWxgLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGF1dG9gIHdoaWNoIGFsd2F5cyBkcmF3cyBlZGdlcyB1bmRlciBub2Rlcy5cbiAqICAgICAgYG1hbnVhbGAgaWdub3JlcyB0aGlzIGNvbnZlbnRpb24gYW5kIGRyYXdzIGJhc2VkIG9uIHRoZSBgei1pbmRleGAgdmFsdWUgc2V0dGluZy5cbiAqICB6LWluZGV4OiBBbiBpbnRlZ2VyIHZhbHVlIHRoYXQgYWZmZWN0cyB0aGUgcmVsYXRpdmUgZHJhdyBvcmRlciBvZiBlbGVtZW50cy4gIEluIGdlbmVyYWwsIGFuIGVsZW1lbnQgd2l0aCBhIGhpZ2hlclxuICogICAgICBgei1pbmRleGAgd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgYW4gZWxlbWVudCB3aXRoIGEgbG93ZXIgYHotaW5kZXhgLlxuICovXG52YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uKCBhLCBiICl7XG4gIHZhciBjeSA9IGEuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKXtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCAnei1jb21wb3VuZC1kZXB0aCcgKTtcbiAgICBpZiAoIHN0eWxlLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgIHJldHVybiBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnpEZXB0aCgpIDogMFxuICAgIH0gZWxzZSBpZiAoIHN0eWxlLnZhbHVlID09PSAnYm90dG9tJyApe1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICggc3R5bGUudmFsdWUgPT09ICd0b3AnICl7XG4gICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB9XG4gICAgLy8gJ29ycGhhbidcbiAgICByZXR1cm4gMFxuICB9XG4gIHZhciBkZXB0aERpZmYgPSBnZXREZXB0aChhKSAtIGdldERlcHRoKGIpO1xuICBpZiAoIGRlcHRoRGlmZiAhPT0gMCApe1xuICAgIHJldHVybiBkZXB0aERpZmZcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZURlcHRoKGVsZSl7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSggJ3otaW5kZXgtY29tcGFyZScgKTtcbiAgICBpZiAoIHN0eWxlLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgPyAxIDogMFxuICAgIH1cbiAgICAvLyAnbWFudWFsJ1xuICAgIHJldHVybiAwXG4gIH1cbiAgdmFyIGVsZURpZmYgPSBnZXRFbGVEZXB0aChhKSAtIGdldEVsZURlcHRoKGIpO1xuICBpZiAoIGVsZURpZmYgIT09IDAgKXtcbiAgICByZXR1cm4gZWxlRGlmZlxuICB9XG5cbiAgdmFyIHpEaWZmID0gYS5wc3R5bGUoICd6LWluZGV4JyApLnZhbHVlIC0gYi5wc3R5bGUoICd6LWluZGV4JyApLnZhbHVlO1xuICBpZiAoIHpEaWZmICE9PSAwICl7XG4gICAgcmV0dXJuIHpEaWZmXG4gIH1cbiAgLy8gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB6SW5kZXhTb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCAnLi4vY29sbGVjdGlvbicgKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJy4uL2NvbGxlY3Rpb24vZWxlbWVudCcgKTtcblxudmFyIGNvcmVmbiA9IHtcbiAgYWRkOiBmdW5jdGlvbiggb3B0cyApe1xuXG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIG9wdHMgKSApe1xuICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICBpZiggZWxlcy5fcHJpdmF0ZS5jeSA9PT0gY3kgKXsgLy8gc2FtZSBpbnN0YW5jZSA9PiBqdXN0IHJlc3RvcmVcbiAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcblxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1sgaSBdO1xuICAgICAgICAgIGpzb25zLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oIGN5LCBqc29ucyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgIGVsc2UgaWYoIGlzLmFycmF5KCBvcHRzICkgKXtcbiAgICAgIHZhciBqc29ucyA9IG9wdHM7XG5cbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oIGN5LCBqc29ucyApO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggb3B0cyApICYmIChpcy5hcnJheSggb3B0cy5ub2RlcyApIHx8IGlzLmFycmF5KCBvcHRzLmVkZ2VzICkpICl7XG4gICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgIHZhciBncnMgPSBbICdub2RlcycsICdlZGdlcycgXTtcbiAgICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IGdycy5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgIHZhciBncm91cCA9IGdyc1sgaSBdO1xuICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbIGdyb3VwIF07XG5cbiAgICAgICAgaWYoIGlzLmFycmF5KCBlbGVzQXJyYXkgKSApe1xuXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBqc29uID0gdXRpbC5leHRlbmQoIHsgZ3JvdXA6IGdyb3VwIH0sIGVsZXNBcnJheVsgaiBdICk7XG5cbiAgICAgICAgICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggY3ksIGpzb25zICk7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgIGVsc2Uge1xuICAgICAgdmFyIGpzb24gPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSAobmV3IEVsZW1lbnQoIGN5LCBqc29uICkpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBjb2xsZWN0aW9uICkgKXtcbiAgICAgIC8vIGFscmVhZHkgaGF2ZSByaWdodCByZWZcbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyggY29sbGVjdGlvbiApICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJCggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgfSxcblxuICBsb2FkOiBmdW5jdGlvbiggZWxlbWVudHMsIG9ubG9hZCwgb25kb25lICl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGN5Lm5vdGlmaWNhdGlvbnMoIGZhbHNlICk7XG5cbiAgICAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG4gICAgdmFyIG9sZEVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICBpZiggb2xkRWxlcy5sZW5ndGggPiAwICl7XG4gICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGlmKCBlbGVtZW50cyAhPSBudWxsICl7XG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzICkgfHwgaXMuYXJyYXkoIGVsZW1lbnRzICkgKXtcbiAgICAgICAgY3kuYWRkKCBlbGVtZW50cyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN5Lm9uZSggJ2xheW91dHJlYWR5JywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnMoIHRydWUgKTtcbiAgICAgIGN5LnRyaWdnZXIoIGUgKTsgLy8gd2UgbWlzc2VkIHRoaXMgZXZlbnQgYnkgdHVybmluZyBub3RpZmljYXRpb25zIG9mZiwgc28gcGFzcyBpdCBvblxuXG4gICAgICBjeS5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICBlbGVzOiBjeS5tdXRhYmxlRWxlbWVudHMoKVxuICAgICAgfSApO1xuXG4gICAgICBjeS5vbmUoICdsb2FkJywgb25sb2FkICk7XG4gICAgICBjeS50cmlnZ2VyKCAnbG9hZCcgKTtcbiAgICB9ICkub25lKCAnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uKCl7XG4gICAgICBjeS5vbmUoICdkb25lJywgb25kb25lICk7XG4gICAgICBjeS50cmlnZ2VyKCAnZG9uZScgKTtcbiAgICB9ICk7XG5cbiAgICB2YXIgbGF5b3V0T3B0cyA9IHV0aWwuZXh0ZW5kKCB7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQgKTtcbiAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS5lbGVtZW50cygpO1xuXG4gICAgY3kubGF5b3V0KCBsYXlvdXRPcHRzICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCAnLi4vZGVmaW5lJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpLFxuXG4gIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKCBlbGVzICk7XG4gIH0sXG5cbiAgc3RvcEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICAvLyBOQiB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBleGVjIGluIGhlYWRsZXNzIGVudmlyb25tZW50cyBpZiBzdHlsZSBlbmFibGVkXG4gICAgLy8gYW5kIGV4cGxpY2l0IGN5LmRlc3Ryb3koKSBpcyBuZWNlc3NhcnkgdG8gc3RvcCB0aGUgbG9vcFxuXG4gICAgZnVuY3Rpb24gZ2xvYmFsQW5pbWF0aW9uU3RlcCgpe1xuICAgICAgaWYoICFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyApeyByZXR1cm47IH1cblxuICAgICAgdXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uIGFuaW1hdGlvblN0ZXAoIG5vdyApe1xuICAgICAgICBoYW5kbGVFbGVtZW50cyggbm93ICk7XG4gICAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuXG4gICAgaWYoIHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlciApeyAvLyBsZXQgdGhlIHJlbmRlcmVyIHNjaGVkdWxlIGFuaW1hdGlvbnNcbiAgICAgIHJlbmRlcmVyLmJlZm9yZVJlbmRlciggZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKCB3aWxsRHJhdywgbm93ICl7XG4gICAgICAgIGhhbmRsZUVsZW1lbnRzKCBub3cgKTtcbiAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyApO1xuICAgIH0gZWxzZSB7IC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICBnbG9iYWxBbmltYXRpb25TdGVwKCk7IC8vIGZpcnN0IGNhbGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50cyggbm93ICl7XG4gICAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudCggZWxlLCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgY3VycmVudCA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2FuY2VsIGFsbCBhbmltYXRpb25zIG9uIGRpc3BsYXk6bm9uZSBlbGVcbiAgICAgICAgaWYoICFpc0NvcmUgJiYgZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScgKXtcbiAgICAgICAgICAvLyBwdXQgYWxsIGN1cnJlbnQgYW5kIHF1ZXVlIGFuaW1hdGlvbnMgaW4gdGhpcyB0aWNrJ3MgY3VycmVudCBsaXN0XG4gICAgICAgICAgLy8gYW5kIGVtcHR5IHRoZSBsaXN0cyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zcGxpY2UoIDAsIGN1cnJlbnQubGVuZ3RoICkuY29uY2F0KCBxdWV1ZS5zcGxpY2UoIDAsIHF1ZXVlLmxlbmd0aCApICk7XG5cbiAgICAgICAgICAvLyBzdG9wIGFsbCBhbmltYXRpb25zXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrICl7IGN1cnJlbnRbaV0uc3RvcCgpOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgaWYoIGN1cnJlbnQubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgaWYoIG5leHQgKXtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaCggbmV4dCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiggY2FsbGJhY2tzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSApe1xuICAgICAgICAgICAgdmFyIGNiID0gY2FsbGJhY2tzWyBqIF07XG5cbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FsbGJhY2tzLnNwbGljZSggMCwgY2FsbGJhY2tzLmxlbmd0aCApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgICAgIGZvciggdmFyIGkgPSBjdXJyZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7XG4gICAgICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbIGkgXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICBpZiggYW5pX3Auc3RvcHBlZCApe1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcyggYW5pX3AuZnJhbWVzICk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICBpZiggYW5pX3AucGxheWluZyAmJiBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWFuaV9wLnN0YXJ0ZWQgKXtcbiAgICAgICAgICAgIHN0YXJ0QW5pbWF0aW9uKCBlbGUsIGFuaSwgbm93ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RlcCggZWxlLCBhbmksIG5vdywgaXNDb3JlICk7XG5cbiAgICAgICAgICBpZiggaXMuZm4oIGFuaV9wLnN0ZXAgKSApe1xuICAgICAgICAgICAgYW5pX3Auc3RlcC5jYWxsKCBlbGUsIG5vdyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmZyYW1lcyApO1xuXG4gICAgICAgICAgaWYoIGFuaS5jb21wbGV0ZWQoKSApe1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcyggYW5pX3AuY29tcGxldGVzICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBkb25lRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5BbmlzO1xuICAgICAgfSAvLyBoYW5kbGVFbGVtZW50XG5cbiAgICAgIC8vIGhhbmRsZSBhbGwgZWxlc1xuICAgICAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBlIF07XG4gICAgICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuXG4gICAgICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcblxuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICBpZiggcmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgaWYoIGVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKS5zcGF3blNlbGYoKS5tZXJnZSggZWxlcyApO1xuXG4gICAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmF3JyxcbiAgICAgICAgICAgIGVsZXM6IHVwZGF0ZWRFbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICAgICAgZWxlcy51bm1lcmdlKCBkb25lRWxlcyApO1xuXG4gICAgICBjeS50cmlnZ2VyKCdzdGVwJyk7XG5cbiAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbiggc2VsZiwgYW5pLCBub3cgKXtcbiAgICAgIHZhciBpc0NvcmUgPSBpcy5jb3JlKCBzZWxmICk7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgIHZhciBlbGUgPSBzZWxmO1xuICAgICAgdmFyIHN0eWxlID0gY3kuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBhbmlfcC5zdGFydFBvc2l0aW9uID0gYW5pX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgfTtcblxuICAgICAgICBhbmlfcC5zdGFydFN0eWxlID0gYW5pX3Auc3RhcnRTdHlsZSB8fCBzdHlsZS5nZXRBbmltYXRpb25TdGFydFN0eWxlKCBlbGUsIGFuaV9wLnN0eWxlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcblxuICAgICAgICBhbmlfcC5zdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuIHx8IHtcbiAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICB5OiBwYW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGFuaV9wLnN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbSAhPSBudWxsID8gYW5pX3Auc3RhcnRab29tIDogY3kuX3ByaXZhdGUuem9vbTtcbiAgICAgIH1cblxuICAgICAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gICAgICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoIHNlbGYsIGFuaSwgbm93LCBpc0NvcmUgKXtcbiAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuXG4gICAgICBpZiggIWFuaV9wLmVhc2luZ0ltcGwgKXtcblxuICAgICAgICBpZiggcEVhc2luZyA9PSBudWxsICl7IC8vIHVzZSBkZWZhdWx0XG4gICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbICdsaW5lYXInIF07XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiBkZWZpbmUgdy8gbmFtZVxuICAgICAgICAgIHZhciBlYXNpbmdWYWxzO1xuXG4gICAgICAgICAgaWYoIGlzLnN0cmluZyggcEVhc2luZyApICl7XG4gICAgICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nICk7XG5cbiAgICAgICAgICAgIGVhc2luZ1ZhbHMgPSBlYXNpbmdQcm9wLnZhbHVlO1xuXG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiBhc3N1bWUgcHJlcGFyc2VkIGFycmF5XG4gICAgICAgICAgICBlYXNpbmdWYWxzID0gcEVhc2luZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmFtZSwgYXJncztcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIGVhc2luZ1ZhbHMgKSApe1xuICAgICAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICAgICAgYXJncyA9IGVhc2luZ1ZhbHMuc2xpY2UoIDIgKS5tYXAoIGZ1bmN0aW9uKCBuICl7IHJldHVybiArbjsgfSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDAgKXsgLy8gY3JlYXRlIHdpdGggYXJnc1xuICAgICAgICAgICAgaWYoIG5hbWUgPT09ICdzcHJpbmcnICl7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaCggYW5pX3AuZHVyYXRpb24gKTsgLy8gbmVlZCBkdXJhdGlvbiB0byBnZW5lcmF0ZSBzcHJpbmdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbIG5hbWUgXS5hcHBseSggbnVsbCwgYXJncyApO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyBuYW1lIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGVhc2luZyA9IGFuaV9wLmVhc2luZ0ltcGw7XG4gICAgICB2YXIgcGVyY2VudDtcblxuICAgICAgaWYoIGFuaV9wLmR1cmF0aW9uID09PSAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmKCBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICBwZXJjZW50ID0gYW5pX3AucHJvZ3Jlc3M7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmKCBhbmlfcC5kZWxheSA9PSBudWxsICl7IC8vIHRoZW4gdXBkYXRlXG5cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gYW5pX3Auc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICAgIGlmKCBlbmRQb3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBvcy54LCBlbmRQb3MueCApICl7XG4gICAgICAgICAgICBwb3MueCA9IGVhc2UoIHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLnksIGVuZFBvcy55ICkgKXtcbiAgICAgICAgICAgIHBvcy55ID0gZWFzZSggc3RhcnRQb3MueSwgZW5kUG9zLnksIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgICAgICB2YXIgZW5kUGFuID0gYW5pX3AucGFuO1xuICAgICAgICB2YXIgcGFuID0gX3AucGFuO1xuICAgICAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuICAgICAgICBpZiggYW5pbWF0aW5nUGFuICl7XG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi54LCBlbmRQYW4ueCApICl7XG4gICAgICAgICAgICBwYW4ueCA9IGVhc2UoIHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLnksIGVuZFBhbi55ICkgKXtcbiAgICAgICAgICAgIHBhbi55ID0gZWFzZSggc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYudHJpZ2dlciggJ3BhbicgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb207XG4gICAgICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICAgICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuICAgICAgICBpZiggYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRab29tLCBlbmRab29tICkgKXtcbiAgICAgICAgICAgIF9wLnpvb20gPSBlYXNlKCBzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYudHJpZ2dlciggJ3pvb20nICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYW5pbWF0aW5nUGFuIHx8IGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoICd2aWV3cG9ydCcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuICAgICAgICBpZiggcHJvcHMgJiYgcHJvcHMubGVuZ3RoID4gMCAmJiBpc0VsZXMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzWyBpIF07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwcm9wO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcgKTtcblxuICAgICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3MoIHNlbGYsIG5hbWUsIGVhc2VkVmFsICk7XG4gICAgICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgICAgIHNlbGYudHJpZ2dlcignc3R5bGUnKTtcblxuICAgICAgICB9IC8vIGlmXG5cbiAgICAgIH1cblxuICAgICAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuXG4gICAgICByZXR1cm4gcGVyY2VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZCggc3RhcnQsIGVuZCApe1xuICAgICAgaWYoIHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggaXMubnVtYmVyKCBzdGFydCApICYmIGlzLm51bWJlciggZW5kICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYoIChzdGFydCkgJiYgKGVuZCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWVzIHAwID0gMCwgcDMgPSAxXG4gICAgZnVuY3Rpb24gZXZhbEN1YmljQmV6aWVyKCBwMSwgcDIsIHQgKXtcbiAgICAgIHZhciBvbmVfdCA9IDEgLSB0O1xuICAgICAgdmFyIHRzcSA9IHQgKiB0O1xuXG4gICAgICByZXR1cm4gKCAzICogb25lX3QgKiBvbmVfdCAqIHQgKiBwMSApICsgKCAzICogb25lX3QgKiB0c3EgKiBwMiApICsgdHNxICogdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdWJpY0JlemllciggcDEsIHAyICl7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGV2YWxDdWJpY0JlemllciggcDEsIHAyLCBwZXJjZW50ICk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbiAgICAvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgICAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xuICAgIHZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IChmdW5jdGlvbigpe1xuICAgICAgZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoIHN0YXRlICl7XG4gICAgICAgIHJldHVybiAoLXN0YXRlLnRlbnNpb24gKiBzdGF0ZS54KSAtIChzdGF0ZS5mcmljdGlvbiAqIHN0YXRlLnYpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoIGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUgKXtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgICAgIHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuICAgICAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4geyBkeDogc3RhdGUudiwgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKCBzdGF0ZSApIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNwcmluZ0ludGVncmF0ZVN0YXRlKCBzdGF0ZSwgZHQgKXtcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKCBzdGF0ZSApXG4gICAgICAgIH0sXG4gICAgICAgIGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoIHN0YXRlLCBkdCAqIDAuNSwgYSApLFxuICAgICAgICBjID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKCBzdGF0ZSwgZHQgKiAwLjUsIGIgKSxcbiAgICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZSggc3RhdGUsIGR0LCBjICksXG4gICAgICAgIGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcbiAgICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuXG4gICAgICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgICAgICBzdGF0ZS52ID0gc3RhdGUudiArIGR2ZHQgKiBkdDtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzcHJpbmdSSzRGYWN0b3J5KCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKXtcblxuICAgICAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgIHY6IDAsXG4gICAgICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBwYXRoID0gWzBdLFxuICAgICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICAgIHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcbiAgICAgICAgRFQgPSAxNiAvIDEwMDAsXG4gICAgICAgIGhhdmVfZHVyYXRpb24sIGR0LCBsYXN0X3N0YXRlO1xuXG4gICAgICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KCB0ZW5zaW9uICkgfHwgNTAwO1xuICAgICAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoIGZyaWN0aW9uICkgfHwgMjA7XG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcblxuICAgICAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgICAgIGluaXRTdGF0ZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuXG4gICAgICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcblxuICAgICAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuICAgICAgICBpZiggaGF2ZV9kdXJhdGlvbiApe1xuICAgICAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICAgICAgdGltZV9sYXBzZWQgPSBzcHJpbmdSSzRGYWN0b3J5KCB0ZW5zaW9uLCBmcmljdGlvbiApO1xuICAgICAgICAgIC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovXG4gICAgICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHQgPSBEVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKCB0cnVlICl7XG4gICAgICAgICAgLyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuICAgICAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZSggbGFzdF9zdGF0ZSB8fCBpbml0U3RhdGUsIGR0ICk7XG4gICAgICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgICAgIHBhdGgucHVzaCggMSArIGxhc3Rfc3RhdGUueCApO1xuICAgICAgICAgIHRpbWVfbGFwc2VkICs9IDE2O1xuICAgICAgICAgIC8qIElmIHRoZSBjaGFuZ2UgdGhyZXNob2xkIGlzIHJlYWNoZWQsIGJyZWFrLiAqL1xuICAgICAgICAgIGlmKCAhKE1hdGguYWJzKCBsYXN0X3N0YXRlLnggKSA+IHRvbGVyYW5jZSAmJiBNYXRoLmFicyggbGFzdF9zdGF0ZS52ICkgPiB0b2xlcmFuY2UpICl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG4gICAgICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuICAgICAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uKCBwZXJjZW50Q29tcGxldGUgKXsgcmV0dXJuIHBhdGhbIChwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSkgfCAwIF07IH07XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgZWFzaW5ncyA9IHtcbiAgICAgICdsaW5lYXInOiBmdW5jdGlvbiggc3RhcnQsIGVuZCwgcGVyY2VudCApe1xuICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGRlZmF1bHQgZWFzaW5nc1xuICAgICAgJ2Vhc2UnOiBjdWJpY0JlemllciggMC4yNSwgMC4xLCAwLjI1LCAxICksXG4gICAgICAnZWFzZS1pbic6IGN1YmljQmV6aWVyKCAwLjQyLCAwLCAxLCAxICksXG4gICAgICAnZWFzZS1vdXQnOiBjdWJpY0JlemllciggMCwgMCwgMC41OCwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0JzogY3ViaWNCZXppZXIoIDAuNDIsIDAsIDAuNTgsIDEgKSxcblxuICAgICAgLy8gc2luZVxuICAgICAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKCAwLjQ3LCAwLCAwLjc0NSwgMC43MTUgKSxcbiAgICAgICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoIDAuMzksIDAuNTc1LCAwLjU2NSwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllciggMC40NDUsIDAuMDUsIDAuNTUsIDAuOTUgKSxcblxuICAgICAgLy8gcXVhZFxuICAgICAgJ2Vhc2UtaW4tcXVhZCc6IGN1YmljQmV6aWVyKCAwLjU1LCAwLjA4NSwgMC42OCwgMC41MyApLFxuICAgICAgJ2Vhc2Utb3V0LXF1YWQnOiBjdWJpY0JlemllciggMC4yNSwgMC40NiwgMC40NSwgMC45NCApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBjdWJpY0JlemllciggMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NSApLFxuXG4gICAgICAvLyBjdWJpY1xuICAgICAgJ2Vhc2UtaW4tY3ViaWMnOiBjdWJpY0JlemllciggMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5ICksXG4gICAgICAnZWFzZS1vdXQtY3ViaWMnOiBjdWJpY0JlemllciggMC4yMTUsIDAuNjEsIDAuMzU1LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtY3ViaWMnOiBjdWJpY0JlemllciggMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSApLFxuXG4gICAgICAvLyBxdWFydFxuICAgICAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllciggMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyICksXG4gICAgICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllciggMC4xNjUsIDAuODQsIDAuNDQsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKCAwLjc3LCAwLCAwLjE3NSwgMSApLFxuXG4gICAgICAvLyBxdWludFxuICAgICAgJ2Vhc2UtaW4tcXVpbnQnOiBjdWJpY0JlemllciggMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2ICksXG4gICAgICAnZWFzZS1vdXQtcXVpbnQnOiBjdWJpY0JlemllciggMC4yMywgMSwgMC4zMiwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogY3ViaWNCZXppZXIoIDAuODYsIDAsIDAuMDcsIDEgKSxcblxuICAgICAgLy8gZXhwb1xuICAgICAgJ2Vhc2UtaW4tZXhwbyc6IGN1YmljQmV6aWVyKCAwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUgKSxcbiAgICAgICdlYXNlLW91dC1leHBvJzogY3ViaWNCZXppZXIoIDAuMTksIDEsIDAuMjIsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1leHBvJzogY3ViaWNCZXppZXIoIDEsIDAsIDAsIDEgKSxcblxuICAgICAgLy8gY2lyY1xuICAgICAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKCAwLjYsIDAuMDQsIDAuOTgsIDAuMzM1ICksXG4gICAgICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKCAwLjA3NSwgMC44MiwgMC4xNjUsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoIDAuNzg1LCAwLjEzNSwgMC4xNSwgMC44NiApLFxuXG5cbiAgICAgIC8vIHVzZXIgcGFyYW0gZWFzaW5ncy4uLlxuXG4gICAgICAnc3ByaW5nJzogZnVuY3Rpb24oIHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbiApe1xuICAgICAgICBpZiggZHVyYXRpb24gPT09IDAgKXsgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgICAgICByZXR1cm4gZWFzaW5ncy5saW5lYXI7IC8vIGR1cmF0aW9uIDAgPT4ganVtcCB0byBlbmQgc28gaW1wbCBkb2Vzbid0IG1hdHRlclxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKCBwZXJjZW50ICk7XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAnY3ViaWMtYmV6aWVyJzogZnVuY3Rpb24oIHgxLCB5MSwgeDIsIHkyICl7XG4gICAgICAgIHJldHVybiBjdWJpY0JlemllciggeDEsIHkxLCB4MiwgeTIgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZWFzZSggc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiApe1xuICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgIGlmKCBzdGFydFByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHN0YXJ0UHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHN0YXJ0UHJvcC5wZlZhbHVlIDogc3RhcnRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydFByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlbmRQcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgZW5kID0gZW5kUHJvcC5wZlZhbHVlICE9IG51bGwgPyBlbmRQcm9wLnBmVmFsdWUgOiBlbmRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlciggc3RhcnQgKSAmJiBpcy5udW1iZXIoIGVuZCApICl7XG4gICAgICAgIHJldHVybiBlYXNpbmdGbiggc3RhcnQsIGVuZCwgcGVyY2VudCApO1xuXG4gICAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCBzdGFydCApICYmIGlzLmFycmF5KCBlbmQgKSApe1xuICAgICAgICB2YXIgZWFzZWRBcnIgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBzaSA9IHN0YXJ0WyBpIF07XG4gICAgICAgICAgdmFyIGVpID0gZW5kWyBpIF07XG5cbiAgICAgICAgICBpZiggc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsICl7XG4gICAgICAgICAgICB2YXIgdmFsID0gZWFzaW5nRm4oIHNpLCBlaSwgcGVyY2VudCApO1xuXG4gICAgICAgICAgICBpZiggc3RhcnRQcm9wLnJvdW5kVmFsdWUgKXsgdmFsID0gTWF0aC5yb3VuZCggdmFsICk7IH1cblxuICAgICAgICAgICAgZWFzZWRBcnIucHVzaCggdmFsICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhc2VkQXJyLnB1c2goIGVpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVhc2VkQXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuICBvbjogZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgb25lOiBkZWZpbmUub24oIHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9ICksXG4gIG9uY2U6IGRlZmluZS5vbiggeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0gKSxcbiAgb2ZmOiBkZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpIC8vIC50cmlnZ2VyKCBldmVudHMgWywgZXh0cmFQYXJhbXNdIClcbn0pO1xuXG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oIGNvcmVmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgcG5nOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICByZXR1cm4gcmVuZGVyZXIucG5nKCBvcHRpb25zICk7XG4gIH0sXG5cbiAganBnOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG5cbiAgICByZXR1cm4gcmVuZGVyZXIuanBnKCBvcHRpb25zICk7XG4gIH1cblxufSk7XG5cbmNvcmVmbi5qcGVnID0gY29yZWZuLmpwZztcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vd2luZG93JyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4uL2NvbGxlY3Rpb24nICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoICcuLi9wcm9taXNlJyApO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoICcuLi9kZWZpbmUnICk7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgdmFyIGN5ID0gdGhpcztcblxuICBvcHRzID0gdXRpbC5leHRlbmQoIHt9LCBvcHRzICk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuXG4gIC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuICBpZiggY29udGFpbmVyICYmICFpcy5odG1sRWxlbWVudCggY29udGFpbmVyICkgJiYgaXMuaHRtbEVsZW1lbnQoIGNvbnRhaW5lclswXSApICl7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG5cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYoIHJlZyAmJiByZWcuY3kgKXtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuXG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cblxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgaWYoIGNvbnRhaW5lciApeyBjb250YWluZXIuX2N5cmVnID0gcmVnOyB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcbiAgcmVnLmN5ID0gY3k7XG5cbiAgdmFyIGhlYWQgPSB3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgb3B0aW9ucy5yZW5kZXJlciA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJyB9LCBvcHRpb25zLnJlbmRlcmVyICk7XG5cbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uKCBkZWYsIHZhbCwgYWx0VmFsICl7XG4gICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiggYWx0VmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICByZWFkeTogZmFsc2UsIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgaW5pdHJlbmRlcjogZmFsc2UsIC8vIGhhcyBpbml0cmVuZGVyIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKCB0aGlzICksIC8vIGVsZW1lbnRzIGluIHRoZSBncmFwaFxuICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24oIHRoaXMgKSwgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICBzY3JhdGNoOiB7fSwgLy8gc2NyYXRjaCBvYmplY3QgZm9yIGNvcmVcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgcmVuZGVyZXI6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSwgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSwgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCggdHJ1ZSwgb3B0aW9ucy56b29taW5nRW5hYmxlZCApLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKCB0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCApLFxuICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQgKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCggdHJ1ZSwgb3B0aW9ucy51c2VyUGFubmluZ0VuYWJsZWQgKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwoIHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCApLFxuICAgIGF1dG9sb2NrOiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMgKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzICksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoIGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSApLFxuICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICB6b29tOiBpcy5udW1iZXIoIG9wdGlvbnMuem9vbSApID8gb3B0aW9ucy56b29tIDogMSxcbiAgICBwYW46IHtcbiAgICAgIHg6IGlzLnBsYWluT2JqZWN0KCBvcHRpb25zLnBhbiApICYmIGlzLm51bWJlciggb3B0aW9ucy5wYW4ueCApID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICB5OiBpcy5wbGFpbk9iamVjdCggb3B0aW9ucy5wYW4gKSAmJiBpcy5udW1iZXIoIG9wdGlvbnMucGFuLnkgKSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2VcbiAgfTtcblxuICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgdmFyIHNlbFR5cGUgPSBvcHRpb25zLnNlbGVjdGlvblR5cGU7XG4gIGlmKCBzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgKHNlbFR5cGUgIT09ICdhZGRpdGl2ZScgJiYgc2VsVHlwZSAhPT0gJ3NpbmdsZScpICl7XG4gICAgLy8gdGhlbiBzZXQgZGVmYXVsdFxuXG4gICAgX3Auc2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xuICB9IGVsc2Uge1xuICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICB9XG5cbiAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICBpZiggaXMubnVtYmVyKCBvcHRpb25zLm1pblpvb20gKSAmJiBpcy5udW1iZXIoIG9wdGlvbnMubWF4Wm9vbSApICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWluWm9vbSApICYmIG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgX3AubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWF4Wm9vbSApICYmIG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfVxuXG4gIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uKCBleHREYXRhLCBuZXh0ICl7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZSggaXMucHJvbWlzZSApO1xuXG4gICAgaWYoIGFueUlzUHJvbWlzZSApe1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKCBleHREYXRhICkudGhlbiggbmV4dCApOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoIGV4dERhdGEgKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgIH1cbiAgfTtcblxuICAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG4gIGN5LmluaXRSZW5kZXJlciggdXRpbC5leHRlbmQoIHtcbiAgICBoaWRlRWRnZXNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQsXG4gICAgdGV4dHVyZU9uVmlld3BvcnQ6IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQsXG4gICAgd2hlZWxTZW5zaXRpdml0eTogaXMubnVtYmVyKCBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgKSAmJiBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgPiAwID8gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5IDogMSxcbiAgICBtb3Rpb25CbHVyOiBvcHRpb25zLm1vdGlvbkJsdXIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5tb3Rpb25CbHVyLCAvLyBvZmYgYnkgZGVmYXVsdFxuICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICBwaXhlbFJhdGlvOiBpcy5udW1iZXIoIG9wdGlvbnMucGl4ZWxSYXRpbyApICYmIG9wdGlvbnMucGl4ZWxSYXRpbyA+IDAgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiB1bmRlZmluZWQsXG4gICAgZGVza3RvcFRhcFRocmVzaG9sZDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA0IDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkLFxuICAgIHRvdWNoVGFwVGhyZXNob2xkOiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA4IDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZFxuICB9LCBvcHRpb25zLnJlbmRlcmVyICkgKTtcblxuICBsb2FkRXh0RGF0YShbIG9wdGlvbnMuc3R5bGUsIG9wdGlvbnMuZWxlbWVudHMgXSwgZnVuY3Rpb24oIHRoZW5zICl7XG4gICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdO1xuXG4gICAgLy8gaW5pdCBzdHlsZVxuICAgIGlmKCBfcC5zdHlsZUVuYWJsZWQgKXtcbiAgICAgIGN5LnNldFN0eWxlKCBpbml0U3R5bGUgKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBwYXNzZWQgZnVuY3Rpb24gZm9yIHRoZSBgaW5pdHJlbmRlcmAgZXZlbnRcbiAgICBpZiggb3B0aW9ucy5pbml0cmVuZGVyICl7XG4gICAgICBjeS5vbiggJ2luaXRyZW5kZXInLCBvcHRpb25zLmluaXRyZW5kZXIgKTtcbiAgICAgIGN5Lm9uKCAnaW5pdHJlbmRlcicsIGZ1bmN0aW9uKCl7XG4gICAgICAgIF9wLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIGN5LmxvYWQoIGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYoIGlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgY3kub24oICdyZWFkeScsIG9wdGlvbnMucmVhZHkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZm4gPSByZWFkaWVzWyBpIF07XG4gICAgICAgIGN5Lm9uKCAncmVhZHknLCBmbiApO1xuICAgICAgfVxuICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cbiAgICAgIGN5LnRyaWdnZXIoICdyZWFkeScgKTtcbiAgICB9LCBvcHRpb25zLmRvbmUgKTtcblxuICB9ICk7XG59O1xuXG52YXIgY29yZWZuID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbnV0aWwuZXh0ZW5kKCBjb3JlZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICdjb3JlJztcbiAgfSxcblxuICBpc1JlYWR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICB9LFxuXG4gIGlzRGVzdHJveWVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmRlc3Ryb3llZDtcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgaWYoIHRoaXMuaXNSZWFkeSgpICl7XG4gICAgICB0aGlzLnRyaWdnZXIoICdyZWFkeScsIFtdLCBmbiApOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oICdyZWFkeScsIGZuICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5pbml0cmVuZGVyO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiggY3kuaXNEZXN0cm95ZWQoKSApIHJldHVybjtcblxuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcblxuICAgIHRoaXMudHJpZ2dlciggJ2Rlc3Ryb3knICk7XG5cbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGN5O1xuICB9LFxuXG4gIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uKCBpZCApe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoIGlkICk7XG4gIH0sXG5cbiAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uKCBpZCApe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICB9LFxuXG4gIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgfSxcblxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG5cbiAgaGVhZGxlc3M6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUub3B0aW9ucy5yZW5kZXJlci5uYW1lID09PSAnbnVsbCc7XG4gIH0sXG5cbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcblxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZSggZWxlcyApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy51bm1lcmdlKCBlbGVzICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuICB9LFxuXG4gIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHV0aWwuY29weSggdGhpcy5fcHJpdmF0ZS5vcHRpb25zICk7XG4gIH0sXG5cbiAganNvbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIGlmKCBpcy5wbGFpbk9iamVjdCggb2JqICkgKXsgLy8gc2V0XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYoIG9iai5lbGVtZW50cyApe1xuICAgICAgICB2YXIgaWRJbkpzb24gPSB7fTtcblxuICAgICAgICB2YXIgdXBkYXRlRWxlcyA9IGZ1bmN0aW9uKCBqc29ucywgZ3IgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIganNvbiA9IGpzb25zWyBpIF07XG4gICAgICAgICAgICB2YXIgaWQgPSBqc29uLmRhdGEuaWQ7XG4gICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgIGlkSW5Kc29uWyBpZCBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoIGVsZS5sZW5ndGggIT09IDAgKXsgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICBlbGUuanNvbigganNvbiApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiggZ3IgKXtcbiAgICAgICAgICAgICAgICBjeS5hZGQoIHV0aWwuZXh0ZW5kKCB7IGdyb3VwOiBnciB9LCBqc29uICkgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjeS5hZGQoIGpzb24gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXMuYXJyYXkoIG9iai5lbGVtZW50cyApICl7IC8vIGVsZW1lbnRzOiBbXVxuICAgICAgICAgIHVwZGF0ZUVsZXMoIG9iai5lbGVtZW50cyApO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICB2YXIgZ3JzID0gWyAnbm9kZXMnLCAnZWRnZXMnIF07XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gb2JqLmVsZW1lbnRzWyBnciBdO1xuXG4gICAgICAgICAgICBpZiggaXMuYXJyYXkoIGVsZW1lbnRzICkgKXtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyggZWxlbWVudHMsIGdyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxlbWVudHMgbm90IHNwZWNpZmllZCBpbiBqc29uIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICAgIGVsZXMuc3RkRmlsdGVyKCBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuICFpZEluSnNvblsgZWxlLmlkKCkgXTtcbiAgICAgICAgfSApLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggb2JqLnN0eWxlICl7XG4gICAgICAgIGN5LnN0eWxlKCBvYmouc3R5bGUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20gKXtcbiAgICAgICAgY3kuem9vbSggb2JqLnpvb20gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai5wYW4gKXtcbiAgICAgICAgaWYoIG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSApe1xuICAgICAgICAgIGN5LnBhbiggb2JqLnBhbiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJyxcbiAgICAgICAgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsXG4gICAgICAgICdib3hTZWxlY3Rpb25FbmFibGVkJyxcbiAgICAgICAgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5J1xuICAgICAgXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbIGkgXTtcblxuICAgICAgICBpZiggb2JqWyBmIF0gIT0gbnVsbCApe1xuICAgICAgICAgIGN5WyBmIF0oIG9ialsgZiBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIGlmKCBvYmogPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcbiAgICAgIHZhciBqc29uID0ge307XG5cbiAgICAgIGpzb24uZWxlbWVudHMgPSB7fTtcbiAgICAgIGVsZXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcblxuICAgICAgICBpZiggIWpzb24uZWxlbWVudHNbIGdyb3VwIF0gKXtcbiAgICAgICAgICBqc29uLmVsZW1lbnRzWyBncm91cCBdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBqc29uLmVsZW1lbnRzWyBncm91cCBdLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgIH0gKTtcblxuICAgICAgaWYoIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cblxuICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAganNvbi5taW5ab29tID0gY3kuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIGpzb24ubWF4Wm9vbSA9IGN5Ll9wcml2YXRlLm1heFpvb207XG4gICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24ucGFuID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5wYW4gKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IGN5Ll9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyICk7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IGN5Ll9wcml2YXRlLm9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubW90aW9uQmx1cjtcblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9LFxuXG4gIHNjcmF0Y2g6IGRlZmluZS5kYXRhKCB7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSApLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKCB7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWVcbiAgfSApXG5cbn0gKTtcblxuW1xuICByZXF1aXJlKCAnLi9hZGQtcmVtb3ZlJyApLFxuICByZXF1aXJlKCAnLi9hbmltYXRpb24nICksXG4gIHJlcXVpcmUoICcuL2V2ZW50cycgKSxcbiAgcmVxdWlyZSggJy4vZXhwb3J0JyApLFxuICByZXF1aXJlKCAnLi9sYXlvdXQnICksXG4gIHJlcXVpcmUoICcuL25vdGlmaWNhdGlvbicgKSxcbiAgcmVxdWlyZSggJy4vcmVuZGVyZXInICksXG4gIHJlcXVpcmUoICcuL3NlYXJjaCcgKSxcbiAgcmVxdWlyZSggJy4vc3R5bGUnICksXG4gIHJlcXVpcmUoICcuL3ZpZXdwb3J0JyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggY29yZWZuLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIGxheW91dDogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLl9wcml2YXRlLnByZXZMYXlvdXQgPSAoIHBhcmFtcyA9PSBudWxsID8gdGhpcy5fcHJpdmF0ZS5wcmV2TGF5b3V0IDogdGhpcy5tYWtlTGF5b3V0KCBwYXJhbXMgKSApO1xuXG4gICAgbGF5b3V0LnJ1bigpO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgbWFrZUxheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYoIG9wdGlvbnMgPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvciggJ0xheW91dCBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIG9wdGlvbnMubmFtZSA9PSBudWxsICl7XG4gICAgICB1dGlsLmVycm9yKCAnQSBgbmFtZWAgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCAnbGF5b3V0JywgbmFtZSApO1xuXG4gICAgaWYoIExheW91dCA9PSBudWxsICl7XG4gICAgICB1dGlsLmVycm9yKCAnQ2FuIG5vdCBhcHBseSBsYXlvdXQ6IE5vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/JyApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVzO1xuICAgIGlmKCBpcy5zdHJpbmcoIG9wdGlvbnMuZWxlcyApICl7XG4gICAgICBlbGVzID0gY3kuJCggb3B0aW9ucy5lbGVzICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IGN5LiQoKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dCggdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3ksXG4gICAgICBlbGVzOiBlbGVzXG4gICAgfSApICk7XG5cbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uY3JlYXRlTGF5b3V0ID0gY29yZWZuLm1ha2VMYXlvdXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZWZuID0gKHtcbiAgbm90aWZ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC5iYXRjaGluZ05vdGlmeSApe1xuICAgICAgdmFyIGJFbGVzID0gX3AuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgdmFyIGJUeXBlcyA9IF9wLmJhdGNoTm90aWZ5VHlwZXM7XG5cbiAgICAgIGlmKCBwYXJhbXMuZWxlcyApe1xuICAgICAgICBiRWxlcy5tZXJnZSggcGFyYW1zLmVsZXMgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdICl7XG4gICAgICAgIGJUeXBlcy5wdXNoKCBwYXJhbXMudHlwZSApO1xuICAgICAgICBiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICB9XG5cbiAgICBpZiggIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkICl7IHJldHVybjsgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG5cbiAgICAvLyBleGl0IGlmIGRlc3Ryb3koKSBjYWxsZWQgb24gY29yZSBvciByZW5kZXJlciBpbiBiZXR3ZWVuIGZyYW1lcyAjMTQ5OSAjMTUyOFxuICAgIGlmKCB0aGlzLmlzRGVzdHJveWVkKCkgfHwgIXJlbmRlcmVyICl7IHJldHVybjsgfVxuXG4gICAgcmVuZGVyZXIubm90aWZ5KCBwYXJhbXMgKTtcbiAgfSxcblxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBib29sID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoIGZhbHNlICk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoIHRydWUgKTtcbiAgfSxcblxuICBzdGFydEJhdGNoOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PSBudWxsICl7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PT0gMCApe1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIF9wLmJhdGNoQ291bnQtLTtcblxuICAgIGlmKCBfcC5iYXRjaENvdW50ID09PSAwICl7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBmYWxzZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBfcC5iYXRjaGluZ05vdGlmeSA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogX3AuYmF0Y2hOb3RpZnlUeXBlcyxcbiAgICAgICAgZWxlczogX3AuYmF0Y2hOb3RpZnlFbGVzXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYmF0Y2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGJhdGNoRGF0YTogZnVuY3Rpb24oIG1hcCApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5iYXRjaCggZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyggbWFwICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBbIGlkIF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuICAgICAgICBlbGUuZGF0YSggZGF0YSApO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICByZW5kZXJUbzogZnVuY3Rpb24oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgIHIucmVuZGVyVG8oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlcmVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuXG4gIGZvcmNlUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHRoaXMubm90aWZ5KCB7XG4gICAgICB0eXBlOiAnZHJhdydcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZXNpemU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5ub3RpZnkoIHtcbiAgICAgIHR5cGU6ICdyZXNpemUnXG4gICAgfSApO1xuXG4gICAgdGhpcy50cmlnZ2VyKCAncmVzaXplJyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbiggJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lICk7XG4gICAgaWYoIFJlbmRlcmVyUHJvdG8gPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvciggJ0NhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgJXNgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jywgb3B0aW9ucy5uYW1lICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJPcHRzID0gdXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3lcbiAgICB9ICk7XG5cbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKCByT3B0cyApO1xuICB9LFxuXG4gIGRlc3Ryb3lSZW5kZXJlcjogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kubm90aWZ5KCB7IHR5cGU6ICdkZXN0cm95JyB9ICk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICB2YXIgZG9tRWxlID0gY3kuY29udGFpbmVyKCk7XG4gICAgaWYoIGRvbUVsZSApe1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlKCBkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICl7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZCggZG9tRWxlLmNoaWxkTm9kZXNbMF0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG51bGw7IC8vIHRvIGJlIGV4dHJhIHNhZmUsIHJlbW92ZSB0aGUgcmVmXG4gIH0sXG5cbiAgb25SZW5kZXI6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG5cbiAgb2ZmUmVuZGVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgfVxuXG59KTtcblxuY29yZWZuLmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuLnJlc2l6ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSggJy4uL2NvbGxlY3Rpb24nICk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24oIGVsZXMsIG9wdHMgKXtcblxuICAgIGlmKCBpcy5zdHJpbmcoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBlbGVzICkgKXtcbiAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLCBlbGVzLCBvcHRzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzICk7XG4gIH0sXG5cbiAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBub2RlcyA9IHRoaXMuJCggZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzTm9kZSgpO1xuICAgIH0gKTtcblxuICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG5cbiAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlZGdlcyA9IHRoaXMuJCggZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpO1xuICAgIH0gKTtcblxuICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH0sXG5cbiAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAkOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBlbGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgfVxuICB9LFxuXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgfVxuXG59KTtcblxuLy8gYWxpYXNlc1xuY29yZWZuLmVsZW1lbnRzID0gY29yZWZuLmZpbHRlciA9IGNvcmVmbi4kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIFN0eWxlID0gcmVxdWlyZSggJy4uL3N0eWxlJyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBzdHlsZTogZnVuY3Rpb24oIG5ld1N0eWxlICl7XG4gICAgaWYoIG5ld1N0eWxlICl7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUoIG5ld1N0eWxlICk7XG5cbiAgICAgIHMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gIH0sXG5cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uKCBzdHlsZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggaXMuc3R5bGVzaGVldCggc3R5bGUgKSApe1xuICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKCB0aGlzICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCBzdHlsZSApICl7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21Kc29uKCB0aGlzLCBzdHlsZSApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoIHN0eWxlICkgKXtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbVN0cmluZyggdGhpcywgc3R5bGUgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlKCB0aGlzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wLnN0eWxlO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vd2luZG93JyApO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBhdXRvbG9jazogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdXNlclBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbjogZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMDogLy8gLnBhbigpXG4gICAgICByZXR1cm4gcGFuO1xuXG4gICAgY2FzZSAxOlxuXG4gICAgICBpZiggaXMuc3RyaW5nKCBhcmdzWzBdICkgKXsgLy8gLnBhbigneCcpXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiBwYW5bIGRpbSBdO1xuXG4gICAgICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKXsgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoIHggKSApe1xuICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoIHkgKSApe1xuICAgICAgICAgIHBhbi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB2aWV3cG9ydCcgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOiAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgaXMubnVtYmVyKCB2YWwgKSApe1xuICAgICAgICBwYW5bIGRpbSBdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoICdwYW4gdmlld3BvcnQnICk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KCB7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbkJ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMTpcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKXsgLy8gLnBhbkJ5KHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoIHggKSApe1xuICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXMubnVtYmVyKCB5ICkgKXtcbiAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCAncGFuIHZpZXdwb3J0JyApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6IC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICBpZiggKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBpcy5udW1iZXIoIHZhbCApICl7XG4gICAgICAgIHBhblsgZGltIF0gKz0gdmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoICdwYW4gdmlld3BvcnQnICk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KCB7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGZpdDogZnVuY3Rpb24oIGVsZW1lbnRzLCBwYWRkaW5nICl7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KCBlbGVtZW50cywgcGFkZGluZyApO1xuXG4gICAgaWYoIHZpZXdwb3J0U3RhdGUgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB6b29tIHZpZXdwb3J0JyApO1xuXG4gICAgICB0aGlzLm5vdGlmeSggeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICBpZiggaXMubnVtYmVyKCBlbGVtZW50cyApICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCApeyAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYoIGlzLnN0cmluZyggZWxlbWVudHMgKSApe1xuICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLiQoIHNlbCApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5ib3VuZGluZ0JveCggZWxlbWVudHMgKSApeyAvLyBhc3N1bWUgYmJcbiAgICAgIHZhciBiYmUgPSBlbGVtZW50cztcbiAgICAgIGJiID0ge1xuICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICB5MTogYmJlLnkxLFxuICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICB5MjogYmJlLnkyXG4gICAgICB9O1xuXG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gICAgfSBlbHNlIGlmKCAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlbWVudHMgKSApe1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cblxuICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcblxuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB2YXIgem9vbTtcbiAgICBwYWRkaW5nID0gaXMubnVtYmVyKCBwYWRkaW5nICkgPyBwYWRkaW5nIDogMDtcblxuICAgIGlmKCAhaXNOYU4oIHcgKSAmJiAhaXNOYU4oIGggKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oIGJiLncgKSAmJiAhaXNOYU4oIGJiLmggKSAmJiAgYmIudyA+IDAgJiYgYmIuaCA+IDAgKXtcbiAgICAgIHpvb20gPSBNYXRoLm1pbiggKHcgLSAyICogcGFkZGluZykgLyBiYi53LCAoaCAtIDIgKiBwYWRkaW5nKSAvIGJiLmggKTtcblxuICAgICAgLy8gY3JvcCB6b29tXG4gICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG5cbiAgICAgIHZhciBwYW4gPSB7IC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgIHg6ICh3IC0gem9vbSAqICggYmIueDEgKyBiYi54MiApKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqICggYmIueTEgKyBiYi55MiApKSAvIDJcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogcGFuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcblxuICBtaW5ab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIHpvb20gKSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5taW5ab29tID0gem9vbTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYXhab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1heFpvb207XG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoIHpvb20gKSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5tYXhab29tID0gem9vbTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB6b29tOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIHBvczsgLy8gaW4gcmVuZGVyZWQgcHhcbiAgICB2YXIgem9vbTtcblxuICAgIGlmKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGdldCB0aGUgem9vbVxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcblxuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCBwYXJhbXMgKSApeyAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcblxuICAgIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIHBhcmFtcyApICl7IC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICBpZiggcGFyYW1zLnBvc2l0aW9uICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgIHZhciB6ID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgICAgIHBvcyA9IHsgLy8gY29udmVydCB0byByZW5kZXJlZCBweFxuICAgICAgICAgIHg6IHAueCAqIHogKyBwYW4ueCxcbiAgICAgICAgICB5OiBwLnkgKiB6ICsgcGFuLnlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3MgJiYgIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybiB0aGlzOyAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgfVxuXG4gICAgaWYoICFpcy5udW1iZXIoIHpvb20gKSB8fCAoIHBvcyAmJiAoIWlzLm51bWJlciggcG9zLnggKSB8fCAhaXMubnVtYmVyKCBwb3MueSApKSApICl7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgfVxuXG4gICAgLy8gY3JvcCB6b29tXG4gICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgIGlmKCBwb3MgKXsgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgem9vbTEgPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB2YXIgem9vbTIgPSB6b29tO1xuXG4gICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW4yO1xuXG4gICAgICB2YXIgcG9zQ2hhbmdlZCA9IHBhbjEueCAhPT0gcGFuMi54IHx8IHBhbjEueSAhPT0gcGFuMi55O1xuICAgICAgdGhpcy50cmlnZ2VyKCAnIHpvb20gJyArIChwb3NDaGFuZ2VkID8gJyBwYW4gJyA6ICcnKSArICcgdmlld3BvcnQgJyApO1xuXG4gICAgfSBlbHNlIHsgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbSA9IHpvb207XG4gICAgICB0aGlzLnRyaWdnZXIoICd6b29tIHZpZXdwb3J0JyApO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KCB7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHZpZXdwb3J0OiBmdW5jdGlvbiggb3B0cyApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG5cbiAgICBpZiggIW9wdHMgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICBpZiggIWlzLm51bWJlciggb3B0cy56b29tICkgKXsgem9vbURlZmQgPSBmYWxzZTsgfVxuICAgIGlmKCAhaXMucGxhaW5PYmplY3QoIG9wdHMucGFuICkgKXsgcGFuRGVmZCA9IGZhbHNlOyB9XG4gICAgaWYoICF6b29tRGVmZCAmJiAhcGFuRGVmZCApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIHpvb21EZWZkICl7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgaWYoIHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCApe1xuICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auem9vbSA9IHo7XG5cbiAgICAgICAgZXZlbnRzLnB1c2goICd6b29tJyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICB2YXIgcCA9IG9wdHMucGFuO1xuXG4gICAgICBpZiggaXMubnVtYmVyKCBwLnggKSApe1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5udW1iZXIoIHAueSApICl7XG4gICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoICFwYW5GYWlsZWQgKXtcbiAgICAgICAgZXZlbnRzLnB1c2goICdwYW4nICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGV2ZW50cy5sZW5ndGggPiAwICl7XG4gICAgICBldmVudHMucHVzaCggJ3ZpZXdwb3J0JyApO1xuICAgICAgdGhpcy50cmlnZ2VyKCBldmVudHMuam9pbiggJyAnICkgKTtcblxuICAgICAgdGhpcy5ub3RpZnkoIHtcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24oIGVsZW1lbnRzICl7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKCBlbGVtZW50cyApO1xuXG4gICAgaWYoIHBhbiApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG5cbiAgICAgIHRoaXMudHJpZ2dlciggJ3BhbiB2aWV3cG9ydCcgKTtcblxuICAgICAgdGhpcy5ub3RpZnkoIHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uKCBlbGVtZW50cywgem9vbSApe1xuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBpcy5zdHJpbmcoIGVsZW1lbnRzICkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9IGVsc2UgaWYoICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBlbGVtZW50cyApICl7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG5cbiAgICB2YXIgcGFuID0geyAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSAqICggYmIueDEgKyBiYi54MiApKSAvIDIsXG4gICAgICB5OiAoaCAtIHpvb20gKiAoIGJiLnkxICsgYmIueTIgKSkgLyAyXG4gICAgfTtcblxuICAgIHJldHVybiBwYW47XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdwb3J0KCB7XG4gICAgICBwYW46IHsgeDogMCwgeTogMCB9LFxuICAgICAgem9vbTogMVxuICAgIH0gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3ByaXZhdGUuc2l6ZUNhY2hlID0gbnVsbDtcbiAgfSxcblxuICBzaXplOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IF9wLmNvbnRhaW5lcjtcblxuICAgIHJldHVybiAoIF9wLnNpemVDYWNoZSA9IF9wLnNpemVDYWNoZSB8fCAoIGNvbnRhaW5lciA/IChmdW5jdGlvbigpe1xuICAgICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggY29udGFpbmVyICk7XG4gICAgICB2YXIgdmFsID0gZnVuY3Rpb24oIG5hbWUgKXsgcmV0dXJuIHBhcnNlRmxvYXQoIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSApOyB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSAtIHZhbCgnYm9yZGVyLWxlZnQtd2lkdGgnKSAtIHZhbCgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSB2YWwoJ3BhZGRpbmctdG9wJykgLSB2YWwoJ3BhZGRpbmctYm90dG9tJykgLSB2YWwoJ2JvcmRlci10b3Atd2lkdGgnKSAtIHZhbCgnYm9yZGVyLWJvdHRvbS13aWR0aCcpXG4gICAgICB9O1xuICAgIH0pKCkgOiB7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMVxuICAgIH0gKSApO1xuICB9LFxuXG4gIHdpZHRoOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLmhlaWdodDtcbiAgfSxcblxuICBleHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcblxuICAgIHZhciBiID0ge1xuICAgICAgeDE6ICggcmIueDEgLSBwYW4ueCApIC8gem9vbSxcbiAgICAgIHgyOiAoIHJiLngyIC0gcGFuLnggKSAvIHpvb20sXG4gICAgICB5MTogKCByYi55MSAtIHBhbi55ICkgLyB6b29tLFxuICAgICAgeTI6ICggcmIueTIgLSBwYW4ueSApIC8gem9vbVxuICAgIH07XG5cbiAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICBiLmggPSBiLnkyIC0gYi55MTtcblxuICAgIHJldHVybiBiO1xuICB9LFxuXG4gIHJlbmRlcmVkRXh0ZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDI6IHdpZHRoLFxuICAgICAgeTI6IGhlaWdodCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbmNvcmVmbi5jZW50cmUgPSBjb3JlZm4uY2VudGVyO1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuY29yZWZuLmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4uYXV0b2xvY2s7XG5jb3JlZm4uYXV0b3VuZ3JhYmlmeU5vZGVzID0gY29yZWZuLmF1dG91bmdyYWJpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbi8vICh1c2VmdWwgZm9yIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiB0aGUgY29yZSBhbmQgY29sbGVjdGlvbnMsIGZvciBleGFtcGxlKVxuXG4vLyBlLmcuXG4vLyB2YXIgZm9vID0gZGVmaW5lLmZvbyh7IC8qIHBhcmFtcy4uLiAqLyB9KVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi9pcycgKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoICcuL3NlbGVjdG9yJyApO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCAnLi9wcm9taXNlJyApO1xudmFyIEV2ZW50ID0gcmVxdWlyZSggJy4vZXZlbnQnICk7XG52YXIgQW5pbWF0aW9uID0gcmVxdWlyZSggJy4vYW5pbWF0aW9uJyApO1xuXG52YXIgZGVmaW5lID0ge1xuXG4gIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gIGRhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9LCAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiggc2VsZiApe30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7IHJldHVybiB0cnVlOyB9XG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBkYXRhSW1wbCggbmFtZSwgdmFsdWUgKXtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgIGlmKCBpcy5zdHJpbmcoIG5hbWUgKSApeyAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycpXG4gICAgICAgIGlmKCBwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldFxuXG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiggc2luZ2xlICl7XG4gICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbIHAuZmllbGQgXVsgbmFtZSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7IC8vIHNldFxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIG5hbWUgXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFsgaSBdICkgKXtcbiAgICAgICAgICAgICAgICBhbGxbIGkgXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgICAgaWYoIHAudXBkYXRlU3R5bGUgKXsgc2VsZi51cGRhdGVTdHlsZSgpOyB9XG5cbiAgICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICAgICAgaWYoIHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQgKXtcbiAgICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG4gICAgICB9IGVsc2UgaWYoIHAuYWxsb3dTZXR0aW5nICYmIGlzLnBsYWluT2JqZWN0KCBuYW1lICkgKXsgLy8gZXh0ZW5kXG4gICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICB2YXIgaywgdjtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggb2JqICk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgayA9IGtleXNbIGkgXTtcbiAgICAgICAgICB2ID0gb2JqWyBrIF07XG5cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzWyBrIF07XG4gICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICB2YXIgZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgIGlmKCBwLmNhblNldCggZWxlICkgKXtcbiAgICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbIHAuZmllbGQgXVsgayBdID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgIGlmKCBwLnVwZGF0ZVN0eWxlICl7IHNlbGYudXBkYXRlU3R5bGUoKTsgfVxuXG4gICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgIGlmKCBwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgIH1cblxuICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICB9IGVsc2UgaWYoIHAuYWxsb3dCaW5kaW5nICYmIGlzLmZuKCBuYW1lICkgKXsgLy8gYmluZCB0byBldmVudFxuICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICBzZWxmLm9uKCBwLmJpbmRpbmdFdmVudCwgZm4gKTtcblxuICAgICAgLy8gLmRhdGEoKVxuICAgICAgfSBlbHNlIGlmKCBwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiggc2luZ2xlICl7XG4gICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIGRhdGFcblxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbCggbmFtZXMgKXtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgaWYoIGlzLnN0cmluZyggbmFtZXMgKSApeyAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCggL1xccysvICk7XG4gICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXsgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzWyBpIF07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKCBrZXkgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1sga2V5IF07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKysgKXtcbiAgICAgICAgICAgICAgYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcC50cmlnZ2VyRXZlbnQgKXtcbiAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICB9XG5cbiAgICAgIC8vIC5yZW1vdmVEYXRhKClcbiAgICAgIH0gZWxzZSBpZiggbmFtZXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuXG4gICAgICAgIGZvciggdmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKysgKXtcbiAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggX3ByaXZhdGVGaWVsZHMgKTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICBpZiggdmFsaWRLZXlUb0RlbGV0ZSApe1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1sga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyByZW1vdmVEYXRhXG5cbiAgLy8gZXZlbnQgZnVuY3Rpb24gcmV1c2FibGUgc3R1ZmZcbiAgZXZlbnQ6IHtcbiAgICByZWdleDogLyhcXHcrKShcXC4oPzpcXHcrfFxcKikpPy8sIC8vIHJlZ2V4IGZvciBtYXRjaGluZyBldmVudCBzdHJpbmdzIChlLmcuIFwiY2xpY2submFtZXNwYWNlXCIpXG4gICAgdW5pdmVyc2FsTmFtZXNwYWNlOiAnLionLCAvLyBtYXRjaGVzIGFzIGlmIG5vIG5hbWVzcGFjZSBzcGVjaWZpZWQgYW5kIHByZXZlbnRzIHVzZXJzIGZyb20gdW5iaW5kaW5nIGFjY2lkZW50YWxseVxuICAgIG9wdGlvbmFsVHlwZVJlZ2V4OiAvKFxcdyspPyhcXC4oPzpcXHcrfFxcKikpPy8sXG4gICAgZmFsc2VDYWxsYmFjazogZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9XG4gIH0sXG5cbiAgLy8gZXZlbnQgYmluZGluZ1xuICBvbjogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IGZhbHNlLFxuICAgICAgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogZmFsc2VcbiAgICB9O1xuICAgIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uSW1wbCggZXZlbnRzLCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2sgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSBpcy5zdHJpbmcoIGV2ZW50cyApO1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCggc2VsZWN0b3IgKSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBkYXRhXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiggaXMuZm4oIHNlbGVjdG9yICkgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggaXMuZm4oIGRhdGEgKSB8fCBkYXRhID09PSBmYWxzZSApeyAvLyBkYXRhIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXNuJ3QgYSBjYWxsYmFjaywgd2UgY2FuJ3QgcmVhbGx5IGRvIGFueXRoaW5nXG4gICAgICAvLyAoY2FuJ3Qgc3BlYWsgZm9yIG1hcHBlZCBldmVudHMgYXJnIHZlcnNpb24pXG4gICAgICBpZiggIShpcy5mbiggY2FsbGJhY2sgKSB8fCBjYWxsYmFjayA9PT0gZmFsc2UpICYmIGV2ZW50c0lzU3RyaW5nICl7XG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBldmVudHMgKTtcblxuICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrICl7XG4gICAgICAgIHZhciBldnRzID0ga2V5c1trXTtcblxuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1sgZXZ0cyBdO1xuICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhaXMuZm4oIGNhbGxiYWNrICkgKXsgY29udGludWU7IH1cblxuICAgICAgICBldnRzID0gZXZ0cy5zcGxpdCggL1xccysvICk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzWyBpIF07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKCBldnQgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCBkZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLCAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgICAgICAgZGF0YTogZGF0YSwgLy8gZXh0cmEgZGF0YSBpbiBldmVudE9iai5kYXRhXG4gICAgICAgICAgICAgIGRlbGVnYXRlZDogc2VsZWN0b3IgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGV2dCBpcyBkZWxlZ2F0ZWRcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLCAvLyB0aGUgc2VsZWN0b3IgdG8gbWF0Y2ggZm9yIGRlbGVnYXRlZCBldmVudHNcbiAgICAgICAgICAgICAgc2VsT2JqOiBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yICksIC8vIGNhY2hlZCBzZWxlY3RvciBvYmplY3QgdG8gc2F2ZSByZWJ1aWxkaW5nXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBwLnVuYmluZFNlbGZPblRyaWdnZXIsXG4gICAgICAgICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHAudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcixcbiAgICAgICAgICAgICAgYmluZGVyczogYWxsIC8vIHdobyBib3VuZCB0b2dldGhlclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIF9wID0gYWxsWyBqIF0uX3ByaXZhdGUgPSBhbGxbIGogXS5fcHJpdmF0ZSB8fCB7fTtcblxuICAgICAgICAgICAgICBfcC5saXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgICAgIF9wLmxpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgZXZlbnRzIGFycmF5XG4gICAgICB9IC8vIGZvciBldmVudHMgbWFwXG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIG9uXG5cbiAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uKCBwcm90byApe1xuICAgIHZhciBwID0gcHJvdG87XG5cbiAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgIHAucmVtb3ZlTGlzdGVuZXIgPSBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZjtcbiAgICBwLmVtaXQgPSBwLnRyaWdnZXI7XG5cbiAgICAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG4gICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uKCBldmVudHMsIHNlbGVjdG9yICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICAgICAgc2VsZi5vZmYuYXBwbHkoIHNlbGYsIG9mZkFyZ3MgKTtcblxuICAgICAgICAgIHJlc29sdmUoIGUgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoIFsgY2FsbGJhY2sgXSApO1xuICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoIFtdICk7XG5cbiAgICAgICAgc2VsZi5vbi5hcHBseSggc2VsZiwgb25BcmdzICk7XG4gICAgICB9ICk7XG4gICAgfTtcbiAgfSxcblxuICBvZmY6IGZ1bmN0aW9uIG9mZkltcGwoIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICB9O1xuICAgIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIHBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjayApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBldmVudHNJc1N0cmluZyA9IGlzLnN0cmluZyggZXZlbnRzICk7XG5cbiAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICl7IC8vIHRoZW4gdW5iaW5kIGFsbFxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgYWxsWyBpIF0uX3ByaXZhdGUgPSBhbGxbIGkgXS5fcHJpdmF0ZSB8fCB7fTtcblxuICAgICAgICAgIF9wLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5mbiggc2VsZWN0b3IgKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIGNvbnZlcnQgdG8gbWFwXG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICBldmVudHMgPSBtYXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGV2ZW50cyApO1xuXG4gICAgICBmb3IoIHZhciBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgdmFyIGV2dHMgPSBrZXlzW2tdO1xuXG4gICAgICAgIGNhbGxiYWNrID0gZXZlbnRzWyBldnRzIF07XG5cbiAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBldnRzID0gZXZ0cy5zcGxpdCggL1xccysvICk7XG4gICAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgZXZ0cy5sZW5ndGg7IGgrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzWyBoIF07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKCBldnQgKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCBkZWZpbmUuZXZlbnQub3B0aW9uYWxUeXBlUmVnZXggKTsgLy8gW3R5cGVdWy5uYW1lc3BhY2VdXG4gICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXsgLy9cbiAgICAgICAgICAgICAgdmFyIF9wID0gYWxsWyBpIF0uX3ByaXZhdGUgPSBhbGxbIGkgXS5fcHJpdmF0ZSB8fCB7fTtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyB8fCBbXTtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxpc3RlbmVycy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1sgaiBdO1xuICAgICAgICAgICAgICAgIHZhciBuc01hdGNoZXMgPSAhbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gbGlzdGVuZXIubmFtZXNwYWNlO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9ICF0eXBlIHx8IGxpc3RlbmVyLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGNiTWF0Y2hlcyA9ICFjYWxsYmFjayB8fCBjYWxsYmFjayA9PT0gbGlzdGVuZXIuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiBjYk1hdGNoZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgbGlzdGVuZXIgaWYgaXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXtcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoIGosIDEgKTtcbiAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZm9yIGxpc3RlbmVyc1xuICAgICAgICAgICAgfSAvLyBmb3IgYWxsXG4gICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcblxuICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBvZmZcblxuICB0cmlnZ2VyOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgcGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdHJpZ2dlckltcGwoIGV2ZW50cywgZXh0cmFQYXJhbXMsIGZuVG9UcmlnZ2VyICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKCBldmVudHMgKTtcbiAgICAgIHZhciBldmVudHNJc09iamVjdCA9IGlzLnBsYWluT2JqZWN0KCBldmVudHMgKTtcbiAgICAgIHZhciBldmVudHNJc0V2ZW50ID0gaXMuZXZlbnQoIGV2ZW50cyApO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHRoaXMuX3ByaXZhdGUgfHwge307XG4gICAgICB2YXIgY3kgPSBfcC5jeSB8fCAoIGlzLmNvcmUoIHRoaXMgKSA/IHRoaXMgOiBudWxsICk7XG4gICAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kgPyBjeS5oYXNDb21wb3VuZE5vZGVzKCkgOiBmYWxzZTtcblxuICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gbWFrZSBhIHBsYWluIGV2ZW50IG9iamVjdCBmb3IgZWFjaCBldmVudCBuYW1lXG4gICAgICAgIHZhciBldnRzID0gZXZlbnRzLnNwbGl0KCAvXFxzKy8gKTtcbiAgICAgICAgZXZlbnRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGV2dCA9IGV2dHNbIGkgXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoIGV2dCApICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG4gICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGV2ZW50cy5wdXNoKCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiggZXZlbnRzSXNPYmplY3QgKXsgLy8gcHV0IGluIGxlbmd0aCAxIGFycmF5XG4gICAgICAgIHZhciBldmVudEFyZ09iaiA9IGV2ZW50cztcblxuICAgICAgICBldmVudHMgPSBbIGV2ZW50QXJnT2JqIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCBleHRyYVBhcmFtcyApe1xuICAgICAgICBpZiggIWlzLmFycmF5KCBleHRyYVBhcmFtcyApICl7IC8vIG1ha2Ugc3VyZSBleHRyYSBwYXJhbXMgYXJlIGluIGFuIGFycmF5IGlmIHNwZWNpZmllZFxuICAgICAgICAgIGV4dHJhUGFyYW1zID0gWyBleHRyYVBhcmFtcyBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIHdlJ3ZlIGdvdCBub3RoaW5nXG4gICAgICAgIGV4dHJhUGFyYW1zID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrICl7IC8vIHRyaWdnZXIgZWFjaCBldmVudCBpbiBvcmRlclxuICAgICAgICB2YXIgZXZ0T2JqID0gZXZlbnRzWyBpIF07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVyID0gYWxsWyBqIF07XG4gICAgICAgICAgdmFyIF9wID0gdHJpZ2dlcmVyLl9wcml2YXRlID0gdHJpZ2dlcmVyLl9wcml2YXRlIHx8IHt9O1xuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgdmFyIHRyaWdnZXJlcklzRWxlbWVudCA9IGlzLmVsZW1lbnQoIHRyaWdnZXJlciApO1xuICAgICAgICAgIHZhciBidWJibGVVcCA9IHRyaWdnZXJlcklzRWxlbWVudCB8fCBwYXJhbXMubGF5b3V0O1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBldmVudCBmb3IgdGhpcyBlbGVtZW50IGZyb20gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICAgIHZhciBldnQ7XG5cbiAgICAgICAgICBpZiggZXZlbnRzSXNFdmVudCApeyAvLyB0aGVuIGp1c3QgZ2V0IHRoZSBvYmplY3RcbiAgICAgICAgICAgIGV2dCA9IGV2dE9iajtcblxuICAgICAgICAgICAgZXZ0LmN5VGFyZ2V0ID0gZXZ0LmN5VGFyZ2V0IHx8IHRyaWdnZXJlcjtcbiAgICAgICAgICAgIGV2dC5jeSA9IGV2dC5jeSB8fCBjeTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gd2UgaGF2ZSB0byBtYWtlIG9uZVxuICAgICAgICAgICAgZXZ0ID0gbmV3IEV2ZW50KCBldnRPYmosIHtcbiAgICAgICAgICAgICAgY3lUYXJnZXQ6IHRyaWdnZXJlcixcbiAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBhIGxheW91dCB3YXMgc3BlY2lmaWVkLCB0aGVuIHB1dCBpdCBpbiB0aGUgdHlwZWQgZXZlbnRcbiAgICAgICAgICBpZiggZXZ0T2JqLmxheW91dCApe1xuICAgICAgICAgICAgZXZ0LmxheW91dCA9IGV2dE9iai5sYXlvdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdHJpZ2dlcmVkIGJ5IGxheW91dCwgcHV0IGluIGV2ZW50XG4gICAgICAgICAgaWYoIHBhcmFtcy5sYXlvdXQgKXtcbiAgICAgICAgICAgIGV2dC5sYXlvdXQgPSB0cmlnZ2VyZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgIGlmKCBldnQuY3lQb3NpdGlvbiApe1xuICAgICAgICAgICAgdmFyIHBvcyA9IGV2dC5jeVBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAgIGV2dC5jeVJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZm5Ub1RyaWdnZXIgKXsgLy8gdGhlbiBvdmVycmlkZSB0aGUgbGlzdGVuZXJzIGxpc3Qgd2l0aCBqdXN0IHRoZSBvbmUgd2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbIHtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldnQubmFtZXNwYWNlLFxuICAgICAgICAgICAgICB0eXBlOiBldnQudHlwZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IGZuVG9UcmlnZ2VyXG4gICAgICAgICAgICB9IF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBsaXN0ZW5lcnMubGVuZ3RoOyBrKysgKXsgLy8gY2hlY2sgZWFjaCBsaXN0ZW5lclxuICAgICAgICAgICAgdmFyIGxpcyA9IGxpc3RlbmVyc1sgayBdO1xuICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFsaXMubmFtZXNwYWNlIHx8IGxpcy5uYW1lc3BhY2UgPT09IGV2dC5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZGVmaW5lLmV2ZW50LnVuaXZlcnNhbE5hbWVzcGFjZTtcbiAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9IGxpcy50eXBlID09PSBldnQudHlwZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXRjaGVzID0gbGlzLmRlbGVnYXRlZCA/ICggdHJpZ2dlcmVyICE9PSBldnQuY3lUYXJnZXQgJiYgaXMuZWxlbWVudCggZXZ0LmN5VGFyZ2V0ICkgJiYgbGlzLnNlbE9iai5tYXRjaGVzKCBldnQuY3lUYXJnZXQgKSApIDogKHRydWUpOyAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gdmFsaWRhdGUgdGhlIGhpZXJhcmNoeTsgdGhhdCdzIHRvbyBleHBlbnNpdmVcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgdGFyZ2V0TWF0Y2hlcztcblxuICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApeyAvLyB0aGVuIHRyaWdnZXIgaXRcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbIGV2dCBdO1xuICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoIGV4dHJhUGFyYW1zICk7IC8vIGFkZCBleHRyYSBwYXJhbXMgdG8gYXJncyBsaXN0XG5cbiAgICAgICAgICAgICAgaWYoIGxpcy5kYXRhICl7IC8vIGFkZCBvbiBkYXRhIHBsdWdnZWQgaW50byBiaW5kaW5nXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBsaXMuZGF0YTtcbiAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3IgY2xlYXIgaXQgaW4gY2FzZSB0aGUgZXZlbnQgb2JqIGlzIHJldXNlZFxuICAgICAgICAgICAgICAgIGV2dC5kYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIGxpcy51bmJpbmRTZWxmT25UcmlnZ2VyIHx8IGxpcy51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyICl7IC8vIHRoZW4gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZSggaywgMSApO1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIGRlbGV0ZSB0aGUgbGlzdGVuZXIgZm9yIGFsbCBiaW5kZXJzXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRlcnMgPSBsaXMuYmluZGVycztcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGJpbmRlcnMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXIgPSBiaW5kZXJzWyBsIF07XG4gICAgICAgICAgICAgICAgICBpZiggIWJpbmRlciB8fCBiaW5kZXIgPT09IHRyaWdnZXJlciApeyBjb250aW51ZTsgfSAvLyBhbHJlYWR5IGhhbmRsZWQgdHJpZ2dlcmVyIG9yIHdlIGNhbid0IGhhbmRsZSBpdFxuXG4gICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXJzID0gYmluZGVyLl9wcml2YXRlLmxpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgIGZvciggdmFyIG0gPSAwOyBtIDwgYmluZGVyTGlzdGVuZXJzLmxlbmd0aDsgbSsrICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJMaXN0ZW5lciA9IGJpbmRlckxpc3RlbmVyc1sgbSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBiaW5kZXJMaXN0ZW5lciA9PT0gbGlzICl7IC8vIGRlbGV0ZSBsaXN0ZW5lciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICBiaW5kZXJMaXN0ZW5lcnMuc3BsaWNlKCBtLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGxpcy5kZWxlZ2F0ZWQgPyBldnQuY3lUYXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSB8fCBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApe1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgaWYoIGJ1YmJsZVVwICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApeyAvLyB0aGVuIGJ1YmJsZSB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlciggZXZ0ICk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGJ1YmJsZSB1cCB0byB0aGUgY29yZVxuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBldnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBmb3IgZWFjaCBvZiBhbGxcbiAgICAgIH0gLy8gZm9yIGVhY2ggZXZlbnRcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gdHJpZ2dlclxuXG4gIGFuaW1hdGVkOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBhbmltYXRlZFxuXG4gIGNsZWFyUXVldWU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgZm5QYXJhbXMgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsWyBpIF07XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSwgLy8gY2xlYXJRdWV1ZVxuXG4gIGRlbGF5OiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0gKTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbigge1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSApO1xuICAgIH07XG4gIH0sIC8vIGRlbGF5XG5cbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogWyBzZWxmIF07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgICBwcm9wZXJ0aWVzID0gdXRpbC5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMgKTtcblxuICAgICAgaWYoIHByb3BlcnRpZXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNDAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2goIHByb3BlcnRpZXMuZHVyYXRpb24gKXtcbiAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BlcnRpZXNFbXB0eSA9IE9iamVjdC5rZXlzKCBwcm9wZXJ0aWVzICkubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiggcHJvcGVydGllc0VtcHR5ICl7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCBhbGxbMF0sIHByb3BlcnRpZXMgKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICB9XG5cbiAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdCggcHJvcGVydGllcy5zdHlsZSB8fCBwcm9wZXJ0aWVzLmNzcyApO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY3NzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICYmIGlzRWxlcyApe1xuICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvIHpvb20sXG4gICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC8gem9vbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICBpZiggcHJvcGVydGllcy5wYW5CeSAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcbiAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcbiAgICAgIGlmKCBjZW50ZXIgJiYgaXNDb3JlICl7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oIGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20gKTtcblxuICAgICAgICBpZiggY2VudGVyUGFuICl7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG4gICAgICBpZiggcHJvcGVydGllcy5maXQgJiYgaXNDb3JlICl7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoIGZpdC5lbGVzIHx8IGZpdC5ib3VuZGluZ0JveCwgZml0LnBhZGRpbmcgKTtcblxuICAgICAgICBpZiggZml0VnAgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKCBhbGxbMF0sIHByb3BlcnRpZXMgKTtcbiAgICB9O1xuICB9LCAvLyBhbmltYXRlXG5cbiAgYW5pbWF0ZTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBmblBhcmFtcyApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbIHNlbGYgXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgaWYoIHBhcmFtcyApe1xuICAgICAgICBwcm9wZXJ0aWVzID0gdXRpbC5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMgKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbIGkgXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcblxuICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbiggcHJvcGVydGllcywgKHF1ZXVlID8geyBxdWV1ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKSApO1xuXG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH07XG4gIH0sIC8vIGFuaW1hdGVcblxuICBzdG9wOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIGZuUGFyYW1zICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoIGNsZWFyUXVldWUsIGp1bXBUb0VuZCApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFsgc2VsZiBdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsWyBpIF07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgYW5pID0gYW5pc1sgaiBdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmKCBjbGVhclF1ZXVlICl7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoIHtcbiAgICAgICAgZWxlczogdGhpcyxcbiAgICAgICAgdHlwZTogJ2RyYXcnXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0gLy8gc3RvcFxuXG59OyAvLyBkZWZpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKXtcbiAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBFdmVudCkgKXtcbiAgICByZXR1cm4gbmV3IEV2ZW50KCBzcmMsIHByb3BzICk7XG4gIH1cblxuICAvLyBFdmVudCBvYmplY3RcbiAgaWYoIHNyYyAmJiBzcmMudHlwZSApe1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoIHNyYy5kZWZhdWx0UHJldmVudGVkICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cbiAgLy8gRXZlbnQgdHlwZVxuICB9IGVsc2Uge1xuICAgIHRoaXMudHlwZSA9IHNyYztcbiAgfVxuXG4gIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gIGlmKCBwcm9wcyApe1xuICAgIC8vIHV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPT0gdW5kZWZpbmVkID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgdGhpcy5jeVRhcmdldCA9IHByb3BzLmN5VGFyZ2V0O1xuICAgIHRoaXMuY3lQb3NpdGlvbiA9IHByb3BzLmN5UG9zaXRpb247XG4gICAgdGhpcy5jeVJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5jeVJlbmRlcmVkUG9zaXRpb247XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBwcm9wcy5tZXNzYWdlO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKXtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCl7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICdldmVudCc7XG4gIH0sXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYoICFlICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiggZS5wcmV2ZW50RGVmYXVsdCApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiggIWUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiggZS5zdG9wUHJvcGFnYXRpb24gKXtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKXtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSggJy4vZGVmaW5lJyApO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCAnLi9jb2xsZWN0aW9uJyApO1xudmFyIENvcmUgPSByZXF1aXJlKCAnLi9jb3JlJyApO1xudmFyIGluY0V4dHMgPSByZXF1aXJlKCAnLi9leHRlbnNpb25zJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG5cbi8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxudmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuLy8gcmVnaXN0ZXJlZCBtb2R1bGVzIGZvciBleHRlbnNpb25zLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBtb2R1bGVzID0ge307XG5cbmZ1bmN0aW9uIHNldEV4dGVuc2lvbiggdHlwZSwgbmFtZSwgcmVnaXN0cmFudCApe1xuXG4gIHZhciBleHQgPSByZWdpc3RyYW50O1xuXG4gIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgIHV0aWwuZXJyb3IoICdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyApO1xuICB9O1xuXG4gIGlmKCB0eXBlID09PSAnY29yZScgKXtcbiAgICBpZiggQ29yZS5wcm90b3R5cGVbIG5hbWUgXSApe1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKCBuYW1lICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvcmUucHJvdG90eXBlWyBuYW1lIF0gPSByZWdpc3RyYW50O1xuICAgIH1cblxuICB9IGVsc2UgaWYoIHR5cGUgPT09ICdjb2xsZWN0aW9uJyApe1xuICAgIGlmKCBDb2xsZWN0aW9uLnByb3RvdHlwZVsgbmFtZSBdICl7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIoIG5hbWUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbIG5hbWUgXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiggdHlwZSA9PT0gJ2xheW91dCcgKXtcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG5cbiAgICB2YXIgTGF5b3V0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmKCAhaXMucGxhaW5PYmplY3QoIHRoaXMuX3ByaXZhdGUgKSApe1xuICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIHJlZ2lzdHJhbnQucHJvdG90eXBlICk7XG5cbiAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1sgaSBdO1xuXG4gICAgICBsYXlvdXRQcm90b1sgZm5OYW1lIF0gPSBsYXlvdXRQcm90b1sgZm5OYW1lIF0gfHwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG4gICAgfVxuXG4gICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgIGlmKCBsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICBsYXlvdXRQcm90by5ydW4gPSBmdW5jdGlvbigpeyB0aGlzLnN0YXJ0KCk7IHJldHVybiB0aGlzOyB9O1xuICAgIH0gZWxzZSBpZiggIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1biApe1xuICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbigpeyB0aGlzLnJ1bigpOyByZXR1cm4gdGhpczsgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVnU3RvcCA9IHJlZ2lzdHJhbnQucHJvdG90eXBlLnN0b3A7XG4gICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYoIG9wdHMgJiYgb3B0cy5hbmltYXRlICl7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgIGlmKCBhbmlzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbmlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBhbmlzWyBpIF0uc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggcmVnU3RvcCApe1xuICAgICAgICByZWdTdG9wLmNhbGwoIHRoaXMgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlciggJ2xheW91dHN0b3AnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBpZiggIWxheW91dFByb3RvLmRlc3Ryb3kgKXtcbiAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGF5b3V0UHJvdG8ub24gPSBkZWZpbmUub24oIHsgbGF5b3V0OiB0cnVlIH0gKTtcbiAgICBsYXlvdXRQcm90by5vbmUgPSBkZWZpbmUub24oIHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0gKTtcbiAgICBsYXlvdXRQcm90by5vbmNlID0gZGVmaW5lLm9uKCB7IGxheW91dDogdHJ1ZSwgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9ICk7XG4gICAgbGF5b3V0UHJvdG8ub2ZmID0gZGVmaW5lLm9mZiggeyBsYXlvdXQ6IHRydWUgfSApO1xuICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSBkZWZpbmUudHJpZ2dlciggeyBsYXlvdXQ6IHRydWUgfSApO1xuXG4gICAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBsYXlvdXRQcm90byApO1xuXG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG5cbiAgfSBlbHNlIGlmKCB0eXBlID09PSAncmVuZGVyZXInICYmIG5hbWUgIT09ICdudWxsJyAmJiBuYW1lICE9PSAnYmFzZScgKXtcbiAgICAvLyB1c2VyIHJlZ2lzdGVyZWQgcmVuZGVyZXJzIGluaGVyaXQgZnJvbSBiYXNlXG5cbiAgICB2YXIgQmFzZVJlbmRlcmVyID0gZ2V0RXh0ZW5zaW9uKCAncmVuZGVyZXInLCAnYmFzZScgKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbigpe1xuICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgIFJlZ2lzdHJhbnRSZW5kZXJlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIGZvciggdmFyIHBOYW1lIGluIGJQcm90byApe1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bIHBOYW1lIF07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvWyBwTmFtZSBdICE9IG51bGw7XG5cbiAgICAgIGlmKCBleGlzdHNJblIgKXtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKCBwTmFtZSApO1xuICAgICAgfVxuXG4gICAgICBwcm90b1sgcE5hbWUgXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG5cbiAgICBmb3IoIHZhciBwTmFtZSBpbiByUHJvdG8gKXtcbiAgICAgIHByb3RvWyBwTmFtZSBdID0gclByb3RvWyBwTmFtZSBdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiggbmFtZSApe1xuICAgICAgcHJvdG9bIG5hbWUgXSA9IHByb3RvWyBuYW1lIF0gfHwgZnVuY3Rpb24oKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnICk7XG4gICAgICB9O1xuICAgIH0gKTtcblxuICAgIGV4dCA9IFJlbmRlcmVyO1xuXG4gIH1cblxuICByZXR1cm4gdXRpbC5zZXRNYXAoIHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF0sXG4gICAgdmFsdWU6IGV4dFxuICB9ICk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbiggdHlwZSwgbmFtZSApe1xuICByZXR1cm4gdXRpbC5nZXRNYXAoIHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgfSApO1xufVxuXG5mdW5jdGlvbiBzZXRNb2R1bGUoIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQgKXtcbiAgcmV0dXJuIHV0aWwuc2V0TWFwKCB7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSBdLFxuICAgIHZhbHVlOiByZWdpc3RyYW50XG4gIH0gKTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlKCB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lICl7XG4gIHJldHVybiB1dGlsLmdldE1hcCgge1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXVxuICB9ICk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKXtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICl7XG4gICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gNCApe1xuICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDUgKXtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIHV0aWwuZXJyb3IoICdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4JyApO1xuICB9XG5cbn07XG5cbi8vIGFsbG93cyBhIGNvcmUgaW5zdGFuY2UgdG8gYWNjZXNzIGV4dGVuc2lvbnMgaW50ZXJuYWxseVxuQ29yZS5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuXG4vLyBpbmNsdWRlZCBleHRlbnNpb25zXG5pbmNFeHRzLmZvckVhY2goIGZ1bmN0aW9uKCBncm91cCApe1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBleHQgKXtcbiAgICBzZXRFeHRlbnNpb24oIGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCApO1xuICB9ICk7XG59ICk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5zaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHR5cGU6ICdsYXlvdXQnLFxuICAgIGV4dGVuc2lvbnM6IHJlcXVpcmUoICcuL2xheW91dCcgKVxuICB9LFxuXG4gIHtcbiAgICB0eXBlOiAncmVuZGVyZXInLFxuICAgIGV4dGVuc2lvbnM6IHJlcXVpcmUoICcuL3JlbmRlcmVyJyApXG4gIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uL2lzJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5CcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgcm9vdHM7XG4gIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBvcHRpb25zLnJvb3RzICkgKXtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiggaXMuYXJyYXkoIG9wdGlvbnMucm9vdHMgKSApe1xuICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbIGkgXTtcbiAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgIHJvb3RzQXJyYXkucHVzaCggZWxlICk7XG4gICAgfVxuXG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCByb290c0FycmF5ICk7XG4gIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBvcHRpb25zLnJvb3RzICkgKXtcbiAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICB9IGVsc2Uge1xuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICl7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgdmFyIGN1cnJDb21wID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIGVsZXMuYmZzKCB7XG4gICAgICAgICAgcm9vdHM6IHVuaGFuZGxlZE5vZGVzWzBdLFxuICAgICAgICAgIHZpc2l0OiBmdW5jdGlvbiggaSwgZGVwdGgsIG5vZGUsIGVkZ2UsIHBOb2RlICl7XG4gICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0gKTtcblxuICAgICAgICB1bmhhbmRsZWROb2RlcyA9IHVuaGFuZGxlZE5vZGVzLm5vdCggY3VyckNvbXAgKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKCBjdXJyQ29tcCApO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbIGkgXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVncmVlKCBmYWxzZSApID09PSBtYXhEZWdyZWU7XG4gICAgICAgIH0gKTtcblxuICAgICAgICByb290cyA9IHJvb3RzLmFkZCggY29tcFJvb3RzICk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuXG4gIHZhciBkZXB0aHMgPSBbXTtcbiAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcbiAgdmFyIGlkMmRlcHRoID0ge307XG4gIHZhciBwcmV2Tm9kZSA9IHt9O1xuICB2YXIgcHJldkVkZ2UgPSB7fTtcbiAgdmFyIHN1Y2Nlc3NvcnMgPSB7fTtcblxuICAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG4gIGdyYXBoLmJmcygge1xuICAgIHJvb3RzOiByb290cyxcbiAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICB2aXNpdDogZnVuY3Rpb24oIGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgaWYoICFkZXB0aHNbIGRlcHRoIF0gKXtcbiAgICAgICAgZGVwdGhzWyBkZXB0aCBdID0gW107XG4gICAgICB9XG5cbiAgICAgIGRlcHRoc1sgZGVwdGggXS5wdXNoKCBlbGUgKTtcbiAgICAgIGZvdW5kQnlCZnNbIGlkIF0gPSB0cnVlO1xuICAgICAgaWQyZGVwdGhbIGlkIF0gPSBkZXB0aDtcbiAgICAgIHByZXZOb2RlWyBpZCBdID0gcE5vZGU7XG4gICAgICBwcmV2RWRnZVsgaWQgXSA9IGVkZ2U7XG5cbiAgICAgIGlmKCBwTm9kZSApe1xuICAgICAgICB2YXIgcHJldklkID0gcE5vZGUuaWQoKTtcbiAgICAgICAgdmFyIHN1Y2MgPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdIHx8IFtdO1xuXG4gICAgICAgIHN1Y2MucHVzaCggbm9kZSApO1xuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG4gIC8vIGNoZWNrIGZvciBub2RlcyBub3QgZm91bmQgYnkgYmZzXG4gIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IG5vZGVzWyBpIF07XG5cbiAgICBpZiggZm91bmRCeUJmc1sgZWxlLmlkKCkgXSApe1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ycGhhbk5vZGVzLnB1c2goIGVsZSApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgYSBkZXB0aCBmcm9tIHRoZWlyIG5laWdoYm9yaG9vZFxuICB2YXIgbWF4Q2hlY2tzID0gb3JwaGFuTm9kZXMubGVuZ3RoICogMztcbiAgdmFyIGNoZWNrcyA9IDA7XG4gIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgJiYgY2hlY2tzIDwgbWF4Q2hlY2tzICl7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIHZhciBuZWlnaGJvcnMgPSBub2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCk7XG4gICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgbmVpZ2hib3JzWyBpIF0uaWQoKSBdO1xuXG4gICAgICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBkZXB0aHNbIGRlcHRoIF0ucHVzaCggbm9kZSApO1xuICAgICAgICBhc3NpZ25lZERlcHRoID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoICFhc3NpZ25lZERlcHRoICl7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgY2hlY2tzKys7XG4gIH1cblxuICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRoYXQgYXJlIHN0aWxsIGxlZnQgdG8gdGhlIGRlcHRoIG9mIHRoZWlyIHN1YmdyYXBoXG4gIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgKXtcbiAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgLy92YXIgc3ViZ3JhcGggPSBncmFwaC5iZnMoIG5vZGUgKS5wYXRoO1xuICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAvLyBmb3IoIHZhciBpID0gMDsgaSA8IHN1YmdyYXBoLmxlbmd0aDsgaSsrICl7XG4gICAgLy8gICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgc3ViZ3JhcGhbaV0uaWQoKSBdO1xuXG4gICAgLy8gICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgIC8vICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAvLyAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgLy8gICAgIGJyZWFrO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIGlmKCAhYXNzaWduZWREZXB0aCApeyAvLyB3b3JzdCBjYXNlIGlmIHRoZSBncmFwaCByZWFsbHkgaXNuJ3QgdHJlZSBmcmllbmRseSwgdGhlbiBqdXN0IGR1bXAgaXQgaW4gMFxuICAgICAgaWYoIGRlcHRocy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgZGVwdGhzLnB1c2goIFtdICk7XG4gICAgICB9XG5cbiAgICAgIGRlcHRoc1swXS5wdXNoKCBub2RlICk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuICB2YXIgYXNzaWduRGVwdGhzVG9FbGVzID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZXMgPSBkZXB0aHNbIGkgXTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzWyBqIF07XG5cbiAgICAgICAgZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0ID0ge1xuICAgICAgICAgIGRlcHRoOiBpLFxuICAgICAgICAgIGluZGV4OiBqXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcblxuXG4gIHZhciBpbnRlcnNlY3RzRGVwdGggPSBmdW5jdGlvbiggbm9kZSApeyAvLyByZXR1cm5zIHRydWUgaWYgaGFzIGVkZ2VzIHBvaW50aW5nIGluIGZyb20gYSBoaWdoZXIgZGVwdGhcbiAgICB2YXIgZWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YSggJ3RhcmdldCcgKSA9PT0gbm9kZS5pZCgpO1xuICAgIH0gKTtcbiAgICB2YXIgdGhpc0luZm8gPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgIHZhciBoaWdoZXN0RGVwdGhPZk90aGVyID0gMDtcbiAgICB2YXIgaGlnaGVzdE90aGVyO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbIGkgXTtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIG90aGVySW5mbyA9IG90aGVyTm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgaWYoIHRoaXNJbmZvLmRlcHRoIDw9IG90aGVySW5mby5kZXB0aCAmJiBoaWdoZXN0RGVwdGhPZk90aGVyIDwgb3RoZXJJbmZvLmRlcHRoICl7XG4gICAgICAgIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSBvdGhlckluZm8uZGVwdGg7XG4gICAgICAgIGhpZ2hlc3RPdGhlciA9IG90aGVyTm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGlnaGVzdE90aGVyO1xuICB9O1xuXG4gIC8vIG1ha2UgbWF4aW1hbCBpZiBzbyBzZXQgYnkgYWRqdXN0aW5nIGRlcHRoc1xuICBmb3IoIHZhciBhZGogPSAwOyBhZGogPCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50czsgYWRqKysgKXtcblxuICAgIHZhciBuRGVwdGhzID0gZGVwdGhzLmxlbmd0aDtcbiAgICB2YXIgZWxlc1RvTW92ZSA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbkRlcHRoczsgaSsrICl7XG4gICAgICB2YXIgZGVwdGggPSBkZXB0aHNbIGkgXTtcblxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoLmxlbmd0aDtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbkRlcHRoOyBqKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGRlcHRoWyBqIF07XG4gICAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgICB2YXIgaW50RWxlID0gaW50ZXJzZWN0c0RlcHRoKCBlbGUgKTtcblxuICAgICAgICBpZiggaW50RWxlICl7XG4gICAgICAgICAgaW5mby5pbnRFbGUgPSBpbnRFbGU7XG4gICAgICAgICAgZWxlc1RvTW92ZS5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvTW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNUb01vdmVbIGkgXTtcbiAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGludEVsZSA9IGluZm8uaW50RWxlO1xuICAgICAgdmFyIGludEluZm8gPSBpbnRFbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGRlcHRoc1sgaW5mby5kZXB0aCBdLnNwbGljZSggaW5mby5pbmRleCwgMSApOyAvLyByZW1vdmUgZnJvbSBvbGQgZGVwdGggJiBpbmRleFxuXG4gICAgICAvLyBhZGQgdG8gZW5kIG9mIG5ldyBkZXB0aFxuICAgICAgdmFyIG5ld0RlcHRoID0gaW50SW5mby5kZXB0aCArIDE7XG4gICAgICB3aGlsZSggbmV3RGVwdGggPiBkZXB0aHMubGVuZ3RoIC0gMSApe1xuICAgICAgICBkZXB0aHMucHVzaCggW10gKTtcbiAgICAgIH1cbiAgICAgIGRlcHRoc1sgbmV3RGVwdGggXS5wdXNoKCBlbGUgKTtcblxuICAgICAgaW5mby5kZXB0aCA9IG5ld0RlcHRoO1xuICAgICAgaW5mby5pbmRleCA9IGRlcHRoc1sgbmV3RGVwdGggXS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpO1xuICB9XG5cbiAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGlmKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuID0gbm9kZXNbIGkgXTtcbiAgICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcblxuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heCggbWluRGlzdGFuY2UsIHcsIGggKTtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGlmKCBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gKXtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF07XG4gICAgfVxuXG4gICAgdmFyIGVsZURlcHRoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5ub3QoICc6cGFyZW50JyApLmludGVyc2VjdGlvbihub2Rlcyk7XG4gICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbIGkgXTtcbiAgICAgIHZhciBiZiA9IG5laWdoYm9yLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbIGRlcHRoIF0ubGVuZ3RoO1xuXG4gICAgICBpZiggZWxlRGVwdGggPiBkZXB0aCB8fCBlbGVEZXB0aCA9PT0gMCApeyAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgIHBlcmNlbnQgKz0gaW5kZXggLyBuRGVwdGg7XG4gICAgICAgIHNhbXBsZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzYW1wbGVzID0gTWF0aC5tYXgoIDEsIHNhbXBsZXMgKTtcbiAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICBpZiggc2FtcGxlcyA9PT0gMCApeyAvLyBzbyBsb25lIG5vZGVzIGhhdmUgYSBcImRvbid0IGNhcmVcIiBzdGF0ZSBpbiBzb3J0aW5nXG4gICAgICBwZXJjZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXSA9IHBlcmNlbnQ7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH07XG5cblxuICAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuICB2YXIgc29ydEZuID0gZnVuY3Rpb24oIGEsIGIgKXtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYSApO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBiICk7XG5cbiAgICByZXR1cm4gYXBjdCAtIGJwY3Q7XG4gIH07XG5cbiAgZm9yKCB2YXIgdGltZXMgPSAwOyB0aW1lcyA8IDM7IHRpbWVzKysgKXsgLy8gZG8gaXQgYSBmZXcgdGltZXMgYi9jIHRoZSBkZXB0aHMgYXJlIGR5bmFtaWMgYW5kIHdlIHdhbnQgYSBtb3JlIHN0YWJsZSByZXN1bHRcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICBkZXB0aHNbIGkgXSA9IGRlcHRoc1sgaSBdLnNvcnQoIHNvcnRGbiApO1xuICAgIH1cbiAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTsgLy8gYW5kIHVwZGF0ZVxuXG4gIH1cblxuICB2YXIgYmlnZ2VzdERlcHRoU2l6ZSA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KCBkZXB0aHNbIGkgXS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUgKTtcbiAgfVxuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi54MSArIGJiLmggLyAyXG4gIH07XG5cbiAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24oIGVsZSwgaXNCb3R0b21EZXB0aCApe1xuICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgIHZhciBkZXB0aCA9IGluZm8uZGVwdGg7XG4gICAgdmFyIGluZGV4ID0gaW5mby5pbmRleDtcbiAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzWyBkZXB0aCBdLmxlbmd0aDtcblxuICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heCggYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoIGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKCBiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCApO1xuICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgoIHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSApO1xuXG4gICAgaWYoICFvcHRpb25zLmNpcmNsZSApe1xuXG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICB9O1xuXG4gICAgICBpZiggaXNCb3R0b21EZXB0aCApe1xuICAgICAgICByZXR1cm4gZXBvcztcbiAgICAgIH1cblxuICAgICAgLy8gdmFyIHN1Y2NzID0gc3VjY2Vzc29yc1sgZWxlLmlkKCkgXTtcbiAgICAgIC8vIGlmKCBzdWNjcyApe1xuICAgICAgLy8gICBlcG9zLnggPSAwO1xuICAgICAgLy9cbiAgICAgIC8vICAgZm9yKCB2YXIgaSA9IDAgOyBpIDwgc3VjY3MubGVuZ3RoOyBpKysgKXtcbiAgICAgIC8vICAgICB2YXIgc3BvcyA9IHBvc1sgc3VjY3NbaV0uaWQoKSBdO1xuICAgICAgLy9cbiAgICAgIC8vICAgICBlcG9zLnggKz0gc3Bvcy54O1xuICAgICAgLy8gICB9XG4gICAgICAvL1xuICAgICAgLy8gICBlcG9zLnggLz0gc3VjY3MubGVuZ3RoO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgLy9kZWJ1Z2dlcjtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIGVwb3M7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIG9wdGlvbnMuY2lyY2xlICl7XG4gICAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gZGVwdGhzWyBkZXB0aCBdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgIGlmKCBkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKSxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApXG4gICAgICAgIH07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvLyBnZXQgcG9zaXRpb25zIGluIHJldmVyc2UgZGVwdGggb3JkZXJcbiAgdmFyIHBvcyA9IHt9O1xuICBmb3IoIHZhciBpID0gZGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7XG4gICAgdmFyIGRlcHRoID0gZGVwdGhzWyBpIF07XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGRlcHRoLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbm9kZSA9IGRlcHRoWyBqIF07XG5cbiAgICAgIHBvc1sgbm9kZS5pZCgpIF0gPSBnZXRQb3NpdGlvbiggbm9kZSwgaSA9PT0gZGVwdGhzLmxlbmd0aCAtIDEgKTtcbiAgICB9XG4gIH1cblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHBvc1sgdGhpcy5pZCgpIF07XG4gIH0gKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnJlYWR0aEZpcnN0TGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLCAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICByYWRpdXM6IHVuZGVmaW5lZCwgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSwgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLCAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xufVxuXG5DaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuXG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuXG4gIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG5cbiAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG5cbiAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gKCBNYXRoLm1heCggMSwgbm9kZXMubGVuZ3RoIC0gMSApICk7XG4gIHZhciByO1xuXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbiA9IG5vZGVzWyBpIF07XG4gICAgdmFyIG5iYiA9IG4uYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IG5iYi53O1xuICAgIHZhciBoID0gbmJiLmg7XG5cbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KCBtaW5EaXN0YW5jZSwgdywgaCApO1xuICB9XG5cbiAgaWYoIGlzLm51bWJlciggb3B0aW9ucy5yYWRpdXMgKSApe1xuICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgfSBlbHNlIGlmKCBub2Rlcy5sZW5ndGggPD0gMSApe1xuICAgIHIgPSAwO1xuICB9IGVsc2Uge1xuICAgIHIgPSBNYXRoLm1pbiggYmIuaCwgYmIudyApIC8gMiAtIG1pbkRpc3RhbmNlO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgaWYoIG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyggZFRoZXRhICkgLSBNYXRoLmNvcyggMCApO1xuICAgIHZhciBkc2luID0gTWF0aC5zaW4oIGRUaGV0YSApIC0gTWF0aC5zaW4oIDAgKTtcbiAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvICggZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgfVxuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgZWxlICl7XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqICggY2xvY2t3aXNlID8gMSA6IC0xICk7XG5cbiAgICB2YXIgcnggPSByICogTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKCB0aGV0YSApO1xuICAgIHZhciBwb3MgPSB7XG4gICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgeTogY2VudGVyLnkgKyByeVxuICAgIH07XG5cbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUxheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uL21hdGgnICk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLCAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBlcXVpZGlzdGFudDogZmFsc2UsIC8vIHdoZXRoZXIgbGV2ZWxzIGhhdmUgYW4gZXF1YWwgcmFkaWFsIGRpc3RhbmNlIGJldHdlbiB0aGVtLCBtYXkgY2F1c2UgYm91bmRpbmcgYm94IG92ZXJmbG93XG4gIG1pbk5vZGVTcGFjaW5nOiAxMCwgLy8gbWluIHNwYWNpbmcgYmV0d2VlbiBvdXRzaWRlIG9mIG5vZGVzICh1c2VkIGZvciByYWRpdXMgYWRqdXN0bWVudClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBoZWlnaHQ6IHVuZGVmaW5lZCwgLy8gaGVpZ2h0IG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIGhlaWdodClcbiAgd2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgd2lkdGgpXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCwgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXAgIFxuICBjb25jZW50cmljOiBmdW5jdGlvbiggbm9kZSApeyAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiggbm9kZXMgKXsgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cbkNvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG5cbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuXG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcbiAgICB2YWx1ZSA9IG9wdGlvbnMuY29uY2VudHJpYy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICBub2RlVmFsdWVzLnB1c2goIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5vZGU6IG5vZGVcbiAgICB9ICk7XG5cbiAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gIH1cblxuICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gIC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgdmFyIG5iYiA9IG5vZGUuYm91bmRpbmdCb3goKTtcblxuICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgoIG1heE5vZGVTaXplLCBuYmIudywgbmJiLmggKTtcbiAgfVxuXG4gIC8vIHNvcnQgbm9kZSB2YWx1ZXMgaW4gZGVzY3JlYXNpbmcgb3JkZXJcbiAgbm9kZVZhbHVlcy5zb3J0KCBmdW5jdGlvbiggYSwgYiApe1xuICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgfSApO1xuXG4gIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKCBub2RlcyApO1xuXG4gIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gIHZhciBsZXZlbHMgPSBbIFtdIF07XG4gIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZVZhbHVlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzWyBpIF07XG5cbiAgICBpZiggY3VycmVudExldmVsLmxlbmd0aCA+IDAgKXtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoIGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSApO1xuXG4gICAgICBpZiggZGlmZiA+PSBsZXZlbFdpZHRoICl7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICBsZXZlbHMucHVzaCggY3VycmVudExldmVsICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudExldmVsLnB1c2goIHZhbCApO1xuICB9XG5cbiAgLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYoICFvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyB0aGVuIHN0cmljdGx5IGNvbnN0cmFpbiB0byBiYlxuICAgIHZhciBmaXJzdEx2bEhhc011bHRpID0gbGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzWzBdLmxlbmd0aCA+IDE7XG4gICAgdmFyIG1heFIgPSAoIE1hdGgubWluKCBiYi53LCBiYi5oICkgLyAyIC0gbWluRGlzdCApO1xuICAgIHZhciByU3RlcCA9IG1heFIgLyAoIGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDAgKTtcblxuICAgIG1pbkRpc3QgPSBNYXRoLm1pbiggbWluRGlzdCwgclN0ZXAgKTtcbiAgfVxuXG4gIC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcbiAgdmFyIHIgPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvICggTWF0aC5tYXgoIDEsIGxldmVsLmxlbmd0aCAtIDEgKSApO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICBpZiggbGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKCBkVGhldGEgKSAtIE1hdGguY29zKCAwICk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKCBkVGhldGEgKSAtIE1hdGguc2luKCAwICk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdCAqIG1pbkRpc3QgLyAoIGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICAgIH1cblxuICAgIGxldmVsLnIgPSByO1xuXG4gICAgciArPSBtaW5EaXN0O1xuICB9XG5cbiAgaWYoIG9wdGlvbnMuZXF1aWRpc3RhbnQgKXtcbiAgICB2YXIgckRlbHRhTWF4ID0gMDtcbiAgICB2YXIgciA9IDA7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG4gICAgICB2YXIgckRlbHRhID0gbGV2ZWwuciAtIHI7XG5cbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KCByRGVsdGFNYXgsIHJEZWx0YSApO1xuICAgIH1cblxuICAgIHIgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgICAgaWYoIGkgPT09IDAgKXtcbiAgICAgICAgciA9IGxldmVsLnI7XG4gICAgICB9XG5cbiAgICAgIGxldmVsLnIgPSByO1xuXG4gICAgICByICs9IHJEZWx0YU1heDtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcbiAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhO1xuICAgIHZhciByID0gbGV2ZWwucjtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGV2ZWwubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciB2YWwgPSBsZXZlbFsgaiBdO1xuICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBkVGhldGEgKiBqO1xuXG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyByICogTWF0aC5jb3MoIHRoZXRhICksXG4gICAgICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKCB0aGV0YSApXG4gICAgICB9O1xuXG4gICAgICBwb3NbIHZhbC5ub2RlLmlkKCkgXSA9IHA7XG4gICAgfVxuICB9XG5cbiAgLy8gcG9zaXRpb24gdGhlIG5vZGVzXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICB2YXIgaWQgPSB0aGlzLmlkKCk7XG5cbiAgICByZXR1cm4gcG9zWyBpZCBdO1xuICB9ICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmNlbnRyaWNMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG5UaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG5odHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG5Nb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uL21hdGgnICk7XG52YXIgVGhyZWFkID0gcmVxdWlyZSggJy4uLy4uL3RocmVhZCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi9pcycgKTtcblxudmFyIERFQlVHO1xuXG4vKipcbiAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gKi9cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uKCl7fSxcblxuICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gIHN0b3A6IGZ1bmN0aW9uKCl7fSxcblxuICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gIGFuaW1hdGU6IHRydWUsXG5cbiAgLy8gVGhlIGxheW91dCBhbmltYXRlcyBvbmx5IGFmdGVyIHRoaXMgbWFueSBtaWxsaXNlY29uZHNcbiAgLy8gKHByZXZlbnRzIGZsYXNoaW5nIG9uIGZhc3QgcnVucylcbiAgYW5pbWF0aW9uVGhyZXNob2xkOiAyNTAsXG5cbiAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZVxuICAvLyAoMCAtPiBvbmx5IHVwZGF0ZWQgb24gdGhlIGVuZClcbiAgcmVmcmVzaDogMjAsXG5cbiAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgZml0OiB0cnVlLFxuXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDMwLFxuXG4gIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuXG4gIC8vIFJhbmRvbWl6ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzICh0cnVlKSBvciB1c2UgZXhpc3RpbmcgcG9zaXRpb25zIChmYWxzZSlcbiAgcmFuZG9taXplOiBmYWxzZSxcblxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmc6IDEwMCxcblxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiA0MDAwMDA7IH0sXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwOiAxMCxcblxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTA7IH0sXG5cbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTAwOyB9LFxuXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogNSxcblxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogODAsXG5cbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDEwMDAsXG5cbiAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgaW5pdGlhbFRlbXA6IDIwMCxcblxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk1LFxuXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjAsXG5cbiAgLy8gV2hldGhlciB0byB1c2UgdGhyZWFkaW5nIHRvIHNwZWVkIHVwIHRoZSBsYXlvdXRcbiAgdXNlTXVsdGl0YXNraW5nOiB0cnVlLFxuXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZFxufTtcblxuXG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBDb3NlTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcblxuICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcbn1cblxuXG4vKipcbiAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ICAgICAgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ICA9IHRoaXM7XG4gIHZhciB0aHJlYWQgID0gdGhpcy50aHJlYWQ7XG5cbiAgaWYoICF0aHJlYWQgfHwgdGhyZWFkLnN0b3BwZWQoKSApe1xuICAgIHRocmVhZCA9IHRoaXMudGhyZWFkID0gVGhyZWFkKCB7IGRpc2FibGVkOiAhb3B0aW9ucy51c2VNdWx0aXRhc2tpbmcgfSApO1xuICB9XG5cbiAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICBsYXlvdXQudHJpZ2dlciggeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9ICk7XG5cbiAgLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG4gIGlmKCB0cnVlID09PSBvcHRpb25zLmRlYnVnICl7XG4gICAgREVCVUcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIERFQlVHID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG4gIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyggY3ksIGxheW91dCwgb3B0aW9ucyApO1xuXG4gIC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcbiAgaWYoIERFQlVHICl7XG4gICAgcHJpbnRMYXlvdXRJbmZvKCBsYXlvdXRJbmZvICk7XG4gIH1cblxuICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyggbGF5b3V0SW5mbywgY3kgKTtcbiAgfVxuXG4gIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB2YXIgcmVmcmVzaFJlcXVlc3RlZCA9IGZhbHNlO1xuICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uKCByT3B0cyApe1xuICAgIHJPcHRzID0gck9wdHMgfHwge307XG5cbiAgICBpZiggcmVmcmVzaFJlcXVlc3RlZCAmJiAhck9wdHMubmV4dCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCAhck9wdHMuZm9yY2UgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVmcmVzaFJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24oKXtcbiAgICAgIHJlZnJlc2hQb3NpdGlvbnMoIGxheW91dEluZm8sIGN5LCBvcHRpb25zICk7XG5cbiAgICAgIC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG4gICAgICBpZiggdHJ1ZSA9PT0gb3B0aW9ucy5maXQgKXtcbiAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cblxuICAgICAgcmVmcmVzaFJlcXVlc3RlZCA9IGZhbHNlO1xuXG4gICAgICBpZiggck9wdHMubmV4dCApeyByT3B0cy5uZXh0KCk7IH1cbiAgICB9KTtcbiAgfTtcblxuICB0aHJlYWQub24oICdtZXNzYWdlJywgZnVuY3Rpb24oIGUgKXtcbiAgICB2YXIgbGF5b3V0Tm9kZXMgPSBlLm1lc3NhZ2U7XG5cbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzID0gbGF5b3V0Tm9kZXM7XG4gICAgcmVmcmVzaCgpO1xuICB9ICk7XG5cbiAgdGhyZWFkLnBhc3MoIHtcbiAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGFuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSxcbiAgICAgIHJlZnJlc2g6IG9wdGlvbnMucmVmcmVzaCxcbiAgICAgIGNvbXBvbmVudFNwYWNpbmc6IG9wdGlvbnMuY29tcG9uZW50U3BhY2luZyxcbiAgICAgIG5vZGVPdmVybGFwOiBvcHRpb25zLm5vZGVPdmVybGFwLFxuICAgICAgbmVzdGluZ0ZhY3Rvcjogb3B0aW9ucy5uZXN0aW5nRmFjdG9yLFxuICAgICAgZ3Jhdml0eTogb3B0aW9ucy5ncmF2aXR5LFxuICAgICAgbnVtSXRlcjogb3B0aW9ucy5udW1JdGVyLFxuICAgICAgaW5pdGlhbFRlbXA6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgICBjb29saW5nRmFjdG9yOiBvcHRpb25zLmNvb2xpbmdGYWN0b3IsXG4gICAgICBtaW5UZW1wOiBvcHRpb25zLm1pblRlbXBcbiAgICB9XG4gIH0gKS5ydW4oIGZ1bmN0aW9uKCBwYXNzICl7XG4gICAgdmFyIGxheW91dEluZm8gPSBwYXNzLmxheW91dEluZm87XG4gICAgdmFyIG9wdGlvbnMgPSBwYXNzLm9wdGlvbnM7XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAgICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucywgc3RlcCApe1xuICAgICAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgICAgIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gICAgICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgICAgIGNhbGN1bGF0ZU5vZGVGb3JjZXMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICAgIC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuICAgICAgY2FsY3VsYXRlRWRnZUZvcmNlcyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgICAgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG4gICAgICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgICAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgICBwcm9wYWdhdGVGb3JjZXMoIGxheW91dEluZm8sIG9wdGlvbnMgKTtcbiAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcbiAgICAgIHVwZGF0ZVBvc2l0aW9ucyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAgIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAgICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKysgKXtcbiAgICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFsgaSBdO1xuICAgICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKyApe1xuICAgICAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFsgaiBdIF0gXTtcblxuICAgICAgICAgIGZvciggdmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKysgKXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBncmFwaFsgayBdIF0gXTtcblxuICAgICAgICAgICAgbm9kZVJlcHVsc2lvbiggbm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uKCBtYXggKXtcbiAgICAgIHJldHVybiAtbWF4ICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICAgICAqL1xuICAgIHZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24oIG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucyApe1xuICAgICAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuXG4gICAgICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgICAgIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gICAgICBpZiggY21wdElkMSAhPT0gY21wdElkMiAmJiAhbGF5b3V0SW5mby5pc0NvbXBvdW5kICl7IHJldHVybjsgfVxuXG4gICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gICAgICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgICAgIHZhciBtYXhSYW5kRGlzdCA9IDE7XG4gICAgICAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcblxuICAgICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcbiAgICAgIGlmKCAwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkgKXtcbiAgICAgICAgZGlyZWN0aW9uWCA9IHJhbmRvbURpc3RhbmNlKCBtYXhSYW5kRGlzdCApO1xuICAgICAgICBkaXJlY3Rpb25ZID0gcmFuZG9tRGlzdGFuY2UoIG1heFJhbmREaXN0ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKCBub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkgKTtcblxuICAgICAgaWYoIG92ZXJsYXAgPiAwICl7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBETyBvdmVybGFwLlwiO1xuICAgICAgICAvLyBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgICAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgICAgIC8vIHRvIHRoZSBvdmVybGFwXG4gICAgICAgIHZhciBmb3JjZSAgICA9IG9wdGlvbnMubm9kZU92ZXJsYXAgKiBvdmVybGFwO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSApO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVggICA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VZICAgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KCBub2RlMSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSApO1xuICAgICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQoIG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSApO1xuXG4gICAgICAgIC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuICAgICAgICB2YXIgZGlzdGFuY2VYICAgPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgICB2YXIgZGlzdGFuY2VZICAgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgICB2YXIgZGlzdGFuY2VTcXIgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICAgIHZhciBkaXN0YW5jZSAgICA9IE1hdGguc3FydCggZGlzdGFuY2VTcXIgKTtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICAgIHZhciBmb3JjZSAgPSAoIG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uICkgLyBkaXN0YW5jZVNxcjtcbiAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBmb3JjZVxuICAgICAgaWYoICFub2RlMS5pc0xvY2tlZCApe1xuICAgICAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbm9kZTIuaXNMb2NrZWQgKXtcbiAgICAgICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgICAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAgICAgKi9cbiAgICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24oIG5vZGUxLCBub2RlMiwgZFgsIGRZICl7XG5cbiAgICAgIGlmKCBkWCA+IDAgKXtcbiAgICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgICAgIH1cblxuICAgICAgaWYoIGRZID4gMCApe1xuICAgICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICAgICAgfVxuXG4gICAgICBpZiggb3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwICl7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAgICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gICAgICovXG4gICAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24oIG5vZGUsIGRYLCBkWSApe1xuXG4gICAgICAvLyBTaG9yY3V0c1xuICAgICAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gICAgICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgICAgIHZhciBkaXJTbG9wZSAgICAgPSBkWSAvIGRYO1xuICAgICAgdmFyIG5vZGVTbG9wZSAgICA9IEggLyBXO1xuXG4gICAgICAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgK1xuICAgICAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7XG4gICAgICAvL1xuICAgICAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcbiAgICAgICAgaWYoIDAgPT09IGRYICYmIDAgPCBkWSApe1xuICAgICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG4gICAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gICAgICAgIGlmKCAwID09PSBkWCAmJiAwID4gZFkgKXtcbiAgICAgICAgICByZXMueCA9IFg7XG4gICAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcbiAgICAgICAgaWYoIDAgPCBkWCAmJlxuICAgICAgICAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJlxuICAgICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUgKXtcbiAgICAgICAgICByZXMueCA9IFggKyBXIC8gMjtcbiAgICAgICAgICByZXMueSA9IFkgKyAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG4gICAgICAgIGlmKCAwID4gZFggJiZcbiAgICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiZcbiAgICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlICl7XG4gICAgICAgICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgICAgICAgcmVzLnkgPSBZIC0gKFcgKiBkWSAvIDIgLyBkWCk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbkxlZnRib3JkZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcbiAgICAgICAgaWYoIDAgPCBkWSAmJlxuICAgICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkgKXtcbiAgICAgICAgICByZXMueCA9IFggKyAoSCAqIGRYIC8gMiAvIGRZKTtcbiAgICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuICAgICAgICBpZiggMCA+IGRZICYmXG4gICAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgICBkaXJTbG9wZSA+PSBub2RlU2xvcGUgKSApe1xuICAgICAgICAgIHJlcy54ID0gWCAtIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgfSB3aGlsZSggZmFsc2UpO1xuXG4gICAgICAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrICl7XG4gICAgICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICAgICAgdmFyIGVkZ2UgICAgID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1sgaSBdO1xuICAgICAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZWRnZS5zb3VyY2VJZCBdO1xuICAgICAgICB2YXIgc291cmNlICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBzb3VyY2VJeCBdO1xuICAgICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZWRnZS50YXJnZXRJZCBdO1xuICAgICAgICB2YXIgdGFyZ2V0ICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyB0YXJnZXRJeCBdO1xuXG4gICAgICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7XG5cbiAgICAgICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAgICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgICAgIGlmKCAwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludCggc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZICk7XG4gICAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCggdGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSApO1xuXG5cbiAgICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGwgID0gTWF0aC5zcXJ0KCBseCAqIGx4ICsgbHkgKiBseSApO1xuXG4gICAgICAgIHZhciBmb3JjZSAgPSBNYXRoLnBvdyggZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIgKSAvIGVkZ2UuZWxhc3RpY2l0eTtcblxuICAgICAgICBpZiggMCAhPT0gbCApe1xuICAgICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuICAgICAgICBpZiggIXNvdXJjZS5pc0xvY2tlZCApe1xuICAgICAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgICAgICBzb3VyY2Uub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXRhcmdldC5pc0xvY2tlZCApe1xuICAgICAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTtcblxuICAgICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKysgKXtcbiAgICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFsgaSBdO1xuICAgICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG4gICAgICAgIGlmKCAwID09PSBpICl7XG4gICAgICAgICAgdmFyIGNlbnRlclggICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgICB2YXIgY2VudGVyWSAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICAgICAgdmFyIHRlbXAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZ3JhcGhbMF0gXSBdO1xuICAgICAgICAgIHZhciBwYXJlbnQgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXAucGFyZW50SWQgXSBdO1xuICAgICAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgZ3JhcGhbIGogXSBdIF07XG4gICAgICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuXG4gICAgICAgICAgaWYoIG5vZGUuaXNMb2NrZWQgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICAgICAgdmFyIGQgID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuICAgICAgICAgIGlmKCBkID4gZGlzdFRocmVzaG9sZCApe1xuICAgICAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAgICAgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICAgICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICAgKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gICAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgICAgdmFyIGVuZCAgID0gLTE7ICAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAgICAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gICAgICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlLnB1c2guYXBwbHkoIHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdICk7XG4gICAgICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7XG5cbiAgICAgIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG4gICAgICB3aGlsZSggc3RhcnQgPD0gZW5kICl7XG4gICAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgICAgdmFyIG5vZGVJZCAgICA9IHF1ZXVlWyBzdGFydCsrIF07XG4gICAgICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgbm9kZUlkIF07XG4gICAgICAgIHZhciBub2RlICAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBub2RlSW5kZXggXTtcbiAgICAgICAgdmFyIGNoaWxkcmVuICA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuICAgICAgICBpZiggMCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5pc0xvY2tlZCApe1xuICAgICAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZO1xuXG4gICAgICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICtcbiAgICAgICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgY2hpbGRyZW5bIGkgXSBdIF07XG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgb2Zmc2V0XG4gICAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTtcbiAgICAgICAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICAgICAgICBxdWV1ZVsgKytlbmQgXSA9IGNoaWxkcmVuWyBpIF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICAgICAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24oIGxheW91dEluZm8sIG9wdGlvbnMgKXtcbiAgICAgIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuICAgICAgICBpZiggMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICl7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICAgICAgaWYoIDAgPCBuLmNoaWxkcmVuLmxlbmd0aCB8fCBuLmlzTG9ja2VkICl7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgICAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuXG4gICAgICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICAgICAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZSggbi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUgKTtcbiAgICAgICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7XG4gICAgICAgIG4ucG9zaXRpb25ZICs9IHRlbXBGb3JjZS55O1xuICAgICAgICBuLm9mZnNldFggPSAwO1xuICAgICAgICBuLm9mZnNldFkgPSAwO1xuICAgICAgICBuLm1pblggICAgPSBuLnBvc2l0aW9uWCAtIG4ud2lkdGg7XG4gICAgICAgIG4ubWF4WCAgICA9IG4ucG9zaXRpb25YICsgbi53aWR0aDtcbiAgICAgICAgbi5taW5ZICAgID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDtcbiAgICAgICAgbi5tYXhZICAgID0gbi5wb3NpdGlvblkgKyBuLmhlaWdodDtcbiAgICAgICAgLy8gcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcbiAgICAgICAgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKCBuLCBsYXlvdXRJbmZvICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGkgXTtcbiAgICAgICAgaWYoIDAgPCBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCApe1xuICAgICAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgICAgIG4ud2lkdGggICAgID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgICAgIG4uaGVpZ2h0ICAgID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgICAgIC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICAgICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gICAgIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uKCBmb3JjZVgsIGZvcmNlWSwgbWF4ICl7XG4gICAgICAvLyB2YXIgcyA9IFwiTGltaXRpbmcgZm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKS4gTWF4OiBcIiArIG1heDtcbiAgICAgIHZhciBmb3JjZSA9IE1hdGguc3FydCggZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZICk7XG5cbiAgICAgIGlmKCBmb3JjZSA+IG1heCApe1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgIHg6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgICAgIHk6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgICAgIH07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgeDogZm9yY2VYLFxuICAgICAgICAgIHk6IGZvcmNlWVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZVxuICAgICAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uKCBub2RlLCBsYXlvdXRJbmZvICl7XG4gICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgICAgaWYoIG51bGwgPT0gcGFyZW50SWQgKXtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgICAgIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHBhcmVudElkIF0gXTtcbiAgICAgIHZhciBmbGFnID0gZmFsc2U7XG5cbiAgICAgIC8vIE1heFhcbiAgICAgIGlmKCBudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYICl7XG4gICAgICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgICAgIH1cblxuICAgICAgLy8gTWluWFxuICAgICAgaWYoIG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCApe1xuICAgICAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgICAgIH1cblxuICAgICAgLy8gTWF4WVxuICAgICAgaWYoIG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZICl7XG4gICAgICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1pbllcbiAgICAgIGlmKCBudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSApe1xuICAgICAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuICAgICAgaWYoIGZsYWcgKXtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMoIHAsIGxheW91dEluZm8gKTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICB2YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24oIGxheXV0SW5mbywgb3B0aW9ucyApe1xuICAgICAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuICAgICAgICB2YXIgY2lkID0gbm9kZS5jbXB0SWQ7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzWyBjaWQgXSA9IGNvbXBvbmVudHNbIGNpZCBdIHx8IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudC5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbEEgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzWyBpIF07XG5cbiAgICAgICAgaWYoICFjICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgYy54MSA9IEluZmluaXR5O1xuICAgICAgICBjLngyID0gLUluZmluaXR5O1xuICAgICAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgICAgIGMueTIgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIG4gPSBjWyBqIF07XG5cbiAgICAgICAgICBjLngxID0gTWF0aC5taW4oIGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aCAvIDIgKTtcbiAgICAgICAgICBjLngyID0gTWF0aC5tYXgoIGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aCAvIDIgKTtcbiAgICAgICAgICBjLnkxID0gTWF0aC5taW4oIGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyICk7XG4gICAgICAgICAgYy55MiA9IE1hdGgubWF4KCBjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0IC8gMiApO1xuICAgICAgICB9XG5cbiAgICAgICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuXG4gICAgICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMuc29ydCggZnVuY3Rpb24oIGMxLCBjMiApe1xuICAgICAgICByZXR1cm4gYzIudyAqIGMyLmggLSBjMS53ICogYzEuaDtcbiAgICAgIH0gKTtcblxuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIHVzZWRXID0gMDtcbiAgICAgIHZhciByb3dIID0gMDtcbiAgICAgIHZhciBtYXhSb3dXID0gTWF0aC5zcXJ0KCB0b3RhbEEgKSAqIGxheW91dEluZm8uY2xpZW50V2lkdGggLyBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjID0gY29tcG9uZW50c1sgaSBdO1xuXG4gICAgICAgIGlmKCAhYyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBuID0gY1sgaiBdO1xuXG4gICAgICAgICAgaWYoICFuLmlzTG9ja2VkICl7XG4gICAgICAgICAgICBuLnBvc2l0aW9uWCArPSB4O1xuICAgICAgICAgICAgbi5wb3NpdGlvblkgKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICByb3dIID0gTWF0aC5tYXgoIHJvd0gsIGMuaCApO1xuXG4gICAgICAgIGlmKCB1c2VkVyA+IG1heFJvd1cgKXtcbiAgICAgICAgICB5ICs9IHJvd0ggKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgdXNlZFcgPSAwO1xuICAgICAgICAgIHJvd0ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uKCBpICl7XG4gICAgICBpZiggc3RvcHBlZCApe1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICAgIHN0ZXAoIGxheW91dEluZm8sIG9wdGlvbnMsIGkgKTtcblxuICAgICAgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG4gICAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiTmV3IHRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuXG4gICAgICBpZiggbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCApe1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsb29wUmV0O1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICB3aGlsZSggZiA8IG9wdGlvbnMucmVmcmVzaCAmJiBpIDwgb3B0aW9ucy5udW1JdGVyICl7XG4gICAgICAgIHZhciBsb29wUmV0ID0gbWFpbkxvb3AoIGkgKTtcbiAgICAgICAgaWYoICFsb29wUmV0ICl7IGJyZWFrOyB9XG5cbiAgICAgICAgZisrO1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgYnJvYWRjYXN0KCBsYXlvdXRJbmZvLmxheW91dE5vZGVzICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIH1cblxuICAgIH0gd2hpbGUoIGxvb3BSZXQgJiYgaSArIDEgPCBvcHRpb25zLm51bUl0ZXIgKTtcblxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuXG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH0gKS50aGVuKCBmdW5jdGlvbiggbGF5b3V0SW5mb1VwZGF0ZWQgKXtcbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzID0gbGF5b3V0SW5mb1VwZGF0ZWQubGF5b3V0Tm9kZXM7IC8vIGdldCB0aGUgcG9zaXRpb25zXG5cbiAgICB0aHJlYWQuc3RvcCgpO1xuICAgIGRvbmUoKTtcbiAgfSApO1xuXG4gIHZhciBkb25lID0gZnVuY3Rpb24oKXtcbiAgICByZWZyZXNoKHtcbiAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgbmV4dDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICBpZiggdGhpcy50aHJlYWQgKXtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoICdsYXlvdXRzdG9wJyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmKCB0aGlzLnRocmVhZCApe1xuICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICovXG52YXIgY3JlYXRlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uKCBjeSwgbGF5b3V0LCBvcHRpb25zICl7XG4gIC8vIFNob3J0Y3V0XG4gIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcblxuICB2YXIgbGF5b3V0SW5mbyAgID0ge1xuICAgIGlzQ29tcG91bmQ6IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSxcbiAgICBsYXlvdXROb2RlczogW10sXG4gICAgaWRUb0luZGV4OiB7fSxcbiAgICBub2RlU2l6ZTogbm9kZXMuc2l6ZSgpLFxuICAgIGdyYXBoU2V0OiBbXSxcbiAgICBpbmRleFRvR3JhcGg6IFtdLFxuICAgIGxheW91dEVkZ2VzOiBbXSxcbiAgICBlZGdlU2l6ZTogZWRnZXMuc2l6ZSgpLFxuICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgIGNsaWVudFdpZHRoOiBjeS53aWR0aCgpLFxuICAgIGNsaWVudEhlaWdodDogY3kud2lkdGgoKSxcbiAgICBib3VuZGluZ0JveDogbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICAgICAgICAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgICAgICAgICAgICAgIH0gKVxuICB9O1xuXG4gIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5lbGVzLmNvbXBvbmVudHMoKTtcbiAgdmFyIGlkMmNtcHRJZCA9IHt9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzWyBpIF07XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbIGogXTtcblxuICAgICAgaWQyY21wdElkWyBub2RlLmlkKCkgXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrICl7XG4gICAgdmFyIG4gPSBub2Rlc1sgaSBdO1xuICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgdGVtcE5vZGUgICAgICAgID0ge307XG4gICAgdGVtcE5vZGUuaXNMb2NrZWQgICA9IG4ubG9ja2VkKCk7XG4gICAgdGVtcE5vZGUuaWQgICAgICAgICA9IG4uZGF0YSggJ2lkJyApO1xuICAgIHRlbXBOb2RlLnBhcmVudElkICAgPSBuLmRhdGEoICdwYXJlbnQnICk7XG4gICAgdGVtcE5vZGUuY21wdElkICAgICA9IGlkMmNtcHRJZFsgbi5pZCgpIF07XG4gICAgdGVtcE5vZGUuY2hpbGRyZW4gICA9IFtdO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWCAgPSBuLnBvc2l0aW9uKCAneCcgKTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblkgID0gbi5wb3NpdGlvbiggJ3knICk7XG4gICAgdGVtcE5vZGUub2Zmc2V0WCAgICA9IDA7XG4gICAgdGVtcE5vZGUub2Zmc2V0WSAgICA9IDA7XG4gICAgdGVtcE5vZGUuaGVpZ2h0ICAgICA9IG5iYi53O1xuICAgIHRlbXBOb2RlLndpZHRoICAgICAgPSBuYmIuaDtcbiAgICB0ZW1wTm9kZS5tYXhYICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICB0ZW1wTm9kZS5taW5YICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ICAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSggJ3BhZGRpbmcnICkgKTtcbiAgICB0ZW1wTm9kZS5wYWRSaWdodCAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSggJ3BhZGRpbmcnICkgKTtcbiAgICB0ZW1wTm9kZS5wYWRUb3AgICAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSggJ3BhZGRpbmcnICkgKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gID0gcGFyc2VGbG9hdCggbi5zdHlsZSggJ3BhZGRpbmcnICkgKTtcblxuICAgIC8vIGZvcmNlc1xuICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBpcy5mbiggb3B0aW9ucy5ub2RlUmVwdWxzaW9uICkgPyBvcHRpb25zLm5vZGVSZXB1bHNpb24uY2FsbCggbiwgbiApIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uO1xuXG4gICAgLy8gQWRkIG5ldyBub2RlXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKCB0ZW1wTm9kZSApO1xuICAgIC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcbiAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcE5vZGUuaWQgXSA9IGk7XG4gIH1cblxuICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDtcbiAgICAvLyBDaGVjayBpZiBub2RlIG4gaGFzIGEgcGFyZW50IG5vZGVcbiAgICBpZiggbnVsbCAhPSBwX2lkICl7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgcF9pZCBdIF0uY2hpbGRyZW4ucHVzaCggbi5pZCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWyArK2VuZCBdID0gbi5pZDtcbiAgICAgIHRlbXBHcmFwaC5wdXNoKCBuLmlkICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKCB0ZW1wR3JhcGggKTtcblxuICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICB3aGlsZSggc3RhcnQgPD0gZW5kICl7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlX2lkICA9IHF1ZXVlWyBzdGFydCsrIF07XG4gICAgdmFyIG5vZGVfaXggID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIG5vZGVfaWQgXTtcbiAgICB2YXIgbm9kZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBub2RlX2l4IF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiggY2hpbGRyZW4ubGVuZ3RoID4gMCApe1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKCBjaGlsZHJlbiApO1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHF1ZXVlWyArK2VuZCBdID0gY2hpbGRyZW5bIGkgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0WyBpIF07XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIGdyYXBoWyBqIF0gXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoWyBpbmRleCBdID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKysgKXtcbiAgICB2YXIgZSA9IGVkZ2VzWyBpIF07XG4gICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgdGVtcEVkZ2UuaWQgICAgICAgPSBlLmRhdGEoICdpZCcgKTtcbiAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSggJ3NvdXJjZScgKTtcbiAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSggJ3RhcmdldCcgKTtcblxuICAgIC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG4gICAgdmFyIGlkZWFsTGVuZ3RoID0gaXMuZm4oIG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aC5jYWxsKCBlLCBlICkgOiBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgICB2YXIgZWxhc3RpY2l0eSA9IGlzLmZuKCBvcHRpb25zLmVkZ2VFbGFzdGljaXR5ICkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5LmNhbGwoIGUsIGUgKSA6IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcbiAgICB2YXIgc291cmNlSXggICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcEVkZ2Uuc291cmNlSWQgXTtcbiAgICB2YXIgdGFyZ2V0SXggICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcEVkZ2UudGFyZ2V0SWQgXTtcbiAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgc291cmNlSXggXTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgdGFyZ2V0SXggXTtcblxuICAgIGlmKCBzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCApe1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSggdGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvICk7XG5cbiAgICAgIC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbIGxjYSBdO1xuICAgICAgdmFyIGRlcHRoICAgID0gMDtcblxuICAgICAgLy8gU291cmNlIGRlcHRoXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBzb3VyY2VJeCBdO1xuICAgICAgd2hpbGUoIC0xID09PSBsY2FHcmFwaC5pbmRleE9mKCB0ZW1wTm9kZS5pZCApICl7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIHRlbXBOb2RlLnBhcmVudElkIF0gXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gVGFyZ2V0IGRlcHRoXG4gICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIHRhcmdldEl4IF07XG4gICAgICB3aGlsZSggLTEgPT09IGxjYUdyYXBoLmluZGV4T2YoIHRlbXBOb2RlLmlkICkgKXtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgdGVtcE5vZGUucGFyZW50SWQgXSBdO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2dEZWJ1ZygnTENBIG9mIG5vZGVzICcgKyB0ZW1wRWRnZS5zb3VyY2VJZCArICcgYW5kICcgKyB0ZW1wRWRnZS50YXJnZXRJZCArXG4gICAgICAvLyAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgK1xuICAgICAgLy8gIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcblxuICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCggdGVtcEVkZ2UgKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICByZXR1cm4gbGF5b3V0SW5mbztcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICpcbiAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKi9cbnZhciBmaW5kTENBID0gZnVuY3Rpb24oIG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbyApe1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gZmluZExDQV9hdXgoIG5vZGUxLCBub2RlMiwgMCwgbGF5b3V0SW5mbyApO1xuICBpZiggMiA+IHJlcy5jb3VudCApe1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gKlxuICogQGFyZyBub2RlMSAgICAgIDogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAqICAgICAgICAgICAgICAgICAgIFggaXMgdGhlIG51bWJlciBvZiBhbmNlc3RlcnMgKG1heDogMikgZm91bmQgaW5cbiAqICAgICAgICAgICAgICAgICAgIGdyYXBoSXggKGFuZCBpdCdzIHN1YmdyYXBocyksXG4gKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmdcbiAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gKi9cbnZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uKCBub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8gKXtcbiAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFsgZ3JhcGhJeCBdO1xuICAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuICBpZiggLTEgPCBncmFwaC5pbmRleE9mKCBub2RlMSApICYmIC0xIDwgZ3JhcGguaW5kZXhPZiggbm9kZTIgKSApe1xuICAgIHJldHVybiB7Y291bnQ6IDIsIGdyYXBoOiBncmFwaEl4fTtcbiAgfVxuXG4gIC8vIE1ha2UgcmVjdXJzaXZlIGNhbGxzIGZvciBhbGwgc3ViZ3JhcGhzXG4gIHZhciBjID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBub2RlSWQgICA9IGdyYXBoWyBpIF07XG4gICAgdmFyIG5vZGVJeCAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbIG5vZGVJZCBdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIG5vZGVJeCBdLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG4gICAgaWYoIDAgPT09IGNoaWxkcmVuLmxlbmd0aCApe1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkR3JhcGhJeCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoWyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgY2hpbGRyZW5bMF0gXSBdO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eCggbm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8gKTtcbiAgICBpZiggMCA9PT0gcmVzdWx0LmNvdW50ICl7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYoIDEgPT09IHJlc3VsdC5jb3VudCApe1xuICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgYysrO1xuICAgICAgaWYoIDIgPT09IGMgKXtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtjb3VudDogYywgZ3JhcGg6IGdyYXBoSXh9O1xufTtcblxuXG4vKipcbiAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmdcbiAqL1xudmFyIHByaW50TGF5b3V0SW5mbyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvICl7XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG5cbiAgaWYoICFERUJVRyApe1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmRlYnVnKCAnbGF5b3V0Tm9kZXM6JyApO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuICAgIHZhciBzID1cbiAgICAnXFxuaW5kZXg6ICcgICAgICsgaSArXG4gICAgJ1xcbklkOiAnICAgICAgICArIG4uaWQgK1xuICAgICdcXG5DaGlsZHJlbjogJyAgKyBuLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xuICAgICdcXG5wYXJlbnRJZDogJyAgKyBuLnBhcmVudElkICArXG4gICAgJ1xcbnBvc2l0aW9uWDogJyArIG4ucG9zaXRpb25YICtcbiAgICAnXFxucG9zaXRpb25ZOiAnICsgbi5wb3NpdGlvblkgK1xuICAgICdcXG5PZmZzZXRYOiAnICsgbi5vZmZzZXRYICtcbiAgICAnXFxuT2Zmc2V0WTogJyArIG4ub2Zmc2V0WSArXG4gICAgJ1xcbnBhZExlZnQ6ICcgKyBuLnBhZExlZnQgK1xuICAgICdcXG5wYWRSaWdodDogJyArIG4ucGFkUmlnaHQgK1xuICAgICdcXG5wYWRUb3A6ICcgKyBuLnBhZFRvcCArXG4gICAgJ1xcbnBhZEJvdHRvbTogJyArIG4ucGFkQm90dG9tO1xuXG4gICAgY29uc29sZS5kZWJ1ZyggcyApO1xuICB9XG5cbiAgY29uc29sZS5kZWJ1ZyggJ2lkVG9JbmRleCcgKTtcbiAgZm9yKCB2YXIgaSBpbiBsYXlvdXRJbmZvLmlkVG9JbmRleCApe1xuICAgIGNvbnNvbGUuZGVidWcoICdJZDogJyArIGkgKyAnXFxuSW5kZXg6ICcgKyBsYXlvdXRJbmZvLmlkVG9JbmRleFsgaSBdICk7XG4gIH1cblxuICBjb25zb2xlLmRlYnVnKCAnR3JhcGggU2V0JyApO1xuICB2YXIgc2V0ID0gbGF5b3V0SW5mby5ncmFwaFNldDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICsrICl7XG4gICAgY29uc29sZS5kZWJ1ZyggJ1NldCA6ICcgKyBpICsgJzogJyArIHNldFsgaSBdLnRvU3RyaW5nKCkgKTtcbiAgfVxuXG4gIHZhciBzID0gJ0luZGV4VG9HcmFwaCc7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5pbmRleFRvR3JhcGgubGVuZ3RoOyBpICsrICl7XG4gICAgcyArPSAnXFxuSW5kZXggOiAnICsgaSArICcgR3JhcGg6ICcgKyBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFsgaSBdO1xuICB9XG4gIGNvbnNvbGUuZGVidWcoIHMgKTtcblxuICBzID0gJ0xheW91dCBFZGdlcyc7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1sgaSBdO1xuICAgIHMgKz0gJ1xcbkVkZ2UgSW5kZXg6ICcgKyBpICsgJyBJRDogJyArIGUuaWQgK1xuICAgICcgU291Y2VJRDogJyArIGUuc291cmNlSWQgKyAnIFRhcmdldElkOiAnICsgZS50YXJnZXRJZCArXG4gICAgJyBJZGVhbCBMZW5ndGg6ICcgKyBlLmlkZWFsTGVuZ3RoO1xuICB9XG4gIGNvbnNvbGUuZGVidWcoIHMgKTtcblxuICBzID0gICdub2RlU2l6ZTogJyArIGxheW91dEluZm8ubm9kZVNpemU7XG4gIHMgKz0gJ1xcbmVkZ2VTaXplOiAnICsgbGF5b3V0SW5mby5lZGdlU2l6ZTtcbiAgcyArPSAnXFxudGVtcGVyYXR1cmU6ICcgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlO1xuICBjb25zb2xlLmRlYnVnKCBzICk7XG5cbiAgcmV0dXJuO1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG59O1xuXG5cbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cbnZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbiggbGF5b3V0SW5mbywgY3kgKXtcbiAgdmFyIHdpZHRoICAgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKyApe1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgaSBdO1xuXG4gICAgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG4gICAgaWYoIDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkICl7XG4gICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG52YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uKCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyApe1xuICAvLyB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBiYiA9IGxheW91dEluZm8uYm91bmRpbmdCb3g7XG4gIHZhciBjb3NlQkIgPSB7IHgxOiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTE6IEluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG5cbiAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICBub2Rlcy5mb3JFYWNoKCBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1sgbGF5b3V0SW5mby5pZFRvSW5kZXhbIG5vZGUuZGF0YSggJ2lkJyApIF0gXTtcblxuICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oIGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YICk7XG4gICAgICBjb3NlQkIueDIgPSBNYXRoLm1heCggY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblggKTtcblxuICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oIGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgICBjb3NlQkIueTIgPSBNYXRoLm1heCggY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICB9ICk7XG5cbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuXG4gIG5vZGVzLnBvc2l0aW9ucyggZnVuY3Rpb24oIGksIGVsZSApe1xuICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbIGxheW91dEluZm8uaWRUb0luZGV4WyBlbGUuZGF0YSggJ2lkJyApIF0gXTtcbiAgICAvLyBzID0gXCJOb2RlOiBcIiArIGxub2RlLmlkICsgXCIuIFJlZnJlc2hlZCBwb3NpdGlvbjogKFwiICtcbiAgICAvLyBsbm9kZS5wb3NpdGlvblggKyBcIiwgXCIgKyBsbm9kZS5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApeyAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgdmFyIHBjdFggPSAobG5vZGUucG9zaXRpb25YIC0gY29zZUJCLngxKSAvIGNvc2VCQi53O1xuICAgICAgdmFyIHBjdFkgPSAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH0gKTtcblxuICAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuICBpZiggdHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSApe1xuICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgbGF5b3V0Lm9uZSggJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSApO1xuICAgIGxheW91dC50cmlnZ2VyKCB7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogdGhpcyB9ICk7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAqL1xuLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuLy8gICBpZiAoREVCVUcpIHtcbi8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuLy8gICB9XG4vLyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvc2VMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgbWF0aCA9IHJlcXVpcmUoICcuLi8uLi9tYXRoJyApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIGF2b2lkT3ZlcmxhcFBhZGRpbmc6IDEwLCAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2RlcyB3aGVuIGF2b2lkT3ZlcmxhcDogdHJ1ZVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmRlbnNlOiBmYWxzZSwgLy8gdXNlcyBhbGwgYXZhaWxhYmxlIHNwYWNlIG9uIGZhbHNlLCB1c2VzIG1pbmltYWwgc3BhY2Ugb24gdHJ1ZVxuICByb3dzOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiByb3dzIGluIHRoZSBncmlkXG4gIGNvbHM6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgcG9zaXRpb246IGZ1bmN0aW9uKCBub2RlICl7fSwgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBHcmlkTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCggJzpwYXJlbnQnICk7XG5cbiAgaWYoIG9wdGlvbnMuc29ydCApe1xuICAgIG5vZGVzID0gbm9kZXMuc29ydCggb3B0aW9ucy5zb3J0ICk7XG4gIH1cblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgaWYoIGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCApe1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB7IHg6IGJiLngxLCB5OiBiYi55MSB9O1xuICAgIH0gKTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoIGNlbGxzICogYmIuaCAvIGJiLncgKTtcbiAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoIHNwbGl0cyApO1xuICAgIHZhciBjb2xzID0gTWF0aC5yb3VuZCggYmIudyAvIGJiLmggKiBzcGxpdHMgKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oIHJvd3MsIGNvbHMgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbiggcm93cywgY29scyApO1xuICAgICAgICBpZiggbWluID09IHJvd3MgKXtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24oIHZhbCApe1xuICAgICAgaWYoIHZhbCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCggcm93cywgY29scyApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KCByb3dzLCBjb2xzICk7XG4gICAgICAgIGlmKCBtYXggPT0gcm93cyApe1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7XG5cbiAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgIGlmKCBvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYoIG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCApe1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbCggY2VsbHMgLyByb3dzICk7XG4gICAgfSBlbHNlIGlmKCBvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoIGNlbGxzIC8gY29scyApO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuXG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmKCBjb2xzICogcm93cyA+IGNlbGxzICl7XG4gICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICBpZiggKHNtIC0gMSkgKiBsZyA+PSBjZWxscyApe1xuICAgICAgICBzbWFsbCggc20gLSAxICk7XG4gICAgICB9IGVsc2UgaWYoIChsZyAtIDEpICogc20gPj0gY2VsbHMgKXtcbiAgICAgICAgbGFyZ2UoIGxnIC0gMSApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB0b28gbG93LCBhZGQgcm93cyBvciBjb2x1bW5zXG4gICAgICB3aGlsZSggY29scyAqIHJvd3MgPCBjZWxscyApe1xuICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuXG4gICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgaWYoIChsZyArIDEpICogc20gPj0gY2VsbHMgKXtcbiAgICAgICAgICBsYXJnZSggbGcgKyAxICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hbGwoIHNtICsgMSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgIHZhciBjZWxsSGVpZ2h0ID0gYmIuaCAvIHJvd3M7XG5cbiAgICBpZiggb3B0aW9ucy5jb25kZW5zZSApe1xuICAgICAgY2VsbFdpZHRoID0gMDtcbiAgICAgIGNlbGxIZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIGlmKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmKCBwb3MueCA9PSBudWxsIHx8IHBvcy55ID09IG51bGwgKXsgLy8gZm9yIGJiXG4gICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgIHBvcy55ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYmIgPSBub2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIHZhciBwID0gb3B0aW9ucy5hdm9pZE92ZXJsYXBQYWRkaW5nO1xuXG4gICAgICAgIHZhciB3ID0gbmJiLncgKyBwO1xuICAgICAgICB2YXIgaCA9IG5iYi5oICsgcDtcblxuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heCggY2VsbFdpZHRoLCB3ICk7XG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heCggY2VsbEhlaWdodCwgaCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsVXNlZCA9IHt9OyAvLyBlLmcuICdjLTAtMicgPT4gdHJ1ZVxuXG4gICAgdmFyIHVzZWQgPSBmdW5jdGlvbiggcm93LCBjb2wgKXtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsgJ2MtJyArIHJvdyArICctJyArIGNvbCBdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdXNlID0gZnVuY3Rpb24oIHJvdywgY29sICl7XG4gICAgICBjZWxsVXNlZFsgJ2MtJyArIHJvdyArICctJyArIGNvbCBdID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cbiAgICB2YXIgcm93ID0gMDtcbiAgICB2YXIgY29sID0gMDtcbiAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbigpe1xuICAgICAgY29sKys7XG4gICAgICBpZiggY29sID49IGNvbHMgKXtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKCBub2RlICk7XG5cbiAgICAgIGlmKCByY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpICl7IC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggcG9zLmNvbCA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgIHBvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgd2hpbGUoIHVzZWQoIHBvcy5yb3csIHBvcy5jb2wgKSApe1xuICAgICAgICAgICAgcG9zLmNvbCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCBwb3Mucm93ID09PSB1bmRlZmluZWQgKXsgLy8gZmluZCB1bnVzZWQgcm93XG4gICAgICAgICAgcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICB3aGlsZSggdXNlZCggcG9zLnJvdywgcG9zLmNvbCApICl7XG4gICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWQybWFuUG9zWyBub2RlLmlkKCkgXSA9IHBvcztcbiAgICAgICAgdXNlKCBwb3Mucm93LCBwb3MuY29sICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBlbGVtZW50ICl7XG4gICAgICB2YXIgeCwgeTtcblxuICAgICAgaWYoIGVsZW1lbnQubG9ja2VkKCkgfHwgZWxlbWVudC5pc1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgaWYoIHJjUG9zICl7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcblxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG5cbiAgICAgICAgd2hpbGUoIHVzZWQoIHJvdywgY29sICkgKXtcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgICB1c2UoIHJvdywgY29sICk7XG5cbiAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuXG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyBuYW1lOiAnYnJlYWR0aGZpcnN0JywgaW1wbDogcmVxdWlyZSggJy4vYnJlYWR0aGZpcnN0JyApIH0sXG4gIHsgbmFtZTogJ2NpcmNsZScsIGltcGw6IHJlcXVpcmUoICcuL2NpcmNsZScgKSB9LFxuICB7IG5hbWU6ICdjb25jZW50cmljJyxpbXBsOiByZXF1aXJlKCAnLi9jb25jZW50cmljJyApIH0sXG4gIHsgbmFtZTogJ2Nvc2UnLCBpbXBsOiByZXF1aXJlKCAnLi9jb3NlJyApIH0sXG4gIHsgbmFtZTogJ2dyaWQnLCBpbXBsOiByZXF1aXJlKCAnLi9ncmlkJyApIH0sXG4gIHsgbmFtZTogJ251bGwnLCBpbXBsOiByZXF1aXJlKCAnLi9udWxsJyApIH0sXG4gIHsgbmFtZTogJ3ByZXNldCcsIGltcGw6IHJlcXVpcmUoICcuL3ByZXNldCcgKSB9LFxuICB7IG5hbWU6ICdyYW5kb20nLCBpbXBsOiByZXF1aXJlKCAnLi9yYW5kb20nICkgfVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKTtcblxuLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xudmFyIGRlZmF1bHRzID0ge1xuICByZWFkeTogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiBmdW5jdGlvbigpe30gLy8gb24gbGF5b3V0c3RvcFxufTtcblxuLy8gY29uc3RydWN0b3Jcbi8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuZnVuY3Rpb24gTnVsbExheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cbi8vIHJ1bnMgdGhlIGxheW91dFxuTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG4gIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gIC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgbGF5b3V0LnRyaWdnZXIoICdsYXlvdXRzdGFydCcgKTtcblxuICAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyggZnVuY3Rpb24oKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9ICk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuICBsYXlvdXQub25lKCAnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5ICk7XG4gIGxheW91dC50cmlnZ2VyKCAnbGF5b3V0cmVhZHknICk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgbGF5b3V0Lm9uZSggJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3AgKTtcbiAgbGF5b3V0LnRyaWdnZXIoICdsYXlvdXRzdG9wJyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vaXMnICk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgcG9zaXRpb25zOiB1bmRlZmluZWQsIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gIHpvb206IHVuZGVmaW5lZCwgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBwYW46IHVuZGVmaW5lZCwgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIFByZXNldExheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG59XG5cblByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBvc0lzRm4gPSBpcy5mbiggb3B0aW9ucy5wb3NpdGlvbnMgKTtcblxuICBmdW5jdGlvbiBnZXRQb3NpdGlvbiggbm9kZSApe1xuICAgIGlmKCBvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiggcG9zSXNGbiApe1xuICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zLmFwcGx5KCBub2RlLCBbIG5vZGUgXSApO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uc1sgbm9kZS5fcHJpdmF0ZS5kYXRhLmlkIF07XG5cbiAgICBpZiggcG9zID09IG51bGwgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24oIG5vZGUgKTtcblxuICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0TGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vbWF0aCcgKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gUmFuZG9tTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbn1cblxuUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoICc6cGFyZW50JyApO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIG5vZGUgKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApXG4gICAgfTtcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21MYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5cbkJScC5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG5cbiAgICB2YXIgaW5zaWRlID0gKHgxIDw9IHggJiYgeCA8PSB4MikgJiYgKHkxIDw9IHkgJiYgeSA8PSB5Mik7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKCBhbmdsZSApIC0geSAqIE1hdGguc2luKCBhbmdsZSApO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbiggYW5nbGUgKSArIHkgKiBNYXRoLmNvcyggYW5nbGUgKTtcblxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uKCBwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICB2YXIgeCA9IHB0c1sgaSBdO1xuICAgICAgdmFyIHkgPSBwdHNbIGkgKyAxXTtcblxuICAgICAgcmV0UHRzLnB1c2goIHRyYW5zZm9ybSggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0UHRzO1xuICB9O1xuXG4gIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uKCBwdHMgKXtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHAgPSBwdHNbIGkgXTtcblxuICAgICAgcmV0LnB1c2goIHAueCwgcC55ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgc3RhbmRhcmRHYXAgPSBmdW5jdGlvbiggZWRnZSApIHtcbiAgICByZXR1cm4gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS5wZlZhbHVlICogMjtcbiAgfTtcblxuICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uKCBuYW1lLCBkZWZuICl7XG4gICAgaWYoIGlzLnN0cmluZyggZGVmbiApICl7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbIGRlZm4gXTtcbiAgICB9XG5cbiAgICBhcnJvd1NoYXBlc1sgbmFtZSBdID0gdXRpbC5leHRlbmQoIHtcbiAgICAgIG5hbWU6IG5hbWUsXG5cbiAgICAgIHBvaW50czogW1xuICAgICAgICAtMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgMC4zLFxuICAgICAgICAtMC4xNSwgMC4zXG4gICAgICBdLFxuXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHBvaW50cyApO1xuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuXG4gICAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoICdwb2x5Z29uJyApKCBjb250ZXh0LCBwb2ludHMgKTtcbiAgICAgIH0sXG5cbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcblxuICAgICAgZ2FwOiBzdGFuZGFyZEdhcFxuICAgIH0sIGRlZm4gKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnbm9uZScsIHtcbiAgICBjb2xsaWRlOiB1dGlsLmZhbHNpZnksXG5cbiAgICByb3VnaENvbGxpZGU6IHV0aWwuZmFsc2lmeSxcblxuICAgIGRyYXc6IHV0aWwubm9vcCxcblxuICAgIHNwYWNpbmc6IHV0aWwuemVyb2lmeSxcblxuICAgIGdhcDogdXRpbC56ZXJvaWZ5XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2Fycm93JywgJ3RyaWFuZ2xlJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sgJ3RyaWFuZ2xlJyBdLnBvaW50cyxcblxuICAgIGNvbnRyb2xQb2ludDogWyAwLCAtMC4xNSBdLFxuXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgIHZhciBjdHJsUHQgPSB0aGlzLmNvbnRyb2xQb2ludDtcbiAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybSggY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyApO1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC45ODU7XG4gICAgfVxuICB9ICk7XG5cblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcblxuICAgIHBvaW50c1RlZTogW1xuICAgICAgLTAuMTUsIC0wLjQsXG4gICAgICAtMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC40XG4gICAgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbiApICk7XG5cbiAgICAgIHZhciBpbnNpZGUgPSBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgdHJpUHRzICkgfHwgbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRlZVB0cyApO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICl7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMgKTtcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgY3Jvc3NMaW5lUG9pbnRzOiBbXG4gICAgICAtMC4yNDE3NSwgLTAuNCxcbiAgICAgIDAuMjQxNzUsIC0wLjQsXG4gICAgXSxcblxuICAgIGZvcmNlU3Ryb2tlOiB0cnVlLFxuXG4gICAgbWF0Y2hFZGdlV2lkdGg6IHRydWUsXG5cbiAgICBzY2FsZUNvb3JkOiBmdW5jdGlvbiAoIGNvbnN0YW50LCBzaXplLCBlZGdlV2lkdGggKXtcbiAgICAgcmV0dXJuIGNvbnN0YW50ICsgKCBlZGdlV2lkdGggKiAwLjAxMiApICsgKCBtYXRoLmxvZzIoIHNpemUgLSAyOC45NSApICogMC4wMDEgKTtcbiAgICB9LFxuXG4gICBzY2FsZUNyb3NzTGluZVhDb29yZDogZnVuY3Rpb24oIHNpemUsIGVkZ2VXaWR0aCApe1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVDb29yZCggMC40Miwgc2l6ZSwgZWRnZVdpZHRoICk7XG4gICAgfSxcblxuICAgIHNjYWxlQ3Jvc3NMaW5lWUNvb3JkOiBmdW5jdGlvbiggc2l6ZSwgZWRnZVdpZHRoICl7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZUNvb3JkKCAtMC4wMSwgc2l6ZSwgZWRnZVdpZHRoICk7XG4gICAgfSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMuY3Jvc3NMaW5lUG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbiApICk7XG5cbiAgICAgIHZhciBpbnNpZGUgPSBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgdHJpUHRzIClcbiAgICAgIHx8IG1hdGguaW5MaW5lVmljaW5pdHkoIHgsIHksXG4gICAgICAgIGNyb3NzTGluZVB0c1swXSwgY3Jvc3NMaW5lUHRzWzFdLCBjcm9zc0xpbmVQdHNbMl0sIGNyb3NzTGluZVB0c1szXSwgcGFkZGluZyApO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGggKXtcbiAgICAgIHZhciBzY2FsZWRDcm9zc0xpbmUgPSBbXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzBdICsgdGhpcy5zY2FsZUNyb3NzTGluZVhDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzFdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVlDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzJdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVhDb29yZCggc2l6ZSwgZWRnZVdpZHRoICksXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUG9pbnRzWzNdIC0gdGhpcy5zY2FsZUNyb3NzTGluZVlDb29yZCggc2l6ZSwgZWRnZVdpZHRoIClcbiAgICAgIF07XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKCBzY2FsZWRDcm9zc0xpbmUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3ZlZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAwLCAtMC4xNVxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjk4NTtcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gKCBNYXRoLnBvdyggdC54IC0geCwgMiApICsgTWF0aC5wb3coIHQueSAtIHksIDIgKSA8PSBNYXRoLnBvdyggKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMiApICk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplICk7XG4gICAgfSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aCggZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSggJ2Fycm93LXNjYWxlJyApLnZhbHVlIClcbiAgICAgICAgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnaW5oaWJpdG9yJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIDAsXG4gICAgICAtMC4xNSwgLTAuMSxcbiAgICAgIDAuMTUsIC0wLjEsXG4gICAgICAwLjE1LCAwXG4gICAgXSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3RlZScsICdpbmhpYml0b3InICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3NxdWFyZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdkaWFtb25kJywge1xuICAgIHBvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjE1LFxuICAgICAgMCwgLTAuMyxcbiAgICAgIDAuMTUsIC0wLjE1LFxuICAgICAgMCwgMFxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZTtcbiAgICB9XG4gIH0gKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIHpJbmRleFNvcnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vY29sbGVjdGlvbi96c29ydCcgKTtcbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vLi4vLi4vd2luZG93JyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24oIGVsZXMsIGUgKXtcbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoIGVsZXMgKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuXG4gICAgICB2YXIgZXZ0cyA9IHJzdHlsZS5kaXJ0eUV2ZW50cyA9IHJzdHlsZS5kaXJ0eUV2ZW50cyB8fCB7IGxlbmd0aDogMCB9O1xuXG4gICAgICBpZiggIWV2dHNbIGUudHlwZSBdICl7XG4gICAgICAgIGV2dHNbIGUudHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgZXZ0cy5sZW5ndGgrKztcbi8vXG4gICAgICAgIC8vIGVsZXNUb1VwZGF0ZS5tZXJnZSggZWxlICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHIuYmluZGVyKCBjeSApXG4gICAgLy8gbm9kZXNcblxuICAgIC5vbigncG9zaXRpb24uKiBzdHlsZS4qIGZyZWUuKicsICdub2RlJywgZnVuY3Rpb24gb25EaXJ0eU1vZE5vZGUoIGUgKXtcbiAgICAgIHZhciBub2RlID0gZS5jeVRhcmdldDtcblxuICAgICAgZW5xdWV1ZSggbm9kZSwgZSApO1xuICAgICAgZW5xdWV1ZSggbm9kZS5jb25uZWN0ZWRFZGdlcygpLCBlICk7XG5cbiAgICAgIGlmKCBjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBub2RlLnBhcmVudHMoKTtcblxuICAgICAgICBlbnF1ZXVlKCBwYXJlbnRzLCBlICk7XG4gICAgICAgIGVucXVldWUoIHBhcmVudHMuY29ubmVjdGVkRWRnZXMoKSwgZSApO1xuICAgICAgfVxuICAgIH0pXG5cbiAgICAub24oJ2FkZC4qIGJhY2tncm91bmQuKicsICdub2RlJywgZnVuY3Rpb24gb25EaXJ0eUFkZE5vZGUoIGUgKXtcbiAgICAgIHZhciBlbGUgPSBlLmN5VGFyZ2V0O1xuXG4gICAgICBlbnF1ZXVlKCBlbGUsIGUgKTtcbiAgICB9KVxuXG4gICAgLy8gZWRnZXNcblxuICAgIC5vbignYWRkLiogc3R5bGUuKicsICdlZGdlJywgZnVuY3Rpb24gb25EaXJ0eUVkZ2UoIGUgKXtcbiAgICAgIHZhciBlZGdlID0gZS5jeVRhcmdldDtcblxuICAgICAgZW5xdWV1ZSggZWRnZSwgZSApO1xuICAgICAgZW5xdWV1ZSggZWRnZS5wYXJhbGxlbEVkZ2VzKCksIGUgKTtcbiAgICB9KVxuXG4gICAgLm9uKCdyZW1vdmUuKicsICdlZGdlJywgZnVuY3Rpb24gb25EaXJ0eVJlbW92ZUVkZ2UoIGUgKXtcbiAgICAgIHZhciBlZGdlID0gZS5jeVRhcmdldDtcbiAgICAgIHZhciBwRWRnZXMgPSBlZGdlLnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHBFZGdlID0gcEVkZ2VzW2ldO1xuXG4gICAgICAgIGlmKCAhcEVkZ2UucmVtb3ZlZCgpICl7XG4gICAgICAgICAgZW5xdWV1ZSggcEVkZ2UsIGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIDtcblxuICB2YXIgdXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiggd2lsbERyYXcgKXtcbiAgICBpZiggd2lsbERyYXcgKXtcbiAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7XG5cbiAgICAgIGlmKCBmbnMgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuID0gZm5zW2ldO1xuXG4gICAgICAgIGZuKCB3aWxsRHJhdywgZWxlc1RvVXBkYXRlICk7XG4gICAgICB9IH1cblxuICAgICAgci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIGVsZXNUb1VwZGF0ZSwgZmFsc2UgKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9VcGRhdGUubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZWxlc1RvVXBkYXRlW2ldLl9wcml2YXRlLnJzdHlsZS5kaXJ0eUV2ZW50cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgci5iZWZvcmVSZW5kZXIoIHVwZGF0ZUVsZUNhbGNzLCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlQ2FsY3MgKTtcbn07XG5cbkJScC5vblVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24oIGZuICl7XG4gIHZhciBmbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgfHwgW107XG5cbiAgZm5zLnB1c2goIGZuICk7XG59O1xuXG5CUnAucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZXMsIHVzZUNhY2hlICl7XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgdXNlZCBmb3IgY2FsY3Mgd2hlbiBkZXN0cm95ZWQsIGUuZy4gZWxlLmJvdW5kaW5nQm94KClcbiAgaWYoIHRoaXMuZGVzdHJveWVkICl7IHJldHVybjsgfVxuXG4gIC8vIHVzZSBjYWNoZSBieSBkZWZhdWx0IGZvciBwZXJmXG4gIGlmKCB1c2VDYWNoZSA9PT0gdW5kZWZpbmVkICl7IHVzZUNhY2hlID0gdHJ1ZTsgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcbiAgICBpZiggKHVzZUNhY2hlICYmIHJzdHlsZS5jbGVhbikgfHwgZWxlLnJlbW92ZWQoKSApeyBjb250aW51ZTsgfVxuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgbm90IGRpc3BsYXk6IG5vbmVcbiAgICBpZiggZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScgKXsgY29udGludWU7IH1cblxuICAgIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgfSBlbHNlIHsgLy8gZWRnZXNcbiAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgIH1cblxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gICAgLy8gcnN0eWxlLmRpcnR5RXZlbnRzID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBub2RlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcblxuICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBlbGUgKTtcblxuICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIHJzdHlsZS5ub2RlVyA9IGVsZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlO1xuICAgIHJzdHlsZS5ub2RlSCA9IGVsZS5wc3R5bGUoICdoZWlnaHQnICkucGZWYWx1ZTtcbiAgfVxuXG4gIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoIGVkZ2VzICk7XG5cbiAgLy8gdXBkYXRlIGVkZ2UgZGF0YSBmcm9tIHByb2plY3Rpb25zXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWRnZXNbIGkgXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyggZWxlICk7XG5cbiAgICAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuICAgIHJzdHlsZS5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgcnN0eWxlLnNyY1kgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICByc3R5bGUudGd0WCA9IHJzLmFycm93RW5kWDtcbiAgICByc3R5bGUudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICByc3R5bGUubWlkWCA9IHJzLm1pZFg7XG4gICAgcnN0eWxlLm1pZFkgPSBycy5taWRZO1xuICAgIHJzdHlsZS5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICByc3R5bGUuc291cmNlTGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnRhcmdldExhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlO1xuICB9XG59O1xuXG4vLyBQcm9qZWN0IG1vdXNlXG5CUnAucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uKCBjbGllbnRYLCBjbGllbnRZICl7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgdmFyIHggPSAoIGNsaWVudFggLSBvZmZzZXRMZWZ0IC0gcGFuLnggKSAvIHpvb207XG4gIHZhciB5ID0gKCBjbGllbnRZIC0gb2Zmc2V0VG9wIC0gcGFuLnkgKSAvIHpvb207XG5cbiAgcmV0dXJuIFsgeCwgeSBdO1xufTtcblxuQlJwLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbigpe1xuICBpZiggdGhpcy5jb250YWluZXJCQiApe1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGNvbnRhaW5lciApO1xuICB2YXIgc3R5bGVWYWx1ZSA9IGZ1bmN0aW9uKCBuYW1lICl7IHJldHVybiBwYXJzZUZsb2F0KCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgKTsgfTtcbiAgdmFyIGV4dHJhID0ge1xuICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctbGVmdCcpICsgc3R5bGVWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpICsgc3R5bGVWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdwYWRkaW5nLXRvcCcpICsgc3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpLFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgncGFkZGluZy1ib3R0b20nKSArIHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICB9O1xuXG4gIHJldHVybiAoIHRoaXMuY29udGFpbmVyQkIgPSBbIC8vIHgsIHksIHcsIGhcbiAgICByZWN0LmxlZnQgKyBleHRyYS5sZWZ0LFxuICAgIHJlY3QudG9wICsgZXh0cmEudG9wLFxuICAgIHJlY3QucmlnaHQgLSByZWN0LmxlZnQgLSBleHRyYS5sZWZ0IC0gZXh0cmEucmlnaHQsXG4gICAgcmVjdC5ib3R0b20gLSByZWN0LnRvcCAtIGV4dHJhLnRvcCAtIGV4dHJhLmJvdHRvbVxuICBdICk7XG59O1xuXG5CUnAuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuXG5CUnAuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24oIHgsIHksIGlzVG91Y2ggKXtcbiAgcmV0dXJuIHRoaXMuZmluZE5lYXJlc3RFbGVtZW50cyggeCwgeSwgaXNUb3VjaCApWzBdO1xufTtcblxuQlJwLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiggeCwgeSwgaXNUb3VjaCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBuZWFyID0gW107IC8vIDEgbm9kZSBtYXgsIDEgZWRnZSBtYXhcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IHIuY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjQgOiA4KSAvIHpvb207XG4gIHZhciBub2RlVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbGFiZWxUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBtaW5TcURpc3QgPSBJbmZpbml0eTtcbiAgdmFyIG5lYXJFZGdlO1xuICB2YXIgbmVhck5vZGU7XG5cbiAgZnVuY3Rpb24gYWRkRWxlKCBlbGUsIHNxRGlzdCApe1xuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGlmKCBuZWFyTm9kZSApe1xuICAgICAgICByZXR1cm47IC8vIGNhbid0IHJlcGxhY2Ugbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhck5vZGUgPSBlbGU7XG4gICAgICAgIG5lYXIucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSAmJiAoIHNxRGlzdCA9PSBudWxsIHx8IHNxRGlzdCA8IG1pblNxRGlzdCApICl7XG4gICAgICBpZiggbmVhckVkZ2UgKXsgLy8gdGhlbiByZXBsYWNlIGV4aXN0aW5nIGVkZ2VcbiAgICAgICAgLy8gY2FuIHJlcGxhY2Ugb25seSBpZiBzYW1lIHotaW5kZXhcbiAgICAgICAgaWYoIG5lYXJFZGdlLnBzdHlsZSggJ3otaW5kZXgnICkudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVhci5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgaWYoIG5lYXJbaV0uaXNFZGdlKCkgKXtcbiAgICAgICAgICAgICAgbmVhcltpXSA9IGVsZTtcbiAgICAgICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXIucHVzaCggZWxlICk7XG4gICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja05vZGUoIG5vZGUgKXtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuXG4gICAgaWYoIG5vZGUucHN0eWxlKCAnZXZlbnRzJyApLnN0clZhbHVlID09PSAnbm8nICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuXG4gICAgaWYoXG4gICAgICBwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICAgJiZcbiAgICAgIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICl7XG4gICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbIHNlbGYuZ2V0Tm9kZVNoYXBlKCBub2RlICkgXTtcblxuICAgICAgaWYoXG4gICAgICAgIHNoYXBlLmNoZWNrUG9pbnQoIHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSApXG4gICAgICApe1xuICAgICAgICBhZGRFbGUoIG5vZGUsIDAgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2UgKXtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuXG4gICAgaWYoIGVkZ2UucHN0eWxlKCdldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ25vJyApeyByZXR1cm47IH1cblxuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBzdHlsZVdpZHRoID0gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkudmFsdWU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIGluRWRnZUJCID0gZmFsc2U7XG4gICAgdmFyIHNxRGlzdDtcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICAgIGlmKFxuICAgICAgICAgIChpbkVkZ2VCQiA9IG1hdGguaW5MaW5lVmljaW5pdHkoIHgsIHksIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSwgcHRzWyBpICsgMl0sIHB0c1sgaSArIDNdLCB3aWR0aDIgKSlcbiAgICAgICAgICAgICYmXG4gICAgICAgICAgd2lkdGhTcSA+ICggc3FEaXN0ID0gbWF0aC5zcWRpc3RUb0Zpbml0ZUxpbmUoIHgsIHksIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSwgcHRzWyBpICsgMl0sIHB0c1sgaSArIDNdICkgKVxuICAgICAgICApe1xuICAgICAgICAgIGFkZEVsZSggZWRnZSwgc3FEaXN0ICk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgKXtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gbWF0aC5pbkJlemllclZpY2luaXR5KCB4LCB5LCBwdHNbIGkgXSwgcHRzWyBpICsgMV0sIHB0c1sgaSArIDJdLCBwdHNbIGkgKyAzXSwgcHRzWyBpICsgNF0sIHB0c1sgaSArIDVdLCB3aWR0aDIgKSlcbiAgICAgICAgICAgICYmXG4gICAgICAgICAgKHdpZHRoU3EgPiAoc3FEaXN0ID0gbWF0aC5zcWRpc3RUb1F1YWRyYXRpY0JlemllciggeCwgeSwgcHRzWyBpIF0sIHB0c1sgaSArIDFdLCBwdHNbIGkgKyAyXSwgcHRzWyBpICsgM10sIHB0c1sgaSArIDRdLCBwdHNbIGkgKyA1XSApKSApXG4gICAgICAgICl7XG4gICAgICAgICAgYWRkRWxlKCBlZGdlLCBzcURpc3QgKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBlZGdlIGJ1dCBkaWRuJ3QgaGl0IGl0LCBtYXliZSB3ZSBoaXQgaXRzIGFycm93c1xuXG4gICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IHRndCB8fCBfcC50YXJnZXQ7XG5cbiAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKCBzdHlsZVdpZHRoLCBzY2FsZSApO1xuXG4gICAgdmFyIGFycm93cyA9IFtcbiAgICAgIHsgbmFtZTogJ3NvdXJjZScsIHg6IHJzLmFycm93U3RhcnRYLCB5OiBycy5hcnJvd1N0YXJ0WSwgYW5nbGU6IHJzLnNyY0Fycm93QW5nbGUgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldCcsIHg6IHJzLmFycm93RW5kWCwgeTogcnMuYXJyb3dFbmRZLCBhbmdsZTogcnMudGd0QXJyb3dBbmdsZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZScsIHg6IHJzLm1pZFgsIHk6IHJzLm1pZFksIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0JywgeDogcnMubWlkWCwgeTogcnMubWlkWSwgYW5nbGU6IHJzLm1pZHRndEFycm93QW5nbGUgfVxuICAgIF07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGFyID0gYXJyb3dzWyBpIF07XG4gICAgICB2YXIgc2hhcGUgPSByLmFycm93U2hhcGVzWyBlZGdlLnBzdHlsZSggYXIubmFtZSArICctYXJyb3ctc2hhcGUnICkudmFsdWUgXTtcblxuICAgICAgaWYoXG4gICAgICAgIHNoYXBlLnJvdWdoQ29sbGlkZSggeCwgeSwgYXJTaXplLCBhci5hbmdsZSwgeyB4OiBhci54LCB5OiBhci55IH0sIGVkZ2VUaHJlc2hvbGQgKVxuICAgICAgICAgJiZcbiAgICAgICAgc2hhcGUuY29sbGlkZSggeCwgeSwgYXJTaXplLCBhci5hbmdsZSwgeyB4OiBhci54LCB5OiBhci55IH0sIGVkZ2VUaHJlc2hvbGQgKVxuICAgICAgKXtcbiAgICAgICAgYWRkRWxlKCBlZGdlICk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuICAgIGlmKCBoYXNDb21wb3VuZHMgJiYgbmVhci5sZW5ndGggPiAwICl7XG4gICAgICBjaGVja05vZGUoIHNyYyApO1xuICAgICAgY2hlY2tOb2RlKCB0Z3QgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwcm9wKCBvYmosIG5hbWUsIHByZSApe1xuICAgIHJldHVybiB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIG9iaiwgbmFtZSwgcHJlICk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0xhYmVsKCBlbGUsIHByZWZpeCApe1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcblxuICAgIHZhciBwcmVmaXhEYXNoO1xuICAgIGlmKCBwcmVmaXggKXtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUoIHByZWZpeERhc2ggKyAnbGFiZWwnICkudmFsdWU7XG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSBlbGUucHN0eWxlKCAndGV4dC1ldmVudHMnICkuc3RyVmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgaWYoICFldmVudHNFbmFibGVkIHx8ICF0ZXh0ICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgYncgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIHB3ID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBsdyA9IHByZXByb3AoIHJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXggKSArIGJ3ICsgMip0aCArIDIqcHc7XG4gICAgdmFyIGxoID0gcHJlcHJvcCggcnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXggKSArIGJ3ICsgMip0aCArIDIqcHc7XG4gICAgdmFyIGx4ID0gcHJlcHJvcCggcnN0eWxlLCAnbGFiZWxYJywgcHJlZml4ICk7XG4gICAgdmFyIGx5ID0gcHJlcHJvcCggcnN0eWxlLCAnbGFiZWxZJywgcHJlZml4ICk7XG5cbiAgICB2YXIgdGhldGEgPSBwcmVwcm9wKCBfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXggKTtcblxuICAgIHZhciBseDEgPSBseCAtIGx3IC8gMjtcbiAgICB2YXIgbHgyID0gbHggKyBsdyAvIDI7XG4gICAgdmFyIGx5MSA9IGx5IC0gbGggLyAyO1xuICAgIHZhciBseTIgPSBseSArIGxoIC8gMjtcblxuICAgIGlmKCB0aGV0YSApe1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24oIHgsIHkgKXtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgbHgsXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBseVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKCBseDEsIGx5MSApO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKCBseDEsIGx5MiApO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKCBseDIsIGx5MSApO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKCBseDIsIGx5MiApO1xuXG4gICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICBweDF5MS54LCBweDF5MS55LFxuICAgICAgICBweDJ5MS54LCBweDJ5MS55LFxuICAgICAgICBweDJ5Mi54LCBweDJ5Mi55LFxuICAgICAgICBweDF5Mi54LCBweDF5Mi55XG4gICAgICBdO1xuXG4gICAgICBpZiggbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHBvaW50cyApICl7XG4gICAgICAgIGFkZEVsZSggZWxlICk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGRvIGEgY2hlYXBlciBiYiBjaGVja1xuICAgICAgdmFyIGJiID0ge1xuICAgICAgICB3OiBsdyxcbiAgICAgICAgaDogbGgsXG4gICAgICAgIHgxOiBseDEsXG4gICAgICAgIHgyOiBseDIsXG4gICAgICAgIHkxOiBseTEsXG4gICAgICAgIHkyOiBseTJcbiAgICAgIH07XG5cbiAgICAgIGlmKCBtYXRoLmluQm91bmRpbmdCb3goIGJiLCB4LCB5ICkgKXtcbiAgICAgICAgYWRkRWxlKCBlbGUgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBmb3IoIHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApeyAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGNoZWNrTm9kZSggZWxlICkgfHwgY2hlY2tMYWJlbCggZWxlICk7XG5cbiAgICB9IGVsc2UgeyAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZSggZWxlICkgfHwgY2hlY2tMYWJlbCggZWxlICkgfHwgY2hlY2tMYWJlbCggZWxlLCAnc291cmNlJyApIHx8IGNoZWNrTGFiZWwoIGVsZSwgJ3RhcmdldCcgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcjtcbn07XG5cbi8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcbkJScC5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcztcbiAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcztcbiAgdmFyIGJveCA9IFtdO1xuXG4gIHZhciB4MWMgPSBNYXRoLm1pbiggeDEsIHgyICk7XG4gIHZhciB4MmMgPSBNYXRoLm1heCggeDEsIHgyICk7XG4gIHZhciB5MWMgPSBNYXRoLm1pbiggeTEsIHkyICk7XG4gIHZhciB5MmMgPSBNYXRoLm1heCggeTEsIHkyICk7XG5cbiAgeDEgPSB4MWM7XG4gIHgyID0geDJjO1xuICB5MSA9IHkxYztcbiAgeTIgPSB5MmM7XG5cbiAgdmFyIGJveEJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIHtcbiAgICB4MTogeDEsIHkxOiB5MSxcbiAgICB4MjogeDIsIHkyOiB5MlxuICB9ICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBub2RlID0gbm9kZXNbIGkgXTtcbiAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCgge1xuICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVNoYWRvd3M6IGZhbHNlXG4gICAgfSApO1xuXG4gICAgaWYoIG1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCggYm94QmIsIG5vZGVCYiApICl7XG4gICAgICBib3gucHVzaCggbm9kZXNbIGkgXSApO1xuICAgIH1cbiAgfVxuXG4gIGZvciggdmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKysgKXtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzWyBlIF07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgIGlmKCBycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KCBib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkgKSApeyBjb250aW51ZTsgfVxuICAgIGlmKCBycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFtYXRoLmluQm91bmRpbmdCb3goIGJveEJiLCBycy5lbmRYLCBycy5lbmRZICkgKXsgY29udGludWU7IH1cblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuXG4gICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICB2YXIgYWxsSW5zaWRlID0gdHJ1ZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoICFtYXRoLnBvaW50SW5Cb3VuZGluZ0JveCggYm94QmIsIHB0c1sgaSBdICkgKXtcbiAgICAgICAgICBhbGxJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggYWxsSW5zaWRlICl7XG4gICAgICAgIGJveC5wdXNoKCBlZGdlICk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnICl7XG4gICAgICBib3gucHVzaCggZWRnZSApO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGJveDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaGFwZSBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgZ2l2ZW4gbm9kZVxuICogaXMgc2V0IHRvIGF1dG8sIHRoZSBub2RlIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBjb21wb3VuZC5cbiAqXG4gKiBAcGFyYW0gbm9kZSAgICAgICAgICBhIG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIHNoYXBlIG9mIHRoZSBub2RlXG4gKi9cbkJScC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiggbm9kZSApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCAnc2hhcGUnICkudmFsdWU7XG5cbiAgaWYoIG5vZGUuaXNQYXJlbnQoKSApe1xuICAgIGlmKCBzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgKXtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBzaGFwZSA9PT0gJ3BvbHlnb24nICl7XG4gICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCAnc2hhcGUtcG9seWdvbi1wb2ludHMnICkudmFsdWU7XG5cbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKCBwb2ludHMgKS5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuQlJwLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuXG4gIGlmKCAhZWxlcyApe1xuICAgIC8vIGp1c3QgbGV0IHRoaXMgYmUgcmVjYWxjdWxhdGVkIG9uIHRoZSBuZXh0IHogc29ydCB0aWNrXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlcy5kcmFnID0gW107XG4gIGVsZXMubm9uZHJhZyA9IFtdO1xuXG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmKCBlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgZ3JhYlRhcmdldHMucHVzaCggZWxlICk7XG4gICAgfSBlbHNlIGlmKCBycy5pbkRyYWdMYXllciApe1xuICAgICAgZWxlcy5kcmFnLnB1c2goIGVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzLm5vbmRyYWcucHVzaCggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZ3JhYlRhcmdldHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZ3JhYlRhcmdldHNbaV07XG5cbiAgICBlbGVzLmRyYWcucHVzaCggZWxlICk7XG4gIH1cbn07XG5cbkJScC5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbn07XG5cbkJScC5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCBmb3JjZVJlY2FsYyApe1xuICBpZiggZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgKXtcbiAgICB2YXIgY3lFbGVzID0gdGhpcy5jeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB2YXIgZWxlcyA9IFtdO1xuXG4gICAgZWxlcy5ub2RlcyA9IFtdO1xuICAgIGVsZXMuZWRnZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY3lFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gY3lFbGVzW2ldO1xuXG4gICAgICBpZiggZWxlLmFuaW1hdGVkKCkgfHwgKGVsZS52aXNpYmxlKCkgJiYgIWVsZS50cmFuc3BhcmVudCgpKSApe1xuICAgICAgICBlbGVzLnB1c2goIGVsZSApO1xuXG4gICAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICBlbGVzLm5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZXMuZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVzLnNvcnQoIHpJbmRleFNvcnQgKTtcblxuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuXG4gICAgdGhpcy51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9IGVsc2Uge1xuICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICB9XG5cbiAgcmV0dXJuIGVsZXM7XG59O1xuXG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKCByLCBlZGdlLCBwdHMgKXtcbiAgdmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uKCBwMSwgcDIsIHAzLCB0ICl7IHJldHVybiBtYXRoLnFiZXppZXJBdCggcDEsIHAyLCBwMywgdCApOyB9O1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuXG4gICAgYnB0cy5wdXNoKCB7XG4gICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIHAgKSxcbiAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcCApXG4gICAgfSApO1xuICB9XG59XG5cbkJScC5wcm9qZWN0TGluZXMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICBpZiggZXQgPT09ICdtdWx0aWJlemllcicgfHwgIGV0ID09PSAnYmV6aWVyJyB8fCAgZXQgPT09ICdzZWxmJyB8fCAgZXQgPT09ICdjb21wb3VuZCcgKXtcbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZSggaSwgaSArIDYgKSApO1xuICAgIH1cbiAgfSBlbHNlIGlmKCAgZXQgPT09ICdzZWdtZW50cycgKXtcbiAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDEgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgIGxwdHMucHVzaCgge1xuICAgICAgICB4OiBycy5hbGxwdHNbIGkgXSxcbiAgICAgICAgeTogcnMuYWxscHRzWyBpICsgMV1cbiAgICAgIH0gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggZXQgPT09ICdoYXlzdGFjaycgKXtcbiAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuXG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW1xuICAgICAgeyB4OiBocHRzWzBdLCB5OiBocHRzWzFdIH0sXG4gICAgICB7IHg6IGhwdHNbMl0sIHk6IGhwdHNbM10gfVxuICAgIF07XG4gIH1cblxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZSApXG4gICAgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5cbkJScC5wcm9qZWN0QmV6aWVyID0gQlJwLnByb2plY3RMaW5lcztcblxuQlJwLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBub2RlICl7XG4gIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoICdsYWJlbCcgKS5zdHJWYWx1ZTtcblxuICBpZiggaXMuZW1wdHlTdHJpbmcoY29udGVudCkgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZyA9IG5vZGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgdmFyIG5vZGVQb3MgPSBfcC5wb3NpdGlvbjtcbiAgdmFyIHRleHRIYWxpZ24gPSBub2RlLnBzdHlsZSggJ3RleHQtaGFsaWduJyApLnN0clZhbHVlO1xuICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUucHN0eWxlKCAndGV4dC12YWxpZ24nICkuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICB9XG5cbiAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6IC8vIGUuZy4gbWlkZGxlXG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueTtcbiAgfVxuXG4gIHJzLmxhYmVsWCA9IHRleHRYO1xuICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG5cbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyggbm9kZSApO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgcDtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRlbnQgPSB7XG4gICAgbWlkOiBlZGdlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICBzb3VyY2U6IGVkZ2UucHN0eWxlKCdzb3VyY2UtbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICB0YXJnZXQ6IGVkZ2UucHN0eWxlKCd0YXJnZXQtbGFiZWwnKS5zdHJWYWx1ZVxuICB9O1xuXG4gIGlmKCBjb250ZW50Lm1pZCB8fCBjb250ZW50LnNvdXJjZSB8fCBjb250ZW50LnRhcmdldCApe1xuICAgIC8vIHRoZW4gd2UgaGF2ZSB0byBjYWxjdWxhdGUuLi5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47IC8vIG5vIGxhYmVscyA9PiBubyBjYWxjc1xuICB9XG5cbiAgLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgLy9cbiAgcCA9IHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcblxuICB2YXIgc2V0UnMgPSBmdW5jdGlvbiggcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUgKXtcbiAgICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSApO1xuICAgIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnN0eWxlLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSApO1xuICB9O1xuXG4gIHNldFJzKCAnbGFiZWxYJywgbnVsbCwgcC54ICk7XG4gIHNldFJzKCAnbGFiZWxZJywgbnVsbCwgcC55ICk7XG5cbiAgdmFyIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8gPSBmdW5jdGlvbigpe1xuICAgIGlmKCBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlICl7IHJldHVybiBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlOyB9IC8vIHVzZSBjYWNoZSBzbyBvbmx5IDF4IHBlciBlZGdlXG5cbiAgICB2YXIgY3RybHB0cyA9IFtdO1xuXG4gICAgLy8gc3RvcmUgZWFjaCBjdHJscHQgaW5mbyBpbml0XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICB2YXIgcDAgPSB7IHg6IHJzLmFsbHB0c1tpXSwgeTogcnMuYWxscHRzW2krMV0gfTtcbiAgICAgIHZhciBwMSA9IHsgeDogcnMuYWxscHRzW2krMl0sIHk6IHJzLmFsbHB0c1tpKzNdIH07IC8vIGN0cmxwdFxuICAgICAgdmFyIHAyID0geyB4OiBycy5hbGxwdHNbaSs0XSwgeTogcnMuYWxscHRzW2krNV0gfTtcblxuICAgICAgY3RybHB0cy5wdXNoKHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDEsXG4gICAgICAgIHAyOiBwMixcbiAgICAgICAgc3RhcnREaXN0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuICAgIHZhciBuUHJvanMgPSByLmJlemllclByb2pQY3RzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnQoIGNwLCBwMCwgcDEsIHQwLCB0MSApe1xuICAgICAgdmFyIGxlbmd0aCA9IG1hdGguZGlzdCggcDAsIHAxICk7XG4gICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1sgY3Auc2VnbWVudHMubGVuZ3RoIC0gMSBdO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQxOiB0MSxcbiAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBjcC5zZWdtZW50cy5wdXNoKCBzZWdtZW50ICk7XG5cbiAgICAgIGNwLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGVhY2ggY3RybHB0IHdpdGggc2VnbWVudCBpbmZvXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjdHJscHRzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY3AgPSBjdHJscHRzW2ldO1xuICAgICAgdmFyIHByZXZDcCA9IGN0cmxwdHNbaSAtIDFdO1xuXG4gICAgICBpZiggcHJldkNwICl7XG4gICAgICAgIGNwLnN0YXJ0RGlzdCA9IHByZXZDcC5zdGFydERpc3QgKyBwcmV2Q3AubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KFxuICAgICAgICBjcCxcbiAgICAgICAgY3AucDAsICAgYnB0c1sgaSAqIG5Qcm9qcyBdLFxuICAgICAgICAwLCAgICAgICByLmJlemllclByb2pQY3RzWyAwIF1cbiAgICAgICk7IC8vIGZpcnN0XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrICl7XG4gICAgICAgIGFkZFNlZ21lbnQoXG4gICAgICAgICAgY3AsXG4gICAgICAgICAgYnB0c1sgaSAqIG5Qcm9qcyArIGogXSwgICBicHRzWyBpICogblByb2pzICsgaiArIDEgXSxcbiAgICAgICAgICByLmJlemllclByb2pQY3RzWyBqIF0sICAgIHIuYmV6aWVyUHJvalBjdHNbIGogKyAxIF1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYWRkU2VnbWVudChcbiAgICAgICAgY3AsXG4gICAgICAgIGJwdHNbIGkgKiBuUHJvanMgKyBuUHJvanMgLSAxIF0sICAgY3AucDIsXG4gICAgICAgIHIuYmV6aWVyUHJvalBjdHNbIG5Qcm9qcyAtIDEgXSwgICAgMVxuICAgICAgKTsgLy8gbGFzdFxuICAgIH1cblxuICAgIHJldHVybiAoIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUgPSBjdHJscHRzICk7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgdmFyIGFuZ2xlO1xuICAgIHZhciBpc1NyYyA9IHByZWZpeCA9PT0gJ3NvdXJjZSc7XG5cbiAgICBpZiggIWNvbnRlbnRbIHByZWZpeCBdICl7IHJldHVybjsgfVxuXG4gICAgdmFyIG9mZnNldCA9IGVkZ2UucHN0eWxlKHByZWZpeCsnLXRleHQtb2Zmc2V0JykucGZWYWx1ZTtcblxuICAgIHZhciBsaW5lQW5nbGUgPSBmdW5jdGlvbiggcDAsIHAxICl7XG4gICAgICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgICAgIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuXG4gICAgICByZXR1cm4gTWF0aC5hdGFuKCBkeSAvIGR4ICk7XG4gICAgfTtcblxuICAgIHZhciBiZXppZXJBbmdsZSA9IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCB0ICl7XG4gICAgICB2YXIgdDAgPSBtYXRoLmJvdW5kKCAwLCB0IC0gMC4wMDEsIDEgKTtcbiAgICAgIHZhciB0MSA9IG1hdGguYm91bmQoIDAsIHQgKyAwLjAwMSwgMSApO1xuXG4gICAgICB2YXIgbHAwID0gbWF0aC5xYmV6aWVyUHRBdCggcDAsIHAxLCBwMiwgdDAgKTtcbiAgICAgIHZhciBscDEgPSBtYXRoLnFiZXppZXJQdEF0KCBwMCwgcDEsIHAyLCB0MSApO1xuXG4gICAgICByZXR1cm4gbGluZUFuZ2xlKCBscDAsIGxwMSApO1xuICAgIH07XG5cbiAgICBzd2l0Y2goIHJzLmVkZ2VUeXBlICl7XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIHZhciBjcHMgPSBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IDA7XG4gICAgICAgIHZhciB0b3RhbERpc3QgPSAwO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHNlZ21lbnQgd2UncmUgb25cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgY3AgPSBjcHNbIGlzU3JjID8gaSA6IGNwcy5sZW5ndGggLSAxIC0gaSBdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjcC5zZWdtZW50cy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHNlZyA9IGNwLnNlZ21lbnRzWyBpc1NyYyA/IGogOiBjcC5zZWdtZW50cy5sZW5ndGggLSAxIC0gaiBdO1xuICAgICAgICAgICAgdmFyIGxhc3RTZWcgPSBpID09PSBjcHMubGVuZ3RoIC0gMSAmJiBqID09PSBjcC5zZWdtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICBzdGFydERpc3QgPSB0b3RhbERpc3Q7XG4gICAgICAgICAgICB0b3RhbERpc3QgKz0gc2VnLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYoIHRvdGFsRGlzdCA+PSBvZmZzZXQgfHwgbGFzdFNlZyApe1xuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHsgY3A6IGNwLCBzZWdtZW50OiBzZWcgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHNlbGVjdGVkICl7IGJyZWFrOyB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3AgPSBzZWxlY3RlZC5jcDtcbiAgICAgICAgdmFyIHNlZyA9IHNlbGVjdGVkLnNlZ21lbnQ7XG4gICAgICAgIHZhciB0U2VnbWVudCA9ICggb2Zmc2V0IC0gc3RhcnREaXN0ICkgLyAoIHNlZy5sZW5ndGggKTtcbiAgICAgICAgdmFyIHNlZ0R0ID0gc2VnLnQxIC0gc2VnLnQwO1xuICAgICAgICB2YXIgdCA9IGlzU3JjID8gc2VnLnQwICsgc2VnRHQgKiB0U2VnbWVudCA6IHNlZy50MSAtIHNlZ0R0ICogdFNlZ21lbnQ7XG5cbiAgICAgICAgdCA9IG1hdGguYm91bmQoIDAsIHQsIDEgKTtcbiAgICAgICAgcCA9IG1hdGgucWJlemllclB0QXQoIGNwLnAwLCBjcC5wMSwgY3AucDIsIHQgKTtcbiAgICAgICAgYW5nbGUgPSBiZXppZXJBbmdsZSggY3AucDAsIGNwLnAxLCBjcC5wMiwgdCwgcCApO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHZhciBkID0gMCwgZGksIGQwO1xuICAgICAgICB2YXIgcDAsIHAxO1xuICAgICAgICB2YXIgbCA9IHJzLmFsbHB0cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgKyAzIDwgbDsgaSArPSAyICl7XG4gICAgICAgICAgaWYoIGlzU3JjICl7XG4gICAgICAgICAgICBwMCA9IHsgeDogcnMuYWxscHRzW2ldLCAgICAgeTogcnMuYWxscHRzW2krMV0gfTtcbiAgICAgICAgICAgIHAxID0geyB4OiBycy5hbGxwdHNbaSsyXSwgICB5OiBycy5hbGxwdHNbaSszXSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwMCA9IHsgeDogcnMuYWxscHRzW2wtMi1pXSwgeTogcnMuYWxscHRzW2wtMS1pXSB9O1xuICAgICAgICAgICAgcDEgPSB7IHg6IHJzLmFsbHB0c1tsLTQtaV0sIHk6IHJzLmFsbHB0c1tsLTMtaV0gfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaSA9IG1hdGguZGlzdCggcDAsIHAxICk7XG4gICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgIGQgKz0gZGk7XG5cbiAgICAgICAgICBpZiggZCA+PSBvZmZzZXQgKXsgYnJlYWs7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuICAgICAgICB2YXIgdCA9IHBEIC8gZGk7XG5cbiAgICAgICAgdCAgPSBtYXRoLmJvdW5kKCAwLCB0LCAxICk7XG4gICAgICAgIHAgPSBtYXRoLmxpbmVBdCggcDAsIHAxLCB0ICk7XG4gICAgICAgIGFuZ2xlID0gbGluZUFuZ2xlKCBwMCwgcDEgKTtcblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzZXRScyggJ2xhYmVsWCcsIHByZWZpeCwgcC54ICk7XG4gICAgc2V0UnMoICdsYWJlbFknLCBwcmVmaXgsIHAueSApO1xuICAgIHNldFJzKCAnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlICk7XG4gIH07XG5cbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiggJ3NvdXJjZScgKTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiggJ3RhcmdldCcgKTtcblxuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBlZGdlICk7XG59O1xuXG5CUnAuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlICl7XG4gIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyggZWxlICk7XG5cbiAgaWYoIGVsZS5pc0VkZ2UoKSApe1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyggZWxlLCAnc291cmNlJyApO1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyggZWxlLCAndGFyZ2V0JyApO1xuICB9XG59O1xuXG5CUnAuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUsIHByZWZpeCApe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlLCBwcmVmaXggKTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRleHQgKTtcblxuICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzdHlsZSwgICAnbGFiZWxXaWR0aCcsIHByZWZpeCwgbGFiZWxEaW1zLndpZHRoICk7XG4gIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4LCBsYWJlbERpbXMud2lkdGggKTtcblxuICB1dGlsLnNldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzdHlsZSwgICAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGxhYmVsRGltcy5oZWlnaHQgKTtcbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KCBfcC5yc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBsYWJlbERpbXMuaGVpZ2h0ICk7XG59O1xuXG5CUnAuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24oIGVsZSwgcHJlZml4ICl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHBmZCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUoIHBmZCArICdsYWJlbCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRUcmFuc2Zvcm0gPSBlbGUucHN0eWxlKCAndGV4dC10cmFuc2Zvcm0nICkudmFsdWU7XG4gIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uKCBwcm9wTmFtZSwgdmFsdWUgKXtcbiAgICBpZiggdmFsdWUgKXtcbiAgICAgIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSggX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlICk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4ICk7XG4gICAgfVxuICB9O1xuXG4gIGlmKCB0ZXh0VHJhbnNmb3JtID09ICdub25lJyApe1xuICAgIC8vIHBhc3N0aHJvdWdoXG4gIH0gZWxzZSBpZiggdGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJyApe1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiggdGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJyApe1xuICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSggJ3RleHQtd3JhcCcgKS52YWx1ZTtcblxuICBpZiggd3JhcFN0eWxlID09PSAnd3JhcCcgKXtcbiAgICAvL2NvbnNvbGUubG9nKCd3cmFwJyk7XG5cbiAgICB2YXIgbGFiZWxLZXkgPSByc2NyYXRjaCggJ2xhYmVsS2V5JyApO1xuXG4gICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmKCBsYWJlbEtleSAmJiByc2NyYXRjaCggJ2xhYmVsV3JhcEtleScgKSA9PT0gbGFiZWxLZXkgKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIGhpdCcpO1xuICAgICAgcmV0dXJuIHJzY3JhdGNoKCAnbGFiZWxXcmFwQ2FjaGVkVGV4dCcgKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3dyYXAgY2FjaGUgbWlzcycpO1xuXG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCggJ1xcbicgKTtcbiAgICB2YXIgbWF4VyA9IGVsZS5wc3R5bGUoICd0ZXh0LW1heC13aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKysgKXtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbIGwgXTtcbiAgICAgIHZhciBsaW5lRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIGxpbmUsICdsaW5lPScgKyBsaW5lICk7XG4gICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcblxuICAgICAgaWYoIGxpbmVXID4gbWF4VyApeyAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQoIC9cXHMrLyApOyAvLyBOQjogYXNzdW1lIGNvbGxhcHNlZCB3aGl0ZXNwYWNlIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgZm9yKCB2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKyApe1xuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbIHcgXTtcbiAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgJyAnICsgd29yZDtcbiAgICAgICAgICB2YXIgdGVzdERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXN0TGluZSwgJ3Rlc3RMaW5lPScgKyB0ZXN0TGluZSApO1xuICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgaWYoIHRlc3RXIDw9IG1heFcgKXsgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggc3VibGluZSApO1xuICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG4gICAgICAgIGlmKCAhc3VibGluZS5tYXRjaCggL15cXHMrJC8gKSApe1xuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIGxpbmUgKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG4gICAgcnNjcmF0Y2goICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyApO1xuICAgIHRleHQgPSByc2NyYXRjaCggJ2xhYmVsV3JhcENhY2hlZFRleHQnLCB3cmFwcGVkTGluZXMuam9pbiggJ1xcbicgKSApO1xuICAgIHJzY3JhdGNoKCAnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkgKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRleHQpXG4gIH0gZWxzZSBpZiggd3JhcFN0eWxlID09PSAnZWxsaXBzaXMnICl7XG4gICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCAndGV4dC1tYXgtd2lkdGgnICkucGZWYWx1ZTtcbiAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgIHZhciBlbGxpcHNpcyA9ICdcXHUyMDI2JztcbiAgICB2YXIgaW5jTGFzdENoID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB3aWR0aFdpdGhOZXh0Q2ggPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCBlbGxpcHNpemVkICsgdGV4dFtpXSArIGVsbGlwc2lzICkud2lkdGg7XG5cbiAgICAgIGlmKCB3aWR0aFdpdGhOZXh0Q2ggPiBtYXhXICl7IGJyZWFrOyB9XG5cbiAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcblxuICAgICAgaWYoIGkgPT09IHRleHQubGVuZ3RoIC0gMSApeyBpbmNMYXN0Q2ggPSB0cnVlOyB9XG4gICAgfVxuXG4gICAgaWYoICFpbmNMYXN0Q2ggKXtcbiAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsbGlwc2l6ZWQ7XG4gIH0gLy8gaWYgZWxsaXBzaXplXG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG5CUnAuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSwgdGV4dCwgZXh0cmFLZXkgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBjYWNoZUtleSA9IGVsZS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5ICsgJyRAJCcgKyB0ZXh0O1xuXG4gIGlmKCBleHRyYUtleSApe1xuICAgIGNhY2hlS2V5ICs9ICckQCQnICsgZXh0cmFLZXk7XG4gIH1cblxuICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IHt9KTtcblxuICBpZiggY2FjaGVbIGNhY2hlS2V5IF0gKXtcbiAgICByZXR1cm4gY2FjaGVbIGNhY2hlS2V5IF07XG4gIH1cblxuICB2YXIgc2l6ZU11bHQgPSAxOyAvLyBpbmNyZWFzZSB0aGUgc2NhbGUgdG8gaW5jcmVhc2UgYWNjdXJhY3kgdy5yLnQuIHpvb21lZCB0ZXh0XG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCAnZm9udC1zdHlsZScgKS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSAoIHNpemVNdWx0ICogZWxlLnBzdHlsZSggJ2ZvbnQtc2l6ZScgKS5wZlZhbHVlICkgKyAncHgnO1xuICB2YXIgZmFtaWx5ID0gZWxlLnBzdHlsZSggJ2ZvbnQtZmFtaWx5JyApLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSggJ2ZvbnQtd2VpZ2h0JyApLnN0clZhbHVlO1xuXG4gIHZhciBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdjtcblxuICBpZiggIWRpdiApe1xuICAgIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cblxuICB2YXIgZHMgPSBkaXYuc3R5bGU7XG5cbiAgLy8gZnJvbSBlbGUgc3R5bGVcbiAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICBkcy5mb250U2l6ZSA9IHNpemU7XG4gIGRzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgLy8gZm9yY2VkIHN0eWxlXG4gIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgZHMudG9wID0gJy05OTk5cHgnO1xuICBkcy56SW5kZXggPSAnLTEnO1xuICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIGRzLnBhZGRpbmcgPSAnMCc7XG4gIGRzLmxpbmVIZWlnaHQgPSAnMSc7XG5cbiAgaWYoIGVsZS5wc3R5bGUoICd0ZXh0LXdyYXAnICkudmFsdWUgPT09ICd3cmFwJyApe1xuICAgIGRzLndoaXRlU3BhY2UgPSAncHJlJzsgLy8gc28gbmV3bGluZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICB9IGVsc2Uge1xuICAgIGRzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgfVxuXG4gIC8vIHB1dCBsYWJlbCBjb250ZW50IGluIGRpdlxuICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gIGNhY2hlWyBjYWNoZUtleSBdID0ge1xuICAgIHdpZHRoOiBNYXRoLmNlaWwoIGRpdi5jbGllbnRXaWR0aCAvIHNpemVNdWx0ICksXG4gICAgaGVpZ2h0OiBNYXRoLmNlaWwoIGRpdi5jbGllbnRIZWlnaHQgLyBzaXplTXVsdCApXG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlWyBjYWNoZUtleSBdO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24oIGVkZ2VzICl7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKCBlZGdlcyApO1xufTtcblxuXG4vLyBGaW5kIGVkZ2UgY29udHJvbCBwb2ludHNcbkJScC5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiggZWRnZXMgKXtcbiAgaWYoICFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaGFzaFRhYmxlID0ge307XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG4gIHZhciBwYWlySWQ7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzWyBpIF07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgZGF0YSA9IF9wLmRhdGE7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSggJ2N1cnZlLXN0eWxlJyApLnZhbHVlO1xuICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJztcblxuICAgIC8vIGlnbm9yZSBlZGdlcyB3aG8gYXJlIG5vdCB0byBiZSBkaXNwbGF5ZWRcbiAgICAvLyB0aGV5IHNob3VsZG4ndCB0YWtlIHVwIHNwYWNlXG4gICAgaWYoIGVkZ2UucHN0eWxlKCAnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScgKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKCBjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snICl7XG4gICAgICBoYXlzdGFja0VkZ2VzLnB1c2goIGVkZ2UgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBzcmNJZCA9IGRhdGEuc291cmNlO1xuICAgIHZhciB0Z3RJZCA9IGRhdGEudGFyZ2V0O1xuXG4gICAgcGFpcklkID0gc3JjSWQgPiB0Z3RJZCA/XG4gICAgICB0Z3RJZCArICckLSQnICsgc3JjSWQgOlxuICAgICAgc3JjSWQgKyAnJC0kJyArIHRndElkIDtcblxuICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgIHBhaXJJZCA9ICd1bmJ1bmRsZWQnICsgJyQtJCcgKyBkYXRhLmlkO1xuICAgIH1cblxuICAgIGlmKCBoYXNoVGFibGVbIHBhaXJJZCBdID09IG51bGwgKXtcbiAgICAgIGhhc2hUYWJsZVsgcGFpcklkIF0gPSBbXTtcbiAgICAgIHBhaXJJZHMucHVzaCggcGFpcklkICk7XG4gICAgfVxuXG4gICAgaGFzaFRhYmxlWyBwYWlySWQgXS5wdXNoKCBlZGdlICk7XG5cbiAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICBoYXNoVGFibGVbIHBhaXJJZCBdLmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYywgdGd0LCBzcmNfcCwgdGd0X3AsIHNyY1BvcywgdGd0UG9zLCBzcmNXLCBzcmNILCB0Z3RXLCB0Z3RILCBzcmNTaGFwZSwgdGd0U2hhcGU7XG4gIHZhciB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIGJhZEJlemllcjtcblxuICAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuICBmb3IoIHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKysgKXtcbiAgICBwYWlySWQgPSBwYWlySWRzWyBwIF07XG4gICAgdmFyIHBhaXJFZGdlcyA9IGhhc2hUYWJsZVsgcGFpcklkIF07XG5cbiAgICAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuICAgIHBhaXJFZGdlcy5zb3J0KCBmdW5jdGlvbiggZWRnZTEsIGVkZ2UyICl7XG4gICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICB9ICk7XG5cbiAgICBzcmMgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUuc291cmNlO1xuICAgIHRndCA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50IGZvciBidW5kbGVkIGVkZ2VzXG4gICAgaWYoICFwYWlyRWRnZXMuaGFzVW5idW5kbGVkICYmIHNyYy5pZCgpID4gdGd0LmlkKCkgKXtcbiAgICAgIHZhciB0ZW1wID0gc3JjO1xuICAgICAgc3JjID0gdGd0O1xuICAgICAgdGd0ID0gdGVtcDtcbiAgICB9XG5cbiAgICBzcmNfcCA9IHNyYy5fcHJpdmF0ZTtcbiAgICB0Z3RfcCA9IHRndC5fcHJpdmF0ZTtcblxuICAgIHNyY1BvcyA9IHNyY19wLnBvc2l0aW9uO1xuICAgIHRndFBvcyA9IHRndF9wLnBvc2l0aW9uO1xuXG4gICAgc3JjVyA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuXG4gICAgdGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCBzcmMgKSBdO1xuICAgIHRndFNoYXBlID0gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggdGd0ICkgXTtcblxuICAgIGJhZEJlemllciA9IGZhbHNlO1xuXG5cbiAgICBpZiggKHBhaXJFZGdlcy5sZW5ndGggPiAxICYmIHNyYyAhPT0gdGd0KSB8fCBwYWlyRWRnZXMuaGFzVW5idW5kbGVkICl7XG5cbiAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgc3JjUG9zLnksXG4gICAgICAgIHNyY1csXG4gICAgICAgIHNyY0gsXG4gICAgICAgIHRndFBvcy54LFxuICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgMFxuICAgICAgKTtcblxuICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRndFBvcy54LFxuICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgdGd0VyxcbiAgICAgICAgdGd0SCxcbiAgICAgICAgc3JjUG9zLngsXG4gICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAwXG4gICAgICApO1xuXG4gICAgICB2YXIgbWlkcHRTcmNQdHMgPSB7XG4gICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9zUHRzID0ge1xuICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgeTE6IHNyY1Bvcy55LFxuICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHZhciBkeSA9ICggdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV0gKTtcbiAgICAgIHZhciBkeCA9ICggdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF0gKTtcbiAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG4gICAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICB4OiBkeCxcbiAgICAgICAgeTogZHlcbiAgICAgIH07XG5cbiAgICAgIHZhciB2ZWN0b3JOb3JtID0ge1xuICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgIHk6IHZlY3Rvci55IC8gbFxuICAgICAgfTtcbiAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICB5OiB2ZWN0b3JOb3JtLnhcbiAgICAgIH07XG5cblxuICAgICAgLy8gaWYgbm9kZSBzaGFwZXMgb3ZlcmxhcCwgdGhlbiBubyBjdHJsIHB0cyB0byBkcmF3XG4gICAgICBpZihcbiAgICAgICAgdGd0U2hhcGUuY2hlY2tQb2ludCggc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55ICkgICYmXG4gICAgICAgIHNyY1NoYXBlLmNoZWNrUG9pbnQoIHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIDAsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSApXG4gICAgICApe1xuICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHt9O1xuICAgICAgICBiYWRCZXppZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIGVkZ2VfcDtcbiAgICB2YXIgcnM7XG5cbiAgICB2YXIgZGlyQ291bnRzID0ge1xuICAgICAgJ25vcnRoJzogMCxcbiAgICAgICd3ZXN0JzogMCxcbiAgICAgICdzb3V0aCc6IDAsXG4gICAgICAnZWFzdCc6IDAsXG4gICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAnc291dGhlYXN0JzogMFxuICAgIH07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhaXJFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgZWRnZSA9IHBhaXJFZGdlc1sgaSBdO1xuICAgICAgZWRnZV9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHJzID0gZWRnZV9wLnJzY3JhdGNoO1xuXG4gICAgICB2YXIgZWRnZUluZGV4MSA9IHJzLmxhc3RFZGdlSW5kZXg7XG4gICAgICB2YXIgZWRnZUluZGV4MiA9IGk7XG5cbiAgICAgIHZhciBudW1FZGdlczEgPSBycy5sYXN0TnVtRWRnZXM7XG4gICAgICB2YXIgbnVtRWRnZXMyID0gcGFpckVkZ2VzLmxlbmd0aDtcblxuICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSggJ2N1cnZlLXN0eWxlJyApLnZhbHVlO1xuICAgICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycgKTtcblxuICAgICAgdmFyIGxvb3BEaXIgPSBlZGdlLnBzdHlsZSgnbG9vcC1kaXJlY3Rpb24nKS5wZlZhbHVlO1xuICAgICAgdmFyIGxvb3BTd3AgPSBlZGdlLnBzdHlsZSgnbG9vcC1zd2VlcCcpLnBmVmFsdWU7XG5cbiAgICAgIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCAnY29udHJvbC1wb2ludC13ZWlnaHRzJyApO1xuICAgICAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKCBjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCApIDogMTtcbiAgICAgIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnICkucGZWYWx1ZTtcbiAgICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdO1xuICAgICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnO1xuXG4gICAgICB2YXIgc3JjWDEgPSBycy5sYXN0U3JjQ3RsUHRYO1xuICAgICAgdmFyIHNyY1gyID0gc3JjUG9zLng7XG4gICAgICB2YXIgc3JjWTEgPSBycy5sYXN0U3JjQ3RsUHRZO1xuICAgICAgdmFyIHNyY1kyID0gc3JjUG9zLnk7XG4gICAgICB2YXIgc3JjVzEgPSBycy5sYXN0U3JjQ3RsUHRXO1xuICAgICAgdmFyIHNyY1cyID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG4gICAgICB2YXIgc3JjSDIgPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgdmFyIHRndFgxID0gcnMubGFzdFRndEN0bFB0WDtcbiAgICAgIHZhciB0Z3RYMiA9IHRndFBvcy54O1xuICAgICAgdmFyIHRndFkxID0gcnMubGFzdFRndEN0bFB0WTtcbiAgICAgIHZhciB0Z3RZMiA9IHRndFBvcy55O1xuICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgIHZhciB0Z3RXMiA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgdGd0SDEgPSBycy5sYXN0VGd0Q3RsUHRIO1xuICAgICAgdmFyIHRndEgyID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIHZhciB3aWR0aDEgPSBycy5sYXN0VztcbiAgICAgIHZhciB3aWR0aDIgPSBlZGdlLnBzdHlsZSggJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyApLnBmVmFsdWU7XG5cbiAgICAgIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG5cbiAgICAgIGlmKCBiYWRCZXppZXIgKXtcbiAgICAgICAgcnMuYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggc3JjWDEgPT09IHNyY1gyICYmIHNyY1kxID09PSBzcmNZMiAmJiBzcmNXMSA9PT0gc3JjVzIgJiYgc3JjSDEgPT09IHNyY0gyXG4gICAgICAmJiAgdGd0WDEgPT09IHRndFgyICYmIHRndFkxID09PSB0Z3RZMiAmJiB0Z3RXMSA9PT0gdGd0VzIgJiYgdGd0SDEgPT09IHRndEgyXG4gICAgICAmJiAgd2lkdGgxID09PSB3aWR0aDJcbiAgICAgICYmICAoKGVkZ2VJbmRleDEgPT09IGVkZ2VJbmRleDIgJiYgbnVtRWRnZXMxID09PSBudW1FZGdlczIpIHx8IGVkZ2VJc1VuYnVuZGxlZCkgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBISVQnKVxuICAgICAgICBjb250aW51ZTsgLy8gdGhlbiB0aGUgY29udHJvbCBwb2ludHMgaGF2ZW4ndCBjaGFuZ2VkIGFuZCB3ZSBjYW4gc2tpcCBjYWxjdWxhdGluZyB0aGVtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRYID0gc3JjWDI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFkgPSBzcmNZMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0VyA9IHNyY1cyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRIID0gc3JjSDI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFggPSB0Z3RYMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0WSA9IHRndFkyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRXID0gdGd0VzI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdEggPSB0Z3RIMjtcbiAgICAgICAgcnMubGFzdEVkZ2VJbmRleCA9IGVkZ2VJbmRleDI7XG4gICAgICAgIHJzLmxhc3ROdW1FZGdlcyA9IG51bUVkZ2VzMjtcbiAgICAgICAgcnMubGFzdFdpZHRoID0gd2lkdGgyO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIE1JU1MnKVxuICAgICAgfVxuXG4gICAgICBpZiggc3JjID09PSB0Z3QgKXtcbiAgICAgICAgLy8gU2VsZi1lZGdlXG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG5cbiAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dEFuZ2xlID0gIGxvb3BEaXIgLSBsb29wU3dwIC8gMjtcbiAgICAgICAgdmFyIGluQW5nbGUgID0gIGxvb3BEaXIgKyBsb29wU3dwIC8gMjtcblxuICAgICAgICAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuICAgICAgICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICAgICAgICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG5cbiAgICAgICAgcnMuY3RybHB0cyA9IFtcbiAgICAgICAgICBzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksXG4gICAgICAgICAgc3JjUG9zLnkgKyBNYXRoLnNpbihvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXG4gICAgICAgIF07XG5cbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgaGFzQ29tcG91bmRzICYmXG4gICAgICAgICggc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpICkgJiZcbiAgICAgICAgKCBzcmMucGFyZW50cygpLmFueVNhbWUoIHRndCApIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZSggc3JjICkgKVxuICAgICAgKXtcbiAgICAgICAgLy8gQ29tcG91bmQgZWRnZVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBsaW5lIGFwcHJveGltYXRpb24gZG9lc24ndCBhcHBseSBmb3IgY29tcG91bmQgYmV6aWVyc1xuICAgICAgICAvLyAobG9vcC9zZWxmIGVkZ2VzIGFyZSBhbHJlYWR5IGVsaWRlZCBiL2Mgb2YgY2hlYXAgc3JjPT10Z3QgY2hlY2spXG4gICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgIGogPSAwO1xuICAgICAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb29wVyA9IDUwO1xuXG4gICAgICAgIHZhciBsb29wYVBvcyA9IHtcbiAgICAgICAgICB4OiBzcmNQb3MueCAtIHNyY1cgLyAyLFxuICAgICAgICAgIHk6IHNyY1Bvcy55IC0gc3JjSCAvIDJcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgICAgICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICAgICAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3BQb3MgPSB7XG4gICAgICAgICAgeDogTWF0aC5taW4oIGxvb3BhUG9zLngsIGxvb3BiUG9zLnggKSxcbiAgICAgICAgICB5OiBNYXRoLm1pbiggbG9vcGFQb3MueSwgbG9vcGJQb3MueSApXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gICAgICAgIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coIHNyY1cgKiAwLjAxICkgKTtcbiAgICAgICAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyggdGd0VyAqIDAuMDEgKSApO1xuXG4gICAgICAgIHJzLmN0cmxwdHMgPSBbXG4gICAgICAgICAgbG9vcFBvcy54LFxuICAgICAgICAgIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3coIGxvb3BXLCAxLjEyICkgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsXG5cbiAgICAgICAgICBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KCBsb29wVywgMS4xMiApIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLFxuICAgICAgICAgIGxvb3BQb3MueVxuICAgICAgICBdO1xuXG4gICAgICB9IGVsc2UgaWYoIGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgKXtcbiAgICAgICAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgICAgICAgcnMuc2VncHRzID0gW107XG5cbiAgICAgICAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCAnc2VnbWVudC13ZWlnaHRzJyApLnBmVmFsdWU7XG4gICAgICAgIHZhciBzZWdtZW50RHMgPSBlZGdlLnBzdHlsZSggJ3NlZ21lbnQtZGlzdGFuY2VzJyApLnBmVmFsdWU7XG4gICAgICAgIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbiggc2VnbWVudFdzLmxlbmd0aCwgc2VnbWVudERzLmxlbmd0aCApO1xuXG4gICAgICAgIGZvciggdmFyIHMgPSAwOyBzIDwgc2VnbWVudHNOOyBzKysgKXtcbiAgICAgICAgICB2YXIgdyA9IHNlZ21lbnRXc1sgcyBdO1xuICAgICAgICAgIHZhciBkID0gc2VnbWVudERzWyBzIF07XG5cbiAgICAgICAgICB2YXIgdzEgPSAxIC0gdztcbiAgICAgICAgICB2YXIgdzIgPSB3O1xuXG4gICAgICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogbWlkcHRTcmNQdHM7XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuc2VncHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCxcbiAgICAgICAgICAgIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBTdHJhaWdodCBlZGdlXG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIHBhaXJFZGdlcy5sZW5ndGggJSAyID09PSAxXG4gICAgICAgICYmIGkgPT09IE1hdGguZmxvb3IoIHBhaXJFZGdlcy5sZW5ndGggLyAyIClcbiAgICAgICAgJiYgIWVkZ2VJc1VuYnVuZGxlZFxuICAgICAgKXtcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIChNdWx0aSliZXppZXJcblxuICAgICAgICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSBtdWx0aSA/ICdtdWx0aWJlemllcicgOiAnYmV6aWVyJztcbiAgICAgICAgcnMuY3RybHB0cyA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrICl7XG4gICAgICAgICAgdmFyIG5vcm1jdHJscHREaXN0ID0gKDAuNSAtIHBhaXJFZGdlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZTtcbiAgICAgICAgICB2YXIgbWFuY3RybHB0RGlzdDtcbiAgICAgICAgICB2YXIgc2lnbiA9IG1hdGguc2lnbnVtKCBub3JtY3RybHB0RGlzdCApO1xuXG4gICAgICAgICAgaWYoIG11bHRpICl7XG4gICAgICAgICAgICBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWyBiIF0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuICAgICAgICAgICAgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbIGIgXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7IC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuXG4gICAgICAgICAgdmFyIHcxID0gMSAtIGN0cmxwdFdlaWdodDtcbiAgICAgICAgICB2YXIgdzIgPSBjdHJscHRXZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBtaWRwdFNyY1B0cztcblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5jdHJscHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuXG4gICAgICB2YXIgYmFkU3RhcnQgPSAhaXMubnVtYmVyKCBycy5zdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5zdGFydFkgKTtcbiAgICAgIHZhciBiYWRBU3RhcnQgPSAhaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WCApIHx8ICFpcy5udW1iZXIoIHJzLmFycm93U3RhcnRZICk7XG4gICAgICB2YXIgYmFkRW5kID0gIWlzLm51bWJlciggcnMuZW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmVuZFkgKTtcbiAgICAgIHZhciBiYWRBRW5kID0gIWlzLm51bWJlciggcnMuYXJyb3dFbmRYICkgfHwgIWlzLm51bWJlciggcnMuYXJyb3dFbmRZICk7XG5cbiAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSwgZWRnZS5wc3R5bGUoICdhcnJvdy1zY2FsZScgKS52YWx1ZSApXG4gICAgICAgICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgdmFyIHN0YXJ0QUNwRGlzdCA9IG1hdGguZGlzdCggeyB4OiBycy5jdHJscHRzWzBdLCB5OiBycy5jdHJscHRzWzFdIH0sIHsgeDogcnMuc3RhcnRYLCB5OiBycy5zdGFydFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICAgIHZhciBlbmRBQ3BEaXN0ID0gbWF0aC5kaXN0KCB7IHg6IHJzLmN0cmxwdHNbMF0sIHk6IHJzLmN0cmxwdHNbMV0gfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG5cbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heCggc3JjVywgc3JjSCApO1xuICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgICBzcmNXLFxuICAgICAgICAgICAgc3JjSCxcbiAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmKCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KCBzcmNXLCBzcmNIICk7XG4gICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICAgIHRndFcsXG4gICAgICAgICAgICB0Z3RILFxuICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYoIGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG92ZXJsYXBwaW5nICl7XG4gICAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICAgIHJzLmFsbHB0cyA9IFtdO1xuXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5zdGFydFgsIHJzLnN0YXJ0WSApO1xuXG4gICAgICAgIGZvciggdmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIgKXtcbiAgICAgICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5jdHJscHRzWyBiIF0sIHJzLmN0cmxwdHNbIGIgKyAxXSApO1xuXG4gICAgICAgICAgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG4gICAgICAgICAgaWYoIGIgKyAzIDwgcnMuY3RybHB0cy5sZW5ndGggKXtcbiAgICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKCAocnMuY3RybHB0c1sgYiBdICsgcnMuY3RybHB0c1sgYiArIDJdKSAvIDIsIChycy5jdHJscHRzWyBiICsgMV0gKyBycy5jdHJscHRzWyBiICsgM10pIC8gMiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5lbmRYLCBycy5lbmRZICk7XG5cbiAgICAgICAgdmFyIG0sIG10O1xuICAgICAgICBpZiggcnMuY3RybHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICAgICAgICBycy5taWRYID0gcnMuYWxscHRzWyBtIF07XG4gICAgICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1sgbSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICAgICAgbXQgPSAwLjU7XG5cbiAgICAgICAgICBycy5taWRYID0gbWF0aC5xYmV6aWVyQXQoIHJzLmFsbHB0c1sgbSBdLCBycy5hbGxwdHNbIG0gKyAyXSwgcnMuYWxscHRzWyBtICsgNF0sIG10ICk7XG4gICAgICAgICAgcnMubWlkWSA9IG1hdGgucWJlemllckF0KCBycy5hbGxwdHNbIG0gKyAxXSwgcnMuYWxscHRzWyBtICsgM10sIHJzLmFsbHB0c1sgbSArIDVdLCBtdCApO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgKXtcbiAgICAgICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgICAgICBycy5hbGxwdHMgPSBbIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZIF07XG5cbiAgICAgICAgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuICAgICAgICBycy5taWRYID0gKCBycy5zdGFydFggKyBycy5lbmRYICsgcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFggKSAvIDQ7XG4gICAgICAgIHJzLm1pZFkgPSAoIHJzLnN0YXJ0WSArIHJzLmVuZFkgKyBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSApIC8gNDtcblxuICAgICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyApe1xuICAgICAgICBycy5hbGxwdHMgPSBbXTtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLnN0YXJ0WCwgcnMuc3RhcnRZICk7XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoLmFwcGx5KCBycy5hbGxwdHMsIHJzLnNlZ3B0cyApO1xuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuZW5kWCwgcnMuZW5kWSApO1xuXG4gICAgICAgIGlmKCBycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCApe1xuICAgICAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgICAgIHJzLm1pZFggPSAoIHJzLnNlZ3B0c1sgaTEgXSArIHJzLnNlZ3B0c1sgaTIgXSApIC8gMjtcbiAgICAgICAgICBycy5taWRZID0gKCBycy5zZWdwdHNbIGkxICsgMV0gKyBycy5zZWdwdHNbIGkyICsgMV0gKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGkxID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1sgaTEgXTtcbiAgICAgICAgICBycy5taWRZID0gcnMuc2VncHRzWyBpMSArIDFdO1xuICAgICAgICB9XG5cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2plY3RMaW5lcyggZWRnZSApO1xuICAgICAgdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyggZWRnZSApO1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKCBlZGdlICk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKCBlZGdlICk7XG5cbiAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG4gIH0gLy8gZm9yIHBhaXIgaWRzXG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoYXlzdGFja0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVkZ2UgPSBoYXlzdGFja0VkZ2VzWyBpIF07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcnMgPSByc2NyYXRjaDtcblxuICAgIGlmKCAhcnNjcmF0Y2guaGF5c3RhY2sgKXtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2guc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyggYW5nbGUgKSxcbiAgICAgICAgeTogTWF0aC5zaW4oIGFuZ2xlIClcbiAgICAgIH07XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2gudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyggYW5nbGUgKSxcbiAgICAgICAgeTogTWF0aC5zaW4oIGFuZ2xlIClcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoICdoYXlzdGFjay1yYWRpdXMnICkudmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbXG4gICAgICBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsXG4gICAgICBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksXG4gICAgICBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsXG4gICAgICBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnlcbiAgICBdO1xuXG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyO1xuXG4gICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICByc2NyYXRjaC5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgcnNjcmF0Y2guaGF5c3RhY2sgPSB0cnVlO1xuXG4gICAgdGhpcy5wcm9qZWN0TGluZXMoIGVkZ2UgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKCBlZGdlICk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKCBlZGdlICk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyggZWRnZSApO1xuICB9XG5cbiAgcmV0dXJuIGhhc2hUYWJsZTtcbn07XG5cbnZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24oIGRpc3BYLCBkaXNwWSApe1xuICByZXR1cm4gTWF0aC5hdGFuMiggZGlzcFksIGRpc3BYICkgLSBNYXRoLlBJIC8gMjtcbn07XG5cbkJScC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7XG5cbiAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcblxuICB2YXIgc3JjUG9zID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gIHZhciB0Z3RQb3MgPSBlZGdlLl9wcml2YXRlLnRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICBpZiggaXNIYXlzdGFjayApe1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG5cbiAgbWlkWCA9IHJzLm1pZFg7XG4gIG1pZFkgPSBycy5taWRZO1xuXG4gIC8vIHNvdXJjZVxuICAvL1xuXG4gIGlmKCBpc1NlZ21lbnRzICl7XG4gICAgZGlzcFggPSBzdGFydFggLSBycy5zZWdwdHNbMF07XG4gICAgZGlzcFkgPSBzdGFydFkgLSBycy5zZWdwdHNbMV07XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0JlemllciApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGJYID0gbWF0aC5xYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMSApO1xuICAgIHZhciBiWSA9IG1hdGgucWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEgKTtcblxuICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICB9XG5cbiAgcnMuc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoIGRpc3BYLCBkaXNwWSApO1xuXG4gIC8vIG1pZCB0YXJnZXRcbiAgLy9cblxuICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gIHZhciBtaWRZID0gcnMubWlkWTtcblxuICBpZiggaXNIYXlzdGFjayApe1xuICAgIG1pZFggPSAoIHN0YXJ0WCArIGVuZFggKSAvIDI7XG4gICAgbWlkWSA9ICggc3RhcnRZICsgZW5kWSApIC8gMjtcbiAgfVxuXG4gIGRpc3BYID0gZW5kWCAtIHN0YXJ0WDtcbiAgZGlzcFkgPSBlbmRZIC0gc3RhcnRZO1xuXG4gIGlmKCBpc1NlbGYgKXtcbiAgICBkaXNwWCA9IC0xO1xuICAgIGRpc3BZID0gMTtcbiAgfSBlbHNlIGlmKCBpc1NlZ21lbnRzICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgIGlmKCBwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDAgKXtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuXG4gICAgICBkaXNwWCA9ICggcHRzWyBpMiBdIC0gcHRzWyBpMSBdICk7XG4gICAgICBkaXNwWSA9ICggcHRzWyBpMiArIDFdIC0gcHRzWyBpMSArIDFdICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcblxuICAgICAgZGlzcFggPSAoIHB0c1sgaTIgXSAtIHB0c1sgaTEgXSApO1xuICAgICAgZGlzcFkgPSAoIHB0c1sgaTIgKyAxXSAtIHB0c1sgaTEgKyAxXSApO1xuICAgIH1cbiAgfSBlbHNlIGlmKCBpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICB2YXIgYnAweCwgYnAweTtcbiAgICB2YXIgYnAxeCwgYnAxeTtcblxuICAgIGlmKCBjcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwICl7XG4gICAgICB2YXIgcDAgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIHN0YXJ0cHRcbiAgICAgIHZhciBpYyA9IHAwICsgMjtcbiAgICAgIHZhciBwMSA9IGljICsgMjtcblxuICAgICAgYnAweCA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwIF0sIHB0c1sgaWMgXSwgcHRzWyBwMSBdLCAwLjAgKTtcbiAgICAgIGJwMHkgPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCArIDFdLCBwdHNbIGljICsgMV0sIHB0c1sgcDEgKyAxXSwgMC4wICk7XG5cbiAgICAgIGJwMXggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC4wMDAxICk7XG4gICAgICBicDF5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuMDAwMSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWMgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIGN0cnB0XG4gICAgICB2YXIgcDAgPSBpYyAtIDI7IC8vIHN0YXJ0cHRcbiAgICAgIHZhciBwMSA9IGljICsgMjsgLy8gZW5kcHRcblxuICAgICAgYnAweCA9IG1hdGgucWJlemllckF0KCBwdHNbIHAwIF0sIHB0c1sgaWMgXSwgcHRzWyBwMSBdLCAwLjQ5OTkgKTtcbiAgICAgIGJwMHkgPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCArIDFdLCBwdHNbIGljICsgMV0sIHB0c1sgcDEgKyAxXSwgMC40OTk5ICk7XG5cbiAgICAgIGJwMXggPSBtYXRoLnFiZXppZXJBdCggcHRzWyBwMCBdLCBwdHNbIGljIF0sIHB0c1sgcDEgXSwgMC41ICk7XG4gICAgICBicDF5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1sgcDAgKyAxXSwgcHRzWyBpYyArIDFdLCBwdHNbIHAxICsgMV0sIDAuNSApO1xuICAgIH1cblxuICAgIGRpc3BYID0gKCBicDF4IC0gYnAweCApO1xuICAgIGRpc3BZID0gKCBicDF5IC0gYnAweSApO1xuICB9XG5cbiAgcnMubWlkdGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoIGRpc3BYLCBkaXNwWSApO1xuXG4gIHJzLm1pZERpc3BYID0gZGlzcFg7XG4gIHJzLm1pZERpc3BZID0gZGlzcFk7XG5cbiAgLy8gbWlkIHNvdXJjZVxuICAvL1xuXG4gIGRpc3BYICo9IC0xO1xuICBkaXNwWSAqPSAtMTtcblxuICBpZiggaXNTZWdtZW50cyApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiggcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwICl7XG4gICAgICAvLyBhbHJlYWR5IG9rXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcblxuICAgICAgZGlzcFggPSAtKCBwdHNbIGkzIF0gLSBwdHNbIGkyIF0gKTtcbiAgICAgIGRpc3BZID0gLSggcHRzWyBpMyArIDFdIC0gcHRzWyBpMiArIDFdICk7XG4gICAgfVxuICB9XG5cbiAgcnMubWlkc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoIGRpc3BYLCBkaXNwWSApO1xuXG4gIC8vIHRhcmdldFxuICAvL1xuXG4gIGlmKCBpc1NlZ21lbnRzICl7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzWyBycy5zZWdwdHMubGVuZ3RoIC0gMiBdO1xuICAgIGRpc3BZID0gZW5kWSAtIHJzLnNlZ3B0c1sgcnMuc2VncHRzLmxlbmd0aCAtIDEgXTtcbiAgfSBlbHNlIGlmKCBpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgbCA9IHB0cy5sZW5ndGg7XG4gICAgdmFyIGJYID0gbWF0aC5xYmV6aWVyQXQoIHB0c1tsLTZdLCBwdHNbbC00XSwgcHRzW2wtMl0sIDAuOSApO1xuICAgIHZhciBiWSA9IG1hdGgucWJlemllckF0KCBwdHNbbC01XSwgcHRzW2wtM10sIHB0c1tsLTFdLCAwLjkgKTtcblxuICAgIGRpc3BYID0gZW5kWCAtIGJYO1xuICAgIGRpc3BZID0gZW5kWSAtIGJZO1xuICB9IGVsc2Uge1xuICAgIGRpc3BYID0gZW5kWCAtIG1pZFg7XG4gICAgZGlzcFkgPSBlbmRZIC0gbWlkWTtcbiAgfVxuXG4gIHJzLnRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcbn07XG5cbkJScC5jYWxjdWxhdGVMYWJlbEFuZ2xlcyA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIHJvdCA9IGVsZS5wc3R5bGUoICd0ZXh0LXJvdGF0aW9uJyApO1xuICB2YXIgcm90U3RyID0gcm90LnN0clZhbHVlO1xuXG4gIGlmKCByb3RTdHIgPT09ICdub25lJyApe1xuICAgIHJzLmxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZSA9IDA7XG4gIH0gZWxzZSBpZiggaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnICl7XG4gICAgcnMubGFiZWxBbmdsZSA9IE1hdGguYXRhbiggcnMubWlkRGlzcFkgLyBycy5taWREaXNwWCApO1xuICAgIHJzLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEF1dG9BbmdsZTtcbiAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBdXRvQW5nbGU7XG4gIH0gZWxzZSBpZiggcm90U3RyID09PSAnYXV0b3JvdGF0ZScgKXtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGUgPSAwO1xuICB9IGVsc2Uge1xuICAgIHJzLmxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHJvdC5wZlZhbHVlO1xuICB9XG59O1xuXG5CUnAubWFudWFsRW5kcHRUb1B4ID0gZnVuY3Rpb24oIG5vZGUsIHByb3AgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbnBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgaWYoIHByb3AudmFsdWUubGVuZ3RoID09PSAyICl7XG4gICAgdmFyIHAgPSBbXG4gICAgICBwcm9wLnBmVmFsdWVbMF0sXG4gICAgICBwcm9wLnBmVmFsdWVbMV1cbiAgICBdO1xuXG4gICAgaWYoIHByb3AudW5pdHNbMF0gPT09ICclJyApe1xuICAgICAgcFswXSA9IHBbMF0gKiB3O1xuICAgIH1cblxuICAgIGlmKCBwcm9wLnVuaXRzWzFdID09PSAnJScgKXtcbiAgICAgIHBbMV0gPSBwWzFdICogaDtcbiAgICB9XG5cbiAgICBwWzBdICs9IG5wb3MueDtcbiAgICBwWzFdICs9IG5wb3MueTtcblxuICAgIHJldHVybiBwO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmdsZSA9IHByb3AucGZWYWx1ZVswXTtcblxuICAgIGFuZ2xlID0gLU1hdGguUEkgLyAyICsgYW5nbGU7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2tcblxuICAgIHZhciBsID0gMiAqIE1hdGgubWF4KCB3LCBoICk7XG5cbiAgICB2YXIgcCA9IFtcbiAgICAgIG5wb3MueCArIE1hdGguY29zKCBhbmdsZSApICogbCxcbiAgICAgIG5wb3MueSArIE1hdGguc2luKCBhbmdsZSApICogbFxuICAgIF07XG5cbiAgICByZXR1cm4gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggbm9kZSApIF0uaW50ZXJzZWN0TGluZShcbiAgICAgIG5wb3MueCwgbnBvcy55LFxuICAgICAgdywgaCxcbiAgICAgIHBbMF0sIHBbMV0sXG4gICAgICAwXG4gICAgKTtcbiAgfVxufTtcblxuQlJwLmZpbmRFbmRwb2ludHMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbnRlcnNlY3Q7XG5cbiAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuXG4gIHZhciBzcmNfcCA9IHNvdXJjZS5fcHJpdmF0ZTtcbiAgdmFyIHRndF9wID0gdGFyZ2V0Ll9wcml2YXRlO1xuXG4gIHZhciBzcmNQb3MgPSBzcmNfcC5wb3NpdGlvbjtcbiAgdmFyIHRndFBvcyA9IHRndF9wLnBvc2l0aW9uO1xuXG4gIHZhciB0Z3RBclNoYXBlID0gZWRnZS5wc3R5bGUoICd0YXJnZXQtYXJyb3ctc2hhcGUnICkudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoICdzb3VyY2UtYXJyb3ctc2hhcGUnICkudmFsdWU7XG5cbiAgdmFyIHRndERpc3QgPSBlZGdlLnBzdHlsZSggJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnICkucGZWYWx1ZTtcbiAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSggJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnICkucGZWYWx1ZTtcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgc2VsZiA9IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgc2VsZjtcbiAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBoYXNFbmRwdHMgPSBiZXppZXIgfHwgbXVsdGkgfHwgbGluZXM7XG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1lbmRwb2ludCcpO1xuXG4gIHJzLnNyY01hbkVuZHB0ID0gc3JjTWFuRW5kcHQ7XG4gIHJzLnRndE1hbkVuZHB0ID0gdGd0TWFuRW5kcHQ7XG5cbiAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcbiAgdmFyIHAyOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gc291cmNlIHNpZGVcblxuICB2YXIgcDFfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggdGFyZ2V0IHNoYXBlXG4gIHZhciBwMl9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCBzb3VyY2Ugc2hhcGVcblxuICBpZiggYmV6aWVyICl7XG4gICAgdmFyIGNwU3RhcnQgPSBbIHJzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV0gXTtcbiAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFsgcnMuY3RybHB0c1sgcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1sgcnMuY3RybHB0cy5sZW5ndGggLSAxXSBdIDogY3BTdGFydDtcblxuICAgIHAxID0gY3BFbmQ7XG4gICAgcDIgPSBjcFN0YXJ0O1xuICB9IGVsc2UgaWYoIGxpbmVzICl7XG4gICAgdmFyIHNyY0Fycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gWyB0Z3RQb3MueCwgdGd0UG9zLnkgXSA6IHJzLnNlZ3B0cy5zbGljZSggMCwgMiApO1xuICAgIHZhciB0Z3RBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFsgc3JjUG9zLngsIHNyY1Bvcy55IF0gOiBycy5zZWdwdHMuc2xpY2UoIHJzLnNlZ3B0cy5sZW5ndGggLSAyICk7XG5cbiAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gIH1cblxuICBpZiggdGd0TWFuRW5kcHQudmFsdWUgPT09ICdpbnNpZGUtdG8tbm9kZScgKXtcbiAgICBpbnRlcnNlY3QgPSBbIHRndFBvcy54LCB0Z3RQb3MueSBdO1xuICB9IGVsc2UgaWYoIHRndE1hbkVuZHB0LnVuaXRzICl7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoIHRhcmdldCwgdGd0TWFuRW5kcHQgKTtcbiAgfSBlbHNlIHtcbiAgICBpZiggdGd0TWFuRW5kcHQudmFsdWUgPT09ICdvdXRzaWRlLXRvLW5vZGUnICl7XG4gICAgICBwMV9pID0gcDE7XG4gICAgfSBlbHNlIGlmKCB0Z3RNYW5FbmRwdC52YWx1ZSA9PT0gJ291dHNpZGUtdG8tbGluZScgKXtcbiAgICAgIHAxX2kgPSBbIHNyY1Bvcy54LCBzcmNQb3MueSBdO1xuICAgIH1cblxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoIHRhcmdldCApIF0uaW50ZXJzZWN0TGluZShcbiAgICAgIHRndFBvcy54LFxuICAgICAgdGd0UG9zLnksXG4gICAgICB0YXJnZXQub3V0ZXJXaWR0aCgpLFxuICAgICAgdGFyZ2V0Lm91dGVySGVpZ2h0KCksXG4gICAgICBwMV9pWzBdLFxuICAgICAgcDFfaVsxXSxcbiAgICAgIDBcbiAgICApO1xuICB9XG5cbiAgdmFyIGFycm93RW5kID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgIGludGVyc2VjdCxcbiAgICBwMSxcbiAgICByLmFycm93U2hhcGVzWyB0Z3RBclNoYXBlIF0uc3BhY2luZyggZWRnZSApICsgdGd0RGlzdFxuICApO1xuICB2YXIgZWRnZUVuZCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsXG4gICAgcDEsXG4gICAgci5hcnJvd1NoYXBlc1sgdGd0QXJTaGFwZSBdLmdhcCggZWRnZSApICsgdGd0RGlzdFxuICApO1xuXG4gIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICBycy5lbmRZID0gZWRnZUVuZFsxXTtcblxuICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG5cbiAgaWYoIHNyY01hbkVuZHB0LnZhbHVlID09PSAnaW5zaWRlLXRvLW5vZGUnICl7XG4gICAgaW50ZXJzZWN0ID0gWyBzcmNQb3MueCwgc3JjUG9zLnkgXTtcbiAgfSBlbHNlIGlmKCBzcmNNYW5FbmRwdC51bml0cyApe1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KCBzb3VyY2UsIHNyY01hbkVuZHB0ICk7XG4gIH0gZWxzZSB7XG4gICAgaWYoIHNyY01hbkVuZHB0LnZhbHVlID09PSAnb3V0c2lkZS10by1ub2RlJyApe1xuICAgICAgcDJfaSA9IHAyO1xuICAgIH0gZWxzZSBpZiggc3JjTWFuRW5kcHQudmFsdWUgPT09ICdvdXRzaWRlLXRvLWxpbmUnICl7XG4gICAgICBwMl9pID0gWyB0Z3RQb3MueCwgdGd0UG9zLnkgXTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCBzb3VyY2UgKSBdLmludGVyc2VjdExpbmUoXG4gICAgICBzcmNQb3MueCxcbiAgICAgIHNyY1Bvcy55LFxuICAgICAgc291cmNlLm91dGVyV2lkdGgoKSxcbiAgICAgIHNvdXJjZS5vdXRlckhlaWdodCgpLFxuICAgICAgcDJfaVswXSxcbiAgICAgIHAyX2lbMV0sXG4gICAgICAwXG4gICAgKTtcbiAgfVxuXG4gIHZhciBhcnJvd1N0YXJ0ID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgIGludGVyc2VjdCxcbiAgICBwMixcbiAgICByLmFycm93U2hhcGVzWyBzcmNBclNoYXBlIF0uc3BhY2luZyggZWRnZSApICsgc3JjRGlzdFxuICApO1xuICB2YXIgZWRnZVN0YXJ0ID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgIGludGVyc2VjdCxcbiAgICBwMixcbiAgICByLmFycm93U2hhcGVzWyBzcmNBclNoYXBlIF0uZ2FwKCBlZGdlICkgKyBzcmNEaXN0XG4gICk7XG5cbiAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG5cbiAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG5cbiAgaWYoIGhhc0VuZHB0cyApe1xuICAgIGlmKCAhaXMubnVtYmVyKCBycy5zdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5zdGFydFkgKSB8fCAhaXMubnVtYmVyKCBycy5lbmRYICkgfHwgIWlzLm51bWJlciggcnMuZW5kWSApICl7XG4gICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQlJwLmdldEFycm93V2lkdGggPSBCUnAuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbiggZWRnZVdpZHRoLCBzY2FsZSApe1xuICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuXG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVsgZWRnZVdpZHRoICsgJywgJyArIHNjYWxlIF07XG4gIGlmKCBjYWNoZWRWYWwgKXtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgY2FjaGVkVmFsID0gIE1hdGgubWF4KCBNYXRoLnBvdyggZWRnZVdpZHRoICogMTMuMzcsIDAuOSApLCAyOSApICogc2NhbGU7XG4gIGNhY2hlWyBlZGdlV2lkdGggKyAnLCAnICsgc2NhbGUgXSA9IGNhY2hlZFZhbDtcblxuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24oIHVybCwgY3Jvc3NPcmlnaW4sIG9uTG9hZCApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlWyB1cmwgXTtcblxuICBpZiggY2FjaGUgKXtcbiAgICBpZiggIWNhY2hlLmltYWdlLmNvbXBsZXRlICl7XG4gICAgICBjYWNoZS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGUuaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUgPSBpbWFnZUNhY2hlWyB1cmwgXSA9IGltYWdlQ2FjaGVbIHVybCBdIHx8IHt9O1xuXG4gICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuXG4gICAgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcbiAgICB2YXIgZGF0YVVyaVByZWZpeCA9ICdkYXRhOic7XG4gICAgdmFyIGlzRGF0YVVyaSA9IHVybC5zdWJzdHJpbmcoIDAsIGRhdGFVcmlQcmVmaXgubGVuZ3RoICkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcbiAgICBpZiggIWlzRGF0YVVyaSApe1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgIH1cblxuICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi8uLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG5cbnZhciBCYXNlUmVuZGVyZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApeyB0aGlzLmluaXQoIG9wdGlvbnMgKTsgfTtcbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAgPSBCUi5wcm90b3R5cGU7XG5cbkJScC5jbGllbnRGdW5jdGlvbnMgPSBbICdyZWRyYXdIaW50JywgJ3JlbmRlcicsICdyZW5kZXJUbycsICdtYXRjaENhbnZhc1NpemUnLCAnbm9kZVNoYXBlSW1wbCcsICdhcnJvd1NoYXBlSW1wbCcgXTtcblxuQlJwLmluaXQgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5vcHRpb25zID0gb3B0aW9ucztcblxuICByLmN5ID0gb3B0aW9ucy5jeTtcblxuICByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG5cbiAgci5zZWxlY3Rpb24gPSBbIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbIDAuMDUsIDAuMjI1LCAwLjQsIDAuNSwgMC42LCAwLjc3NSwgMC45NSBdO1xuXG4gIC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuICByLmhvdmVyRGF0YSA9IHtkb3duOiBudWxsLCBsYXN0OiBudWxsLFxuICAgICAgZG93blRpbWU6IG51bGwsIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgaW5pdGlhbFBhbjogWyBudWxsLCBudWxsIF0sIGNhcHR1cmU6IGZhbHNlfTtcblxuICByLmRyYWdEYXRhID0ge3Bvc3NpYmxlRHJhZ0VsZW1lbnRzOiBbXX07XG5cbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsIGNhcHR1cmU6IGZhbHNlLFxuXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogWyBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsIF0sXG4gICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgc2luZ2xlVG91Y2hNb3ZlZDogdHJ1ZSxcblxuICAgIG5vdzogWyBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsIF0sXG4gICAgZWFybGllcjogWyBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsIF1cbiAgfTtcblxuICByLnJlZHJhd3MgPSAwO1xuICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG4gIHIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gIHIudGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICByLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gIHIubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcbiAgci5mb3JjZWRQaXhlbFJhdGlvID0gb3B0aW9ucy5waXhlbFJhdGlvO1xuICByLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgci5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICByLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgci5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcblxuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHsgLy8gaGlnaGVyIHByaW9yaXR5IGV4ZWNzIGJlZm9yZSBsb3dlciBvbmVcbiAgICBhbmltYXRpb25zOiAgIDQwMCxcbiAgICBlbGVDYWxjczogICAgIDMwMCxcbiAgICBlbGVUeHJEZXE6ICAgIDIwMCxcbiAgICBseXJUeHJEZXE6ICAgIDEwMFxuICB9O1xuXG4gIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbiAgci5sb2FkKCk7XG59O1xuXG5CUnAubm90aWZ5ID0gZnVuY3Rpb24oIHBhcmFtcyApe1xuICB2YXIgdHlwZXM7XG4gIHZhciByID0gdGhpcztcblxuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgbm90aWZpZWQgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgaWYoIHRoaXMuZGVzdHJveWVkICl7IHJldHVybjsgfVxuXG4gIGlmKCBpcy5hcnJheSggcGFyYW1zLnR5cGUgKSApe1xuICAgIHR5cGVzID0gcGFyYW1zLnR5cGU7XG5cbiAgfSBlbHNlIHtcbiAgICB0eXBlcyA9IFsgcGFyYW1zLnR5cGUgXTtcbiAgfVxuXG4gIHZhciBoYXMgPSB7fTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciB0eXBlID0gdHlwZXNbIGkgXTtcblxuICAgIGhhc1sgdHlwZSBdID0gdHJ1ZTtcbiAgfSAvLyBmb3JcblxuICBpZiggaGFzWydkZXN0cm95J10gKXtcbiAgICByLmRlc3Ryb3koKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiggaGFzWydhZGQnXSB8fCBoYXNbJ3JlbW92ZSddIHx8IGhhc1snbG9hZCddIHx8IGhhc1snem9yZGVyJ10gKXtcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICB9XG5cbiAgaWYoIGhhc1sndmlld3BvcnQnXSApe1xuICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgfVxuXG4gIGlmKCBoYXNbJ2xvYWQnXSB8fCBoYXNbJ3Jlc2l6ZSddICl7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICByLm1hdGNoQ2FudmFzU2l6ZSggci5jb250YWluZXIgKTtcbiAgfVxuXG4gIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcblxuICB0aGlzLnJlZHJhdygpO1xufTtcblxuQlJwLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbIGkgXTtcbiAgICB2YXIgYiA9IGJpbmRpbmc7XG4gICAgdmFyIHRndCA9IGIudGFyZ2V0O1xuXG4gICAgKCB0Z3Qub2ZmIHx8IHRndC5yZW1vdmVFdmVudExpc3RlbmVyICkuYXBwbHkoIHRndCwgYi5hcmdzICk7XG4gIH1cblxuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIub25VcGRhdGVFbGVDYWxjc0ZucyA9IFtdO1xuXG4gIGlmKCByLnJlbW92ZU9ic2VydmVyICl7XG4gICAgci5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiggci5zdHlsZU9ic2VydmVyICl7XG4gICAgci5zdHlsZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmKCByLmxhYmVsQ2FsY0RpdiApe1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCByLmxhYmVsQ2FsY0RpdiApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfSBjYXRjaCggZSApe1xuICAgICAgLy8gaWUxMCBpc3N1ZSAjMTAxNFxuICAgIH1cbiAgfVxufTtcblxuW1xuICByZXF1aXJlKCAnLi9hcnJvdy1zaGFwZXMnICksXG4gIHJlcXVpcmUoICcuL2Nvb3JkLWVsZS1tYXRoJyApLFxuICByZXF1aXJlKCAnLi9pbWFnZXMnICksXG4gIHJlcXVpcmUoICcuL2xvYWQtbGlzdGVuZXJzJyApLFxuICByZXF1aXJlKCAnLi9ub2RlLXNoYXBlcycgKSxcbiAgcmVxdWlyZSggJy4vcmVkcmF3JyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggQlJwLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJSO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoICcuLi8uLi8uLi9ldmVudCcgKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24oIHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKXtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoIGFyZ3VtZW50cywgWzFdICk7IC8vIGNvcHlcbiAgdmFyIGIgPSB0aGlzLmJpbmRlciggdGFyZ2V0ICk7XG5cbiAgcmV0dXJuIGIub24uYXBwbHkoIGIsIGFyZ3MgKTtcbn07XG5cbkJScC5iaW5kZXIgPSBmdW5jdGlvbiggdGd0ICl7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgdGd0SXNEb20gPSB0Z3QgPT09IHdpbmRvdyB8fCB0Z3QgPT09IGRvY3VtZW50IHx8IHRndCA9PT0gZG9jdW1lbnQuYm9keSB8fCBpcy5kb21FbGVtZW50KCB0Z3QgKTtcblxuICBpZiggci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPT0gbnVsbCApe1xuXG4gICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0ZXN0JywgbnVsbCwgb3B0cyApO1xuICAgIH0gY2F0Y2goIGVyciApe31cblxuICAgIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gc3VwcG9ydHNQYXNzaXZlO1xuICB9XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlICl7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgICBpZiggdGd0SXNEb20gJiYgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgKXsgLy8gcmVwbGFjZSB1c2VDYXB0dXJlIHcvIG9wdHMgb2JqXG4gICAgICBhcmdzWzJdID0ge1xuICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlICE9IG51bGwgPyB1c2VDYXB0dXJlIDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG5cbiAgICAoIHRndC5hZGRFdmVudExpc3RlbmVyIHx8IHRndC5vbiApLmFwcGx5KCB0Z3QsIGFyZ3MgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG9uLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IG9uLFxuICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICBiaW5kOiBvblxuICB9O1xufTtcblxuQlJwLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uKCBub2RlICl7XG4gIHJldHVybiAoXG4gICAgbm9kZVxuICAgICYmIG5vZGUuaXNOb2RlKClcbiAgICAmJiAhbm9kZS5sb2NrZWQoKVxuICAgICYmIG5vZGUuZ3JhYmJhYmxlKClcbiAgKTtcbn07XG5cbkJScC5ub2RlSXNHcmFiYmFibGUgPSBmdW5jdGlvbiggbm9kZSApe1xuICByZXR1cm4gKFxuICAgIHRoaXMubm9kZUlzRHJhZ2dhYmxlKCBub2RlIClcbiAgICAmJiBub2RlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWUgIT09IDBcbiAgICAmJiBub2RlLnBzdHlsZSggJ3Zpc2liaWxpdHknICkudmFsdWUgPT09ICd2aXNpYmxlJ1xuICAgICYmIG5vZGUucHN0eWxlKCAnZGlzcGxheScgKS52YWx1ZSA9PT0gJ2VsZW1lbnQnXG4gICk7XG59O1xuXG5CUnAubG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKCB0YXJnZXQsIG5hbWVzLCBlLCBwcm9wcyApe1xuICAgIGlmKCB0YXJnZXQgPT0gbnVsbCApe1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzWyBpIF07XG5cbiAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCggZSwgdXRpbC5leHRlbmQoIHsgdHlwZTogbmFtZSB9LCBwcm9wcyApICk7XG4gICAgICB0YXJnZXQudHJpZ2dlciggZXZlbnQgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiggZSApe1xuICAgIHJldHVybiBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7IC8vIG1heWJlIGUuYWx0S2V5XG4gIH07XG5cbiAgdmFyIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoID0gZnVuY3Rpb24oIGRvd24sIGRvd25zICl7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgaWYoIHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5pc0VkZ2UoKSApe1xuICAgICAgLy8gYSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlZGdlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciggdmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICBpZiggZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG5cbiAgdmFyIGdldERyYWdMaXN0SWRzID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICB2YXIgbGlzdEhhc0lkO1xuXG4gICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmIHIuY3kuaGFzQ29tcG91bmROb2RlcygpICl7IC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgIGlmKCAhb3B0cy5hZGRUb0xpc3QuaGFzSWQgKXsgLy8gYnVpbGQgaWRzIGxvb2t1cCBpZiBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IG9wdHMuYWRkVG9MaXN0WyBpIF07XG5cbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZFsgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdEhhc0lkID0gb3B0cy5hZGRUb0xpc3QuaGFzSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RIYXNJZCB8fCB7fTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEluRHJhZ0xheWVyID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlR3JhYlRhcmdldCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiggZWxlLCBvcHRzICl7XG4gICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICBpZiggIWxpc3RIYXNJZFsgZWxlLmlkKCkgXSApe1xuICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggZWxlICk7XG4gICAgICBsaXN0SGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICBzZXRHcmFiYmVkKCBlbGUgKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24oIG5vZGUsIG9wdHMgKXtcbiAgICBpZiggIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCApe1xuICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgYWRkVG9EcmFnTGlzdCggZWxlLCBvcHRzICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG4gIHZhciBhZGROb2Rlc1RvRHJhZyA9IGZ1bmN0aW9uKCBub2Rlcywgb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBub2Rlcy5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICBub2Rlcy5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuXG4gICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZm9yRWFjaCggc2V0SW5EcmFnTGF5ZXIgKTtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgKXtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICBhZGRUb0RyYWdMaXN0KCBlbGUsIG9wdHMgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKCBub2Rlcywgb3B0cyApOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoIG5vZGVzLCB7XG4gICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgIH0gKTtcblxuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuXG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGdyYWJiZWRFbGVzICl7XG4gICAgaWYoICFncmFiYmVkRWxlcyApeyByZXR1cm47IH1cblxuICAgIGdyYWJiZWRFbGVzLmhhc0lkID0ge307IC8vIGNsZWFyIHRoZSBpZCBsaXN0XG5cbiAgICAvLyBqdXN0IGdvIG92ZXIgYWxsIGVsZW1lbnRzIHJhdGhlciB0aGFuIGRvaW5nIGEgYnVuY2ggb2YgKHBvc3NpYmx5IGV4cGVuc2l2ZSkgdHJhdmVyc2Fsc1xuICAgIHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHNldEZyZWVkKCBlbGUgKTtcbiAgICAgIHNldE91dERyYWdMYXllciggZWxlICk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KCBlbGUgKTtcbiAgICB9KTtcblxuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG4gIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uKCBub2RlLCBvcHRzICl7XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIGlmKCAhbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTtcblxuICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICBpZiggcGFyZW50LnNhbWUoIG5vZGUgKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpXG4gICAgICAubWVyZ2UoIHBhcmVudCApXG4gICAgICAudW5tZXJnZSggbm9kZSApXG4gICAgICAudW5tZXJnZSggbm9kZS5kZXNjZW5kYW50cygpIClcbiAgICA7XG5cbiAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIGVkZ2VzLmZvckVhY2goIHNldEluRHJhZ0xheWVyICk7XG4gICAgICBub2Rlcy5mb3JFYWNoKCBzZXRJbkRyYWdMYXllciApO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCApe1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoIGVsZSwgb3B0cyApO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYXZlTXV0YXRpb25zQXBpID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIHdhdGNoIGZvciB3aGVuIHRoZSBjeSBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgaWYoIGhhdmVNdXRhdGlvbnNBcGkgKXtcbiAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIGZ1bmN0aW9uKCBtdXRucyApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBtdXRuID0gbXV0bnNbIGkgXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgIGlmKCByTm9kZXMgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbIGogXTtcblxuICAgICAgICAgIGlmKCByTm9kZSA9PT0gci5jb250YWluZXIgKXtcbiAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBpZiggci5jb250YWluZXIucGFyZW50Tm9kZSApe1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKCByLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0gKTtcbiAgfVxuXG4gIHZhciBvblJlc2l6ZSA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gICAgci5jeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG5cbiAgICByLm1hdGNoQ2FudmFzU2l6ZSggci5jb250YWluZXIgKTtcbiAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gICAgci5yZWRyYXcoKTtcbiAgfSwgMTAwICk7XG5cbiAgaWYoIGhhdmVNdXRhdGlvbnNBcGkgKXtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlciggb25SZXNpemUgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5zdHlsZU9ic2VydmVyLm9ic2VydmUoIHIuY29udGFpbmVyLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSApO1xuICB9XG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICB2YXIgaW52YWxDdG5yQkJPblNjcm9sbCA9IGZ1bmN0aW9uKCBkb21FbGUgKXtcbiAgICByLnJlZ2lzdGVyQmluZGluZyggZG9tRWxlLCAnc2Nyb2xsJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgfSApO1xuICB9O1xuXG4gIHZhciBiYkN0bnIgPSByLmN5LmNvbnRhaW5lcigpO1xuXG4gIGZvciggOzsgKXtcblxuICAgIGludmFsQ3RuckJCT25TY3JvbGwoIGJiQ3RuciApO1xuXG4gICAgaWYoIGJiQ3Ruci5wYXJlbnROb2RlICl7XG4gICAgICBiYkN0bnIgPSBiYkN0bnIucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiggZSApe1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSApO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICB9O1xuXG4gIHZhciBldmVudEluQ29udGFpbmVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG5cbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogWyBlIF07XG4gICAgdmFyIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcblxuICAgICAgaWYoIHggPD0gcC5jbGllbnRYICYmIHAuY2xpZW50WCA8PSB4ICsgd2lkdGhcbiAgICAgICAgJiYgeSA8PSBwLmNsaWVudFkgJiYgcC5jbGllbnRZIDw9IHkgKyBoZWlnaHRcbiAgICAgICl7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIWF0TGVhc3RPbmVQb3NJbnNpZGUgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSggdFBhcmVudCApe1xuICAgICAgaWYoIHRQYXJlbnQgPT09IGNvbnRhaW5lciApe1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmKCAhY29udGFpbmVySXNUYXJnZXQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFByaW1hcnkga2V5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoIGUgKXtcbiAgICBpZiggIWV2ZW50SW5Db250YWluZXIoZSkgKXsgcmV0dXJuOyB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgZ3BvcyA9IFsgZS5jbGllbnRYLCBlLmNsaWVudFkgXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBncG9zWzBdLCBncG9zWzFdICk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyggcG9zWzBdLCBwb3NbMV0sIGZhbHNlICk7XG4gICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24oKXtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KCByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCApO1xuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYoIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICBlbGUudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24gKTtcbiAgICB9O1xuXG4gICAgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG4gICAgaWYoIGUud2hpY2ggPT0gMyApe1xuXG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgdmFyIGN4dEV2dCA9IG5ldyBFdmVudCggZSwge1xuICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICBuZWFyLnRyaWdnZXIoIGN4dEV2dCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgfSBlbHNlIGlmKCBlLndoaWNoID09IDEgKXtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiggbmVhciAhPSBudWxsICl7XG5cbiAgICAgICAgICBpZiggci5ub2RlSXNHcmFiYmFibGUoIG5lYXIgKSApe1xuXG4gICAgICAgICAgICB2YXIgZ3JhYkV2ZW50ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIHNldEdyYWJUYXJnZXQoIG5lYXIgKTtcblxuICAgICAgICAgICAgaWYoICFuZWFyLnNlbGVjdGVkKCkgKXtcblxuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggZ3JhYkV2ZW50ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbICBdO1xuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJCggZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKCB0aGlzICk7IH0gKTtcblxuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyggc2VsZWN0ZWROb2RlcywgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBncmFiRXZlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3ducyA9IG5lYXJzO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJyBdLCBlLCB7XG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZiggbmVhciA9PSBudWxsICl7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG5cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiggbmVhci5pc0VkZ2UoKSApe1xuICAgICAgICBzZWxlY3RbNF0gPSAxOyAvLyBmb3IgZnV0dXJlIHBhblxuICAgICAgfVxuXG4gICAgICBjaGVja0ZvclRhcGhvbGQoKTtcblxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgfSwgZmFsc2UgKTtcblxuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlciggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYoICFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgZ3BvcyA9IFsgZS5jbGllbnRYLCBlLmNsaWVudFkgXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBncG9zWzBdLCBncG9zWzFdICk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggcG9zWzBdLCBwb3NbMV0sIGZhbHNlICk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICB2YXIgZGlzcCA9IFsgcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM10gXTtcblxuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiggbWRvd25HUG9zICl7XG4gICAgICB2YXIgZHggPSBncG9zWzBdIC0gbWRvd25HUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBncG9zWzFdIC0gbWRvd25HUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG5cbiAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oIGUgKTtcblxuICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgIGlmKCBkcmFnRGVsdGEubGVuZ3RoID09PSAwICl7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzBdICk7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAnbW91c2Vtb3ZlJywgJ3Ztb3VzZW1vdmUnLCAndGFwZHJhZycgXSwgZSwge1xuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApO1xuXG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbigpe1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiggIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICBjeS50cmlnZ2VyKCdib3hzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cbiAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG92ZXIgdGhyZXNob2xkXG4gICAgICBpZiggaXNPdmVyVGhyZXNob2xkRHJhZyApe1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSApICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG4gICAgfSBlbHNlIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApe1xuICAgICAgICB2YXIgZGVsdGFQO1xuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiApe1xuICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuXG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogKCBwb3NbMF0gLSBtZFBvc1swXSApICogem9vbSxcbiAgICAgICAgICAgIHk6ICggcG9zWzFdIC0gbWRQb3NbMV0gKSAqIHpvb21cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICBjeS5wYW5CeSggZGVsdGFQICk7XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG4gICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7XG5cbiAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYoXG4gICAgICAgIHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5pc0VkZ2UoKSlcbiAgICApe1xuXG4gICAgICBpZiggaXNPdmVyVGhyZXNob2xkRHJhZyApe1xuXG4gICAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmICggbXVsdFNlbEtleURvd24gfHwgIWN5LnBhbm5pbmdFbmFibGVkKCkgfHwgIWN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICkgKXtcbiAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmKCAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKCBkb3duLCByLmhvdmVyRGF0YS5kb3ducyApO1xuXG4gICAgICAgICAgaWYoIGFsbG93UGFzc3Rocm91Z2ggKXtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IG1hdGguYXJyYXkycG9pbnQoIG1kb3duUG9zICk7XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggZG93biAmJiBkb3duLmlzRWRnZSgpICYmIGRvd24uYWN0aXZlKCkgKXsgZG93bi51bmFjdGl2YXRlKCk7IH1cblxuICAgICAgaWYoICggIWRvd24gfHwgIWRvd24uZ3JhYmJlZCgpICkgJiYgbmVhciAhPSBsYXN0ICl7XG5cbiAgICAgICAgaWYoIGxhc3QgKXtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKCBsYXN0LCBbICdtb3VzZW91dCcsICd0YXBkcmFnb3V0JyBdLCBlLCB7XG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlcicgXSwgZSwge1xuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIGlmKCBkb3duICYmIHIubm9kZUlzRHJhZ2dhYmxlKCBkb3duICkgKXtcblxuICAgICAgICBpZiggaXNPdmVyVGhyZXNob2xkRHJhZyApeyAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuXG4gICAgICAgICAgaWYoIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93biApeyAvLyB0aGVuIHNlbGVjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgICAgIGlmKCBkb3duICYmIGRvd24uZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVtZW50cyApO1xuXG4gICAgICAgICAgICAgIGRvd24udHJpZ2dlcignZnJlZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UgZHJhZ1xuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuXG4gICAgICAgICAgICB2YXIgdG9UcmlnZ2VyID0gW107XG5cbiAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG4gICAgICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyApe1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyggY3kuY29sbGVjdGlvbiggZHJhZ2dlZEVsZW1lbnRzICksIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVtZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgZEVsZSA9IGRyYWdnZWRFbGVtZW50c1sgaSBdO1xuXG4gICAgICAgICAgICAgIC8vIExvY2tlZCBub2RlcyBub3QgZHJhZ2dhYmxlLCBhcyB3ZWxsIGFzIG5vbi12aXNpYmxlIG5vZGVzXG4gICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZSggZEVsZSApICYmIGRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgICAgdmFyIGRQb3MgPSBkRWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgdG9UcmlnZ2VyLnB1c2goIGRFbGUgKTtcblxuICAgICAgICAgICAgICAgIGlmKCBpcy5udW1iZXIoIGRpc3BbMF0gKSAmJiBpcy5udW1iZXIoIGRpc3BbMV0gKSApe1xuICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBvcyA9ICFkRWxlLmlzUGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgKXtcbiAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBkcmFnRGVsdGEgJiYgaXMubnVtYmVyKCBkcmFnRGVsdGFbMF0gKSAmJiBpcy5udW1iZXIoIGRyYWdEZWx0YVsxXSApICl7XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIHRjb2wgPSBjeS5jb2xsZWN0aW9uKCB0b1RyaWdnZXIgKTtcblxuICAgICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgICAgdGNvbC50cmlnZ2VyKCAncG9zaXRpb24gZHJhZycgKTtcblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0WzJdID0gcG9zWzBdOyBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICBpZiggcHJldmVudERlZmF1bHQgKXtcbiAgICAgIGlmKCBlLnN0b3BQcm9wYWdhdGlvbiApIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiggZS5wcmV2ZW50RGVmYXVsdCApIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIGZhbHNlICk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiBtb3VzZXVwSGFuZGxlciggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgIGlmKCAhY2FwdHVyZSApeyByZXR1cm47IH1cbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICB2YXIgY3kgPSByLmN5OyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLmNsaWVudFgsIGUuY2xpZW50WSApOyB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudCggcG9zWzBdLCBwb3NbMV0sIGZhbHNlICk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7IHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKCBlICk7XG5cbiAgICBpZiggci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuXG4gICAgaWYoIGRvd24gKXtcbiAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgdmFyIGN4dEV2dCA9IG5ldyBFdmVudCggZSwge1xuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKCBkb3duICl7XG4gICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgIHZhciBjeHRUYXAgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG5cbiAgICB9IGVsc2UgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAxICl7XG5cbiAgICAgIC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG4gICAgICBpZiggKGRvd24gPT0gbnVsbCkgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICAmJiAhaXNNdWx0U2VsS2V5RG93biggZSApXG4gICAgICApe1xuXG4gICAgICAgIGN5LiQoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgICAgfSApLnVuc2VsZWN0KCk7XG5cbiAgICAgICAgaWYoIGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnIF0sIGUsIHtcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKFxuICAgICAgICAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICApe1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKCBkb3duLCBbJ2NsaWNrJywgJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmdsZSBzZWxlY3Rpb25cbiAgICAgIGlmKCBuZWFyID09IGRvd24gJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgIGlmKCBuZWFyICE9IG51bGwgJiYgbmVhci5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgICAgIC8vIGlmIHBhbm5pbmcsIGRvbid0IGNoYW5nZSBzZWxlY3Rpb24gc3RhdGVcbiAgICAgICAgICB9IGVsc2UgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBtdWx0U2VsS2V5RG93biApe1xuICAgICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggIW11bHRTZWxLZXlEb3duICl7XG4gICAgICAgICAgICAgIGN5LiQoICc6c2VsZWN0ZWQnICkudW5tZXJnZSggbmVhciApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKCByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKSApO1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgICBpZiggYm94Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kudHJpZ2dlcignYm94ZW5kJyk7XG5cbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpOyB9O1xuXG4gICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgKXtcbiAgICAgICAgICBib3hcbiAgICAgICAgICAgIC50cmlnZ2VyKCdib3gnKVxuICAgICAgICAgICAgLnN0ZEZpbHRlciggZWxlV291bGRCZVNlbGVjdGVkIClcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKCdib3hzZWxlY3QnKVxuICAgICAgICAgIDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiggIW11bHRTZWxLZXlEb3duICl7XG4gICAgICAgICAgICBjeS4kKCAnOnNlbGVjdGVkJyApLnVubWVyZ2UoIGJveCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm94XG4gICAgICAgICAgICAudHJpZ2dlcignYm94JylcbiAgICAgICAgICAgIC5zdGRGaWx0ZXIoIGVsZVdvdWxkQmVTZWxlY3RlZCApXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAudHJpZ2dlcignYm94c2VsZWN0JylcbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBkcmFnIHBhblxuICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhc2VsZWN0WzRdICkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIGRvd25XYXNHcmFiYmVkID0gZG93biAmJiBkb3duLmdyYWJiZWQoKTtcblxuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlbWVudHMgKTtcblxuICAgICAgICBpZiggZG93bldhc0dyYWJiZWQgKXsgZG93bi50cmlnZ2VyKCdmcmVlJyk7IH1cbiAgICAgIH1cblxuICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuICAgIHNlbGVjdFs0XSA9IDA7IHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuXG4gICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcblxuICB9LCBmYWxzZSApO1xuXG4gIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiggZSApe1xuXG5cbiAgICBpZiggci5zY3JvbGxpbmdQYWdlICl7IHJldHVybjsgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7XG4gICAgdmFyIHJwb3MgPSBbIHBvc1swXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLngsXG4gICAgICAgICAgICAgICAgICBwb3NbMV0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS55IF07XG5cbiAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSApeyAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCggci5kYXRhLndoZWVsVGltZW91dCApO1xuICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgMTUwICk7XG5cbiAgICAgIHZhciBkaWZmO1xuXG4gICAgICBpZiggZS5kZWx0YVkgIT0gbnVsbCApe1xuICAgICAgICBkaWZmID0gZS5kZWx0YVkgLyAtMjUwO1xuICAgICAgfSBlbHNlIGlmKCBlLndoZWVsRGVsdGFZICE9IG51bGwgKXtcbiAgICAgICAgZGlmZiA9IGUud2hlZWxEZWx0YVkgLyAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IGUud2hlZWxEZWx0YSAvIDEwMDA7XG4gICAgICB9XG5cbiAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuXG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgaWYoIG5lZWRzV2hlZWxGaXggKXsgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgIH1cblxuICAgICAgY3kuem9vbSgge1xuICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coIDEwLCBkaWZmICksXG4gICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHsgeDogcnBvc1swXSwgeTogcnBvc1sxXSB9XG4gICAgICB9ICk7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUgKTtcblxuICAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCB3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKCBlICl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuXG4gICAgY2xlYXJUaW1lb3V0KCByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ICk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICB9LCAyNTAgKTtcbiAgfSwgdHJ1ZSApO1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ21vdXNlb3V0JywgZnVuY3Rpb24gbW91c2VPdXRIYW5kbGVyKCBlICl7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS5jbGllbnRYLCBlLmNsaWVudFkgKTtcblxuICAgIHIuY3kudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApICk7XG4gIH0sIGZhbHNlICk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlciggZSApe1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUuY2xpZW50WCwgZS5jbGllbnRZICk7XG5cbiAgICByLmN5LnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICB9ICkgKTtcbiAgfSwgZmFsc2UgKTtcblxuICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG4gIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG4gIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiApe1xuICAgIHJldHVybiBNYXRoLnNxcnQoICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSApO1xuICB9O1xuXG4gIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24oIHgxLCB5MSwgeDIsIHkyICl7XG4gICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgfTtcblxuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKCByLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgaWYoICFldmVudEluQ29udGFpbmVyKGUpICl7IHJldHVybjsgfVxuXG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgIGlmKCBlLnRvdWNoZXNbMV0gKXtcblxuICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggci5kcmFnRGF0YS50b3VjaERyYWdFbGVzICk7XG5cbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuXG4gICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPVxuICAgICAgICAgICAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHRcbiAgICAgICAgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICA7XG5cbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKCBmMXgxLCBmMXkxLCBmMngxLCBmMnkxICk7XG4gICAgICBjZW50ZXIxID0gWyAoZjF4MSArIGYyeDEpIC8gMiwgKGYxeTEgKyBmMnkxKSAvIDIgXTtcbiAgICAgIG1vZGVsQ2VudGVyMSA9IFtcbiAgICAgICAgKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21cbiAgICAgIF07XG5cbiAgICAgIC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgIGlmKCBkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdICl7XG5cbiAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIG5vd1swXSwgbm93WzFdLCB0cnVlICk7XG4gICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMl0sIG5vd1szXSwgdHJ1ZSApO1xuXG4gICAgICAgIGlmKCBuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSApe1xuICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSApICk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMTtcblxuICAgICAgICB9IGVsc2UgaWYoIG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpICl7XG4gICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggbmV3IEV2ZW50KCBlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSApICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYoIGUudG91Y2hlc1syXSApe1xuICAgICAgLy8gaWdub3JlXG4gICAgfSBlbHNlIGlmKCBlLnRvdWNoZXNbMV0gKXtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzBdICl7XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMoIG5vd1swXSwgbm93WzFdLCB0cnVlICk7XG4gICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuXG4gICAgICBpZiggbmVhciAhPSBudWxsICl7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcblxuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0cyA9IG5lYXJzO1xuXG4gICAgICAgIGlmKCByLm5vZGVJc0dyYWJiYWJsZSggbmVhciApICl7XG5cbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBbXTtcblxuICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcblxuICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoIHRoaXMgKTtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoIHNlbGVjdGVkTm9kZXMsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0R3JhYlRhcmdldCggbmVhciApO1xuXG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsgJ3RvdWNoc3RhcnQnLCAndGFwc3RhcnQnLCAndm1vdXNlZG93bicgXSwgZSwge1xuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYoIG5lYXIgPT0gbnVsbCApe1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBUYXAsIHRhcGhvbGRcbiAgICAgIC8vIC0tLS0tXG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgKTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZVxuICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICl7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyggci50b3VjaERhdGEuc3RhcnQsIFsgJ3RhcGhvbGQnIF0sIGUsIHtcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKTtcblxuICAgICAgICAgIGlmKCAhci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICAgIGN5LiQoICc6c2VsZWN0ZWQnICkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24gKTtcbiAgICB9XG5cbiAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA+PSAxICl7XG4gICAgICB2YXIgc1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgc1Bvc1tpXSA9IGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3VjaDAgPSBlLnRvdWNoZXNbMF07XG5cbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gWyB0b3VjaDAuY2xpZW50WCwgdG91Y2gwLmNsaWVudFkgXTtcbiAgICB9XG5cbiAgfSwgZmFsc2UgKTtcblxuICB2YXIgdG91Y2htb3ZlSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgIGlmKCAhY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSApeyByZXR1cm47IH1cblxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgaWYoIGUudG91Y2hlc1swXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkgKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzFdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSApOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgIGlmKCBlLnRvdWNoZXNbMl0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZICk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zICl7XG4gICAgICB2YXIgZGlzcCA9IFtdOyBmb3IgKHZhciBqPTA7ajxub3cubGVuZ3RoO2orKykgeyBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTsgfVxuICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG5cbiAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMjtcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcbiAgICBpZiggY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIHZhciBmYWN0b3JTcSA9IGRpc3RhbmNlMlNxIC8gZGlzdGFuY2UxU3E7XG5cbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDtcblxuICAgICAgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuICAgICAgaWYoIGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSApe1xuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcblxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0XG4gICAgICAgICAgICAudW5hY3RpdmF0ZSgpXG4gICAgICAgICAgICAudHJpZ2dlciggY3h0RXZ0IClcbiAgICAgICAgICA7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNvbnRleHQgc3dpcGVcbiAgICBpZiggY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgIHZhciBjeHRFdnQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSApO1xuXG4gICAgICBpZiggIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyBFdmVudCggZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgLy8gYm94IHNlbGVjdGlvblxuICAgIH0gZWxzZSBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiggIXIudG91Y2hEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICBjeS50cmlnZ2VyKCdib3hzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgIGlmKCAhc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMyArIDE7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAvLyBwaW5jaCB0byB6b29tXG4gICAgfSBlbHNlIGlmKCBjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXsgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgIGlmKCBkcmFnZ2VkRWxlcyApe1xuICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZGVfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuXG4gICAgICAgICAgZGVfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZGVfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG5cbiAgICAgIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcbiAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG5cbiAgICAgIGlmKCB0d29GaW5nZXJzU3RhcnRJbnNpZGUgKXtcbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxO1xuXG4gICAgICAgIC8vIGRlbHRhIGZpbmdlciAyXG4gICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpIC8gMjtcbiAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KSAvIDI7XG5cbiAgICAgICAgLy8gYWRqdXN0IGZhY3RvciBieSB0aGUgc3BlZWQgbXVsdGlwbGllclxuICAgICAgICAvLyB2YXIgc3BlZWQgPSAxLjU7XG4gICAgICAgIC8vIGlmKCBmYWN0b3IgPiAxICl7XG4gICAgICAgIC8vICAgZmFjdG9yID0gKGZhY3RvciAtIDEpICogc3BlZWQgKyAxO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIGZhY3RvciA9IDEgLSAoMSAtIGZhY3RvcikgKiBzcGVlZDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTtcblxuICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcblxuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBkcmFnZ2VkIGVsZXNcbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICYmIHIudG91Y2hEYXRhLnN0YXJ0LmFjdGl2ZSgpICl7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZXMgKTtcblxuICAgICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0XG4gICAgICAgICAgICAudW5hY3RpdmF0ZSgpXG4gICAgICAgICAgICAudHJpZ2dlciggJ2ZyZWUnIClcbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgICBjeS52aWV3cG9ydCgge1xuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG5cbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiggZS50b3VjaGVzWzFdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSApOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgaWYoIGUudG91Y2hlc1syXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkgKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzBdICl7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgIHZhciBuZWFyO1xuXG4gICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KCBub3dbMF0sIG5vd1sxXSwgdHJ1ZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZ2dpbmcgbm9kZXNcbiAgICAgIGlmKCBjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoIHN0YXJ0ICkgKXtcblxuICAgICAgICBpZiggaXNPdmVyVGhyZXNob2xkRHJhZyApeyAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyggY3kuY29sbGVjdGlvbiggZHJhZ2dlZEVsZXMgKSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGUgPSBkcmFnZ2VkRWxlc1sgayBdO1xuXG4gICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIGRyYWdnZWRFbGUgKSAmJiBkcmFnZ2VkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRyYWdnZWRFbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICAgIHZhciB1cGRhdGVQb3MgPSAhZHJhZ2dlZEVsZS5pc1BhcmVudCgpO1xuXG4gICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgaXMubnVtYmVyKCBkaXNwWzBdICkgJiYgaXMubnVtYmVyKCBkaXNwWzFdICkgKXtcbiAgICAgICAgICAgICAgICBkUG9zLnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgZHJhZ0RlbHRhICYmIGlzLm51bWJlciggZHJhZ0RlbHRhWzBdICkgJiYgaXMubnVtYmVyKCBkcmFnRGVsdGFbMV0gKSApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGNvbCA9IGN5LmNvbGxlY3Rpb24oIGRyYWdnZWRFbGVzICk7XG5cbiAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgdGNvbC50cmlnZ2VyKCAncG9zaXRpb24gZHJhZycgKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF1cbiAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXVxuICAgICAgICAgICl7XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRvdWNobW92ZVxuICAgICAge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKCAoc3RhcnQgfHwgbmVhciksIFsgJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnIF0sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCAoICFzdGFydCB8fCAhc3RhcnQuZ3JhYmJlZCgpICkgJiYgbmVhciAhPSBsYXN0ICl7XG4gICAgICAgICAgaWYoIGxhc3QgKXsgbGFzdC50cmlnZ2VyKCBuZXcgRXZlbnQoIGUsIHsgdHlwZTogJ3RhcGRyYWdvdXQnLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSApICk7IH1cbiAgICAgICAgICBpZiggbmVhciApeyBuZWFyLnRyaWdnZXIoIG5ldyBFdmVudCggZSwgeyB0eXBlOiAndGFwZHJhZ292ZXInLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSApICk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuICAgICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBpZiggbm93WyBpIF1cbiAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bIGkgXVxuICAgICAgICAgICAgJiYgaXNPdmVyVGhyZXNob2xkRHJhZyApe1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFubmluZ1xuICAgICAgaWYoXG4gICAgICAgICAgY2FwdHVyZVxuICAgICAgICAgICYmICggc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5pc0VkZ2UoKSApXG4gICAgICAgICAgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKVxuICAgICAgKXtcblxuICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKCBzdGFydCwgci50b3VjaERhdGEuc3RhcnRzICk7XG5cbiAgICAgICAgaWYoIGFsbG93UGFzc3Rocm91Z2ggKXtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiggci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgICAgIGN5LnBhbkJ5KCB7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgfSBlbHNlIGlmKCBpc092ZXJUaHJlc2hvbGREcmFnICl7XG4gICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGN5LnBhbkJ5KCB7XG4gICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYoICFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBtYXRoLmFycmF5MnBvaW50KCByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoICdzZWxlY3QnLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkgKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKysgKXsgZWFybGllclsgaiBdID0gbm93WyBqIF07IH1cbiAgICAvL3IucmVkcmF3KCk7XG5cbiAgfSwgZmFsc2UgKTtcblxuICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiggc3RhcnQgKXtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH0gKTtcblxuICB2YXIgdG91Y2hlbmRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyggd2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiggZSApeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiggY2FwdHVyZSApe1xuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmKCBlLnRvdWNoZXNbMF0gKXsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydCggZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZICk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYoIGUudG91Y2hlc1sxXSApeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KCBlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkgKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiggZS50b3VjaGVzWzJdICl7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoIGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSApOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgaWYoIHN0YXJ0ICl7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eFRhcGVuZDtcbiAgICBpZiggci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBjdHhUYXBlbmQgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgIHZhciBjdHhUYXAgPSBuZXcgRXZlbnQoIGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuICAgIGlmKCAhZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuXG4gICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbiggci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICkgKTtcblxuICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuXG4gICAgICBjeS50cmlnZ2VyKCdib3hlbmQnKTtcblxuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpOyB9O1xuXG4gICAgICBib3hcbiAgICAgICAgLnRyaWdnZXIoJ2JveCcpXG4gICAgICAgIC5zdGRGaWx0ZXIoIGVsZVdvdWxkQmVTZWxlY3RlZCApXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2JveHNlbGVjdCcpXG4gICAgICA7XG5cbiAgICAgIGlmKCBib3gubm9uZW1wdHkoKSApe1xuICAgICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGlmKCBzdGFydCAhPSBudWxsICl7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYoIGUudG91Y2hlc1syXSApe1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCAnc2VsZWN0JywgdHJ1ZSApO1xuICAgIH0gZWxzZSBpZiggZS50b3VjaGVzWzFdICl7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9IGVsc2UgaWYoIGUudG91Y2hlc1swXSApe1xuICAgICAgLy8gaWdub3JlXG5cbiAgICAvLyBMYXN0IHRvdWNoIHJlbGVhc2VkXG4gICAgfSBlbHNlIGlmKCAhZS50b3VjaGVzWzBdICl7XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCggJ3NlbGVjdCcsIHRydWUgKTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiggc3RhcnQgIT0gbnVsbCApe1xuXG4gICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuXG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVzICk7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcblxuICAgICAgICBpZiggc3RhcnRXYXNHcmFiYmVkICl7XG4gICAgICAgICAgc3RhcnQudHJpZ2dlciggJ2ZyZWUnICk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyRXZlbnRzKCBzdGFydCwgWyAndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnIF0sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQoIG5vd1swXSwgbm93WzFdLCB0cnVlICk7XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyAndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnIF0sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICBpZiggc3RhcnQgIT0gbnVsbFxuICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgJiYgc3RhcnQuX3ByaXZhdGUuc2VsZWN0YWJsZVxuICAgICAgICAgICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyXG4gICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICl7XG5cbiAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICBjeS4kKCAnOnNlbGVjdGVkJyApLnVubWVyZ2UoIHN0YXJ0ICkudW5zZWxlY3QoKTtcbiAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiggc3RhcnQuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgc3RhcnQudW5zZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG4gICAgICBpZiggIXIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgKXtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyggc3RhcnQsIFsgJ3RhcCcsICd2Y2xpY2snIF0sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKyApeyBlYXJsaWVyWyBqIF0gPSBub3dbIGogXTsgfVxuXG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IG1vdXNlZG93blxuXG4gICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPT09IDAgKXtcbiAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPCAyICl7XG4gICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvL3IucmVkcmF3KCk7XG5cbiAgfSwgZmFsc2UgKTtcblxuICAvLyBmYWxsYmFjayBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBtcyBwb2ludGVyIGV2ZW50c1xuICBpZiggdHlwZW9mIFRvdWNoRXZlbnQgPT09ICd1bmRlZmluZWQnICl7XG5cbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcblxuICAgIHZhciBtYWtlVG91Y2ggPSBmdW5jdGlvbiggZSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIGZvcmNlOiAxLFxuICAgICAgICBpZGVudGlmaWVyOiBlLnBvaW50ZXJJZCxcbiAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICByYWRpdXNYOiBlLndpZHRoIC8gMixcbiAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQgLyAyLFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VQb2ludGVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKCBlIClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhZGRQb2ludGVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHBvaW50ZXJzLnB1c2goIG1ha2VQb2ludGVyKCBlICkgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzWyBpIF07XG5cbiAgICAgICAgaWYoIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCApe1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlciggZnVuY3Rpb24oIHAgKXtcbiAgICAgICAgcmV0dXJuIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZDtcbiAgICAgIH0gKVswXTtcblxuICAgICAgcC5ldmVudCA9IGU7XG4gICAgICBwLnRvdWNoID0gbWFrZVRvdWNoKCBlICk7XG4gICAgfTtcblxuICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoIGZ1bmN0aW9uKCBwICl7XG4gICAgICAgIHJldHVybiBwLnRvdWNoO1xuICAgICAgfSApO1xuICAgIH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uKCBlICl7XG4gICAgICBpZiggZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgYWRkUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2hzdGFydEhhbmRsZXIoIGUgKTtcbiAgICB9ICk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbiggZSApe1xuICAgICAgaWYoIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaGVuZEhhbmRsZXIoIGUgKTtcbiAgICB9ICk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyggci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24oIGUgKXtcbiAgICAgIGlmKCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKCBlICk7XG4gICAgfSApO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoIHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiggZSApe1xuICAgICAgaWYoIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHVwZGF0ZVBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNobW92ZUhhbmRsZXIoIGUgKTtcbiAgICB9ICk7XG5cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLmdlbmVyYXRlUG9seWdvbiA9IGZ1bmN0aW9uKCBuYW1lLCBwb2ludHMgKXtcbiAgcmV0dXJuICggdGhpcy5ub2RlU2hhcGVzWyBuYW1lIF0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiBuYW1lLFxuXG4gICAgcG9pbnRzOiBwb2ludHMsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCAncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcgKXtcbiAgICAgIHJldHVybiBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgdGhpcy5wb2ludHMsXG4gICAgICAgICAgbm9kZVgsXG4gICAgICAgICAgbm9kZVksXG4gICAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICAgIHBhZGRpbmcgKVxuICAgICAgICA7XG4gICAgfSxcblxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKCB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZICl7XG4gICAgICByZXR1cm4gbWF0aC5wb2ludEluc2lkZVBvbHlnb24oIHgsIHksIHRoaXMucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nIClcbiAgICAgIDtcbiAgICB9XG4gIH0gKTtcbn07XG5cbkJScC5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKCB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcblxuICAgIG5hbWU6ICdlbGxpcHNlJyxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoIHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICByZXR1cm4gbWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIgKyBwYWRkaW5nLFxuICAgICAgICBoZWlnaHQgLyAyICsgcGFkZGluZyApXG4gICAgICA7XG4gICAgfSxcblxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKCB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZICl7XG4gICAgICB4IC09IGNlbnRlclg7XG4gICAgICB5IC09IGNlbnRlclk7XG5cbiAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuXG4gICAgICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xuICAgIH1cbiAgfSApO1xufTtcblxuQlJwLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gKCB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiAncm91bmRyZWN0YW5nbGUnLFxuXG4gICAgcG9pbnRzOiBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSggNCwgMCApLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCggdGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcgKXtcbiAgICAgIHJldHVybiBtYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBwYWRkaW5nIClcbiAgICAgIDtcbiAgICB9LFxuXG4gICAgLy8gTG9va3MgbGlrZSB0aGUgd2lkdGggcGFzc2VkIGludG8gdGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSB0aGUgdG90YWwgd2lkdGggLyAyXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZICl7XG5cbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmKCBtYXRoLnBvaW50SW5zaWRlUG9seWdvbiggeCwgeSwgdGhpcy5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogY29ybmVyUmFkaXVzLCBbMCwgLTFdLCBwYWRkaW5nICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmKCBtYXRoLnBvaW50SW5zaWRlUG9seWdvbiggeCwgeSwgdGhpcy5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIGNvcm5lclJhZGl1cywgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nICkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja0luRWxsaXBzZSA9IGZ1bmN0aW9uKCB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nICl7XG4gICAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgICAgeSAtPSBjZW50ZXJZO1xuXG4gICAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG5cbiAgICAgICAgcmV0dXJuICh4ICogeCArIHkgKiB5IDw9IDEpO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYoIGNoZWNrSW5FbGxpcHNlKCB4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZyApICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYoIGNoZWNrSW5FbGxpcHNlKCB4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZyApICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYoIGNoZWNrSW5FbGxpcHNlKCB4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZyApICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiggY2hlY2tJbkVsbGlwc2UoIHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nICkgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSApO1xufTtcblxuQlJwLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBub2RlU2hhcGVzID0gdGhpcy5ub2RlU2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgdGhpcy5nZW5lcmF0ZUVsbGlwc2UoKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3RyaWFuZ2xlJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDMsIDAgKSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAncmVjdGFuZ2xlJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDQsIDAgKSApO1xuICBub2RlU2hhcGVzWyAnc3F1YXJlJyBdID0gbm9kZVNoYXBlc1sgJ3JlY3RhbmdsZScgXTtcblxuICB0aGlzLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUoKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ2RpYW1vbmQnLCBbXG4gICAgMCwgMSxcbiAgICAxLCAwLFxuICAgIDAsIC0xLFxuICAgIC0xLCAwXG4gIF0gKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3BlbnRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDUsIDAgKSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAnaGV4YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA2LCAwICkgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ2hlcHRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoIDcsIDAgKSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAnb2N0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKCA4LCAwICkgKTtcblxuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoIDIwICk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIDUsIDAgKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIDUsIE1hdGguUEkgLyA1ICk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KCA1ICkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG5cbiAgICBmb3IoIHZhciBpID0gMDtpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjtpKysgKXtcbiAgICAgIGlubmVyUG9pbnRzWyBpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1sgaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDtpIDwgMjAgLyA0O2krKyApe1xuICAgICAgc3RhcjVQb2ludHNbIGkgKiA0XSA9IG91dGVyUG9pbnRzWyBpICogMl07XG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzWyBpICogMiArIDFdO1xuXG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAyXSA9IGlubmVyUG9pbnRzWyBpICogMl07XG4gICAgICBzdGFyNVBvaW50c1sgaSAqIDQgKyAzXSA9IGlubmVyUG9pbnRzWyBpICogMiArIDFdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXI1UG9pbnRzID0gbWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHN0YXI1UG9pbnRzICk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oICdzdGFyJywgc3RhcjVQb2ludHMgKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbiggJ3ZlZScsIFtcbiAgICAtMSwgLTEsXG4gICAgMCwgLTAuMzMzLFxuICAgIDEsIC0xLFxuICAgIDAsIDFcbiAgXSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCAncmhvbWJvaWQnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAuMzMzLCAtMSxcbiAgICAxLCAxLFxuICAgIC0wLjMzMywgMVxuICBdICk7XG5cbiAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcblxuICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuXG4gICAgdmFyIGtleSA9IHBvaW50cy5qb2luKCAnJCcgKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgaWYoIChzaGFwZSA9IHRoaXNbIG5hbWUgXSkgKXsgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbiggbmFtZSwgcG9pbnRzICk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcblxuQlJwLnJlZHJhdyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYoIHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDsgfVxuICBpZiggci5sYXN0UmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHIubGFzdFJlZHJhd1RpbWUgPSAwOyB9XG4gIGlmKCByLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHIubGFzdERyYXdUaW1lID0gMDsgfVxuXG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuQlJwLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uKCBmbiwgcHJpb3JpdHkgKXtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiggdGhpcy5kZXN0cm95ZWQgKXsgcmV0dXJuOyB9XG5cbiAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXG4gIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcblxuICBjYnMucHVzaCh7IGZuOiBmbiwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuXG4gIC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcbiAgY2JzLnNvcnQoZnVuY3Rpb24oIGEsIGIgKXsgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5OyB9KTtcbn07XG5cbnZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiggciwgd2lsbERyYXcsIHN0YXJ0VGltZSApe1xuICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKysgKXtcbiAgICBjYnNbaV0uZm4oIHdpbGxEcmF3LCBzdGFydFRpbWUgKTtcbiAgfVxufTtcblxuQlJwLnN0YXJ0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcztcblxuICBpZiggci5yZW5kZXJMb29wU3RhcnRlZCApe1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uKCByZXF1ZXN0VGltZSApe1xuICAgIGlmKCByLmRlc3Ryb3llZCApeyByZXR1cm47IH1cblxuICAgIGlmKCByLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSApe1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKCByLCB0cnVlLCByZXF1ZXN0VGltZSApO1xuXG4gICAgICB2YXIgc3RhcnRUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICByLnJlbmRlciggci5yZW5kZXJPcHRpb25zICk7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gci5sYXN0RHJhd1RpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgaWYoIHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuXG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyggciwgZmFsc2UsIHJlcXVlc3RUaW1lICk7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuICB9O1xuXG4gIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24oIG5hbWUgKXtcbiAgcmV0dXJuICggaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAncG9seWdvbic6IGZ1bmN0aW9uKCBjb250ZXh0LCBwb2ludHMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1sgaSBdO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICd0cmlhbmdsZS1iYWNrY3VydmUnOiBmdW5jdGlvbiggY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQgKXtcbiAgICAgIHZhciBmaXJzdFB0O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbIGkgXTtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSApO1xuICAgIH0sXG5cbiAgICAndHJpYW5nbGUtdGVlJzogZnVuY3Rpb24oIGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMgKXtcbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRyaVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiggY29udGV4dC5jbG9zZVBhdGggKXsgY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gICAgICAgIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRlZVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLWNyb3NzJzogZnVuY3Rpb24oIGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCBjcm9zc0xpbmVQb2ludHMgKXtcbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwdCA9IHRyaVB0c1sgaSBdO1xuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiggY29udGV4dC5jbG9zZVBhdGggKXsgY29udGV4dC5jbG9zZVBhdGgoKTsgfVxuXG5cbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSBjcm9zc0xpbmVQb2ludHM7XG4gICAgICB2YXIgZmlyc3RUZWVQdCA9IGNyb3NzTGluZVBvaW50c1swXTtcbiAgICAgIGNvbnRleHQubW92ZVRvKCBmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNyb3NzTGluZVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBjcm9zc0xpbmVQdHNbIGkgXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuICAgICAgaWYoIGNvbnRleHQuY2xvc2VQYXRoICl7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH1cbiAgICB9LFxuXG4gICAgJ2NpcmNsZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCByeCwgcnksIHIgKXtcbiAgICAgIGNvbnRleHQuYXJjKCByeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSApO1xuICAgIH1cbiAgfSkgKVsgbmFtZSBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmRyYXdFZGdlID0gZnVuY3Rpb24oIGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGRyYXdMYWJlbCwgZHJhd092ZXJsYXlJbnN0ZWFkICl7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuICBpZiggcnMuYmFkTGluZSB8fCBpc05hTihycy5hbGxwdHNbMF0pICl7IC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCAhZWRnZS52aXNpYmxlKCkgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIGJiO1xuICBpZiggc2hpZnRUb09yaWdpbldpdGhCYiApe1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKCAtYmIueDEsIC1iYi55MSApO1xuICB9XG5cbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gZWRnZS5wc3R5bGUoICdvdmVybGF5LXBhZGRpbmcnICkucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gZWRnZS5wc3R5bGUoICdvdmVybGF5LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBlZGdlLnBzdHlsZSggJ292ZXJsYXktY29sb3InICkudmFsdWU7XG5cbiAgLy8gRWRnZSBjb2xvciAmIG9wYWNpdHlcbiAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApe1xuXG4gICAgaWYoIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgbm8gb3ZlcmxheVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5ICk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PSAnc2VsZicgJiYgIXVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVkZ2UucHN0eWxlKCAnbGluZS1jb2xvcicgKS52YWx1ZTtcblxuICAgIHRoaXMuc3Ryb2tlU3R5bGUoIGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIGVkZ2UucHN0eWxlKCAnb3BhY2l0eScgKS52YWx1ZSApO1xuXG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9XG5cbiAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCAnd2lkdGgnICkucGZWYWx1ZSArIChkcmF3T3ZlcmxheUluc3RlYWQgPyAyICogb3ZlcmxheVBhZGRpbmcgOiAwKTtcbiAgdmFyIGxpbmVTdHlsZSA9IGRyYXdPdmVybGF5SW5zdGVhZCA/ICdzb2xpZCcgOiBlZGdlLnBzdHlsZSggJ2xpbmUtc3R5bGUnICkudmFsdWU7XG4gIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoO1xuXG4gIHZhciBzaGFkb3dCbHVyID0gZWRnZS5wc3R5bGUoICdzaGFkb3ctYmx1cicgKS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCAnc2hhZG93LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBzaGFkb3dDb2xvciA9IGVkZ2UucHN0eWxlKCAnc2hhZG93LWNvbG9yJyApLnZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IGVkZ2UucHN0eWxlKCAnc2hhZG93LW9mZnNldC14JyApLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gZWRnZS5wc3R5bGUoICdzaGFkb3ctb2Zmc2V0LXknICkucGZWYWx1ZTtcblxuICB0aGlzLnNoYWRvd1N0eWxlKCBjb250ZXh0LCAgc2hhZG93Q29sb3IsIGRyYXdPdmVybGF5SW5zdGVhZCA/IDAgOiBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZICk7XG5cbiAgdGhpcy5kcmF3RWRnZVBhdGgoXG4gICAgZWRnZSxcbiAgICBjb250ZXh0LFxuICAgIHJzLmFsbHB0cyxcbiAgICBsaW5lU3R5bGUsXG4gICAgZWRnZVdpZHRoXG4gICk7XG5cbiAgdGhpcy5kcmF3QXJyb3doZWFkcyggY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkICk7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcblxuICBpZiggIWRyYXdPdmVybGF5SW5zdGVhZCApe1xuICAgIHRoaXMuZHJhd0VkZ2UoIGNvbnRleHQsIGVkZ2UsIGZhbHNlLCBkcmF3TGFiZWwsIHRydWUgKTtcbiAgfVxuXG4gIHRoaXMuZHJhd0VsZW1lbnRUZXh0KCBjb250ZXh0LCBlZGdlLCBkcmF3TGFiZWwgKTtcblxuICBpZiggc2hpZnRUb09yaWdpbldpdGhCYiApe1xuICAgIGNvbnRleHQudHJhbnNsYXRlKCBiYi54MSwgYmIueTEgKTtcbiAgfVxufTtcblxuXG5DUnAuZHJhd0VkZ2VQYXRoID0gZnVuY3Rpb24oIGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSwgd2lkdGggKXtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oICckJyApO1xuICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuXG4gICAgaWYoIGtleU1hdGNoZXMgKXtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYoIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBzd2l0Y2goIHR5cGUgKXtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCggWyAxLCAxIF0gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCggWyA2LCAzIF0gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKCBbIF0gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoICFwYXRoQ2FjaGVIaXQgJiYgIXJzLmJhZExpbmUgKXtcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgIGNvbnRleHQubW92ZVRvKCBwdHNbMF0sIHB0c1sxXSApO1xuXG4gICAgc3dpdGNoKCBycy5lZGdlVHlwZSApe1xuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICBmb3IoIHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSwgcHRzWyBpICsgMl0sIHB0c1sgaSArIDNdICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgZm9yKCB2YXIgaSA9IDI7IGkgKyAxIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oIHB0c1sgaSBdLCBwdHNbIGkgKyAxXSApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIF0gKTtcbiAgfVxuXG59O1xuXG5DUnAuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiggY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkICl7XG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXsgcmV0dXJuOyB9IC8vIGRvbid0IGRvIGFueXRoaW5nIGZvciBvdmVybGF5c1xuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlICk7XG4gIH1cblxuICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSApO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlICk7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiggY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSApe1xuICBpZiggaXNOYU4oIHggKSB8fCB4ID09IG51bGwgfHwgaXNOYU4oIHkgKSB8fCB5ID09IG51bGwgfHwgaXNOYU4oIGFuZ2xlICkgfHwgYW5nbGUgPT0gbnVsbCApeyByZXR1cm47IH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUoIHByZWZpeCArICctYXJyb3ctc2hhcGUnICkudmFsdWU7XG4gIGlmKCBhcnJvd1NoYXBlID09PSAnbm9uZScgKSB7IHJldHVybjsgfVxuXG4gIHZhciBhcnJvd0NsZWFyRmlsbCA9IGVkZ2UucHN0eWxlKCBwcmVmaXggKyAnLWFycm93LWZpbGwnICkudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZSggcHJlZml4ICsgJy1hcnJvdy1maWxsJyApLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoICd3aWR0aCcgKS5wZlZhbHVlO1xuICB2YXIgb3BhY2l0eSA9IGVkZ2UucHN0eWxlKCAnb3BhY2l0eScgKS52YWx1ZTtcblxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgdmFyIHNoYXBlSW1wbCA9IHNlbGYuYXJyb3dTaGFwZXNbIGFycm93U2hhcGUgXTtcblxuICAvLyBjaGVjayBpZiB0aGUgc2hhcGUgbmVlZHMgYm90aCBmaWxsIGFuZCBzdHJva2Ugb3BlcmF0aW9ucyB0byBiZSBkcmF3blxuICBpZiggc2hhcGVJbXBsLmZvcmNlU3Ryb2tlICYmIGFycm93RmlsbCA9PT0gJ2ZpbGxlZCcgKXtcbiAgICBhcnJvd0ZpbGwgPSAnYm90aCc7XG4gIH1cblxuICBpZiggb3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnICl7IC8vIHRoZW4gZXh0cmEgY2xlYXIgaXMgbmVlZGVkXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgIHNlbGYuZmlsbFN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxICk7XG4gICAgc2VsZi5zdHJva2VTdHlsZSggY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSApO1xuXG4gICAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LFxuICAgICAgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGVcbiAgICApO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKCBwcmVmaXggKyAnLWFycm93LWNvbG9yJyApLnZhbHVlO1xuICBzZWxmLmZpbGxTdHlsZSggY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSApO1xuICBzZWxmLnN0cm9rZVN0eWxlKCBjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5ICk7XG5cbiAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LFxuICAgIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZVxuICApO1xufTtcblxuQ1JwLmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24oIGVkZ2UsIGFycm93VHlwZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgYW5nbGUgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhdGg7XG4gIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgdmFyIHRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XG4gIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCAnYXJyb3ctc2NhbGUnICkudmFsdWU7XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlV2lkdGgsIHNjYWxlICk7XG4gIHZhciBzaGFwZUltcGwgPSByLmFycm93U2hhcGVzWyBzaGFwZSBdO1xuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzaXplICsgJyQnICsgc2hhcGUgKyAnJCcgKyBhbmdsZSArICckJyArIHggKyAnJCcgKyB5O1xuICAgIHJzLmFycm93UGF0aENhY2hlS2V5ID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXkgfHwge307XG4gICAgcnMuYXJyb3dQYXRoQ2FjaGUgPSBycy5hcnJvd1BhdGhDYWNoZSB8fCB7fTtcblxuICAgIHZhciBhbHJlYWR5Q2FjaGVkID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXlbIGFycm93VHlwZSBdID09PSBwYXRoQ2FjaGVLZXk7XG4gICAgaWYoIGFscmVhZHlDYWNoZWQgKXtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMuYXJyb3dQYXRoQ2FjaGVbIGFycm93VHlwZSBdO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5WyBhcnJvd1R5cGUgXSA9IHBhdGhDYWNoZUtleTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlWyBhcnJvd1R5cGUgXSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgIHNoYXBlSW1wbC5kcmF3KCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCApO1xuICB9XG5cbiAgaWYoICFzaGFwZUltcGwubGVhdmVQYXRoT3BlbiAmJiBjb250ZXh0LmNsb3NlUGF0aCApe1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cblxuICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICBpZiggZmlsbCA9PT0gJ2ZpbGxlZCcgfHwgZmlsbCA9PT0gJ2JvdGgnICl7XG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgaWYoIGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gKCBzaGFwZUltcGwubWF0Y2hFZGdlV2lkdGggPyBlZGdlV2lkdGggOiAxICk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcblxudmFyIENScCA9IHt9O1xuXG5DUnAuZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICByLmRyYXdOb2RlKCBjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCApO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoIGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsICk7XG4gIH1cbn07XG5cbkNScC5kcmF3Q2FjaGVkRWxlbWVudCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gIGlmKCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgaWYoICFleHRlbnQgfHwgbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBiYiwgZXh0ZW50ICkgKXtcbiAgICB2YXIgY2FjaGUgPSByLmRhdGEuZWxlVHhyQ2FjaGUuZ2V0RWxlbWVudCggZWxlLCBiYiwgcHhSYXRpbyApO1xuXG4gICAgaWYoIGNhY2hlICl7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSggY2FjaGUudGV4dHVyZS5jYW52YXMsIGNhY2hlLngsIDAsIGNhY2hlLndpZHRoLCBjYWNoZS5oZWlnaHQsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCApO1xuICAgIH0gZWxzZSB7IC8vIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBjYWNoZWFibGUsIHRoZW4gZHJhdyBkaXJlY3RseVxuICAgICAgci5kcmF3RWxlbWVudCggY29udGV4dCwgZWxlICk7XG4gICAgfVxuICB9XG59O1xuXG5DUnAuZHJhd0VsZW1lbnRzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZXMgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICByLmRyYXdFbGVtZW50KCBjb250ZXh0LCBlbGUgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG5cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KCBjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCApO1xuICB9XG59O1xuXG5DUnAuZHJhd0NhY2hlZE5vZGVzID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGkgXTtcblxuICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KCBjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCApO1xuICB9XG59O1xuXG5DUnAuZHJhd0xheWVyZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBsYXllcnMgPSByLmRhdGEubHlyVHhyQ2FjaGUuZ2V0TGF5ZXJzKCBlbGVzLCBweFJhdGlvICk7XG5cbiAgaWYoIGxheWVycyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgYmIgPSBsYXllci5iYjtcblxuICAgICAgaWYoIGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCApeyBjb250aW51ZTsgfVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSggbGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmggKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIGZhbGwgYmFjayBvbiBwbGFpbiBjYWNoaW5nIGlmIG5vIGxheWVyc1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKCBjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdEZWJ1Z1BvaW50cyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVzICl7XG4gIHZhciBkcmF3ID0gZnVuY3Rpb24oIHgsIHksIGNvbG9yICl7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KCB4IC0gMSwgeSAtIDEsIDMsIDMgKTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIHZhciBwID0gZWxlLnBvc2l0aW9uKCk7XG5cbiAgICAgIGRyYXcoIHAueCwgcC55LCAnbWFnZW50YScgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogKyAxIDwgcHRzLmxlbmd0aDsgaiArPSAyICl7XG4gICAgICAgIHZhciB4ID0gcHRzWyBqIF07XG4gICAgICAgIHZhciB5ID0gcHRzWyBqICsgMSBdO1xuXG4gICAgICAgIGRyYXcoIHgsIHksICdjeWFuJyApO1xuICAgICAgfVxuXG4gICAgICBkcmF3KCBycy5taWRYLCBycy5taWRZLCAneWVsbG93JyApO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiggY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApO1xuICB9IGNhdGNoKCBlICl7XG4gICAgci5yZWRyYXdIaW50KCAnZWxlcycsIHRydWUgKTtcbiAgICByLnJlZHJhd0hpbnQoICdkcmFnJywgdHJ1ZSApO1xuXG4gICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuXG4gICAgci5yZWRyYXcoKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBpbWcsIG5vZGUgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVggPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLng7XG4gIHZhciBub2RlWSA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgdmFyIGZpdCA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1maXQnICkudmFsdWU7XG4gIHZhciB4UG9zID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnICk7XG4gIHZhciB5UG9zID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknICk7XG4gIHZhciByZXBlYXQgPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtcmVwZWF0JyApLnZhbHVlO1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLWNsaXAnICkudmFsdWU7XG4gIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICB2YXIgaW1nT3BhY2l0eSA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JyApLnZhbHVlO1xuXG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcbiAgaWYoIG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0ggKXtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBpbWcgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaW1nVyA9IGltZy5jYWNoZWRXID0gaW1nLndpZHRoIHx8IGltZy5vZmZzZXRXaWR0aDtcbiAgICBpbWdIID0gaW1nLmNhY2hlZEggPSBpbWcuaGVpZ2h0IHx8IGltZy5vZmZzZXRIZWlnaHQ7XG5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCBpbWcgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG5cbiAgdmFyIGJnVyA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC13aWR0aCcgKTtcbiAgaWYoIGJnVy52YWx1ZSAhPT0gJ2F1dG8nICl7XG4gICAgaWYoIGJnVy51bml0cyA9PT0gJyUnICl7XG4gICAgICB3ID0gYmdXLnBmVmFsdWUgKiBub2RlVztcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IGJnVy5wZlZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiZ0ggPSBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtaGVpZ2h0JyApO1xuICBpZiggYmdILnZhbHVlICE9PSAnYXV0bycgKXtcbiAgICBpZiggYmdILnVuaXRzID09PSAnJScgKXtcbiAgICAgIGggPSBiZ0gucGZWYWx1ZSAqIG5vZGVIO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gYmdILnBmVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYoIHcgPT09IDAgfHwgaCA9PT0gMCApe1xuICAgIHJldHVybjsgLy8gbm8gcG9pbnQgaW4gZHJhd2luZyBlbXB0eSBpbWFnZSAoYW5kIGNocm9tZSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlKVxuICB9XG5cbiAgaWYoIGZpdCA9PT0gJ2NvbnRhaW4nICl7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5taW4oIG5vZGVXIC8gdywgbm9kZUggLyBoICk7XG5cbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG5cbiAgfSBlbHNlIGlmKCBmaXQgPT09ICdjb3ZlcicgKXtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1heCggbm9kZVcgLyB3LCBub2RlSCAvIGggKTtcblxuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfVxuXG4gIHZhciB4ID0gKG5vZGVYIC0gbm9kZVcgLyAyKTsgLy8gbGVmdFxuICBpZiggeFBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgeCArPSAobm9kZVcgLSB3KSAqIHhQb3MucGZWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB4ICs9IHhQb3MucGZWYWx1ZTtcbiAgfVxuXG4gIHZhciB5ID0gKG5vZGVZIC0gbm9kZUggLyAyKTsgLy8gdG9wXG4gIGlmKCB5UG9zLnVuaXRzID09PSAnJScgKXtcbiAgICB5ICs9IChub2RlSCAtIGgpICogeVBvcy5wZlZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHkgKz0geVBvcy5wZlZhbHVlO1xuICB9XG5cbiAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgIHggLT0gbm9kZVg7XG4gICAgeSAtPSBub2RlWTtcblxuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICBpZiggcmVwZWF0ID09PSAnbm8tcmVwZWF0JyApe1xuXG4gICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgICAgIGNvbnRleHQuY2xpcCggcnMucGF0aENhY2hlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbIHIuZ2V0Tm9kZVNoYXBlKCBub2RlICkgXS5kcmF3KFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbm9kZVgsIG5vZGVZLFxuICAgICAgICAgIG5vZGVXLCBub2RlSCApO1xuXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2FmZURyYXdJbWFnZSggY29udGV4dCwgaW1nLCAwLCAwLCBpbWdXLCBpbWdILCB4LCB5LCB3LCBoICk7XG5cbiAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKCBpbWcsIHJlcGVhdCApO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcblxuICAgIHIubm9kZVNoYXBlc1sgci5nZXROb2RlU2hhcGUoIG5vZGUgKSBdLmRyYXcoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG5vZGVYLCBub2RlWSxcbiAgICAgICAgbm9kZVcsIG5vZGVIICk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSggeCwgeSApO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKCAteCwgLXkgKTtcbiAgfVxuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcblxudmFyIENScCA9IHt9O1xuXG5DUnAuZWxlVGV4dEJpZ2dlclRoYW5NaW4gPSBmdW5jdGlvbiggZWxlLCBzY2FsZSApe1xuICBpZiggIXNjYWxlICl7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG4gICAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgbHZsID0gTWF0aC5jZWlsKCBtYXRoLmxvZzIoIHpvb20gKiBweFJhdGlvICkgKTsgLy8gdGhlIGVmZmVjdGl2ZSB0ZXh0dXJlIGxldmVsXG5cbiAgICBzY2FsZSA9IE1hdGgucG93KCAyLCBsdmwgKTtcbiAgfVxuXG4gIHZhciBjb21wdXRlZFNpemUgPSBlbGUucHN0eWxlKCAnZm9udC1zaXplJyApLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCAnbWluLXpvb21lZC1mb250LXNpemUnICkucGZWYWx1ZTtcblxuICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ1JwLmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGUsIGZvcmNlICl7XG4gIHZhciByID0gdGhpcztcblxuICBpZiggZm9yY2UgPT09IHVuZGVmaW5lZCApe1xuICAgIGlmKCAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbiggZWxlICkgKXsgcmV0dXJuOyB9XG4gIH0gZWxzZSB7XG4gICAgaWYoICFmb3JjZSApeyByZXR1cm47IH1cbiAgfVxuXG4gIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCAnbGFiZWwnICk7XG5cbiAgICBpZiggIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtaGFsaWduJyApLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VmFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtdmFsaWduJyApLnN0clZhbHVlO1xuXG4gICAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCAnbGFiZWwnICk7XG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSggJ3NvdXJjZS1sYWJlbCcgKTtcbiAgICB2YXIgdGd0TGFiZWwgPSBlbGUucHN0eWxlKCAndGFyZ2V0LWxhYmVsJyApO1xuXG4gICAgaWYoXG4gICAgICAoICFsYWJlbCB8fCAhbGFiZWwudmFsdWUgKVxuICAgICAgJiYgKCAhc3JjTGFiZWwgfHwgIXNyY0xhYmVsLnZhbHVlIClcbiAgICAgICYmICggIXRndExhYmVsIHx8ICF0Z3RMYWJlbC52YWx1ZSApXG4gICAgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cblxuXG4gIHIuZHJhd1RleHQoIGNvbnRleHQsIGVsZSApO1xuXG4gIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICByLmRyYXdUZXh0KCBjb250ZXh0LCBlbGUsICdzb3VyY2UnICk7XG5cbiAgICByLmRyYXdUZXh0KCBjb250ZXh0LCBlbGUsICd0YXJnZXQnICk7XG4gIH1cbn07XG5cbkNScC5kcmF3Tm9kZVRleHQgPSBDUnAuZHJhd0VkZ2VUZXh0ID0gQ1JwLmRyYXdFbGVtZW50VGV4dDtcblxuQ1JwLmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uKCBjb250ZXh0ICl7XG4gIHZhciBjYWNoZTtcblxuICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1sgaSBdO1xuXG4gICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH1cblxuICBjYWNoZSA9IHtcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHRoaXMuZm9udENhY2hlcy5wdXNoKCBjYWNoZSApO1xuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbi8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbkNScC5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGUgKXtcbiAgLy8gRm9udCBzdHlsZVxuICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSggJ2ZvbnQtc3R5bGUnICkuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFNpemUgPSBlbGUucHN0eWxlKCAnZm9udC1zaXplJyApLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgbGFiZWxGYW1pbHkgPSBlbGUucHN0eWxlKCAnZm9udC1mYW1pbHknICkuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoICdmb250LXdlaWdodCcgKS5zdHJWYWx1ZTtcbiAgdmFyIG9wYWNpdHkgPSBlbGUucHN0eWxlKCAndGV4dC1vcGFjaXR5JyApLnZhbHVlICogZWxlLnBzdHlsZSggJ29wYWNpdHknICkudmFsdWUgKiBwYXJlbnRPcGFjaXR5O1xuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCAndGV4dC1vdXRsaW5lLW9wYWNpdHknICkudmFsdWUgKiBvcGFjaXR5O1xuICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCAnY29sb3InICkudmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCAndGV4dC1vdXRsaW5lLWNvbG9yJyApLnZhbHVlO1xuICB2YXIgc2hhZG93Qmx1ciA9IGVsZS5wc3R5bGUoICd0ZXh0LXNoYWRvdy1ibHVyJyApLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtc2hhZG93LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBzaGFkb3dDb2xvciA9IGVsZS5wc3R5bGUoICd0ZXh0LXNoYWRvdy1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnICkucGZWYWx1ZTtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSBlbGUucHN0eWxlKCAndGV4dC1zaGFkb3ctb2Zmc2V0LXknICkucGZWYWx1ZTtcblxuICB2YXIgZm9udENhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmZvbnRLZXk7XG4gIHZhciBjYWNoZSA9IHRoaXMuZ2V0Rm9udENhY2hlKCBjb250ZXh0ICk7XG5cbiAgaWYoIGNhY2hlLmtleSAhPT0gZm9udENhY2hlS2V5ICl7XG4gICAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG5cbiAgICBjYWNoZS5rZXkgPSBmb250Q2FjaGVLZXk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50XG5cbiAgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCBjb2xvclsgMCBdLCBjb2xvclsgMSBdLCBjb2xvclsgMiBdLCBvcGFjaXR5ICk7XG5cbiAgdGhpcy5zdHJva2VTdHlsZSggY29udGV4dCwgb3V0bGluZUNvbG9yWyAwIF0sIG91dGxpbmVDb2xvclsgMSBdLCBvdXRsaW5lQ29sb3JbIDIgXSwgb3V0bGluZU9wYWNpdHkgKTtcblxuICB0aGlzLnNoYWRvd1N0eWxlKCBjb250ZXh0LCBzaGFkb3dDb2xvciwgc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSApO1xufTtcblxuZnVuY3Rpb24gcm91bmRSZWN0KCBjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyApe1xuICB2YXIgcmFkaXVzID0gcmFkaXVzIHx8IDU7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyggeCArIHJhZGl1cywgeSApO1xuICBjdHgubGluZVRvKCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzICk7XG4gIGN0eC5saW5lVG8oIHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyApO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyggeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQgKTtcbiAgY3R4LmxpbmVUbyggeCArIHJhZGl1cywgeSArIGhlaWdodCApO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyggeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyApO1xuICBjdHgubGluZVRvKCB4LCB5ICsgcmFkaXVzICk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKCB4LCB5LCB4ICsgcmFkaXVzLCB5ICk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn1cblxuLy8gRHJhdyB0ZXh0XG5DUnAuZHJhd1RleHQgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlLCBwcmVmaXggKXtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICBpZiggcGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCAndGV4dC1vcGFjaXR5JyApLnZhbHVlID09PSAwICl7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRleHRYID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KCByc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCApO1xuICB2YXIgdGV4dFkgPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4ICk7XG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZSwgcHJlZml4ICk7XG5cbiAgaWYoIHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4oIHRleHRYICkgJiYgIWlzTmFOKCB0ZXh0WSApICl7XG4gICAgdGhpcy5zZXR1cFRleHRTdHlsZSggY29udGV4dCwgZWxlICk7XG5cbiAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgdGV4dFcgPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCApO1xuICAgIHZhciB0ZXh0SCA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCApO1xuICAgIHZhciB0ZXh0QW5nbGUgPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoIHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCApO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZSggcGRhc2ggKyAndGV4dC1tYXJnaW4teCcgKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZSggcGRhc2ggKyAndGV4dC1tYXJnaW4teScgKS5wZlZhbHVlO1xuXG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuXG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LWhhbGlnbicgKS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSggJ3RleHQtdmFsaWduJyApLnZhbHVlO1xuXG4gICAgaWYoIGlzRWRnZSApe1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICB0ZXh0WCArPSBtYXJnaW5YO1xuICAgIHRleHRZICs9IG1hcmdpblk7XG5cbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKCAndGV4dC1yb3RhdGlvbicgKTtcbiAgICB2YXIgdGhldGE7XG5cbiAgICBpZiggcm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJyApe1xuICAgICAgdGhldGEgPSBpc0VkZ2UgPyB0ZXh0QW5nbGUgOiAwO1xuICAgIH0gZWxzZSBpZiggcm90YXRpb24uc3RyVmFsdWUgPT09ICdub25lJyApe1xuICAgICAgdGhldGEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGV0YSA9IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgfVxuXG4gICAgaWYoIHRoZXRhICE9PSAwICl7XG4gICAgICB2YXIgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgIHZhciBvcmdUZXh0WSA9IHRleHRZO1xuXG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggb3JnVGV4dFgsIG9yZ1RleHRZICk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSggdGhldGEgKTtcblxuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCggdmFsaWduICl7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JyApLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSggJ3RleHQtYm9yZGVyLW9wYWNpdHknICkudmFsdWU7XG4gICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LWJvcmRlci13aWR0aCcgKS5wZlZhbHVlO1xuICAgIHZhciBiYWNrZ3JvdW5kUGFkZGluZyA9IGVsZS5wc3R5bGUoICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycgKS5wZlZhbHVlO1xuXG4gICAgaWYoIGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCAoIHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDAgKSApe1xuICAgICAgdmFyIGJnWCA9IHRleHRYIC0gYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIHN3aXRjaCggaGFsaWduICl7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdXID0gdGV4dFcgKyAyKmJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnSCA9IHRleHRIICsgMipiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgaWYoIGJhY2tncm91bmRPcGFjaXR5ID4gMCApe1xuICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJyApLnZhbHVlO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbIDAgXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbIDEgXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbIDIgXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBlbGUucHN0eWxlKCAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJyApLnN0clZhbHVlO1xuICAgICAgICBpZiggc3R5bGVTaGFwZSA9PSAncm91bmRyZWN0YW5nbGUnICl7XG4gICAgICAgICAgcm91bmRSZWN0KCBjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gsIDIgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCBiZ1gsIGJnWSwgYmdXLCBiZ0ggKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgfVxuXG4gICAgICBpZiggdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCApe1xuICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItY29sb3InICkudmFsdWU7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCAndGV4dC1ib3JkZXItc3R5bGUnICkudmFsdWU7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0Qm9yZGVyQ29sb3JbIDAgXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsgMSBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWyAyIF0gKyAnLCcgKyBib3JkZXJPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG5cbiAgICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgc3dpdGNoKCB0ZXh0Qm9yZGVyU3R5bGUgKXtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgMSwgMSBdICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyA0LCAyIF0gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDQ7IC8vIDUwJSByZXNlcnZlZCBmb3Igd2hpdGUgYmV0d2VlbiB0aGUgdHdvIGJvcmRlcnNcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggW10gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFtdICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCggYmdYLCBiZ1ksIGJnVywgYmdIICk7XG5cbiAgICAgICAgaWYoIHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDI7XG5cbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoIGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggW10gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRMaW5lV2lkdGg7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCAndGV4dC1vdXRsaW5lLXdpZHRoJyApLnBmVmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmKCBlbGUucHN0eWxlKCAndGV4dC13cmFwJyApLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICAgIHZhciBsaW5lcyA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSggcnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCApO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0SCAvIGxpbmVzLmxlbmd0aDtcblxuICAgICAgc3dpdGNoKCB2YWxpZ24gKXtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAoIGxpbmVzLmxlbmd0aCAtIDEgKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdGV4dFkgLT0gKCBsaW5lcy5sZW5ndGggLSAxICkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCBsaW5lc1sgbCBdLCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoIGxpbmVzWyBsIF0sIHRleHRYLCB0ZXh0WSApO1xuXG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5maWxsVGV4dCggdGV4dCwgdGV4dFgsIHRleHRZICk7XG4gICAgfVxuXG4gICAgaWYoIHRoZXRhICE9PSAwICl7XG4gICAgICBjb250ZXh0LnJvdGF0ZSggLXRoZXRhICk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggLW9yZ1RleHRYLCAtb3JnVGV4dFkgKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYWRvd1N0eWxlKCBjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwICk7IC8vIHJlc2V0IGZvciBuZXh0IGd1eVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uLy4uLy4uL2lzJyApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3Tm9kZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBkcmF3TGFiZWwgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcG9zID0gcG9zIHx8IF9wLnBvc2l0aW9uO1xuXG4gIGlmKCAhaXMubnVtYmVyKCBwb3MueCApIHx8ICFpcy5udW1iZXIoIHBvcy55ICkgKXtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG5cbiAgaWYoICFub2RlLnZpc2libGUoKSApeyByZXR1cm47IH1cblxuICB2YXIgcGFyZW50T3BhY2l0eSA9IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcblxuICB2YXIgcGFkZGluZyA9IG5vZGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcblxuICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogcGFkZGluZztcbiAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogcGFkZGluZztcblxuICBjb250ZXh0LmxpbmVXaWR0aCA9IG5vZGUucHN0eWxlKCAnYm9yZGVyLXdpZHRoJyApLnBmVmFsdWU7XG5cbiAgLy9cbiAgLy8gc2V0dXAgc2hpZnRcblxuICB2YXIgYmI7XG4gIGlmKCBzaGlmdFRvT3JpZ2luV2l0aEJiICl7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoIC1iYi54MSwgLWJiLnkxICk7XG4gIH1cblxuICAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1pbWFnZScgKTtcbiAgdmFyIHVybCA9IGJnSW1nUHJvcC52YWx1ZVsyXSB8fCBiZ0ltZ1Byb3AudmFsdWVbMV07XG4gIHZhciBpbWFnZTtcblxuICBpZiggdXJsICE9PSB1bmRlZmluZWQgKXtcblxuICAgIHZhciBiZ0ltZ0Nyb3NzT3JpZ2luID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJyApO1xuXG4gICAgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcbiAgICBpbWFnZSA9IHRoaXMuZ2V0Q2FjaGVkSW1hZ2UoIHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUudHJpZ2dlcignYmFja2dyb3VuZCcpO1xuXG4gICAgICByLnJlZHJhd0hpbnQoICdlbGVzJywgdHJ1ZSApO1xuICAgICAgci5yZWRyYXdIaW50KCAnZHJhZycsIHRydWUgKTtcblxuICAgICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuXG4gICAgICByLnJlZHJhdygpO1xuICAgIH0gKTtcblxuICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgIF9wLmJhY2tncm91bmRpbmcgPSAhaW1hZ2UuY29tcGxldGU7XG5cbiAgICBpZiggcHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nICl7IC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgbm9kZS51cGRhdGVTdHlsZSggZmFsc2UgKTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuICB2YXIgYmdDb2xvciA9IG5vZGUucHN0eWxlKCAnYmFja2dyb3VuZC1jb2xvcicgKS52YWx1ZTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoICdib3JkZXItY29sb3InICkudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCAnYm9yZGVyLXN0eWxlJyApLnZhbHVlO1xuXG4gIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCBiZ0NvbG9yWzBdLCBiZ0NvbG9yWzFdLCBiZ0NvbG9yWzJdLCBub2RlLnBzdHlsZSggJ2JhY2tncm91bmQtb3BhY2l0eScgKS52YWx1ZSAqIHBhcmVudE9wYWNpdHkgKTtcblxuICB0aGlzLnN0cm9rZVN0eWxlKCBjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBub2RlLnBzdHlsZSggJ2JvcmRlci1vcGFjaXR5JyApLnZhbHVlICogcGFyZW50T3BhY2l0eSApO1xuXG4gIHZhciBzaGFkb3dCbHVyID0gbm9kZS5wc3R5bGUoICdzaGFkb3ctYmx1cicgKS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IG5vZGUucHN0eWxlKCAnc2hhZG93LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBzaGFkb3dDb2xvciA9IG5vZGUucHN0eWxlKCAnc2hhZG93LWNvbG9yJyApLnZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IG5vZGUucHN0eWxlKCAnc2hhZG93LW9mZnNldC14JyApLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gbm9kZS5wc3R5bGUoICdzaGFkb3ctb2Zmc2V0LXknICkucGZWYWx1ZTtcblxuICB0aGlzLnNoYWRvd1N0eWxlKCBjb250ZXh0LCBzaGFkb3dDb2xvciwgc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSApO1xuXG4gIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goIFsgMSwgMSBdICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKCBbIDQsIDIgXSApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyBdICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG5cbiAgLy9cbiAgLy8gZHJhdyBzaGFwZVxuXG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHN0eWxlU2hhcGUgKyAnJCcgKyBub2RlV2lkdGggKyAnJCcgKyBub2RlSGVpZ2h0ICsgKCBzdHlsZVNoYXBlID09PSAncG9seWdvbicgPyAnJCcgKyBzaGFwZVB0cy5qb2luKCckJykgOiAnJyApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgaWYoIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5ICl7XG4gICAgICBwYXRoID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCApe1xuXG4gICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIG5wb3MgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSggbm9kZSApIF0uZHJhdyhcbiAgICAgICAgICAoIHBhdGggfHwgY29udGV4dCApLFxuICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICBucG9zLnksXG4gICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgIG5vZGVIZWlnaHQgKTtcbiAgfVxuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgdGhpcy5zaGFkb3dTdHlsZSggY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcblxuICAvL1xuICAvLyBiZyBpbWFnZVxuXG4gIGlmKCB1cmwgIT09IHVuZGVmaW5lZCApe1xuICAgIGlmKCBpbWFnZS5jb21wbGV0ZSApe1xuICAgICAgdGhpcy5kcmF3SW5zY3JpYmVkSW1hZ2UoIGNvbnRleHQsIGltYWdlLCBub2RlICk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gcGllXG5cbiAgdmFyIGRhcmtuZXNzID0gbm9kZS5wc3R5bGUoICdiYWNrZ3JvdW5kLWJsYWNrZW4nICkudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCAnYm9yZGVyLXdpZHRoJyApLnBmVmFsdWU7XG5cbiAgaWYoIHRoaXMuaGFzUGllKCBub2RlICkgKXtcbiAgICB0aGlzLmRyYXdQaWUoIGNvbnRleHQsIG5vZGUsIHBhcmVudE9wYWNpdHkgKTtcblxuICAgIC8vIHJlZHJhdyBwYXRoIGZvciBibGFja2VuIGFuZCBib3JkZXJcbiAgICBpZiggZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDAgKXtcblxuICAgICAgaWYoICF1c2VQYXRocyApe1xuICAgICAgICByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKCBub2RlICkgXS5kcmF3KFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHBvcy54LFxuICAgICAgICAgICAgcG9zLnksXG4gICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICBub2RlSGVpZ2h0ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gZGFya2VuL2xpZ2h0ZW5cblxuICBpZiggZGFya25lc3MgPiAwICl7XG4gICAgdGhpcy5maWxsU3R5bGUoIGNvbnRleHQsIDAsIDAsIDAsIGRhcmtuZXNzICk7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBkYXJrbmVzcyA8IDAgKXtcbiAgICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgLWRhcmtuZXNzICk7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBib3JkZXJcblxuICBpZiggYm9yZGVyV2lkdGggPiAwICl7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgaWYoIGJvcmRlclN0eWxlID09PSAnZG91YmxlJyApe1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBub2RlLnBzdHlsZSggJ2JvcmRlci13aWR0aCcgKS5wZlZhbHVlIC8gMztcblxuICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICB9XG5cbiAgfVxuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQudHJhbnNsYXRlKCAtcG9zLngsIC1wb3MueSApO1xuICB9XG5cbiAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgY29udGV4dC5zZXRMaW5lRGFzaCggWyBdICk7XG4gIH1cblxuICAvL1xuICAvLyBsYWJlbFxuXG4gIHIuZHJhd0VsZW1lbnRUZXh0KCBjb250ZXh0LCBub2RlLCBkcmF3TGFiZWwgKTtcblxuICAvL1xuICAvLyBvdmVybGF5XG5cbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gbm9kZS5wc3R5bGUoICdvdmVybGF5LXBhZGRpbmcnICkucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gbm9kZS5wc3R5bGUoICdvdmVybGF5LW9wYWNpdHknICkudmFsdWU7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBub2RlLnBzdHlsZSggJ292ZXJsYXktY29sb3InICkudmFsdWU7XG5cbiAgaWYoIG92ZXJsYXlPcGFjaXR5ID4gMCApe1xuICAgIHRoaXMuZmlsbFN0eWxlKCBjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSApO1xuXG4gICAgci5ub2RlU2hhcGVzWyAncm91bmRyZWN0YW5nbGUnIF0uZHJhdyhcbiAgICAgIGNvbnRleHQsXG4gICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICBub2RlV2lkdGggKyBvdmVybGF5UGFkZGluZyAqIDIsXG4gICAgICBub2RlSGVpZ2h0ICsgb3ZlcmxheVBhZGRpbmcgKiAyXG4gICAgKTtcblxuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgLy9cbiAgLy8gY2xlYW4gdXAgc2hpZnRcblxuICBpZiggc2hpZnRUb09yaWdpbldpdGhCYiApe1xuICAgIGNvbnRleHQudHJhbnNsYXRlKCBiYi54MSwgYmIueTEgKTtcbiAgfVxuXG59O1xuXG4vLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cbkNScC5oYXNQaWUgPSBmdW5jdGlvbiggbm9kZSApe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuXG5DUnAuZHJhd1BpZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zICl7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoICdwaWUtc2l6ZScgKTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcG9zID0gcG9zIHx8IF9wLnBvc2l0aW9uO1xuICB2YXIgeCA9IHBvcy54O1xuICB2YXIgeSA9IHBvcy55O1xuICB2YXIgcmFkaXVzID0gTWF0aC5taW4oIG5vZGVXLCBub2RlSCApIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIGlmKCBwaWVTaXplLnVuaXRzID09PSAnJScgKXtcbiAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiggcGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICB2YXIgc2l6ZSA9IG5vZGUucHN0eWxlKCAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnICkudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InICkudmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZSggJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JyApLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cblxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuICAgIGlmKCBwZXJjZW50ICsgbGFzdFBlcmNlbnQgPiAxICl7XG4gICAgICBwZXJjZW50ID0gMSAtIGxhc3RQZXJjZW50O1xuICAgIH1cblxuICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhO1xuXG4gICAgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICBpZiggc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEgKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oIHgsIHkgKTtcbiAgICBjb250ZXh0LmFyYyggeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICB0aGlzLmZpbGxTdHlsZSggY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSApO1xuXG4gICAgY29udGV4dC5maWxsKCk7XG5cbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcblxudmFyIG1vdGlvbkJsdXJEZWxheSA9IDEwMDtcblxuLy8gdmFyIGlzRmlyZWZveCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScC5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYoIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsICl7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59O1xuXG5DUnAucGFpbnRDYWNoZSA9IGZ1bmN0aW9uKCBjb250ZXh0ICl7XG4gIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgdmFyIG5lZWRUb0NyZWF0ZUNhY2hlID0gdHJ1ZTtcbiAgdmFyIGNhY2hlO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgY2FjaGUgPSBjYWNoZXNbIGkgXTtcblxuICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIG5lZWRUb0NyZWF0ZUNhY2hlICl7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaCggY2FjaGUgKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbkNScC5maWxsU3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgciwgZywgYiwgYSApe1xuICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAuc3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgciwgZywgYiwgYSApe1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIC8vIH1cbn07XG5cbkNScC5zaGFkb3dTdHlsZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBjb2xvciwgb3BhY2l0eSwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSApe1xuICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuXG4gIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZSggY29udGV4dCApO1xuICAvL1xuICAvLyAvLyBkb24ndCBtYWtlIGV4cGVuc2l2ZSBjaGFuZ2VzIHRvIHRoZSBzaGFkb3cgc3R5bGUgaWYgaXQncyBub3QgdXNlZFxuICAvLyBpZiggY2FjaGUuc2hhZG93T3BhY2l0eSA9PT0gMCAmJiBvcGFjaXR5ID09PSAwICl7XG4gIC8vICAgcmV0dXJuO1xuICAvLyB9XG4gIC8vXG4gIC8vIGNhY2hlLnNoYWRvd09wYWNpdHkgPSBvcGFjaXR5O1xuXG4gIGlmKCBvcGFjaXR5ID4gMCApe1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGJsdXIgKiB6b29tO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAncmdiYSgnICsgY29sb3JbMF0gKyAnLCcgKyBjb2xvclsxXSArICcsJyArIGNvbG9yWzJdICsgJywnICsgb3BhY2l0eSArICcpJztcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBvZmZzZXRYICogem9vbTtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBvZmZzZXRZICogem9vbTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfVxufTtcblxuLy8gUmVzaXplIGNhbnZhc1xuQ1JwLm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uKCBjb250YWluZXIgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIGJiID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IGJiWzJdO1xuICB2YXIgaGVpZ2h0ID0gYmJbM107XG4gIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuXG4gIGlmKFxuICAgIGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSB8fFxuICAgIGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXVxuICApe1xuICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gIH1cblxuICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzO1xuXG4gIGlmKCBjYW52YXNXaWR0aCA9PT0gci5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHIuY2FudmFzSGVpZ2h0ICl7XG4gICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gIH1cblxuICByLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgci5DQU5WQVNfTEFZRVJTOyBpKysgKXtcblxuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbIGkgXTtcblxuICAgIGlmKCBjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCApe1xuXG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgci5CVUZGRVJfQ09VTlQ7IGkrKyApe1xuXG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdO1xuXG4gICAgaWYoIGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0ICl7XG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG4gIGlmKCBwaXhlbFJhdGlvIDw9IDEgKXtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gIH1cblxuICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG59O1xuXG5DUnAucmVuZGVyVG8gPSBmdW5jdGlvbiggY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgdGhpcy5yZW5kZXIoIHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSApO1xufTtcblxuQ1JwLnJlbmRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5OyB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgIGlmKCByLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvICl7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoIHIuY29udGFpbmVyICk7XG5cbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgci5wcmV2UHhSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cblxuICBpZiggIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCApe1xuICAgIGNsZWFyVGltZW91dCggci5tb3Rpb25CbHVyVGltZW91dCApO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICBpZiggci5tYkZyYW1lcyA9PSBudWxsICl7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICBpZiggIXIuZHJhd2luZ0ltYWdlICl7IC8vIGltYWdlIGxvYWRpbmcgZnJhbWVzIGRvbid0IGNvdW50IHRvd2FyZHMgbW90aW9uIGJsdXIgYmx1cnJ5IGZyYW1lc1xuICAgICAgci5tYkZyYW1lcysrO1xuICAgIH1cblxuICAgIGlmKCByLm1iRnJhbWVzIDwgMyApeyAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcbiAgICBpZiggci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzICl7XG4gICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgfVxuICB9XG5cbiAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gIGlmKCByLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdyApe1xuICAgIG5lZWREcmF3WyByLk5PREUgXSA9IHRydWU7XG4gICAgbmVlZERyYXdbIHIuU0VMRUNUX0JPWCBdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjb3JlU3R5bGUgPSBjeS5zdHlsZSgpLl9wcml2YXRlLmNvcmVTdHlsZTtcblxuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIGVmZmVjdGl2ZVpvb20gPSBmb3JjZWRab29tICE9PSB1bmRlZmluZWQgPyBmb3JjZWRab29tIDogem9vbTtcbiAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICB2YXIgZWZmZWN0aXZlUGFuID0ge1xuICAgIHg6IHBhbi54LFxuICAgIHk6IHBhbi55XG4gIH07XG5cbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTtcblxuICAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuICBpZiggIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpICl7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICBpZiggZm9yY2VkUGFuICl7XG4gICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICB9XG5cbiAgLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG5cbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgZnVuY3Rpb24gbWJjbGVhciggY29udGV4dCwgeCwgeSwgdywgaCApe1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgci5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoIHgsIHksIHcsIGggKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgY2xlYXIgKXtcbiAgICB2YXIgZVBhbiwgZVpvb20sIHcsIGg7XG5cbiAgICBpZiggIXIuY2xlYXJpbmdNb3Rpb25CbHVyICYmIChjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXSkgKXtcbiAgICAgIGVQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgfTtcblxuICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuXG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgfVxuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuICAgIGlmKCBjbGVhciA9PT0gJ21vdGlvbkJsdXInICl7XG4gICAgICBtYmNsZWFyKCBjb250ZXh0LCAwLCAwLCB3LCBoICk7XG4gICAgfSBlbHNlIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikgKXtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB3LCBoICk7XG4gICAgfVxuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZVBhbi54LCBlUGFuLnkgKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoIGVab29tLCBlWm9vbSApO1xuICAgIH1cbiAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55ICk7XG4gICAgfVxuICAgIGlmKCBmb3JjZWRab29tICl7XG4gICAgICBjb250ZXh0LnNjYWxlKCBmb3JjZWRab29tLCBmb3JjZWRab29tICk7XG4gICAgfVxuICB9XG5cbiAgaWYoICF0ZXh0dXJlRHJhdyApe1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmKCB0ZXh0dXJlRHJhdyApe1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYoICFyLnRleHR1cmVDYWNoZSApe1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcblxuICAgICAgYmIgPSByLnRleHR1cmVDYWNoZS5iYiA9IGN5Lm11dGFibGVFbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG4gICAgICBjeHQuY2xlYXJSZWN0KCAwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0ICk7XG5cbiAgICAgIHIucmVuZGVyKCB7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9ICk7XG5cbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICB2cC5tcGFuID0ge1xuICAgICAgICB4OiAoMCAtIHZwLnBhbi54KSAvIHZwLnpvb20sXG4gICAgICAgIHk6ICgwIC0gdnAucGFuLnkpIC8gdnAuem9vbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBuZWVkRHJhd1sgci5EUkFHIF0gPSBmYWxzZTtcbiAgICBuZWVkRHJhd1sgci5OT0RFIF0gPSBmYWxzZTtcblxuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1sgci5OT0RFIF07XG5cbiAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgYmIgPSByLnRleHR1cmVDYWNoZS5iYjtcblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cbiAgICBpZiggbW90aW9uQmx1ciApe1xuICAgICAgbWJjbGVhciggY29udGV4dCwgMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCggMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuICAgIH1cblxuICAgIHZhciBvdXRzaWRlQmdDb2xvciA9IGNvcmVTdHlsZVsgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicgXS52YWx1ZTtcbiAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IGNvcmVTdHlsZVsgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyBdLnZhbHVlO1xuICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5ICk7XG4gICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuXG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBmYWxzZSApO1xuXG4gICAgY29udGV4dC5jbGVhclJlY3QoIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyApO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKCB0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8gKTtcblxuICB9IGVsc2UgaWYoIHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgKXsgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG4gIHZhciB2cE1hbmlwID0gKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG5cbiAgdmFyIG5lZWRNYkNsZWFyID0gW107XG5cbiAgbmVlZE1iQ2xlYXJbIHIuTk9ERSBdID0gIW5lZWREcmF3WyByLk5PREUgXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLk5PREUgXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYoIG5lZWRNYkNsZWFyWyByLk5PREUgXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLk5PREUgXSA9IHRydWU7IH1cblxuICBuZWVkTWJDbGVhclsgci5EUkFHIF0gPSAhbmVlZERyYXdbIHIuRFJBRyBdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbIHIuRFJBRyBdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICBpZiggbmVlZE1iQ2xlYXJbIHIuRFJBRyBdICl7IHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbIHIuRFJBRyBdID0gdHJ1ZTsgfVxuXG4gIGlmKCBuZWVkRHJhd1sgci5OT0RFIF0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhclsgci5OT0RFIF0gKXtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbIHIuTk9ERSBdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdIDogZGF0YS5jb250ZXh0c1sgci5OT0RFIF0gKTtcbiAgICB2YXIgY2xlYXIgPSBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQ7XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBjbGVhciApO1xuXG4gICAgaWYoIGhpZGVFZGdlcyApe1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoIGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0xheWVyZWRFbGVtZW50cyggY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQgKTtcbiAgICB9XG5cbiAgICBpZiggci5kZWJ1ZyApe1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoIGNvbnRleHQsIGVsZXMubm9uZHJhZyApO1xuICAgIH1cblxuICAgIGlmKCAhZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1ciApe1xuICAgICAgbmVlZERyYXdbIHIuTk9ERSBdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYoICFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbIHIuRFJBRyBdIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbIHIuRFJBRyBdKSApe1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhclsgci5EUkFHIF0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAoIHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF0gOiBkYXRhLmNvbnRleHRzWyByLkRSQUcgXSApO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkICk7XG5cbiAgICBpZiggaGlkZUVkZ2VzICl7XG4gICAgICByLmRyYXdDYWNoZWROb2RlcyggY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoIGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG4gICAgfVxuXG4gICAgaWYoIHIuZGVidWcgKXtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKCBjb250ZXh0LCBlbGVzLmRyYWcgKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgIG5lZWREcmF3WyByLkRSQUcgXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCByLnNob3dGcHMgfHwgKCFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbIHIuU0VMRUNUX0JPWCBdICYmICFkcmF3QWxsTGF5ZXJzKSkgKXtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1sgci5TRUxFQ1RfQk9YIF07XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0ICk7XG5cbiAgICBpZiggci5zZWxlY3Rpb25bNF0gPT0gMSAmJiAoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKSApe1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyBdLnZhbHVlIC8gem9vbTtcblxuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJ1xuICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtY29sb3InIF0udmFsdWVbMF0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWNvbG9yJyBdLnZhbHVlWzFdICsgJywnXG4gICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1jb2xvcicgXS52YWx1ZVsyXSArICcsJ1xuICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScgXS52YWx1ZSArICcpJztcblxuICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgci5zZWxlY3Rpb25bMF0sXG4gICAgICAgIHIuc2VsZWN0aW9uWzFdLFxuICAgICAgICByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdICk7XG5cbiAgICAgIGlmKCBib3JkZXJXaWR0aCA+IDAgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCdcbiAgICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyBdLnZhbHVlWzBdICsgJywnXG4gICAgICAgICAgKyBjb3JlU3R5bGVbICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicgXS52YWx1ZVsxXSArICcsJ1xuICAgICAgICAgICsgY29yZVN0eWxlWyAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InIF0udmFsdWVbMl0gKyAnLCdcbiAgICAgICAgICArIGNvcmVTdHlsZVsgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScgXS52YWx1ZSArICcpJztcblxuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICAgICAgci5zZWxlY3Rpb25bMF0sXG4gICAgICAgICAgci5zZWxlY3Rpb25bMV0sXG4gICAgICAgICAgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSxcbiAgICAgICAgICByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdhY3RpdmUtYmctY29sb3InIF0udmFsdWVbMF0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdhY3RpdmUtYmctY29sb3InIF0udmFsdWVbMV0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdhY3RpdmUtYmctY29sb3InIF0udmFsdWVbMl0gKyAnLCdcbiAgICAgICAgKyBjb3JlU3R5bGVbICdhY3RpdmUtYmctb3BhY2l0eScgXS52YWx1ZSArICcpJztcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKCBwb3MueCwgcG9zLnksIGNvcmVTdHlsZVsgJ2FjdGl2ZS1iZy1zaXplJyBdLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSApO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgdmFyIHRpbWVUb1JlbmRlciA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgaWYoIHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIgKXtcbiAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQoIHRpbWVUb1JlbmRlciApO1xuICAgICAgdmFyIGZwcyA9IE1hdGgucm91bmQoIDEwMDAgLyB0aW1lVG9SZW5kZXIgKTtcblxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoICcxIGZyYW1lID0gJyArIHRpbWVUb1JlbmRlciArICcgbXMgPSAnICsgZnBzICsgJyBmcHMnLCAwLCAyMCApO1xuXG4gICAgICB2YXIgbWF4RnBzID0gNjA7XG4gICAgICBjb250ZXh0LnN0cm9rZVJlY3QoIDAsIDMwLCAyNTAsIDIwICk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAzMCwgMjUwICogTWF0aC5taW4oIGZwcyAvIG1heEZwcywgMSApLCAyMCApO1xuICAgIH1cblxuICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgbmVlZERyYXdbIHIuU0VMRUNUX0JPWCBdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG4gIGlmKCBtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSApe1xuICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1sgci5OT0RFIF07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdO1xuXG4gICAgdmFyIGN4dERyYWcgPSBkYXRhLmNvbnRleHRzWyByLkRSQUcgXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF07XG5cbiAgICB2YXIgZHJhd01vdGlvbkJsdXIgPSBmdW5jdGlvbiggY3h0LCB0eHQsIG5lZWRDbGVhciApe1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xuXG4gICAgICBpZiggbmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCApe1xuICAgICAgICBjeHQuY2xlYXJSZWN0KCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWJjbGVhciggY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuXG4gICAgICBjeHQuZHJhd0ltYWdlKFxuICAgICAgICB0eHQsIC8vIGltZ1xuICAgICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsIC8vIHN3LCBzaFxuICAgICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmKCBuZWVkRHJhd1sgci5OT0RFIF0gfHwgbmVlZE1iQ2xlYXJbIHIuTk9ERSBdICl7XG4gICAgICBkcmF3TW90aW9uQmx1ciggY3h0Tm9kZSwgdHh0Tm9kZSwgbmVlZE1iQ2xlYXJbIHIuTk9ERSBdICk7XG4gICAgICBuZWVkRHJhd1sgci5OT0RFIF0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiggbmVlZERyYXdbIHIuRFJBRyBdIHx8IG5lZWRNYkNsZWFyWyByLkRSQUcgXSApe1xuICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyWyByLkRSQUcgXSApO1xuICAgICAgbmVlZERyYXdbIHIuRFJBRyBdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgci5wcmV2Vmlld3BvcnQgPSB2cDtcblxuICBpZiggci5jbGVhcmluZ01vdGlvbkJsdXIgKXtcbiAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgIHIubW90aW9uQmx1ckNsZWFyZWQgPSB0cnVlO1xuICAgIHIubW90aW9uQmx1ciA9IHRydWU7XG4gIH1cblxuICBpZiggbW90aW9uQmx1ciApe1xuICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG5cbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbIHIuTk9ERSBdID0gZmFsc2U7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyWyByLkRSQUcgXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuXG4gICAgICBuZWVkRHJhd1sgci5OT0RFIF0gPSB0cnVlO1xuICAgICAgbmVlZERyYXdbIHIuRFJBRyBdID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCBtb3Rpb25CbHVyRGVsYXkgKTtcbiAgfVxuXG4gIHIuZHJhd2luZ0ltYWdlID0gZmFsc2U7XG5cblxuICBpZiggIWZvcmNlZENvbnRleHQgJiYgIXIuaW5pdHJlbmRlciApe1xuICAgIHIuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgY3kudHJpZ2dlciggJ2luaXRyZW5kZXInICk7XG4gIH1cblxuICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICBjeS50cmlnZ2VyKCdyZW5kZXInKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcblxudmFyIENScCA9IHt9O1xuXG4vLyBATyBQb2x5Z29uIGRyYXdpbmdcbkNScC5kcmF3UG9seWdvblBhdGggPSBmdW5jdGlvbihcbiAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzICl7XG5cbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgZm9yKCB2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrICl7XG4gICAgY29udGV4dC5saW5lVG8oIHggKyBoYWxmVyAqIHBvaW50c1sgaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbIGkgKiAyICsgMV0gKTtcbiAgfVxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCApe1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoIHdpZHRoLCBoZWlnaHQgKTtcblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oIHgsIHkgLSBoYWxmSGVpZ2h0ICk7XG4gIC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuICBjb250ZXh0LmFyY1RvKCB4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gIGNvbnRleHQuYXJjVG8oIHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgY29udGV4dC5hcmNUbyggeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyApO1xuICAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG4gIGNvbnRleHQuYXJjVG8oIHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzICk7XG4gIC8vIEpvaW4gbGluZVxuICBjb250ZXh0LmxpbmVUbyggeCwgeSAtIGhhbGZIZWlnaHQgKTtcblxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG52YXIgc2luMCA9IE1hdGguc2luKCAwICk7XG52YXIgY29zMCA9IE1hdGguY29zKCAwICk7XG5cbnZhciBzaW4gPSB7fTtcbnZhciBjb3MgPSB7fTtcblxudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcblxuZm9yKCB2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICl7XG4gIHNpblsgaSBdID0gTWF0aC5zaW4oIGkgKTtcbiAgY29zWyBpIF0gPSBNYXRoLmNvcyggaSApO1xufVxuXG5DUnAuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgaWYoIGNvbnRleHQuZWxsaXBzZSApe1xuICAgICAgY29udGV4dC5lbGxpcHNlKCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHJoID0gaGVpZ2h0IC8gMjtcbiAgICAgIGZvciggdmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApe1xuICAgICAgICB4UG9zID0gY2VudGVyWCAtIChydyAqIHNpblsgaSBdKSAqIHNpbjAgKyAocncgKiBjb3NbIGkgXSkgKiBjb3MwO1xuICAgICAgICB5UG9zID0gY2VudGVyWSArIChyaCAqIGNvc1sgaSBdKSAqIHNpbjAgKyAocmggKiBzaW5bIGkgXSkgKiBjb3MwO1xuXG4gICAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oIHhQb3MsIHlQb3MgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyggeFBvcywgeVBvcyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSggJy4uLy4uLy4uL21hdGgnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIEhlYXAgPSByZXF1aXJlKCAnLi4vLi4vLi4vaGVhcCcgKTtcbnZhciBkZWZzID0gcmVxdWlyZSggJy4vdGV4dHVyZS1jYWNoZS1kZWZzJyApO1xuXG52YXIgbWluVHhySCA9IDI1OyAvLyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBjYWNoZSBmb3Igc21hbGwgaGVpZ2h0IGVsZXMgKHNwZWNpYWwgY2FzZSlcbnZhciB0eHJTdGVwSCA9IDUwOyAvLyB0aGUgbWluIHNpemUgb2YgdGhlIHJlZ3VsYXIgY2FjaGUsIGFuZCB0aGUgc2l6ZSBpdCBpbmNyZWFzZXMgd2l0aCBlYWNoIHN0ZXAgdXBcbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxudmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxudmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcbnZhciBkZWZUeHJXaWR0aCA9IDEwMjQ7IC8vIGRlZmF1bHQvbWluaW11bSB0ZXh0dXJlIHdpZHRoXG52YXIgbWF4VHhyVyA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgdGV4dHVyZVxudmFyIG1heFR4ckggPSAxMDI0OyAgLy8gdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgdGV4dHVyZVxudmFyIG1pblV0aWxpdHkgPSAwLjU7IC8vIGlmIHVzYWdlIG9mIHRleHR1cmUgaXMgbGVzcyB0aGFuIHRoaXMsIGl0IGlzIHJldGlyZWRcbnZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcbnZhciBtYXhGdWxsbmVzc0NoZWNrcyA9IDEwOyAvLyBkZXF1ZXVlZCBhZnRlciB0aGlzIG1hbnkgY2hlY2tzXG52YXIgYWxsb3dFZGdlVHhyQ2FjaGluZyA9IGZhbHNlOyAvLyB3aGV0aGVyIGVkZ2VzIGNhbiBiZSBjYWNoZWQgYXMgdGV4dHVyZXMgKFRPRE8gbWF5YmUgYmV0dGVyIG9uIGlmIHdlYmdsIHN1cHBvcnRlZD8pXG52YXIgYWxsb3dQYXJlbnRUeHJDYWNoaW5nID0gZmFsc2U7IC8vIHdoZXRoZXIgcGFyZW50IG5vZGVzIGNhbiBiZSBjYWNoZWQgYXMgdGV4dHVyZXMgKFRPRE8gbWF5YmUgYmV0dGVyIG9uIGlmIHdlYmdsIHN1cHBvcnRlZD8pXG52YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG52YXIgZGVxTm9EcmF3Q29zdCA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSAxMDA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG52YXIgbWF4RGVxU2l6ZSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbnZhciBnZXRUeHJSZWFzb25zID0ge1xuICBkZXF1ZXVlOiAnZGVxdWV1ZScsXG4gIGRvd25zY2FsZTogJ2Rvd25zY2FsZScsXG4gIGhpZ2hRdWFsaXR5OiAnaGlnaFF1YWxpdHknXG59O1xuXG52YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uKCByZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICBzZWxmLm9uRGVxdWV1ZXMgPSBbXTtcblxuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcblxudmFyIEVUQ3AgPSBFbGVtZW50VGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcblxuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29ucztcblxuLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5FVENwLmdldFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uKCB0eHJIICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lbGVJbWdDYWNoZXMgPSBzZWxmLmVsZUltZ0NhY2hlcyB8fCB7fTtcblxuICByZXR1cm4gKCBzZWxmLmVsZUltZ0NhY2hlc1sgdHhySCBdID0gc2VsZi5lbGVJbWdDYWNoZXNbIHR4ckggXSB8fCBbXSApO1xufTtcblxuLy8gdGhlIGxpc3Qgb2YgdXN1c2VkIHRleHR1cmVzIHdoaWNoIGNhbiBiZSByZWN5Y2xlZCAoaW4gdXNlIGluIHRleHR1cmUgcXVldWUpXG5FVENwLmdldFJldGlyZWRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiggdHhySCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbIHR4ckggXSA9IHJ0eHRyUXNbIHR4ckggXSB8fCBbXTtcblxuICByZXR1cm4gcnR4dHJRO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcbkVUQ3AuZ2V0RWxlbWVudFF1ZXVlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBxID0gc2VsZi5lbGVDYWNoZVF1ZXVlID0gc2VsZi5lbGVDYWNoZVF1ZXVlIHx8IG5ldyBIZWFwKGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfSk7XG5cbiAgcmV0dXJuIHE7XG59O1xuXG4vLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVscyAoZWxlbWVudCBpZCBsb29rdXApXG5FVENwLmdldEVsZW1lbnRJZFRvUXVldWUgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGlkMnEgPSBzZWxmLmVsZUlkVG9DYWNoZVF1ZXVlID0gc2VsZi5lbGVJZFRvQ2FjaGVRdWV1ZSB8fCB7fTtcblxuICByZXR1cm4gaWQycTtcbn07XG5cbkVUQ3AuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCBlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbiApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuXG4gIGlmKCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgKXsgcmV0dXJuIG51bGw7IH1cblxuICBpZiggbHZsID09IG51bGwgKXtcbiAgICBsdmwgPSBNYXRoLmNlaWwoIG1hdGgubG9nMiggem9vbSAqIHB4UmF0aW8gKSApO1xuICB9XG5cbiAgaWYoIGx2bCA8IG1pbkx2bCApe1xuICAgIGx2bCA9IG1pbkx2bDtcbiAgfSBlbHNlIGlmKCB6b29tID49IG1heFpvb20gfHwgbHZsID4gbWF4THZsICl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2NhbGUgPSBNYXRoLnBvdyggMiwgbHZsICk7XG4gIHZhciBlbGVTY2FsZWRIID0gYmIuaCAqIHNjYWxlO1xuICB2YXIgZWxlU2NhbGVkVyA9IGJiLncgKiBzY2FsZTtcbiAgdmFyIGNhY2hlcyA9IHJzLmltZ0NhY2hlcyA9IHJzLmltZ0NhY2hlcyB8fCB7fTtcbiAgdmFyIGVsZUNhY2hlID0gY2FjaGVzW2x2bF07XG5cbiAgaWYoIGVsZUNhY2hlICl7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG5cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiggZWxlU2NhbGVkSCA8PSBtaW5UeHJIICl7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiggZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCApe1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKCBlbGVTY2FsZWRIIC8gdHhyU3RlcEggKSAqIHR4clN0ZXBIO1xuICB9XG5cbiAgaWYoXG4gICAgZWxlU2NhbGVkSCA+IG1heFR4ckhcbiAgICB8fCBlbGVTY2FsZWRXID4gbWF4VHhyV1xuICAgIHx8ICggIWFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIClcbiAgICB8fCAoICFhbGxvd1BhcmVudFR4ckNhY2hpbmcgJiYgZWxlLmlzUGFyZW50KCkgKVxuICApe1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuXG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUoIHR4ckggKTtcblxuICAvLyBmaXJzdCB0cnkgdGhlIHNlY29uZCBsYXN0IG9uZSBpbiBjYXNlIGl0IGhhcyBzcGFjZSBhdCB0aGUgZW5kXG4gIHZhciB0eHIgPSB0eHJRWyB0eHJRLmxlbmd0aCAtIDIgXTtcblxuICB2YXIgYWRkTmV3VHhyID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gc2VsZi5yZWN5Y2xlVGV4dHVyZSggdHhySCwgZWxlU2NhbGVkVyApIHx8IHNlbGYuYWRkVGV4dHVyZSggdHhySCwgZWxlU2NhbGVkVyApO1xuICB9O1xuXG4gIC8vIHRyeSB0aGUgbGFzdCBvbmUgaWYgdGhlcmUgaXMgbm8gc2Vjb25kIGxhc3Qgb25lXG4gIGlmKCAhdHhyICl7XG4gICAgdHhyID0gdHhyUVsgdHhyUS5sZW5ndGggLSAxIF07XG4gIH1cblxuICAvLyBpZiB0aGUgbGFzdCBvbmUgZG9lc24ndCBleGlzdCwgd2UgbmVlZCBhIGZpcnN0IG9uZVxuICBpZiggIXR4ciApe1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG5cbiAgLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG4gIGlmKCB0eHIud2lkdGggLSB0eHIudXNlZFdpZHRoIDwgZWxlU2NhbGVkVyApe1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG5cbiAgdmFyIHNjYWxlZExhYmVsU2hvd24gPSByLmVsZVRleHRCaWdnZXJUaGFuTWluKCBlbGUsIHNjYWxlICk7XG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiggb3RoZXJDYWNoZSApe1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcblxuICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG5cbiAgdmFyIGhpZ2hlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgaGlnaGVyIGxldmVsXG4gIGZvciggdmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bDsgbCsrICl7XG4gICAgdmFyIGMgPSBjYWNoZXNbbF07XG5cbiAgICBpZiggYyApeyBoaWdoZXJDYWNoZSA9IGM7IGJyZWFrOyB9XG4gIH1cblxuICB2YXIgb25lVXBDYWNoZSA9IGhpZ2hlckNhY2hlICYmIGhpZ2hlckNhY2hlLmxldmVsID09PSBsdmwgKyAxID8gaGlnaGVyQ2FjaGUgOiBudWxsO1xuXG4gIHZhciBkb3duc2NhbGUgPSBmdW5jdGlvbigpe1xuICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgIG9uZVVwQ2FjaGUudGV4dHVyZS5jYW52YXMsXG4gICAgICBvbmVVcENhY2hlLngsIDAsXG4gICAgICBvbmVVcENhY2hlLndpZHRoLCBvbmVVcENhY2hlLmhlaWdodCxcbiAgICAgIHR4ci51c2VkV2lkdGgsIDAsXG4gICAgICBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIXG4gICAgKTtcbiAgfTtcblxuICBpZiggc2NhbGFibGVGcm9tKG9uZVVwQ2FjaGUpICl7XG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVsYXRpdmVseSBjaGVhcGx5IHJlc2NhbGUgdGhlIGV4aXN0aW5nIGltYWdlIHcvbyByZXJlbmRlcmluZ1xuICAgIGRvd25zY2FsZSgpO1xuXG4gIH0gZWxzZSBpZiggc2NhbGFibGVGcm9tKGhpZ2hlckNhY2hlKSApe1xuICAgIC8vIHRoZW4gdXNlIHRoZSBoaWdoZXIgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIG5leHQgbGV2ZWwgZG93blxuICAgIC8vIHRvIGNoZWFwbHkgc2NhbGUgdG93YXJkcyB0aGUgc21hbGxlciBsZXZlbFxuXG4gICAgaWYoIGhpZ2hRdWFsaXR5UmVxICl7XG4gICAgICBmb3IoIHZhciBsID0gaGlnaGVyQ2FjaGUubGV2ZWw7IGwgPiBsdmw7IGwtLSApe1xuICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KCBlbGUsIGJiLCBweFJhdGlvLCBsLCBnZXRUeHJSZWFzb25zLmRvd25zY2FsZSApO1xuICAgICAgfVxuXG4gICAgICBkb3duc2NhbGUoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudCggZWxlLCBiYiwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxICk7XG5cbiAgICAgIHJldHVybiBoaWdoZXJDYWNoZTtcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgICB2YXIgbG93ZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGxvd2VyIGxldmVsXG4gICAgaWYoICFkZXFpbmcgJiYgIWhpZ2hRdWFsaXR5UmVxICYmICFkb3duc2NhbGVSZXEgKXtcbiAgICAgIGZvciggdmFyIGwgPSBsdmwgLSAxOyBsID49IG1pbkx2bDsgbC0tICl7XG4gICAgICAgIHZhciBjID0gY2FjaGVzW2xdO1xuXG4gICAgICAgIGlmKCBjICl7IGxvd2VyQ2FjaGUgPSBjOyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkgKXtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuXG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudCggZWxlLCBiYiwgbHZsICk7XG5cbiAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgIH1cblxuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSggdHhyLnVzZWRXaWR0aCwgMCApO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKCBzY2FsZSwgc2NhbGUgKTtcblxuICAgIHIuZHJhd0VsZW1lbnQoIHR4ci5jb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duICk7XG5cbiAgICB0eHIuY29udGV4dC5zY2FsZSggMS9zY2FsZSwgMS9zY2FsZSApO1xuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSggLXR4ci51c2VkV2lkdGgsIDAgKTtcbiAgfVxuXG4gIGVsZUNhY2hlID0gY2FjaGVzW2x2bF0gPSB7XG4gICAgZWxlOiBlbGUsXG4gICAgeDogdHhyLnVzZWRXaWR0aCxcbiAgICB0ZXh0dXJlOiB0eHIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgd2lkdGg6IGVsZVNjYWxlZFcsXG4gICAgaGVpZ2h0OiBlbGVTY2FsZWRILFxuICAgIHNjYWxlZExhYmVsU2hvd246IHNjYWxlZExhYmVsU2hvd25cbiAgfTtcblxuICB0eHIudXNlZFdpZHRoICs9IE1hdGguY2VpbCggZWxlU2NhbGVkVyArIGVsZVR4clNwYWNpbmcgKTtcblxuICB0eHIuZWxlQ2FjaGVzLnB1c2goIGVsZUNhY2hlICk7XG5cbiAgc2VsZi5jaGVja1RleHR1cmVGdWxsbmVzcyggdHhyICk7XG5cbiAgcmV0dXJuIGVsZUNhY2hlO1xufTtcblxuRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGVzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoLmltZ0NhY2hlcztcblxuICBpZiggY2FjaGVzICl7XG4gICAgZm9yKCB2YXIgbHZsID0gbWluTHZsOyBsdmwgPD0gbWF4THZsOyBsdmwrKyApe1xuICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWyBsdmwgXTtcblxuICAgICAgaWYoIGNhY2hlICl7XG4gICAgICAgIHZhciB0eHIgPSBjYWNoZS50ZXh0dXJlO1xuXG4gICAgICAgIC8vIHJlbW92ZSBzcGFjZSBmcm9tIHRoZSB0ZXh0dXJlIGl0IGJlbG9uZ3MgdG9cbiAgICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggKz0gY2FjaGUud2lkdGg7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHJlZnMgd2l0aCB0aGUgZWxlbWVudFxuICAgICAgICBjYWNoZXNbIGx2bCBdID0gbnVsbDtcbiAgICAgICAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIHR4ci5lbGVDYWNoZXMsIGNhY2hlICk7XG5cbiAgICAgICAgLy8gbWlnaHQgaGF2ZSB0byByZW1vdmUgdGhlIGVudGlyZSB0ZXh0dXJlIGlmIGl0J3Mgbm90IGVmZmljaWVudGx5IHVzaW5nIGl0cyBzcGFjZVxuICAgICAgICBzZWxmLmNoZWNrVGV4dHVyZVV0aWxpdHkoIHR4ciApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRVRDcC5jaGVja1RleHR1cmVVdGlsaXR5ID0gZnVuY3Rpb24oIHR4ciApe1xuICAvLyBpbnZhbGlkYXRlIGFsbCBlbnRyaWVzIGluIHRoZSBjYWNoZSBpZiB0aGUgY2FjaGUgc2l6ZSBpcyBzbWFsbFxuICBpZiggdHhyLmludmFsaWRhdGVkV2lkdGggPj0gbWluVXRpbGl0eSAqIHR4ci53aWR0aCApe1xuICAgIHRoaXMucmV0aXJlVGV4dHVyZSggdHhyICk7XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlRnVsbG5lc3MgPSBmdW5jdGlvbiggdHhyICl7XG4gIC8vIGlmIHRleHR1cmUgaGFzIGJlZW4gbW9zdGx5IGZpbGxlZCBhbmQgcGFzc2VkIG92ZXIgc2V2ZXJhbCB0aW1lcywgcmVtb3ZlXG4gIC8vIGl0IGZyb20gdGhlIHF1ZXVlIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FzdGUgdGltZSBsb29raW5nIGF0IGl0IHRvIHB1dCBuZXcgdGhpbmdzXG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHIuaGVpZ2h0ICk7XG5cbiAgaWYoIHR4ci51c2VkV2lkdGggLyB0eHIud2lkdGggPiBtYXhGdWxsbmVzcyAmJiB0eHIuZnVsbG5lc3NDaGVja3MgPj0gbWF4RnVsbG5lc3NDaGVja3MgKXtcbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheSggdHhyUSwgdHhyICk7XG4gIH0gZWxzZSB7XG4gICAgdHhyLmZ1bGxuZXNzQ2hlY2tzKys7XG4gIH1cbn07XG5cbkVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uKCB0eHIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUoIHR4ckggKTtcblxuICAvLyByZXRpcmUgdGhlIHRleHR1cmUgZnJvbSB0aGUgYWN0aXZlIC8gc2VhcmNoYWJsZSBxdWV1ZTpcblxuICB1dGlsLnJlbW92ZUZyb21BcnJheSggdHhyUSwgdHhyICk7XG5cbiAgdHhyLnJldGlyZWQgPSB0cnVlO1xuXG4gIC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgdmFyIGVsZSA9IGVsZUNhY2hlLmVsZTtcbiAgICB2YXIgbHZsID0gZWxlQ2FjaGUubGV2ZWw7XG4gICAgdmFyIGltZ0NhY2hlcyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdDYWNoZXM7XG5cbiAgICBpZiggaW1nQ2FjaGVzICl7XG4gICAgICBpbWdDYWNoZXNbIGx2bCBdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB1dGlsLmNsZWFyQXJyYXkoIGVsZUNhY2hlcyApO1xuXG4gIC8vIGFkZCB0aGUgdGV4dHVyZSB0byBhIHJldGlyZWQgcXVldWUgc28gaXQgY2FuIGJlIHJlY3ljbGVkIGluIGZ1dHVyZTpcblxuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgcnR4dHJRLnB1c2goIHR4ciApO1xufTtcblxuRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24oIHR4ckgsIG1pblcgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKCB0eHJIICk7XG4gIHZhciB0eHIgPSB7fTtcblxuICB0eHJRLnB1c2goIHR4ciApO1xuXG4gIHR4ci5lbGVDYWNoZXMgPSBbXTtcblxuICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgdHhyLndpZHRoID0gTWF0aC5tYXgoIGRlZlR4cldpZHRoLCBtaW5XICk7XG4gIHR4ci51c2VkV2lkdGggPSAwO1xuICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG5cbiAgdHhyLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIHR4ci5jYW52YXMud2lkdGggPSB0eHIud2lkdGg7XG4gIHR4ci5jYW52YXMuaGVpZ2h0ID0gdHhyLmhlaWdodDtcblxuICB0eHIuY29udGV4dCA9IHR4ci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICByZXR1cm4gdHhyO1xufTtcblxuRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uKCB0eHJILCBtaW5XICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSggdHhySCApO1xuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKCB0eHJIICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBydHh0clEubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdHhyID0gcnR4dHJRW2ldO1xuXG4gICAgaWYoIHR4ci53aWR0aCA+PSBtaW5XICl7XG4gICAgICB0eHIucmV0aXJlZCA9IGZhbHNlO1xuXG4gICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG5cbiAgICAgIHV0aWwuY2xlYXJBcnJheSggdHhyLmVsZUNhY2hlcyApO1xuXG4gICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoIDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCApO1xuXG4gICAgICB1dGlsLnJlbW92ZUZyb21BcnJheSggcnR4dHJRLCB0eHIgKTtcbiAgICAgIHR4clEucHVzaCggdHhyICk7XG5cbiAgICAgIHJldHVybiB0eHI7XG4gICAgfVxuICB9XG59O1xuXG5FVENwLnF1ZXVlRWxlbWVudCA9IGZ1bmN0aW9uKCBlbGUsIGJiLCBsdmwgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBpZDJxID0gc2VsZi5nZXRFbGVtZW50SWRUb1F1ZXVlKCk7XG4gIHZhciBpZCA9IGVsZS5pZCgpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBpZDJxWyBpZCBdO1xuXG4gIGlmKCBleGlzdGluZ1JlcSApeyAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoIGV4aXN0aW5nUmVxLmxldmVsLCBsdmwgKTtcbiAgICBleGlzdGluZ1JlcS5yZXFzKys7XG5cbiAgICBxLnVwZGF0ZUl0ZW0oIGV4aXN0aW5nUmVxICk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgIGVsZTogZWxlLFxuICAgICAgYmI6IGJiLFxuICAgICAgcG9zaXRpb246IG1hdGguY29weVBvc2l0aW9uKCBlbGUucG9zaXRpb24oKSApLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHJlcXM6IDFcbiAgICB9O1xuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSApe1xuICAgICAgcmVxLnBvc2l0aW9ucyA9IHtcbiAgICAgICAgc291cmNlOiBtYXRoLmNvcHlQb3NpdGlvbiggZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCkgKSxcbiAgICAgICAgdGFyZ2V0OiBtYXRoLmNvcHlQb3NpdGlvbiggZWxlLnRhcmdldCgpLnBvc2l0aW9uKCkgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBxLnB1c2goIHJlcSApO1xuXG4gICAgaWQycVsgaWQgXSA9IHJlcTtcbiAgfVxufTtcblxuRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24oIHB4UmF0aW8sIGV4dGVudCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGlkMnEgPSBzZWxmLmdldEVsZW1lbnRJZFRvUXVldWUoKTtcbiAgdmFyIGRlcXVldWVkID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBtYXhEZXFTaXplOyBpKysgKXtcbiAgICBpZiggcS5zaXplKCkgPiAwICl7XG4gICAgICB2YXIgcmVxID0gcS5wb3AoKTtcblxuICAgICAgaWQycVsgcmVxLmVsZS5pZCgpIF0gPSBudWxsO1xuXG4gICAgICBkZXF1ZXVlZC5wdXNoKCByZXEgKTtcblxuICAgICAgdmFyIGVsZSA9IHJlcS5lbGU7XG4gICAgICB2YXIgYmI7XG5cbiAgICAgIGlmKFxuICAgICAgICAoIGVsZS5pc0VkZ2UoKVxuICAgICAgICAgICYmIChcbiAgICAgICAgICAgICFtYXRoLmFyZVBvc2l0aW9uc1NhbWUoIGVsZS5zb3VyY2UoKS5wb3NpdGlvbigpLCByZXEucG9zaXRpb25zLnNvdXJjZSApXG4gICAgICAgICAgICB8fCAhbWF0aC5hcmVQb3NpdGlvbnNTYW1lKCBlbGUudGFyZ2V0KCkucG9zaXRpb24oKSwgcmVxLnBvc2l0aW9ucy50YXJnZXQgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICB8fCAoICFtYXRoLmFyZVBvc2l0aW9uc1NhbWUoIGVsZS5wb3NpdGlvbigpLCByZXEucG9zaXRpb24gKSApXG4gICAgICApe1xuICAgICAgICBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmIgPSByZXEuYmI7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZ2V0RWxlbWVudCggcmVxLmVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXF1ZXVlZDtcbn07XG5cbkVUQ3Aub25EZXF1ZXVlID0gZnVuY3Rpb24oIGZuICl7IHRoaXMub25EZXF1ZXVlcy5wdXNoKCBmbiApOyB9O1xuRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24oIGZuICl7IHV0aWwucmVtb3ZlRnJvbUFycmF5KCB0aGlzLm9uRGVxdWV1ZXMsIGZuICk7IH07XG5cbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uKCBzZWxmLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKCBweFJhdGlvLCBleHRlbnQgKTtcbiAgfSxcbiAgb25EZXFkOiBmdW5jdGlvbiggc2VsZiwgZGVxZCApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5vbkRlcXVldWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZm4gPSBzZWxmLm9uRGVxdWV1ZXNbaV07XG5cbiAgICAgIGZuKCBkZXFkICk7XG4gICAgfVxuICB9LFxuICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uKCBzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBiYiA9IGRlcWRbaV0uYmI7XG5cbiAgICAgIGlmKCBtYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGJiLCBleHRlbnQgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiggc2VsZiApe1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlVHhyRGVxO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50VGV4dHVyZUNhY2hlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKCB3LCBoICl7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIGJ1ZmZlci53aWR0aCA9IHc7XG4gIGJ1ZmZlci5oZWlnaHQgPSBoO1xuXG4gIHJldHVybiBbIGJ1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoICcyZCcgKSBdO1xufTtcblxuQ1JwLmJ1ZmZlckNhbnZhc0ltYWdlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgdmFyIGJiID0gZWxlcy5ib3VuZGluZ0JveCgpO1xuICB2YXIgY3RyUmVjdCA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoIGJiLncgKSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoIGJiLmggKSA6IGN0clJlY3RbM107XG4gIHZhciBzcGVjZE1heERpbXMgPSBpcy5udW1iZXIoIG9wdGlvbnMubWF4V2lkdGggKSB8fCBpcy5udW1iZXIoIG9wdGlvbnMubWF4SGVpZ2h0ICk7XG4gIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBzY2FsZSA9IDE7XG5cbiAgaWYoIG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCApe1xuICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG5cbiAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIH0gZWxzZSBpZiggc3BlY2RNYXhEaW1zICl7XG4gICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcblxuICAgIGlmKCBpcy5udW1iZXIoIG9wdGlvbnMubWF4V2lkdGggKSApe1xuICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYoIGlzLm51bWJlciggb3B0aW9ucy5tYXhIZWlnaHQgKSApe1xuICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICB9XG5cbiAgICBzY2FsZSA9IE1hdGgubWluKCBtYXhTY2FsZVcsIG1heFNjYWxlSCApO1xuXG4gICAgd2lkdGggKj0gc2NhbGU7XG4gICAgaGVpZ2h0ICo9IHNjYWxlO1xuICB9XG5cbiAgaWYoICFzcGVjZE1heERpbXMgKXtcbiAgICB3aWR0aCAqPSBweFJhdGlvO1xuICAgIGhlaWdodCAqPSBweFJhdGlvO1xuICAgIHNjYWxlICo9IHB4UmF0aW87XG4gIH1cblxuICB2YXIgYnVmZkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXG4gIC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuICBpZiggd2lkdGggPiAwICYmIGhlaWdodCA+IDAgKXtcblxuICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICBpZiggb3B0aW9ucy5iZyApe1xuICAgICAgYnVmZkN4dC5maWxsU3R5bGUgPSBvcHRpb25zLmJnO1xuICAgICAgYnVmZkN4dC5yZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICB9XG5cbiAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cbiAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgICBpZiggb3B0aW9ucy5mdWxsICl7IC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoIC1iYi54MSAqIHNjYWxlLCAtYmIueTEgKiBzY2FsZSApO1xuICAgICAgYnVmZkN4dC5zY2FsZSggc2NhbGUsIHNjYWxlICk7XG5cbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKCBidWZmQ3h0LCB6c29ydGVkRWxlcyApO1xuICAgIH0gZWxzZSB7IC8vIGRyYXcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgIH07XG5cbiAgICAgIHNjYWxlICo9IGN5Lnpvb20oKTtcblxuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkgKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoIHNjYWxlLCBzY2FsZSApO1xuXG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyggYnVmZkN4dCwgenNvcnRlZEVsZXMgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZkNhbnZhcztcbn07XG5cbmZ1bmN0aW9uIGI2NFRvQmxvYiggYjY0LCBtaW1lVHlwZSApe1xuICB2YXIgYnl0ZXMgPSBhdG9iKCBiNjQgKTtcbiAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoIGJ5dGVzLmxlbmd0aCApO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmYgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrICl7XG4gICAgYnVmZlVpbnQ4W2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQmxvYiggW2J1ZmZdLCB7IHR5cGU6IG1pbWVUeXBlIH0gKTtcbn1cblxuZnVuY3Rpb24gYjY0VXJpVG9CNjQoIGI2NHVyaSApe1xuICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG5cbiAgcmV0dXJuIGI2NHVyaS5zdWJzdHIoIGkgKyAxICk7XG59O1xuXG5mdW5jdGlvbiBvdXRwdXQoIG9wdGlvbnMsIGNhbnZhcywgbWltZVR5cGUgKXtcbiAgdmFyIGI2NFVyaSA9IGNhbnZhcy50b0RhdGFVUkwoIG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkgKTtcblxuICBzd2l0Y2goIG9wdGlvbnMub3V0cHV0ICl7XG4gICAgY2FzZSAnYmxvYic6XG4gICAgICByZXR1cm4gYjY0VG9CbG9iKCBiNjRVcmlUb0I2NCggYjY0VXJpICksIG1pbWVUeXBlICk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KCBiNjRVcmkgKTtcblxuICAgIGNhc2UgJ2Jhc2U2NHVyaSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBiNjRVcmk7XG4gIH1cbn1cblxuQ1JwLnBuZyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIHJldHVybiBvdXRwdXQoIG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2UoIG9wdGlvbnMgKSwgJ2ltYWdlL3BuZycgKTtcbn07XG5cbkNScC5qcGcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICByZXR1cm4gb3V0cHV0KCBvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICksICdpbWFnZS9qcGVnJyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIvKlxuVGhlIGNhbnZhcyByZW5kZXJlciB3YXMgd3JpdHRlbiBieSBZdWUgRG9uZy5cblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi8uLi8uLi9pcycgKTtcbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gcmVxdWlyZSgnLi9lbGUtdGV4dHVyZS1jYWNoZScpO1xudmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSByZXF1aXJlKCcuL2xheWVyZWQtdGV4dHVyZS1jYWNoZScpO1xuXG52YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbnZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbkNScC5DQU5WQVNfTEFZRVJTID0gMztcbi8vXG5DUnAuU0VMRUNUX0JPWCA9IDA7XG5DUnAuRFJBRyA9IDE7XG5DUnAuTk9ERSA9IDI7XG5cbkNScC5CVUZGRVJfQ09VTlQgPSAzO1xuLy9cbkNScC5URVhUVVJFX0JVRkZFUiA9IDA7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSA9IDE7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCBvcHRpb25zICl7XG4gIHZhciByID0gdGhpcztcblxuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheSggQ1JwLkNBTlZBU19MQVlFUlMgKSxcbiAgICBjb250ZXh0czogbmV3IEFycmF5KCBDUnAuQ0FOVkFTX0xBWUVSUyApLFxuICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoIENScC5DQU5WQVNfTEFZRVJTICksXG5cbiAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KCBDUnAuQlVGRkVSX0NPVU5UICksXG4gICAgYnVmZmVyQ29udGV4dHM6IG5ldyBBcnJheSggQ1JwLkNBTlZBU19MQVlFUlMgKSxcbiAgfTtcblxuICByLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTsnICk7XG4gIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoIHIuZGF0YS5jYW52YXNDb250YWluZXIgKTtcbiAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgKCBjb250YWluZXIuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICkgfHwgJycgKSArICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7JyApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKyApe1xuICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbIGkgXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmNvbnRleHRzWyBpIF0gPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAtbW96LXVzZXItc2VsZWN0OiAtbW96LW5vbmU7IHVzZXItc2VsZWN0OiBub25lOyAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7IG91dGxpbmUtc3R5bGU6IG5vbmU7JyArICggaXMubXMoKSA/ICcgLW1zLXRvdWNoLWFjdGlvbjogbm9uZTsgdG91Y2gtYWN0aW9uOiBub25lOyAnIDogJycgKSApO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSggJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSApO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoIENScC5DQU5WQVNfTEFZRVJTIC0gaSApO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuXG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3WyBpIF0gPSBmYWxzZTtcbiAgfVxuICByLmRhdGEudG9wQ2FudmFzID0gci5kYXRhLmNhbnZhc2VzWzBdO1xuXG4gIHIuZGF0YS5jYW52YXNlc1sgQ1JwLk5PREUgXS5zZXRBdHRyaWJ1dGUoICdkYXRhLWlkJywgJ2xheWVyJyArIENScC5OT0RFICsgJy1ub2RlJyApO1xuICByLmRhdGEuY2FudmFzZXNbIENScC5TRUxFQ1RfQk9YIF0uc2V0QXR0cmlidXRlKCAnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94JyApO1xuICByLmRhdGEuY2FudmFzZXNbIENScC5EUkFHIF0uc2V0QXR0cmlidXRlKCAnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycgKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKyApe1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICByLmRhdGEuYnVmZmVyQ29udGV4dHNbIGkgXSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLmdldENvbnRleHQoICcyZCcgKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIGkgXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBpIF0uc2V0QXR0cmlidXRlKCAnZGF0YS1pZCcsICdidWZmZXInICsgaSApO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1sgaSBdLnN0eWxlLnpJbmRleCA9IFN0cmluZyggLWkgLSAxICk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBpIF0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIC8vci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICB9XG5cbiAgci5wYXRoc0VuYWJsZWQgPSB0cnVlO1xuXG4gIHIuZGF0YS5lbGVUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKCByICk7XG4gIHIuZGF0YS5seXJUeHJDYWNoZSA9IG5ldyBMYXllcmVkVGV4dHVyZUNhY2hlKCByLCByLmRhdGEuZWxlVHhyQ2FjaGUgKTtcblxuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMoIHdpbGxEcmF3LCBlbGVzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG4gICAgICB2YXIgZGUgPSBycy5kaXJ0eUV2ZW50cztcblxuICAgICAgaWYoIGVsZS5pc05vZGUoKSAmJiBkZSAmJiBkZS5sZW5ndGggPT09IDEgJiYgZGVbJ3Bvc2l0aW9uJ10gKXtcbiAgICAgICAgLy8gdGhlbiBrZWVwIGNhY2hlZCBlbGUgdGV4dHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5kYXRhLmVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50KCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZWxlcy5sZW5ndGggPiAwICl7XG4gICAgICByLmRhdGEubHlyVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKCBlbGVzICk7XG4gICAgfVxuICB9KTtcbn1cblxuQ1JwLnJlZHJhd0hpbnQgPSBmdW5jdGlvbiggZ3JvdXAsIGJvb2wgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHN3aXRjaCggZ3JvdXAgKXtcbiAgICBjYXNlICdlbGVzJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLk5PREUgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkcmFnJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLkRSQUcgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3WyBDUnAuU0VMRUNUX0JPWCBdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiggb24gKXtcbiAgaWYoIG9uID09PSB1bmRlZmluZWQgKXtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuXG5bXG4gIHJlcXVpcmUoICcuL2Fycm93LXNoYXBlcycgKSxcbiAgcmVxdWlyZSggJy4vZHJhd2luZy1lbGVtZW50cycgKSxcbiAgcmVxdWlyZSggJy4vZHJhd2luZy1lZGdlcycgKSxcbiAgcmVxdWlyZSggJy4vZHJhd2luZy1pbWFnZXMnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctbGFiZWwtdGV4dCcgKSxcbiAgcmVxdWlyZSggJy4vZHJhd2luZy1ub2RlcycgKSxcbiAgcmVxdWlyZSggJy4vZHJhd2luZy1yZWRyYXcnICksXG4gIHJlcXVpcmUoICcuL2RyYXdpbmctc2hhcGVzJyApLFxuICByZXF1aXJlKCAnLi9leHBvcnQtaW1hZ2UnICksXG4gIHJlcXVpcmUoICcuL25vZGUtc2hhcGVzJyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggQ1JwLCBwcm9wcyApO1xufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENSO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vLi4vLi4vbWF0aCcgKTtcbnZhciBIZWFwID0gcmVxdWlyZSggJy4uLy4uLy4uL2hlYXAnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vLi4vLi4vaXMnICk7XG52YXIgZGVmcyA9IHJlcXVpcmUoICcuL3RleHR1cmUtY2FjaGUtZGVmcycgKTtcblxudmFyIGRlZk51bUxheWVycyA9IDE7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIGxheWVycyB0byB1c2VcbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxudmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxudmFyIGRlcVJlZHJhd1RocmVzaG9sZCA9IDUwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIHJlZmluZUVsZURlYm91bmNlVGltZSA9IDUwOyAvLyB0aW1lIHRvIGRlYm91bmNlIHNoYXJwZXIgZWxlIHRleHR1cmUgdXBkYXRlc1xudmFyIGRpc2FibGVFbGVJbWdTbW9vdGhpbmcgPSB0cnVlOyAvLyB3aGVuIGRyYXdpbmcgZWxlcyBvbiBsYXllcnMgZnJvbSBhbiBlbGUgY2FjaGUgOyBjcmlzcGVyIGFuZCBtb3JlIHBlcmZvcm1hbnQgd2hlbiB0cnVlXG52YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG52YXIgZGVxTm9EcmF3Q29zdCA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcbnZhciBpbnZhbGlkVGhyZXNob2xkID0gMjUwOyAvLyB0aW1lIHRocmVzaG9sZCBmb3IgZGlzYWJsaW5nIGIvYyBvZiBpbnZhbGlkYXRpb25zXG52YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG52YXIgYWx3YXlzUXVldWUgPSB0cnVlOyAvLyBuZXZlciBkcmF3IGFsbCB0aGUgbGF5ZXJzIGluIGEgbGV2ZWwgb24gYSBmcmFtZTsgZHJhdyBkaXJlY3RseSB1bnRpbCBhbGwgZGVxdWV1ZWRcbnZhciB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBoaWdoIHF1YWxpdHkgZWxlIHR4ciByZXF1ZXN0cyAoZ2VuZXJhbGx5IGZhc3RlciBhbmQgY2hlYXBlciBpbiB0aGUgbG9uZ3Rlcm0pXG5cbnZhciB1c2VFbGVUeHJDYWNoaW5nID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaW5kaXZpZHVhbCBlbGUgdGV4dHVyZSBjYWNoaW5nIHVuZGVybmVhdGggdGhpcyBjYWNoZVxuXG4vLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uKCByZW5kZXJlciwgZWxlVHhyQ2FjaGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciByID0gc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gIHNlbGYubGF5ZXJzQnlMZXZlbCA9IHt9OyAvLyBlLmcuIDIgPT4gWyBsYXllcjEsIGxheWVyMiwgLi4uLCBsYXllck4gXVxuXG4gIHNlbGYuZmlyc3RHZXQgPSB0cnVlO1xuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCkgLSAyKmludmFsaWRUaHJlc2hvbGQ7XG5cbiAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuXG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uKCB3aWxsRHJhdywgbm93ICl7XG4gICAgaWYoIG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCApe1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBxU29ydCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH07XG5cbiAgc2VsZi5sYXllcnNRdWV1ZSA9IG5ldyBIZWFwKCBxU29ydCApO1xuXG4gIHNlbGYuZWxlVHhyQ2FjaGUgPSBlbGVUeHJDYWNoZTtcblxuICBzZWxmLnNldHVwRWxlQ2FjaGVJbnZhbGlkYXRpb24oKTtcblxuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcblxudmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcblxudmFyIGxheWVySWRQb29sID0gMDtcbnZhciBNQVhfSU5UID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuTFRDcC5tYWtlTGF5ZXIgPSBmdW5jdGlvbiggYmIsIGx2bCApe1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdyggMiwgbHZsICk7XG5cbiAgdmFyIHcgPSBNYXRoLmNlaWwoIGJiLncgKiBzY2FsZSApO1xuICB2YXIgaCA9IE1hdGguY2VpbCggYmIuaCAqIHNjYWxlICk7XG5cbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG5cbiAgdmFyIGxheWVyID0ge1xuICAgIGlkOiAobGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCApLFxuICAgIGJiOiBiYixcbiAgICBsZXZlbDogbHZsLFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICBlbGVzOiBbXSxcbiAgICBlbGVzUXVldWU6IFtdLFxuICAgIHJlcXM6IDBcbiAgfTtcblxuICAvLyBsb2coJ21ha2UgbGF5ZXIgJXMgd2l0aCB3ICVzIGFuZCBoICVzIGFuZCBsdmwgJXMnLCBsYXllci5pZCwgbGF5ZXIud2lkdGgsIGxheWVyLmhlaWdodCwgbGF5ZXIubGV2ZWwpO1xuXG4gIHZhciBjeHQgPSBsYXllci5jb250ZXh0O1xuICB2YXIgZHggPSAtbGF5ZXIuYmIueDE7XG4gIHZhciBkeSA9IC1sYXllci5iYi55MTtcblxuICAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcbiAgY3h0LnNjYWxlKCBzY2FsZSwgc2NhbGUgKTtcbiAgY3h0LnRyYW5zbGF0ZSggZHgsIGR5ICk7XG5cbiAgcmV0dXJuIGxheWVyO1xufTtcblxuTFRDcC5nZXRMYXllcnMgPSBmdW5jdGlvbiggZWxlcywgcHhSYXRpbywgbHZsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIGZpcnN0R2V0ID0gc2VsZi5maXJzdEdldDtcblxuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7XG5cbiAgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICBpZiggbHZsID09IG51bGwgKXtcbiAgICBsdmwgPSBNYXRoLmNlaWwoIG1hdGgubG9nMiggem9vbSAqIHB4UmF0aW8gKSApO1xuXG4gICAgaWYoIGx2bCA8IG1pbkx2bCApe1xuICAgICAgbHZsID0gbWluTHZsO1xuICAgIH0gZWxzZSBpZiggem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyggbHZsLCBlbGVzICk7XG5cbiAgdmFyIGxheWVyc0J5THZsID0gc2VsZi5sYXllcnNCeUxldmVsO1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdyggMiwgbHZsICk7XG4gIHZhciBsYXllcnMgPSBsYXllcnNCeUx2bFsgbHZsIF0gPSBsYXllcnNCeUx2bFsgbHZsIF0gfHwgW107XG4gIHZhciBiYjtcblxuICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZSggbHZsLCBlbGVzICk7XG4gIHZhciB0bXBMYXllcnM7XG5cbiAgdmFyIGNoZWNrVGVtcExldmVscyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24oIGwgKXtcbiAgICAgIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcoIGwsIGVsZXMgKTtcblxuICAgICAgaWYoIHNlbGYubGV2ZWxJc0NvbXBsZXRlKCBsLCBlbGVzICkgKXtcbiAgICAgICAgdG1wTGF5ZXJzID0gbGF5ZXJzQnlMdmxbbF07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2hlY2tMdmxzID0gZnVuY3Rpb24oIGRpciApe1xuICAgICAgaWYoIHRtcExheWVycyApeyByZXR1cm47IH1cblxuICAgICAgZm9yKCB2YXIgbCA9IGx2bCArIGRpcjsgbWluTHZsIDw9IGwgJiYgbCA8PSBtYXhMdmw7IGwgKz0gZGlyICl7XG4gICAgICAgIGlmKCBjYW5Vc2VBc1RtcEx2bChsKSApeyBicmVhazsgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja0x2bHMoICsxICk7XG4gICAgY2hlY2tMdmxzKCAtMSApO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgZm9yKCB2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApe1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICBpZiggbGF5ZXIuaW52YWxpZCApe1xuICAgICAgICB1dGlsLnJlbW92ZUZyb21BcnJheSggbGF5ZXJzLCBsYXllciApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiggIWx2bENvbXBsZXRlICl7XG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgaW5jb21wbGV0ZSwgdGhlbiB1c2UgdGhlIGNsb3Nlc3QsIGJlc3QgcXVhbGl0eSBsYXllcnNldCB0ZW1wb3JhcmlseVxuICAgIC8vIGFuZCBsYXRlciBxdWV1ZSB0aGUgY3VycmVudCBsYXllcnNldCBzbyB3ZSBjYW4gZ2V0IHRoZSBwcm9wZXIgcXVhbGl0eSBsZXZlbCBzb29uXG5cbiAgICBjaGVja1RlbXBMZXZlbHMoKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIHZhciBnZXRCYiA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICFiYiApe1xuICAgICAgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgbWF0aC51cGRhdGVCb3VuZGluZ0JveCggYmIsIGVsZXNbaV0uYm91bmRpbmdCb3goKSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYjtcbiAgfTtcblxuICB2YXIgbWFrZUxheWVyID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBhZnRlciA9IG9wdHMuYWZ0ZXI7XG5cbiAgICBnZXRCYigpO1xuXG4gICAgdmFyIGFyZWEgPSAoIGJiLncgKiBzY2FsZSApICogKCBiYi5oICogc2NhbGUgKTtcblxuICAgIGlmKCBhcmVhID4gbWF4TGF5ZXJBcmVhICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSBzZWxmLm1ha2VMYXllciggYmIsIGx2bCApO1xuXG4gICAgaWYoIGFmdGVyICE9IG51bGwgKXtcbiAgICAgIHZhciBpbmRleCA9IGxheWVycy5pbmRleE9mKCBhZnRlciApICsgMTtcblxuICAgICAgbGF5ZXJzLnNwbGljZSggaW5kZXgsIDAsIGxheWVyICk7XG4gICAgfSBlbHNlIGlmKCBvcHRzLmluc2VydCA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuaW5zZXJ0ICl7XG4gICAgICAvLyBubyBhZnRlciBzcGVjaWZpZWQgPT4gZmlyc3QgbGF5ZXIgbWFkZSBzbyBwdXQgYXQgc3RhcnRcbiAgICAgIGxheWVycy51bnNoaWZ0KCBsYXllciApO1xuICAgIH1cblxuICAgIC8vIGlmKCB0bXBMYXllcnMgKXtcbiAgICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfTtcblxuICBpZiggc2VsZi5za2lwcGluZyAmJiAhZmlyc3RHZXQgKXtcbiAgICAvLyBsb2coJ3NraXAgbGF5ZXJzJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsb2coJ2RvIGxheWVycycpO1xuXG4gIHZhciBsYXllciA9IG51bGw7XG4gIHZhciBtYXhFbGVzUGVyTGF5ZXIgPSBlbGVzLmxlbmd0aCAvIGRlZk51bUxheWVycztcbiAgdmFyIGFsbG93TGF6eVF1ZXVlaW5nID0gYWx3YXlzUXVldWUgJiYgIWZpcnN0R2V0O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIC8vIGxvZygnbG9vayBhdCBlbGUnLCBlbGUuaWQoKSk7XG5cbiAgICB2YXIgZXhpc3RpbmdMYXllciA9IGNhY2hlc1sgbHZsIF07XG5cbiAgICBpZiggZXhpc3RpbmdMYXllciApe1xuICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYoXG4gICAgICAhbGF5ZXJcbiAgICAgIHx8IGxheWVyLmVsZXMubGVuZ3RoID49IG1heEVsZXNQZXJMYXllclxuICAgICAgfHwgIW1hdGguYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KCBsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkgKVxuICAgICl7XG4gICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG5cbiAgICAgIGxheWVyID0gbWFrZUxheWVyKHsgaW5zZXJ0OiB0cnVlLCBhZnRlcjogbGF5ZXIgfSk7XG5cbiAgICAgIC8vIGlmIG5vdyBsYXllciBjYW4gYmUgYnVpbHQgdGhlbiB3ZSBjYW4ndCB1c2UgbGF5ZXJzIGF0IHRoaXMgbGV2ZWxcbiAgICAgIGlmKCAhbGF5ZXIgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgLy8gbG9nKCduZXcgbGF5ZXIgd2l0aCBpZCAlcycsIGxheWVyLmlkKTtcbiAgICB9XG5cbiAgICBpZiggdG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nICl7XG4gICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLnF1ZXVlTGF5ZXIoIGxheWVyLCBlbGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9nKCdkcmF3IGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKCBsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8gKTtcbiAgICB9XG5cbiAgICBsYXllci5lbGVzLnB1c2goIGVsZSApO1xuXG4gICAgY2FjaGVzWyBsdmwgXSA9IGxheWVyO1xuICB9XG5cbiAgLy8gbG9nKCctLScpO1xuXG4gIGlmKCB0bXBMYXllcnMgKXsgLy8gdGhlbiB3ZSBvbmx5IHF1ZXVlZCB0aGUgY3VycmVudCBsYXllcnNldCBhbmQgY2FuJ3QgZHJhdyBpdCB5ZXRcbiAgICByZXR1cm4gdG1wTGF5ZXJzO1xuICB9XG5cbiAgaWYoIGFsbG93TGF6eVF1ZXVlaW5nICl7XG4gICAgLy8gbG9nKCdsYXp5IHF1ZXVlIGxldmVsJywgbHZsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBsYXllcnM7XG59O1xuXG4vLyBhIGxheWVyIG1heSB3YW50IHRvIHVzZSBhbiBlbGUgY2FjaGUgb2YgYSBoaWdoZXIgbGV2ZWwgdG8gYXZvaWQgYmx1cnJpbmVzc1xuLy8gc28gdGhlIGxheWVyIGxldmVsIG1pZ2h0IG5vdCBlcXVhbCB0aGUgZWxlIGxldmVsXG5MVENwLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCA9IGZ1bmN0aW9uKCBsdmwsIHB4UmF0aW8gKXtcbiAgcmV0dXJuIGx2bDtcbn07XG5cbmZ1bmN0aW9uIGltZ1Ntb290aGluZyggY29udGV4dCwgYm9vbCApe1xuICBpZiggY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCApe1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9XG59XG5cbkxUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiggbGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gIGlmKCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIGVsZUNhY2hlID0gc2VsZi5lbGVUeHJDYWNoZTtcbiAgdmFyIHJlYXNvbiA9IHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyA/IGVsZUNhY2hlLnJlYXNvbnMuaGlnaFF1YWxpdHkgOiB1bmRlZmluZWQ7XG5cbiAgbHZsID0gc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwoIGx2bCwgcHhSYXRpbyApO1xuXG4gIHZhciBjYWNoZSA9IHVzZUVsZVR4ckNhY2hpbmcgPyBlbGVDYWNoZS5nZXRFbGVtZW50KCBlbGUsIGJiLCBudWxsLCBsdmwsIHJlYXNvbiApIDogbnVsbDtcblxuICBpZiggY2FjaGUgKXtcbiAgICBpZiggZGlzYWJsZUVsZUltZ1Ntb290aGluZyApeyBpbWdTbW9vdGhpbmcoIGNvbnRleHQsIGZhbHNlICk7IH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKCBjYWNoZS50ZXh0dXJlLmNhbnZhcywgY2FjaGUueCwgMCwgY2FjaGUud2lkdGgsIGNhY2hlLmhlaWdodCwgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oICk7XG5cbiAgICBpZiggZGlzYWJsZUVsZUltZ1Ntb290aGluZyApeyBpbWdTbW9vdGhpbmcoIGNvbnRleHQsIHRydWUgKTsgfVxuICB9IGVsc2UgeyAvLyBpZiB0aGUgZWxlbWVudCBpcyBub3QgY2FjaGVhYmxlLCB0aGVuIGRyYXcgZGlyZWN0bHlcbiAgICByLmRyYXdFbGVtZW50KCBjb250ZXh0LCBlbGUgKTtcbiAgfVxufTtcblxuTFRDcC5sZXZlbElzQ29tcGxldGUgPSBmdW5jdGlvbiggbHZsLCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFsgbHZsIF07XG5cbiAgaWYoICFsYXllcnMgfHwgbGF5ZXJzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbnVtRWxlc0luTGF5ZXJzID0gMDtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgZWxlcyBuZWVkZWQgdG8gYmUgZHJhd24geWV0LCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYoIGxheWVyLnJlcXMgPiAwICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGlzIGludmFsaWQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcbiAgICBpZiggbGF5ZXIuaW52YWxpZCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIG51bWJlciBvZiBlbGVzIHBhc3NlZCBpbiB0byBiZSBjb21wbGV0ZVxuICBpZiggbnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCApeyByZXR1cm4gZmFsc2U7IH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkxUQ3AudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcgPSBmdW5jdGlvbiggbHZsLCBlbGVzICl7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbIGx2bCBdO1xuXG4gIGlmKCAhbGF5ZXJzICl7IHJldHVybjsgfVxuXG4gIC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuXG4gICAgLy8gZmluZCB0aGUgb2Zmc2V0XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICBpZiggbGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSApe1xuICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggb2Zmc2V0IDwgMCApe1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0YW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllciggbGF5ZXIgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRoZSBlbGVzIGluIHRoZSBsYXllciBtdXN0IGJlIGluIHRoZSBzYW1lIGNvbnRpbnVvdXMgb3JkZXIsIGVsc2UgdGhlIGxheWVyIGlzIGludmFsaWRcblxuICAgIHZhciBvID0gb2Zmc2V0O1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsYXllci5lbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICBpZiggbGF5ZXIuZWxlc1tqXSAhPT0gZWxlc1tvK2pdICl7XG4gICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcblxuICAgICAgICB0aGlzLmludmFsaWRhdGVMYXllciggbGF5ZXIgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiggZWxlcywgdXBkYXRlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzRWxlcyA9IGlzLmVsZW1lbnQoIGVsZXNbMF0gKTtcblxuICAvLyBjb2xsZWN0IHVkcGF0ZWQgZWxlbWVudHMgKGNhc2NhZGVkIGZyb20gdGhlIGxheWVycykgYW5kIHVwZGF0ZSBlYWNoXG4gIC8vIGxheWVyIGl0c2VsZiBhbG9uZyB0aGUgd2F5XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciByZXEgPSBpc0VsZXMgPyBudWxsIDogZWxlc1tpXTtcbiAgICB2YXIgZWxlID0gaXNFbGVzID8gZWxlc1tpXSA6IGVsZXNbaV0uZWxlO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGZvciggdmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKysgKXtcbiAgICAgIHZhciBsYXllciA9IGNhY2hlc1tsXTtcblxuICAgICAgaWYoICFsYXllciApeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuICAgICAgaWYoIHJlcSAmJiBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCggbGF5ZXIubGV2ZWwgKSAhPT0gcmVxLmxldmVsICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUoIGxheWVyLCBlbGUsIHJlcSApO1xuICAgIH1cbiAgfVxufTtcblxuTFRDcC5oYXZlTGF5ZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaGF2ZUxheWVycyA9IGZhbHNlO1xuXG4gIGZvciggdmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKysgKXtcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuXG4gICAgaWYoIGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCApe1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGF2ZUxheWVycztcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lIGZyb20gZWxlcycpO1xuXG4gIGlmKCBlbGVzLmxlbmd0aCA9PT0gMCB8fCAhc2VsZi5oYXZlTGF5ZXJzKCkgKXsgcmV0dXJuOyB9XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKCBlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKCBsYXllciwgZWxlLCByZXEgKXtcbiAgICBzZWxmLmludmFsaWRhdGVMYXllciggbGF5ZXIgKTtcbiAgfSApO1xufTtcblxuTFRDcC5pbnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbiggbGF5ZXIgKXtcbiAgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lJyk7XG5cbiAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcblxuICBpZiggbGF5ZXIuaW52YWxpZCApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXNcblxuICB2YXIgbHZsID0gbGF5ZXIubGV2ZWw7XG4gIHZhciBlbGVzID0gbGF5ZXIuZWxlcztcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFsgbHZsIF07XG5cbiAgIC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgdXRpbC5yZW1vdmVGcm9tQXJyYXkoIGxheWVycywgbGF5ZXIgKTtcbiAgLy8gbGF5ZXIuZWxlcyA9IFtdO1xuXG4gIGxheWVyLmVsZXNRdWV1ZSA9IFtdO1xuXG4gIGxheWVyLmludmFsaWQgPSB0cnVlO1xuXG4gIGlmKCBsYXllci5yZXBsYWNlbWVudCApe1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG5cbiAgICBpZiggY2FjaGVzICl7XG4gICAgICBjYWNoZXNbIGx2bCBdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AucmVmaW5lRWxlbWVudFRleHR1cmVzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGxvZygncmVmaW5lJywgZWxlcy5sZW5ndGgpO1xuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyggZWxlcywgZnVuY3Rpb24gcmVmaW5lRWFjaEVsZSggbGF5ZXIsIGVsZSwgcmVxICl7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgIGlmKCAhckx5ciApe1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIoIGxheWVyLmJiLCBsYXllci5sZXZlbCApO1xuICAgICAgckx5ci5yZXBsYWNlcyA9IGxheWVyO1xuICAgICAgckx5ci5lbGVzID0gbGF5ZXIuZWxlcztcblxuICAgICAgIC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiggIXJMeXIucmVxcyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKCByTHlyLCByTHlyLmVsZXNbaV0gKTtcbiAgICAgIH1cblxuICAgICAgIC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuICAgIH1cbiAgfSApO1xufTtcblxuTFRDcC5zZXR1cEVsZUNhY2hlSW52YWxpZGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlRGVxcyA9IFtdO1xuXG4gIGlmKCAhdXNlRWxlVHhyQ2FjaGluZyApeyByZXR1cm47IH1cblxuICB2YXIgdXBkYXRlZEVsZXNJbkxheWVycyA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5yZWZpbmVFbGVtZW50VGV4dHVyZXMoIGVsZURlcXMgKTtcblxuICAgIGVsZURlcXMgPSBbXTtcbiAgfSwgcmVmaW5lRWxlRGVib3VuY2VUaW1lICk7XG5cbiAgc2VsZi5lbGVUeHJDYWNoZS5vbkRlcXVldWUoZnVuY3Rpb24oIHJlcXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlcXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVsZURlcXMucHVzaCggcmVxc1tpXSApO1xuICAgIH1cblxuICAgIHVwZGF0ZWRFbGVzSW5MYXllcnMoKTtcbiAgfSk7XG59O1xuXG5MVENwLnF1ZXVlTGF5ZXIgPSBmdW5jdGlvbiggbGF5ZXIsIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGVsZXNRID0gbGF5ZXIuZWxlc1F1ZXVlO1xuICB2YXIgaGFzSWQgPSBlbGVzUS5oYXNJZCA9IGVsZXNRLmhhc0lkIHx8IHt9O1xuXG4gIC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG4gIGlmKCBsYXllci5yZXBsYWNlbWVudCApeyByZXR1cm47IH1cblxuICBpZiggZWxlICl7XG4gICAgaWYoIGhhc0lkWyBlbGUuaWQoKSBdICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlc1EucHVzaCggZWxlICk7XG4gICAgaGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICB9XG5cbiAgaWYoIGxheWVyLnJlcXMgKXtcbiAgICBsYXllci5yZXFzKys7XG5cbiAgICBxLnVwZGF0ZUl0ZW0oIGxheWVyICk7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG5cbiAgICBxLnB1c2goIGxheWVyICk7XG4gIH1cbn07XG5cbkxUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uKCBweFJhdGlvICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZGVxZCA9IFtdO1xuICB2YXIgZWxlRGVxcyA9IDA7XG5cbiAgd2hpbGUoIGVsZURlcXMgPCBtYXhEZXFTaXplICl7XG4gICAgaWYoIHEuc2l6ZSgpID09PSAwICl7IGJyZWFrOyB9XG5cbiAgICB2YXIgbGF5ZXIgPSBxLnBlZWsoKTtcblxuICAgIC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcbiAgICBpZiggbGF5ZXIucmVwbGFjZW1lbnQgKXtcbiAgICAgICAvLyBsb2coJ2xheWVyICVzIGluIHF1ZXVlIHNraXBwZWQgYi9jIGl0IGFscmVhZHkgaGFzIGEgcmVwbGFjZW1lbnQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlcGxhY2VtZW50IGxheWVyIHRoYXQgaGFzIGJlZW4gc3VwZXJjZWRlZCwgdGhlbiBmb3JnZXQgaXRcbiAgICBpZiggbGF5ZXIucmVwbGFjZXMgJiYgbGF5ZXIgIT09IGxheWVyLnJlcGxhY2VzLnJlcGxhY2VtZW50ICl7XG4gICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYoIGxheWVyLmludmFsaWQgKXtcbiAgICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSBsYXllci5lbGVzUXVldWUuc2hpZnQoKTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgICAvLyBsb2coJ2RlcXVldWUgbGF5ZXIgJXMnLCBsYXllci5pZCk7XG5cbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIoIGxheWVyLCBlbGUsIGxheWVyLmxldmVsLCBweFJhdGlvICk7XG5cbiAgICAgIGVsZURlcXMrKztcbiAgICB9XG5cbiAgICBpZiggZGVxZC5sZW5ndGggPT09IDAgKXtcbiAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgZW50cnkgaW4gZGVxZCB0byBxdWV1ZSByZWRyYXdpbmcgZXRjXG4gICAgICBkZXFkLnB1c2goIHRydWUgKTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbGF5ZXIgaGFzIGFsbCBpdHMgZWxlcyBkb25lLCB0aGVuIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZVxuICAgIGlmKCBsYXllci5lbGVzUXVldWUubGVuZ3RoID09PSAwICl7XG4gICAgICBxLnBvcCgpO1xuXG4gICAgICBsYXllci5yZXFzID0gMDtcblxuICAgICAgIC8vIGxvZygnZGVxdWV1ZSBvZiBsYXllciAlcyBjb21wbGV0ZScsIGxheWVyLmlkKTtcblxuICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuICAgICAgaWYoIGxheWVyLnJlcGxhY2VzICl7XG4gICAgICAgIHNlbGYuYXBwbHlMYXllclJlcGxhY2VtZW50KCBsYXllciApO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxZDtcbn07XG5cbkxUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24oIGxheWVyICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbIGxheWVyLmxldmVsIF07XG4gIHZhciByZXBsYWNlZCA9IGxheWVyLnJlcGxhY2VzO1xuICB2YXIgaW5kZXggPSBsYXllcnNJbkxldmVsLmluZGV4T2YoIHJlcGxhY2VkICk7XG5cbiAgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuICBpZiggaW5kZXggPCAwIHx8IHJlcGxhY2VkLmludmFsaWQgKXtcbiAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciB3b3VsZCBoYXZlIG5vIGVmZmVjdCcsIGxheWVyLmlkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsYXllcnNJbkxldmVsWyBpbmRleCBdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG5cbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgaWYoIGNhY2hlICl7XG4gICAgICBjYWNoZVsgbGF5ZXIubGV2ZWwgXSA9IGxheWVyO1xuICAgIH1cbiAgfVxuXG4gICAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG4gIHNlbGYucmVxdWVzdFJlZHJhdygpO1xufTtcblxuTFRDcC5yZXF1ZXN0UmVkcmF3ID0gdXRpbC5kZWJvdW5jZSggZnVuY3Rpb24oKXtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDAgKTtcblxuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICBkZXFDb3N0OiBkZXFDb3N0LFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gIGRlcTogZnVuY3Rpb24oIHNlbGYsIHB4UmF0aW8gKXtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKCBweFJhdGlvICk7XG4gIH0sXG4gIG9uRGVxZDogdXRpbC5ub29wLFxuICBzaG91bGRSZWRyYXc6IHV0aWwudHJ1ZWlmeSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uKCBzZWxmICl7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJEZXE7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheWVyZWRUZXh0dXJlQ2FjaGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiggbmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzICl7XG4gIHN3aXRjaCggbmFtZSApe1xuICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyApO1xuICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnICk7XG5cbnZhciBmdWxsRnBzVGltZSA9IDEwMDAvNjA7IC8vIGFzc3VtZSA2MCBmcmFtZXMgcGVyIHNlY29uZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0dXBEZXF1ZXVlaW5nOiBmdW5jdGlvbiggb3B0cyApe1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmdJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgIGlmKCBzZWxmLmRlcXVldWVpbmdTZXR1cCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKCl7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2VsZXMnLCB0cnVlICk7XG4gICAgICAgIHIucmVkcmF3SGludCggJ2RyYWcnLCB0cnVlICk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIG9wdHMuZGVxUmVkcmF3VGhyZXNob2xkICk7XG5cbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24oIHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSApe1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICB2YXIgYXZnUmVuZGVyVGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWU7XG4gICAgICAgIHZhciByZW5kZXJUaW1lID0gci5sYXN0UmVkcmF3VGltZTtcbiAgICAgICAgdmFyIGRlcWQgPSBbXTtcbiAgICAgICAgdmFyIGV4dGVudCA9IHIuY3kuZXh0ZW50KCk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgd2hpbGUoIHRydWUgKXtcbiAgICAgICAgICB2YXIgbm93ID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuXG4gICAgICAgICAgaWYoIHJlbmRlclRpbWUgPCBmdWxsRnBzVGltZSApe1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgcmVuZGVyaW5nIGZhc3RlciB0aGFuIHRoZSBpZGVhbCBmcHMsIHRoZW4gZG8gZGVxdWV1ZWluZ1xuICAgICAgICAgICAgLy8gZHVyaW5nIGFsbCBvZiB0aGUgcmVtYWluaW5nIGZyYW1lIHRpbWVcblxuICAgICAgICAgICAgdmFyIHRpbWVBdmFpbGFibGUgPSBmdWxsRnBzVGltZSAtICggd2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCApO1xuXG4gICAgICAgICAgICBpZiggZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcUZhc3RDb3N0ICogdGltZUF2YWlsYWJsZSApe1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIHdpbGxEcmF3ICl7XG4gICAgICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWVcbiAgICAgICAgICAgICAgICB8fCBkdXJhdGlvbiA+PSBvcHRzLmRlcUF2Z0Nvc3QgKiBhdmdSZW5kZXJUaW1lXG4gICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiggZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcU5vRHJhd0Nvc3QgKiBmdWxsRnBzVGltZSApe1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcSggc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50ICk7XG5cbiAgICAgICAgICBpZiggdGhpc0RlcWQubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzRGVxZC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICBkZXFkLnB1c2goIHRoaXNEZXFkW2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG4gICAgICAgIGlmKCBkZXFkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBvcHRzLm9uRGVxZCggc2VsZiwgZGVxZCApO1xuXG4gICAgICAgICAgaWYoICF3aWxsRHJhdyAmJiBvcHRzLnNob3VsZFJlZHJhdyggc2VsZiwgZGVxZCwgcGl4ZWxSYXRpbywgZXh0ZW50ICkgKXtcbiAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJpb3JpdHkgPSBvcHRzLnByaW9yaXR5IHx8IHV0aWwubm9vcDtcblxuICAgICAgci5iZWZvcmVSZW5kZXIoIGRlcXVldWUsIHByaW9yaXR5KCBzZWxmICkgKTtcbiAgICB9O1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyBuYW1lOiAnbnVsbCcsIGltcGw6IHJlcXVpcmUoICcuL251bGwnICkgfSxcbiAgeyBuYW1lOiAnYmFzZScsIGltcGw6IHJlcXVpcmUoICcuL2Jhc2UnICkgfSxcbiAgeyBuYW1lOiAnY2FudmFzJywgaW1wbDogcmVxdWlyZSggJy4vY2FudmFzJyApIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIE51bGxSZW5kZXJlciggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAwOyAvLyBmb3IgdGVzdGluZ1xufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuTnVsbFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBub29wLFxuICBub3RpZnk6IGZ1bmN0aW9uKCl7IHRoaXMubm90aWZpY2F0aW9ucysrOyB9LFxuICBpbml0OiBub29wXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxSZW5kZXJlcjtcbiIsIi8qISBXZWF2ZXIgbGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL3RsZHJsZWdhbC5jb20vbGljZW5zZS9taXQtbGljZW5zZSksIGNvcHlyaWdodCBNYXggRnJhbnogKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4vdGhyZWFkJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJy4vZGVmaW5lJyk7XG5cbnZhciBGYWJyaWMgPSBmdW5jdGlvbiggTiApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgRmFicmljKSApe1xuICAgIHJldHVybiBuZXcgRmFicmljKCBOICk7XG4gIH1cblxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIHBhc3M6IFtdXG4gIH07XG5cbiAgdmFyIGRlZk4gPSA0O1xuXG4gIGlmKCBpcy5udW1iZXIoTikgKXtcbiAgICAvLyB0aGVuIHVzZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aHJlYWRzXG4gIH0gaWYoIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5ICE9IG51bGwgKXtcbiAgICBOID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gIH0gZWxzZSB7XG4gICAgdHJ5e1xuICAgICAgTiA9IHJlcXVpcmUoJ29zJykuY3B1cygpLmxlbmd0aDtcbiAgICB9IGNhdGNoKCBlcnIgKXtcbiAgICAgIE4gPSBkZWZOO1xuICAgIH1cbiAgfSAvLyBUT0RPIGNvdWxkIHVzZSBhbiBlc3RpbWF0aW9uIGhlcmUgYnV0IHdvdWxkIHRoZSBhZGRpdGlvbmFsIGV4cGVuc2UgYmUgd29ydGggaXQ/XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBOOyBpKysgKXtcbiAgICB0aGlzW2ldID0gbmV3IFRocmVhZCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBOO1xufTtcblxudmFyIGZhYmZuID0gRmFicmljLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudXRpbC5leHRlbmQoZmFiZm4sIHtcblxuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuICdmYWJyaWMnOyB9LFxuXG4gIC8vIHJlcXVpcmUgZm4gaW4gYWxsIHRocmVhZHNcbiAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5yZXF1aXJlKCBmbiwgYXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBnZXQgYSByYW5kb20gdGhyZWFkXG4gIHJhbmRvbTogZnVuY3Rpb24oKXtcbiAgICB2YXIgaSA9IE1hdGgucm91bmQoICh0aGlzLmxlbmd0aCAtIDEpICogTWF0aC5yYW5kb20oKSApO1xuICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfSxcblxuICAvLyBydW4gb24gcmFuZG9tIHRocmVhZFxuICBydW46IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzICkucnVuKCBmbiApO1xuICB9LFxuXG4gIC8vIHNlbmRzIGEgcmFuZG9tIHRocmVhZCBhIG1lc3NhZ2VcbiAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5tZXNzYWdlKCBtICk7XG4gIH0sXG5cbiAgLy8gc2VuZCBhbGwgdGhyZWFkcyBhIG1lc3NhZ2VcbiAgYnJvYWRjYXN0OiBmdW5jdGlvbiggbSApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5tZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gc3RvcCBhbGwgdGhyZWFkc1xuICBzdG9wOiBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcGFzcyBkYXRhIHRvIGJlIHVzZWQgd2l0aCAuc3ByZWFkKCkgZXRjLlxuICBwYXNzOiBmdW5jdGlvbiggZGF0YSApe1xuICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzO1xuXG4gICAgaWYoIGlzLmFycmF5KGRhdGEpICl7XG4gICAgICBwYXNzLnB1c2goIGRhdGEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ09ubHkgYXJyYXlzIG1heSBiZSB1c2VkIHdpdGggZmFicmljLnBhc3MoKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc3ByZWFkU2l6ZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgc3Vic2l6ZSA9ICBNYXRoLmNlaWwoIHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGggLyB0aGlzLmxlbmd0aCApO1xuXG4gICAgc3Vic2l6ZSA9IE1hdGgubWF4KCAxLCBzdWJzaXplICk7IC8vIGRvbid0IHBhc3MgbGVzcyB0aGFuIG9uZSBlbGUgdG8gZWFjaCB0aHJlYWRcblxuICAgIHJldHVybiBzdWJzaXplO1xuICB9LFxuXG4gIC8vIHNwbGl0IHRoZSBkYXRhIGludG8gc2xpY2VzIHRvIHNwcmVhZCB0aGUgZGF0YSBlcXVhbGx5IGFtb25nIHRocmVhZHNcbiAgc3ByZWFkOiBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICB2YXIgc3Vic2l6ZSA9IHNlbGYuc3ByZWFkU2l6ZSgpOyAvLyBudW1iZXIgb2YgcGFzcyBlbGVzIHRvIGhhbmRsZSBpbiBlYWNoIHRocmVhZFxuICAgIHZhciBwYXNzID0gX3AucGFzcy5zaGlmdCgpLmNvbmNhdChbXSk7IC8vIGtlZXAgYSBjb3B5XG4gICAgdmFyIHJ1blBzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNsaWNlID0gcGFzcy5zcGxpY2UoIDAsIHN1YnNpemUgKTtcblxuICAgICAgdmFyIHJ1blAgPSB0aHJlYWQucGFzcyggc2xpY2UgKS5ydW4oIGZuICk7XG5cbiAgICAgIHJ1blBzLnB1c2goIHJ1blAgKTtcblxuICAgICAgdmFyIGRvbmVFYXJseSA9IHBhc3MubGVuZ3RoID09PSAwO1xuICAgICAgaWYoIGRvbmVFYXJseSApeyBicmVhazsgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbCggcnVuUHMgKS50aGVuKGZ1bmN0aW9uKCB0aGVucyApe1xuICAgICAgdmFyIHBvc3RwYXNzID0gW107XG4gICAgICB2YXIgcCA9IDA7XG5cbiAgICAgIC8vIGZpbGwgcG9zdHBhc3Mgd2l0aCB0aGUgdG90YWwgcmVzdWx0IGpvaW5lZCBmcm9tIGFsbCB0aHJlYWRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoZW5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aGVuID0gdGhlbnNbaV07IC8vIGFycmF5IHJlc3VsdCBmcm9tIHRocmVhZCBpXG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCB0aGVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHQgPSB0aGVuW2pdOyAvLyBhcnJheSBlbGVtZW50XG5cbiAgICAgICAgICBwb3N0cGFzc1sgcCsrIF0gPSB0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3N0cGFzcztcbiAgICB9KTtcbiAgfSxcblxuICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5Lm1hcCgpXG4gIG1hcDogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5yZXF1aXJlKCBmbiwgJ18kXyRfZmFibWFwJyApO1xuXG4gICAgcmV0dXJuIHNlbGYuc3ByZWFkKGZ1bmN0aW9uKCBzcGxpdCApe1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgIHJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICBtYXBwZWQucHVzaCggdmFsICk7XG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvbGRMZW4gPSBtYXBwZWQubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gXyRfJF9mYWJtYXAoIHNwbGl0W2ldICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB2YXIgbm90aGluZ0luc2RCeVJlc29sdmUgPSBvbGRMZW4gPT09IG1hcHBlZC5sZW5ndGg7XG5cbiAgICAgICAgaWYoIG5vdGhpbmdJbnNkQnlSZXNvbHZlICl7XG4gICAgICAgICAgbWFwcGVkLnB1c2goIHJldCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUgPSBvcmlnUmVzb2x2ZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG5cbiAgfSxcblxuICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5LmZpbHRlcigpXG4gIGZpbHRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgcGFzcyA9IF9wLnBhc3NbMF07XG5cbiAgICByZXR1cm4gdGhpcy5tYXAoIGZuICkudGhlbihmdW5jdGlvbiggaW5jbHVkZSApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRhdHVtID0gcGFzc1tpXTtcbiAgICAgICAgdmFyIGluY0RhdHVtID0gaW5jbHVkZVtpXTtcblxuICAgICAgICBpZiggaW5jRGF0dW0gKXtcbiAgICAgICAgICByZXQucHVzaCggZGF0dW0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHNvcnRzIHRoZSBwYXNzZWQgYXJyYXkgdXNpbmcgYSBkaXZpZGUgYW5kIGNvbnF1ZXIgc3RyYXRlZ3lcbiAgc29ydDogZnVuY3Rpb24oIGNtcCApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgUCA9IHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGg7XG4gICAgdmFyIHN1YnNpemUgPSB0aGlzLnNwcmVhZFNpemUoKTtcblxuICAgIGNtcCA9IGNtcCB8fCBmdW5jdGlvbiggYSwgYiApeyAvLyBkZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgIGlmKCBhIDwgYiApe1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYoIGEgPiBiICl7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1aXJlKCBjbXAsICdfJF8kX2NtcCcgKTtcblxuICAgIHJldHVybiBzZWxmLnNwcmVhZChmdW5jdGlvbiggc3BsaXQgKXsgLy8gc29ydCBlYWNoIHNwbGl0IG5vcm1hbGx5XG4gICAgICB2YXIgc29ydGVkU3BsaXQgPSBzcGxpdC5zb3J0KCBfJF8kX2NtcCApOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHJlc29sdmUoIHNvcnRlZFNwbGl0ICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgfSkudGhlbihmdW5jdGlvbiggam9pbmVkICl7XG4gICAgICAvLyBkbyBhbGwgdGhlIG1lcmdpbmcgaW4gdGhlIG1haW4gdGhyZWFkIHRvIG1pbmltaXNlIGRhdGEgdHJhbnNmZXJcblxuICAgICAgLy8gVE9ETyBjb3VsZCBkbyBtZXJnaW5nIGluIHNlcGFyYXRlIHRocmVhZHMgYnV0IHdvdWxkIGluY3VyIGFkZCdsIGNvc3Qgb2YgZGF0YSB0cmFuc2ZlclxuICAgICAgLy8gZm9yIGVhY2ggbGV2ZWwgb2YgdGhlIG1lcmdlXG5cbiAgICAgIHZhciBtZXJnZSA9IGZ1bmN0aW9uKCBpLCBqLCBtYXggKXtcbiAgICAgICAgLy8gZG9uJ3Qgb3ZlcmZsb3cgYXJyYXlcbiAgICAgICAgaiA9IE1hdGgubWluKCBqLCBQICk7XG4gICAgICAgIG1heCA9IE1hdGgubWluKCBtYXgsIFAgKTtcblxuICAgICAgICAvLyBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiBtZXJnZVxuICAgICAgICB2YXIgbCA9IGk7XG4gICAgICAgIHZhciByID0gajtcblxuICAgICAgICB2YXIgc29ydGVkID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgayA9IGw7IGsgPCBtYXg7IGsrKyApe1xuXG4gICAgICAgICAgdmFyIGVsZUkgPSBqb2luZWRbaV07XG4gICAgICAgICAgdmFyIGVsZUogPSBqb2luZWRbal07XG5cbiAgICAgICAgICBpZiggaSA8IHIgJiYgKCBqID49IG1heCB8fCBjbXAoZWxlSSwgZWxlSikgPD0gMCApICl7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaCggZWxlSSApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaCggZWxlSiApO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gdGhlIGFycmF5IHByb3BlciwgcHV0IHRoZSBzb3J0ZWQgdmFsdWVzXG4gICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrICl7IC8vIGt0aCBzb3J0ZWQgaXRlbVxuICAgICAgICAgIHZhciBpbmRleCA9IGwgKyBrO1xuXG4gICAgICAgICAgam9pbmVkWyBpbmRleCBdID0gc29ydGVkW2tdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBzcGxpdEwgPSBzdWJzaXplOyBzcGxpdEwgPCBQOyBzcGxpdEwgKj0gMiApeyAvLyBtZXJnZSB1bnRpbCBhcnJheSBpcyBcInNwbGl0XCIgYXMgMVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgUDsgaSArPSAyKnNwbGl0TCApe1xuICAgICAgICAgIG1lcmdlKCBpLCBpICsgc3BsaXRMLCBpICsgMipzcGxpdEwgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfSk7XG4gIH1cblxuXG59KTtcblxudmFyIGRlZmluZVJhbmRvbVBhc3NlciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiggZm4sIGFyZzEgKXtcbiAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgcmV0dXJuIHRoaXMucmFuZG9tKCkucGFzcyggcGFzcyApWyBvcHRzLnRocmVhZEZuIF0oIGZuLCBhcmcxICk7XG4gIH07XG59O1xuXG51dGlsLmV4dGVuZChmYWJmbiwge1xuICByYW5kb21NYXA6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAnbWFwJyB9KSxcblxuICByZWR1Y2U6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAncmVkdWNlJyB9KSxcblxuICByZWR1Y2VSaWdodDogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdyZWR1Y2VSaWdodCcgfSlcbn0pO1xuXG4vLyBhbGlhc2VzXG52YXIgZm4gPSBmYWJmbjtcbmZuLnByb21pc2UgPSBmbi5ydW47XG5mbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbmZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4vLyBwdWxsIGluIGV2ZW50IGFwaXNcbnV0aWwuZXh0ZW5kKGZhYmZuLCB7XG4gIG9uOiBkZWZpbmUub24oKSxcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSxcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKVxufSk7XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbiggZmFiZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWJyaWM7XG4iLCIvKiFcblBvcnRlZCBieSBYdWVxaWFvIFh1IDx4dWVxaWFveHVAZ21haWwuY29tPjtcblxuUFNGIExJQ0VOU0UgQUdSRUVNRU5UIEZPUiBQWVRIT04gMi43LjJcblxuMS4gVGhpcyBMSUNFTlNFIEFHUkVFTUVOVCBpcyBiZXR3ZWVuIHRoZSBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbiAo4oCcUFNG4oCdKSwgYW5kIHRoZSBJbmRpdmlkdWFsIG9yIE9yZ2FuaXphdGlvbiAo4oCcTGljZW5zZWXigJ0pIGFjY2Vzc2luZyBhbmQgb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiBzb2Z0d2FyZSBpbiBzb3VyY2Ugb3IgYmluYXJ5IGZvcm0gYW5kIGl0cyBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24uXG4yLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LCBQU0YgaGVyZWJ5IGdyYW50cyBMaWNlbnNlZSBhIG5vbmV4Y2x1c2l2ZSwgcm95YWx0eS1mcmVlLCB3b3JsZC13aWRlIGxpY2Vuc2UgdG8gcmVwcm9kdWNlLCBhbmFseXplLCB0ZXN0LCBwZXJmb3JtIGFuZC9vciBkaXNwbGF5IHB1YmxpY2x5LCBwcmVwYXJlIGRlcml2YXRpdmUgd29ya3MsIGRpc3RyaWJ1dGUsIGFuZCBvdGhlcndpc2UgdXNlIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uLCBwcm92aWRlZCwgaG93ZXZlciwgdGhhdCBQU0bigJlzIExpY2Vuc2UgQWdyZWVtZW50IGFuZCBQU0bigJlzIG5vdGljZSBvZiBjb3B5cmlnaHQsIGkuZS4sIOKAnENvcHlyaWdodCDCqSAyMDAxLTIwMTIgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWTigJ0gYXJlIHJldGFpbmVkIGluIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uIHByZXBhcmVkIGJ5IExpY2Vuc2VlLlxuMy4gSW4gdGhlIGV2ZW50IExpY2Vuc2VlIHByZXBhcmVzIGEgZGVyaXZhdGl2ZSB3b3JrIHRoYXQgaXMgYmFzZWQgb24gb3IgaW5jb3Jwb3JhdGVzIFB5dGhvbiAyLjcuMiBvciBhbnkgcGFydCB0aGVyZW9mLCBhbmQgd2FudHMgdG8gbWFrZSB0aGUgZGVyaXZhdGl2ZSB3b3JrIGF2YWlsYWJsZSB0byBvdGhlcnMgYXMgcHJvdmlkZWQgaGVyZWluLCB0aGVuIExpY2Vuc2VlIGhlcmVieSBhZ3JlZXMgdG8gaW5jbHVkZSBpbiBhbnkgc3VjaCB3b3JrIGEgYnJpZWYgc3VtbWFyeSBvZiB0aGUgY2hhbmdlcyBtYWRlIHRvIFB5dGhvbiAyLjcuMi5cbjQuIFBTRiBpcyBtYWtpbmcgUHl0aG9uIDIuNy4yIGF2YWlsYWJsZSB0byBMaWNlbnNlZSBvbiBhbiDigJxBUyBJU+KAnSBiYXNpcy4gUFNGIE1BS0VTIE5PIFJFUFJFU0VOVEFUSU9OUyBPUiBXQVJSQU5USUVTLCBFWFBSRVNTIE9SIElNUExJRUQuIEJZIFdBWSBPRiBFWEFNUExFLCBCVVQgTk9UIExJTUlUQVRJT04sIFBTRiBNQUtFUyBOTyBBTkQgRElTQ0xBSU1TIEFOWSBSRVBSRVNFTlRBVElPTiBPUiBXQVJSQU5UWSBPRiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQU5ZIFBBUlRJQ1VMQVIgUFVSUE9TRSBPUiBUSEFUIFRIRSBVU0UgT0YgUFlUSE9OIDIuNy4yIFdJTEwgTk9UIElORlJJTkdFIEFOWSBUSElSRCBQQVJUWSBSSUdIVFMuXG41LiBQU0YgU0hBTEwgTk9UIEJFIExJQUJMRSBUTyBMSUNFTlNFRSBPUiBBTlkgT1RIRVIgVVNFUlMgT0YgUFlUSE9OIDIuNy4yIEZPUiBBTlkgSU5DSURFTlRBTCwgU1BFQ0lBTCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIExPU1MgQVMgQSBSRVNVTFQgT0YgTU9ESUZZSU5HLCBESVNUUklCVVRJTkcsIE9SIE9USEVSV0lTRSBVU0lORyBQWVRIT04gMi43LjIsIE9SIEFOWSBERVJJVkFUSVZFIFRIRVJFT0YsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgVEhFUkVPRi5cbjYuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZSB1cG9uIGEgbWF0ZXJpYWwgYnJlYWNoIG9mIGl0cyB0ZXJtcyBhbmQgY29uZGl0aW9ucy5cbjcuIE5vdGhpbmcgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBzaGFsbCBiZSBkZWVtZWQgdG8gY3JlYXRlIGFueSByZWxhdGlvbnNoaXAgb2YgYWdlbmN5LCBwYXJ0bmVyc2hpcCwgb3Igam9pbnQgdmVudHVyZSBiZXR3ZWVuIFBTRiBhbmQgTGljZW5zZWUuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgUFNGIHRyYWRlbWFya3Mgb3IgdHJhZGUgbmFtZSBpbiBhIHRyYWRlbWFyayBzZW5zZSB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgb3Igc2VydmljZXMgb2YgTGljZW5zZWUsIG9yIGFueSB0aGlyZCBwYXJ0eS5cbjguIEJ5IGNvcHlpbmcsIGluc3RhbGxpbmcgb3Igb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiwgTGljZW5zZWUgYWdyZWVzIHRvIGJlIGJvdW5kIGJ5IHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuXG52YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbmZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuLypcbkRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gKi9cblxuZGVmYXVsdENtcCA9IGZ1bmN0aW9uKCB4LCB5ICl7XG4gIGlmKCB4IDwgeSApe1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiggeCA+IHkgKXtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuLypcbkluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG5cbklmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cblxuT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxub2YgYSB0byBiZSBzZWFyY2hlZC5cbiAqL1xuXG5pbnNvcnQgPSBmdW5jdGlvbiggYSwgeCwgbG8sIGhpLCBjbXAgKXtcbiAgdmFyIG1pZDtcbiAgaWYoIGxvID09IG51bGwgKXtcbiAgICBsbyA9IDA7XG4gIH1cbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBpZiggbG8gPCAwICl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCAnbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnICk7XG4gIH1cbiAgaWYoIGhpID09IG51bGwgKXtcbiAgICBoaSA9IGEubGVuZ3RoO1xuICB9XG4gIHdoaWxlKCBsbyA8IGhpICl7XG4gICAgbWlkID0gZmxvb3IoIChsbyArIGhpKSAvIDIgKTtcbiAgICBpZiggY21wKCB4LCBhWyBtaWQgXSApIDwgMCApe1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoIGEsIFsgbG8sIGxvIC0gbG8gXS5jb25jYXQoIHggKSApLCB4KTtcbn07XG5cblxuLypcblB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAqL1xuXG5oZWFwcHVzaCA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgYXJyYXkucHVzaCggaXRlbSApO1xuICByZXR1cm4gX3NpZnRkb3duKCBhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wICk7XG59O1xuXG5cbi8qXG5Qb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gKi9cblxuaGVhcHBvcCA9IGZ1bmN0aW9uKCBhcnJheSwgY21wICl7XG4gIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgaWYoIGFycmF5Lmxlbmd0aCApe1xuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgX3NpZnR1cCggYXJyYXksIDAsIGNtcCApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICB9XG4gIHJldHVybiByZXR1cm5pdGVtO1xufTtcblxuXG4vKlxuUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuXG5UaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbm1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxucmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxudGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAqL1xuXG5oZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIHZhciByZXR1cm5pdGVtO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgYXJyYXlbMF0gPSBpdGVtO1xuICBfc2lmdHVwKCBhcnJheSwgMCwgY21wICk7XG4gIHJldHVybiByZXR1cm5pdGVtO1xufTtcblxuXG4vKlxuRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICovXG5cbmhlYXBwdXNocG9wID0gZnVuY3Rpb24oIGFycmF5LCBpdGVtLCBjbXAgKXtcbiAgdmFyIF9yZWY7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgaWYoIGFycmF5Lmxlbmd0aCAmJiBjbXAoIGFycmF5WzBdLCBpdGVtICkgPCAwICl7XG4gICAgX3JlZiA9IFsgYXJyYXlbMF0sIGl0ZW0gXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICBfc2lmdHVwKCBhcnJheSwgMCwgY21wICk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbi8qXG5UcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICovXG5cbmhlYXBpZnkgPSBmdW5jdGlvbiggYXJyYXksIGNtcCApe1xuICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBfcmVmMSA9IChmdW5jdGlvbigpe1xuICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgIGZvciggdmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKCBhcnJheS5sZW5ndGggLyAyICk7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0gKXsgX3Jlc3VsdHMxLnB1c2goIF9qICk7IH1cbiAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICB9KS5hcHBseSggdGhpcyApLnJldmVyc2UoKTtcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yKCBfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKyApe1xuICAgIGkgPSBfcmVmMVsgX2kgXTtcbiAgICBfcmVzdWx0cy5wdXNoKCBfc2lmdHVwKCBhcnJheSwgaSwgY21wICkgKTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5cbi8qXG5VcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gKi9cblxudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKCBhcnJheSwgaXRlbSwgY21wICl7XG4gIHZhciBwb3M7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgcG9zID0gYXJyYXkuaW5kZXhPZiggaXRlbSApO1xuICBpZiggcG9zID09PSAtMSApe1xuICAgIHJldHVybjtcbiAgfVxuICBfc2lmdGRvd24oIGFycmF5LCAwLCBwb3MsIGNtcCApO1xuICByZXR1cm4gX3NpZnR1cCggYXJyYXksIHBvcywgY21wICk7XG59O1xuXG5cbi8qXG5GaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICovXG5cbm5sYXJnZXN0ID0gZnVuY3Rpb24oIGFycmF5LCBuLCBjbXAgKXtcbiAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gIGlmKCBjbXAgPT0gbnVsbCApe1xuICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gIH1cbiAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoIDAsIG4gKTtcbiAgaWYoICFyZXN1bHQubGVuZ3RoICl7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoZWFwaWZ5KCByZXN1bHQsIGNtcCApO1xuICBfcmVmID0gYXJyYXkuc2xpY2UoIG4gKTtcbiAgZm9yKCBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrICl7XG4gICAgZWxlbSA9IF9yZWZbIF9pIF07XG4gICAgaGVhcHB1c2hwb3AoIHJlc3VsdCwgZWxlbSwgY21wICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5zb3J0KCBjbXAgKS5yZXZlcnNlKCk7XG59O1xuXG5cbi8qXG5GaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAqL1xuXG5uc21hbGxlc3QgPSBmdW5jdGlvbiggYXJyYXksIG4sIGNtcCApe1xuICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGlmKCBuICogMTAgPD0gYXJyYXkubGVuZ3RoICl7XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoIDAsIG4gKS5zb3J0KCBjbXAgKTtcbiAgICBpZiggIXJlc3VsdC5sZW5ndGggKXtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxvcyA9IHJlc3VsdFsgcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZSggbiApO1xuICAgIGZvciggX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKyApe1xuICAgICAgZWxlbSA9IF9yZWZbIF9pIF07XG4gICAgICBpZiggY21wKCBlbGVtLCBsb3MgKSA8IDAgKXtcbiAgICAgICAgaW5zb3J0KCByZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCApO1xuICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgIGxvcyA9IHJlc3VsdFsgcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhlYXBpZnkoIGFycmF5LCBjbXAgKTtcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yKCBpID0gX2ogPSAwLCBfcmVmMSA9IG1pbiggbiwgYXJyYXkubGVuZ3RoICk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faiApe1xuICAgIF9yZXN1bHRzLnB1c2goIGhlYXBwb3AoIGFycmF5LCBjbXAgKSApO1xuICB9XG4gIHJldHVybiBfcmVzdWx0cztcbn07XG5cbl9zaWZ0ZG93biA9IGZ1bmN0aW9uKCBhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wICl7XG4gIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgaWYoIGNtcCA9PSBudWxsICl7XG4gICAgY21wID0gZGVmYXVsdENtcDtcbiAgfVxuICBuZXdpdGVtID0gYXJyYXlbIHBvcyBdO1xuICB3aGlsZSggcG9zID4gc3RhcnRwb3MgKXtcbiAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICBwYXJlbnQgPSBhcnJheVsgcGFyZW50cG9zIF07XG4gICAgaWYoIGNtcCggbmV3aXRlbSwgcGFyZW50ICkgPCAwICl7XG4gICAgICBhcnJheVsgcG9zIF0gPSBwYXJlbnQ7XG4gICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGFycmF5WyBwb3MgXSA9IG5ld2l0ZW07XG59O1xuXG5fc2lmdHVwID0gZnVuY3Rpb24oIGFycmF5LCBwb3MsIGNtcCApe1xuICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICBpZiggY21wID09IG51bGwgKXtcbiAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICB9XG4gIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgc3RhcnRwb3MgPSBwb3M7XG4gIG5ld2l0ZW0gPSBhcnJheVsgcG9zIF07XG4gIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gIHdoaWxlKCBjaGlsZHBvcyA8IGVuZHBvcyApe1xuICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgIGlmKCByaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcCggYXJyYXlbIGNoaWxkcG9zIF0sIGFycmF5WyByaWdodHBvcyBdICkgPCAwKSApe1xuICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICB9XG4gICAgYXJyYXlbIHBvcyBdID0gYXJyYXlbIGNoaWxkcG9zIF07XG4gICAgcG9zID0gY2hpbGRwb3M7XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgfVxuICBhcnJheVsgcG9zIF0gPSBuZXdpdGVtO1xuICByZXR1cm4gX3NpZnRkb3duKCBhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wICk7XG59O1xuXG5IZWFwID0gKGZ1bmN0aW9uKCl7XG4gIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gIGZ1bmN0aW9uIEhlYXAoIGNtcCApe1xuICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuXG4gIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiggeCApe1xuICAgIHJldHVybiBoZWFwcHVzaCggdGhpcy5ub2RlcywgeCwgdGhpcy5jbXAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBoZWFwcG9wKCB0aGlzLm5vZGVzLCB0aGlzLmNtcCApO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKCB4ICkgIT09IC0xO1xuICB9O1xuXG4gIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiggeCApe1xuICAgIHJldHVybiBoZWFwcmVwbGFjZSggdGhpcy5ub2RlcywgeCwgdGhpcy5jbXAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oIHggKXtcbiAgICByZXR1cm4gaGVhcHB1c2hwb3AoIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGhlYXBpZnkoIHRoaXMubm9kZXMsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKCB4ICl7XG4gICAgcmV0dXJuIHVwZGF0ZUl0ZW0oIHRoaXMubm9kZXMsIHgsIHRoaXMuY21wICk7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBoZWFwO1xuICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKCAwICk7XG4gICAgcmV0dXJuIGhlYXA7XG4gIH07XG5cbiAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoIDAgKTtcbiAgfTtcblxuICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICByZXR1cm4gSGVhcDtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLy1wcmVhbWJsZScpO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSggJy4vd2luZG93JyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgQ29yZSA9IHJlcXVpcmUoICcuL2NvcmUnICk7XG52YXIgZXh0ZW5zaW9uID0gcmVxdWlyZSggJy4vZXh0ZW5zaW9uJyApO1xudmFyIHJlZ2lzdGVySnF1ZXJ5ID0gcmVxdWlyZSggJy4vanF1ZXJ5LXBsdWdpbicgKTtcbnZhciBTdHlsZXNoZWV0ID0gcmVxdWlyZSggJy4vc3R5bGVzaGVldCcgKTtcbnZhciBUaHJlYWQgPSByZXF1aXJlKCAnLi90aHJlYWQnICk7XG52YXIgRmFicmljID0gcmVxdWlyZSggJy4vZmFicmljJyApO1xuXG52YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICl7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gY3JlYXRlIGluc3RhbmNlXG4gIGlmKCBpcy5wbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgcmV0dXJuIG5ldyBDb3JlKCBvcHRpb25zICk7XG4gIH1cblxuICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgZWxzZSBpZiggaXMuc3RyaW5nKCBvcHRpb25zICkgKXtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KCBleHRlbnNpb24sIGFyZ3VtZW50cyApO1xuICB9XG59O1xuXG4vLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cbmN5dG9zY2FwZS52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbi8vIHRyeSB0byByZWdpc3RlciB3LyBqcXVlcnlcbmlmKCB3aW5kb3cgJiYgd2luZG93LmpRdWVyeSApe1xuICByZWdpc3RlckpxdWVyeSggd2luZG93LmpRdWVyeSwgY3l0b3NjYXBlICk7XG59XG5cbi8vIGV4cG9zZSByZWdpc3RlciBhcGlcbmN5dG9zY2FwZS5yZWdpc3RlckpxdWVyeSA9IGZ1bmN0aW9uKCBqUXVlcnkgKXtcbiAgcmVnaXN0ZXJKcXVlcnkoIGpRdWVyeSwgY3l0b3NjYXBlICk7XG59O1xuXG4vLyBleHBvc2UgcHVibGljIGFwaXMgKG1vc3RseSBmb3IgZXh0ZW5zaW9ucylcbmN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xuY3l0b3NjYXBlLnRocmVhZCA9IGN5dG9zY2FwZS5UaHJlYWQgPSBUaHJlYWQ7XG5jeXRvc2NhcGUuZmFicmljID0gY3l0b3NjYXBlLkZhYnJpYyA9IEZhYnJpYztcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZ2xvYmFsIEhUTUxFbGVtZW50IERvY3VtZW50VG91Y2ggKi9cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoICcuL3dpbmRvdycgKTtcbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgPyB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbnZhciBkb2N1bWVudCA9IHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IG51bGw7XG5cbnZhciB0eXBlb2ZzdHIgPSB0eXBlb2YgJyc7XG52YXIgdHlwZW9mb2JqID0gdHlwZW9mIHt9O1xudmFyIHR5cGVvZmZuID0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50O1xuXG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiggb2JqICl7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGlzLmZuKCBvYmouaW5zdGFuY2VTdHJpbmcgKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBpcyA9IHtcbiAgZGVmaW5lZDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbDsgLy8gbm90IHVuZGVmaW5lZCBvciBudWxsXG4gIH0sXG5cbiAgc3RyaW5nOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mc3RyO1xuICB9LFxuXG4gIGZuOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZmZuO1xuICB9LFxuXG4gIGFycmF5OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KCBvYmogKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICB9LFxuXG4gIHBsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZm9iaiAmJiAhaXMuYXJyYXkoIG9iaiApICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9LFxuXG4gIG9iamVjdDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmo7XG4gIH0sXG5cbiAgbnVtYmVyOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAxICYmICFpc05hTiggb2JqICk7XG4gIH0sXG5cbiAgaW50ZWdlcjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5udW1iZXIoIG9iaiApICYmIE1hdGguZmxvb3IoIG9iaiApID09PSBvYmo7XG4gIH0sXG5cbiAgYm9vbDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgdHJ1ZTtcbiAgfSxcblxuICBodG1sRWxlbWVudDogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSApe1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBlbGVtZW50T3JDb2xsZWN0aW9uOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGlzLmVsZW1lbnQoIG9iaiApIHx8IGlzLmNvbGxlY3Rpb24oIG9iaiApO1xuICB9LFxuXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnY29sbGVjdGlvbicgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfSxcblxuICBjb2xsZWN0aW9uOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKCBvYmogKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9LFxuXG4gIGNvcmU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnY29yZSc7XG4gIH0sXG5cbiAgc3R5bGU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnc3R5bGUnO1xuICB9LFxuXG4gIHN0eWxlc2hlZXQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnc3R5bGVzaGVldCc7XG4gIH0sXG5cbiAgZXZlbnQ6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIoIG9iaiApID09PSAnZXZlbnQnO1xuICB9LFxuXG4gIHRocmVhZDogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpbnN0YW5jZVN0ciggb2JqICkgPT09ICd0aHJlYWQnO1xuICB9LFxuXG4gIGZhYnJpYzogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpbnN0YW5jZVN0ciggb2JqICkgPT09ICdmYWJyaWMnO1xuICB9LFxuXG4gIGVtcHR5U3RyaW5nOiBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCApeyAvLyBudWxsIGlzIGVtcHR5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYoIG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKCAvXlxccyskLyApICl7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3RcbiAgfSxcblxuICBub25lbXB0eVN0cmluZzogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCBvYmogJiYgaXMuc3RyaW5nKCBvYmogKSAmJiBvYmogIT09ICcnICYmICFvYmoubWF0Y2goIC9eXFxzKyQvICkgKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBkb21FbGVtZW50OiBmdW5jdGlvbiggb2JqICl7XG4gICAgaWYoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9LFxuXG4gIGJvdW5kaW5nQm94OiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGlzLnBsYWluT2JqZWN0KCBvYmogKSAmJlxuICAgICAgaXMubnVtYmVyKCBvYmoueDEgKSAmJiBpcy5udW1iZXIoIG9iai54MiApICYmXG4gICAgICBpcy5udW1iZXIoIG9iai55MSApICYmIGlzLm51bWJlciggb2JqLnkyIClcbiAgICA7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiBpcy5vYmplY3QoIG9iaiApICYmIGlzLmZuKCBvYmoudGhlbiApO1xuICB9LFxuXG4gIHRvdWNoOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgfSxcblxuICBnZWNrbzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93ICYmICggdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgKTtcbiAgfSxcblxuICB3ZWJraXQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiAoIHR5cGVvZiB3ZWJraXRVUkwgIT09ICd1bmRlZmluZWQnIHx8ICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSApO1xuICB9LFxuXG4gIGNocm9taXVtOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCB0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyApO1xuICB9LFxuXG4gIGtodG1sOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnZlbmRvci5tYXRjaCggL2tkZS9pICk7IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICB9LFxuXG4gIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBpcy5raHRtbCgpIHx8IGlzLndlYmtpdCgpIHx8IGlzLmNocm9taXVtKCk7XG4gIH0sXG5cbiAgbXM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCAvbXNpZXx0cmlkZW50fGVkZ2UvaSApOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goIC9XaW4vaSApO1xuICB9LFxuXG4gIG1hYzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKCAvTWFjL2kgKTtcbiAgfSxcblxuICBsaW51eDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKCAvTGludXgvaSApO1xuICB9LFxuXG4gIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCggL1gxMS9pICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuL2lzJyApO1xuXG52YXIgY3lSZWcgPSBmdW5jdGlvbiggJGVsZSApe1xuICB2YXIgZCA9ICRlbGVbMF0uX2N5cmVnID0gJGVsZVswXS5fY3lyZWcgfHwge307XG5cbiAgcmV0dXJuIGQ7XG59O1xuXG52YXIgcmVnaXN0ZXJKcXVlcnkgPSBmdW5jdGlvbiggJCwgY3l0b3NjYXBlICl7XG4gIGlmKCAhJCApeyByZXR1cm47IH0gLy8gbm8ganF1ZXJ5ID0+IGRvbid0IG5lZWQgdGhpc1xuXG4gIGlmKCAkLmZuLmN5dG9zY2FwZSApeyByZXR1cm47IH0gLy8gYWxyZWFkeSByZWdpc3RlcmVkXG5cbiAgLy8gYWxsb3cgY2FsbHMgb24gYSBqUXVlcnkgc2VsZWN0b3IgYnkgcHJveHlpbmcgY2FsbHMgdG8gJC5jeXRvc2NhcGVcbiAgLy8gZS5nLiAkKFwiI2Zvb1wiKS5jeXRvc2NhcGUob3B0aW9ucykgPT4gJC5jeXRvc2NhcGUob3B0aW9ucykgb24gI2Zvb1xuICAkLmZuLmN5dG9zY2FwZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgdmFyICR0aGlzID0gJCggdGhpcyApO1xuXG4gICAgLy8gZ2V0IG9iamVjdFxuICAgIGlmKCBvcHRzID09PSAnZ2V0JyApe1xuICAgICAgcmV0dXJuIGN5UmVnKCAkdGhpcyApLmN5O1xuICAgIH1cblxuICAgIC8vIGJpbmQgdG8gcmVhZHlcbiAgICBlbHNlIGlmKCBpcy5mbiggb3B0cyApICl7XG5cbiAgICAgIHZhciByZWFkeSA9IG9wdHM7XG4gICAgICB2YXIgY3kgPSBjeVJlZyggJHRoaXMgKS5jeTtcblxuICAgICAgaWYoIGN5ICYmIGN5LmlzUmVhZHkoKSApeyAvLyBhbHJlYWR5IHJlYWR5IHNvIGp1c3QgdHJpZ2dlciBub3dcbiAgICAgICAgY3kudHJpZ2dlciggJ3JlYWR5JywgW10sIHJlYWR5ICk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG5vdCB5ZXQgcmVhZHksIHNvIGFkZCB0byByZWFkaWVzIGxpc3RcbiAgICAgICAgdmFyIGRhdGEgPSBjeVJlZyggJHRoaXMgKTtcbiAgICAgICAgdmFyIHJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgfHwgW107XG5cbiAgICAgICAgcmVhZGllcy5wdXNoKCByZWFkeSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcHJveHkgdG8gY3JlYXRlIGluc3RhbmNlXG4gICAgZWxzZSBpZiggaXMucGxhaW5PYmplY3QoIG9wdHMgKSApe1xuICAgICAgcmV0dXJuICR0aGlzLmVhY2goIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRzLCB7XG4gICAgICAgICAgY29udGFpbmVyOiAkKCB0aGlzIClbMF1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGN5dG9zY2FwZSggb3B0aW9ucyApO1xuICAgICAgfSApO1xuICAgIH1cbiAgfTtcblxuICAvLyBhbGxvdyBhY2Nlc3MgdG8gdGhlIGdsb2JhbCBjeXRvc2NhcGUgb2JqZWN0IHVuZGVyIGpxdWVyeSBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgJC5jeXRvc2NhcGUgPSBjeXRvc2NhcGU7XG5cbiAgLy8gdXNlIHNob3J0IGFsaWFzIChjeSkgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICBpZiggJC5mbi5jeSA9PSBudWxsICYmICQuY3kgPT0gbnVsbCApe1xuICAgICQuZm4uY3kgPSAkLmZuLmN5dG9zY2FwZTtcbiAgICAkLmN5ID0gJC5jeXRvc2NhcGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJKcXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0ge307XG5cbm1hdGguYXJlUG9zaXRpb25zU2FtZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn07XG5cbm1hdGguY29weVBvc2l0aW9uID0gZnVuY3Rpb24oIHAgKXtcbiAgcmV0dXJuIHsgeDogcC54LCB5OiBwLnkgfTtcbn07XG5cbm1hdGguYXJyYXkycG9pbnQgPSBmdW5jdGlvbiggYXJyICl7XG4gIHJldHVybiB7XG4gICAgeDogYXJyWzBdLFxuICAgIHk6IGFyclsxXVxuICB9O1xufTtcblxubWF0aC5kZWcycmFkID0gZnVuY3Rpb24oIGRlZyApe1xuICByZXR1cm4gTWF0aC5QSSAqIGRlZyAvIDE4MDtcbn07XG5cbm1hdGgubG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiggbiApe1xuICByZXR1cm4gTWF0aC5sb2coIG4gKSAvIE1hdGgubG9nKCAyICk7XG59O1xuXG5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uKCB4ICl7XG4gIGlmKCB4ID4gMCApe1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYoIHggPCAwICl7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5tYXRoLmRpc3QgPSBmdW5jdGlvbiggcDEsIHAyICl7XG4gIHJldHVybiBNYXRoLnNxcnQoIG1hdGguc3FkaXN0KCBwMSwgcDIgKSApO1xufTtcblxubWF0aC5zcWRpc3QgPSBmdW5jdGlvbiggcDEsIHAyICl7XG4gIHZhciBkeCA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkgPSBwMi55IC0gcDEueTtcblxuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG4vLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG5tYXRoLnFiZXppZXJBdCA9IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCB0ICl7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqIHAwICsgMiAqICgxIC0gdCkgKiB0ICogcDEgKyB0ICogdCAqIHAyO1xufTtcblxubWF0aC5xYmV6aWVyUHRBdCA9IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCB0ICl7XG4gIHJldHVybiB7XG4gICAgeDogbWF0aC5xYmV6aWVyQXQoIHAwLngsIHAxLngsIHAyLngsIHQgKSxcbiAgICB5OiBtYXRoLnFiZXppZXJBdCggcDAueSwgcDEueSwgcDIueSwgdCApXG4gIH07XG59O1xuXG5tYXRoLmxpbmVBdCA9IGZ1bmN0aW9uKCBwMCwgcDEsIHQsIGQgKXtcbiAgdmFyIHZlYyA9IHtcbiAgICB4OiBwMS54IC0gcDAueCxcbiAgICB5OiBwMS55IC0gcDAueVxuICB9O1xuXG4gIHZhciB2ZWNEaXN0ID0gbWF0aC5kaXN0KCBwMCwgcDEgKTtcblxuICB2YXIgbm9ybVZlYyA9IHtcbiAgICB4OiB2ZWMueCAvIHZlY0Rpc3QsXG4gICAgeTogdmVjLnkgLyB2ZWNEaXN0XG4gIH07XG5cbiAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuXG4gIHZhciBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuXG4gIHJldHVybiB7XG4gICAgeDogcDAueCArIG5vcm1WZWMueCAqIGQsXG4gICAgeTogcDAueSArIG5vcm1WZWMueSAqIGRcbiAgfTtcbn07XG5cbm1hdGgubGluZUF0RGlzdCA9IGZ1bmN0aW9uKCBwMCwgcDEsIGQgKXtcbiAgcmV0dXJuIG1hdGgubGluZUF0KCBwMCwgcDEsIHVuZGVmaW5lZCwgZCApO1xufTtcblxuLy8gZ2V0IGFuZ2xlIGF0IEEgdmlhIGNvc2luZSBsYXdcbm1hdGgudHJpYW5nbGVBbmdsZSA9IGZ1bmN0aW9uKCBBLCBCLCBDICl7XG4gIHZhciBhID0gbWF0aC5kaXN0KCBCLCBDICk7XG4gIHZhciBiID0gbWF0aC5kaXN0KCBBLCBDICk7XG4gIHZhciBjID0gbWF0aC5kaXN0KCBBLCBCICk7XG5cbiAgcmV0dXJuIE1hdGguYWNvcyggKGEqYSArIGIqYiAtIGMqYykvKDIqYSpiKSApO1xufTtcblxubWF0aC5ib3VuZCA9IGZ1bmN0aW9uKCBtaW4sIHZhbCwgbWF4ICl7XG4gIHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWwgKSApO1xufTtcblxuLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbm1hdGgubWFrZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiICl7XG4gIGlmKCBiYiA9PSBudWxsICl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgIHkxOiBJbmZpbml0eSxcbiAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICB5MjogLUluZmluaXR5LFxuICAgICAgdzogMCxcbiAgICAgIGg6IDBcbiAgICB9O1xuICB9IGVsc2UgaWYoIGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCApe1xuICAgIGlmKCBiYi54MiAhPSBudWxsICYmIGJiLnkyICE9IG51bGwgJiYgYmIueDIgPj0gYmIueDEgJiYgYmIueTIgPj0gYmIueTEgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDIsXG4gICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgdzogYmIueDIgLSBiYi54MSxcbiAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoIGJiLncgIT0gbnVsbCAmJiBiYi5oICE9IG51bGwgJiYgYmIudyA+PSAwICYmIGJiLmggPj0gMCApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgIHc6IGJiLncsXG4gICAgICAgIGg6IGJiLmhcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG5tYXRoLnVwZGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiMSwgYmIyICl7XG4gIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG5cbiAgYmIxLngxID0gTWF0aC5taW4oIGJiMS54MSwgYmIyLngxICk7XG4gIGJiMS54MiA9IE1hdGgubWF4KCBiYjEueDIsIGJiMi54MiApO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcblxuICBiYjEueTEgPSBNYXRoLm1pbiggYmIxLnkxLCBiYjIueTEgKTtcbiAgYmIxLnkyID0gTWF0aC5tYXgoIGJiMS55MiwgYmIyLnkyICk7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcblxubWF0aC5leHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgcGFkZGluZyApe1xuICBiYi54MSAtPSBwYWRkaW5nO1xuICBiYi54MiArPSBwYWRkaW5nO1xuICBiYi55MSAtPSBwYWRkaW5nO1xuICBiYi55MiArPSBwYWRkaW5nO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgcmV0dXJuIGJiO1xufTtcblxubWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24oIGJiMSwgYmIyICl7XG4gIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICBpZiggYmIxLngxID4gYmIyLngyICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLngxID4gYmIxLngyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gIGlmKCBiYjEueDIgPCBiYjIueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueDIgPCBiYjEueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gIGlmKCBiYjEueTIgPCBiYjIueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueTIgPCBiYjEueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gIGlmKCBiYjEueTEgPiBiYjIueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueTEgPiBiYjEueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gIHJldHVybiB0cnVlO1xufTtcblxubWF0aC5pbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCB4LCB5ICl7XG4gIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xufTtcblxubWF0aC5wb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHB0ICl7XG4gIHJldHVybiB0aGlzLmluQm91bmRpbmdCb3goIGJiLCBwdC54LCBwdC55ICk7XG59O1xuXG5tYXRoLmJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICByZXR1cm4gKFxuICAgICAgIG1hdGguaW5Cb3VuZGluZ0JveCggYmIxLCBiYjIueDEsIGJiMi55MSApXG4gICAgJiYgbWF0aC5pbkJvdW5kaW5nQm94KCBiYjEsIGJiMi54MiwgYmIyLnkyIClcbiAgKTtcbn07XG5cbm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24oXG4gIHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApe1xuXG4gIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuXG4gIC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSApO1xuXG4gICAgaWYoIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlICk7XG5cbiAgICBpZiggc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICl7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21TdGFydFgsIGJvdHRvbVN0YXJ0WSwgYm90dG9tRW5kWCwgYm90dG9tRW5kWSwgZmFsc2UgKTtcblxuICAgIGlmKCBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgKXtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICB7XG4gICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBsZWZ0U3RhcnRYLCBsZWZ0U3RhcnRZLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGZhbHNlICk7XG5cbiAgICBpZiggc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICl7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zO1xuXG4gIC8vIFRvcCBMZWZ0XG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSApe1xuICAgICAgcmV0dXJuIFsgYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXSBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRvcCBSaWdodFxuICB7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nICk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiggYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkgKXtcbiAgICAgIHJldHVybiBbIGFyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV0gXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gUmlnaHRcbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyApO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYoIGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZICl7XG4gICAgICByZXR1cm4gWyBhcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdIF07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIExlZnRcbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLFxuICAgICAgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nICk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiggYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZICl7XG4gICAgICByZXR1cm4gWyBhcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG59O1xuXG5tYXRoLmluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24oIHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlICl7XG4gIHZhciB0ID0gdG9sZXJhbmNlO1xuXG4gIHZhciB4MSA9IE1hdGgubWluKCBseDEsIGx4MiApO1xuICB2YXIgeDIgPSBNYXRoLm1heCggbHgxLCBseDIgKTtcbiAgdmFyIHkxID0gTWF0aC5taW4oIGx5MSwgbHkyICk7XG4gIHZhciB5MiA9IE1hdGgubWF4KCBseTEsIGx5MiApO1xuXG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdFxuICAgICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcblxubWF0aC5pbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24oXG4gIHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSApe1xuXG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oIHgxLCB4MywgeDIgKSAtIHRvbGVyYW5jZSxcbiAgICB4MjogTWF0aC5tYXgoIHgxLCB4MywgeDIgKSArIHRvbGVyYW5jZSxcbiAgICB5MTogTWF0aC5taW4oIHkxLCB5MywgeTIgKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoIHkxLCB5MywgeTIgKSArIHRvbGVyYW5jZVxuICB9O1xuXG4gIC8vIGlmIG91dHNpZGUgdGhlIHJvdWdoIGJvdW5kaW5nIGJveCBmb3IgdGhlIGJlemllciwgdGhlbiBpdCBjYW4ndCBiZSBhIGhpdFxuICBpZiggeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyICl7XG4gICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuXG5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbiggYSwgYiwgYywgZCwgcmVzdWx0ICl7XG5cbiAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgLy8gciBpcyB0aGUgcmVhbCBjb21wb25lbnQsIGkgaXMgdGhlIGltYWdpbmFyeSBjb21wb25lbnRcblxuICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcblxuICBiIC89IGE7XG4gIGMgLz0gYTtcbiAgZCAvPSBhO1xuXG4gIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG5cbiAgcSA9ICgzLjAgKiBjIC0gKGIgKiBiKSkgLyA5LjA7XG4gIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICByIC89IDU0LjA7XG5cbiAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHRlcm0xID0gKGIgLyAzLjApO1xuXG4gIGlmKCBkaXNjcmltaW5hbnQgPiAwICl7XG4gICAgcyA9IHIgKyBNYXRoLnNxcnQoIGRpc2NyaW1pbmFudCApO1xuICAgIHMgPSAoKHMgPCAwKSA/IC1NYXRoLnBvdyggLXMsICgxLjAgLyAzLjApICkgOiBNYXRoLnBvdyggcywgKDEuMCAvIDMuMCkgKSk7XG4gICAgdCA9IHIgLSBNYXRoLnNxcnQoIGRpc2NyaW1pbmFudCApO1xuICAgIHQgPSAoKHQgPCAwKSA/IC1NYXRoLnBvdyggLXQsICgxLjAgLyAzLjApICkgOiBNYXRoLnBvdyggdCwgKDEuMCAvIDMuMCkgKSk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgdGVybTEgPSBNYXRoLnNxcnQoIDMuMCApICogKC10ICsgcykgLyAyO1xuICAgIHJlc3VsdFszXSA9IHRlcm0xO1xuICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXN1bHRbNV0gPSByZXN1bHRbM10gPSAwO1xuXG4gIGlmKCBkaXNjcmltaW5hbnQgPT09IDAgKXtcbiAgICByMTMgPSAoKHIgPCAwKSA/IC1NYXRoLnBvdyggLXIsICgxLjAgLyAzLjApICkgOiBNYXRoLnBvdyggciwgKDEuMCAvIDMuMCkgKSk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgMi4wICogcjEzO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHEgPSAtcTtcbiAgZHVtMSA9IHEgKiBxICogcTtcbiAgZHVtMSA9IE1hdGguYWNvcyggciAvIE1hdGguc3FydCggZHVtMSApICk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydCggcSApO1xuICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyggZHVtMSAvIDMuMCApO1xuICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyggKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyggKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCApO1xuXG4gIHJldHVybjtcbn07XG5cbm1hdGguc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihcbiAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyApe1xuXG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcblxuICB2YXIgYSA9IDEuMCAqIHgxICogeDEgLSA0ICogeDEgKiB4MiArIDIgKiB4MSAqIHgzICsgNCAqIHgyICogeDIgLSA0ICogeDIgKiB4MyArIHgzICogeDNcbiAgICArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG5cbiAgdmFyIGIgPSAxLjAgKiA5ICogeDEgKiB4MiAtIDMgKiB4MSAqIHgxIC0gMyAqIHgxICogeDMgLSA2ICogeDIgKiB4MiArIDMgKiB4MiAqIHgzXG4gICAgKyA5ICogeTEgKiB5MiAtIDMgKiB5MSAqIHkxIC0gMyAqIHkxICogeTMgLSA2ICogeTIgKiB5MiArIDMgKiB5MiAqIHkzO1xuXG4gIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHhcbiAgICArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuXG4gIHZhciBkID0gMS4wICogeDEgKiB4MiAtIHgxICogeDEgKyB4MSAqIHggLSB4MiAqIHhcbiAgICArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5O1xuXG4gIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTtcblxuICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gIHRoaXMuc29sdmVDdWJpYyggYSwgYiwgYywgZCwgcm9vdHMgKTtcblxuICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcblxuICB2YXIgcGFyYW1zID0gW107XG5cbiAgZm9yKCB2YXIgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4ICs9IDIgKXtcbiAgICBpZiggTWF0aC5hYnMoIHJvb3RzWyBpbmRleCArIDFdICkgPCB6ZXJvVGhyZXNob2xkXG4gICAgICAgICYmIHJvb3RzWyBpbmRleCBdID49IDBcbiAgICAgICAgJiYgcm9vdHNbIGluZGV4IF0gPD0gMS4wICl7XG4gICAgICBwYXJhbXMucHVzaCggcm9vdHNbIGluZGV4IF0gKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMucHVzaCggMS4wICk7XG4gIHBhcmFtcy5wdXNoKCAwLjAgKTtcblxuICB2YXIgbWluRGlzdGFuY2VTcXVhcmVkID0gLTE7XG4gIHZhciBjbG9zZXN0UGFyYW07XG5cbiAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKyApe1xuICAgIGN1clggPSBNYXRoLnBvdyggMS4wIC0gcGFyYW1zWyBpIF0sIDIuMCApICogeDFcbiAgICAgICsgMi4wICogKDEgLSBwYXJhbXNbIGkgXSkgKiBwYXJhbXNbIGkgXSAqIHgyXG4gICAgICArIHBhcmFtc1sgaSBdICogcGFyYW1zWyBpIF0gKiB4MztcblxuICAgIGN1clkgPSBNYXRoLnBvdyggMSAtIHBhcmFtc1sgaSBdLCAyLjAgKSAqIHkxXG4gICAgICArIDIgKiAoMS4wIC0gcGFyYW1zWyBpIF0pICogcGFyYW1zWyBpIF0gKiB5MlxuICAgICAgKyBwYXJhbXNbIGkgXSAqIHBhcmFtc1sgaSBdICogeTM7XG5cbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KCBjdXJYIC0geCwgMiApICsgTWF0aC5wb3coIGN1clkgLSB5LCAyICk7XG4gICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgaWYoIG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwICl7XG4gICAgICBpZiggZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQgKXtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1sgaSBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1sgaSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xuXG5tYXRoLnNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uKCB4LCB5LCB4MSwgeTEsIHgyLCB5MiApe1xuICB2YXIgb2Zmc2V0ID0gWyB4IC0geDEsIHkgLSB5MSBdO1xuICB2YXIgbGluZSA9IFsgeDIgLSB4MSwgeTIgLSB5MSBdO1xuXG4gIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG5cbiAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgdmFyIGFkalNxID0gZG90UHJvZHVjdCAqIGRvdFByb2R1Y3QgLyBsaW5lU3E7XG5cbiAgaWYoIGRvdFByb2R1Y3QgPCAwICl7XG4gICAgcmV0dXJuIGh5cFNxO1xuICB9XG5cbiAgaWYoIGFkalNxID4gbGluZVNxICl7XG4gICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICB9XG5cbiAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG59O1xuXG5tYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyA9IGZ1bmN0aW9uKCB4LCB5LCBwb2ludHMgKXtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICB2YXIgeTM7XG5cbiAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICB2YXIgdXAgPSAwO1xuICB2YXIgZG93biA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKyApe1xuXG4gICAgeDEgPSBwb2ludHNbIGkgKiAyXTtcbiAgICB5MSA9IHBvaW50c1sgaSAqIDIgKyAxXTtcblxuICAgIGlmKCBpICsgMSA8IHBvaW50cy5sZW5ndGggLyAyICl7XG4gICAgICB4MiA9IHBvaW50c1sgKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbIChpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgyID0gcG9pbnRzWyAoaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyAoaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuXG4gICAgaWYoIHgxID09IHggJiYgeDIgPT0geCApe1xuICAgICAgLy8gdGhlbiBpZ25vcmVcbiAgICB9IGVsc2UgaWYoICh4MSA+PSB4ICYmIHggPj0geDIpXG4gICAgICB8fCAoeDEgPD0geCAmJiB4IDw9IHgyKSApe1xuXG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgIGlmKCB5MyA+IHkgKXtcbiAgICAgICAgdXArKztcbiAgICAgIH1cblxuICAgICAgaWYoIHkzIDwgeSApe1xuICAgICAgICBkb3duKys7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gIH1cblxuICBpZiggdXAgJSAyID09PSAwICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5tYXRoLnBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uKFxuICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcgKXtcblxuICAvL3ZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHNbNl07XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheSggYmFzZVBvaW50cy5sZW5ndGggKTtcblxuICAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuICB2YXIgYW5nbGU7XG5cbiAgaWYoIGRpcmVjdGlvblswXSAhPSBudWxsICl7XG4gICAgYW5nbGUgPSBNYXRoLmF0YW4oIGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSApO1xuXG4gICAgaWYoIGRpcmVjdGlvblswXSA8IDAgKXtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICB2YXIgY29zID0gTWF0aC5jb3MoIC1hbmdsZSApO1xuICB2YXIgc2luID0gTWF0aC5zaW4oIC1hbmdsZSApO1xuXG4gIC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDJdID1cbiAgICAgIHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzWyBpICogMl0gKiBjb3NcbiAgICAgICAgLSBiYXNlUG9pbnRzWyBpICogMiArIDFdICogc2luKTtcblxuICAgIHRyYW5zZm9ybWVkUG9pbnRzWyBpICogMiArIDFdID1cbiAgICAgIGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1sgaSAqIDIgKyAxXSAqIGNvc1xuICAgICAgICArIGJhc2VQb2ludHNbIGkgKiAyXSAqIHNpbik7XG5cbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDJdICs9IGNlbnRlclg7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbIGkgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYoIHBhZGRpbmcgPiAwICl7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbihcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgLXBhZGRpbmcgKTtcblxuICAgIHBvaW50cyA9IHRoaXMuam9pbkxpbmVzKCBleHBhbmRlZExpbmVTZXQgKTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgcG9pbnRzICk7XG59O1xuXG5tYXRoLmpvaW5MaW5lcyA9IGZ1bmN0aW9uKCBsaW5lU2V0ICl7XG5cbiAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KCBsaW5lU2V0Lmxlbmd0aCAvIDIgKTtcblxuICB2YXIgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWTtcbiAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKyApe1xuICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFsgaSAqIDRdO1xuICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFsgaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0WyBpICogNCArIDJdO1xuICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbIGkgKiA0ICsgM107XG5cbiAgICBpZiggaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEgKXtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsgKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyAoaSArIDEpICogNCArIDFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsgKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbIChpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLFxuICAgICAgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksXG4gICAgICBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksXG4gICAgICBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSxcbiAgICAgIHRydWUgKTtcblxuICAgIHZlcnRpY2VzWyBpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgdmVydGljZXNbIGkgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gIH1cblxuICByZXR1cm4gdmVydGljZXM7XG59O1xuXG5tYXRoLmV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbiggcG9pbnRzLCBwYWQgKXtcblxuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KCBwb2ludHMubGVuZ3RoICogMiApO1xuXG4gIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKyApe1xuICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbIGkgKiAyXTtcbiAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzWyBpICogMiArIDFdO1xuXG4gICAgaWYoIGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEgKXtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbIChpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbIChpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuXG4gICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcblxuICAgIHZhciBvZmZzZXRYID0gKG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZKTtcbiAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydCggb2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSApO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcblxuICAgIGV4cGFuZGVkTGluZVNldFsgaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFsgaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbIGkgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0WyBpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbn07XG5cbm1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbihcbiAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzICl7XG5cbiAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuXG4gIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICBkaXNwWSAvPSBlbGxpcHNlSHJhZGl1cztcblxuICB2YXIgbGVuID0gTWF0aC5zcXJ0KCBkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSApO1xuXG4gIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuXG4gIGlmKCBuZXdMZW5ndGggPCAwICl7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG5cbiAgcmV0dXJuIFsgKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHkgXTtcbn07XG5cbi8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG5tYXRoLmludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbihcbiAgeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyApe1xuXG4gIC8vIENhbGN1bGF0ZSBkLCBkaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGQgPSBbIHgyIC0geDEsIHkyIC0geTEgXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBjID0gWyBjZW50ZXJYLCBjZW50ZXJZIF07IC8vIENlbnRlciBvZiBjaXJjbGVcbiAgdmFyIGYgPSBbIHgxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZIF07XG5cbiAgdmFyIGEgPSBkWzBdICogZFswXSArIGRbMV0gKiBkWzFdO1xuICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gIHZhciBjID0gKGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0pIC0gcmFkaXVzICogcmFkaXVzIDtcblxuICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYoIGRpc2NyaW1pbmFudCA8IDAgKXtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoIGRpc2NyaW1pbmFudCApKSAvICgyICogYSk7XG4gIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydCggZGlzY3JpbWluYW50ICkpIC8gKDIgKiBhKTtcblxuICB2YXIgdE1pbiA9IE1hdGgubWluKCB0MSwgdDIgKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCggdDEsIHQyICk7XG4gIHZhciBpblJhbmdlUGFyYW1zID0gW107XG5cbiAgaWYoIHRNaW4gPj0gMCAmJiB0TWluIDw9IDEgKXtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2goIHRNaW4gKTtcbiAgfVxuXG4gIGlmKCB0TWF4ID49IDAgJiYgdE1heCA8PSAxICl7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKCB0TWF4ICk7XG4gIH1cblxuICBpZiggaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDAgKXtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gIGlmKCBpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEgKXtcblxuICAgIGlmKCBpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0gKXtcbiAgICAgIHJldHVybiBbIG5lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSBdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcblxuICAgICAgcmV0dXJuIFsgbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZIF07XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsgbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZIF07XG4gIH1cblxufTtcblxubWF0aC5maW5kQ2lyY2xlTmVhclBvaW50ID0gZnVuY3Rpb24oIGNlbnRlclgsIGNlbnRlclksXG4gIHJhZGl1cywgZmFyWCwgZmFyWSApe1xuXG4gIHZhciBkaXNwbGFjZW1lbnRYID0gZmFyWCAtIGNlbnRlclg7XG4gIHZhciBkaXNwbGFjZW1lbnRZID0gZmFyWSAtIGNlbnRlclk7XG4gIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZGlzcGxhY2VtZW50WCAqIGRpc3BsYWNlbWVudFhcbiAgICArIGRpc3BsYWNlbWVudFkgKiBkaXNwbGFjZW1lbnRZICk7XG5cbiAgdmFyIHVuaXREaXNwbGFjZW1lbnRYID0gZGlzcGxhY2VtZW50WCAvIGRpc3RhbmNlO1xuICB2YXIgdW5pdERpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnRZIC8gZGlzdGFuY2U7XG5cbiAgcmV0dXJuIFsgY2VudGVyWCArIHVuaXREaXNwbGFjZW1lbnRYICogcmFkaXVzLFxuICAgIGNlbnRlclkgKyB1bml0RGlzcGxhY2VtZW50WSAqIHJhZGl1cyBdO1xufTtcblxubWF0aC5maW5kTWF4U3FEaXN0YW5jZVRvT3JpZ2luID0gZnVuY3Rpb24oIHBvaW50cyApe1xuICB2YXIgbWF4U3FEaXN0YW5jZSA9IDAuMDAwMDAxO1xuICB2YXIgc3FEaXN0YW5jZTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcblxuICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbIGkgKiAyXSAqIHBvaW50c1sgaSAqIDJdXG4gICAgICArIHBvaW50c1sgaSAqIDIgKyAxXSAqIHBvaW50c1sgaSAqIDIgKyAxXTtcblxuICAgIGlmKCBzcURpc3RhbmNlID4gbWF4U3FEaXN0YW5jZSApe1xuICAgICAgbWF4U3FEaXN0YW5jZSA9IHNxRGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heFNxRGlzdGFuY2U7XG59O1xuXG5tYXRoLm1pZE9mVGhyZWUgPSBmdW5jdGlvbiggYSwgYiwgYyApe1xuICBpZiggKGIgPD0gYSAmJiBhIDw9IGMpIHx8IChjIDw9IGEgJiYgYSA8PSBiKSApe1xuICAgIHJldHVybiBhO1xuICB9IGVsc2UgaWYoIChhIDw9IGIgJiYgYiA8PSBjKSB8fCAoYyA8PSBiICYmIGIgPD0gYSkgKXtcbiAgICByZXR1cm4gYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYztcbiAgfVxufTtcblxubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMgKXtcblxuICB2YXIgZHgxMyA9IHgxIC0geDM7XG4gIHZhciBkeDIxID0geDIgLSB4MTtcbiAgdmFyIGR4NDMgPSB4NCAtIHgzO1xuXG4gIHZhciBkeTEzID0geTEgLSB5MztcbiAgdmFyIGR5MjEgPSB5MiAtIHkxO1xuICB2YXIgZHk0MyA9IHk0IC0geTM7XG5cbiAgdmFyIHVhX3QgPSBkeDQzICogZHkxMyAtIGR5NDMgKiBkeDEzO1xuICB2YXIgdWJfdCA9IGR4MjEgKiBkeTEzIC0gZHkyMSAqIGR4MTM7XG4gIHZhciB1X2IgID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcblxuICBpZiggdV9iICE9PSAwICl7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuXG4gICAgdmFyIGZscHRUaHJlc2hvbGQgPSAwLjAwMTtcbiAgICB2YXIgbWluID0gMCAtIGZscHRUaHJlc2hvbGQ7XG4gICAgdmFyIG1heCA9IDEgKyBmbHB0VGhyZXNob2xkO1xuXG4gICAgaWYoIG1pbiA8PSB1YSAmJiB1YSA8PSBtYXggJiYgbWluIDw9IHViICYmIHViIDw9IG1heCApe1xuICAgICAgcmV0dXJuIFsgeDEgKyB1YSAqIGR4MjEsIHkxICsgdWEgKiBkeTIxIF07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoICFpbmZpbml0ZUxpbmVzICl7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbIHgxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMSBdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiggdWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwICl7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG5cbiAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiggdGhpcy5taWRPZlRocmVlKCB4MSwgeDIsIHg0ICkgPT09IHg0ICl7XG4gICAgICAgIHJldHVybiBbIHg0LCB5NCBdO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBzdGFydCBwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYoIHRoaXMubWlkT2ZUaHJlZSggeDEsIHgyLCB4MyApID09PSB4MyApe1xuICAgICAgICByZXR1cm4gWyB4MywgeTMgXTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgaWYoIHRoaXMubWlkT2ZUaHJlZSggeDMsIHg0LCB4MiApID09PSB4MiApe1xuICAgICAgICByZXR1cm4gWyB4MiwgeTIgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBub24tY29pbmNpZGVudFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcblxubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nICl7XG5cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcblxuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoIGJhc2VQb2ludHMubGVuZ3RoICk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1sgaSAqIDJdID0gYmFzZVBvaW50c1sgaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzWyBpICogMiArIDFdID0gYmFzZVBvaW50c1sgaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmKCBwYWRkaW5nID4gMCApe1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBtYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgIC1wYWRkaW5nICk7XG5cbiAgICBwb2ludHMgPSBtYXRoLmpvaW5MaW5lcyggZXhwYW5kZWRMaW5lU2V0ICk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cbiAgLy8gdmFyIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuXG4gIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKysgKXtcblxuICAgIGN1cnJlbnRYID0gcG9pbnRzWyBpICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbIGkgKiAyICsgMV07XG5cbiAgICBpZiggaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSApe1xuICAgICAgbmV4dFggPSBwb2ludHNbIChpICsgMSkgKiAyXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWyAoaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgY3VycmVudFgsIGN1cnJlbnRZLFxuICAgICAgbmV4dFgsIG5leHRZICk7XG5cbiAgICBpZiggaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCApe1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcblxubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oXG4gIGludGVyc2VjdGlvbiwgb2Zmc2V0LCBhbW91bnQgKXtcblxuICB2YXIgZGlzcCA9IFsgaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV0gXTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KCBkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdICk7XG5cbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgaWYoIGxlblJhdGlvIDwgMCApe1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuXG4gIHJldHVybiBbIG9mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdIF07XG59O1xuXG5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uKCBzaWRlcywgcm90YXRpb25SYWRpYW5zICl7XG4gIHZhciBwb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoIHNpZGVzLCByb3RhdGlvblJhZGlhbnMgKTtcbiAgcG9pbnRzID0gbWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHBvaW50cyApO1xuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uKCBwb2ludHMgKXtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrICl7XG4gICAgeCA9IHBvaW50c1syICogaSBdO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcblxuICAgIG1pblggPSBNYXRoLm1pbiggbWluWCwgeCApO1xuICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgIG1heFkgPSBNYXRoLm1heCggbWF4WSwgeSApO1xuICB9XG5cbiAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICB4ID0gcG9pbnRzWzIgKiBpIF0gPSBwb2ludHNbMiAqIGkgXSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IHBvaW50c1syICogaSArIDFdICogc3k7XG5cbiAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICBtaW5ZID0gTWF0aC5taW4oIG1pblksIHkgKTtcbiAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgfVxuXG4gIGlmKCBtaW5ZIDwgLTEgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IHBvaW50c1syICogaSArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uKCBzaWRlcywgcm90YXRpb25SYWRpYW5zICl7XG5cbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID9cbiAgICBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgLy8gICAgY29uc29sZS5sb2cobm9kZVNoYXBlc1snc3F1YXJlJ10pO1xuICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcblxuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KCBzaWRlcyAqIDIgKTtcblxuICB2YXIgY3VycmVudEFuZ2xlLCB4LCB5O1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKysgKXtcbiAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcblxuICAgIHggPSBwb2ludHNbMiAqIGkgXSA9IE1hdGguY29zKCBjdXJyZW50QW5nbGUgKTsvLyAqICgxICsgaS8yKTtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbiggLWN1cnJlbnRBbmdsZSApOy8vICAqICgxICsgaS8yKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQgKXtcblxuICAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcbiAgcmV0dXJuIE1hdGgubWluKCB3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDggKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0aDtcbiIsIi8qIVxuRW1iZWRkYWJsZSBNaW5pbXVtIFN0cmljdGx5LUNvbXBsaWFudCBQcm9taXNlcy9BKyAxLjEuMSBUaGVuYWJsZVxuQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgUmFsZiBTLiBFbmdlbHNjaGFsbCAoaHR0cDovL2VuZ2Vsc2NoYWxsLmNvbSlcbkxpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xudmFyIFNUQVRFX1BFTkRJTkcgICA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cbnZhciBTVEFURV9GVUxGSUxMRUQgPSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG52YXIgU1RBVEVfUkVKRUNURUQgID0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG4vKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG52YXIgYXBpID0gZnVuY3Rpb24oIGV4ZWN1dG9yICl7XG4gIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBhcGkpIClcbiAgICByZXR1cm4gbmV3IGFwaSggZXhlY3V0b3IgKTtcblxuICAvKiAgaW5pdGlhbGl6ZSBvYmplY3QgICovXG4gIHRoaXMuaWQgICAgICAgICAgID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgdGhpcy5zdGF0ZSAgICAgICAgPSBTVEFURV9QRU5ESU5HOyAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cbiAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCByZWFzb24gKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cbiAgdGhpcy5vbkZ1bGZpbGxlZCAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cbiAgdGhpcy5vblJlamVjdGVkICAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG4gIHRoaXMucHJveHkgPSB7XG4gICAgdGhlbjogdGhpcy50aGVuLmJpbmQoIHRoaXMgKVxuICB9O1xuXG4gIC8qICBzdXBwb3J0IG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uICAqL1xuICBpZiggdHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nIClcbiAgICBleGVjdXRvci5jYWxsKCB0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCggdGhpcyApLCB0aGlzLnJlamVjdC5iaW5kKCB0aGlzICkgKTtcbn07XG5cbi8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuYXBpLnByb3RvdHlwZSA9IHtcbiAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gIGZ1bGZpbGw6IGZ1bmN0aW9uKCB2YWx1ZSApeyByZXR1cm4gZGVsaXZlciggdGhpcywgU1RBVEVfRlVMRklMTEVELCAnZnVsZmlsbFZhbHVlJywgdmFsdWUgKTsgfSxcbiAgcmVqZWN0OiAgZnVuY3Rpb24oIHZhbHVlICl7IHJldHVybiBkZWxpdmVyKCB0aGlzLCBTVEFURV9SRUpFQ1RFRCwgICdyZWplY3RSZWFzb24nLCB2YWx1ZSApOyB9LFxuXG4gIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgdGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICl7XG4gICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChcbiAgICAgIHJlc29sdmVyKCBvbkZ1bGZpbGxlZCwgbmV4dCwgJ2Z1bGZpbGwnICkgKTsgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG4gICAgY3Vyci5vblJlamVjdGVkLnB1c2goXG4gICAgICByZXNvbHZlciggb25SZWplY3RlZCwgIG5leHQsICdyZWplY3QnICkgKTsgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG4gICAgZXhlY3V0ZSggY3VyciApO1xuICAgIHJldHVybiBuZXh0LnByb3h5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gIH1cbn07XG5cbi8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cbnZhciBkZWxpdmVyID0gZnVuY3Rpb24oIGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSApe1xuICBpZiggY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORyApe1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG4gICAgY3VyclsgbmFtZSBdID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuICAgIGV4ZWN1dGUoIGN1cnIgKTtcbiAgfVxuICByZXR1cm4gY3Vycjtcbn07XG5cbi8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlID0gZnVuY3Rpb24oIGN1cnIgKXtcbiAgaWYoIGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRCApXG4gICAgZXhlY3V0ZV9oYW5kbGVycyggY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUgKTtcbiAgZWxzZSBpZiggY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQgKVxuICAgIGV4ZWN1dGVfaGFuZGxlcnMoIGN1cnIsICdvblJlamVjdGVkJywgIGN1cnIucmVqZWN0UmVhc29uICk7XG59O1xuXG4vKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24oIGN1cnIsIG5hbWUsIHZhbHVlICl7XG4gIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cbiAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICBpZiggY3VyclsgbmFtZSBdLmxlbmd0aCA9PT0gMCApXG4gICAgcmV0dXJuO1xuXG4gIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gIHZhciBoYW5kbGVycyA9IGN1cnJbIG5hbWUgXTtcbiAgY3VyclsgbmFtZSBdID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKysgKVxuICAgICAgaGFuZGxlcnNbIGkgXSggdmFsdWUgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG4gIH07XG5cbiAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqLyAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG4gIGlmKCB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nIClcbiAgICBzZXRJbW1lZGlhdGUoIGZ1bmMgKTtcbiAgZWxzZVxuICAgIHNldFRpbWVvdXQoIGZ1bmMsIDAgKTtcbn07XG5cbi8qICBnZW5lcmF0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uICAqL1xudmFyIHJlc29sdmVyID0gZnVuY3Rpb24oIGNiLCBuZXh0LCBtZXRob2QgKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApe1xuICAgIGlmKCB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgIG5leHRbIG1ldGhvZCBdLmNhbGwoIG5leHQsIHZhbHVlICk7ICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgdHJ5IHsgcmVzdWx0ID0gY2IoIHZhbHVlICk7IH0gICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICBjYXRjaCggZSApe1xuICAgICAgICBuZXh0LnJlamVjdCggZSApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKCBuZXh0LCByZXN1bHQgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4xXSAgKi9cbiAgICB9XG4gIH07XG59O1xuXG4vKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xudmFyIHJlc29sdmUgPSBmdW5jdGlvbiggcHJvbWlzZSwgeCApe1xuICAvKiAgc2FuaXR5IGNoZWNrIGFyZ3VtZW50cyAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMV0gICovXG4gIGlmKCBwcm9taXNlID09PSB4IHx8IHByb21pc2UucHJveHkgPT09IHggKXtcbiAgICBwcm9taXNlLnJlamVjdCggbmV3IFR5cGVFcnJvciggJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnICkgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuICB2YXIgdGhlbjtcbiAgaWYoICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicgKXtcbiAgICB0cnkgeyB0aGVuID0geC50aGVuOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgY2F0Y2goIGUgKXtcbiAgICAgIHByb21pc2UucmVqZWN0KCBlICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuICBpZiggdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicgKXtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqLyAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuM10gICovXG4gICAgICB0aGVuLmNhbGwoIHgsXG4gICAgICAgIC8qICByZXNvbHZlUHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICAgIGZ1bmN0aW9uKCB5ICl7XG4gICAgICAgICAgaWYoIHJlc29sdmVkICkgcmV0dXJuOyByZXNvbHZlZCA9IHRydWU7ICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICBpZiggeSA9PT0geCApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoIG5ldyBUeXBlRXJyb3IoICdjaXJjdWxhciB0aGVuYWJsZSBjaGFpbicgKSApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc29sdmUoIHByb21pc2UsIHkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgICBmdW5jdGlvbiggciApe1xuICAgICAgICAgIGlmKCByZXNvbHZlZCApIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoIHIgKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgY2F0Y2goIGUgKXtcbiAgICAgIGlmKCAhcmVzb2x2ZWQgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgcHJvbWlzZS5yZWplY3QoIGUgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cbiAgcHJvbWlzZS5mdWxmaWxsKCB4ICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG59O1xuXG4vLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5hcGkuYWxsID0gZnVuY3Rpb24oIHBzICl7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uKCByZXNvbHZlQWxsLCByZWplY3RBbGwgKXtcbiAgICB2YXIgdmFscyA9IG5ldyBBcnJheSggcHMubGVuZ3RoICk7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uKCBpLCB2YWwgKXtcbiAgICAgIHZhbHNbIGkgXSA9IHZhbDtcbiAgICAgIGRvbmVDb3VudCsrO1xuXG4gICAgICBpZiggZG9uZUNvdW50ID09PSBwcy5sZW5ndGggKXtcbiAgICAgICAgcmVzb2x2ZUFsbCggdmFscyApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrICl7XG4gICAgICAoZnVuY3Rpb24oIGkgKXtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICBpZiggaXNQcm9taXNlICl7XG4gICAgICAgICAgcC50aGVuKCBmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICBmdWxmaWxsKCBpLCB2YWwgKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiggZXJyICl7XG4gICAgICAgICAgICByZWplY3RBbGwoIGVyciApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKCBpLCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgfSkoIGkgKTtcbiAgICB9XG5cbiAgfSApO1xufTtcblxuYXBpLnJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXsgcmVzb2x2ZSggdmFsICk7IH0pO1xufTtcblxuYXBpLnJlamVjdCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApeyByZWplY3QoIHZhbCApOyB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IGFwaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4vdXRpbCcgKTtcblxudmFyIFNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG5cbiAgaWYoICEodGhpcyBpbnN0YW5jZW9mIFNlbGVjdG9yKSApe1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yICk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5fcHJpdmF0ZSA9IHtcbiAgICBzZWxlY3RvclRleHQ6IG51bGwsXG4gICAgaW52YWxpZDogdHJ1ZVxuICB9O1xuXG4gIC8vIHN0b3JhZ2UgZm9yIHBhcnNlZCBxdWVyaWVzXG4gIHZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgY29sb25TZWxlY3RvcnM6IFtdLFxuICAgICAgZGF0YTogW10sXG4gICAgICBncm91cDogbnVsbCxcbiAgICAgIGlkczogW10sXG4gICAgICBtZXRhOiBbXSxcblxuICAgICAgLy8gZmFrZSBzZWxlY3RvcnNcbiAgICAgIGNvbGxlY3Rpb246IG51bGwsIC8vIGEgY29sbGVjdGlvbiB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICBmaWx0ZXI6IG51bGwsIC8vIGZpbHRlciBmdW5jdGlvblxuXG4gICAgICAvLyB0aGVzZSBhcmUgZGVmaW5lZCBpbiB0aGUgdXB3YXJkIGRpcmVjdGlvbiByYXRoZXIgdGhhbiBkb3duIChlLmcuIGNoaWxkKVxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIHVwIGluIFNlbGVjdG9yLmZpbHRlcigpXG4gICAgICBwYXJlbnQ6IG51bGwsIC8vIHBhcmVudCBxdWVyeSBvYmpcbiAgICAgIGFuY2VzdG9yOiBudWxsLCAvLyBhbmNlc3RvciBxdWVyeSBvYmpcbiAgICAgIHN1YmplY3Q6IG51bGwsIC8vIGRlZmluZXMgc3ViamVjdCBpbiBjb21wb3VuZCBxdWVyeSAoc3ViamVjdCBxdWVyeSBvYmo7IHBvaW50cyB0byBzZWxmIGlmIHN1YmplY3QpXG5cbiAgICAgIC8vIHVzZSB0aGVzZSBvbmx5IHdoZW4gc3ViamVjdCBoYXMgYmVlbiBkZWZpbmVkXG4gICAgICBjaGlsZDogbnVsbCxcbiAgICAgIGRlc2NlbmRhbnQ6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIGlmKCAhc2VsZWN0b3IgfHwgKCBpcy5zdHJpbmcoIHNlbGVjdG9yICkgJiYgc2VsZWN0b3IubWF0Y2goIC9eXFxzKiQvICkgKSApe1xuXG4gICAgc2VsZi5sZW5ndGggPSAwO1xuXG4gIH0gZWxzZSBpZiggc2VsZWN0b3IgPT09ICcqJyB8fCBzZWxlY3RvciA9PT0gJ2VkZ2UnIHx8IHNlbGVjdG9yID09PSAnbm9kZScgKXtcblxuICAgIC8vIG1ha2Ugc2luZ2xlLCBncm91cC1vbmx5IHNlbGVjdG9ycyBjaGVhcCB0byBtYWtlIGFuZCBjaGVhcCB0byBmaWx0ZXJcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uZ3JvdXAgPSBzZWxlY3RvciA9PT0gJyonID8gc2VsZWN0b3IgOiBzZWxlY3RvciArICdzJztcbiAgICBzZWxmWzBdLmdyb3VwT25seSA9IHRydWU7XG4gICAgc2VsZi5fcHJpdmF0ZS5pbnZhbGlkID0gZmFsc2U7XG4gICAgc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG5cbiAgfSBlbHNlIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBzZWxlY3RvciApICl7XG5cbiAgICB2YXIgY29sbGVjdGlvbiA9IHNlbGVjdG9yLmNvbGxlY3Rpb24oKTtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIH0gZWxzZSBpZiggaXMuZm4oIHNlbGVjdG9yICkgKXtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uZmlsdGVyID0gc2VsZWN0b3I7XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIH0gZWxzZSBpZiggaXMuc3RyaW5nKCBzZWxlY3RvciApICl7XG5cbiAgICAvLyB0aGUgY3VycmVudCBzdWJqZWN0IGluIHRoZSBxdWVyeVxuICAgIHZhciBjdXJyZW50U3ViamVjdCA9IG51bGw7XG5cbiAgICAvLyB0b2tlbnMgaW4gdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gICAgdmFyIHRva2VucyA9IHtcbiAgICAgIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJywgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gdmFyIG5hbWVzLCBldGNcbiAgICAgIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLCAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKStcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkrJ1wiLCAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICAgICAgbnVtYmVyOiB1dGlsLnJlZ2V4Lm51bWJlciwgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gICAgICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gICAgICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJywgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgICAgIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICAgICAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgICAgIHN1YmplY3Q6ICdcXFxcJCdcbiAgICB9O1xuICAgIHRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lXG4gICAgdG9rZW5zLnZhbHVlID0gdG9rZW5zLnN0cmluZyArICd8JyArIHRva2Vucy5udW1iZXI7IC8vIGEgdmFsdWUgbGl0ZXJhbCwgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlclxuICAgIHRva2Vucy5jbGFzc05hbWUgPSB0b2tlbnMudmFyaWFibGU7IC8vIGEgY2xhc3MgbmFtZSAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcbiAgICB0b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbiAgICAvLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4gICAgLy8gc28gdGhhdCB2YWx1ZXMgZ2V0IGNvbXBhcmVkIHByb3Blcmx5IGluIFNlbGVjdG9yLmZpbHRlcigpXG4gICAgdmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24oIHN0ciApe1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCBuZXcgUmVnRXhwKCAnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnICksIGZ1bmN0aW9uKCBtYXRjaCwgJDEsIG9mZnNldCwgb3JpZ2luYWwgKXtcbiAgICAgICAgcmV0dXJuICQxO1xuICAgICAgfSApO1xuICAgIH07XG5cbiAgICAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICB2YXIgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCggJ3wnICk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBvcCA9IG9wc1sgaSBdO1xuICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfEAnICsgb3A7XG4gICAgfVxuXG4gICAgLy8gYWRkICEgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoICd8JyApO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgb3AgPSBvcHNbIGkgXTtcblxuICAgICAgaWYoIG9wLmluZGV4T2YoICchJyApID49IDAgKXsgY29udGludWU7IH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuICAgICAgaWYoIG9wID09PSAnPScgKXsgY29udGludWU7IH0gLy8gc2tpcCA9IGIvYyAhPSBpcyBleHBsaWNpdGx5IGRlZmluZWRcblxuICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfFxcXFwhJyArIG9wO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbiAgICAvLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbiAgICAvLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxmW2ldIC0tLSB5b3UgY2FuIHVzZSB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYCBpbiB0aGUgcG9wdWxhdGUgZnVuY3Rpb247XG4gICAgLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBTZWxlY3Rvci5maWx0ZXIoKSBmb3IgaXQgYWN0dWFsbHkgZmlsdGVyIHByb3Blcmx5LCBidXQgdGhhdCdzIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXG4gICAgLy8gLSB3aGVuIHlvdSBhZGQgc29tZXRoaW5nIGhlcmUsIGFsc28gYWRkIHRvIFNlbGVjdG9yLnRvU3RyaW5nKClcbiAgICB2YXIgZXhwcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdncm91cCcsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJyhub2RlfGVkZ2V8XFxcXCopJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBncm91cCApe1xuICAgICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cCA9PT0gJyonID8gZ3JvdXAgOiBncm91cCArICdzJztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3RhdGUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgLy8gTkI6IGlmIG9uZSBjb2xvbiBzZWxlY3RvciBpcyBhIHN1YnN0cmluZyBvZiBhbm90aGVyIGZyb20gaXRzIHN0YXJ0LCBwbGFjZSB0aGUgbG9uZ2VyIG9uZSBmaXJzdFxuICAgICAgICAvLyBlLmcuIDpmb29iYXJ8OmZvb1xuICAgICAgICByZWdleDogJyg6c2VsZWN0ZWR8OnVuc2VsZWN0ZWR8OmxvY2tlZHw6dW5sb2NrZWR8OnZpc2libGV8OmhpZGRlbnw6dHJhbnNwYXJlbnR8OmdyYWJiZWR8OmZyZWV8OnJlbW92ZWR8Omluc2lkZXw6Z3JhYmJhYmxlfDp1bmdyYWJiYWJsZXw6YW5pbWF0ZWR8OnVuYW5pbWF0ZWR8OnNlbGVjdGFibGV8OnVuc2VsZWN0YWJsZXw6b3JwaGFufDpub25vcnBoYW58OnBhcmVudHw6Y2hpbGR8Omxvb3B8OnNpbXBsZXw6YWN0aXZlfDppbmFjdGl2ZXw6dG91Y2h8OmJhY2tncm91bmRpbmd8Om5vbmJhY2tncm91bmRpbmcpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBzdGF0ZSApe1xuICAgICAgICAgIHRoaXMuY29sb25TZWxlY3RvcnMucHVzaCggc3RhdGUgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcIygnICsgdG9rZW5zLmlkICsgJyknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGlkICl7XG4gICAgICAgICAgdGhpcy5pZHMucHVzaCggY2xlYW5NZXRhQ2hhcnMoIGlkICkgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgICAgICAgdGhpcy5jbGFzc2VzLnB1c2goIGNsZWFuTWV0YUNoYXJzKCBjbGFzc05hbWUgKSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlICl7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goIHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyggdmFyaWFibGUgKVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUNvbXBhcmUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhbHVlICsgJylcXFxccypcXFxcXScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUsIGNvbXBhcmF0b3JPcCwgdmFsdWUgKXtcbiAgICAgICAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoICdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcgKS5leGVjKCB2YWx1ZSApICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoIDEsIHZhbHVlLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKCB7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMoIHZhcmlhYmxlICksXG4gICAgICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhQm9vbCcsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGJvb2xPcCwgdmFyaWFibGUgKXtcbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCgge1xuICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKCB2YXJpYWJsZSApLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIG1ldGEsIGNvbXBhcmF0b3JPcCwgbnVtYmVyICl7XG4gICAgICAgICAgdGhpcy5tZXRhLnB1c2goIHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyggbWV0YSApLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KCBudW1iZXIgKVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbmV4dFF1ZXJ5JyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuICAgICAgICAgIHNlbGZbICsraSBdID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NoaWxkJyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLmNoaWxkLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyB0aGlzIHF1ZXJ5IGlzIHRoZSBwYXJlbnQgb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgIHZhciBjaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBjaGlsZFF1ZXJ5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgY2hpbGRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgIHNlbGZbIGkgXSA9IGNoaWxkUXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgIHZhciBkZXNjZW5kYW50UXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5hbmNlc3RvciA9IHRoaXM7XG4gICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICBzZWxmWyBpIF0gPSBkZXNjZW5kYW50UXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3N1YmplY3QnLFxuICAgICAgICBtb2RpZmllcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICBpZiggY3VycmVudFN1YmplY3QgIT0gbnVsbCAmJiB0aGlzLnN1YmplY3QgIT0gdGhpcyApe1xuICAgICAgICAgICAgdXRpbC5lcnJvciggJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCcgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5zdWJqZWN0ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgXTtcblxuICAgIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgdmFyIHJlbWFpbmluZyA9IHNlbGVjdG9yO1xuICAgIHZhciBpID0gMDtcblxuICAgIC8vIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dFxuICAgIHZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uKCBleHBlY3RhdGlvbiApe1xuICAgICAgdmFyIGV4cHI7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgbmFtZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZSA9IGV4cHJzWyBqIF07XG4gICAgICAgIHZhciBuID0gZS5uYW1lO1xuXG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGV4cHJlc3Npb24gaWYgaXQgZG9lc24ndCBtZWV0IHRoZSBleHBlY3RhdGlvbiBmdW5jdGlvblxuICAgICAgICBpZiggaXMuZm4oIGV4cGVjdGF0aW9uICkgJiYgIWV4cGVjdGF0aW9uKCBuLCBlICkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaCggbmV3IFJlZ0V4cCggJ14nICsgZS5yZWdleCApICk7XG5cbiAgICAgICAgaWYoIG0gIT0gbnVsbCApe1xuICAgICAgICAgIG1hdGNoID0gbTtcbiAgICAgICAgICBleHByID0gZTtcbiAgICAgICAgICBuYW1lID0gbjtcblxuICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7XG5cbiAgICAgICAgICBicmVhazsgLy8gd2UndmUgY29uc3VtZWQgb25lIGV4cHIsIHNvIHdlIGNhbiByZXR1cm4gbm93XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBjb25zdW1lIGFsbCBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICB2YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIG1hdGNoID0gcmVtYWluaW5nLm1hdGNoKCAvXlxccysvICk7XG5cbiAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpOyAvLyBnZXQgc3RhcnRlZFxuXG4gICAgY29uc3VtZVdoaXRlc3BhY2UoKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICBmb3IoIDs7ICl7XG4gICAgICB2YXIgY2hlY2sgPSBjb25zdW1lRXhwcigpO1xuXG4gICAgICBpZiggY2hlY2suZXhwciA9PSBudWxsICl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgaXMgaW52YWxpZCcgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yKCB2YXIgaiA9IDE7IGogPCBjaGVjay5tYXRjaC5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIGFyZ3MucHVzaCggY2hlY2subWF0Y2hbIGogXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IChpLmUuIGluIHNlbGZbaV0pXG4gICAgICAgIHZhciByZXQgPSBjaGVjay5leHByLnBvcHVsYXRlLmFwcGx5KCBzZWxmWyBpIF0sIGFyZ3MgKTtcblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyByZXR1cm47IH0gLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubWF0Y2goIC9eXFxzKiQvICkgKXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5sZW5ndGggPSBpICsgMTtcblxuICAgIC8vIGFkanVzdCByZWZlcmVuY2VzIGZvciBzdWJqZWN0XG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmWyBqIF07XG5cbiAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ICE9IG51bGwgKXtcbiAgICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgICAgZm9yKCA7OyApe1xuICAgICAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09IHF1ZXJ5ICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgc3ViamVjdCBpcyBzZWxmXG5cbiAgICAgICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXsgLy8gc3dhcCBwYXJlbnQvY2hpbGQgcmVmZXJlbmNlXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcXVlcnkucGFyZW50O1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gcXVlcnk7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGQgPSBjaGlsZDtcblxuICAgICAgICAgICAgcXVlcnkgPSBwYXJlbnQ7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgfSBlbHNlIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7IC8vIHN3YXAgYW5jZXN0b3IvZGVzY2VuZGFudFxuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gcXVlcnkuYW5jZXN0b3I7XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICBkZXNjZW5kYW50LmFuY2VzdG9yID0gbnVsbDtcbiAgICAgICAgICAgIGFuY2VzdG9yLmRlc2NlbmRhbnQgPSBkZXNjZW5kYW50O1xuXG4gICAgICAgICAgICBxdWVyeSA9IGFuY2VzdG9yOyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKCAnV2hlbiBhZGp1c3RpbmcgcmVmZXJlbmNlcyBmb3IgdGhlIHNlbGVjdG9yIGAnICsgcXVlcnkgKyAnYCwgbmVpdGhlciBwYXJlbnQgbm9yIGFuY2VzdG9yIHdhcyBmb3VuZCcgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3JcblxuICAgICAgICBzZWxmWyBqIF0gPSBxdWVyeS5zdWJqZWN0OyAvLyBzdWJqZWN0IHNob3VsZCBiZSB0aGUgcm9vdCBxdWVyeVxuICAgICAgfSAvLyBpZlxuICAgIH0gLy8gZm9yXG5cbiAgfSBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCAnQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyArIHNlbGVjdG9yICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi5fcHJpdmF0ZS5pbnZhbGlkID0gZmFsc2U7XG5cbn07XG5cbnZhciBzZWxmbiA9IFNlbGVjdG9yLnByb3RvdHlwZTtcblxuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbnNlbGZuLmVxID0gZnVuY3Rpb24oIGkgKXtcbiAgcmV0dXJuIHRoaXNbIGkgXTtcbn07XG5cbnZhciBxdWVyeU1hdGNoZXMgPSBmdW5jdGlvbiggcXVlcnksIGVsZSApe1xuICB2YXIgZWxlX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgLy8gbWFrZSBzaW5nbGUgZ3JvdXAtb25seSBzZWxlY3RvcnMgcmVhbGx5IGNoZWFwIHRvIGNoZWNrIHNpbmNlIHRoZXkncmUgdGhlIG1vc3QgY29tbW9uIG9uZXNcbiAgaWYoIHF1ZXJ5Lmdyb3VwT25seSApe1xuICAgIHJldHVybiBxdWVyeS5ncm91cCA9PT0gJyonIHx8IHF1ZXJ5Lmdyb3VwID09PSBlbGVfcC5ncm91cDtcbiAgfVxuXG4gIC8vIGNoZWNrIGdyb3VwXG4gIGlmKCBxdWVyeS5ncm91cCAhPSBudWxsICYmIHF1ZXJ5Lmdyb3VwICE9ICcqJyAmJiBxdWVyeS5ncm91cCAhPSBlbGVfcC5ncm91cCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjeSA9IGVsZS5jeSgpO1xuXG4gIC8vIGNoZWNrIGNvbG9uIHNlbGVjdG9yc1xuICB2YXIgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IHRydWU7XG4gIGZvciggdmFyIGsgPSAwOyBrIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBrKysgKXtcbiAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbIGsgXTtcblxuICAgIHN3aXRjaCggc2VsICl7XG4gICAgICBjYXNlICc6c2VsZWN0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuc2VsZWN0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpzZWxlY3RhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5zZWxlY3RhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuc2VsZWN0YWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLnNlbGVjdGFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6bG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5sb2NrZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5sb2NrZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5sb2NrZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dmlzaWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpoaWRkZW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS52aXNpYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRyYW5zcGFyZW50JzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS50cmFuc3BhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpncmFiYmVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmZyZWUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZS5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnJlbW92ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLnJlbW92ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aW5zaWRlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUucmVtb3ZlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmdyYWJiYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmdyYWJiYWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLmdyYWJiYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzphbmltYXRlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuYW5pbWF0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5hbmltYXRlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLmFuaW1hdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnBhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuaXNOb2RlKCkgJiYgZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Y2hpbGQnOlxuICAgICAgY2FzZSAnOm5vbm9ycGhhbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuaXNOb2RlKCkgJiYgZWxlLnBhcmVudCgpLm5vbmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOm9ycGhhbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuaXNOb2RlKCkgJiYgZWxlLnBhcmVudCgpLmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmxvb3AnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmlzRWRnZSgpICYmIGVsZS5kYXRhKCAnc291cmNlJyApID09PSBlbGUuZGF0YSggJ3RhcmdldCcgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2ltcGxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZS5pc0VkZ2UoKSAmJiBlbGUuZGF0YSggJ3NvdXJjZScgKSAhPT0gZWxlLmRhdGEoICd0YXJnZXQnICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmFjdGl2ZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGUuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluYWN0aXZlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGUuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRvdWNoJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGlzLnRvdWNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6bm9uYmFja2dyb3VuZGluZyc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNoZWNrIGlkXG4gIHZhciBhbGxJZHNNYXRjaCA9IHRydWU7XG4gIGZvciggdmFyIGsgPSAwOyBrIDwgcXVlcnkuaWRzLmxlbmd0aDsgaysrICl7XG4gICAgdmFyIGlkID0gcXVlcnkuaWRzWyBrIF07XG4gICAgdmFyIGFjdHVhbElkID0gZWxlX3AuZGF0YS5pZDtcblxuICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgKGlkID09IGFjdHVhbElkKTtcblxuICAgIGlmKCAhYWxsSWRzTWF0Y2ggKSBicmVhaztcbiAgfVxuICBpZiggIWFsbElkc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNoZWNrIGNsYXNzZXNcbiAgdmFyIGFsbENsYXNzZXNNYXRjaCA9IHRydWU7XG4gIGZvciggdmFyIGsgPSAwOyBrIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGsrKyApe1xuICAgIHZhciBjbHMgPSBxdWVyeS5jbGFzc2VzWyBrIF07XG5cbiAgICBhbGxDbGFzc2VzTWF0Y2ggPSBhbGxDbGFzc2VzTWF0Y2ggJiYgZWxlLmhhc0NsYXNzKCBjbHMgKTtcblxuICAgIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gZ2VuZXJpYyBjaGVja2luZyBmb3IgZGF0YS9tZXRhZGF0YVxuICB2YXIgb3BlcmFuZHNNYXRjaCA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSB0cnVlO1xuICAgIGZvciggdmFyIGsgPSAwOyBrIDwgcXVlcnlbIHBhcmFtcy5uYW1lIF0ubGVuZ3RoOyBrKysgKXtcbiAgICAgIHZhciBkYXRhID0gcXVlcnlbIHBhcmFtcy5uYW1lIF1bIGsgXTtcbiAgICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgdmFyIGZpZWxkID0gZGF0YS5maWVsZDtcbiAgICAgIHZhciBtYXRjaGVzO1xuXG4gICAgICBpZiggb3BlcmF0b3IgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsICl7XG5cbiAgICAgICAgdmFyIGZpZWxkVmFsID0gcGFyYW1zLmZpZWxkVmFsdWUoIGZpZWxkICk7XG4gICAgICAgIHZhciBmaWVsZFN0ciA9ICFpcy5zdHJpbmcoIGZpZWxkVmFsICkgJiYgIWlzLm51bWJlciggZmllbGRWYWwgKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgICAgdmFyIHZhbFN0ciA9ICcnICsgdmFsdWU7XG5cbiAgICAgICAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZiggJ0AnICkgPj0gMCApe1xuICAgICAgICAgIGZpZWxkU3RyID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSggJ0AnLCAnJyApO1xuICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZiggJyEnICkgPj0gMCApe1xuICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSggJyEnLCAnJyApO1xuICAgICAgICAgIG5vdEV4cHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gICAgICAgIGlmKCBjYXNlSW5zZW5zaXRpdmUgKXtcbiAgICAgICAgICB2YWx1ZSA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2goIG9wZXJhdG9yICl7XG4gICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZiggdmFsU3RyICkgPj0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKCB2YWxTdHIsIGZpZWxkU3RyLmxlbmd0aCAtIHZhbFN0ci5sZW5ndGggKSA+PSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YoIHZhbFN0ciApID09PSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuICAgICAgICBpZiggbm90RXhwciAmJiAoIGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCApICl7XG4gICAgICAgICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIG9wZXJhdG9yICE9IG51bGwgKXtcbiAgICAgICAgc3dpdGNoKCBvcGVyYXRvciApe1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVHJ1dGh5KCBmaWVsZCApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFRydXRoeSggZmllbGQgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFVuZGVmaW5lZCggZmllbGQgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRVbmRlZmluZWQoIGZpZWxkICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbWF0Y2hlcyApe1xuICAgICAgICBhbGxEYXRhTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG4gICAgcmV0dXJuIGFsbERhdGFNYXRjaGVzO1xuICB9OyAvLyBvcGVyYW5kc01hdGNoXG5cbiAgLy8gY2hlY2sgZGF0YSBtYXRjaGVzXG4gIHZhciBhbGxEYXRhTWF0Y2hlcyA9IG9wZXJhbmRzTWF0Y2goIHtcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oIGZpZWxkICl7XG4gICAgICByZXR1cm4gZWxlX3AuZGF0YVsgZmllbGQgXTtcbiAgICB9LFxuICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbiggZmllbGQgKXtcbiAgICAgIHJldHVybiBlbGVfcC5kYXRhWyBmaWVsZCBdID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oIGZpZWxkICl7XG4gICAgICBpZiggZWxlX3AuZGF0YVsgZmllbGQgXSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gKTtcblxuICBpZiggIWFsbERhdGFNYXRjaGVzICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgbWV0YWRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKCB7XG4gICAgbmFtZTogJ21ldGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgcmV0dXJuIGVsZVsgZmllbGQgXSgpO1xuICAgIH0sXG4gICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKCBmaWVsZCApe1xuICAgICAgcmV0dXJuIGVsZVsgZmllbGQgXSgpID09IG51bGw7XG4gICAgfSxcbiAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oIGZpZWxkICl7XG4gICAgICBpZiggZWxlWyBmaWVsZCBdKCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9ICk7XG5cbiAgaWYoICFhbGxNZXRhTWF0Y2hlcyApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGNvbGxlY3Rpb25cbiAgaWYoIHF1ZXJ5LmNvbGxlY3Rpb24gIT0gbnVsbCApe1xuICAgIHZhciBtYXRjaGVzQW55ID0gcXVlcnkuY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKCBlbGUuaWQoKSApO1xuXG4gICAgaWYoICFtYXRjaGVzQW55ICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZmlsdGVyIGZ1bmN0aW9uXG4gIGlmKCBxdWVyeS5maWx0ZXIgIT0gbnVsbCAmJiBlbGUuY29sbGVjdGlvbigpLmZpbHRlciggcXVlcnkuZmlsdGVyICkuc2l6ZSgpID09PSAwICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgcGFyZW50L2NoaWxkIHJlbGF0aW9uc1xuICB2YXIgY29uZmlybVJlbGF0aW9ucyA9IGZ1bmN0aW9uKCBxdWVyeSwgZWxlcyApe1xuICAgIGlmKCBxdWVyeSAhPSBudWxsICl7XG4gICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICBpZiggIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGVsZXMgPSBlbGVzKCk7IC8vIHNhdmUgY3ljbGVzIGlmIHF1ZXJ5ID09IG51bGxcblxuICAgICAgLy8gcXVlcnkgbXVzdCBtYXRjaCBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQgKG1heSBiZSByZWN1cnNpdmUpXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyggcXVlcnksIGVsZXNbIGkgXSApICl7XG4gICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpZiggIWNvbmZpcm1SZWxhdGlvbnMoIHF1ZXJ5LnBhcmVudCwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlLnBhcmVudCgpO1xuICB9ICkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYoICFjb25maXJtUmVsYXRpb25zKCBxdWVyeS5hbmNlc3RvciwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlLnBhcmVudHMoKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmKCAhY29uZmlybVJlbGF0aW9ucyggcXVlcnkuY2hpbGQsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZS5jaGlsZHJlbigpO1xuICB9ICkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYoICFjb25maXJtUmVsYXRpb25zKCBxdWVyeS5kZXNjZW5kYW50LCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGUuZGVzY2VuZGFudHMoKTtcbiAgfSApICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCwgc28gd2UndmUgbWF0Y2hlZCBldmVyeXRoaW5nIGZvciB0aGlzIHF1ZXJ5XG4gIHJldHVybiB0cnVlO1xufTsgLy8gcXVlcnlNYXRjaGVzXG5cbi8vIGZpbHRlciBhbiBleGlzdGluZyBjb2xsZWN0aW9uXG5zZWxmbi5maWx0ZXIgPSBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeSA9IGNvbGxlY3Rpb24uY3koKTtcblxuICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oIGksIGVsZW1lbnQgKXtcbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbIGogXTtcblxuICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyggcXVlcnksIGVsZW1lbnQgKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgaWYoIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID09IG51bGwgKXtcbiAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH07XG4gIH1cblxuICB2YXIgZmlsdGVyZWRDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5maWx0ZXIoIHNlbGVjdG9yRnVuY3Rpb24gKTtcblxuICByZXR1cm4gZmlsdGVyZWRDb2xsZWN0aW9uO1xufTsgLy8gZmlsdGVyXG5cbi8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbnNlbGZuLm1hdGNoZXMgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgdmFyIHF1ZXJ5ID0gc2VsZlsgaiBdO1xuXG4gICAgaWYoIHF1ZXJ5TWF0Y2hlcyggcXVlcnksIGVsZSApICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmaWx0ZXJcblxuLy8gaXRoIHF1ZXJ5IHRvIHN0cmluZ1xuc2VsZm4udG9TdHJpbmcgPSBzZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsZWFuVmFsID0gZnVuY3Rpb24oIHZhbCApe1xuICAgIGlmKCBpcy5zdHJpbmcoIHZhbCApICl7XG4gICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbGVhbiggdmFsICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzcGFjZSA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICByZXR1cm4gJyAnICsgdmFsICsgJyAnO1xuICB9O1xuXG4gIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24oIHF1ZXJ5ICl7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5ICl7XG4gICAgICBzdHIgKz0gJyQnO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IGNsZWFuKCBxdWVyeS5ncm91cCApO1xuICAgIHN0ciArPSBncm91cC5zdWJzdHJpbmcoIDAsIGdyb3VwLmxlbmd0aCAtIDEgKTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGRhdGEgPSBxdWVyeS5kYXRhWyBqIF07XG5cbiAgICAgIGlmKCBkYXRhLnZhbHVlICl7XG4gICAgICAgIHN0ciArPSAnWycgKyBkYXRhLmZpZWxkICsgc3BhY2UoIGNsZWFuKCBkYXRhLm9wZXJhdG9yICkgKSArIGNsZWFuVmFsKCBkYXRhLnZhbHVlICkgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gJ1snICsgY2xlYW4oIGRhdGEub3BlcmF0b3IgKSArIGRhdGEuZmllbGQgKyAnXSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBxdWVyeS5tZXRhLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbWV0YSA9IHF1ZXJ5Lm1ldGFbIGogXTtcbiAgICAgIHN0ciArPSAnW1snICsgbWV0YS5maWVsZCArIHNwYWNlKCBjbGVhbiggbWV0YS5vcGVyYXRvciApICkgKyBjbGVhblZhbCggbWV0YS52YWx1ZSApICsgJ11dJztcbiAgICB9XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbIGkgXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBxdWVyeS5pZHMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBzZWwgPSAnIycgKyBxdWVyeS5pZHNbIGkgXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgc2VsID0gJy4nICsgcXVlcnkuY2xhc3Nlc1sgaiBdO1xuICAgICAgc3RyICs9IHNlbDtcbiAgICB9XG5cbiAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXtcbiAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LnBhcmVudCApICsgJyA+ICcgKyBzdHI7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXtcbiAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmFuY2VzdG9yICkgKyAnICcgKyBzdHI7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LmNoaWxkICE9IG51bGwgKXtcbiAgICAgIHN0ciArPSAnID4gJyArIHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmNoaWxkICk7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LmRlc2NlbmRhbnQgIT0gbnVsbCApe1xuICAgICAgc3RyICs9ICcgJyArIHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmRlc2NlbmRhbnQgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBxdWVyeSA9IHRoaXNbIGkgXTtcblxuICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKCBxdWVyeSApO1xuXG4gICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxICl7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4vLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbi8vIC0gaXRzIGJ5cGFzc1xuLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiggZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG5cbiAgaWYoIF9wLm5ld1N0eWxlICl7IC8vIGNsZWFyIHN0eWxlIGNhY2hlc1xuICAgIF9wLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICBfcC5wcm9wRGlmZnMgPSB7fTtcblxuICAgIHNlbGYuY2xlYW5FbGVtZW50cyggZWxlcywgdHJ1ZSApO1xuICB9XG5cbiAgZm9yKCB2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGllIF07XG5cbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoIGVsZSApO1xuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKCBjeHRNZXRhICk7XG4gICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKTtcblxuICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgYXBwLmRpZmZQcm9wcyApO1xuICAgIHNlbGYudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG5cbiAgfSAvLyBmb3IgZWxlbWVudHNcblxuICBfcC5uZXdTdHlsZSA9IGZhbHNlO1xufTtcblxuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiggb2xkQ3h0S2V5LCBuZXdDeHRLZXkgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlWyBkdWFsQ3h0S2V5IF07XG5cbiAgaWYoIGNhY2hlZFZhbCApe1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICB2YXIgZGlmZlByb3BzID0gW107XG4gIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gc2VsZlsgaSBdO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbIGkgXSA9PT0gJ3QnO1xuICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbIGkgXSA9PT0gJ3QnO1xuICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgaWYoIGN4dEhhc0RpZmZlZCB8fCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgdmFyIHByb3BzO1xuXG4gICAgICBpZiggY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzRGlmZmVkICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgLy8gaXMgY2FjaGVkKVxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZbIGsgXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlbIGsgXSA9PT0gJ3QnO1xuXG4gICAgICAgICAgaWYoICFoYXNMYXRlckN4dCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggbGF0ZXJDeHRPdmVycmlkZXMgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFhZGRlZFByb3BbIG5hbWUgXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMgKXtcbiAgICAgICAgICBhZGRlZFByb3BbIG5hbWUgXSA9IHRydWU7XG4gICAgICAgICAgZGlmZlByb3BzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgcHJvcHNcbiAgICB9IC8vIGlmXG5cbiAgfSAvLyBmb3IgY29udGV4dHNcblxuICBjYWNoZVsgZHVhbEN4dEtleSBdID0gZGlmZlByb3BzO1xuICByZXR1cm4gZGlmZlByb3BzO1xufTtcblxuc3R5Zm4uZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApe1xuICAgIHByZXZLZXkgPSAnJzsgLy8gc2luY2Ugd2UgbmVlZCB0byBhcHBseSBhbGwgc3R5bGUgaWYgYSBmcmVzaCBzdHlsZXNoZWV0XG4gIH1cblxuICAvLyBnZXQgdGhlIGN4dCBrZXlcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBzZWxmWyBpIF07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmKCBjb250ZXh0U2VsZWN0b3JNYXRjaGVzICl7XG4gICAgICBjeHRLZXkgKz0gJ3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gJ2YnO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYoIHByZXZLZXksIGN4dEtleSApO1xuXG4gIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcblxuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wc1xuICB9O1xufTtcblxuLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcbiAgaWYoIGN4dFN0eWxlc1sgY3h0S2V5IF0gKXsgcmV0dXJuIGN4dFN0eWxlc1sgY3h0S2V5IF07IH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgX3ByaXZhdGU6IHtcbiAgICAgIGtleTogY3h0S2V5XG4gICAgfVxuICB9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjeHQgPSBzZWxmWyBpIF07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVsgaSBdID09PSAndCc7XG5cbiAgICBpZiggIWhhc0N4dCApeyBjb250aW51ZTsgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1sgaiBdO1xuXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGN4dFN0eWxlc1sgY3h0S2V5IF0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbIGkgXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoIGRpZmZQcm9wTmFtZSApO1xuXG4gICAgaWYoICFjeHRQcm9wICl7IC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmKCAhZWxlUHJvcCApe1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmKCBlbGVQcm9wLmJ5cGFzcyApe1xuICAgICAgICBjeHRQcm9wID0geyBuYW1lOiBkaWZmUHJvcE5hbWUsIGRlbGV0ZUJ5cGFzc2VkOiB0cnVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeHRQcm9wID0geyBuYW1lOiBkaWZmUHJvcE5hbWUsIGRlbGV0ZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmKCBlbGVQcm9wID09PSBjeHRQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG5cbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoIGRpZmZQcm9wTmFtZSApO1xuXG4gICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgfTtcbn07XG5cbnN0eWZuLnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbihlbGUpe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiggZWxlLnJlbW92ZWQoKSApeyByZXR1cm47IH1cblxuICAvLyBzZXQgd2hldGhlciBoYXMgcGllIG9yIG5vdDsgZm9yIGdyZWF0ZXIgZWZmaWNpZW5jeVxuICB2YXIgaGFzUGllID0gZmFsc2U7XG4gIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IHNlbGYucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IGVsZS5wc3R5bGUoICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScgKS52YWx1ZTtcblxuICAgICAgaWYoIHNpemUgPiAwICl7XG4gICAgICAgIGhhc1BpZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wLmhhc1BpZSA9IGhhc1BpZTtcblxuICB2YXIgdHJhbnNmb3JtID0gZWxlLnBzdHlsZSggJ3RleHQtdHJhbnNmb3JtJyApLnN0clZhbHVlO1xuICB2YXIgY29udGVudCA9IGVsZS5wc3R5bGUoICdsYWJlbCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHNyY0NvbnRlbnQgPSBlbGUucHN0eWxlKCAnc291cmNlLWxhYmVsJyApLnN0clZhbHVlO1xuICB2YXIgdGd0Q29udGVudCA9IGVsZS5wc3R5bGUoICd0YXJnZXQtbGFiZWwnICkuc3RyVmFsdWU7XG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCAnZm9udC1zdHlsZScgKS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCAnZm9udC1zaXplJyApLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgZmFtaWx5ID0gZWxlLnBzdHlsZSggJ2ZvbnQtZmFtaWx5JyApLnN0clZhbHVlO1xuICAvLyB2YXIgdmFyaWFudCA9IHN0eWxlWydmb250LXZhcmlhbnQnXS5zdHJWYWx1ZTtcbiAgdmFyIHdlaWdodCA9IGVsZS5wc3R5bGUoICdmb250LXdlaWdodCcgKS5zdHJWYWx1ZTtcbiAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoICd0ZXh0LXZhbGlnbicgKS5zdHJWYWx1ZTtcbiAgdmFyIG9XaWR0aCA9IGVsZS5wc3R5bGUoICd0ZXh0LW91dGxpbmUtd2lkdGgnICkucGZWYWx1ZTtcbiAgdmFyIHdyYXAgPSBlbGUucHN0eWxlKCAndGV4dC13cmFwJyApLnN0clZhbHVlO1xuICB2YXIgd3JhcFcgPSBlbGUucHN0eWxlKCAndGV4dC1tYXgtd2lkdGgnICkucGZWYWx1ZTtcbiAgdmFyIGxhYmVsU3R5bGVLZXkgPSBmU3R5bGUgKyAnJCcgKyBzaXplICsgJyQnICsgZmFtaWx5ICsgJyQnICsgd2VpZ2h0ICsgJyQnICsgdHJhbnNmb3JtICsgJyQnICsgdmFsaWduICsgJyQnICsgaGFsaWduICsgJyQnICsgb1dpZHRoICsgJyQnICsgd3JhcCArICckJyArIHdyYXBXO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gbGFiZWxTdHlsZUtleTtcbiAgX3Auc291cmNlTGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgc3JjQ29udGVudDtcbiAgX3AudGFyZ2V0TGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgdGd0Q29udGVudDtcbiAgX3AubGFiZWxLZXkgPSBsYWJlbFN0eWxlS2V5ICsgJyQnICsgY29udGVudDtcbiAgX3AuZm9udEtleSA9IGZTdHlsZSArICckJyArIHdlaWdodCArICckJyArIHNpemUgKyAnJCcgKyBmYW1pbHk7XG5cbiAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpO1xufTtcblxuLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5zdHlmbi5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24oIGVsZSwgcGFyc2VkUHJvcCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG5cbiAgLy8gZWRnZXMgY29ubmVjdGVkIHRvIGNvbXBvdW5kIG5vZGVzIGNhbiBub3QgYmUgaGF5c3RhY2tzXG4gIGlmKFxuICAgIHBhcnNlZFByb3AubmFtZSA9PT0gJ2N1cnZlLXN0eWxlJ1xuICAgICYmIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaydcbiAgICAmJiBlbGUuaXNFZGdlKClcbiAgICAmJiAoIGVsZS5pc0xvb3AoKSB8fCBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSApXG4gICl7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBwYXJzZWRQcm9wLm5hbWUsICdiZXppZXInLCBwcm9wSXNCeXBhc3MgKTtcbiAgfVxuXG4gIGlmKCBwcm9wLmRlbGV0ZSApeyAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGFuZCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gZmFsc2V5IHZhbHVlXG4gICAgc3R5bGVbIHByb3AubmFtZSBdID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiggcHJvcC5kZWxldGVCeXBhc3NlZCApeyAvLyBkZWxldGUgdGhlIHByb3BlcnR5IHRoYXQgdGhlXG4gICAgaWYoICFvcmlnUHJvcCApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGNhbid0IGRlbGV0ZSBpZiBubyBwcm9wXG5cbiAgICB9IGVsc2UgaWYoIG9yaWdQcm9wLmJ5cGFzcyApeyAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gIGlmKCBwcm9wLmRlbGV0ZUJ5cGFzcyApeyAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgaWYoICFvcmlnUHJvcCApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcblxuICAgIH0gZWxzZSBpZiggb3JpZ1Byb3AuYnlwYXNzICl7IC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gb3JpZ1Byb3AuYnlwYXNzZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uKCl7XG4gICAgdXRpbC5lcnJvciggJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcgKTtcbiAgfTtcblxuICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gIHN3aXRjaCggcHJvcC5tYXBwZWQgKXsgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgY2FzZSB0eXBlcy5tYXBMYXlvdXREYXRhOlxuICBjYXNlIHR5cGVzLm1hcFNjcmF0Y2g6XG5cbiAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICB2YXIgaXNTY3JhdGNoID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLm1hcFNjcmF0Y2g7XG5cbiAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoICcuJyApO1xuICAgIHZhciBmaWVsZFZhbDtcblxuICAgIGlmKCBpc1NjcmF0Y2ggfHwgaXNMYXlvdXQgKXtcbiAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrICl7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcbiAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQ7XG4gICAgaWYoICFpcy5udW1iZXIoIGZpZWxkVmFsICkgKXsgLy8gdGhlbiBrZWVwIHRoZSBtYXBwaW5nIGJ1dCBhc3N1bWUgMCUgZm9yIG5vd1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmNlbnQgPSAoZmllbGRWYWwgLSBwcm9wLmZpZWxkTWluKSAvIChwcm9wLmZpZWxkTWF4IC0gcHJvcC5maWVsZE1pbik7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgIHBlcmNlbnQgPSAxO1xuICAgIH1cblxuICAgIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICB2YXIgcjEgPSBwcm9wLnZhbHVlTWluWzBdO1xuICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICB2YXIgZzIgPSBwcm9wLnZhbHVlTWF4WzFdO1xuICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICB2YXIgYTEgPSBwcm9wLnZhbHVlTWluWzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1pblszXTtcbiAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuXG4gICAgICB2YXIgY2xyID0gW1xuICAgICAgICBNYXRoLnJvdW5kKCByMSArIChyMiAtIHIxKSAqIHBlcmNlbnQgKSxcbiAgICAgICAgTWF0aC5yb3VuZCggZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50ICksXG4gICAgICAgIE1hdGgucm91bmQoIGIxICsgKGIyIC0gYjEpICogcGVyY2VudCApLFxuICAgICAgICBNYXRoLnJvdW5kKCBhMSArIChhMiAtIGExKSAqIHBlcmNlbnQgKVxuICAgICAgXTtcblxuICAgICAgZmxhdFByb3AgPSB7IC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIHVzZSB0aGUgb3JpZ1Byb3Agc28gd2Ugc3RpbGwga2VlcCB0aGUgbWFwcGluZyBpdHNlbGZcbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBvcmlnUHJvcC5zdHJWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyApO1xuICAgIH1cblxuICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgIGJyZWFrO1xuXG4gIC8vIGRpcmVjdCBtYXBwaW5nXG4gIGNhc2UgdHlwZXMuZGF0YTpcbiAgY2FzZSB0eXBlcy5sYXlvdXREYXRhOlxuICBjYXNlIHR5cGVzLnNjcmF0Y2g6XG4gICAgdmFyIGlzTGF5b3V0ID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLmxheW91dERhdGE7XG4gICAgdmFyIGlzU2NyYXRjaCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5zY3JhdGNoO1xuXG4gICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCAnLicgKTtcbiAgICB2YXIgZmllbGRWYWw7XG5cbiAgICBpZiggaXNTY3JhdGNoIHx8IGlzTGF5b3V0ICl7XG4gICAgICBmaWVsZFZhbCA9IF9wLnNjcmF0Y2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICB9XG5cbiAgICBpZiggZmllbGRWYWwgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFsgZmllbGQgXTtcbiAgICB9IH1cblxuICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmaWVsZFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyApO1xuXG4gICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICB2YXIgZmxhdFByb3BWYWwgPSBvcmlnUHJvcCA/IG9yaWdQcm9wLnN0clZhbHVlIDogJyc7XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmbGF0UHJvcFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyApO1xuICAgIH1cblxuICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgdHlwZXMuZm46XG4gICAgdmFyIGZuID0gcHJvcC52YWx1ZTtcbiAgICB2YXIgZm5SZXRWYWwgPSBmbiggZWxlICk7XG5cbiAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZm5SZXRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcgKTtcbiAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgdW5kZWZpbmVkOlxuICAgIGJyZWFrOyAvLyBqdXN0IHNldCB0aGUgcHJvcGVydHlcblxuICBkZWZhdWx0OlxuICAgIHJldHVybiBmYWxzZTsgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICB9XG5cbiAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gIGlmKCBwcm9wSXNCeXBhc3MgKXtcbiAgICBpZiggb3JpZ1Byb3BJc0J5cGFzcyApeyAvLyB0aGVuIHRoaXMgYnlwYXNzIG92ZXJyaWRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgfSBlbHNlIHsgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG5cbiAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbmQgc2V0XG5cbiAgfSBlbHNlIHsgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgIH0gZWxzZSB7IC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKCBlbGUsIHByb3AubmFtZSwgb3JpZ1Byb3AgPyBvcmlnUHJvcC52YWx1ZSA6IG51bGwsIHByb3AudmFsdWUgKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnN0eWZuLmNsZWFuRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlcywga2VlcEJ5cGFzc2VzICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYoICFrZWVwQnlwYXNzZXMgKXtcbiAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgdmFyIGVsZVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIGVsZVByb3AgKXtcbiAgICAgICAgICBpZiggZWxlUHJvcC5ieXBhc3MgKXtcbiAgICAgICAgICAgIGVsZVByb3AuYnlwYXNzZWQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG59O1xuXG4vLyBqdXN0IHVwZGF0ZSB0aGUgZnVuY3Rpb25hbCBwcm9wZXJ0aWVzIChpLmUuIG1hcHBpbmdzKSBpbiB0aGUgZWxlbWVudHMnXG4vLyBzdHlsZXMgKGxlc3MgZXhwZW5zaXZlIHRoYW4gcmVjYWxjdWxhdGlvbilcbnN0eWZuLnVwZGF0ZU1hcHBlcnMgPSBmdW5jdGlvbiggZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIGogXTtcbiAgICAgIHZhciBwcm9wSW5TdHlsZSA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcgKXtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm9wSW5TdHlsZS5tYXBwaW5nO1xuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgbWFwcGluZyApOyAvLyByZWFwcGx5IHRoZSBtYXBwaW5nIHByb3BlcnR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgfVxufTtcblxuLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cbnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSggJ3RyYW5zaXRpb24tcHJvcGVydHknICkudmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoICd0cmFuc2l0aW9uLWR1cmF0aW9uJyApLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoICd0cmFuc2l0aW9uLWRlbGF5JyApLnBmVmFsdWU7XG5cbiAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICB2YXIgY3NzID0ge307XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBpIF07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUoIHByb3AgKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcCBdO1xuXG4gICAgICBpZiggIWRpZmZQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgIGlmKCBpcy5udW1iZXIoIGZyb21Qcm9wLnBmVmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC5wZlZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmKCBpcy5hcnJheSggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5hcnJheSggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF1cbiAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdXG4gICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXVxuICAgICAgICA7XG5cbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgIGlmKCBkaWZmICl7XG4gICAgICAgIGNzc1sgcHJvcCBdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBwcm9wLCBpbml0VmFsICk7IC8vIGZyb20gdmFsXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG5cbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICBpZiggIWFueVByZXYgKXsgcmV0dXJuOyB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIGVsZS5zdG9wKCk7XG5cbiAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICBlbGUuZGVsYXkoIGRlbGF5ICk7XG4gICAgfVxuXG4gICAgZWxlLmFuaW1hdGUoIHtcbiAgICAgIGNzczogY3NzXG4gICAgfSwge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nICkudmFsdWUsXG4gICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFpc0J5cGFzcyApe1xuICAgICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgfSBlbHNlIGlmKCBfcC50cmFuc2l0aW9uaW5nICl7XG4gICAgZWxlLnN0b3AoKTtcblxuICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24oIGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlICl7XG4gIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF07XG5cbiAgaWYoIHByb3AudHJpZ2dlcnNaT3JkZXIgJiYgKCBmcm9tVmFsdWUgPT0gbnVsbCB8fCBwcm9wLnRyaWdnZXJzWk9yZGVyKCBmcm9tVmFsdWUsIHRvVmFsdWUgKSApICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoe1xuICAgICAgdHlwZTogJ3pvcmRlcicsXG4gICAgICBlbGVzOiBlbGVcbiAgICB9KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbnN0eWZuLmFwcGx5QnlwYXNzID0gZnVuY3Rpb24oIGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgaWYoIG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionICl7IC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggbmFtZSApICl7IC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBuYW1lICkgKXsgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciB2YWx1ZSA9IHNwZWNpZmllZFByb3BzWyBuYW1lIF07XG5cbiAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIHV0aWwuZGFzaDJjYW1lbCggbmFtZSApIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUsIHRydWUgKTtcblxuICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHsgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICBpZiggcHJvcHMubGVuZ3RoID09PSAwICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaiBdO1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHByb3AgKSB8fCByZXQ7XG5cbiAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgICB9XG5cbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgaWYoIHJldCApe1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgICB9XG5cbiAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaCggbmFtZSApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzWyBpIF07XG4gICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbIG5hbWUgXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1sgbmFtZSBdLnR5cGU7XG4gICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuXG4gICAgaWYoICFwcm9wIHx8ICFwcm9wLmJ5cGFzcyApeyAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIG5hbWUsIHZhbHVlICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgb2xkVmFsdWUgPSBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiggcHJvcC5wZlZhbHVlICE9IG51bGwgKXtcbiAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmKCBpc0NvbG9yICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbiggJywnICkgKyAnKSc7XG4gICAgfSBlbHNlIGlmKCBpc011bHRpICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbiggJyAnICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3Auc3RyVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKCBlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSApO1xuICB9XG59O1xuXG5zdHlmbi5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyggZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xufTtcblxuc3R5Zm4ucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbIGogXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IHByb3BzWyBpIF07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1sgbmFtZSBdO1xuICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG5cbiAgICAgIGlmKCAhcHJldlByb3AgfHwgIXByZXZQcm9wLmJ5cGFzcyApe1xuICAgICAgICAvLyBpZiBhIGJ5cGFzcyBkb2Vzbid0IGV4aXN0IGZvciB0aGUgcHJvcCwgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBuYW1lLCB2YWx1ZSwgdHJ1ZSApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHBhcnNlZFByb3AgKTtcblxuICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoIHByb3AubmFtZSApO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vd2luZG93JyApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbnN0eWZuLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoICdmb250LXNpemUnICk7XG5cbiAgaWYoIHB4ICE9IG51bGwgKXtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCggcHggKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gIH1cbn07XG5cbi8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5zdHlmbi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRvbUVsZW1lbnQgKS5nZXRQcm9wZXJ0eVZhbHVlKCBwcm9wTmFtZSApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuLmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiggZWxlLCBwcm9wICl7XG4gIGlmKCBwcm9wICl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIHByb3AsIHRydWUgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYXdTdHlsZSggZWxlLCB0cnVlICk7XG4gIH1cbn07XG5cbi8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4uZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiggZWxlLCBpc1JlbmRlcmVkVmFsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmKCBlbGUgKXtcbiAgICB2YXIgcnN0eWxlID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIGkgXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwgKTtcblxuICAgICAgaWYoIHZhbCAhPSBudWxsICl7XG4gICAgICAgIHJzdHlsZVsgcHJvcC5uYW1lIF0gPSB2YWw7XG4gICAgICAgIHJzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKCBwcm9wLm5hbWUgKSBdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH1cbn07XG5cbnN0eWZuLmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKCBlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmKCBlbGUgKXtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXTtcblxuICAgIGlmKCBwcm9wLmFsaWFzICl7XG4gICAgICBwcm9wID0gcHJvcC5wb2ludHNUbztcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZSggcHJvcC5uYW1lICk7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICB2YXIgdW5pdHMgPSBzdHlsZVByb3AudW5pdHMgPyB0eXBlLmltcGxpY2l0VW5pdHMgfHwgJ3B4JyA6IG51bGw7XG4gICAgICB2YXIgdmFsID0gdW5pdHMgPyBbXS5jb25jYXQoIHN0eWxlUHJvcC5wZlZhbHVlICkubWFwKCBmdW5jdGlvbiggcGZWYWx1ZSApe1xuICAgICAgICByZXR1cm4gKCBwZlZhbHVlICogKGlzUmVuZGVyZWRWYWwgPyB6b29tIDogMSkgKSArIHVuaXRzO1xuICAgICAgfSApLmpvaW4oICcgJyApIDogc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxuc3R5Zm4uZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIGFuaVByb3BzICl7XG4gIHZhciByc3R5bGUgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1sgaSBdO1xuICAgIHZhciBuYW1lID0gYW5pUHJvcC5uYW1lO1xuXG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUoIG5hbWUgKTtcblxuICAgIGlmKCBzdHlsZVByb3AgIT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIHN0eWxlUHJvcCApICl7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHN0eWxlUHJvcC5zdHJWYWx1ZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZSggbmFtZSwgc3R5bGVQcm9wICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgcnN0eWxlWyBuYW1lIF0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuLmdldFByb3BzTGlzdCA9IGZ1bmN0aW9uKCBwcm9wc09iaiApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByc3R5bGUgPSBbXTtcbiAgdmFyIHN0eWxlID0gcHJvcHNPYmo7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBpZiggc3R5bGUgKXtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyggc3R5bGUgKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgdmFsID0gc3R5bGVbIG5hbWUgXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIG5hbWUgXSB8fCBwcm9wc1sgdXRpbC5jYW1lbDJkYXNoKCBuYW1lICkgXTtcbiAgICAgIHZhciBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIHZhbCApO1xuXG4gICAgICByc3R5bGUucHVzaCggc3R5bGVQcm9wICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKCAnLi4vc2VsZWN0b3InICk7XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkgKXtcbiAgICByZXR1cm4gbmV3IFN0eWxlKCBjeSApO1xuICB9XG5cbiAgaWYoICFpcy5jb3JlKCBjeSApICl7XG4gICAgdXRpbC5lcnJvciggJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgY29yZVN0eWxlOiB7fVxuICB9O1xuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xuXG52YXIgc3R5Zm4gPSBTdHlsZS5wcm90b3R5cGU7XG5cbnN0eWZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdzdHlsZSc7XG59O1xuXG4vLyByZW1vdmUgYWxsIGNvbnRleHRzXG5zdHlmbi5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHRoaXNbIGkgXSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICBfcC5uZXdTdHlsZSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbi5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5zdHlmbi5jb3JlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xufTtcblxuLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3JTdHIgKXtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgdGhpc1sgaSBdID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG5zdHlmbi5jc3MgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgY2FzZSAxOlxuICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBpIF07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIG1hcFZhbCA9IG1hcFsgdXRpbC5kYXNoMmNhbWVsKCBwcm9wLm5hbWUgKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5jc3NSdWxlKCBwcm9wLm5hbWUsIG1hcFZhbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgMjpcbiAgICB0aGlzLmNzc1J1bGUoIGFyZ3NbMF0sIGFyZ3NbMV0gKTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIGJyZWFrOyAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzO1xuXG4vLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gIGlmKCBwcm9wZXJ0eSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHRoaXNbIGkgXS5wcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgdGhpc1sgaSBdLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiggcHJvcGVydHkubmFtZS5tYXRjaCggL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLyApICYmIHByb3BlcnR5LnZhbHVlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHByb3BlcnR5Lm1hcHBlZCApe1xuICAgICAgdGhpc1sgaSBdLm1hcHBlZFByb3BlcnRpZXMucHVzaCggcHJvcGVydHkgKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbIGkgXS5zZWxlY3RvcjtcbiAgICBpZiggY3VycmVudFNlbGVjdG9ySXNDb3JlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVsgcHJvcGVydHkubmFtZSBdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBzdGF0aWMgZnVuY3Rpb25cblN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZSggY3kgKTtcblxuICBzdHlsZS5mcm9tSnNvbigganNvbiApO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICByZXR1cm4gbmV3IFN0eWxlKCBjeSApLmZyb21TdHJpbmcoIHN0cmluZyApO1xufTtcblxuW1xuICByZXF1aXJlKCAnLi9hcHBseScgKSxcbiAgcmVxdWlyZSggJy4vYnlwYXNzJyApLFxuICByZXF1aXJlKCAnLi9jb250YWluZXInICksXG4gIHJlcXVpcmUoICcuL2dldC1mb3ItZWxlJyApLFxuICByZXF1aXJlKCAnLi9qc29uJyApLFxuICByZXF1aXJlKCAnLi9zdHJpbmctc2hlZXQnICksXG4gIHJlcXVpcmUoICcuL3Byb3BlcnRpZXMnICksXG4gIHJlcXVpcmUoICcuL3BhcnNlJyApXG5dLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggc3R5Zm4sIHByb3BzICk7XG59ICk7XG5cblxuU3R5bGUudHlwZXMgPSBzdHlmbi50eXBlcztcblN0eWxlLnByb3BlcnRpZXMgPSBzdHlmbi5wcm9wZXJ0aWVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBqc29uICl7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uWyBpIF07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKCBwcm9wcyApO1xuXG4gICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yICk7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbIG5hbWUgXTtcblxuICAgICAgc3R5bGUuY3NzKCBuYW1lLCB2YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuc3R5Zm4uZnJvbUpzb24gPSBmdW5jdGlvbigganNvbiApe1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGx5RnJvbUpzb24oIGpzb24gKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5zdHlmbi5qc29uID0gZnVuY3Rpb24oKXtcbiAgdmFyIGpzb24gPSBbXTtcblxuICBmb3IoIHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjeHQgPSB0aGlzWyBpIF07XG4gICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbIGogXTtcbiAgICAgIGNzc1sgcHJvcC5uYW1lIF0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCgge1xuICAgICAgc2VsZWN0b3I6ICFzZWxlY3RvciA/ICdjb3JlJyA6IHNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICBzdHlsZTogY3NzXG4gICAgfSApO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vbWF0aCcgKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGEgY2FjaGluZyBsYXllciBmb3IgcHJvcGVydHkgcGFyc2luZ1xuc3R5Zm4ucGFyc2UgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuICBpZiggaXMuZm4oIHZhbHVlICkgKXtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICk7XG4gIH1cblxuICB2YXIgZmxhdEtleSA9ICggcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnIHx8IHByb3BJc0ZsYXQgPT09IHRydWUgfHwgcHJvcElzRmxhdCA9PT0gZmFsc2UgfHwgcHJvcElzRmxhdCA9PSBudWxsICkgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGFyZ0hhc2ggPSBbIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIGZsYXRLZXkgXS5qb2luKCAnJCcgKTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwge307XG4gIHZhciByZXQ7XG5cbiAgaWYoICEocmV0ID0gcHJvcENhY2hlWyBhcmdIYXNoIF0pICl7XG4gICAgcmV0ID0gcHJvcENhY2hlWyBhcmdIYXNoIF0gPSBzZWxmLnBhcnNlSW1wbFdhcm4oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKTtcbiAgfVxuXG4gIC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG4gIGlmKCBwcm9wSXNCeXBhc3MgfHwgcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnICl7XG4gICAgLy8gbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICAgIHJldCA9IHV0aWwuY29weSggcmV0ICk7XG5cbiAgICBpZiggcmV0ICl7XG4gICAgICByZXQudmFsdWUgPSB1dGlsLmNvcHkoIHJldC52YWx1ZSApOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5zdHlmbi5wYXJzZUltcGxXYXJuID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHByb3AgPSB0aGlzLnBhcnNlSW1wbCggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApO1xuXG4gIGlmKCAhcHJvcCAmJiB2YWx1ZSAhPSBudWxsICl7XG4gICAgdXRpbC5lcnJvcignVGhlIHN0eWxlIHByb3BlcnR5IGAlczogJXNgIGlzIGludmFsaWQnLCBuYW1lLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcHJvcDtcbn07XG5cbi8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuc3R5Zm4ucGFyc2VJbXBsID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG5hbWUgPSB1dGlsLmNhbWVsMmRhc2goIG5hbWUgKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1sgbmFtZSBdO1xuICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBpZiggIXByb3BlcnR5ICl7IHJldHVybiBudWxsOyB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcbiAgaWYoIHByb3BlcnR5LmFsaWFzICl7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgfVxuXG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gaXMuc3RyaW5nKCB2YWx1ZSApO1xuICBpZiggdmFsdWVJc1N0cmluZyApeyAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG4gIGlmKCAhdHlwZSApeyByZXR1cm4gbnVsbDsgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgaWYoIHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSApe1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICBpZiggaXMuZm4oIHZhbHVlICkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICB2YXIgZGF0YSwgbWFwRGF0YSwgbGF5b3V0RGF0YSwgbWFwTGF5b3V0RGF0YSwgc2NyYXRjaCwgbWFwU2NyYXRjaDtcbiAgaWYoICF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgKXtcbiAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gIH0gZWxzZSBpZihcbiAgICAoIGRhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5kYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgKCBsYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggc2NyYXRjaCA9IG5ldyBSZWdFeHAoIHR5cGVzLnNjcmF0Y2gucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgKXtcbiAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgdmFyIG1hcHBlZDtcbiAgICBpZiggZGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICB9IGVsc2UgaWYoIGxheW91dERhdGEgKXtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLmxheW91dERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLnNjcmF0Y2g7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwgbGF5b3V0RGF0YSB8fCBzY3JhdGNoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoXG4gICAgKCBtYXBEYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwRGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggbWFwTGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcExheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAoIG1hcFNjcmF0Y2ggPSBuZXcgUmVnRXhwKCB0eXBlcy5tYXBTY3JhdGNoLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApXG4gICl7XG4gICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcbiAgICBpZiggdHlwZS5tdWx0aXBsZSApeyByZXR1cm4gZmFsc2U7IH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cbiAgICB2YXIgbWFwcGVkO1xuICAgIGlmKCBtYXBEYXRhICl7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5tYXBEYXRhO1xuICAgIH0gZWxzZSBpZiggbWFwTGF5b3V0RGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkID0gdHlwZXMubWFwU2NyYXRjaDtcbiAgICB9XG5cbiAgICBtYXBEYXRhID0gbWFwRGF0YSB8fCBtYXBMYXlvdXREYXRhIHx8IG1hcFNjcmF0Y2g7XG5cbiAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICBpZiggISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNF0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNV0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcbiAgICBpZiggdmFsdWVNaW4udmFsdWUgPT09IHZhbHVlTWF4LnZhbHVlICl7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcblxuICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcblxuICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAmJiAoIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIDtcblxuICAgICAgaWYoIHNhbWUgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KCBtYXBEYXRhWzJdICksIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQoIG1hcERhdGFbM10gKSxcbiAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIGlmKCB0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScgKXtcbiAgICB2YXIgdmFscztcblxuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoIC9cXHMrLyApO1xuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIHZhbHVlICkgKXtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFsgdmFsdWUgXTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5ldmVuTXVsdGlwbGUgJiYgdmFscy5sZW5ndGggJSAyICE9PSAwICl7IHJldHVybiBudWxsOyB9XG5cbiAgICB2YXIgdmFsQXJyID0gW107XG4gICAgdmFyIHVuaXRzQXJyID0gW107XG4gICAgdmFyIHBmVmFsQXJyID0gW107XG4gICAgdmFyIGhhc0VudW0gPSBmYWxzZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHAgPSBzZWxmLnBhcnNlKCBuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScgKTtcblxuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgaXMuc3RyaW5nKCBwLnZhbHVlICk7XG5cbiAgICAgIHZhbEFyci5wdXNoKCBwLnZhbHVlICk7XG4gICAgICBwZlZhbEFyci5wdXNoKCBwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUgKTtcbiAgICAgIHVuaXRzQXJyLnB1c2goIHAudW5pdHMgKTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS52YWxpZGF0ZSAmJiAhdHlwZS52YWxpZGF0ZSggdmFsQXJyLCB1bml0c0FyciApICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0gKXtcbiAgICAgIGlmKCB2YWxBcnIubGVuZ3RoID09PSAxICYmIGlzLnN0cmluZyggdmFsQXJyWzBdICkgKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogdmFsQXJyLmpvaW4oICcgJyApLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9XG5cbiAgLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbIGkgXTtcblxuICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gIGlmKCB0eXBlLm51bWJlciApe1xuICAgIHZhciB1bml0cztcbiAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgIGlmKCB0eXBlLnVuaXRzICl7IC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuaW1wbGljaXRVbml0cyApe1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG5cbiAgICBpZiggIXR5cGUudW5pdGxlc3MgKXtcbiAgICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICBpZiggdW5pdHMgKXsgdW5pdHNSZWdleCA9IHVuaXRzOyB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCAnXignICsgdXRpbC5yZWdleC5udW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcgKTtcblxuICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoICF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMgKXtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG4gICAgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuICAgIGlmKCBpc05hTiggdmFsdWUgKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgaWYoIGlzTmFOKCB2YWx1ZSApICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcblxuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcbiAgICBpZiggdHlwZS5pbnRlZ2VyICYmICFpcy5pbnRlZ2VyKCB2YWx1ZSApICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiggKCB0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICggdmFsdWUgPCB0eXBlLm1pbiB8fCAodHlwZS5zdHJpY3RNaW4gJiYgdmFsdWUgPT09IHR5cGUubWluKSApIClcbiAgICB8fCAgKCB0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmICggdmFsdWUgPiB0eXBlLm1heCB8fCAodHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSApIClcbiAgICApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgIGlmKCB0eXBlLnVuaXRsZXNzIHx8ICh1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuICAgIGlmKCB1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogbWF0aC5kZWcycmFkKCB2YWx1ZSApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSB2YWx1ZSBpbiAlXG4gICAgaWYoIHVuaXRzID09PSAnJScgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWUgLyAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxuICB9IGVsc2UgaWYoIHR5cGUucHJvcExpc3QgKXtcblxuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgIH0gZWxzZSB7IC8vIGdvIG92ZXIgZWFjaCBwcm9wXG5cbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoICcsJyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbIGkgXS50cmltKCk7XG5cbiAgICAgICAgaWYoIHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXSApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oICcsICcgKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICB2YXIgdHVwbGUgPSB1dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgaWYoICF0dXBsZSApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICByb3VuZFZhbHVlOiB0cnVlXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzICl7XG5cbiAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgIGlmKCB0eXBlLmVudW1zICl7XG4gICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG5cbiAgICAgIGlmKCBlbnVtUHJvcCApeyByZXR1cm4gZW51bVByb3A7IH1cbiAgICB9XG5cbiAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFsgdHlwZS5yZWdleCBdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCByZWdleGVzWyBpIF0gKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG4gICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWMoIHZhbHVlICk7XG5cbiAgICAgIGlmKCBtICl7IC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuXG4gIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuZW51bXMgKXsgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKTtcbnZhciBpcyA9IHJlcXVpcmUoICcuLi9pcycgKTtcblxudmFyIHN0eWZuID0ge307XG5cbihmdW5jdGlvbigpe1xuICB2YXIgbnVtYmVyID0gdXRpbC5yZWdleC5udW1iZXI7XG4gIHZhciByZ2JhID0gdXRpbC5yZWdleC5yZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSB1dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICB2YXIgaGV4MyA9IHV0aWwucmVnZXguaGV4MztcbiAgdmFyIGhleDYgPSB1dGlsLnJlZ2V4LmhleDY7XG4gIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2O1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gIH07XG5cbiAgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuICBzdHlmbi50eXBlcyA9IHtcbiAgICB0aW1lOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCB1bml0czogJ3N8bXMnLCBpbXBsaWNpdFVuaXRzOiAnbXMnIH0sXG4gICAgcGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxMDAsIHVuaXRzOiAnJScsIGltcGxpY2l0VW5pdHM6ICclJyB9LFxuICAgIHplcm9PbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBuT25lT25lTnVtYmVyOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAtMSwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG5vbk5lZ2F0aXZlSW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBpbnRlZ2VyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIHBvc2l0aW9uOiB7IGVudW1zOiBbICdwYXJlbnQnLCAnb3JpZ2luJyBdIH0sXG4gICAgbm9kZVNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGVudW1zOiBbICdsYWJlbCcgXSB9LFxuICAgIG51bWJlcjogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbnVtYmVyczogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIHBvc2l0aXZlTnVtYmVyOiB7IG51bWJlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUsIG1pbjogMCwgc3RyaWN0TWluOiB0cnVlIH0sXG4gICAgc2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCB9LFxuICAgIGJpZGlyZWN0aW9uYWxTaXplOiB7IG51bWJlcjogdHJ1ZSB9LCAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZXM6IHsgbnVtYmVyOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LCAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBzaXplTWF5YmVQZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICBiZ1dIOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUsIGVudW1zOiBbICdhdXRvJyBdIH0sXG4gICAgYmdQb3M6IHsgbnVtYmVyOiB0cnVlLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICBiZ1JlcGVhdDogeyBlbnVtczogWyAncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCcgXSB9LFxuICAgIGJnRml0OiB7IGVudW1zOiBbICdub25lJywgJ2NvbnRhaW4nLCAnY292ZXInIF0gfSxcbiAgICBiZ0Nyb3NzT3JpZ2luOiB7IGVudW1zOiBbICdhbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJyBdIH0sXG4gICAgYmdDbGlwOiB7IGVudW1zOiBbICdub25lJywgJ25vZGUnIF0gfSxcbiAgICBjb2xvcjogeyBjb2xvcjogdHJ1ZSB9LFxuICAgIGJvb2w6IHsgZW51bXM6IFsgJ3llcycsICdubycgXSB9LFxuICAgIGxpbmVTdHlsZTogeyBlbnVtczogWyAnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcgXSB9LFxuICAgIGJvcmRlclN0eWxlOiB7IGVudW1zOiBbICdzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZScgXSB9LFxuICAgIGN1cnZlU3R5bGU6IHsgZW51bXM6IFsgJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJyBdIH0sXG4gICAgZm9udEZhbWlseTogeyByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCcgfSxcbiAgICBmb250VmFyaWFudDogeyBlbnVtczogWyAnc21hbGwtY2FwcycsICdub3JtYWwnIF0gfSxcbiAgICBmb250U3R5bGU6IHsgZW51bXM6IFsgJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZScgXSB9LFxuICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsgJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwIF0gfSxcbiAgICB0ZXh0RGVjb3JhdGlvbjogeyBlbnVtczogWyAnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJyBdIH0sXG4gICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWyAnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJyBdIH0sXG4gICAgdGV4dFdyYXA6IHsgZW51bXM6IFsgJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcycgXSB9LFxuICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHsgZW51bXM6IFsgJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScgXX0sXG4gICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbICdyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAnZWxsaXBzZScsICd0cmlhbmdsZScsICdzcXVhcmUnLCAncGVudGFnb24nLCAnaGV4YWdvbicsICdoZXB0YWdvbicsICdvY3RhZ29uJywgJ3N0YXInLCAnZGlhbW9uZCcsICd2ZWUnLCAncmhvbWJvaWQnLCAncG9seWdvbicgXSB9LFxuICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczogeyBlbnVtczogWyAnaW5jbHVkZScsICdleGNsdWRlJyBdIH0sXG4gICAgYXJyb3dTaGFwZTogeyBlbnVtczogWyAndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1jcm9zcycsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcsICd2ZWUnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ25vbmUnIF0gfSxcbiAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsgJ2ZpbGxlZCcsICdob2xsb3cnIF0gfSxcbiAgICBkaXNwbGF5OiB7IGVudW1zOiBbICdlbGVtZW50JywgJ25vbmUnIF0gfSxcbiAgICB2aXNpYmlsaXR5OiB7IGVudW1zOiBbICdoaWRkZW4nLCAndmlzaWJsZScgXSB9LFxuICAgIHpDb21wb3VuZERlcHRoOiB7IGVudW1zOiBbICdib3R0b20nLCAnb3JwaGFuJywgJ2F1dG8nLCAndG9wJyBdIH0sXG4gICAgekluZGV4Q29tcGFyZTogeyBlbnVtczogWyAnYXV0bycsICdtYW51YWwnIF0gfSxcbiAgICB2YWxpZ246IHsgZW51bXM6IFsgJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJyBdIH0sXG4gICAgaGFsaWduOiB7IGVudW1zOiBbICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgXSB9LFxuICAgIHRleHQ6IHsgc3RyaW5nOiB0cnVlIH0sXG4gICAgZGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSggJ2RhdGEnICkgfSxcbiAgICBsYXlvdXREYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCAnbGF5b3V0RGF0YScgKSB9LFxuICAgIHNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoICdzY3JhdGNoJyApIH0sXG4gICAgbWFwRGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSggJ21hcERhdGEnICkgfSxcbiAgICBtYXBMYXlvdXREYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCAnbWFwTGF5b3V0RGF0YScgKSB9LFxuICAgIG1hcFNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoICdtYXBTY3JhdGNoJyApIH0sXG4gICAgZm46IHsgbWFwcGluZzogdHJ1ZSwgZm46IHRydWUgfSxcbiAgICB1cmw6IHsgcmVnZXg6ICd1cmxcXFxccypcXFxcKFxcXFxzKltcXCdcIl0/KC4rPylbXFwnXCJdP1xcXFxzKlxcXFwpfG5vbmV8KC4rKSQnIH0sXG4gICAgcHJvcExpc3Q6IHsgcHJvcExpc3Q6IHRydWUgfSxcbiAgICBhbmdsZTogeyBudW1iZXI6IHRydWUsIHVuaXRzOiAnZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdyYWQnIH0sXG4gICAgdGV4dFJvdGF0aW9uOiB7IG51bWJlcjogdHJ1ZSwgdW5pdHM6ICdkZWd8cmFkJywgaW1wbGljaXRVbml0czogJ3JhZCcsIGVudW1zOiBbICdub25lJywgJ2F1dG9yb3RhdGUnIF0gfSxcbiAgICBwb2x5Z29uUG9pbnRMaXN0OiB7IG51bWJlcjogdHJ1ZSwgbXVsdGlwbGU6IHRydWUsIGV2ZW5NdWx0aXBsZTogdHJ1ZSwgbWluOiAtMSwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIGVkZ2VEaXN0YW5jZXM6IHsgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nXSB9LFxuICAgIGVkZ2VFbmRwb2ludDoge1xuICAgICAgbnVtYmVyOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSwgdW5pdHM6ICclfHB4fGVtfGRlZ3xyYWQnLCBpbXBsaWNpdFVuaXRzOiAncHgnLFxuICAgICAgZW51bXM6IFsgJ2luc2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLWxpbmUnIF0sIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24oIHZhbEFyciwgdW5pdHNBcnIgKXtcbiAgICAgICAgc3dpdGNoKCB2YWxBcnIubGVuZ3RoICl7XG4gICAgICAgICAgY2FzZSAyOiAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuICAgICAgICAgIGNhc2UgMTogLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBpcy5zdHJpbmcoIHZhbEFyclswXSApIHx8IHVuaXRzQXJyWzBdID09PSAnZGVnJyB8fCB1bml0c0FyclswXSA9PT0gJ3JhZCc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbXG4gICAgICAgICdeKHNwcmluZylcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCcsXG4gICAgICAgICdeKGN1YmljLWJlemllcilcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSQnXG4gICAgICBdLFxuICAgICAgZW51bXM6IFtcbiAgICAgICAgJ2xpbmVhcicsXG4gICAgICAgICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLFxuICAgICAgICAnZWFzZS1pbi1zaW5lJywgJ2Vhc2Utb3V0LXNpbmUnLCAnZWFzZS1pbi1vdXQtc2luZScsXG4gICAgICAgICdlYXNlLWluLXF1YWQnLCAnZWFzZS1vdXQtcXVhZCcsICdlYXNlLWluLW91dC1xdWFkJyxcbiAgICAgICAgJ2Vhc2UtaW4tY3ViaWMnLCAnZWFzZS1vdXQtY3ViaWMnLCAnZWFzZS1pbi1vdXQtY3ViaWMnLFxuICAgICAgICAnZWFzZS1pbi1xdWFydCcsICdlYXNlLW91dC1xdWFydCcsICdlYXNlLWluLW91dC1xdWFydCcsXG4gICAgICAgICdlYXNlLWluLXF1aW50JywgJ2Vhc2Utb3V0LXF1aW50JywgJ2Vhc2UtaW4tb3V0LXF1aW50JyxcbiAgICAgICAgJ2Vhc2UtaW4tZXhwbycsICdlYXNlLW91dC1leHBvJywgJ2Vhc2UtaW4tb3V0LWV4cG8nLFxuICAgICAgICAnZWFzZS1pbi1jaXJjJywgJ2Vhc2Utb3V0LWNpcmMnLCAnZWFzZS1pbi1vdXQtY2lyYydcbiAgICAgIF1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHpPcmRlckRpZmYgPSB7XG4gICAgemVyb05vblplcm86IGZ1bmN0aW9uKCB2YWwxLCB2YWwyICl7XG4gICAgICBpZiggdmFsMSA9PT0gMCAmJiB2YWwyICE9PSAwICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmKCB2YWwxICE9PSAwICYmIHZhbDIgPT09IDAgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnlEaWZmOiBmdW5jdGlvbiggdmFsMSwgdmFsMiApe1xuICAgICAgcmV0dXJuIHZhbDEgIT09IHZhbDI7XG4gICAgfVxuICB9O1xuXG4gIHZhciB6ZCA9IHpPcmRlckRpZmY7XG5cbiAgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciB0ID0gc3R5Zm4udHlwZXM7XG4gIHZhciBwcm9wcyA9IHN0eWZuLnByb3BlcnRpZXMgPSBbXG4gICAgLy8gbWFpbiBsYWJlbFxuICAgIHsgbmFtZTogJ2xhYmVsJywgdHlwZTogdC50ZXh0IH0sXG4gICAgeyBuYW1lOiAndGV4dC1yb3RhdGlvbicsIHR5cGU6IHQudGV4dFJvdGF0aW9uIH0sXG4gICAgeyBuYW1lOiAndGV4dC1tYXJnaW4teCcsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW1hcmdpbi15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuXG4gICAgLy8gc291cmNlIGxhYmVsXG4gICAgeyBuYW1lOiAnc291cmNlLWxhYmVsJywgdHlwZTogdC50ZXh0IH0sXG4gICAgeyBuYW1lOiAnc291cmNlLXRleHQtcm90YXRpb24nLCB0eXBlOiB0LnRleHRSb3RhdGlvbiB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS10ZXh0LW9mZnNldCcsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgLy8gdGFyZ2V0IGxhYmVsXG4gICAgeyBuYW1lOiAndGFyZ2V0LWxhYmVsJywgdHlwZTogdC50ZXh0IH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LXRleHQtcm90YXRpb24nLCB0eXBlOiB0LnRleHRSb3RhdGlvbiB9LFxuICAgIHsgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RhcmdldC10ZXh0LW9mZnNldCcsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgLy8gY29tbW9uIGxhYmVsIHN0eWxlXG4gICAgeyBuYW1lOiAndGV4dC12YWxpZ24nLCB0eXBlOiB0LnZhbGlnbiB9LFxuICAgIHsgbmFtZTogJ3RleHQtaGFsaWduJywgdHlwZTogdC5oYWxpZ24gfSxcbiAgICB7IG5hbWU6ICdjb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1zaGFwZScsIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZX0sXG4gICAgLy8geyBuYW1lOiAndGV4dC1kZWNvcmF0aW9uJywgdHlwZTogdC50ZXh0RGVjb3JhdGlvbiB9LCAvLyBub3Qgc3VwcG9ydGVkIGluIGNhbnZhc1xuICAgIHsgbmFtZTogJ3RleHQtdHJhbnNmb3JtJywgdHlwZTogdC50ZXh0VHJhbnNmb3JtIH0sXG4gICAgeyBuYW1lOiAndGV4dC13cmFwJywgdHlwZTogdC50ZXh0V3JhcCB9LFxuICAgIHsgbmFtZTogJ3RleHQtbWF4LXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ldmVudHMnLCB0eXBlOiB0LmJvb2wgfSxcbiAgICB7IG5hbWU6ICdmb250LWZhbWlseScsIHR5cGU6IHQuZm9udEZhbWlseSB9LFxuICAgIHsgbmFtZTogJ2ZvbnQtc3R5bGUnLCB0eXBlOiB0LmZvbnRTdHlsZSB9LFxuICAgIC8vIHsgbmFtZTogJ2ZvbnQtdmFyaWFudCcsIHR5cGU6IHQuZm9udFZhcmlhbnQgfSwgLy8gbm90IHVzZWZ1bFxuICAgIHsgbmFtZTogJ2ZvbnQtd2VpZ2h0JywgdHlwZTogdC5mb250V2VpZ2h0IH0sXG4gICAgeyBuYW1lOiAnZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcblxuICAgIC8vIGJlaGF2aW91clxuICAgIHsgbmFtZTogJ2V2ZW50cycsIHR5cGU6IHQuYm9vbCB9LFxuXG4gICAgLy8gdmlzaWJpbGl0eVxuICAgIHsgbmFtZTogJ2Rpc3BsYXknLCB0eXBlOiB0LmRpc3BsYXksIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sXG4gICAgeyBuYW1lOiAndmlzaWJpbGl0eScsIHR5cGU6IHQudmlzaWJpbGl0eSwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcbiAgICB7IG5hbWU6ICdvcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyLCB0cmlnZ2Vyc1pPcmRlcjogemQuemVyb05vblplcm8gfSxcbiAgICB7IG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJywgdHlwZTogdC56Q29tcG91bmREZXB0aCwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcbiAgICB7IG5hbWU6ICd6LWluZGV4LWNvbXBhcmUnLCB0eXBlOiB0LnpJbmRleENvbXBhcmUsIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sXG4gICAgeyBuYW1lOiAnei1pbmRleCcsIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQsIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sXG5cbiAgICAvLyBvdmVybGF5c1xuICAgIHsgbmFtZTogJ292ZXJsYXktcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ292ZXJsYXktY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG5cbiAgICAvLyBzaGFkb3dzXG4gICAgeyBuYW1lOiAnc2hhZG93LWJsdXInLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdzaGFkb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdzaGFkb3ctb2Zmc2V0LXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuXG4gICAgLy8gbGFiZWwgc2hhZG93c1xuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LWJsdXInLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb2Zmc2V0LXknLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG5cbiAgICAvLyB0cmFuc2l0aW9uIGFuaXNcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JywgdHlwZTogdC5wcm9wTGlzdCB9LFxuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0eXBlOiB0LnRpbWUgfSxcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JywgdHlwZTogdC50aW1lIH0sXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCB0eXBlOiB0LmVhc2luZyB9LFxuXG4gICAgLy8gbm9kZSBib2R5XG4gICAgeyBuYW1lOiAnaGVpZ2h0JywgdHlwZTogdC5ub2RlU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3dpZHRoJywgdHlwZTogdC5ub2RlU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NoYXBlJywgdHlwZTogdC5ub2RlU2hhcGUgfSxcbiAgICB7IG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsIHR5cGU6IHQucG9seWdvblBvaW50TGlzdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJywgdHlwZTogdC5uT25lT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgLy8gbm9kZSBib3JkZXJcbiAgICB7IG5hbWU6ICdib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG5cbiAgICAvLyBub2RlIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsIHR5cGU6IHQudXJsIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsIHR5cGU6IHQuYmdDcm9zc09yaWdpbiB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHR5cGU6IHQuYmdQb3MgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLCB0eXBlOiB0LmJnUmVwZWF0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1maXQnLCB0eXBlOiB0LmJnRml0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJywgdHlwZTogdC5iZ1dIIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLCB0eXBlOiB0LmJnV0ggfSxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiB0LnBvc2l0aW9uIH0sXG4gICAgeyBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLCB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyB9LFxuICAgIHsgbmFtZTogJ21pbi13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLCB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQgfSxcbiAgICB7IG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LFxuICAgIHsgbmFtZTogJ21pbi1oZWlnaHQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sXG4gICAgeyBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LFxuXG4gICAgLy8gZWRnZSBsaW5lXG4gICAgeyBuYW1lOiAnbGluZS1zdHlsZScsIHR5cGU6IHQubGluZVN0eWxlIH0sXG4gICAgeyBuYW1lOiAnbGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LFxuICAgIHsgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsIHR5cGU6IHQuZWRnZUVuZHBvaW50IH0sXG4gICAgeyBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JywgdHlwZTogdC5lZGdlRW5kcG9pbnQgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSxcbiAgICB7IG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzIH0sXG4gICAgeyBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJywgdHlwZTogdC5udW1iZXJzIH0sXG4gICAgeyBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLCB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1zY2FsZScsIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdsb29wLWRpcmVjdGlvbicsIHR5cGU6IHQuYW5nbGUgfSxcbiAgICB7IG5hbWU6ICdsb29wLXN3ZWVwJywgdHlwZTogdC5hbmdsZSB9LFxuICAgIHsgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyB0aGVzZSBhcmUganVzdCBmb3IgdGhlIGNvcmVcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfVxuICBdO1xuXG4gIC8vIGRlZmluZSBhbGlhc2VzXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4uYWxpYXNlcyA9IFtcbiAgICB7IG5hbWU6ICdjb250ZW50JywgcG9pbnRzVG86ICdsYWJlbCcgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJywgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyB9LFxuICAgIHsgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbicgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLWxlZnQnLCBwb2ludHNUbzogJ3BhZGRpbmcnIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1yaWdodCcsIHBvaW50c1RvOiAncGFkZGluZycgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLXRvcCcsIHBvaW50c1RvOiAncGFkZGluZycgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsIHBvaW50c1RvOiAncGFkZGluZycgfVxuICBdO1xuXG4gIC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgc3R5Zm4ucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS1zaXplJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0gKTtcbiAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gc3R5Zm4ucGllQmFja2dyb3VuZE47IGkrKyApe1xuICAgIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSApO1xuICAgIHByb3BzLnB1c2goIHsgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJywgdHlwZTogdC5wZXJjZW50IH0gKTtcbiAgICBwcm9wcy5wdXNoKCB7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9ICk7XG4gIH1cblxuICAvLyBlZGdlIGFycm93c1xuICB2YXIgYXJyb3dQcmVmaXhlcyA9IHN0eWZuLmFycm93UHJlZml4ZXMgPSBbICdzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCcgXTtcbiAgW1xuICAgIHsgbmFtZTogJ2Fycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH1cbiAgXS5mb3JFYWNoKCBmdW5jdGlvbiggcHJvcCApe1xuICAgIGFycm93UHJlZml4ZXMuZm9yRWFjaCggZnVuY3Rpb24oIHByZWZpeCApe1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcblxuICAgICAgcHJvcHMucHVzaCggeyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlIH0gKTtcbiAgICB9ICk7XG4gIH0sIHt9ICk7XG5cbiAgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICBzdHlmbi5wcm9wZXJ0eU5hbWVzID0gcHJvcHMubWFwKCBmdW5jdGlvbiggcCApeyByZXR1cm4gcC5uYW1lOyB9ICk7XG5cbiAgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuXG4gICAgcHJvcHNbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxuXG4gIC8vIG1hcCBhbGlhc2VzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgYWxpYXNlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbIGkgXTtcbiAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbIGFsaWFzLnBvaW50c1RvIF07XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFsaWFzIHByb3AgZm9yIHBhcnNpbmdcbiAgICBwcm9wcy5wdXNoKCBhbGlhc1Byb3AgKTtcblxuICAgIHByb3BzWyBhbGlhcy5uYW1lIF0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5cbnN0eWZuLmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBuYW1lICl7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbIG5hbWUgXTtcbn07XG5cbnN0eWZuLmdldERlZmF1bHRQcm9wZXJ0aWVzID0gdXRpbC5tZW1vaXplKCBmdW5jdGlvbigpe1xuICB2YXIgcmF3UHJvcHMgPSB1dGlsLmV4dGVuZCgge1xuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgLy8gJ2ZvbnQtdmFyaWFudCc6IGZvbnRWYXJpYW50LFxuICAgICdmb250LXdlaWdodCc6ICdub3JtYWwnLFxuICAgICdmb250LXNpemUnOiAxNixcbiAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICd0ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICdzb3VyY2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndGFyZ2V0LXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgJ2Rpc3BsYXknOiAnZWxlbWVudCcsXG4gICAgJ29wYWNpdHknOiAxLFxuICAgICd6LWNvbXBvdW5kLWRlcHRoJzogJ2F1dG8nLFxuICAgICd6LWluZGV4LWNvbXBhcmUnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgnOiAwLFxuICAgICdsYWJlbCc6ICcnLFxuICAgICd0ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3NvdXJjZS1sYWJlbCc6ICcnLFxuICAgICdzb3VyY2UtdGV4dC1vZmZzZXQnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAndGFyZ2V0LWxhYmVsJzogJycsXG4gICAgJ3RhcmdldC10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXknOiAwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLFxuICAgICdvdmVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAnc2hhZG93LW9wYWNpdHknOiAwLFxuICAgICdzaGFkb3ctY29sb3InOiAnIzAwMCcsXG4gICAgJ3NoYWRvdy1ibHVyJzogMTAsXG4gICAgJ3NoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgJ3NoYWRvdy1vZmZzZXQteSc6IDAsXG4gICAgJ3RleHQtc2hhZG93LW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LXNoYWRvdy1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1zaGFkb3ctYmx1cic6IDUsXG4gICAgJ3RleHQtc2hhZG93LW9mZnNldC14JzogMCxcbiAgICAndGV4dC1zaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG5cbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2hlaWdodCc6IDMwLFxuICAgICd3aWR0aCc6IDMwLFxuICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTEsIC0xLCAgIDEsIC0xLCAgIDEsIDEsICAgLTEsIDEnLFxuXG4gICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAncGFkZGluZyc6IDAsXG4gICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnLFxuICAgICdtaW4td2lkdGgnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAwXG4gIH0sIHtcbiAgICAvLyBub2RlIHBpZSBiZ1xuICAgICdwaWUtc2l6ZSc6ICcxMDAlJ1xuICB9LCBbXG4gICAgeyBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ2JsYWNrJyB9LFxuICAgIHsgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLCB2YWx1ZTogJzAlJyB9LFxuICAgIHsgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLCB2YWx1ZTogMSB9XG4gIF0ucmVkdWNlKCBmdW5jdGlvbiggY3NzLCBwcm9wICl7XG4gICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gc3R5Zm4ucGllQmFja2dyb3VuZE47IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSggJ3t7aX19JywgaSApO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG5cbiAgICAgIGNzc1sgbmFtZSBdID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9ICksIHtcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAnZWRnZS1kaXN0YW5jZXMnOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICdsb29wLWRpcmVjdGlvbic6ICctMTM1ZGVnJyxcbiAgICAnbG9vcC1zd2VlcCc6ICctOTBkZWcnLFxuICAgICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJ1xuICB9LCBbXG4gICAgeyBuYW1lOiAnYXJyb3ctc2hhcGUnLCB2YWx1ZTogJ25vbmUnIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctY29sb3InLCB2YWx1ZTogJyM5OTknIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctZmlsbCcsIHZhbHVlOiAnZmlsbGVkJyB9XG4gIF0ucmVkdWNlKCBmdW5jdGlvbiggY3NzLCBwcm9wICl7XG4gICAgc3R5Zm4uYXJyb3dQcmVmaXhlcy5mb3JFYWNoKCBmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuXG4gICAgICBjc3NbIG5hbWUgXSA9IHZhbDtcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSApICk7XG5cbiAgdmFyIHBhcnNlZFByb3BzID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tpXTtcblxuICAgIGlmKCBwcm9wLnBvaW50c1RvICl7IGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICB2YXIgdmFsID0gcmF3UHJvcHNbIG5hbWUgXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbCApO1xuXG4gICAgcGFyc2VkUHJvcHNbIG5hbWUgXSA9IHBhcnNlZFByb3A7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkUHJvcHM7XG59ICk7XG5cbnN0eWZuLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgdGhpc1xuICAgIC5zZWxlY3RvciggJyRub2RlID4gbm9kZScgKSAvLyBjb21wb3VuZCAocGFyZW50KSBub2RlIHByb3BlcnRpZXNcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ3NoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgICAgICdwYWRkaW5nJzogMTAsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNlZWUnLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyNjY2MnLFxuICAgICAgICAnYm9yZGVyLXdpZHRoJzogMVxuICAgICAgfSApXG4gICAgLnNlbGVjdG9yKCAnZWRnZScgKSAvLyBqdXN0IGVkZ2UgcHJvcGVydGllc1xuICAgICAgLmNzcygge1xuICAgICAgICAnd2lkdGgnOiAzLFxuICAgICAgICAnY3VydmUtc3R5bGUnOiAnaGF5c3RhY2snXG4gICAgICB9IClcbiAgICAuc2VsZWN0b3IoICc6c2VsZWN0ZWQnIClcbiAgICAgIC5jc3MoIHtcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAgICdsaW5lLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgICAgIH0gKVxuICAgIC5zZWxlY3RvciggJ25vZGU6cGFyZW50OnNlbGVjdGVkJyApXG4gICAgICAuY3NzKCB7XG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNDQ0UxRjknLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyNhZWM4ZTUnXG4gICAgICB9IClcbiAgICAuc2VsZWN0b3IoICc6YWN0aXZlJyApXG4gICAgICAuY3NzKCB7XG4gICAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICAgICAgfSApXG4gICAgLnNlbGVjdG9yKCAnY29yZScgKSAvLyBqdXN0IGNvcmUgcHJvcGVydGllc1xuICAgICAgLmNzcygge1xuICAgICAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAgICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNVxuICAgICAgfSApXG4gIDtcblxuICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnICk7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKCAnLi4vc2VsZWN0b3InICk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG5zdHlmbi5hcHBseUZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3RyaW5nICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgdmFyIHJlbWFpbmluZyA9ICcnICsgc3RyaW5nO1xuICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gIHZhciBibG9ja1JlbTtcbiAgdmFyIHByb3BBbmRWYWxTdHI7XG5cbiAgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSggL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyApO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpe1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmKCByZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoICl7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKCBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKXtcbiAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICBpZiggYmxvY2tSZW0ubGVuZ3RoID4gcHJvcEFuZFZhbFN0ci5sZW5ndGggKXtcbiAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKCBwcm9wQW5kVmFsU3RyLmxlbmd0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlKCB0cnVlICl7XG4gICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCggL15cXHMqJC8gKTtcbiAgICBpZiggbm90aGluZ0xlZnRUb1BhcnNlICl7IGJyZWFrOyB9XG5cbiAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goIC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8gKTtcblxuICAgIGlmKCAhc2VsQW5kQmxvY2sgKXtcbiAgICAgIHV0aWwuZXJyb3IoICdIYWx0aW5nIHN0eWxlc2hlZXQgcGFyc2luZzogU3RyaW5nIHN0eWxlc2hlZXQgY29udGFpbnMgbW9yZSB0byBwYXJzZSBidXQgbm8gc2VsZWN0b3IgYW5kIGJsb2NrIGZvdW5kIGluOiAnICsgcmVtYWluaW5nICk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG4gICAgaWYoIHNlbGVjdG9yU3RyICE9PSAnY29yZScgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICAgIGlmKCBzZWxlY3Rvci5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgICAgIHV0aWwuZXJyb3IoICdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIgKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG4gICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZSB0aGUgYmxvY2sgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgdmFyIGJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMl07XG4gICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgIGJsb2NrUmVtID0gYmxvY2tTdHI7XG4gICAgdmFyIHByb3BzID0gW107XG5cbiAgICB3aGlsZSggdHJ1ZSApe1xuICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKCAvXlxccyokLyApO1xuICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKCAvXlxccyooLis/KVxccyo6XFxzKiguKz8pXFxzKjsvICk7XG5cbiAgICAgIGlmKCAhcHJvcEFuZFZhbCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIgKTtcbiAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG5cbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBwcm9wU3RyIF07XG4gICAgICBpZiggIXByb3AgKXtcbiAgICAgICAgdXRpbC5lcnJvciggJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyICk7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZSggcHJvcFN0ciwgdmFsU3RyICk7XG5cbiAgICAgIGlmKCAhcGFyc2VkUHJvcCApe1xuICAgICAgICB1dGlsLmVycm9yKCAnU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIgKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcy5wdXNoKCB7XG4gICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgIHZhbDogdmFsU3RyXG4gICAgICB9ICk7XG4gICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgIH1cblxuICAgIGlmKCBpbnZhbGlkQmxvY2sgKXtcbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG4gICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1sgaSBdO1xuICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsICk7XG4gICAgfVxuXG4gICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5zdHlmbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0cmluZyApe1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3RyaW5nICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4vaXMnICk7XG52YXIgdXRpbCA9IHJlcXVpcmUoICcuL3V0aWwnICk7XG52YXIgU3R5bGUgPSByZXF1aXJlKCAnLi9zdHlsZScgKTtcblxuLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuLy8gKHVzZWZ1bCBmb3IgaW5pdClcbnZhciBTdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgaWYoICEodGhpcyBpbnN0YW5jZW9mIFN0eWxlc2hlZXQpICl7XG4gICAgcmV0dXJuIG5ldyBTdHlsZXNoZWV0KCk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgc2hlZXRmbiA9IFN0eWxlc2hlZXQucHJvdG90eXBlO1xuXG5zaGVldGZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG5cbiAgdGhpc1sgaSBdID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICBpZiggaXMuc3RyaW5nKCBuYW1lICkgKXtcbiAgICB0aGlzWyBpIF0ucHJvcGVydGllcy5wdXNoKCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSApO1xuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBuYW1lICkgKXtcbiAgICB2YXIgbWFwID0gbmFtZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgU3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBTdHlsZS5wcm9wZXJ0aWVzWyBqIF07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7IC8vIGFsc28gdHJ5IGNhbWVsIGNhc2UgbmFtZVxuICAgICAgICBtYXBWYWwgPSBtYXBbIHV0aWwuZGFzaDJjYW1lbCggcHJvcC5uYW1lICkgXTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBtYXBWYWw7XG5cbiAgICAgICAgdGhpc1sgaSBdLnByb3BlcnRpZXMucHVzaCgge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnNoZWV0Zm4uc3R5bGUgPSBzaGVldGZuLmNzcztcblxuLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKCBjeSApO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb250ZXh0ID0gdGhpc1sgaSBdO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yICk7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzWyBqIF07XG5cbiAgICAgIHN0eWxlLmNzcyggcHJvcC5uYW1lLCBwcm9wLnZhbHVlICk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZXNoZWV0O1xuIiwiLyohIFdlYXZlciBsaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vdGxkcmxlZ2FsLmNvbS9saWNlbnNlL21pdC1saWNlbnNlKSwgY29weXJpZ2h0IE1heCBGcmFueiAqL1xuXG4vLyBjcm9zcy1lbnYgdGhyZWFkL3dvcmtlclxuLy8gTkIgOiB1c2VzIChoZWF2eXdlaWdodCkgcHJvY2Vzc2VzIG9uIG5vZGVqcyBzbyBiZXN0IG5vdCB0byBjcmVhdGUgdG9vIG1hbnkgdGhyZWFkc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCcuL3dpbmRvdycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnLi9kZWZpbmUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxudmFyIFRocmVhZCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBUaHJlYWQpICl7XG4gICAgcmV0dXJuIG5ldyBUaHJlYWQoIG9wdHMgKTtcbiAgfVxuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgcmVxdWlyZXM6IFtdLFxuICAgIGZpbGVzOiBbXSxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBwYXNzOiBbXSxcbiAgICBkaXNhYmxlZDogZmFsc2VcbiAgfTtcblxuICBpZiggaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICBpZiggb3B0cy5kaXNhYmxlZCAhPSBudWxsICl7XG4gICAgICBfcC5kaXNhYmxlZCA9ICEhb3B0cy5kaXNhYmxlZDtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIHRoZGZuID0gVGhyZWFkLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudmFyIHN0cmluZ2lmeUZpZWxkVmFsID0gZnVuY3Rpb24oIHZhbCApe1xuICB2YXIgdmFsU3RyID0gaXMuZm4oIHZhbCApID8gdmFsLnRvU3RyaW5nKCkgOiBcIkpTT04ucGFyc2UoJ1wiICsgSlNPTi5zdHJpbmdpZnkodmFsKSArIFwiJylcIjtcblxuICByZXR1cm4gdmFsU3RyO1xufTtcblxuLy8gYWxsb3dzIGZvciByZXF1aXJlcyB3aXRoIHByb3RvdHlwZXMgYW5kIHN1Ym9ianMgZXRjXG52YXIgZm5Bc1JlcXVpcmUgPSBmdW5jdGlvbiggZm4gKXtcbiAgdmFyIHJlcTtcbiAgdmFyIGZuTmFtZTtcblxuICBpZiggaXMub2JqZWN0KGZuKSAmJiBmbi5mbiApeyAvLyBtYW51YWwgZm5cbiAgICByZXEgPSBmbkFzKCBmbi5mbiwgZm4ubmFtZSApO1xuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgZm4gPSBmbi5mbjtcbiAgfSBlbHNlIGlmKCBpcy5mbihmbikgKXsgLy8gYXV0byBmblxuICAgIHJlcSA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoZm4pICl7IC8vIHN0cmluZ2lmaWVkIGZuXG4gICAgcmVxID0gZm47XG4gIH0gZWxzZSBpZiggaXMub2JqZWN0KGZuKSApeyAvLyBwbGFpbiBvYmplY3RcbiAgICBpZiggZm4ucHJvdG8gKXtcbiAgICAgIHJlcSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXEgPSBmbi5uYW1lICsgJyA9IHt9Oyc7XG4gICAgfVxuXG4gICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICBmbiA9IGZuLm9iajtcbiAgfVxuXG4gIHJlcSArPSAnXFxuJztcblxuICB2YXIgcHJvdG9yZXEgPSBmdW5jdGlvbiggdmFsLCBzdWJuYW1lICl7XG4gICAgaWYoIHZhbC5wcm90b3R5cGUgKXtcbiAgICAgIHZhciBwcm90b05vbmVtcHR5ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBwcm9wIGluIHZhbC5wcm90b3R5cGUgKXsgcHJvdG9Ob25lbXB0eSA9IHRydWU7IGJyZWFrOyB9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICBpZiggcHJvdG9Ob25lbXB0eSApe1xuICAgICAgICByZXEgKz0gZm5Bc1JlcXVpcmUoIHtcbiAgICAgICAgICBuYW1lOiBzdWJuYW1lLFxuICAgICAgICAgIG9iajogdmFsLFxuICAgICAgICAgIHByb3RvOiB0cnVlXG4gICAgICAgIH0sIHZhbCApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBwdWxsIGluIHByb3RvdHlwZVxuICBpZiggZm4ucHJvdG90eXBlICYmIGZuTmFtZSAhPSBudWxsICl7XG5cbiAgICBmb3IoIHZhciBuYW1lIGluIGZuLnByb3RvdHlwZSApe1xuICAgICAgdmFyIHByb3RvU3RyID0gJyc7XG5cbiAgICAgIHZhciB2YWwgPSBmbi5wcm90b3R5cGVbIG5hbWUgXTtcbiAgICAgIHZhciB2YWxTdHIgPSBzdHJpbmdpZnlGaWVsZFZhbCggdmFsICk7XG4gICAgICB2YXIgc3VibmFtZSA9IGZuTmFtZSArICcucHJvdG90eXBlLicgKyBuYW1lO1xuXG4gICAgICBwcm90b1N0ciArPSBzdWJuYW1lICsgJyA9ICcgKyB2YWxTdHIgKyAnO1xcbic7XG5cbiAgICAgIGlmKCBwcm90b1N0ciApe1xuICAgICAgICByZXEgKz0gcHJvdG9TdHI7XG4gICAgICB9XG5cbiAgICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gICAgfVxuXG4gIH1cblxuICAvLyBwdWxsIGluIHByb3BlcnRpZXMgZm9yIG9iai9mbnNcbiAgaWYoICFpcy5zdHJpbmcoZm4pICl7IGZvciggdmFyIG5hbWUgaW4gZm4gKXtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJztcblxuICAgIGlmKCBmbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSApe1xuICAgICAgdmFyIHZhbCA9IGZuWyBuYW1lIF07XG4gICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnW1wiJyArIG5hbWUgKyAnXCJdJztcblxuICAgICAgcHJvcHNTdHIgKz0gc3VibmFtZSArICcgPSAnICsgdmFsU3RyICsgJztcXG4nO1xuICAgIH1cblxuICAgIGlmKCBwcm9wc1N0ciApe1xuICAgICAgcmVxICs9IHByb3BzU3RyO1xuICAgIH1cblxuICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gIH0gfVxuXG4gIHJldHVybiByZXE7XG59O1xuXG52YXIgaXNQYXRoU3RyID0gZnVuY3Rpb24oIHN0ciApe1xuICByZXR1cm4gaXMuc3RyaW5nKHN0cikgJiYgc3RyLm1hdGNoKC9cXC5qcyQvKTtcbn07XG5cbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAndGhyZWFkJzsgfSxcblxuICByZXF1aXJlOiBmdW5jdGlvbiggZm4sIGFzICl7XG4gICAgdmFyIHJlcXVpcmVzID0gdGhpcy5fcHJpdmF0ZS5yZXF1aXJlcztcblxuICAgIGlmKCBpc1BhdGhTdHIoZm4pICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmZpbGVzLnB1c2goIGZuICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmKCBhcyApe1xuICAgICAgaWYoIGlzLmZuKGZuKSApe1xuICAgICAgICBmbiA9IHsgbmFtZTogYXMsIGZuOiBmbiB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBvYmo6IGZuIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBpcy5mbihmbikgKXtcbiAgICAgICAgaWYoICFmbi5uYW1lICl7XG4gICAgICAgICAgdGhyb3cgJ1RoZSBmdW5jdGlvbiBuYW1lIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQuICBVc2UgdGhyZWFkLnJlcXVpcmUoIHNvbWVGdW5jdGlvbiwgXCJzb21lRnVuY3Rpb25cIiApJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0geyBuYW1lOiBmbi5uYW1lLCBmbjogZm4gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1aXJlcy5wdXNoKCBmbiApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICB0aGlzLl9wcml2YXRlLnBhc3MucHVzaCggZGF0YSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcnVuOiBmdW5jdGlvbiggZm4sIHBhc3MgKXsgLy8gZm4gdXNlZCBsaWtlIG1haW4oKVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHBhc3MgPSBwYXNzIHx8IF9wLnBhc3Muc2hpZnQoKTtcblxuICAgIGlmKCBfcC5zdG9wcGVkICl7XG4gICAgICB0aHJvdyAnQXR0ZW1wdGVkIHRvIHJ1biBhIHN0b3BwZWQgdGhyZWFkISAgU3RhcnQgYSBuZXcgdGhyZWFkIG9yIGRvIG5vdCBzdG9wIHRoZSBleGlzdGluZyB0aHJlYWQgYW5kIHJldXNlIGl0Lic7XG4gICAgfVxuXG4gICAgaWYoIF9wLnJ1bm5pbmcgKXtcbiAgICAgIHJldHVybiAoIF9wLnF1ZXVlID0gX3AucXVldWUudGhlbihmdW5jdGlvbigpeyAvLyBpbmR1Y3RpdmUgc3RlcFxuICAgICAgICByZXR1cm4gc2VsZi5ydW4oIGZuLCBwYXNzICk7XG4gICAgICB9KSApO1xuICAgIH1cblxuICAgIHZhciB1c2VXVyA9IHdpbmRvdyAhPSBudWxsICYmICFfcC5kaXNhYmxlZDtcbiAgICB2YXIgdXNlTm9kZSA9ICF3aW5kb3cgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9wLmRpc2FibGVkO1xuXG4gICAgc2VsZi50cmlnZ2VyKCdydW4nKTtcblxuICAgIHZhciBydW5QID0gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuXG4gICAgICBfcC5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgdmFyIHRocmVhZFRlY2hBbHJlYWR5RXhpc3RzID0gX3AucmFuO1xuXG4gICAgICB2YXIgZm5JbXBsU3RyID0gaXMuc3RyaW5nKCBmbiApID8gZm4gOiBmbi50b1N0cmluZygpO1xuXG4gICAgICAvLyB3b3JrZXIgY29kZSB0byBleGVjXG4gICAgICB2YXIgZm5TdHIgPSAnXFxuJyArICggX3AucmVxdWlyZXMubWFwKGZ1bmN0aW9uKCByICl7XG4gICAgICAgIHJldHVybiBmbkFzUmVxdWlyZSggciApO1xuICAgICAgfSkgKS5jb25jYXQoIF9wLmZpbGVzLm1hcChmdW5jdGlvbiggZiApe1xuICAgICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgICB2YXIgd3dpZnlGaWxlID0gZnVuY3Rpb24oIGZpbGUgKXtcbiAgICAgICAgICAgIGlmKCBmaWxlLm1hdGNoKC9eXFwuXFwvLykgfHwgZmlsZS5tYXRjaCgvXlxcLlxcLi8pICl7XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgZmlsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggZmlsZS5tYXRjaCgvXlxcLy8pICl7XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gJ2ltcG9ydFNjcmlwdHMoXCInICsgd3dpZnlGaWxlKGYpICsgJ1wiKTsnO1xuICAgICAgICB9IGVsc2UgaWYoIHVzZU5vZGUgKSB7XG4gICAgICAgICAgcmV0dXJuICdldmFsKCByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKFwiJyArIGYgKyAnXCIsIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pICk7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAnRXh0ZXJuYWwgZmlsZSBgJyArIGYgKyAnYCBjYW4gbm90IGJlIHJlcXVpcmVkIHdpdGhvdXQgYW55IHRocmVhZGluZyB0ZWNobm9sb2d5Lic7XG4gICAgICAgIH1cbiAgICAgIH0pICkuY29uY2F0KFtcbiAgICAgICAgJyggZnVuY3Rpb24oKXsnLFxuICAgICAgICAgICd2YXIgcmV0ID0gKCcgKyBmbkltcGxTdHIgKyAnKSgnICsgSlNPTi5zdHJpbmdpZnkocGFzcykgKyAnKTsnLFxuICAgICAgICAgICdpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgcmVzb2x2ZShyZXQpOyB9JywgLy8gYXNzdW1lIGlmIHJhbiBmbiByZXR1cm5zIGRlZmluZWQgdmFsdWUgKGluY2wuIG51bGwpLCB0aGF0IHdlIHdhbnQgdG8gcmVzb2x2ZSB0byBpdFxuICAgICAgICAnfSApKClcXG4nXG4gICAgICBdKS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gYmVjYXVzZSB3ZSd2ZSBub3cgY29uc3VtZWQgdGhlIHJlcXVpcmVzLCBlbXB0eSB0aGUgbGlzdCBzbyB3ZSBkb24ndCBkdXBlIG9uIG5leHQgcnVuKClcbiAgICAgIF9wLnJlcXVpcmVzID0gW107XG4gICAgICBfcC5maWxlcyA9IFtdO1xuXG4gICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgdmFyIGZuQmxvYiwgZm5Vcmw7XG5cbiAgICAgICAgLy8gYWRkIG5vcm1hbGlzZWQgdGhyZWFkIGFwaSBmdW5jdGlvbnNcbiAgICAgICAgaWYoICF0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApe1xuICAgICAgICAgIHZhciBmblByZSA9IGZuU3RyICsgJyc7XG5cbiAgICAgICAgICBmblN0ciA9IFtcbiAgICAgICAgICAgICdmdW5jdGlvbiBfcmVmXyhvKXsgcmV0dXJuIGV2YWwobyk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsIC8vIGFsaWFzXG4gICAgICAgICAgICAnZnVuY3Rpb24gbWVzc2FnZShtKXsgcG9zdE1lc3NhZ2UobSk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiBsaXN0ZW4oZm4peycsXG4gICAgICAgICAgICAnICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAnLFxuICAgICAgICAgICAgJyAgICBpZiggdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgKG0uZGF0YS4kJGV2YWwgfHwgbS5kYXRhID09PSBcIiQkc3RhcnRcIikgKXsnLFxuICAgICAgICAgICAgJyAgICB9IGVsc2UgeyAnLFxuICAgICAgICAgICAgJyAgICAgIGZuKCBtLmRhdGEgKTsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgIH0pOycsXG4gICAgICAgICAgICAnfTsnLFxuICAgICAgICAgICAgJ3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24obSl7ICBpZiggbS5kYXRhLiQkZXZhbCApeyBldmFsKCBtLmRhdGEuJCRldmFsICk7IH0gIH0pOycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZSh2KXsgcG9zdE1lc3NhZ2UoeyAkJHJlc29sdmU6IHYgfSk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiByZWplY3Qodil7IHBvc3RNZXNzYWdlKHsgJCRyZWplY3Q6IHYgfSk7IH07J1xuICAgICAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgICAgICBmblN0ciArPSBmblByZTtcblxuICAgICAgICAgIGZuQmxvYiA9IG5ldyBCbG9iKFsgZm5TdHIgXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm5VcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggZm5CbG9iICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHdlYndvcmtlciBhbmQgbGV0IGl0IGV4ZWMgdGhlIHNlcmlhbGlzZWQgY29kZVxuICAgICAgICB2YXIgd3cgPSBfcC53ZWJ3b3JrZXIgPSBfcC53ZWJ3b3JrZXIgfHwgbmV3IFdvcmtlciggZm5VcmwgKTtcblxuICAgICAgICBpZiggdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXsgLy8gdGhlbiBqdXN0IGV4ZWMgbmV3IHJ1bigpIGNvZGVcbiAgICAgICAgICB3dy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3b3JrZXIgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgd3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiID0gZnVuY3Rpb24oIG0gKXtcbiAgICAgICAgICB2YXIgaXNPYmplY3QgPSBpcy5vYmplY3QobSkgJiYgaXMub2JqZWN0KCBtLmRhdGEgKTtcblxuICAgICAgICAgIGlmKCBpc09iamVjdCAmJiAoJyQkcmVzb2x2ZScgaW4gbS5kYXRhKSApe1xuICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlc29sdmUoKVxuXG4gICAgICAgICAgICByZXNvbHZlKCBtLmRhdGEuJCRyZXNvbHZlICk7XG4gICAgICAgICAgfSBlbHNlIGlmKCBpc09iamVjdCAmJiAoJyQkcmVqZWN0JyBpbiBtLmRhdGEpICl7XG4gICAgICAgICAgICB3dy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVqZWN0KClcblxuICAgICAgICAgICAgcmVqZWN0KCBtLmRhdGEuJCRyZWplY3QgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCBuZXcgRXZlbnQobSwgeyB0eXBlOiAnbWVzc2FnZScsIG1lc3NhZ2U6IG0uZGF0YSB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGlmKCAhdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXtcbiAgICAgICAgICB3dy5wb3N0TWVzc2FnZSgnJCRzdGFydCcpOyAvLyBzdGFydCB1cCB0aGUgd29ya2VyXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICl7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9jZXNzXG5cbiAgICAgICAgaWYoICFfcC5jaGlsZCApe1xuICAgICAgICAgIF9wLmNoaWxkID0gKCByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZm9yayggcmVxdWlyZSgncGF0aCcpLmpvaW4oX19kaXJuYW1lLCAndGhyZWFkLW5vZGUtZm9yaycpICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IF9wLmNoaWxkO1xuXG4gICAgICAgIC8vIGNoaWxkIHByb2Nlc3MgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgY2hpbGQub24oJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgaWYoIGlzLm9iamVjdChtKSAmJiAoJyQkcmVzb2x2ZScgaW4gbSkgKXtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVzb2x2ZSgpXG5cbiAgICAgICAgICAgIHJlc29sdmUoIG0uJCRyZXNvbHZlICk7XG4gICAgICAgICAgfSBlbHNlIGlmKCBpcy5vYmplY3QobSkgJiYgKCckJHJlamVjdCcgaW4gbSkgKXtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVqZWN0KClcblxuICAgICAgICAgICAgcmVqZWN0KCBtLiQkcmVqZWN0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3IEV2ZW50KHt9LCB7IHR5cGU6ICdtZXNzYWdlJywgbWVzc2FnZTogbSB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXNrIHRoZSBjaGlsZCBwcm9jZXNzIHRvIGV2YWwgdGhlIHdvcmtlciBjb2RlXG4gICAgICAgIGNoaWxkLnNlbmQoe1xuICAgICAgICAgICQkZXZhbDogZm5TdHJcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIHVzZSBhIGZhbGxiYWNrIG1lY2hhbmlzbSB1c2luZyBhIHRpbWVvdXRcblxuICAgICAgICB2YXIgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB2YXIgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcblxuICAgICAgICB2YXIgdGltZXIgPSBfcC50aW1lciA9IF9wLnRpbWVyIHx8IHtcblxuICAgICAgICAgIGxpc3RlbmVyczogW10sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gYXMgYSBzdHJpbmcgc28gaXQgY2FuJ3QgYmUgbWFuZ2xlZCBieSBtaW5pZmllcnMgYW5kIHByb2Nlc3NvcnNcbiAgICAgICAgICAgIGZuU3RyID0gW1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gX3JlZl8obyl7IHJldHVybiBldmFsKG8pOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBtZXNzYWdlKG0peyBzZWxmLnRyaWdnZXIoIG5ldyBFdmVudCh7fSwgeyB0eXBlOiBcIm1lc3NhZ2VcIiwgbWVzc2FnZTogbSB9KSApOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBsaXN0ZW4oZm4peyB0aW1lci5saXN0ZW5lcnMucHVzaCggZm4gKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZSh2KXsgcHJvbWlzZVJlc29sdmUodik7IH07JyxcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlamVjdCh2KXsgcHJvbWlzZVJlamVjdCh2KTsgfTsnXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpICsgZm5TdHI7XG5cbiAgICAgICAgICAgIC8vIHRoZSAucnVuKCkgY29kZVxuICAgICAgICAgICAgZXZhbCggZm5TdHIgKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgICB2YXIgbHMgPSB0aW1lci5saXN0ZW5lcnM7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGZuID0gbHNbaV07XG5cbiAgICAgICAgICAgICAgZm4oIG0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aW1lci5leGVjKCk7XG4gICAgICB9XG5cbiAgICB9KS50aGVuKGZ1bmN0aW9uKCB2ICl7XG4gICAgICBfcC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBfcC5yYW4gPSB0cnVlO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ3JhbicpO1xuXG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcblxuICAgIGlmKCBfcC5xdWV1ZSA9PSBudWxsICl7XG4gICAgICBfcC5xdWV1ZSA9IHJ1blA7IC8vIGkuZS4gZmlyc3Qgc3RlcCBvZiBpbmR1Y3RpdmUgcHJvbWlzZSBjaGFpbiAoZm9yIHF1ZXVlKVxuICAgIH1cblxuICAgIHJldHVybiBydW5QO1xuICB9LFxuXG4gIC8vIHNlbmQgdGhlIHRocmVhZCBhIG1lc3NhZ2VcbiAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgX3Aud2Vid29ya2VyLnBvc3RNZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgaWYoIF9wLmNoaWxkICl7XG4gICAgICBfcC5jaGlsZC5zZW5kKCBtICk7XG4gICAgfVxuXG4gICAgaWYoIF9wLnRpbWVyICl7XG4gICAgICBfcC50aW1lci5tZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgX3Aud2Vid29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGlmKCBfcC5jaGlsZCApe1xuICAgICAgX3AuY2hpbGQua2lsbCgpO1xuICAgIH1cblxuICAgIGlmKCBfcC50aW1lciApe1xuICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8gaWYgd2UndmUgcnVuIGEgdGltZW91dFxuICAgIH1cblxuICAgIF9wLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHN0b3BwZWQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3RvcHBlZDtcbiAgfVxuXG59KTtcblxuLy8gdHVybnMgYSBzdHJpbmdpZmllZCBmdW5jdGlvbiBpbnRvIGEgKHJlKW5hbWVkIGZ1bmN0aW9uXG52YXIgZm5BcyA9IGZ1bmN0aW9uKCBmbiwgbmFtZSApe1xuICB2YXIgZm5TdHIgPSBmbi50b1N0cmluZygpO1xuICBmblN0ciA9IGZuU3RyLnJlcGxhY2UoL2Z1bmN0aW9uXFxzKj9cXFMqP1xccyo/XFwoLywgJ2Z1bmN0aW9uICcgKyBuYW1lICsgJygnKTtcblxuICByZXR1cm4gZm5TdHI7XG59O1xuXG52YXIgZGVmaW5lRm5hbCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBmbmFsSW1wbCggZm4sIGFyZzEgKXtcbiAgICB2YXIgZm5TdHIgPSBmbkFzKCBmbiwgJ18kXyRfJyArIG9wdHMubmFtZSApO1xuXG4gICAgdGhpcy5yZXF1aXJlKCBmblN0ciApO1xuXG4gICAgcmV0dXJuIHRoaXMucnVuKCBbXG4gICAgICAnZnVuY3Rpb24oIGRhdGEgKXsnLFxuICAgICAgJyAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsnLFxuICAgICAgJyAgdmFyIHJlcyA9IFtdOycsXG4gICAgICAnICAnLFxuICAgICAgJyAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXsnLFxuICAgICAgJyAgICByZXMucHVzaCggdmFsICk7JyxcbiAgICAgICcgIH07JyxcbiAgICAgICcgICcsXG4gICAgICAnICB2YXIgcmV0ID0gZGF0YS4nICsgb3B0cy5uYW1lICsgJyggXyRfJF8nICsgb3B0cy5uYW1lICsgKCBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICcsICcgKyBKU09OLnN0cmluZ2lmeShhcmcxKSA6ICcnICkgKyAnICk7JyxcbiAgICAgICcgICcsXG4gICAgICAnICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7JyxcbiAgICAgICcgIHJlc29sdmUoIHJlcy5sZW5ndGggPiAwID8gcmVzIDogcmV0ICk7JyxcbiAgICAgICd9J1xuICAgIF0uam9pbignXFxuJykgKTtcbiAgfTtcbn07XG5cbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG4gIHJlZHVjZTogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2UnIH0pLFxuXG4gIHJlZHVjZVJpZ2h0OiBkZWZpbmVGbmFsKHsgbmFtZTogJ3JlZHVjZVJpZ2h0JyB9KSxcblxuICBtYXA6IGRlZmluZUZuYWwoeyBuYW1lOiAnbWFwJyB9KVxufSk7XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IHRoZGZuO1xuZm4ucHJvbWlzZSA9IGZuLnJ1bjtcbmZuLnRlcm1pbmF0ZSA9IGZuLmhhbHQgPSBmbi5zdG9wO1xuZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbi8vIHB1bGwgaW4gZXZlbnQgYXBpc1xudXRpbC5leHRlbmQodGhkZm4sIHtcbiAgb246IGRlZmluZS5vbigpLFxuICBvbmU6IGRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gIG9mZjogZGVmaW5lLm9mZigpLFxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCB0aGRmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVhZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZ2V0IFtyLCBnLCBiXSBmcm9tICNhYmMgb3IgI2FhYmJjY1xuICBoZXgydHVwbGU6IGZ1bmN0aW9uKCBoZXggKXtcbiAgICBpZiggIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gJyMnICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICB2YXIgciwgZywgYjtcbiAgICB2YXIgYmFzZSA9IDE2O1xuXG4gICAgaWYoIHNob3J0SGV4ICl7XG4gICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsxXSwgYmFzZSApO1xuICAgICAgZyA9IHBhcnNlSW50KCBoZXhbMl0gKyBoZXhbMl0sIGJhc2UgKTtcbiAgICAgIGIgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzNdLCBiYXNlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICBnID0gcGFyc2VJbnQoIGhleFszXSArIGhleFs0XSwgYmFzZSApO1xuICAgICAgYiA9IHBhcnNlSW50KCBoZXhbNV0gKyBoZXhbNl0sIGJhc2UgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWyByLCBnLCBiIF07XG4gIH0sXG5cbiAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG4gIGhzbDJ0dXBsZTogZnVuY3Rpb24oIGhzbCApe1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gICAgZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApe1xuICAgICAgaWYoIHQgPCAwICkgdCArPSAxO1xuICAgICAgaWYoIHQgPiAxICkgdCAtPSAxO1xuICAgICAgaWYoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuICAgICAgaWYoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBtID0gbmV3IFJlZ0V4cCggJ14nICsgdGhpcy5yZWdleC5oc2xhICsgJyQnICkuZXhlYyggaHNsICk7XG4gICAgaWYoIG0gKXtcblxuICAgICAgLy8gZ2V0IGh1ZVxuICAgICAgaCA9IHBhcnNlSW50KCBtWzFdICk7XG4gICAgICBpZiggaCA8IDAgKXtcbiAgICAgICAgaCA9ICggMzYwIC0gKC0xICogaCAlIDM2MCkgKSAlIDM2MDtcbiAgICAgIH0gZWxzZSBpZiggaCA+IDM2MCApe1xuICAgICAgICBoID0gaCAlIDM2MDtcbiAgICAgIH1cbiAgICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIHMgPSBwYXJzZUZsb2F0KCBtWzJdICk7XG4gICAgICBpZiggcyA8IDAgfHwgcyA+IDEwMCApeyByZXR1cm47IH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgbCA9IHBhcnNlRmxvYXQoIG1bM10gKTtcbiAgICAgIGlmKCBsIDwgMCB8fCBsID4gMTAwICl7IHJldHVybjsgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cbiAgICAgIGwgPSBsIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGEgPSBtWzRdO1xuICAgICAgaWYoIGEgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBhID0gcGFyc2VGbG9hdCggYSApO1xuXG4gICAgICAgIGlmKCBhIDwgMCB8fCBhID4gMSApeyByZXR1cm47IH0gLy8gYWxwaGEgaXMgWzAsIDFdXG4gICAgICB9XG5cbiAgICAgIC8vIG5vdywgY29udmVydCB0byByZ2JcbiAgICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG4gICAgICBpZiggcyA9PT0gMCApe1xuICAgICAgICByID0gZyA9IGIgPSBNYXRoLnJvdW5kKCBsICogMjU1ICk7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKCBwLCBxLCBoICsgMSAvIDMgKSApO1xuICAgICAgICBnID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYiggcCwgcSwgaCApICk7XG4gICAgICAgIGIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKCBwLCBxLCBoIC0gMSAvIDMgKSApO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBbIHIsIGcsIGIsIGEgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuICByZ2IydHVwbGU6IGZ1bmN0aW9uKCByZ2IgKXtcbiAgICB2YXIgcmV0O1xuXG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKCAnXicgKyB0aGlzLnJlZ2V4LnJnYmEgKyAnJCcgKS5leGVjKCByZ2IgKTtcbiAgICBpZiggbSApe1xuICAgICAgcmV0ID0gW107XG5cbiAgICAgIHZhciBpc1BjdCA9IFtdO1xuICAgICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gMzsgaSsrICl7XG4gICAgICAgIHZhciBjaGFubmVsID0gbVsgaSBdO1xuXG4gICAgICAgIGlmKCBjaGFubmVsWyBjaGFubmVsLmxlbmd0aCAtIDEgXSA9PT0gJyUnICl7XG4gICAgICAgICAgaXNQY3RbIGkgXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoIGNoYW5uZWwgKTtcblxuICAgICAgICBpZiggaXNQY3RbIGkgXSApe1xuICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsIC8gMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1ICl7IHJldHVybjsgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuICAgICAgICByZXQucHVzaCggTWF0aC5mbG9vciggY2hhbm5lbCApICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcbiAgICAgIGlmKCBhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCApeyByZXR1cm47IH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgICBpZiggYWxwaGEgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoIGFscGhhICk7XG5cbiAgICAgICAgaWYoIGFscGhhIDwgMCB8fCBhbHBoYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgICByZXQucHVzaCggYWxwaGEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGNvbG9ybmFtZTJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JzWyBjb2xvci50b0xvd2VyQ2FzZSgpIF07XG4gIH0sXG5cbiAgY29sb3IydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgIHJldHVybiAoIGlzLmFycmF5KCBjb2xvciApID8gY29sb3IgOiBudWxsIClcbiAgICAgIHx8IHRoaXMuY29sb3JuYW1lMnR1cGxlKCBjb2xvciApXG4gICAgICB8fCB0aGlzLmhleDJ0dXBsZSggY29sb3IgKVxuICAgICAgfHwgdGhpcy5yZ2IydHVwbGUoIGNvbG9yIClcbiAgICAgIHx8IHRoaXMuaHNsMnR1cGxlKCBjb2xvciApO1xuICB9LFxuXG4gIGNvbG9yczoge1xuICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSwgLy8gTkIgYWxwaGEgPT09IDBcblxuICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgIGFsaWNlYmx1ZTogWyAyNDAsIDI0OCwgMjU1IF0sXG4gICAgYW50aXF1ZXdoaXRlOiBbIDI1MCwgMjM1LCAyMTUgXSxcbiAgICBhcXVhOiBbMCwgMjU1LCAyNTUgXSxcbiAgICBhcXVhbWFyaW5lOiBbIDEyNywgMjU1LCAyMTIgXSxcbiAgICBhenVyZTogWyAyNDAsIDI1NSwgMjU1IF0sXG4gICAgYmVpZ2U6IFsgMjQ1LCAyNDUsIDIyMCBdLFxuICAgIGJpc3F1ZTogWyAyNTUsIDIyOCwgMTk2IF0sXG4gICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICBibGFuY2hlZGFsbW9uZDogWyAyNTUsIDIzNSwgMjA1IF0sXG4gICAgYmx1ZTogWzAsIDAsIDI1NSBdLFxuICAgIGJsdWV2aW9sZXQ6IFsgMTM4LCA0MywgMjI2IF0sXG4gICAgYnJvd246IFsgMTY1LCA0MiwgNDIgXSxcbiAgICBidXJseXdvb2Q6IFsgMjIyLCAxODQsIDEzNSBdLFxuICAgIGNhZGV0Ymx1ZTogWyA5NSwgMTU4LCAxNjAgXSxcbiAgICBjaGFydHJldXNlOiBbIDEyNywgMjU1LCAwXSxcbiAgICBjaG9jb2xhdGU6IFsgMjEwLCAxMDUsIDMwIF0sXG4gICAgY29yYWw6IFsgMjU1LCAxMjcsIDgwIF0sXG4gICAgY29ybmZsb3dlcmJsdWU6IFsgMTAwLCAxNDksIDIzNyBdLFxuICAgIGNvcm5zaWxrOiBbIDI1NSwgMjQ4LCAyMjAgXSxcbiAgICBjcmltc29uOiBbIDIyMCwgMjAsIDYwIF0sXG4gICAgY3lhbjogWzAsIDI1NSwgMjU1IF0sXG4gICAgZGFya2JsdWU6IFswLCAwLCAxMzkgXSxcbiAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5IF0sXG4gICAgZGFya2dvbGRlbnJvZDogWyAxODQsIDEzNCwgMTEgXSxcbiAgICBkYXJrZ3JheTogWyAxNjksIDE2OSwgMTY5IF0sXG4gICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICBkYXJrZ3JleTogWyAxNjksIDE2OSwgMTY5IF0sXG4gICAgZGFya2toYWtpOiBbIDE4OSwgMTgzLCAxMDcgXSxcbiAgICBkYXJrbWFnZW50YTogWyAxMzksIDAsIDEzOSBdLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBbIDg1LCAxMDcsIDQ3IF0sXG4gICAgZGFya29yYW5nZTogWyAyNTUsIDE0MCwgMF0sXG4gICAgZGFya29yY2hpZDogWyAxNTMsIDUwLCAyMDQgXSxcbiAgICBkYXJrcmVkOiBbIDEzOSwgMCwgMF0sXG4gICAgZGFya3NhbG1vbjogWyAyMzMsIDE1MCwgMTIyIF0sXG4gICAgZGFya3NlYWdyZWVuOiBbIDE0MywgMTg4LCAxNDMgXSxcbiAgICBkYXJrc2xhdGVibHVlOiBbIDcyLCA2MSwgMTM5IF0sXG4gICAgZGFya3NsYXRlZ3JheTogWyA0NywgNzksIDc5IF0sXG4gICAgZGFya3NsYXRlZ3JleTogWyA0NywgNzksIDc5IF0sXG4gICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5IF0sXG4gICAgZGFya3Zpb2xldDogWyAxNDgsIDAsIDIxMSBdLFxuICAgIGRlZXBwaW5rOiBbIDI1NSwgMjAsIDE0NyBdLFxuICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTUgXSxcbiAgICBkaW1ncmF5OiBbIDEwNSwgMTA1LCAxMDUgXSxcbiAgICBkaW1ncmV5OiBbIDEwNSwgMTA1LCAxMDUgXSxcbiAgICBkb2RnZXJibHVlOiBbIDMwLCAxNDQsIDI1NSBdLFxuICAgIGZpcmVicmljazogWyAxNzgsIDM0LCAzNCBdLFxuICAgIGZsb3JhbHdoaXRlOiBbIDI1NSwgMjUwLCAyNDAgXSxcbiAgICBmb3Jlc3RncmVlbjogWyAzNCwgMTM5LCAzNCBdLFxuICAgIGZ1Y2hzaWE6IFsgMjU1LCAwLCAyNTUgXSxcbiAgICBnYWluc2Jvcm86IFsgMjIwLCAyMjAsIDIyMCBdLFxuICAgIGdob3N0d2hpdGU6IFsgMjQ4LCAyNDgsIDI1NSBdLFxuICAgIGdvbGQ6IFsgMjU1LCAyMTUsIDBdLFxuICAgIGdvbGRlbnJvZDogWyAyMTgsIDE2NSwgMzIgXSxcbiAgICBncmF5OiBbIDEyOCwgMTI4LCAxMjggXSxcbiAgICBncmV5OiBbIDEyOCwgMTI4LCAxMjggXSxcbiAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgZ3JlZW55ZWxsb3c6IFsgMTczLCAyNTUsIDQ3IF0sXG4gICAgaG9uZXlkZXc6IFsgMjQwLCAyNTUsIDI0MCBdLFxuICAgIGhvdHBpbms6IFsgMjU1LCAxMDUsIDE4MCBdLFxuICAgIGluZGlhbnJlZDogWyAyMDUsIDkyLCA5MiBdLFxuICAgIGluZGlnbzogWyA3NSwgMCwgMTMwIF0sXG4gICAgaXZvcnk6IFsgMjU1LCAyNTUsIDI0MCBdLFxuICAgIGtoYWtpOiBbIDI0MCwgMjMwLCAxNDAgXSxcbiAgICBsYXZlbmRlcjogWyAyMzAsIDIzMCwgMjUwIF0sXG4gICAgbGF2ZW5kZXJibHVzaDogWyAyNTUsIDI0MCwgMjQ1IF0sXG4gICAgbGF3bmdyZWVuOiBbIDEyNCwgMjUyLCAwXSxcbiAgICBsZW1vbmNoaWZmb246IFsgMjU1LCAyNTAsIDIwNSBdLFxuICAgIGxpZ2h0Ymx1ZTogWyAxNzMsIDIxNiwgMjMwIF0sXG4gICAgbGlnaHRjb3JhbDogWyAyNDAsIDEyOCwgMTI4IF0sXG4gICAgbGlnaHRjeWFuOiBbIDIyNCwgMjU1LCAyNTUgXSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWyAyNTAsIDI1MCwgMjEwIF0sXG4gICAgbGlnaHRncmF5OiBbIDIxMSwgMjExLCAyMTEgXSxcbiAgICBsaWdodGdyZWVuOiBbIDE0NCwgMjM4LCAxNDQgXSxcbiAgICBsaWdodGdyZXk6IFsgMjExLCAyMTEsIDIxMSBdLFxuICAgIGxpZ2h0cGluazogWyAyNTUsIDE4MiwgMTkzIF0sXG4gICAgbGlnaHRzYWxtb246IFsgMjU1LCAxNjAsIDEyMiBdLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFsgMzIsIDE3OCwgMTcwIF0sXG4gICAgbGlnaHRza3libHVlOiBbIDEzNSwgMjA2LCAyNTAgXSxcbiAgICBsaWdodHNsYXRlZ3JheTogWyAxMTksIDEzNiwgMTUzIF0sXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBbIDE3NiwgMTk2LCAyMjIgXSxcbiAgICBsaWdodHllbGxvdzogWyAyNTUsIDI1NSwgMjI0IF0sXG4gICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgbGltZWdyZWVuOiBbIDUwLCAyMDUsIDUwIF0sXG4gICAgbGluZW46IFsgMjUwLCAyNDAsIDIzMCBdLFxuICAgIG1hZ2VudGE6IFsgMjU1LCAwLCAyNTUgXSxcbiAgICBtYXJvb246IFsgMTI4LCAwLCAwXSxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBbIDEwMiwgMjA1LCAxNzAgXSxcbiAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1IF0sXG4gICAgbWVkaXVtb3JjaGlkOiBbIDE4NiwgODUsIDIxMSBdLFxuICAgIG1lZGl1bXB1cnBsZTogWyAxNDcsIDExMiwgMjE5IF0sXG4gICAgbWVkaXVtc2VhZ3JlZW46IFsgNjAsIDE3OSwgMTEzIF0sXG4gICAgbWVkaXVtc2xhdGVibHVlOiBbIDEyMywgMTA0LCAyMzggXSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0IF0sXG4gICAgbWVkaXVtdHVycXVvaXNlOiBbIDcyLCAyMDksIDIwNCBdLFxuICAgIG1lZGl1bXZpb2xldHJlZDogWyAxOTksIDIxLCAxMzMgXSxcbiAgICBtaWRuaWdodGJsdWU6IFsgMjUsIDI1LCAxMTIgXSxcbiAgICBtaW50Y3JlYW06IFsgMjQ1LCAyNTUsIDI1MCBdLFxuICAgIG1pc3R5cm9zZTogWyAyNTUsIDIyOCwgMjI1IF0sXG4gICAgbW9jY2FzaW46IFsgMjU1LCAyMjgsIDE4MSBdLFxuICAgIG5hdmFqb3doaXRlOiBbIDI1NSwgMjIyLCAxNzMgXSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4IF0sXG4gICAgb2xkbGFjZTogWyAyNTMsIDI0NSwgMjMwIF0sXG4gICAgb2xpdmU6IFsgMTI4LCAxMjgsIDBdLFxuICAgIG9saXZlZHJhYjogWyAxMDcsIDE0MiwgMzUgXSxcbiAgICBvcmFuZ2U6IFsgMjU1LCAxNjUsIDBdLFxuICAgIG9yYW5nZXJlZDogWyAyNTUsIDY5LCAwXSxcbiAgICBvcmNoaWQ6IFsgMjE4LCAxMTIsIDIxNCBdLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFsgMjM4LCAyMzIsIDE3MCBdLFxuICAgIHBhbGVncmVlbjogWyAxNTIsIDI1MSwgMTUyIF0sXG4gICAgcGFsZXR1cnF1b2lzZTogWyAxNzUsIDIzOCwgMjM4IF0sXG4gICAgcGFsZXZpb2xldHJlZDogWyAyMTksIDExMiwgMTQ3IF0sXG4gICAgcGFwYXlhd2hpcDogWyAyNTUsIDIzOSwgMjEzIF0sXG4gICAgcGVhY2hwdWZmOiBbIDI1NSwgMjE4LCAxODUgXSxcbiAgICBwZXJ1OiBbIDIwNSwgMTMzLCA2MyBdLFxuICAgIHBpbms6IFsgMjU1LCAxOTIsIDIwMyBdLFxuICAgIHBsdW06IFsgMjIxLCAxNjAsIDIyMSBdLFxuICAgIHBvd2RlcmJsdWU6IFsgMTc2LCAyMjQsIDIzMCBdLFxuICAgIHB1cnBsZTogWyAxMjgsIDAsIDEyOCBdLFxuICAgIHJlZDogWyAyNTUsIDAsIDBdLFxuICAgIHJvc3licm93bjogWyAxODgsIDE0MywgMTQzIF0sXG4gICAgcm95YWxibHVlOiBbIDY1LCAxMDUsIDIyNSBdLFxuICAgIHNhZGRsZWJyb3duOiBbIDEzOSwgNjksIDE5IF0sXG4gICAgc2FsbW9uOiBbIDI1MCwgMTI4LCAxMTQgXSxcbiAgICBzYW5keWJyb3duOiBbIDI0NCwgMTY0LCA5NiBdLFxuICAgIHNlYWdyZWVuOiBbIDQ2LCAxMzksIDg3IF0sXG4gICAgc2Vhc2hlbGw6IFsgMjU1LCAyNDUsIDIzOCBdLFxuICAgIHNpZW5uYTogWyAxNjAsIDgyLCA0NSBdLFxuICAgIHNpbHZlcjogWyAxOTIsIDE5MiwgMTkyIF0sXG4gICAgc2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjM1IF0sXG4gICAgc2xhdGVibHVlOiBbIDEwNiwgOTAsIDIwNSBdLFxuICAgIHNsYXRlZ3JheTogWyAxMTIsIDEyOCwgMTQ0IF0sXG4gICAgc2xhdGVncmV5OiBbIDExMiwgMTI4LCAxNDQgXSxcbiAgICBzbm93OiBbIDI1NSwgMjUwLCAyNTAgXSxcbiAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3IF0sXG4gICAgc3RlZWxibHVlOiBbIDcwLCAxMzAsIDE4MCBdLFxuICAgIHRhbjogWyAyMTAsIDE4MCwgMTQwIF0sXG4gICAgdGVhbDogWzAsIDEyOCwgMTI4IF0sXG4gICAgdGhpc3RsZTogWyAyMTYsIDE5MSwgMjE2IF0sXG4gICAgdG9tYXRvOiBbIDI1NSwgOTksIDcxIF0sXG4gICAgdHVycXVvaXNlOiBbIDY0LCAyMjQsIDIwOCBdLFxuICAgIHZpb2xldDogWyAyMzgsIDEzMCwgMjM4IF0sXG4gICAgd2hlYXQ6IFsgMjQ1LCAyMjIsIDE3OSBdLFxuICAgIHdoaXRlOiBbIDI1NSwgMjU1LCAyNTUgXSxcbiAgICB3aGl0ZXNtb2tlOiBbIDI0NSwgMjQ1LCAyNDUgXSxcbiAgICB5ZWxsb3c6IFsgMjU1LCAyNTUsIDBdLFxuICAgIHllbGxvd2dyZWVuOiBbIDE1NCwgMjA1LCA1MCBdXG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZ2xvYmFsIGNvbnNvbGUgKi9cblxudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIG1hdGggPSByZXF1aXJlKCAnLi4vbWF0aCcgKTtcblxudmFyIHV0aWwgPSB7XG5cbiAgdHJ1ZWlmeTogZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH0sXG5cbiAgZmFsc2lmeTogZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9LFxuXG4gIHplcm9pZnk6IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9LFxuXG4gIG5vb3A6IGZ1bmN0aW9uKCl7fSxcblxuICBlcnJvcjogZnVuY3Rpb24oIG1zZyApe1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgaWYoIGNvbnNvbGUuZXJyb3IgKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuXG4gICAgICBpZiggY29uc29sZS50cmFjZSApeyBjb25zb2xlLnRyYWNlKCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuXG4gICAgICBpZiggY29uc29sZS50cmFjZSApeyBjb25zb2xlLnRyYWNlKCk7IH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKCB7fSwgb2JqICk7XG4gIH0sXG5cbiAgLy8gZ2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnRcbiAgY29weTogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGlmKCBpcy5hcnJheSggb2JqICkgKXtcbiAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBvYmogKSApe1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoIG9iaiApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSxcblxuICB1dWlkOiBmdW5jdGlvbihcbiAgICAgIGEsYiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlcnNcbiAgKXtcbiAgICAgIGZvciggICAgICAgICAgICAgICAvLyBsb29wIDopXG4gICAgICAgICAgYj1hPScnOyAgICAgICAgLy8gYiAtIHJlc3VsdCAsIGEgLSBudW1lcmljIHZhcmlhYmxlXG4gICAgICAgICAgYSsrPDM2OyAgICAgICAgLy9cbiAgICAgICAgICBiKz1hKjUxJjUyICAvLyBpZiBcImFcIiBpcyBub3QgOSBvciAxNCBvciAxOSBvciAyNFxuICAgICAgICAgICAgICAgICAgICAgID8gIC8vICByZXR1cm4gYSByYW5kb20gbnVtYmVyIG9yIDRcbiAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICBhXjE1ICAgICAgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gICAgICAgICAgICAgICAgICA/ICAgICAgLy8gZ2VuZXRhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICAgICAgICAgICAgICAgOF5NYXRoLnJhbmRvbSgpKlxuICAgICAgICAgICAgICAgKGFeMjA/MTY6NCkgIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gICAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICA0ICAgICAgICAgICAgLy8gIG90aGVyd2lzZSA0XG4gICAgICAgICAgICAgICApLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAnLScgICAgICAgICAgICAvLyAgaW4gb3RoZXIgY2FzZXMgKGlmIFwiYVwiIGlzIDksMTQsMTksMjQpIGluc2VydCBcIi1cIlxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gYjtcbiAgfVxuXG59O1xuXG51dGlsLm1ha2VCb3VuZGluZ0JveCA9IG1hdGgubWFrZUJvdW5kaW5nQm94LmJpbmQoIG1hdGggKTtcblxudXRpbC5fc3RhdGljRW1wdHlPYmplY3QgPSB7fTtcblxudXRpbC5zdGF0aWNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB1dGlsLl9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG5cbnV0aWwuZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uKCB0Z3QgKXtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgZm9yKCB2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG9iaiA9IGFyZ3NbIGkgXTtcblxuICAgIGlmKCAhb2JqICl7IGNvbnRpbnVlOyB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBvYmogKTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuXG4gICAgICB0Z3RbIGsgXSA9IG9ialsgayBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG51dGlsLmRlZmF1bHQgPSBmdW5jdGlvbiggdmFsLCBkZWYgKXtcbiAgaWYoIHZhbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgcmV0dXJuIGRlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xuXG51dGlsLnJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uKCBhcnIsIGVsZSwgbWFueUNvcGllcyApe1xuICBmb3IoIHZhciBpID0gYXJyLmxlbmd0aDsgaSA+PSAwOyBpLS0gKXtcbiAgICBpZiggYXJyW2ldID09PSBlbGUgKXtcbiAgICAgIGFyci5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgaWYoICFtYW55Q29waWVzICl7IGJyZWFrOyB9XG4gICAgfVxuICB9XG59O1xuXG51dGlsLmNsZWFyQXJyYXkgPSBmdW5jdGlvbiggYXJyICl7XG4gIGFyci5zcGxpY2UoIDAsIGFyci5sZW5ndGggKTtcbn07XG5cbnV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3BOYW1lLCBwcmVmaXggKXtcbiAgaWYoIHByZWZpeCApe1xuICAgIHByb3BOYW1lID0gdGhpcy5wcmVwZW5kQ2FtZWwoIHByZWZpeCwgcHJvcE5hbWUgKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqWyBwcm9wTmFtZSBdO1xufTtcblxudXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24oIG9iaiwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUgKXtcbiAgaWYoIHByZWZpeCApe1xuICAgIHByb3BOYW1lID0gdGhpcy5wcmVwZW5kQ2FtZWwoIHByZWZpeCwgcHJvcE5hbWUgKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICBvYmpbIHByb3BOYW1lIF0gPSB2YWx1ZTtcbn07XG5cbltcbiAgcmVxdWlyZSggJy4vY29sb3JzJyApLFxuICByZXF1aXJlKCAnLi9tYXBzJyApLFxuICB7IG1lbW9pemU6IHJlcXVpcmUoICcuL21lbW9pemUnICkgfSxcbiAgcmVxdWlyZSggJy4vcmVnZXgnICksXG4gIHJlcXVpcmUoICcuL3N0cmluZ3MnICksXG4gIHJlcXVpcmUoICcuL3RpbWluZycgKVxuXS5mb3JFYWNoKCBmdW5jdGlvbiggcmVxICl7XG4gIHV0aWwuZXh0ZW5kKCB1dGlsLCByZXEgKTtcbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBoYXMgYW55dGhpbmcgYmVlbiBzZXQgaW4gdGhlIG1hcFxuICBtYXBFbXB0eTogZnVuY3Rpb24oIG1hcCApe1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBpZiggbWFwICE9IG51bGwgKXtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyggbWFwICkubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBlbXB0eTtcbiAgfSxcblxuICAvLyBwdXNoZXMgdG8gdGhlIGFycmF5IGF0IHRoZSBlbmQgb2YgYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxuICBwdXNoTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0TWFwKCBvcHRpb25zICk7XG5cbiAgICBpZiggYXJyYXkgPT0gbnVsbCApeyAvLyBpZiBlbXB0eSwgcHV0IGluaXRpYWwgYXJyYXlcbiAgICAgIHRoaXMuc2V0TWFwKCB0aGlzLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgICAgdmFsdWU6IFsgb3B0aW9ucy52YWx1ZSBdXG4gICAgICB9ICkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkucHVzaCggb3B0aW9ucy52YWx1ZSApO1xuICAgIH1cbiAgfSxcblxuICAvLyBzZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gIHNldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleTtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBrZXkgPSBrZXlzWyBpIF07XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgdGhpcy5lcnJvciggJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5JyApO1xuICAgICAgfVxuXG4gICAgICBpZiggaSA8IGtleXMubGVuZ3RoIC0gMSApe1xuXG4gICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiggb2JqWyBrZXkgXSA9PSBudWxsICl7XG4gICAgICAgICAgb2JqWyBrZXkgXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqWyBrZXkgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgb2JqWyBrZXkgXSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG4gIGdldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIga2V5ID0ga2V5c1sgaSBdO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgIHRoaXMuZXJyb3IoICdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScgKTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqWyBrZXkgXTtcblxuICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICAvLyBkZWxldGVzIHRoZSBlbnRyeSBpbiB0aGUgbWFwXG4gIGRlbGV0ZU1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIga2VlcENoaWxkcmVuID0gb3B0aW9ucy5rZWVwQ2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGtleSA9IGtleXNbIGkgXTtcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICB0aGlzLmVycm9yKCAnVHJpZWQgdG8gZGVsZXRlIG1hcCB3aXRoIG9iamVjdCBrZXknICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0S2V5ID0gaSA9PT0gb3B0aW9ucy5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICBpZiggbGFzdEtleSApe1xuXG4gICAgICAgIGlmKCBrZWVwQ2hpbGRyZW4gKXsgLy8gdGhlbiBvbmx5IGRlbGV0ZSBjaGlsZCBmaWVsZHMgbm90IGluIGtlZXBDaGlsZHJlblxuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IE9iamVjdC5rZXlzKCBvYmogKTtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2pdO1xuXG4gICAgICAgICAgICBpZiggIWtlZXBDaGlsZHJlblsgY2hpbGQgXSApe1xuICAgICAgICAgICAgICBvYmpbIGNoaWxkIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gb2JqWyBrZXkgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVtb2l6ZSggZm4sIGtleUZuICl7XG4gIGlmKCAha2V5Rm4gKXtcbiAgICBrZXlGbiA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYXJncy5wdXNoKCBhcmd1bWVudHNbIGkgXSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncy5qb2luKCAnJCcgKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIG1lbW9pemVkRm4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcmV0O1xuICAgIHZhciBrID0ga2V5Rm4uYXBwbHkoIHNlbGYsIGFyZ3MgKTtcbiAgICB2YXIgY2FjaGUgPSBtZW1vaXplZEZuLmNhY2hlO1xuXG4gICAgaWYoICEocmV0ID0gY2FjaGVbIGsgXSkgKXtcbiAgICAgIHJldCA9IGNhY2hlWyBrIF0gPSBmbi5hcHBseSggc2VsZiwgYXJncyApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuXG4gIHJldHVybiBtZW1vaXplZEZuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9ICcoPzpbLStdPyg/Oig/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbRWVdWystXT9cXFxcZCspPykpJztcblxudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuXG52YXIgaHNsYSA9ICdoc2xbYV0/XFxcXCgoJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgaHNsYU5vQmFja1JlZnMgPSAnaHNsW2FdP1xcXFwoKD86JyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG5cbnZhciBoZXgzID0gJ1xcXFwjWzAtOWEtZkEtRl17M30nO1xudmFyIGhleDYgPSAnXFxcXCNbMC05YS1mQS1GXXs2fSc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWdleDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHJnYmE6IHJnYmEsXG4gICAgcmdiYU5vQmFja1JlZnM6IHJnYmFOb0JhY2tSZWZzLFxuICAgIGhzbGE6IGhzbGEsXG4gICAgaHNsYU5vQmFja1JlZnM6IGhzbGFOb0JhY2tSZWZzLFxuICAgIGhleDM6IGhleDMsXG4gICAgaGV4NjogaGV4NlxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWVtb2l6ZSA9IHJlcXVpcmUoICcuL21lbW9pemUnICk7XG52YXIgaXMgPSByZXF1aXJlKCAnLi4vaXMnICk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNhbWVsMmRhc2g6IG1lbW9pemUoIGZ1bmN0aW9uKCBzdHIgKXtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oW0EtWl0pL2csIGZ1bmN0aW9uKCB2ICl7XG4gICAgICByZXR1cm4gJy0nICsgdi50b0xvd2VyQ2FzZSgpO1xuICAgIH0gKTtcbiAgfSApLFxuXG4gIGRhc2gyY2FtZWw6IG1lbW9pemUoIGZ1bmN0aW9uKCBzdHIgKXtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oLVxcdykvZywgZnVuY3Rpb24oIHYgKXtcbiAgICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSApO1xuICB9ICksXG5cbiAgcHJlcGVuZENhbWVsOiBtZW1vaXplKCBmdW5jdGlvbiggcHJlZml4LCBzdHIgKXtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICB9LCBmdW5jdGlvbiggcHJlZml4LCBzdHIgKXtcbiAgICByZXR1cm4gcHJlZml4ICsgJyQnICsgc3RyO1xuICB9ICksXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oIHN0ciApe1xuICAgIGlmKCBpcy5lbXB0eVN0cmluZyggc3RyICkgKXtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZyggMSApO1xuICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCAnLi4vd2luZG93JyApO1xudmFyIGlzID0gcmVxdWlyZSggJy4uL2lzJyApO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93ID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcblxudmFyIHV0aWwgPSB7fTtcblxudmFyIHJhZiA9ICF3aW5kb3cgPyBmdW5jdGlvbiggZm4gKXtcbiAgaWYoIGZuICl7XG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgIGZuKCBwbm93KCkgKTtcbiAgICB9LCAxMDAwIC8gNjAgKTtcbiAgfVxufSA6IChmdW5jdGlvbigpe1xuICBpZiggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApe1xuICAgIHJldHVybiBmdW5jdGlvbiggZm4gKXsgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggZm4gKTsgfTtcbiAgfSBlbHNlIGlmKCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBmbiApeyB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmbiApOyB9O1xuICB9IGVsc2UgaWYoIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuICl7IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZuICk7IH07XG4gIH0gZWxzZSBpZiggd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBmbiApeyB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZuICk7IH07XG4gIH1cbn0pKCk7XG5cbnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGZuICl7XG4gIHJhZiggZm4gKTtcbn07XG5cbnZhciBwbm93ID0gcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24oKXsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9IDogZnVuY3Rpb24oKXsgcmV0dXJuIERhdGUubm93KCk7IH07XG5cbnV0aWwucGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG4vLyBwb3J0ZWQgbG9kYXNoIHRocm90dGxlIGZ1bmN0aW9uXG51dGlsLnRocm90dGxlID0gZnVuY3Rpb24oIGZ1bmMsIHdhaXQsIG9wdGlvbnMgKXtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmKCBvcHRpb25zID09PSBmYWxzZSApe1xuICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgb3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgb3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gIHJldHVybiB1dGlsLmRlYm91bmNlKCBmdW5jLCB3YWl0LCBvcHRpb25zICk7XG59O1xuXG51dGlsLm5vdyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudXRpbC5kZWJvdW5jZSA9IGZ1bmN0aW9uKCBmdW5jLCB3YWl0LCBvcHRpb25zICl7IC8vIHBvcnRlZCBsb2Rhc2ggZGVib3VuY2UgZnVuY3Rpb25cbiAgdmFyIHV0aWwgPSB0aGlzO1xuICB2YXIgYXJncyxcbiAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YW1wLFxuICAgICAgdGhpc0FyZyxcbiAgICAgIHRpbWVvdXRJZCxcbiAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmKCAhaXMuZm4oIGZ1bmMgKSApe1xuICAgIHJldHVybjtcbiAgfVxuICB3YWl0ID0gTWF0aC5tYXgoIDAsIHdhaXQgKSB8fCAwO1xuICBpZiggb3B0aW9ucyA9PT0gdHJ1ZSApe1xuICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICB0cmFpbGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAoTWF0aC5tYXgoIHdhaXQsIG9wdGlvbnMubWF4V2FpdCApIHx8IDApO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtICh1dGlsLm5vdygpIC0gc3RhbXApO1xuICAgIGlmKCByZW1haW5pbmcgPD0gMCApe1xuICAgICAgaWYoIG1heFRpbWVvdXRJZCApe1xuICAgICAgICBjbGVhclRpbWVvdXQoIG1heFRpbWVvdXRJZCApO1xuICAgICAgfVxuICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgaWYoIGlzQ2FsbGVkICl7XG4gICAgICAgIGxhc3RDYWxsZWQgPSB1dGlsLm5vdygpO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCB0aGlzQXJnLCBhcmdzICk7XG4gICAgICAgIGlmKCAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQgKXtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCggZGVsYXllZCwgcmVtYWluaW5nICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKXtcbiAgICBpZiggdGltZW91dElkICl7XG4gICAgICBjbGVhclRpbWVvdXQoIHRpbWVvdXRJZCApO1xuICAgIH1cbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgaWYoIHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSApe1xuICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCB0aGlzQXJnLCBhcmdzICk7XG4gICAgICBpZiggIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkICl7XG4gICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICBpZiggbWF4V2FpdCA9PT0gZmFsc2UgKXtcbiAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoICFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcgKXtcbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgfVxuICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICBpZiggaXNDYWxsZWQgKXtcbiAgICAgICAgaWYoIG1heFRpbWVvdXRJZCApe1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCggbWF4VGltZW91dElkICk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCB0aGlzQXJnLCBhcmdzICk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKCAhbWF4VGltZW91dElkICl7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIG1heERlbGF5ZWQsIHJlbWFpbmluZyApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiggaXNDYWxsZWQgJiYgdGltZW91dElkICl7XG4gICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQoIHRpbWVvdXRJZCApO1xuICAgIH1cbiAgICBlbHNlIGlmKCAhdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQgKXtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIGRlbGF5ZWQsIHdhaXQgKTtcbiAgICB9XG4gICAgaWYoIGxlYWRpbmdDYWxsICl7XG4gICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KCB0aGlzQXJnLCBhcmdzICk7XG4gICAgfVxuICAgIGlmKCBpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQgKXtcbiAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIyLjcuMTRcIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLyogRmlsZVNhdmVyLmpzXG4gKiBBIHNhdmVBcygpIEZpbGVTYXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqIDEuMy4yXG4gKiAyMDE2LTA2LTE2IDE4OjI1OjE5XG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogTGljZW5zZTogTUlUXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYgKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUsIGluZGVudDogNCwgbGF4YnJlYWs6IHRydWUsIGxheGNvbW1hOiB0cnVlLCBzbWFydHRhYnM6IHRydWUsIHBsdXNwbHVzOiB0cnVlICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvRmlsZVNhdmVyLmpzICovXG5cbnZhciBzYXZlQXMgPSBzYXZlQXMgfHwgKGZ1bmN0aW9uKHZpZXcpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8vIElFIDwxMCBpcyBleHBsaWNpdGx5IHVuc3VwcG9ydGVkXG5cdGlmICh0eXBlb2YgdmlldyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFsxLTldXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhclxuXHRcdCAgZG9jID0gdmlldy5kb2N1bWVudFxuXHRcdCAgLy8gb25seSBnZXQgVVJMIHdoZW4gbmVjZXNzYXJ5IGluIGNhc2UgQmxvYi5qcyBoYXNuJ3Qgb3ZlcnJpZGRlbiBpdCB5ZXRcblx0XHQsIGdldF9VUkwgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3O1xuXHRcdH1cblx0XHQsIHNhdmVfbGluayA9IGRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIFwiYVwiKVxuXHRcdCwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXG5cdFx0LCBjbGljayA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIik7XG5cdFx0XHRub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHQsIGlzX3NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3Qodmlldy5IVE1MRWxlbWVudCkgfHwgdmlldy5zYWZhcmlcblx0XHQsIGlzX2Nocm9tZV9pb3MgPS9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuXHRcdCwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uKGV4KSB7XG5cdFx0XHQodmlldy5zZXRJbW1lZGlhdGUgfHwgdmlldy5zZXRUaW1lb3V0KShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgZXg7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdFx0LCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuXHRcdC8vIHRoZSBCbG9iIEFQSSBpcyBmdW5kYW1lbnRhbGx5IGJyb2tlbiBhcyB0aGVyZSBpcyBubyBcImRvd25sb2FkZmluaXNoZWRcIiBldmVudCB0byBzdWJzY3JpYmUgdG9cblx0XHQsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCA9IDEwMDAgKiA0MCAvLyBpbiBtc1xuXHRcdCwgcmV2b2tlID0gZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0dmFyIHJldm9rZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7IC8vIGZpbGUgaXMgYW4gb2JqZWN0IFVSTFxuXHRcdFx0XHRcdGdldF9VUkwoKS5yZXZva2VPYmplY3RVUkwoZmlsZSk7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGZpbGUgaXMgYSBGaWxlXG5cdFx0XHRcdFx0ZmlsZS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHNldFRpbWVvdXQocmV2b2tlciwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0KTtcblx0XHR9XG5cdFx0LCBkaXNwYXRjaCA9IGZ1bmN0aW9uKGZpbGVzYXZlciwgZXZlbnRfdHlwZXMsIGV2ZW50KSB7XG5cdFx0XHRldmVudF90eXBlcyA9IFtdLmNvbmNhdChldmVudF90eXBlcyk7XG5cdFx0XHR2YXIgaSA9IGV2ZW50X3R5cGVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZmlsZXNhdmVyW1wib25cIiArIGV2ZW50X3R5cGVzW2ldXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGwoZmlsZXNhdmVyLCBldmVudCB8fCBmaWxlc2F2ZXIpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0XHR0aHJvd19vdXRzaWRlKGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0LCBhdXRvX2JvbSA9IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdC8vIHByZXBlbmQgQk9NIGZvciBVVEYtOCBYTUwgYW5kIHRleHQvKiB0eXBlcyAoaW5jbHVkaW5nIEhUTUwpXG5cdFx0XHQvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuXHRcdFx0aWYgKC9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGJsb2IudHlwZSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCbG9iKFtTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRiksIGJsb2JdLCB7dHlwZTogYmxvYi50eXBlfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmxvYjtcblx0XHR9XG5cdFx0LCBGaWxlU2F2ZXIgPSBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaXJzdCB0cnkgYS5kb3dubG9hZCwgdGhlbiB3ZWIgZmlsZXN5c3RlbSwgdGhlbiBvYmplY3QgVVJMc1xuXHRcdFx0dmFyXG5cdFx0XHRcdCAgZmlsZXNhdmVyID0gdGhpc1xuXHRcdFx0XHQsIHR5cGUgPSBibG9iLnR5cGVcblx0XHRcdFx0LCBmb3JjZSA9IHR5cGUgPT09IGZvcmNlX3NhdmVhYmxlX3R5cGVcblx0XHRcdFx0LCBvYmplY3RfdXJsXG5cdFx0XHRcdCwgZGlzcGF0Y2hfYWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2goZmlsZXNhdmVyLCBcIndyaXRlc3RhcnQgcHJvZ3Jlc3Mgd3JpdGUgd3JpdGVlbmRcIi5zcGxpdChcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9uIGFueSBmaWxlc3lzIGVycm9ycyByZXZlcnQgdG8gc2F2aW5nIHdpdGggb2JqZWN0IFVSTHNcblx0XHRcdFx0LCBmc19lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICgoaXNfY2hyb21lX2lvcyB8fCAoZm9yY2UgJiYgaXNfc2FmYXJpKSkgJiYgdmlldy5GaWxlUmVhZGVyKSB7XG5cdFx0XHRcdFx0XHQvLyBTYWZhcmkgZG9lc24ndCBhbGxvdyBkb3dubG9hZGluZyBvZiBibG9iIHVybHNcblx0XHRcdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdFx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gaXNfY2hyb21lX2lvcyA/IHJlYWRlci5yZXN1bHQgOiByZWFkZXIucmVzdWx0LnJlcGxhY2UoL15kYXRhOlteO10qOy8sICdkYXRhOmF0dGFjaG1lbnQvZmlsZTsnKTtcblx0XHRcdFx0XHRcdFx0dmFyIHBvcHVwID0gdmlldy5vcGVuKHVybCwgJ19ibGFuaycpO1xuXHRcdFx0XHRcdFx0XHRpZighcG9wdXApIHZpZXcubG9jYXRpb24uaHJlZiA9IHVybDtcblx0XHRcdFx0XHRcdFx0dXJsPXVuZGVmaW5lZDsgLy8gcmVsZWFzZSByZWZlcmVuY2UgYmVmb3JlIGRpc3BhdGNoaW5nXG5cdFx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuXHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgY3JlYXRlIG1vcmUgb2JqZWN0IFVSTHMgdGhhbiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoIW9iamVjdF91cmwpIHtcblx0XHRcdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZm9yY2UpIHtcblx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBvcGVuZWQgPSB2aWV3Lm9wZW4ob2JqZWN0X3VybCwgXCJfYmxhbmtcIik7XG5cdFx0XHRcdFx0XHRpZiAoIW9wZW5lZCkge1xuXHRcdFx0XHRcdFx0XHQvLyBBcHBsZSBkb2VzIG5vdCBhbGxvdyB3aW5kb3cub3Blbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL1Rvb2xzL0NvbmNlcHR1YWwvU2FmYXJpRXh0ZW5zaW9uR3VpZGUvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzLmh0bWxcblx0XHRcdFx0XHRcdFx0dmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdH1cblx0XHRcdDtcblx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cblx0XHRcdGlmIChjYW5fdXNlX3NhdmVfbGluaykge1xuXHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzYXZlX2xpbmsuaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmRvd25sb2FkID0gbmFtZTtcblx0XHRcdFx0XHRjbGljayhzYXZlX2xpbmspO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdHJldm9rZShvYmplY3RfdXJsKTtcblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmc19lcnJvcigpO1xuXHRcdH1cblx0XHQsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuXHRcdCwgc2F2ZUFzID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdHJldHVybiBuZXcgRmlsZVNhdmVyKGJsb2IsIG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIiwgbm9fYXV0b19ib20pO1xuXHRcdH1cblx0O1xuXHQvLyBJRSAxMCsgKG5hdGl2ZSBzYXZlQXMpXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRuYW1lID0gbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiO1xuXG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBuYW1lKTtcblx0XHR9O1xuXHR9XG5cblx0RlNfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbigpe307XG5cdEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcblx0RlNfcHJvdG8uV1JJVElORyA9IDE7XG5cdEZTX3Byb3RvLkRPTkUgPSAyO1xuXG5cdEZTX3Byb3RvLmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZXN0YXJ0ID1cblx0RlNfcHJvdG8ub25wcm9ncmVzcyA9XG5cdEZTX3Byb3RvLm9ud3JpdGUgPVxuXHRGU19wcm90by5vbmFib3J0ID1cblx0RlNfcHJvdG8ub25lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuXHRcdG51bGw7XG5cblx0cmV0dXJuIHNhdmVBcztcbn0oXG5cdCAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcblx0fHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcblx0fHwgdGhpcy5jb250ZW50XG4pKTtcbi8vIGBzZWxmYCBpcyB1bmRlZmluZWQgaW4gRmlyZWZveCBmb3IgQW5kcm9pZCBjb250ZW50IHNjcmlwdCBjb250ZXh0XG4vLyB3aGlsZSBgdGhpc2AgaXMgbnNJQ29udGVudEZyYW1lTWVzc2FnZU1hbmFnZXJcbi8vIHdpdGggYW4gYXR0cmlidXRlIGBjb250ZW50YCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB3aW5kb3dcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMuc2F2ZUFzID0gc2F2ZUFzO1xufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkZWZpbmUgIT09IG51bGwpICYmIChkZWZpbmUuYW1kICE9PSBudWxsKSkge1xuICBkZWZpbmUoXCJGaWxlU2F2ZXIuanNcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNhdmVBcztcbiAgfSk7XG59XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHR5cGVvZiBrZXkgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRnVsbF0gU3BlY2lmeSBhIGNsb25lIGluY2x1ZGluZyBzeW1ib2xzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIGlmIChpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lT2JqZWN0KGlzRnVuYyA/IHt9IDogdmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKCFpc0Fycikge1xuICAgIHZhciBwcm9wcyA9IGlzRnVsbCA/IGdldEFsbEtleXModmFsdWUpIDoga2V5cyh2YWx1ZSk7XG4gIH1cbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKSB7XG4gIHJldHVybiBpc09iamVjdChwcm90bykgPyBvYmplY3RDcmVhdGUocHJvdG8pIDoge307XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKSkge1xuICAgIHZhciBwcm9wcyA9IGJhc2VLZXlzSW4oc291cmNlKTtcbiAgfVxuICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzcmNWYWx1ZTtcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgKHNyY0luZGV4ICYmIGlzRnVuY3Rpb24ob2JqVmFsdWUpKSkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGJhc2VDbG9uZShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgdHJ1ZSkgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgbWVyZ2VEZWZhdWx0cywgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAqL1xudmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgYXJncy5wdXNoKHVuZGVmaW5lZCwgbWVyZ2VEZWZhdWx0cyk7XG4gIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2V2ZW4gYXJndW1lbnRzOlxuICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICpcbiAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICovXG52YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0c0RlZXA7XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIGNvbnZlcnRlciA9IHJlcXVpcmUoJy4vc2Jnbm1sQ29udmVydGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgcmV0dXJuIGNvbnZlcnRlci5jb252ZXJ0KHRleHQpO1xufTtcbiIsIi8qIGpzbGludCBicm93c2VyOiB0cnVlICovXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdDogZmFsc2UgKi9cblxudmFyIHNiZ25tbENvbnZlcnRlciA9IHtcbiAgbG9hZFhNTEZyb21TdHJpbmc6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIGRvYztcbiAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgIGRvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICBkb2MuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgZG9jLmxvYWRYTUwodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsICd0ZXh0L3htbCcpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZUVycm9yID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpO1xuICAgIGlmIChwYXJzZUVycm9yLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgdGhlIGZvbGxvd2luZyB0ZXh0IHRvIHhtbDogJyArIEpTT04uc3RyaW5naWZ5KHRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jO1xuICB9LFxuICBzYmdubWxUYWdzOiB7XG4gICAgJ3Vuc3BlY2lmaWVkIGVudGl0eSc6IHRydWUsXG4gICAgJ3NpbXBsZSBjaGVtaWNhbCc6IHRydWUsXG4gICAgJ21hY3JvbW9sZWN1bGUnOiB0cnVlLFxuICAgICdudWNsZWljIGFjaWQgZmVhdHVyZSc6IHRydWUsXG4gICAgJ3BlcnR1cmJpbmcgYWdlbnQnOiB0cnVlLFxuICAgICdzb3VyY2UgYW5kIHNpbmsnOiB0cnVlLFxuICAgICdjb21wbGV4JzogdHJ1ZSxcbiAgICAncHJvY2Vzcyc6IHRydWUsXG4gICAgJ29taXR0ZWQgcHJvY2Vzcyc6IHRydWUsXG4gICAgJ3VuY2VydGFpbiBwcm9jZXNzJzogdHJ1ZSxcbiAgICAnYXNzb2NpYXRpb24nOiB0cnVlLFxuICAgICdkaXNzb2NpYXRpb24nOiB0cnVlLFxuICAgICdwaGVub3R5cGUnOiB0cnVlLFxuICAgICd0YWcnOiB0cnVlLFxuICAgICdjb25zdW1wdGlvbic6IHRydWUsXG4gICAgJ3Byb2R1Y3Rpb24nOiB0cnVlLFxuICAgICdtb2R1bGF0aW9uJzogdHJ1ZSxcbiAgICAnc3RpbXVsYXRpb24nOiB0cnVlLFxuICAgICdjYXRhbHlzaXMnOiB0cnVlLFxuICAgICdpbmhpYml0aW9uJzogdHJ1ZSxcbiAgICAnbmVjZXNzYXJ5IHN0aW11bGF0aW9uJzogdHJ1ZSxcbiAgICAnbG9naWMgYXJjJzogdHJ1ZSxcbiAgICAnZXF1aXZhbGVuY2UgYXJjJzogdHJ1ZSxcbiAgICAnYW5kIG9wZXJhdG9yJzogdHJ1ZSxcbiAgICAnb3Igb3BlcmF0b3InOiB0cnVlLFxuICAgICdub3Qgb3BlcmF0b3InOiB0cnVlLFxuICAgICdhbmQnOiB0cnVlLFxuICAgICdvcic6IHRydWUsXG4gICAgJ25vdCc6IHRydWUsXG4gICAgJ251Y2xlaWMgYWNpZCBmZWF0dXJlIG11bHRpbWVyJzogdHJ1ZSxcbiAgICAnbWFjcm9tb2xlY3VsZSBtdWx0aW1lcic6IHRydWUsXG4gICAgJ3NpbXBsZSBjaGVtaWNhbCBtdWx0aW1lcic6IHRydWUsXG4gICAgJ2NvbXBsZXggbXVsdGltZXInOiB0cnVlLFxuICAgICdjb21wYXJ0bWVudCc6IHRydWVcbiAgfSxcbiAgaW5zZXJ0ZWROb2Rlczoge30sXG4gIGdldEFsbENvbXBhcnRtZW50czogZnVuY3Rpb24gKHhtbE9iamVjdCkge1xuICAgIHZhciBjb21wYXJ0bWVudHMgPSBbXTtcblxuICAgIHZhciBjb21wYXJ0bWVudEVscyA9IHhtbE9iamVjdC5xdWVyeVNlbGVjdG9yQWxsKFwiZ2x5cGhbY2xhc3M9J2NvbXBhcnRtZW50J11cIik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBhcnRtZW50RWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcGFydG1lbnQgPSBjb21wYXJ0bWVudEVsc1tpXTtcbiAgICAgIHZhciBiYm94ID0gdGhpcy5maW5kQ2hpbGROb2RlKGNvbXBhcnRtZW50LCAnYmJveCcpO1xuICAgICAgY29tcGFydG1lbnRzLnB1c2goe1xuICAgICAgICAneCc6IHBhcnNlRmxvYXQoYmJveC5nZXRBdHRyaWJ1dGUoJ3gnKSksXG4gICAgICAgICd5JzogcGFyc2VGbG9hdChiYm94LmdldEF0dHJpYnV0ZSgneScpKSxcbiAgICAgICAgJ3cnOiBwYXJzZUZsb2F0KGJib3guZ2V0QXR0cmlidXRlKCd3JykpLFxuICAgICAgICAnaCc6IHBhcnNlRmxvYXQoYmJveC5nZXRBdHRyaWJ1dGUoJ2gnKSksXG4gICAgICAgICdpZCc6IGNvbXBhcnRtZW50LmdldEF0dHJpYnV0ZSgnaWQnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcGFydG1lbnRzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgaWYgKGMxLmggKiBjMS53IDwgYzIuaCAqIGMyLncpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGMxLmggKiBjMS53ID4gYzIuaCAqIGMyLncpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb21wYXJ0bWVudHM7XG4gIH0sXG4gIGlzSW5Cb3VuZGluZ0JveDogZnVuY3Rpb24gKGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MS54ID4gYmJveDIueCAmJlxuICAgICAgICBiYm94MS55ID4gYmJveDIueSAmJlxuICAgICAgICBiYm94MS54ICsgYmJveDEudyA8IGJib3gyLnggKyBiYm94Mi53ICYmXG4gICAgICAgIGJib3gxLnkgKyBiYm94MS5oIDwgYmJveDIueSArIGJib3gyLmgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGJib3hQcm9wOiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgYmJveEVsID0gZWxlLnF1ZXJ5U2VsZWN0b3IoJ2Jib3gnKTtcblxuICAgIGJib3gueCA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICBiYm94LnkgPSBiYm94RWwuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgYmJveC53ID0gYmJveEVsLmdldEF0dHJpYnV0ZSgndycpO1xuICAgIGJib3guaCA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ2gnKTtcbiAgICAvLyBzZXQgcG9zaXRpb25zIGFzIGNlbnRlclxuICAgIGJib3gueCA9IHBhcnNlRmxvYXQoYmJveC54KSArIHBhcnNlRmxvYXQoYmJveC53KSAvIDI7XG4gICAgYmJveC55ID0gcGFyc2VGbG9hdChiYm94LnkpICsgcGFyc2VGbG9hdChiYm94LmgpIC8gMjtcblxuICAgIHJldHVybiBiYm94O1xuICB9LFxuICBzdGF0ZUFuZEluZm9CYm94UHJvcDogZnVuY3Rpb24gKGVsZSwgcGFyZW50QmJveCkge1xuICAgIHZhciB4UG9zID0gcGFyc2VGbG9hdChwYXJlbnRCYm94LngpO1xuICAgIHZhciB5UG9zID0gcGFyc2VGbG9hdChwYXJlbnRCYm94LnkpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgYmJveEVsID0gZWxlLnF1ZXJ5U2VsZWN0b3IoJ2Jib3gnKTtcblxuICAgIGJib3gueCA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICBiYm94LnkgPSBiYm94RWwuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgYmJveC53ID0gYmJveEVsLmdldEF0dHJpYnV0ZSgndycpO1xuICAgIGJib3guaCA9IGJib3hFbC5nZXRBdHRyaWJ1dGUoJ2gnKTtcblxuICAgIC8vIHNldCBwb3NpdGlvbnMgYXMgY2VudGVyXG4gICAgYmJveC54ID0gcGFyc2VGbG9hdChiYm94LngpICsgcGFyc2VGbG9hdChiYm94LncpIC8gMiAtIHhQb3M7XG4gICAgYmJveC55ID0gcGFyc2VGbG9hdChiYm94LnkpICsgcGFyc2VGbG9hdChiYm94LmgpIC8gMiAtIHlQb3M7XG5cbiAgICBiYm94LnggPSBiYm94LnggLyBwYXJzZUZsb2F0KHBhcmVudEJib3gudykgKiAxMDA7XG4gICAgYmJveC55ID0gYmJveC55IC8gcGFyc2VGbG9hdChwYXJlbnRCYm94LmgpICogMTAwO1xuXG4gICAgcmV0dXJuIGJib3g7XG4gIH0sXG4gIGZpbmRDaGlsZE5vZGVzOiBmdW5jdGlvbiAoZWxlLCBjaGlsZFRhZ05hbWUpIHtcbiAgICAvLyBmaW5kIGNoaWxkIG5vZGVzIGF0IGRlcHRoIGxldmVsIG9mIDEgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBlbGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZC50YWdOYW1lID09PSBjaGlsZFRhZ05hbWUpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgZmluZENoaWxkTm9kZTogZnVuY3Rpb24gKGVsZSwgY2hpbGRUYWdOYW1lKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5maW5kQ2hpbGROb2RlcyhlbGUsIGNoaWxkVGFnTmFtZSk7XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyBub2Rlc1swXSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgc3RhdGVBbmRJbmZvUHJvcDogZnVuY3Rpb24gKGVsZSwgcGFyZW50QmJveCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhdGVBbmRJbmZvQXJyYXkgPSBbXTtcblxuICAgIHZhciBjaGlsZEdseXBocyA9IHRoaXMuZmluZENoaWxkTm9kZXMoZWxlLCAnZ2x5cGgnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRHbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBnbHlwaCA9IGNoaWxkR2x5cGhzW2ldO1xuICAgICAgdmFyIGluZm8gPSB7fTtcblxuICAgICAgaWYgKGdseXBoLmNsYXNzTmFtZSA9PT0gJ3VuaXQgb2YgaW5mb3JtYXRpb24nKSB7XG4gICAgICAgIGluZm8uaWQgPSBnbHlwaC5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICBpbmZvLmNsYXp6ID0gZ2x5cGguY2xhc3NOYW1lIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGxhYmVsID0gZ2x5cGgucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcbiAgICAgICAgaW5mby5sYWJlbCA9IHtcbiAgICAgICAgICAndGV4dCc6IChsYWJlbCAmJiBsYWJlbC5nZXRBdHRyaWJ1dGUoJ3RleHQnKSkgfHwgdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGluZm8uYmJveCA9IHNlbGYuc3RhdGVBbmRJbmZvQmJveFByb3AoZ2x5cGgsIHBhcmVudEJib3gpO1xuICAgICAgICBzdGF0ZUFuZEluZm9BcnJheS5wdXNoKGluZm8pO1xuICAgICAgfSBlbHNlIGlmIChnbHlwaC5jbGFzc05hbWUgPT09ICdzdGF0ZSB2YXJpYWJsZScpIHtcbiAgICAgICAgaW5mby5pZCA9IGdseXBoLmdldEF0dHJpYnV0ZSgnaWQnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGluZm8uY2xhenogPSBnbHlwaC5jbGFzc05hbWUgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc3RhdGUgPSBnbHlwaC5xdWVyeVNlbGVjdG9yKCdzdGF0ZScpO1xuICAgICAgICB2YXIgdmFsdWUgPSAoc3RhdGUgJiYgc3RhdGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YXJpYWJsZSA9IChzdGF0ZSAmJiBzdGF0ZS5nZXRBdHRyaWJ1dGUoJ3ZhcmlhYmxlJykpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaW5mby5zdGF0ZSA9IHtcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAndmFyaWFibGUnOiB2YXJpYWJsZVxuICAgICAgICB9O1xuICAgICAgICBpbmZvLmJib3ggPSBzZWxmLnN0YXRlQW5kSW5mb0Jib3hQcm9wKGdseXBoLCBwYXJlbnRCYm94KTtcbiAgICAgICAgc3RhdGVBbmRJbmZvQXJyYXkucHVzaChpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHJldHVybiBzdGF0ZUFuZEluZm9BcnJheTtcbiAgfSxcbiAgYWRkUGFyZW50SW5mb1RvTm9kZTogZnVuY3Rpb24gKGVsZSwgbm9kZU9iaiwgcGFyZW50LCBjb21wYXJ0bWVudHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbXBhcnRtZW50UmVmID0gZWxlLmdldEF0dHJpYnV0ZSgnY29tcGFydG1lbnRSZWYnKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG5vZGVPYmoucGFyZW50ID0gcGFyZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb21wYXJ0bWVudFJlZikge1xuICAgICAgbm9kZU9iai5wYXJlbnQgPSBjb21wYXJ0bWVudFJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZU9iai5wYXJlbnQgPSAnJztcblxuICAgICAgLy8gYWRkIGNvbXBhcnRtZW50IGFjY29yZGluZyB0byBnZW9tZXRyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wYXJ0bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJib3hFbCA9IHNlbGYuZmluZENoaWxkTm9kZShlbGUsICdiYm94Jyk7XG4gICAgICAgIHZhciBiYm94ID0ge1xuICAgICAgICAgICd4JzogcGFyc2VGbG9hdChiYm94RWwuZ2V0QXR0cmlidXRlKCd4JykpLFxuICAgICAgICAgICd5JzogcGFyc2VGbG9hdChiYm94RWwuZ2V0QXR0cmlidXRlKCd5JykpLFxuICAgICAgICAgICd3JzogcGFyc2VGbG9hdChiYm94RWwuZ2V0QXR0cmlidXRlKCd3JykpLFxuICAgICAgICAgICdoJzogcGFyc2VGbG9hdChiYm94RWwuZ2V0QXR0cmlidXRlKCdoJykpLFxuICAgICAgICAgICdpZCc6IGVsZS5nZXRBdHRyaWJ1dGUoJ2lkJylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlbGYuaXNJbkJvdW5kaW5nQm94KGJib3gsIGNvbXBhcnRtZW50c1tpXSkpIHtcbiAgICAgICAgICBub2RlT2JqLnBhcmVudCA9IGNvbXBhcnRtZW50c1tpXS5pZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkQ3l0b3NjYXBlSnNOb2RlOiBmdW5jdGlvbiAoZWxlLCBqc29uQXJyYXksIHBhcmVudCwgY29tcGFydG1lbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBub2RlT2JqID0ge307XG5cbiAgICAvLyBhZGQgaWQgaW5mb3JtYXRpb25cbiAgICBub2RlT2JqLmlkID0gZWxlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAvLyBhZGQgbm9kZSBib3VuZGluZyBib3ggaW5mb3JtYXRpb25cbiAgICBub2RlT2JqLmJib3ggPSBzZWxmLmJib3hQcm9wKGVsZSk7XG4gICAgLy8gYWRkIGNsYXNzIGluZm9ybWF0aW9uXG4gICAgbm9kZU9iai5jbGFzcyA9IGVsZS5jbGFzc05hbWU7XG4gICAgLy8gYWRkIGxhYmVsIGluZm9ybWF0aW9uXG4gICAgdmFyIGxhYmVsID0gc2VsZi5maW5kQ2hpbGROb2RlKGVsZSwgJ2xhYmVsJyk7XG4gICAgbm9kZU9iai5sYWJlbCA9IChsYWJlbCAmJiBsYWJlbC5nZXRBdHRyaWJ1dGUoJ3RleHQnKSkgfHwgdW5kZWZpbmVkO1xuICAgIC8vIGFkZCBzdGF0ZSBhbmQgaW5mbyBib3ggaW5mb3JtYXRpb25cbiAgICBub2RlT2JqLnN0YXRlc2FuZGluZm9zID0gc2VsZi5zdGF0ZUFuZEluZm9Qcm9wKGVsZSwgbm9kZU9iai5iYm94KTtcbiAgICAvLyBhZGRpbmcgcGFyZW50IGluZm9ybWF0aW9uXG4gICAgc2VsZi5hZGRQYXJlbnRJbmZvVG9Ob2RlKGVsZSwgbm9kZU9iaiwgcGFyZW50LCBjb21wYXJ0bWVudHMpO1xuXG4gICAgLy8gYWRkIGNsb25lIGluZm9ybWF0aW9uXG4gICAgdmFyIGNsb25lTWFya2VycyA9IHNlbGYuZmluZENoaWxkTm9kZXMoZWxlLCAnY2xvbmUnKTtcbiAgICBpZiAoY2xvbmVNYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGVPYmouY2xvbmVtYXJrZXIgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlT2JqLmNsb25lbWFya2VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGFkZCBwb3J0IGluZm9ybWF0aW9uXG4gICAgdmFyIHBvcnRzID0gW107XG4gICAgdmFyIHBvcnRFbGVtZW50cyA9IGVsZS5xdWVyeVNlbGVjdG9yQWxsKCdwb3J0Jyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvcnRFbCA9IHBvcnRFbGVtZW50c1tpXTtcbiAgICAgIHZhciBpZCA9IHBvcnRFbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICB2YXIgcmVsYXRpdmVYUG9zID0gcGFyc2VGbG9hdChwb3J0RWwuZ2V0QXR0cmlidXRlKCd4JykpIC0gbm9kZU9iai5iYm94Lng7XG4gICAgICB2YXIgcmVsYXRpdmVZUG9zID0gcGFyc2VGbG9hdChwb3J0RWwuZ2V0QXR0cmlidXRlKCd5JykpIC0gbm9kZU9iai5iYm94Lnk7XG5cbiAgICAgIHJlbGF0aXZlWFBvcyA9IHJlbGF0aXZlWFBvcyAvIHBhcnNlRmxvYXQobm9kZU9iai5iYm94LncpICogMTAwO1xuICAgICAgcmVsYXRpdmVZUG9zID0gcmVsYXRpdmVZUG9zIC8gcGFyc2VGbG9hdChub2RlT2JqLmJib3guaCkgKiAxMDA7XG5cbiAgICAgIHBvcnRzLnB1c2goe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHg6IHJlbGF0aXZlWFBvcyxcbiAgICAgICAgeTogcmVsYXRpdmVZUG9zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBub2RlT2JqLnBvcnRzID0gcG9ydHM7XG5cbiAgICB2YXIgY3l0b3NjYXBlSnNOb2RlID0ge2RhdGE6IG5vZGVPYmp9O1xuICAgIGpzb25BcnJheS5wdXNoKGN5dG9zY2FwZUpzTm9kZSk7XG4gIH0sXG4gIHRyYXZlcnNlTm9kZXM6IGZ1bmN0aW9uIChlbGUsIGpzb25BcnJheSwgcGFyZW50LCBjb21wYXJ0bWVudHMpIHtcbiAgICB2YXIgZWxJZCA9IGVsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKCF0aGlzLnNiZ25tbFRhZ3NbZWxlLmNsYXNzTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnNlcnRlZE5vZGVzW2VsSWRdID0gdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYWRkIGNvbXBsZXggbm9kZXMgaGVyZVxuXG4gICAgdmFyIGVsZUNsYXNzID0gZWxlLmNsYXNzTmFtZTtcblxuICAgIGlmIChlbGVDbGFzcyA9PT0gJ2NvbXBsZXgnIHx8IGVsZUNsYXNzID09PSAnc3VibWFwJykge1xuICAgICAgc2VsZi5hZGRDeXRvc2NhcGVKc05vZGUoZWxlLCBqc29uQXJyYXksIHBhcmVudCwgY29tcGFydG1lbnRzKTtcblxuICAgICAgdmFyIGNoaWxkR2x5cGhzID0gc2VsZi5maW5kQ2hpbGROb2RlcyhlbGUsICdnbHlwaCcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSBjaGlsZEdseXBoc1tpXTtcbiAgICAgICAgdmFyIGdseXBoQ2xhc3MgPSBnbHlwaC5jbGFzc05hbWU7XG4gICAgICAgIGlmIChnbHlwaENsYXNzICE9PSAnc3RhdGUgdmFyaWFibGUnICYmIGdseXBoQ2xhc3MgIT09ICd1bml0IG9mIGluZm9ybWF0aW9uJykge1xuICAgICAgICAgIHNlbGYudHJhdmVyc2VOb2RlcyhnbHlwaCwganNvbkFycmF5LCBlbElkLCBjb21wYXJ0bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuYWRkQ3l0b3NjYXBlSnNOb2RlKGVsZSwganNvbkFycmF5LCBwYXJlbnQsIGNvbXBhcnRtZW50cyk7XG4gICAgfVxuICB9LFxuICBnZXRQb3J0czogZnVuY3Rpb24gKHhtbE9iamVjdCkge1xuICAgIHJldHVybiAoIHhtbE9iamVjdC5fY2FjaGVkUG9ydHMgPSB4bWxPYmplY3QuX2NhY2hlZFBvcnRzIHx8IHhtbE9iamVjdC5xdWVyeVNlbGVjdG9yQWxsKCdwb3J0JykpO1xuICB9LFxuICBnZXRHbHlwaHM6IGZ1bmN0aW9uICh4bWxPYmplY3QpIHtcbiAgICB2YXIgZ2x5cGhzID0geG1sT2JqZWN0Ll9jYWNoZWRHbHlwaHM7XG5cbiAgICBpZiAoIWdseXBocykge1xuICAgICAgZ2x5cGhzID0geG1sT2JqZWN0Ll9jYWNoZWRHbHlwaHMgPSB4bWxPYmplY3QuX2NhY2hlZEdseXBocyB8fCB4bWxPYmplY3QucXVlcnlTZWxlY3RvckFsbCgnZ2x5cGgnKTtcblxuICAgICAgdmFyIGlkMmdseXBoID0geG1sT2JqZWN0Ll9pZDJnbHlwaCA9IHt9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBnID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgaWQgPSBnLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgICAgICBpZDJnbHlwaFsgaWQgXSA9IGc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbiAgfSxcbiAgZ2V0R2x5cGhCeUlkOiBmdW5jdGlvbiAoeG1sT2JqZWN0LCBpZCkge1xuICAgIHRoaXMuZ2V0R2x5cGhzKHhtbE9iamVjdCk7IC8vIG1ha2Ugc3VyZSBjYWNoZSBpcyBidWlsdFxuXG4gICAgcmV0dXJuIHhtbE9iamVjdC5faWQyZ2x5cGhbaWRdO1xuICB9LFxuICBnZXRBcmNTb3VyY2VBbmRUYXJnZXQ6IGZ1bmN0aW9uIChhcmMsIHhtbE9iamVjdCkge1xuICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGNhbiBiZSBpbnNpZGUgb2YgYSBwb3J0XG4gICAgdmFyIHNvdXJjZSA9IGFyYy5nZXRBdHRyaWJ1dGUoJ3NvdXJjZScpO1xuICAgIHZhciB0YXJnZXQgPSBhcmMuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICB2YXIgc291cmNlTm9kZUlkO1xuICAgIHZhciB0YXJnZXROb2RlSWQ7XG5cbiAgICB2YXIgc291cmNlRXhpc3RzID0gdGhpcy5nZXRHbHlwaEJ5SWQoeG1sT2JqZWN0LCBzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRFeGlzdHMgPSB0aGlzLmdldEdseXBoQnlJZCh4bWxPYmplY3QsIHRhcmdldCk7XG5cbiAgICBpZiAoc291cmNlRXhpc3RzKSB7XG4gICAgICBzb3VyY2VOb2RlSWQgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldEV4aXN0cykge1xuICAgICAgdGFyZ2V0Tm9kZUlkID0gdGFyZ2V0O1xuICAgIH1cblxuXG4gICAgdmFyIGk7XG4gICAgdmFyIHBvcnRFbHMgPSB0aGlzLmdldFBvcnRzKHhtbE9iamVjdCk7XG4gICAgdmFyIHBvcnQ7XG4gICAgaWYgKHNvdXJjZU5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcG9ydEVscy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgcG9ydCA9IHBvcnRFbHNbaV07XG4gICAgICAgIGlmIChwb3J0LmdldEF0dHJpYnV0ZSgnaWQnKSA9PT0gc291cmNlKSB7XG4gICAgICAgICAgc291cmNlTm9kZUlkID0gcG9ydC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0YXJnZXROb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvcnRFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9ydCA9IHBvcnRFbHNbaV07XG4gICAgICAgIGlmIChwb3J0LmdldEF0dHJpYnV0ZSgnaWQnKSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZUlkID0gcG9ydC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7J3NvdXJjZSc6IHNvdXJjZU5vZGVJZCwgJ3RhcmdldCc6IHRhcmdldE5vZGVJZH07XG4gIH0sXG5cbiAgZ2V0QXJjQmVuZFBvaW50UG9zaXRpb25zOiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGJlbmRQb2ludFBvc2l0aW9ucyA9IFtdO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5maW5kQ2hpbGROb2RlcyhlbGUsICduZXh0Jyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9zWCA9IGNoaWxkcmVuW2ldLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgdmFyIHBvc1kgPSBjaGlsZHJlbltpXS5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgICAgYmVuZFBvaW50UG9zaXRpb25zLnB1c2goe1xuICAgICAgICB4OiBwb3NYLFxuICAgICAgICB5OiBwb3NZXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVuZFBvaW50UG9zaXRpb25zO1xuICB9LFxuICBhZGRDeXRvc2NhcGVKc0VkZ2U6IGZ1bmN0aW9uIChlbGUsIGpzb25BcnJheSwgeG1sT2JqZWN0KSB7XG4gICAgaWYgKCF0aGlzLnNiZ25tbFRhZ3NbZWxlLmNsYXNzTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZUFuZFRhcmdldCA9IHNlbGYuZ2V0QXJjU291cmNlQW5kVGFyZ2V0KGVsZSwgeG1sT2JqZWN0KTtcblxuICAgIGlmICghdGhpcy5pbnNlcnRlZE5vZGVzW3NvdXJjZUFuZFRhcmdldC5zb3VyY2VdIHx8ICF0aGlzLmluc2VydGVkTm9kZXNbc291cmNlQW5kVGFyZ2V0LnRhcmdldF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWRnZU9iaiA9IHt9O1xuICAgIHZhciBiZW5kUG9pbnRQb3NpdGlvbnMgPSBzZWxmLmdldEFyY0JlbmRQb2ludFBvc2l0aW9ucyhlbGUpO1xuXG4gICAgZWRnZU9iai5pZCA9IGVsZS5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgdW5kZWZpbmVkO1xuICAgIGVkZ2VPYmouY2xhc3MgPSBlbGUuY2xhc3NOYW1lO1xuICAgIGVkZ2VPYmouYmVuZFBvaW50UG9zaXRpb25zID0gYmVuZFBvaW50UG9zaXRpb25zO1xuXG4gICAgdmFyIGdseXBoQ2hpbGRyZW4gPSBzZWxmLmZpbmRDaGlsZE5vZGVzKGVsZSwgJ2dseXBoJyk7XG4gICAgdmFyIGdseXBoRGVzY2VuZGVudHMgPSBlbGUucXVlcnlTZWxlY3RvckFsbCgnZ2x5cGgnKTtcbiAgICBpZiAoZ2x5cGhEZXNjZW5kZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgZWRnZU9iai5jYXJkaW5hbGl0eSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ2x5cGhDaGlsZHJlbltpXS5jbGFzc05hbWUgPT09ICdjYXJkaW5hbGl0eScpIHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBnbHlwaENoaWxkcmVuW2ldLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG4gICAgICAgICAgZWRnZU9iai5jYXJkaW5hbGl0eSA9IGxhYmVsLmdldEF0dHJpYnV0ZSgndGV4dCcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVkZ2VPYmouc291cmNlID0gc291cmNlQW5kVGFyZ2V0LnNvdXJjZTtcbiAgICBlZGdlT2JqLnRhcmdldCA9IHNvdXJjZUFuZFRhcmdldC50YXJnZXQ7XG5cbiAgICBlZGdlT2JqLnBvcnRzb3VyY2UgPSBlbGUuZ2V0QXR0cmlidXRlKCdzb3VyY2UnKTtcbiAgICBlZGdlT2JqLnBvcnR0YXJnZXQgPSBlbGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcblxuICAgIHZhciBjeXRvc2NhcGVKc0VkZ2UgPSB7ZGF0YTogZWRnZU9ian07XG4gICAganNvbkFycmF5LnB1c2goY3l0b3NjYXBlSnNFZGdlKTtcbiAgfSxcbiAgY29udmVydDogZnVuY3Rpb24gKHNiZ25tbFRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN5dG9zY2FwZUpzTm9kZXMgPSBbXTtcbiAgICB2YXIgY3l0b3NjYXBlSnNFZGdlcyA9IFtdO1xuXG4gICAgdmFyIHhtbE9iamVjdCA9IHRoaXMubG9hZFhNTEZyb21TdHJpbmcoc2Jnbm1sVGV4dCk7XG5cbiAgICB2YXIgY29tcGFydG1lbnRzID0gc2VsZi5nZXRBbGxDb21wYXJ0bWVudHMoeG1sT2JqZWN0KTtcblxuICAgIHZhciBnbHlwaHMgPSBzZWxmLmZpbmRDaGlsZE5vZGVzKHhtbE9iamVjdC5xdWVyeVNlbGVjdG9yKCdtYXAnKSwgJ2dseXBoJyk7XG4gICAgdmFyIGFyY3MgPSBzZWxmLmZpbmRDaGlsZE5vZGVzKHhtbE9iamVjdC5xdWVyeVNlbGVjdG9yKCdtYXAnKSwgJ2FyYycpO1xuXG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgc2VsZi50cmF2ZXJzZU5vZGVzKGdseXBoLCBjeXRvc2NhcGVKc05vZGVzLCAnJywgY29tcGFydG1lbnRzKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJjcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyYyA9IGFyY3NbaV07XG4gICAgICBzZWxmLmFkZEN5dG9zY2FwZUpzRWRnZShhcmMsIGN5dG9zY2FwZUpzRWRnZXMsIHhtbE9iamVjdCk7XG4gICAgfVxuXG4gICAgdmFyIGN5dG9zY2FwZUpzR3JhcGggPSB7fTtcbiAgICBjeXRvc2NhcGVKc0dyYXBoLm5vZGVzID0gY3l0b3NjYXBlSnNOb2RlcztcbiAgICBjeXRvc2NhcGVKc0dyYXBoLmVkZ2VzID0gY3l0b3NjYXBlSnNFZGdlcztcblxuICAgIHRoaXMuaW5zZXJ0ZWROb2RlcyA9IHt9O1xuXG4gICAgcmV0dXJuIGN5dG9zY2FwZUpzR3JhcGg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2Jnbm1sQ29udmVydGVyO1xuIiwibGV0IEN5dG9zY2FwZSA9IHJlcXVpcmUoJ2N5dG9zY2FwZScpO1xubGV0IGRlZmF1bHRzRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC5kZWZhdWx0c2RlZXAnKTtcblxubGV0IHNiZ25TdHlsZVNoZWV0ID0gcmVxdWlyZSgnLi9zYmduU3R5bGUvZ3JhcGgnKTtcblxubGV0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzdHlsZTogc2JnblN0eWxlU2hlZXQoQ3l0b3NjYXBlKSxcbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgc2hvd092ZXJsYXk6IGZhbHNlLFxuICBtaW5ab29tOiBmYWxzZSxcbiAgbWF4Wm9vbTogZmFsc2UsXG4gIG1vdGlvbkJsdXI6IGZhbHNlLFxuICB3aGVlbFNlbnNpdGl2aXR5OiAwLjFcbn07XG5cbmNsYXNzIFNCR05SZW5kZXJlciBleHRlbmRzIEN5dG9zY2FwZSB7XG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICl7XG4gICAgc3VwZXIoIGRlZmF1bHRzRGVlcCgge30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zICkgKTtcbiAgfVxuLy8gICBUT0RPOiBJbml0aWFsIHNiZ24tcmVuZGVyZXIgYXBpXG4vLyAgIHNiZ24gKGtkZmtkKSB7IC8vIHRoZSBmdW5jdGlvbiB0aGF0IGNhbiBwb3NzaWJseSB0dXJuZWQgaW50byBhbiBleHRlbnNpb25cbi8vICAgLi4uOyAvLyBzdHlsZSBzaGVldCBjYW4gYmUgc2V0IGluIGhlcmVcbi8vICAgLi4uOyAvLyBhY2NlcHQgc2JuZ21sIGZpbGUgb3Igc3RyaW5nLCBwcm9taXNlIHRvIHJlc29sdmUgdG8gc3RyaW5nIChmZXRjaCBzdXBwb3J0KSwgcG9zc2libHkgYWx3YXlzIHRyZWF0IGl0IGFzIGEgcHJvbWlzZVxuLy8gICAuLi47IC8vIGV4cG9ydCAgdG8gc2Jnbm1sIGZpbGUgb3IgcGljdHVyZVxuLy8gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQkdOUmVuZGVyZXI7XG4iLCJ2YXIgZWxlbWVudFN0eWxlID0ge307XG5cbmVsZW1lbnRTdHlsZS5zYmduU2hhcGUgPSAobm9kZSkgPT4ge1xuICBsZXQgc2JnbkNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICBpZiAoc2JnbkNsYXNzLmVuZHNXaXRoKCcgbXVsdGltZXInKSkge1xuICAgIHNiZ25DbGFzcyA9IHNiZ25DbGFzcy5yZXBsYWNlKCcgbXVsdGltZXInLCAnJyk7XG4gIH1cblxuICBpZiAoc2JnbkNsYXNzID09ICdwaGVub3R5cGUnKSB7XG4gICAgcmV0dXJuICdoZXhhZ29uJztcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgcmV0dXJuICdzcXVhcmUnO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAncGVydHVyYmluZyBhZ2VudCcgfHwgc2JnbkNsYXNzID09ICd0YWcnXG4gICAgfHwgc2JnbkNsYXNzID09ICdzb3VyY2UgYW5kIHNpbmsnIHx8IHNiZ25DbGFzcyA9PSAnY29tcGFydG1lbnQnIHx8IHNiZ25DbGFzcyA9PSAnY29tcGxleCcpIHtcbiAgICByZXR1cm4gJ3BvbHlnb24nO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAnZGlzc29jaWF0aW9uJykge1xuICAgIHJldHVybiAnZWxsaXBzZSc7XG4gIH1cblxuICBpZiAoIHNiZ25DbGFzcyA9PSAnbnVjbGVpYyBhY2lkIGZlYXR1cmUnIHx8IHNiZ25DbGFzcyA9PSAnbWFjcm9tb2xlY3VsZScpIHtcbiAgICByZXR1cm4gJ3JvdW5kcmVjdGFuZ2xlJztcbiAgfVxuICByZXR1cm4gJ2VsbGlwc2UnO1xufTtcblxuZWxlbWVudFN0eWxlLnNiZ25BcnJvd1NoYXBlID0gKGVkZ2UpID0+IHtcbiAgbGV0IHNiZ25DbGFzcyA9IGVkZ2UuZGF0YSgnY2xhc3MnKTtcbiAgaWYgKHNiZ25DbGFzcyA9PSAnbmVjZXNzYXJ5IHN0aW11bGF0aW9uJykge1xuICAgIHJldHVybiAndHJpYW5nbGUtY3Jvc3MnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2luaGliaXRpb24nKSB7XG4gICAgcmV0dXJuICd0ZWUnO1xuICB9XG4gIGlmIChzYmduQ2xhc3MgPT0gJ2NhdGFseXNpcycpIHtcbiAgICByZXR1cm4gJ2NpcmNsZSc7XG4gIH1cbiAgaWYgKHNiZ25DbGFzcyA9PSAnc3RpbXVsYXRpb24nIHx8IHNiZ25DbGFzcyA9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gJ3RyaWFuZ2xlJztcbiAgfVxuICBpZiAoc2JnbkNsYXNzID09ICdtb2R1bGF0aW9uJykge1xuICAgIHJldHVybiAnZGlhbW9uZCc7XG4gIH1cbiAgcmV0dXJuICdub25lJztcbn07XG5cbmVsZW1lbnRTdHlsZS5zYmduQ29udGVudCA9IChub2RlKSA9PiB7XG4gIGxldCBzYmduQ2xhc3MgPSBub2RlLmRhdGEoJ2NsYXNzJyk7XG4gIGxldCBjb250ZW50ID0gJyc7XG5cbiAgaWYgKHNiZ25DbGFzcy5lbmRzV2l0aCgnIG11bHRpbWVyJykpIHtcbiAgICBzYmduQ2xhc3MgPSBzYmduQ2xhc3MucmVwbGFjZSgnIG11bHRpbWVyJywgJycpO1xuICB9XG5cbiAgaWYgKHNiZ25DbGFzcyA9PSAnbWFjcm9tb2xlY3VsZScgfHwgc2JnbkNsYXNzID09ICdzaW1wbGUgY2hlbWljYWwnXG4gICAgICB8fCBzYmduQ2xhc3MgPT0gJ3BoZW5vdHlwZSdcbiAgICAgIHx8IHNiZ25DbGFzcyA9PSAndW5zcGVjaWZpZWQgZW50aXR5JyB8fCBzYmduQ2xhc3MgPT0gJ251Y2xlaWMgYWNpZCBmZWF0dXJlJ1xuICAgICAgfHwgc2JnbkNsYXNzID09ICdwZXJ0dXJiaW5nIGFnZW50JyB8fCBzYmduQ2xhc3MgPT0gJ3RhZycpIHtcbiAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdsYWJlbCcpID8gbm9kZS5kYXRhKCdsYWJlbCcpIDogJyc7XG4gIH1cbiAgZWxzZSBpZihzYmduQ2xhc3MgPT0gJ2NvbXBhcnRtZW50Jyl7XG4gICAgY29udGVudCA9IG5vZGUuZGF0YSgnbGFiZWwnKSA/IG5vZGUuZGF0YSgnbGFiZWwnKSA6ICcnO1xuICB9XG4gIGVsc2UgaWYoc2JnbkNsYXNzID09ICdjb21wbGV4Jyl7XG4gICAgaWYobm9kZS5jaGlsZHJlbigpLmxlbmd0aCA9PSAwKXtcbiAgICAgIGlmKG5vZGUuZGF0YSgnbGFiZWwnKSl7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmRhdGEoJ2xhYmVsJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKG5vZGUuZGF0YSgnaW5mb0xhYmVsJykpe1xuICAgICAgICBjb250ZW50ID0gbm9kZS5kYXRhKCdpbmZvTGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdhbmQnKSB7XG4gICAgY29udGVudCA9ICdBTkQnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb3InKSB7XG4gICAgY29udGVudCA9ICdPUic7XG4gIH1cbiAgZWxzZSBpZiAoc2JnbkNsYXNzID09ICdub3QnKSB7XG4gICAgY29udGVudCA9ICdOT1QnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAnb21pdHRlZCBwcm9jZXNzJykge1xuICAgIGNvbnRlbnQgPSAnXFxcXFxcXFwnO1xuICB9XG4gIGVsc2UgaWYgKHNiZ25DbGFzcyA9PSAndW5jZXJ0YWluIHByb2Nlc3MnKSB7XG4gICAgY29udGVudCA9ICc/JztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufTtcblxuY29uc3QgZHluYW1pY0xhYmVsVGV4dFNpemUgPSAobm9kZUhlaWdodCwgc2l6ZUNvZWZmaWNpZW50ID0gMSkgPT4ge1xuICByZXR1cm4gKG5vZGVIZWlnaHQgLyAyLjQ1KSAqIHNpemVDb2VmZmljaWVudDtcbn07XG5cbmVsZW1lbnRTdHlsZS5sYWJlbFRleHRTaXplID0gKG5vZGUpID0+IHtcbiAgY29uc3Qgc2JnbkNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICBjb25zdCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgLy8gRGlydHkgbGVnYWN5IGhhY2suICBUaGVzZSB0eXBlcyBvZiBub2RlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGhhdmUgbGFiZWxzXG4gIC8vIGJ1dCBhcHBhcmVudGx5IHRoZXkgbmVlZCB0byBoYXZlIGEgdGV4dCBzaXplXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhc3NvY2lhdGlvbicgfHwgc2JnbkNsYXNzID09PSAnZGlzc29jaWF0aW9uJykge1xuICAgIHJldHVybiAyMDtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdhbmQnIHx8IHNiZ25DbGFzcyA9PT0gJ29yJyB8fCBzYmduQ2xhc3MgPT09ICdub3QnKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNMYWJlbFRleHRTaXplKG5oLCAxKTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MuZW5kc1dpdGgoJ3Byb2Nlc3MnKSkge1xuICAgIHJldHVybiBkeW5hbWljTGFiZWxUZXh0U2l6ZShuaCwgMS41KTtcbiAgfVxuXG4gIGlmIChzYmduQ2xhc3MgPT09ICdjb21wbGV4JyB8fCBzYmduQ2xhc3MgPT09ICdjb21wYXJ0bWVudCcpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cblxuICByZXR1cm4gZHluYW1pY0xhYmVsVGV4dFNpemUobmgpO1xufTtcblxuZWxlbWVudFN0eWxlLmNhcmRpbmFsaXR5RGlzdGFuY2UgPSAoZWRnZSkgPT4ge1xuICBjb25zdCBzcmNQb3MgPSBlZGdlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gIGNvbnN0IHRndFBvcyA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdygoc3JjUG9zLnggLSB0Z3RQb3MueCksIDIpICsgTWF0aC5wb3coKHNyY1Bvcy55IC0gdGd0UG9zLnkpLCAyKSk7XG4gIHJldHVybiBkaXN0YW5jZSAqIDAuMTU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRTdHlsZTtcbiIsImNvbnN0IGJhc2VTaGFwZXMgPSB7XG4gIHN0eWxlTWFwMlN0ciAoc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYCR7Wy4uLnN0eWxlTWFwXS5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn07YCkuam9pbignICcpfWA7XG4gIH0sXG5cbiAgYmFzZVJlY3RhbmdsZSAoeCwgeSwgdywgaCwgcjEsIHIyLCByMywgcjQsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGBcbiAgICA8cGF0aCBzdHlsZT0nJHt0aGlzLnN0eWxlTWFwMlN0cihzdHlsZU1hcCl9JyBkPSdcbiAgICAgIE0gJHt4ICsgcjF9ICR7eX1cbiAgICAgIEwgJHt4ICsgdyAtIHIyfSAke3l9IFEgJHt4ICsgd30gJHt5fSAke3ggKyB3fSAke3kgKyByMn1cbiAgICAgIEwgJHt4ICsgdyB9ICR7eSArIGggLSByM30gUSAke3ggKyB3fSAke3kgKyBofSAke3ggKyB3IC0gcjN9ICR7eSArIGh9XG4gICAgICBMICR7eCArIHI0fSAke3kgKyBofSBRICR7eH0gJHt5ICsgaH0gJHt4fSAke3kgKyBoIC0gcjR9XG4gICAgICBMICR7eH0gJHt5ICsgcjF9IFEgJHt4fSAke3l9ICR7eCArIHIxfSAke3l9XG4gICAgICBaJ1xuICAgIC8+XG4gICAgYDtcbiAgfSxcblxuICBiYXJyZWwgKHdpZHRoLCBoZWlnaHQsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIGBcblxuICAgIDxnIHN0eWxlPVwiJHt0aGlzLnN0eWxlTWFwMlN0cihzdHlsZU1hcCl9XCI+XG4gICAgICA8cGF0aCBkPVwiTSAkezAqd2lkdGh9ICR7LjAzKmhlaWdodH0gTCAkezAqd2lkdGh9ICR7Ljk3KmhlaWdodH0gUSAkezAuMDYqd2lkdGh9ICR7aGVpZ2h0fSAkezAuMjUqd2lkdGh9ICR7aGVpZ2h0fVwiLz5cblxuICAgICAgPHBhdGggZD1cIk0gJHswLjI1KndpZHRofSAke2hlaWdodH0gTCAkezAuNzUqd2lkdGh9ICR7aGVpZ2h0fSBRICR7MC45NSp3aWR0aH0gJHtoZWlnaHR9ICR7d2lkdGh9ICR7MC45NSpoZWlnaHR9XCIvPlxuXG4gICAgICA8cGF0aCBkPVwiTSAke3dpZHRofSAkey45NSpoZWlnaHR9IEwgJHt3aWR0aH0gJHswLjA1KmhlaWdodH0gUSAke3dpZHRofSAkezAqaGVpZ2h0fSAkezAuNzUqd2lkdGh9ICR7MCpoZWlnaHR9XCIvPlxuXG4gICAgICA8cGF0aCBkPVwiTSAkezAuNzUqd2lkdGh9ICR7MCpoZWlnaHR9IEwgJHswLjI1KndpZHRofSAkezAqaGVpZ2h0fSBRICR7MC4wNip3aWR0aH0gJHswKmhlaWdodH0gJHswKndpZHRofSAkezAuMDMqaGVpZ2h0fVwiLz5cbiAgICA8L2c+XG5cbiAgICBgO1xuICB9LFxuXG4gIGNpcmNsZSAoY3gsIGN5LCByLCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgPGNpcmNsZSBjeD0nJHtjeH0nIGN5PScke2N5fScgcj0nJHtyfScgc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfScgLz5gO1xuICB9LFxuXG4gIGNvbmNhdmVIZXhhZ29uICh3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG4gICAgPHBvbHlnb24gc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfSdcbiAgICAgIHBvaW50cz0nJHswfSwgJHswfSwgJHt3aWR0aH0sICR7MH0sICR7MC44NSp3aWR0aH0sICR7MC41KmhlaWdodH0sICR7d2lkdGh9LCAke2hlaWdodH0sICR7MH0sICR7aGVpZ2h0fSwgJHswLjE1KndpZHRofSwgJHswLjUqaGVpZ2h0fSdcbiAgICAvPmA7XG4gIH0sXG5cbiAgY3V0UmVjdGFuZ2xlICh3aWR0aCwgaGVpZ2h0LCBzdHlsZU1hcCkge1xuICAgIHJldHVybiBgXG4gICAgPHBvbHlnb24gc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfSdcbiAgICAgIHBvaW50cz0nXG4gICAgICAkezAqd2lkdGh9ICR7MC4wNSpoZWlnaHR9ICR7MC4wNSp3aWR0aH0gJHswKmhlaWdodH0gJHswLjk1KndpZHRofSAkezAqaGVpZ2h0fSAke3dpZHRofSAkezAuMDUqaGVpZ2h0fVxuICAgICAgJHt3aWR0aH0gJHswLjk1KmhlaWdodH0gJHswLjk1KndpZHRofSAke2hlaWdodH0gJHswLjA1KndpZHRofSAke2hlaWdodH0gJHswKndpZHRofSAkezAuOTUqaGVpZ2h0fVxuICAgICAgJ1xuICAgIC8+XG4gICAgYDtcbiAgfSxcblxuICBlbGxpcHNlIChjeCwgY3ksIHJ4LCByeSwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGVsbGlwc2UgY3g9JyR7Y3h9JyBjeT0nJHtjeX0nIHJ4PScke3J4fScgcnk9JyR7cnl9JyBzdHlsZT0nJHt0aGlzLnN0eWxlTWFwMlN0cihzdHlsZU1hcCl9JyAvPlxuICAgIGA7XG4gIH0sXG5cbiAgaGV4YWdvbiAod2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYFxuICAgIDxwb2x5Z29uIHN0eWxlPScke3RoaXMuc3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0nXG4gICAgICBwb2ludHM9JyR7MH0sICR7MC41KmhlaWdodH0sICR7MC4yNSp3aWR0aH0sICR7MCpoZWlnaHR9LCAkezAuNzUqd2lkdGh9LCAkezAqaGVpZ2h0fSwgJHt3aWR0aH0sICR7MC41KmhlaWdodH0sICR7MC43NSp3aWR0aH0sICR7aGVpZ2h0fSwgJHswLjI1KndpZHRofSwgJHtoZWlnaHR9J1xuICAgIC8+YDtcbiAgfSxcblxuICBsaW5lICh4MSwgeTEsIHgyLCB5Miwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYDxsaW5lIHgxPScke3gxfScgeTE9JyR7eTF9JyB4Mj0nJHt4Mn0nIHkyPScke3kyfScgc3R5bGU9JyR7dGhpcy5zdHlsZU1hcDJTdHIoc3R5bGVNYXApfScgLz5gO1xuICB9LFxuXG4gIHJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIDAsIDAsIDAsIHN0eWxlTWFwKTtcbiAgfSxcblxuICByb3VuZEJvdHRvbVJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIDAsIC4zKmhlaWdodCwgLjMqaGVpZ2h0LCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgcm91bmRSZWN0YW5nbGUgKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAuMypoZWlnaHQsIC4zKmhlaWdodCwgLjMqaGVpZ2h0LCAuMypoZWlnaHQsIHN0eWxlTWFwKTtcbiAgfSxcblxuICBzcXVhcmUgKHgsIHksIGxlbmd0aCwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlUmVjdGFuZ2xlKHgsIHksIGxlbmd0aCwgbGVuZ3RoLCAwLCAwLCAwLCAwLCBzdHlsZU1hcCk7XG4gIH0sXG5cbiAgdGV4dCAodCwgeCwgeSwgdGV4dEFuY2hvciwgc3R5bGVNYXApIHtcbiAgICByZXR1cm4gYDx0ZXh0IHg9JyR7eH0nIHk9JyR7eX0nIHRleHRBbmNob3I9JyR7dGV4dEFuY2hvcn0nIHN0eWxlPScke3RoaXMuc3R5bGVNYXAyU3RyKHN0eWxlTWFwKX0nPiR7dH08L3RleHQ+YDtcbiAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNoYXBlcztcbiIsImNvbnN0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMuanMnKTtcbmNvbnN0IHN2Z1N0ciA9IHJlcXVpcmUoJy4uL3V0aWwvc3ZnLmpzJyk7XG5cbmNvbnN0IGNvbnRhaW5lck5vZGVzID0ge1xuXG4gIGNvbXBhcnRtZW50IChub2RlKSB7XG4gICAgY29uc3QgbmggPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gICAgY29uc3QgbncgPSBub2RlLm91dGVyV2lkdGgoKTtcblxuICAgIGNvbnN0IHN0eWxlID0gbmV3IE1hcCgpXG4gICAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMy43NScpXG4gICAgICAuc2V0KCdmaWxsJywgJ25vbmUnKVxuICAgICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKTtcblxuICAgIGNvbnN0IGNvbXBhcnRtZW50U3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuYmFycmVsKG53LCBuaCwgc3R5bGUpfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihjb21wYXJ0bWVudFN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5lck5vZGVzOyIsImNvbnN0IGJhc2VTaGFwZXMgPSByZXF1aXJlKCcuL2Jhc2VTaGFwZXMuanMnKTtcbmNvbnN0IHN2Z1N0ciA9IHJlcXVpcmUoJy4uL3V0aWwvc3ZnLmpzJyk7XG5cbmNvbnN0IGVudGl0eVBvb2xOb2RlcyA9IHtcblxuICB1bnNwZWNpZmllZEVudGl0eSAobm9kZSkge1xuICAgIGxldCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgbGV0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCB1bnNwZWNFbnRpdHlTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5lbGxpcHNlKG53IC8gMiwgbmggLyAyLCAoIG5oIC0gMiApIC8gMiwgKCBudyAtIDIgKSAvIDIsIHN0eWxlTWFwKX1cbiAgICBgO1xuICAgIHJldHVybiBzdmdTdHIodW5zcGVjRW50aXR5U3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgc2ltcGxlQ2hlbWljYWwgKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgc2ltcGxlQ2hlbWljYWxTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUobncgLyAyLCBuaCAvIDIsIChNYXRoLm1pbihudywgbmgpIC0gMikgLyAyLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHNpbXBsZUNoZW1pY2FsU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgbWFjcm9tb2xlY3VsZSAobm9kZSkge1xuICAgIGxldCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgbGV0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICczJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGxldCBtYWNyb21vbGVjdWxlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMucm91bmRSZWN0YW5nbGUoMCwgMCwgbncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKG1hY3JvbW9sZWN1bGVTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBudWNsZWljQWNpZEZlYXR1cmUgKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMycpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgbnVjbGVpY0FjaWRGZWF0dXJlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMucm91bmRCb3R0b21SZWN0YW5nbGUoMCwgMCwgbncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKG51Y2xlaWNBY2lkRmVhdHVyZVN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9LFxuXG4gIGNvbXBsZXggKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICBsZXQgbmggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgICBsZXQgc3R5bGVNYXAgPSBuZXcgTWFwKClcbiAgICAuc2V0KCdzdHJva2UnLCAnIzZBNkE2QScpXG4gICAgLnNldCgnc3Ryb2tlLXdpZHRoJywgJzMnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgbGV0IGNvbXBsZXhTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jdXRSZWN0YW5nbGUobncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKGNvbXBsZXhTdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBzb3VyY2VBbmRTaW5rIChub2RlKSB7XG4gICAgbGV0IG5vZGVDZW50ZXJYID0gbm9kZS53aWR0aCgpIC8gMjtcbiAgICBsZXQgbm9kZUNlbnRlclkgPSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBsZXQgY2lyY2xlUmFkaXVzID0gKG5vZGUud2lkdGgoKSAtIDIpIC8gMjtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2UtbGluZWNhcCcsICdzcXVhcmUnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcxLjUnKVxuICAgIC5zZXQoJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgY29uc3Qgc291cmNlQW5kU2lua1N2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShub2RlQ2VudGVyWCwgbm9kZUNlbnRlclksIGNpcmNsZVJhZGl1cywgc3R5bGVNYXApfVxuICAgICAgJHtiYXNlU2hhcGVzLmxpbmUoMCwgbm9kZS5oZWlnaHQoKSwgbm9kZS53aWR0aCgpLCAwLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHNvdXJjZUFuZFNpbmtTdmcsIG5vZGUud2lkdGgoKSwgbm9kZS5oZWlnaHQoKSwgMCwgMCwgbm9kZS53aWR0aCgpLCBub2RlLmhlaWdodCgpKTtcbiAgfSxcblxuICBwZXJ0dXJiaW5nQWdlbnQgKG5vZGUpIHtcbiAgICBsZXQgbncgPSBub2RlLndpZHRoKCk7XG4gICAgbGV0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMycpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgcGVydHVyYmluZ0FnZW50U3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuY29uY2F2ZUhleGFnb24obncsIG5oLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKHBlcnR1cmJpbmdBZ2VudFN2ZywgbncsIG5oLCAwLCAwLCBudywgbmgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudGl0eVBvb2xOb2RlczsiLCJjb25zdCBjb250YWluZXJOb2RlcyA9IHJlcXVpcmUoJy4vY29udGFpbmVyTm9kZVNoYXBlcy5qcycpO1xuY29uc3QgZW50aXR5UG9vbE5vZGVzID0gcmVxdWlyZSgnLi9lbnRpdHlQb29sTm9kZVNoYXBlcy5qcycpO1xuY29uc3QgcHJvY2Vzc05vZGVzID0gcmVxdWlyZSgnLi9wcm9jZXNzTm9kZVNoYXBlcy5qcycpO1xuXG5jb25zdCBzYmduTm9kZVNoYXBlTWFwID0gbmV3IE1hcCgpXG4vLyBwcm9jZXNzIG5vZGVzXG4uc2V0KCdwcm9jZXNzJywgcHJvY2Vzc05vZGVzLnByb2Nlc3MpXG4uc2V0KCdvbWl0dGVkIHByb2Nlc3MnLCBwcm9jZXNzTm9kZXMucHJvY2Vzcylcbi5zZXQoJ3VuY2VydGFpbiBwcm9jZXNzJywgcHJvY2Vzc05vZGVzLnByb2Nlc3MpXG4uc2V0KCdhc3NvY2lhdGlvbicsIHByb2Nlc3NOb2Rlcy5hc3NvY2lhdGlvbilcbi5zZXQoJ2Rpc3NvY2lhdGlvbicsIHByb2Nlc3NOb2Rlcy5kaXNzb2NpYXRpb24pXG4uc2V0KCdwaGVub3R5cGUnLCBwcm9jZXNzTm9kZXMucGhlbm90eXBlKVxuXG4vLyBlbnRpdHkgcG9vbCBub2Rlc1xuLnNldCgnc291cmNlIGFuZCBzaW5rJywgZW50aXR5UG9vbE5vZGVzLnNvdXJjZUFuZFNpbmspXG4uc2V0KCd1bnNwZWNpZmllZCBlbnRpdHknLCBlbnRpdHlQb29sTm9kZXMudW5zcGVjaWZpZWRFbnRpdHkpXG4uc2V0KCdzaW1wbGUgY2hlbWljYWwnLCBlbnRpdHlQb29sTm9kZXMuc2ltcGxlQ2hlbWljYWwpXG4uc2V0KCdtYWNyb21vbGVjdWxlJywgZW50aXR5UG9vbE5vZGVzLm1hY3JvbW9sZWN1bGUpXG4uc2V0KCdudWNsZWljIGFjaWQgZmVhdHVyZScsIGVudGl0eVBvb2xOb2Rlcy5udWNsZWljQWNpZEZlYXR1cmUpXG4uc2V0KCdjb21wbGV4JywgZW50aXR5UG9vbE5vZGVzLmNvbXBsZXgpXG4uc2V0KCdwZXJ0dXJiaW5nIGFnZW50JywgZW50aXR5UG9vbE5vZGVzLnBlcnR1cmJpbmdBZ2VudClcblxuLy8gY29udGFpbmVyIG5vZGVzXG4uc2V0KCdjb21wYXJ0bWVudCcsIGNvbnRhaW5lck5vZGVzLmNvbXBhcnRtZW50KTtcblxuXG5jb25zdCBkcmF3ID0gZnVuY3Rpb24gKHNiZ25DbGFzcywgbm9kZSkge1xuICBsZXQgc2hhcGVGbiA9IHNiZ25Ob2RlU2hhcGVNYXAuZ2V0KHNiZ25DbGFzcyk7XG4gIGlmIChzaGFwZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3NiZ25DbGFzc30gZG9lcyBub3QgaGF2ZSBhIHNoYXBlIGltcGxlbWVudGF0aW9uYCk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlRm4obm9kZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhd1xufTsiLCJjb25zdCBiYXNlU2hhcGVzID0gcmVxdWlyZSgnLi9iYXNlU2hhcGVzLmpzJyk7XG5jb25zdCBzdmdTdHIgPSByZXF1aXJlKCcuLi91dGlsL3N2Zy5qcycpO1xuXG5jb25zdCBwcm9jZXNzTm9kZXMgPSB7XG5cbiAgcHJvY2VzcyAobm9kZSkge1xuICAgIGNvbnN0IG53ID0gbm9kZS53aWR0aCgpO1xuICAgIGNvbnN0IG5oID0gbm9kZS5oZWlnaHQoKTtcblxuICAgIGNvbnN0IGxpbmVTdHlsZSA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMScpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBjb25zdCBzcXVhcmVTdHlsZSA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBjb25zdCBsaW5lID0gYmFzZVNoYXBlcy5saW5lKDAsIG5oIC8gMiwgbncsIG5oIC8gMiwgbGluZVN0eWxlKTtcblxuICAgIGNvbnN0IHByb2Nlc3NTdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5zcXVhcmUoMCwgMCwgTWF0aC5tYXgobncsIG5oKSwgc3F1YXJlU3R5bGUpfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihwcm9jZXNzU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgYXNzb2NpYXRpb24gKG5vZGUpIHtcbiAgICBjb25zdCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBjb25zdCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgICBjb25zdCBjZW50ZXJYID0gbncgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBuaCAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gKE1hdGgubWluKG53LCBuaCkgLSAyKSAvIDI7XG5cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMicpXG4gICAgLnNldCgnZmlsbCcsICcjNkE2QTZBJylcbiAgICAuc2V0KCdmaWxsLW9wYWNpdHknLCAnMCcpO1xuXG5cbiAgICBjb25zdCBsaW5lID0gYmFzZVNoYXBlcy5saW5lKDAsIG5oIC8gMiwgbncsIG5oIC8gMiwgc3R5bGVNYXApO1xuXG4gICAgY29uc3QgYXNzb2NpYXRpb25TdmcgPVxuICAgIGBcbiAgICAgICR7YmFzZVNoYXBlcy5jaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBzdHlsZU1hcCl9XG4gICAgYDtcbiAgICByZXR1cm4gc3ZnU3RyKGFzc29jaWF0aW9uU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH0sXG5cbiAgZGlzc29jaWF0aW9uIChub2RlKSB7XG4gICAgY29uc3QgbncgPSBub2RlLndpZHRoKCk7XG4gICAgY29uc3QgbmggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgY29uc3QgY2VudGVyWCA9IG5vZGUud2lkdGgoKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IG5vZGUuaGVpZ2h0KCkgLyAyO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gKE1hdGgubWluKG53LCBuaCkgLSAyKSAvIDI7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSAoTWF0aC5taW4obncsIG5oKSAtIDIpIC8gMztcblxuICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpXG4gICAgLnNldCgnc3Ryb2tlJywgJyM2QTZBNkEnKVxuICAgIC5zZXQoJ3N0cm9rZS13aWR0aCcsICcyJylcbiAgICAuc2V0KCdmaWxsJywgJ25vbmUnKTtcblxuICAgIGNvbnN0IGRpc3NvY2lhdGlvblN2ZyA9XG4gICAgYFxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3R5bGVNYXApfVxuICAgICAgJHtiYXNlU2hhcGVzLmNpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgc3R5bGVNYXApfVxuICAgIGA7XG4gICAgcmV0dXJuIHN2Z1N0cihkaXNzb2NpYXRpb25TdmcsIG53LCBuaCwgMCwgMCwgbncsIG5oKTtcbiAgfSxcblxuICBwaGVub3R5cGUgKG5vZGUpIHtcbiAgICBjb25zdCBudyA9IG5vZGUud2lkdGgoKTtcbiAgICBjb25zdCBuaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKVxuICAgIC5zZXQoJ3N0cm9rZScsICcjNkE2QTZBJylcbiAgICAuc2V0KCdzdHJva2Utd2lkdGgnLCAnMycpXG4gICAgLnNldCgnZmlsbCcsICdub25lJyk7XG5cbiAgICBsZXQgcGhlbm90eXBlU3ZnID1cbiAgICBgXG4gICAgICAke2Jhc2VTaGFwZXMuaGV4YWdvbihudywgbmgsIHN0eWxlTWFwKX1cbiAgICBgO1xuICAgIHJldHVybiBzdmdTdHIocGhlbm90eXBlU3ZnLCBudywgbmgsIDAsIDAsIG53LCBuaCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc05vZGVzOyIsImNvbnN0IGVsZW1lbnRTdHlsZSA9IHJlcXVpcmUoJy4vZWxlbWVudC5qcycpO1xuY29uc3Qgc2JnblNoYXBlcyA9IHJlcXVpcmUoJy4vZ2x5cGgnKTtcblxuLy8gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBjeXRvc2NhcGUgc3R5bGUgc2hlZXQgZnJvbSBhIGdpdmVuXG4vLyBjeXRvc2NhcGUgaW5zdGFuY2VcbnZhciBzYmduU3R5bGVTaGVldCA9IGZ1bmN0aW9uIChjeXRvc2NhcGUpIHtcblxuICByZXR1cm4gY3l0b3NjYXBlLnN0eWxlc2hlZXQoKVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnY29udGVudCc6IChub2RlKSA9PiBlbGVtZW50U3R5bGUuc2JnbkNvbnRlbnQobm9kZSksXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6IChub2RlKSA9PiBlbGVtZW50U3R5bGUubGFiZWxUZXh0U2l6ZShub2RlKSxcbiAgICAgICAgICAndGV4dC12YWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMS41LFxuICAgICAgICAgICdib3JkZXItY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2Y2ZjZmNicsXG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDAuNSxcbiAgICAgICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3RleHQtd3JhcCc6ICd3cmFwJyxcbiAgICAgICAgICAndGV4dC1tYXgtd2lkdGgnOiAxMDAsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzc10nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUnOiAobm9kZSkgPT4gZWxlbWVudFN0eWxlLnNiZ25TaGFwZShub2RlKVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJwcm9jZXNzXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUuZGF0YSgnY2xhc3MnKSwgbm9kZSksXG4gICAgICAgICAgJ3NoYXBlJzogJ3NxdWFyZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJ1bmNlcnRhaW4gcHJvY2Vzc1wiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdzaGFwZSc6ICdzcXVhcmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwib21pdHRlZCBwcm9jZXNzXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUuZGF0YSgnY2xhc3MnKSwgbm9kZSksXG4gICAgICAgICAgJ3BhZGRpbmcnOiAobm9kZSkgPT4gTWF0aC5tYXgobm9kZS53aWR0aCgpLCBub2RlLmhlaWdodCgpKSAqIDAuMSxcbiAgICAgICAgICAnc2hhcGUnOiAnc3F1YXJlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cImFzc29jaWF0aW9uXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUuZGF0YSgnY2xhc3MnKSwgbm9kZSksXG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJkaXNzb2NpYXRpb25cIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUuZGF0YSgnY2xhc3MnKSwgbm9kZSksXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cInBoZW5vdHlwZVwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzaGFwZSc6ICdoZXhhZ29uJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBzYmduU2hhcGVzLmRyYXcobm9kZS5kYXRhKCdjbGFzcycpLCBub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwic291cmNlIGFuZCBzaW5rXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0wLjg2LCAwLjUsIC0wLjc1LCAwLjY1LCAtMSwgMC45NSwgLTAuOTUsIDEsIC0wLjY1LCAwLjc1LCAtMC41LCAwLjg2LCAwLCAxLCAwLjUsIDAuODYsIDAuNzEsIDAuNzEsIDAuODYsIDAuNSwgMSwgMCwgMC44NiwgLTAuNSwgMC43NSwgLTAuNjUsIDEsIC0wLjk1LCAwLjk1LCAtMSwgMC42NSwgLTAuNzUsIDAuNSwgLTAuODYsIDAsIC0xLCAtMC41LCAtMC44NiwgLTAuNzEsIC0wLjcxLCAtMC44NiwgLTAuNSwgLTEsIDAnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJudWNsZWljIGFjaWQgZmVhdHVyZVwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJwZXJ0dXJiaW5nIGFnZW50XCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAtMC41LCAwLCAgLTEsIDEsICAgMSwgMSwgICAwLjUsIDAsIDEsIC0xJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBzYmduU2hhcGVzLmRyYXcobm9kZS5kYXRhKCdjbGFzcycpLCBub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwibWFjcm9tb2xlY3VsZVwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJzaW1wbGUgY2hlbWljYWxcIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAobm9kZSkgPT4gc2JnblNoYXBlcy5kcmF3KG5vZGUuZGF0YSgnY2xhc3MnKSwgbm9kZSksXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdib3JkZXItd2lkdGgnOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZVtjbGFzcz1cInVuc3BlY2lmaWVkIGVudGl0eVwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChub2RlKSA9PiBzYmduU2hhcGVzLmRyYXcobm9kZS5kYXRhKCdjbGFzcycpLCBub2RlKSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwiY29tcGxleFwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdwYWRkaW5nJzogKG5vZGUpID0+IE1hdGgubWluKG5vZGUuaGVpZ2h0KCksIG5vZGUud2lkdGgoKSkgKiAuMDU1LFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAuMixcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTEwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzExMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgICAgJ3RleHQtdmFsaWduJzogJ2JvdHRvbScsXG4gICAgICAgICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgJ21pbi1oZWlnaHQnOiAobm9kZSkgPT4gbm9kZS53aWR0aCgpICogLjc1LFxuICAgICAgICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogJzUwJScsXG4gICAgICAgICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAnNTAlJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbY2xhc3M9XCJjb21wYXJ0bWVudFwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogKG5vZGUpID0+IHNiZ25TaGFwZXMuZHJhdyhub2RlLmRhdGEoJ2NsYXNzJyksIG5vZGUpLFxuICAgICAgICAgICdwYWRkaW5nJzogKG5vZGUpID0+IE1hdGgubWF4KG5vZGUuaGVpZ2h0KCksIG5vZGUud2lkdGgoKSkgKiAuMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnMTEwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJzExMCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IC4yLFxuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICdib3R0b20nLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdtaW4taGVpZ2h0JzogMTAwLFxuICAgICAgICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogJzUwJScsXG4gICAgICAgICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAnNTAlJyxcbiAgICAgICAgICAnbWluLXdpZHRoJzogMTc1LFxuICAgICAgICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6ICc1MCUnLFxuICAgICAgICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogJzUwJSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwidGFnXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAwLjI1LCAtMSwgICAxLCAwLCAgICAwLjI1LCAxLCAgICAtMSwgMSdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlW2NsYXNzPVwiYXNzb2NpYXRpb25cIl0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjNkI2QjZCJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGVbYmJveF1bY2xhc3NdW2NsYXNzIT1cImNvbXBsZXhcIl1bY2xhc3MhPVwiY29tcGFydG1lbnRcIl1bY2xhc3MhPVwic3VibWFwXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3dpZHRoJzogJ2RhdGEoYmJveC53KScsXG4gICAgICAgICAgJ2hlaWdodCc6ICdkYXRhKGJib3guaCknXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZTpzZWxlY3RlZCcpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ25vZGU6YWN0aXZlJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDAuNywgJ292ZXJsYXktY29sb3InOiAnI2Q2NzYxNCcsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6ICcxNCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1maWxsJzogJ2hvbGxvdycsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1maWxsJzogJ2hvbGxvdycsXG4gICAgICAgICAgJ3dpZHRoJzogMS41LFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzU1NScsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjNTU1JyxcbiAgICAgICAgICAndGV4dC1ib3JkZXItY29sb3InOiAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJyNkNjc2MTQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVkZ2UuY3NzKCdsaW5lLWNvbG9yJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnY29sb3InOiAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJyNkNjc2MTQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVkZ2UuY3NzKCdsaW5lLWNvbG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2U6c2VsZWN0ZWQnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnbGluZS1jb2xvcic6ICcjZDY3NjE0JyxcbiAgICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnI2Q2NzYxNCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlOmFjdGl2ZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjcsICdvdmVybGF5LWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICdvdmVybGF5LXBhZGRpbmcnOiAnOCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NhcmRpbmFsaXR5ID4gMF0nKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAndGV4dC1yb3RhdGlvbic6ICdhdXRvcm90YXRlJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAnMScsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogJzEnLFxuICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnd2hpdGUnLFxuICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6ICcxJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3M9XCJjb25zdW1wdGlvblwiXVtjYXJkaW5hbGl0eSA+IDBdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3NvdXJjZS1sYWJlbCc6IChlZGdlKSA9PiAnJyArIGVkZ2UuZGF0YSgnY2FyZGluYWxpdHknKSxcbiAgICAgICAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAnLTEwJyxcbiAgICAgICAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogKGVkZ2UpID0+IGVsZW1lbnRTdHlsZS5jYXJkaW5hbGl0eURpc3RhbmNlKGVkZ2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignZWRnZVtjbGFzcz1cInByb2R1Y3Rpb25cIl1bY2FyZGluYWxpdHkgPiAwXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0YXJnZXQtbGFiZWwnOiAoZWRnZSkgPT4gJycgKyBlZGdlLmRhdGEoJ2NhcmRpbmFsaXR5JyksXG4gICAgICAgICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogJy0xMCcsXG4gICAgICAgICAgJ3RhcmdldC10ZXh0LW9mZnNldCc6IChlZGdlKSA9PiBlbGVtZW50U3R5bGUuY2FyZGluYWxpdHlEaXN0YW5jZShlZGdlKVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3NdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1zaGFwZSc6IChlZGdlKSA9PiBlbGVtZW50U3R5bGUuc2JnbkFycm93U2hhcGUoZWRnZSksXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1zaGFwZSc6ICdub25lJ1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2VbY2xhc3M9XCJpbmhpYml0aW9uXCJdJylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1maWxsJzogJ2ZpbGxlZCdcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdG9yKCdlZGdlW2NsYXNzPVwicHJvZHVjdGlvblwiXScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignY29yZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkNjc2MTQnLFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAnMC4yJywgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNkNjc2MTQnXG4gICAgICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzYmduU3R5bGVTaGVldDtcbiIsImNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuY29uc3Qgc3ZnID0gKHN2Z1N0ciwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgdmJYID0gMCwgdmJZID0gMCwgdmJXaWR0aCA9IDEwMCwgdmJIZWlnaHQgPSAxMDApID0+IHtcbiAgbGV0IHN2Z1RleHQgPVxuICBgXG4gICAgPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JyR7d2lkdGh9JyBoZWlnaHQ9JyR7aGVpZ2h0fScgdmlld0JveD0nJHt2Ylh9ICR7dmJZfSAke3ZiV2lkdGh9ICR7dmJIZWlnaHR9Jz5cbiAgICAke3N2Z1N0cn1cbiAgICA8L3N2Zz5cbiAgYDtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnVGV4dCwgJ3RleHQveG1sJykuZG9jdW1lbnRFbGVtZW50O1xufTtcblxuY29uc3Qgc3ZnYjY0U3RyID0gKHN2Z1RleHQsIHZpZXdQb3J0V2lkdGgsIHZpZXdQb3J0SGVpZ2h0LCB2aWV3Qm94WCwgdmlld0JveFksIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCkgPT4ge1xuICBsZXQgc3ZnRWwgPSBzdmcoc3ZnVGV4dCwgdmlld1BvcnRXaWR0aCwgdmlld1BvcnRIZWlnaHQsIHZpZXdCb3hYLCB2aWV3Qm94WSwgdmlld0JveFdpZHRoLCB2aWV3Qm94SGVpZ2h0KTtcbiAgbGV0IGI2NERhdGEgPSBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2Eoc3ZnRWwub3V0ZXJIVE1MKX1gO1xuXG4gIHJldHVybiBiNjREYXRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdmdiNjRTdHI7Il19
